Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"48420900","1","64570545","","2018-01-24 11:03:27","","10","3177","<p>I have to test a function that uses the <strong>fromEvent</strong> observable function. 
Before the upgrade to 'lettable' operators, I was just doing this: </p>

<pre><code>spyOn(Observable, 'fromEvent').and.callFake(mockFromEventFunction)
</code></pre>

<p>But now, Rxjs have changed, and <strong>Observable.fromEvent</strong> is just a function named <strong>fromEvent</strong>, that is imported like this: (and used the same way)</p>

<pre><code>import { fromEvent } from 'rxjs/observable/fromEvent';
</code></pre>

<p>My question is, how I can mock that function with Jasmine spy utilities without knowing it's parent context?</p>

<p>I advise that this doesn't work:</p>

<pre><code>import * as FromEventContext from 'rxjs/observable/fromEvent';
...
spyOn(FromEventContext , 'fromEvent').and.callFake(mockFromEventFunction)
</code></pre>

<p>Now I have a workaround wrapping that fromEvent in one Object which I know the context. But I am wondering how I can solve this cleanly.</p>

<p>Thanks in advance.</p>
","6099651","","6099651","","2018-05-25 12:48:48","2020-10-28 10:04:44","How can I mock fromEvent function from RXJS 5.5.6?","<angular><unit-testing><jasmine><rxjs5><rxjs6>","3","3","3","","","CC BY-SA 3.0"
"49840152","1","49840448","","2018-04-15 08:49:31","","173","199924","<p><a href=""https://i.stack.imgur.com/BAqe4.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/BAqe4.png"" alt=""code""></a></p>

<p><a href=""https://i.stack.imgur.com/XLYOx.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/XLYOx.png"" alt=""error info""></a></p>

<p><strong>Typescript code:</strong></p>

<pre><code>import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { of } from 'rxjs/observable/of';
import { Hero } from './hero';
import { HEROES } from './mock-heroes';

@Injectable({
  providedIn: 'root'
})
export class HeroService {

  constructor() { }

  getHeroes(): Observable&lt;Hero[]&gt; {
    return of(HEROES);
  }

}
</code></pre>

<p><strong>error info:</strong></p>

<blockquote>
  <p>error TS2307: Cannot find module 'rxjs-compat/Observable'.
  node_modules/rxjs/observable/of.d.ts(1,15): error TS2307: Cannot find
  module 'rxjs-compat/observable/of'. src/app/hero.service.ts(2,10):
  error TS2305: Module
  '""F:/angular-tour-of-heroes/node_modules/rxjs/Observable""' has no
  exported member 'Observable'. src/app/hero.service.ts(15,12): error
  TS2304: Cannot find name 'of'.</p>
</blockquote>

<p><strong><code>package.json</code> file with Angular version:</strong></p>

<p><a href=""https://i.stack.imgur.com/58sa4.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/58sa4.png"" alt=""version""></a></p>
","7361800","","8718377","","2019-02-14 09:14:43","2021-06-29 07:53:50","Angular - ""has no exported member 'Observable'""","<angular><typescript><rxjs><angular6><rxjs6>","15","4","37","","","CC BY-SA 4.0"
"50061953","1","50062096","","2018-04-27 12:00:05","","31","18530","<p>In RxJS 6, how do I import a static merge function for merging a list of Observables?</p>

<p>I want to be able to do:</p>

<pre><code>const merged$ = merge(
    obs1$,
    obs2$,
    obs3$
);
</code></pre>

<p>I've tried:</p>

<p><code>import { merge } from 'rxjs/observable/merge';</code> and </p>

<p><code>import { merge } from 'rxjs/operators';</code></p>

<p>but neither seems to give me what I want.</p>
","20489","","10544556","","2020-01-08 11:40:49","2021-06-03 14:24:19","Where is RxJS 6 static merge?","<rxjs><rxjs6>","4","1","3","","","CC BY-SA 3.0"
"50138201","1","50138317","","2018-05-02 15:22:37","","6","11825","<p>I am trying to use <code>mergeMap</code> in <code>rxjs6</code> and i am getting this error:</p>

<p><code>Property 'mergeMap' does not exist on type 'Observable&lt;{}&gt;'</code></p>

<p>I have tried <code>import 'rxjs/add/operator/mergeMap';</code> and it is not working.</p>

<p>What am i doing wrong?</p>

<hr>

<pre><code>import {from, Observable} from 'rxjs';

export class Test {

    public doSomething(): Observable&lt;any&gt; {
        return from(...).mergeMap();
    }

}
</code></pre>
","427763","","","","","2019-01-17 09:29:24","mergeMap does not exist on type observable","<typescript><rxjs><reactivex><rxjs6>","4","0","2","","","CC BY-SA 4.0"
"50184538","1","50184607","","2018-05-05 00:17:34","","2","2570","<p>I'm thoroughly confused about the new RxJS 6 and compatibility package. Currently I have these installed (for Angular 6):</p>

<pre><code>""rxjs"": ""^6.1.0"",
""rxjs-compat"": ""^6.1.0"",
</code></pre>

<p>I have been previously using <a href=""https://www.learnrxjs.io/operators/transformation/switchmap.html"" rel=""nofollow noreferrer"">this signature</a> for <code>switchMap</code> (in RxJS5):</p>

<pre><code>switchMap(
 project: function: Observable, 
 resultSelector: function(outerValue, innerValue, outerIndex, innerIndex): any): Observable
</code></pre>

<p>But when updating to version 6 only this overload is available (without the <code>resultSelector</code> parameter):</p>

<pre><code>export declare function switchMap&lt;T, R&gt;(this: Observable&lt;T&gt;, 
       project: (value: T, index: number) =&gt; ObservableInput&lt;R&gt;): Observable&lt;R&gt;;
</code></pre>

<p>I'm importing it with </p>

<pre><code>import { switchMap } from 'rxjs/operators';
</code></pre>

<p>How can I get access to this overload?</p>

<p>Also I tried to look at <code>\node_modules\rxjs\operators\switchMap.d.ts</code> to see what signatures were in there but the contents of this file is :</p>

<pre><code> export * from 'rxjs-compat/operators/switchMap';
</code></pre>

<p>So it looks like the RxJS main package references the compatibility package? How does that make sense? Does the compatibility package actually modify RxJS - or has my package been corrupted - all the files show 1985 date stamps too!</p>

<p>Like I said I'm very confused! What's going on?</p>
","16940","","","","","2018-05-05 00:32:48","Missing `switchMap` and `flatMap` overloads containing 'resultSelector' in RxJS6","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50200859","1","50200915","","2018-05-06 14:35:49","","22","32529","<p>I want to update my rxjs code to 6 got I don't get it.</p>

<p>Before I had the below that wouth poll for new data every 5 seconds:</p>

<pre><code>import { Observable, interval } from 'rxjs';
import { switchMap, map } from 'rxjs/operators';

var result = interval(5000).switchMap(() =&gt; this._authHttp.get(url)).map(res =&gt; res.json().results);
</code></pre>

<p>Now...of course, it's broken and the documentation leaves me nowhere to go.</p>

<p>How do I write the above to conform to rxjs 6?</p>

<p>Thanks</p>
","1203556","","","","","2018-08-24 06:50:51","I dont get rxjs 6 with angular 6 with interval, switchMap, and map","<angular><rxjs><rxjs6>","2","1","5","","","CC BY-SA 4.0"
"50209119","1","","","2018-05-07 07:30:01","","46","43110","<p>After upgrading to Angular 6.0 and Rxjs to 6.0 I receive the following compilation error:</p>

<p><code>Property 'do' does not exist on type 'Observable'.</code></p>

<p>Here is the code:</p>

<pre><code>import { Observable, of } from 'rxjs';
import 'rxjs/add/operator/do';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/catch';
import { IProduct } from './product';

@Injectable()
export class ProductService { 
    constructor(
        private product: IProduct)
    {         
    }

    getProduct = () =&gt; { 
        return product.products
            // error on next line
            .do(data =&gt; console.log('All:' + JSON.stringify(data)))
            .catch(this.handleError);
    }

    private handleError(err: HttpErrorResponse) { 
        console.log(err.message);
        return Observable.throw(err.message);        
    }
}
</code></pre>

<p>Any idea?</p>
","9685781","","578411","","2018-12-19 11:19:04","2020-08-17 17:11:58","Property 'do' does not exist on type 'Observable<IProduct[]>'","<angular><rxjs6>","5","2","10","","","CC BY-SA 4.0"
"50213569","1","50301000","","2018-05-07 11:51:42","","1","920","<p>I'm having an issue after updating libraries to new Angular 6 and RxJS 6.</p>

<p>I have <code>RouteService</code> class which is working as service. It uses <code>HttpClient</code> to get data from remote API. After update I'm getting some weird error when I try to compile project.</p>

<p>Here's my service class:</p>

<pre><code>import {Injectable} from '@angular/core';
import {HttpClient} from ""@angular/common/http"";
import {Observable} from ""rxjs/Rx"";
import {catchError} from 'rxjs/operators';

export interface Route {
    name:string;
    route_id:number;
    created_at:Date;
}

@Injectable()
export class RouteService {
    constructor(private http:HttpClient) {}

    getRoutesList():Observable&lt;Route[]&gt; {
        return this.http.get&lt;Route[]&gt;(`http://localhost:8090/api/routes`)
        .pipe(catchError(ServiceUtil.handleError));
    }
}
</code></pre>

<p>Here's handleError method:</p>

<pre><code>import {HttpErrorResponse} from '@angular/common/http';
import {ErrorObservable} from 'rxjs/observable/ErrorObservable';

export module ServiceUtil {
    export function handleError(error:HttpErrorResponse) {
        if (error.error instanceof ErrorEvent)
        console.error('An error occurred:', error.error.message);
        else 
        console.error('An error occurred:', JSON.stringify(error.error));    
        return new ErrorObservable(error.error);
    }
}
</code></pre>

<p>After <code>ng serve</code> I'm getting error:</p>

<pre><code>ERROR in src/app/service/route-service/route.service.ts(21,5): error TS2322: Type 'Observable&lt;{} | Route[]&gt;' is not assignable to type 'Observable&lt;Route[]&gt;'.
Type '{} | Route[]' is not assignable to type 'Route[]'.
    Type '{}' is not assignable to type 'Route[]'.
    Property 'includes' is missing in type '{}'.

Failed to compile.
</code></pre>

<p>What am I doing wrong? Is there something wrong with my code that causes error in new versions but was working in old one? Or something changed?</p>
","3626048","","","","","2018-05-11 22:23:52","Compile error after update Angular and RxJS 5 to 6","<angular><typescript><rxjs><angular6><rxjs6>","3","2","","","","CC BY-SA 4.0"
"50218784","1","50219421","","2018-05-07 16:36:15","","7","8493","<p>What is the correct expression and import for <code>Observable.of([]);</code>. </p>

<p><code>import { of } from 'rxjs';</code> does not work for me.</p>
","5798225","","13860","","2018-06-11 13:27:13","2019-04-07 17:40:56","How to get ""Observable.of([]);"" to work?","<angular><typescript><rxjs><rxjs5><rxjs6>","2","7","","","","CC BY-SA 4.0"
"50220854","1","50245593","","2018-05-07 19:05:01","","63","44738","<pre><code> import { Observable, of } from ""rxjs"";

// And if I try to return like this
  return Observable.of(this.purposes);
</code></pre>

<p>I am getting an error stating, Property 'of' does not exist on type 'typeof Observable'</p>
","7962294","","5490782","","2018-08-27 09:43:20","2019-05-13 17:05:54","Could not use Observable.of in RxJs 6 and Angular 6","<angular><rxjs6><angular-observable>","3","2","9","","","CC BY-SA 4.0"
"50223248","1","","","2018-05-07 22:16:38","","5","606","<p>It's a good practice to create my own Observable extended classes? i want to implement my own Single and Completable classes for the sake of know the amount or absence of data than and observable can return and i want it as a class because i use <code>reclect-metadata</code> and i use <code>design:returntype</code> in my decorators so i need a classes not an alias (because using alias the type returned will be always Object and not the original class constructor).</p>

<p>The idea is: for Single observables use the single operator and for Completable observables use the ignoreElements operators but without a class in Typescript for Singles i don't know the amount of data by only reading in the code Observable, that observable can return one or many or none and i want a Single for particular cases, this is what i want:</p>

<pre><code>// some methods in some class
loginUser(userName: string, password: string): Single&lt;User&gt;
saveUser(user: User): Completable
</code></pre>

<p>For my this is more readable (because i use RxJava 2 in my Android projects) and with that i know that expect or not, without that i need to do:</p>

<pre><code>loginUser(userName: string, password: string): Observable&lt;User&gt; // if i chain this with other observables i don't know how much users this will return
saveUser(user: User): Observable&lt;void&gt; // simply ugly
</code></pre>

<p>That is not good for my eyes you know? so i want to create that classes for a better read of my code and better implementation.</p>
","813353","","","","","2021-05-09 22:11:41","Create classes for Single, Maybe and Completable in RxJS 6","<typescript><rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50229130","1","50229268","","2018-05-08 08:22:45","","19","22228","<p>I tried importing rxjs timer on my angular 6 project like</p>

<pre><code>import { timer } from 'rxjs/observable/timer';
</code></pre>

<p>I also tried it like,</p>

<pre><code>Rx.Observable.timer(200, 100)
</code></pre>

<p>They don't work </p>

<p>Here is the code on <a href=""https://stackblitz.com/edit/angular-q8rehy?file=src/app/hello.component.ts"" rel=""noreferrer"">plunker</a></p>
","4646531","","5377805","","2020-09-30 21:35:11","2020-09-30 21:42:28","How to import rxjs timer in angular 6?","<angular><timer><rxjs6>","4","2","6","","","CC BY-SA 4.0"
"50245202","1","50246811","","2018-05-09 03:42:45","","18","15961","<p>cdSo I'm trying to migrate some of my Angular 5 code to 6, and I understand most of the changes required for rxjs to work using the .pipe() operator. It works as you would expect for 'pipable' operations.</p>

<p>However, the behavior of <code>catchError()</code> is different than the <code>.catch()</code> operator. Prior to rxjs 6 I used the <code>.catch()</code> operator to transform the error input into a a consistent error object that can then be caught in the `.subscribe().</p>

<pre><code>getAlbums(): Observable&lt;Album[]&gt; {
     return this.httpClient.get&lt;Album[]&gt;(this.config.urls.url(""albums""))
           .map(albumList =&gt; this.albumList = albumList)
           .catch(new ErrorInfo().parseObservableResponseError);            
    }
</code></pre>

<p><code>new ErrorInfo().parseObservableResponseError</code> is a function that takes a error object as input and parses the input error into a simpler error object with a normalized object. Catch returns <code>Observable&lt;any&gt;</code>:</p>

<pre><code>parseObservableResponseError(response): Observable&lt;any&gt; {
    let err = new ErrorInfo();
    ...
    return Observable.throw(err);        
}
</code></pre>

<p>This worked great for easily handling errors up rxjs5 - errors basically are captured as part of the pipeline and then throw a well known error structure that can be captured <code>.subscribe()</code> error function.</p>

<p>Moving that same code to rxjs 6 however and using <code>.pipe()</code> I am trying to do the following:</p>

<pre><code>getAlbums(): Observable&lt;Album[]&gt; {
    return this.httpClient.get&lt;Album[]&gt;(this.config.urls.url(""albums""))
                .pipe(
                    map(albumList =&gt; this.albumList = albumList),
                    catchError(new ErrorInfo().parseObservableResponseError)                        
                );           
}
</code></pre>

<p>However this doesn't work because catchError now returns a result of <code>Observable&lt;any&gt;</code> into the pipeline, which is not what I want here. In essence I just want to re-throw any errors as I did before.</p>

<blockquote>
  <p>error TS2322: Type 'Observable&lt;{} | Album[]>' is not assignable to type 'Observable'</p>
</blockquote>

<p>How do simulate the old  operator <code>.catch()</code>behavior?</p>

<p><strong>Update:</strong></p>

<p>After mucking around with this a bit more, the code as shown just started working without giving me a build error. Honestly I have no idea why it failed with the error message before, but is working now. The suggestion by @cartant in the comments is an explicit way to specify the result and that works as well.</p>
","11197","","11197","","2018-05-09 20:13:29","2018-05-09 20:13:29","How do I use catchError() and still return a typed Observable with rxJs 6.0?","<angular><typescript><typescript-typings><rxjs6>","1","3","5","","","CC BY-SA 4.0"
"50273512","1","51653254","","2018-05-10 12:59:00","","1","1200","<p>Hi I appreciate these are a pain. </p>

<p>After updating Angular to version 6 and rxjs to version 6 we are getting a lot of browser errors that the system is unable to instantiate a number of packages. </p>

<p>We use a combination of node_modules and systemjs.config.server.js
without trying to start an argument on whether one is better than the other, If there are any improvements please let me know.</p>

<p><strong>package.json</strong> </p>

<pre><code> {
      ""version"": ""1.0.0"",
      ""name"": ""infrastructure-annual-reporting"",
      ""private"": true,
      ""dependencies"": {
        ""@angular/animations"": ""^6.0.0"",
        ""@angular/cdk"": ""^6.0.0"",
        ""@angular/common"": ""^6.0.0"",
        ""@angular/compiler"": ""^6.0.0"",
        ""@angular/core"": ""^6.0.0"",
        ""@angular/forms"": ""^6.0.0"",
        ""@angular/http"": ""^6.0.0"",
        ""@angular/material"": ""^6.0.1"",
        ""@angular/platform-browser"": ""^6.0.0"",
        ""@angular/platform-browser-dynamic"": ""^6.0.0"",
        ""@angular/router"": ""^6.0.0"",
        ""angular-date-value-accessor"": ""^0.0.2"",
        ""bootstrap"": ""^3.3.7"",
        ""core-js"": ""^2.5.6"",
        ""hammerjs"": ""^2.0.8"",
        ""ng2-bs3-modal"": ""^0.13.0"",
        ""ngx-accordion"": ""^0.0.17"",
        ""nodemailer"": ""^4.6.4"",
        ""rxjs"": ""^6.1.0"",
        ""rxjs-compat"": ""^6.1.0"",
        ""rxjs-tslint"": ""^0.1.3"",
        ""socks"": ""^2.2.0"",
        ""systemjs"": ""^0.21.3"",
        ""web-animations-js"": ""^2.3.1"",
        ""zone.js"": ""^0.8.26""
      },
      ""devDependencies"": {
        ""@angular/cli"": ""^6.0.0"",
        ""@angular/language-service"": ""^6.0.0"",
        ""@types/hammerjs"": ""^2.0.35"",
        ""@types/jasmine"": ""^2.8.7"",
        ""@types/node"": ""^10.0.6"",
        ""codelyzer"": ""^4.3.0"",
        ""jasmine"": ""^3.1.0"",
        ""karma"": ""^2.0.2"",
        ""lite-server"": ""^2.3.0"",
        ""lodash"": ""^4.17.10"",
        ""protractor"": ""^5.3.1"",
        ""ts-node"": ""^6.0.3"",
        ""tslint"": ""^5.10.0"",
        ""typescript"": ""^2.8.3""
      },
      ""keywords"": [],
      ""license"": ""MIT"",
      ""peerDependencies"": {
        ""@angular/core"": ""&gt;=2.0.0"",
        ""@angular/common"": ""&gt;=2.0.0"",
        ""@angular/compiler"": ""&gt;=2.0.0"",
        ""@angular/platform-browser"": ""&gt;=2.0.0"",
        ""@angular/platform-browser-dynamic"": ""&gt;=2.0.0"",
        ""@angular/cdk"": ""6.0.1""
      },
      ""repository"": {},
      ""scripts"": {
        ""build"": ""tsc -p src/"",
        ""build:watch"": ""tsc -p src/ -w"",
        ""build:e2e"": ""tsc -p e2e/"",
        ""serve"": ""lite-server -c=bs-config.json"",
        ""serve:e2e"": ""lite-server -c=bs-config.e2e.json"",
        ""prestart"": ""npm run build"",
        ""start"": ""concurrently \""npm run build:watch\"" \""npm run serve\"""",
        ""pree2e"": ""npm run build:e2e"",
        ""e2e"": ""concurrently \""npm run serve:e2e\"" \""npm run protractor\"" --kill-others --success first"",
        ""preprotractor"": ""webdriver-manager update"",
        ""protractor"": ""protractor protractor.config.js"",
        ""pretest"": ""npm run build"",
        ""test"": ""concurrently \""npm run build:watch\"" \""karma start karma.conf.js\"""",
        ""pretest:once"": ""npm run build"",
        ""test:once"": ""karma start karma.conf.js --single-run"",
        ""lint"": ""tslint ./src/**/*.ts -t verbose""
      }
    }
</code></pre>

<p><strong>systemjs.config.server.js</strong></p>

<pre><code>(function (global) {
    // map tells the System loader where to look for things
    var paths = {
        'npm:': ""https://unpkg.com/""
    };
    var map = {
        'app': ""app"", // 'dist',
        '@angular': ""node_modules/@angular"",
        'angular2-in-memory-web-api': ""node_modules/angular2-in-memory-web-api"",
        'rxjs': ""npm:rxjs"",
        '@angular/platform-browser/animations': ""npm:@angular/platform-browser/bundles/platform-browser-animations.umd.min.js"",
        ""ngx-accordion"": ""npm:ngx-accordion@0.0.17/index.js"",
        '@angular/common/http': ""npm:@angular/common/bundles/common-http.umd.js"",
        '@angular/animations/browser': ""npm:@angular/animations@5.2.10/bundles/animations-browser.umd.js"",
        'ng2-bs3-modal': ""npm:ng2-bs3-modal/bundles/ng2-bs3-modal.umd.js"",
        'hammerjs':""npm:hammerjs/hammer.js"",

        // CDK individual packages
        '@angular/cdk/bidi': ""npm:@angular/cdk/bundles/cdk-bidi.umd.js"",
        '@angular/cdk/platform': ""npm:@angular/cdk/bundles/cdk-platform.umd.js"",
        '@angular/cdk/keycodes': ""npm:@angular/cdk/bundles/cdk-keycodes.umd.js"",
        '@angular/cdk/collections': ""npm:@angular/cdk/bundles/cdk-collections.umd.js"",
        '@angular/cdk/portal': ""npm:@angular/cdk/bundles/cdk-portal.umd.js"",
        '@angular/cdk/coercion': ""npm:@angular/cdk/bundles/cdk-coercion.umd.js"",
        '@angular/cdk/overlay': ""npm:@angular/cdk/bundles/cdk-overlay.umd.js"",
        '@angular/cdk/accordion': ""npm:@angular/cdk/bundles/cdk-accordion.umd.js"",
        '@angular/cdk/observers': ""npm:@angular/cdk/bundles/cdk-observers.umd.js"",
        '@angular/cdk/layout': ""npm:@angular/cdk/bundles/cdk-layout.umd.js"",
        '@angular/cdk/scrolling': ""npm:@angular/cdk/bundles/cdk-scrolling.umd.js"",
        '@angular/cdk/table': ""npm:@angular/cdk/bundles/cdk-table.umd.js"",
        '@angular/cdk/stepper': ""npm:@angular/cdk/bundles/cdk-stepper.umd.js"",
        '@angular/cdk/a11y': ""npm:@angular/cdk/bundles/cdk-a11y.umd.js"",
        '@angular/cdk/tree' : ""node_modules/@angular/cdk@6.0.1/tree"",
        'tslib': ""npm:tslib/tslib.js"",
        'rxjs/operators' : ""npm:rxjs/operators/""
    };
    // packages tells the System loader how to load when no filename and/or no extension
    var packages = {
        'app': { main: ""main.js"", defaultExtension: ""js"" },
        'rxjs': { defaultExtension: ""js"" },
        'rxjs-compact': { defaultExtension: ""js"" },
        'angular2-in-memory-web-api': { main: ""index.js"", defaultExtension: ""js"" }
    };
    var ngPackageNames = [
        ""animations"",
        ""common"",
        ""compiler"",
        ""core"",
        ""forms"",
        ""http"",
        ""material"",
        ""platform-browser"",
        ""platform-browser-dynamic"",
        ""router""

    ];
    // Individual files (~300 requests):
    function packIndex(pkgName) {
        packages[""@angular/"" + pkgName] = { main: ""index.js"", defaultExtension: ""js"" };
    }
    // Bundled (~40 requests):
    function packUmd(pkgName) {
        packages[""@angular/"" + pkgName] = { main: ""bundles/"" + pkgName + "".umd.js"", defaultExtension: ""js"" };
    }
    // Most environments should use UMD; some (Karma) need the individual index files
    var setPackageConfig = System.packageWithIndex ? packIndex : packUmd;
    // Add package entries for angular packages
    ngPackageNames.forEach(setPackageConfig);
    var config = {
        paths: paths,
        map: map,
        packages: packages
    };
    System.config(config);
})(this);
</code></pre>

<p>the errors that we are seeing in the browser are </p>

<p><a href=""https://i.stack.imgur.com/FbUpU.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FbUpU.jpg"" alt=""browser error 1""></a>
<a href=""https://i.stack.imgur.com/w1F3x.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/w1F3x.jpg"" alt=""browser error 2""></a></p>
","2739080","","2739080","","2018-05-10 13:04:12","2018-08-02 12:07:18","Angular6 rxjs 6 update","<angular6><rxjs6>","2","3","","","","CC BY-SA 4.0"
"50275159","1","50302819","","2018-05-10 14:22:31","","0","912","<p>I've upgraded to Angular/Rxjs 6 and I've noticed that the ""skip"" operator on Observable is no longer there.  I've not been able to find a suitable substitute, does anyone have any suggestions?
Thanks!</p>
","518043","","","","","2018-06-05 20:22:41","rxjs 6 ""skip"" operator missing","<angular6><rxjs6>","2","0","","","","CC BY-SA 4.0"
"50275834","1","50276301","","2018-05-10 14:56:22","","23","23447","<p>I just want to sort data on an observable of my class type 'Category'.  So Observable &lt; Category[] > I want to sort.</p>

<p>So I upgraded to Angular6 and rxjs6 with it.  One issue that is probably simple Typescript that I do know is how do I just do a 'sort' operation like:</p>

<pre><code>sort((x,y) =&gt; x.description &lt; y.description ? -1 : 1)
</code></pre>

<p>Inside of the new Angular6?  I used to do this in 5</p>

<pre><code>var response = this.http.get&lt;Category[]&gt;(this.endpoint);
        .map((result: Response) =&gt; this.alphabetize(result));


alphabetize = (result: Response) =&gt; this.Categories = result.json()
.sort((x,y) =&gt; x.description &lt; y.description ? -1 : 1)
</code></pre>

<p>And it worked fine.  Now in the HttpCLIENTModule and HttpClient that Angular wants you to use it is simpler:</p>

<pre><code>var data = this.http.get&lt;Category[]&gt;(this.endpoint);
</code></pre>

<p>I just put the magic &lt;(object)> before my endpoint and it does it for me.  Cool.  But I am not seeing how you get inside the object easily to sort from it with Source, Pipe, from, of.  I know it is probably something simple I just don't know the syntax for.</p>
","580428","","","","","2018-05-10 15:20:15","How do you sort an Observable<Item[]> in Angular 6 with rxjs 6?","<typescript><angular6><rxjs6>","1","0","3","","","CC BY-SA 4.0"
"50276165","1","50276374","","2018-05-10 15:12:51","","79","70106","<p>After running the rxjs migration tool using</p>

<blockquote>
  <p>rxjs-5-to-6-migrate -p src/tsconfig.app.json</p>
</blockquote>

<p>I'm now getting a linting error:</p>

<blockquote>
  <p>combineLatest is deprecated: Deprecated in favor of static
  combineLatest.</p>
</blockquote>

<p>Here is my code before running the migration command:</p>

<pre><code>this.store.combineLatest(
        this.store.select(lang.getCurrent),
        this.store.select(lang.getCurrentLocale)
    ).subscribe(([state, currentLang, locale]) =&gt; {
        this._language = session.language === currentLang ? '' : currentLang;
        this._locale = session.locale === locale ? '' : locale;
    });
</code></pre>

<p>My code after running the migration command: (currently presenting a linting error)</p>

<pre><code>import {map, combineLatest} from 'rxjs/operators';
this.store.combineLatest(
        this.store.select(lang.getCurrent),
        this.store.select(lang.getCurrentLocale)
    ).subscribe(([state, currentLang, locale]) =&gt; {
        this._language = session.language === currentLang ? '' : currentLang;
        this._locale = session.locale === locale ? '' : locale;
    });
</code></pre>

<p>The question was asked in this stackoverflow questions, but it was  not specific enough: <a href=""https://stackoverflow.com/questions/50274275/angular-6-ng-lint-duplicate-errors-and-warnings-combinelatest-is-deprecated"">Angular 6 ng lint duplicate errors and warnings, combineLatest is deprecated
</a>.</p>
","3044062","","3345644","","2018-08-17 14:05:32","2021-04-26 13:16:40","combineLatest deprecated in favor of static combineLatest","<rxjs><rxjs6>","4","0","4","","","CC BY-SA 4.0"
"50282107","1","50282569","","2018-05-10 22:00:27","","3","4168","<p>I've spent at least 2 hours trying to get things work with version 6 but no avail. I just cannot get both route params and queryparams.</p>

<p>This is the closest syntax to the older versions but it only logs query params.</p>

<p>What I want to do is wrap this in global routing service so the method call is clean and if any other updates occur I can change in one place.</p>

<pre><code>    import {BehaviorSubject, combineLatest, Observable} from 'rxjs';

constructor(private router: Router, private route: ActivatedRoute)
// body of constructor left out


     // Combine them both into a single observable
    const urlParams: Observable&lt;any&gt; = combineLatest(
        this.route.params,
        this.route.queryParams,
        (params, queryParams) =&gt; ({ ...params, ...queryParams})
    );

    urlParams.subscribe(x =&gt; console.log(x));
</code></pre>

<p>I also noticed that combinedLatest isn't in 'rxjs/operators' for some reason.
Observable.combineLatest doesn't work either. </p>

<p>Thanks.</p>
","2245810","","2245810","","2018-05-10 22:05:42","2019-04-05 08:25:07","Angular/RxJs 6 - combining route params and query params not working anymore","<angular><rxjs6>","3","0","","","","CC BY-SA 4.0"
"50295564","1","50298444","","2018-05-11 15:27:15","","22","23785","<p>I wrote a function that is <code>pipe</code>-able:</p>

<pre><code>HandleHttpBasicError&lt;T&gt;()
{
    return ((source:Observable&lt;T&gt;) =&gt; {
        return source.pipe(
            catchError((err:any) =&gt; {
                let msg = '';
                if(err &amp;&amp; err instanceof HttpErrorResponse)
                {
                    if(err.status == 0)
                        msg += ""The server didn't respond"";
                }
                throw {
                    err,
                    msg
                } as CustomError
            })
        )

    })
}
</code></pre>

<p>I can use this function this way in my <code>HttpService</code>:</p>

<pre><code>checkExist(id:string)
{
    return this.http.head&lt;void&gt;(environment.apiUrl + 'some_url/' + id)
        .pipe(
            HandleHttpBasicError(),
            catchError((err:CustomError) =&gt; {
                if(err.msg)
                    throw err.msg;
                if(err.err.status == HttpStatusCodes.NOT_FOUND)
                    throw(""It doesn't exist."");
                throw(err);
            })

        )
}
</code></pre>

<p>It's working great. When I subscribe to <code>checkExist()</code>, I get a good error message, because <code>HandleHttpBasicError</code> first catches an error and throws it to the service's <code>catchError()</code>, which throwes the error message because it was not <code>null</code>.</p>

<p>This way, it allows me to have a global <code>catchError()</code> which handles error messages that will always be the same. In the future, I will do it in a <code>HttpHandler</code>, but that's not the point here.</p>

<p>Is it ok to chain the errors with the <code>throw</code> keyword?</p>

<p>I tried to return <code>Observable.throwError()</code>, but the browser said </p>

<blockquote>
  <p>Observable.throwError is not a function</p>
</blockquote>

<p>My imports are <code>import {Observable, of, throwError} from 'rxjs';</code>.</p>

<p>Isn't it better to do this:</p>

<pre><code>return ((source:Observable&lt;T&gt;) =&gt; {
        return source.pipe(
            catchError((err:any) =&gt; {
                msg = '';
                ...
                return of({err, msg} as CustomError)
                /* instead of
                throw(err)
                -or-
                return Observable.throwError(err) (which doesn't work)
                */
            })
        )

    })
</code></pre>

<p>?</p>
","7429175","","2756409","","2019-01-03 20:03:45","2019-01-03 20:03:45","How to propagate errors through catchError() properly?","<rxjs><angular-http><rxjs6>","1","0","4","","","CC BY-SA 4.0"
"50299783","1","","","2018-05-11 20:24:50","","11","7933","<p>I have upgraded my Angular 5 app to 6.0.1 and RxJs to 6.1.0.</p>

<p>In one of my services, I have the import below:</p>

<pre><code>import { ErrorObservable } from 'rxjs/observable/ErrorObservable';
</code></pre>

<p>However, I now get the following error:</p>

<blockquote>
  <p>Module '""...node_modules/rxjs/observable/ErrorObservable""' has no exported member 'ErrorObservable'.</p>
</blockquote>

<p>I have search online for how to import this in rxjs6 or if the name </p>

<pre><code>ErrorObservable 
</code></pre>

<p>has changed.</p>

<p>I used this as my guide for the upgrade process:</p>

<p><a href=""https://www.academind.com/learn/javascript/rxjs-6-what-changed/"" rel=""noreferrer"">RxJS 6 Changes - Overview</a></p>

<p>Does anyone know how to resolve this import?</p>
","1672352","","1672352","","2018-05-11 20:31:55","2018-05-11 20:41:30","RXJS6 Upgrade: ErrorObservable has no exported member 'ErrorObservable'","<angular><angular6><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"50303336","1","50303433","","2018-05-12 06:01:33","","1","215","<p>When i use only subscribe-method, it works truthy, but with this code - i don't understand the result.</p>

<pre><code>const Observable = require(""rxjs"").Observable;
let i = 0;
const x = new Observable((o) =&gt; {
    setInterval(() =&gt; o.next(++i), 1000);
});

(async () =&gt; {
    while (true) {
        try {
            console.log(""loop"");
            console.log(""value"", await x.toPromise());
        } catch (e) {
            console.log(e);
        }
    }
})();
x.subscribe((value) =&gt; {
    console.log(""subscribe"", value);
});
</code></pre>

<p>This code result is:</p>

<pre><code>loop
subscribe 2
subscribe 4
subscribe 6
subscribe 8
subscribe 10
subscribe 12
subscribe 14
</code></pre>

<p>What's happened?</p>

<p>It works same with this variant of using toPromise</p>

<pre><code>function a() {
    x.toPromise().then((value) =&gt; {
        console.log(""promise"", value);
        a();
    }).catch((e) =&gt; {
        console.log(""error"", value);
    });
}
a();
</code></pre>
","3551506","","","","","2018-05-12 10:08:23","What the unexpected behavior Observable RxJS with async functions and toPromise?","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50321926","1","50322026","","2018-05-14 00:53:10","","12","4440","<p>I have extension for observable. It was working perfectly fine but now I've updated to angular 6 with typescript 2.7.2. </p>

<pre><code>import { Observable } from 'rxjs/Observable';
import { BaseComponent } from './base-component';
import { Subscription } from 'rxjs/Subscription';
import { Subscribable } from 'rxjs';

declare module 'rxjs/Observable' {
    export interface Observable&lt;T&gt; {
        safeSubscribe&lt;T&gt;(this: Observable&lt;T&gt;, component: BaseComponent,
            next?: (value: T) =&gt; void, error?: (error: T) =&gt; void, complete?: () =&gt; void): Subscription;
    }
}


export function safeSubscribe&lt;T&gt;(this: Observable&lt;T&gt;, component: BaseComponent,
    next?: (value: T) =&gt; void, error?: (error: T) =&gt; void, complete?: () =&gt; void): Subscription {
    let sub = this.subscribe(next, error, complete);
    component.markForSafeDelete(sub);
    return sub;
}

Observable.prototype.safeSubscribe = safeSubscribe;
</code></pre>

<p>And this code is not working</p>

<ol>
<li>'Observable' only refers to a type, but is being used as a value here.</li>
<li>Property 'subscribe' does not exist on type 'Observable'.</li>
</ol>

<p><a href=""https://www.typescriptlang.org/docs/handbook/declaration-merging.html"" rel=""noreferrer"">https://www.typescriptlang.org/docs/handbook/declaration-merging.html</a></p>
","1100248","","1100248","","2018-05-14 01:10:02","2018-05-14 01:13:49","TypeScript module Augmentation","<angular><typescript><rxjs><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"50353164","1","50353265","","2018-05-15 14:46:18","","50","46731","<p>I have finished to update my App to Angular 6 (it was in 5.2 version).</p>

<p>I got an error syntax in :</p>

<pre><code>import { Router, ActivatedRoute, NavigationEnd } from '@angular/router';
import { filter } from 'rxjs/operators';
...
constructor(private router: Router) {}

this.router.events.filter
      (event =&gt; event instanceof NavigationEnd).subscribe((res) =&gt; 
    {
      // DO something
    });
</code></pre>

<blockquote>
  <p>error TS2339: Property 'filter' does not exist on type
  'Observable'.</p>
</blockquote>

<p>what's the right syntax in Angular 6 ?</p>

<p>thanks</p>
","2239841","","5170364","","2018-07-20 10:18:47","2020-10-18 16:22:06","Angular 6 router.events.filter 'filter' does not exist on type 'Observable<Event>'","<angular><typescript><rxjs><angular6><rxjs6>","3","2","8","","","CC BY-SA 4.0"
"50359837","1","50379440","","2018-05-15 22:08:50","","0","804","<p>I'm trying to implement a delete epic with a confirmation dialog.</p>

<p>I came up with this approach. It has the advantage of being easy to test.</p>

<p>My question is, is this a good approach, should I worry about adding <code>takeUntil(action$.ofType(MODAL_NO_CLICKED))</code>?</p>

<p>Please let me know if you can think of a better way to implement this.</p>

<pre class=""lang-js prettyprint-override""><code>    const deleteNotification$ = (id, { ajax }) =&gt; ajax({ url: `api/delete/{id}` });

    // showYesNo is an action to eventually show a dialog using this approach https://stackoverflow.com/a/35641680/235659
    const showYesNo = payload =&gt; ({
        type: SHOW_MODAL,
        modalType: MODAL_TYPE_YES_NO,
        modalProps: { ...payload },
    });

    const deleteNotificationEpic = (action$, store, dependencies) =&gt; {
        let uid = dependencies.uid; // dependencies.uid is added here to allow passing the uid during unit test.

        return merge(
            // Show confirmation dialog.
            action$.pipe(
                ofType(NOTIFICATION_DELETE_REQUEST),
                map(action =&gt; {
                    uid = shortid.generate();

                    return showYesNo({
                        message: 'NOTIFICATION_DELETE_CONFIRMATION',
                        payload: {
                            notificationId: action.notificationId,
                            uid,
                        },
                    })
                }),
            ),

            // Deletes the notification if the user clicks on Yes
            action$.pipe(
                ofType(MODAL_YES_CLICKED),
                filter(({ payload }) =&gt; payload.uid === uid),
                mergeMap(({ payload }) =&gt;
                    deleteNotification$(payload.notificationId, dependencies).pipe(
                        mergeMap(() =&gt; of(deleteNotificationSuccess())),
                        catchError(error =&gt; of(deleteNotificationSuccess(error))),
                    ),
                ),
            ),
        );
    };
</code></pre>

<p>I know I can show the confirmation dialog on the React level and only dispatch the delete action if the user clicks on Yes, but my question is a more general case where I might have some logic (calling the back-end) before deciding to show the confirmation dialog or not.</p>
","235659","","235659","","2018-05-20 19:00:05","2018-05-20 19:00:05","show confirmation dialog using redux-observable","<reactjs><redux-observable><rxjs6>","2","0","","","","CC BY-SA 4.0"
"50371887","1","50374389","","2018-05-16 13:11:14","","7","2961","<p>Angular 6 requires an update to RxJs 6 and with that RxJs update the <code>Observable.publish()</code> function is gone. I found a <code>publish</code> operator in <code>RxJs/operators</code> but I'm having trouble figuring out how to use it.</p>

<p>How could this RxJs 5 code be rewritten to work with RxJs 6?</p>

<p><code>const myConnectableObservable = this.getObservable().publish()</code></p>
","713428","","","","","2019-07-15 08:34:57","RxJs 6: Get ConnectableObservable from Observable","<angular><rxjs><rxjs6>","2","6","","","","CC BY-SA 4.0"
"50373166","1","50374127","","2018-05-16 14:08:44","","1","2093","<p><em>Please see the sample: <a href=""https://stackblitz.com/edit/angular-bvcrcz"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-bvcrcz</a></em></p>

<p>I have <code>&lt;mat-checkbox [ngModel]=""row.IsVerified"" [disabled]=""row.IsVerified"" (ngModelChange)=""setTrue()""&gt;&lt;/mat-checkbox&gt;</code> in my template.</p>

<p>The <code>setTrue</code> method looks like this:
<code>
  setTrue = () =&gt; {
    ObservableOf(67).subscribe(_ =&gt; {
      this.row.IsVerified = true; // This throws a ExpressionChangedAfterItHasBeenCheckedError!!!
    });
  }
</code></p>

<p>What I'm trying to achieve is: clicking the checkbox <strong>should not immediately change the ngModel value</strong>, but instead it should trigger a call to a server (to update the value on the server) and, upon succesful response code, set the <code>ngModel</code> to <code>true</code>. </p>

<p>Setting <code>ngModel</code> should, in turn, disable the checkbox to disallow the user to click it again.</p>

<p>However, I'm getting an error (in the console) saying: <code>ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'ng-untouched: true'. Current value: 'ng-untouched: false'.</code></p>

<p>What should I do to get rid of the error?</p>
","1841545","","","","","2018-05-18 09:24:15","Using disabled, ngModel and ngModelChanged bindings together throws an ExpressionChangedAfterItHasBeenCheckedError","<angular><angular-material2><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50376325","1","","","2018-05-16 16:56:26","","3","850","<p>I am in the middle of migrating my Angular 5 application from using rxjs 5 to rxjs 6. A big part of this is the change from using dot-chaining to using .pipe(). My application is using ngrx, and I am having trouble with Effects. When using rxjs 5, this works.</p>

<pre><code>@Effect() public onSave$: void | Observable&lt;void|{}&gt; =
this.actions.ofType&lt;DashboardGroupsActions.Save&gt;(DashboardGroupsActions.SAVE_DASHBOARD_GROUPS)
  .map((action: DashboardGroupsActions.Save) =&gt; action.payload)
  .switchMap((payload: DashboardGroups) =&gt; {

      return this.api.saveDashboardGroup(payload);
  })
  .catch(() =&gt; {

      return Observable.of();
  });
</code></pre>

<p>Below is what my code looks like after converting the dot-chaining to .pipe(). But now I also get the following error that I can't seem to fix. </p>

<p>""Property 'pipe' does not exist on type '<code>Actions&lt;Action&gt;</code>'""</p>

<pre><code>import { Observable, pipe, of } from 'rxjs';
import { catchError, filter, map, mergeMap, switchMap } from 'rxjs/operators';
import { Action, Store } from '@ngrx/store';
import { Actions, Effect, ofType } from '@ngrx/effects';

@Effect() public onSave$: Observable&lt;{}|Action&gt; = this.actions.pipe(
      ofType&lt;DashboardGroupsActions.Save&gt;(DashboardGroupsActions.SAVE_DASHBOARD_GROUPS),
      map((action: DashboardGroupsActions.Save) =&gt; action.payload),
      switchMap((payload: DashboardGroups) =&gt; {

          return this.api.saveDashboardGroup(payload);
      }),
      catchError(() =&gt; {

          return of({});
      })
  );
</code></pre>

<p>Any help is much appreciated.</p>
","9800971","","9800971","","2018-05-30 17:58:01","2018-05-30 17:58:01","ngrx help for migrating from rxjs 5 to 6","<rxjs5><ngrx-effects><rxjs6>","0","2","","","","CC BY-SA 4.0"
"50382614","1","50382766","","2018-05-17 02:44:38","","13","28713","<p>I make a call to a method called getWorkOrders() in my service file which in turn makes a call to the server to fetch the records.</p>

<p>Here is my service. I am using the new HttpClient.</p>

<pre><code>export class BackendServices {
  private BASE_URL ='http://localhost:3000/backend';
  constructor(private http: HttpClient) {}
  getWorkOrders(){
    return this.http.get(this.BASE_URL + '/getworkorders/');
 }
}
</code></pre>

<p>Component.ts file</p>

<pre><code>private woSubject = new BehaviorSubject&lt;IWorkOrders[]&gt;([]);
    getWorkOrders() {
        this.bs.getWorkOrders()
          .subscribe((data: any) =&gt;
            this.woSubject.next(data),
        );
      }
</code></pre>

<p>From the component getWorkOrders method how do I filter the data from all the records that was fetched from the server. I understand that it is using pipe &amp; the filter rxjs operators, but not sure how to put it together.</p>

<p><a href=""https://i.stack.imgur.com/YcIqd.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/YcIqd.jpg"" alt=""enter image description here""></a></p>
","3826733","","3826733","","2018-05-17 03:39:22","2019-01-11 00:57:07","Angular how do I filter the data from an observable using rxjs pipe","<angular><rxjs6>","1","4","3","","","CC BY-SA 4.0"
"50393781","1","50393863","","2018-05-17 14:17:15","","0","1294","<p>in app.component I need to perform an action based on the ActivatedRoute. 
using: Angular6, rxjs6 (with it's new syntax)</p>

<pre><code>import {Observable} from 'rxjs';
import {map} from 'rxjs/operators';

....

constructor (private route:ActivatedRoute){
  const url: Observable&lt;string&gt; =route.url.pipe(map(segments=&gt;segments.join('')));

}
</code></pre>

<p>the intent is to show/hide something based on changes in the activated route. </p>

<p>Thank you in advance!</p>
","3407751","","","","","2018-05-17 16:40:47","rxjs6 ActivatedRoute subscribe to observable","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50397685","1","50398056","","2018-05-17 17:51:40","","2","174","<p>I updated rxjs to 6.1.0. And I want to refactor my imports to new style. I mean:</p>

<pre><code>import { Observable, of } from 'rxjs';
</code></pre>

<p>But this is gave me an error:</p>

<pre><code>// return Observable.of(data); 
error TS2339: Property 'of' does not exist on type 'typeof Observable'.
</code></pre>

<p>map import wokrs (I think)</p>

<pre><code>import { map } from 'rxjs/operators';

return this.http.post(url, data).pipe(
    map(res =&gt; res)
)
</code></pre>

<p>What should I do?</p>

<p>i also append my dependencies</p>

<pre><code>""@agm/core"": ""1.0.0-beta.2"",
""@angular/animations"": ""^6.0.0"",
""@angular/common"": ""^6.0.0"",
""@angular/compiler"": ""^6.0.0"",
""@angular/core"": ""^6.0.0"",
""@angular/forms"": ""^6.0.0"",
""@angular/http"": ""^6.0.0"",
""@angular/platform-browser"": ""^6.0.0"",
""@angular/platform-browser-dynamic"": ""^6.0.0"",
""@angular/router"": ""^6.0.0"",
""brace"": ""0.11.0"",
""codemirror"": ""5.33.0"",
""core-js"": ""^2.5.4"",
""dragula"": ""3.7.2"",
""moment"": ""2.20.1"",
""ngx-quill"": ""2.0.4"",
""rxjs"": ""^6.1.0"",
""rxjs-compat"": ""^6.1.0"",
""spinkit"": ""1.2.5"",
""ts-helpers"": ""1.1.2"",
""zone.js"": ""^0.8.26""
</code></pre>

<p>and my devDependencies</p>

<pre><code>""@angular-devkit/build-angular"": ""~0.6.0"",
""@angular/cli"": ""~6.0.0"",
""@angular/compiler-cli"": ""^6.0.0"",
""@angular/language-service"": ""^6.0.0"",
""@types/jasmine"": ""~2.8.6"",
""@types/jasminewd2"": ""~2.0.3"",
""@types/node"": ""~8.9.4"",
""codelyzer"": ""~4.2.1"",
""jasmine-core"": ""~2.99.1"",
""jasmine-spec-reporter"": ""~4.2.1"",
""karma"": ""~1.7.1"",
""karma-chrome-launcher"": ""~2.2.0"",
""karma-coverage-istanbul-reporter"": ""~1.4.2"",
""karma-jasmine"": ""~1.1.1"",
""karma-jasmine-html-reporter"": ""^0.2.2"",
""protractor"": ""~5.3.0"",
""ts-node"": ""~5.0.1"",
""tslint"": ""~5.9.1"",
""typescript"": ""^2.7.2""
</code></pre>
","9807047","","","","","2018-05-17 18:15:42","Angular and new RxJS import system","<angular><angular6><rxjs6>","2","0","","","","CC BY-SA 4.0"
"50412389","1","50412516","","2018-05-18 13:26:14","","2","1562","<p>I upgraded my Angular application from version 5.2 to 6.0 with the instructions from <a href=""https://update.angular.io"" rel=""nofollow noreferrer"">https://update.angular.io</a>. </p>

<p>Now my Angular application doesn't build because of the ""rxjs-5-to-6-migrate"" migration:</p>

<blockquote>
  <p>ERROR in bla.ts: error TS2339:
  Property 'map' does not exist on type 'Observable'.</p>
</blockquote>

<p>I have the following imports:</p>

<pre><code>import { Observable } from 'rxjs/observable';
import { of } from 'rxjs/observable/of';
import { map } from 'rxjs/operators';
</code></pre>

<p>If I change the imports like this it works:</p>

<pre><code>import { Observable } from 'rxjs/observable';
import 'rxjs/Rx';
</code></pre>

<p>But I don't understand why... I want to use the explicit imports and not import all operators.</p>

<hr>

<p><strong>UPDATE:</strong> As some answers pointed out I have to use pipes to be able to use operators. This was my problem because I thought I can still chain the operators to the observables.</p>

<p><em>Old Style:</em></p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/catch';

this.http.get('/api/appsettings/get').map(data =&gt; { return true; }).catch(() =&gt; { return Observable.of(false); });
</code></pre>

<p><em>New Style</em></p>

<pre><code>import { of,  Observable } from 'rxjs';
import { catchError, map } from 'rxjs/operators';

this.http.get('/api/appsettings/get').pipe(map(data =&gt; { return true; }), catchError(() =&gt; { return of(false); }));
</code></pre>
","2301612","","2301612","","2018-05-18 13:55:33","2018-05-18 14:21:28","Property 'map' does not exist on type 'Observable' after upgrading rxjs to 6","<angular><rxjs><rxjs5><rxjs6><rxjs-compat>","3","2","1","","","CC BY-SA 4.0"
"50413038","1","50422531","","2018-05-18 14:01:20","","6","11971","<p>I have updated code that worked fine with Angular 5.5/rxJS5.5 using the new <strong>pipe</strong> method to Angular 6/rxJS6 using the rxjs-lint package and the following commands</p>

<pre><code>npm i -g rxjs-tslint
rxjs-5-to-6-migrate -p tsconfig.json
</code></pre>

<p>Imports etc have been amended as expected but now the code that worked fine with v5 of Angular/5.5 of RxJS is erroring with the error:</p>

<pre><code> error TS2339: Property 'pipe' does not exist on type 'OperatorFunction&lt;{}, {} | RouterEvent | RouteConfigLoadStart | RouteConfigLoadEnd | ChildActivati...'.
</code></pre>

<p>I have removed the rxjs6-compat package but it makes no difference. It's almost as if the build thinks it's got an earlier version of rxJS than v5.5.  <strong>package.json</strong> used with npm install looks like this...</p>

<pre><code>""dependencies"": {
    ""@angular/animations"": ""^6.0.2"",
    ""@angular/cdk"": ""^6.0.2"",
    ""@angular/common"": ""^6.0.2"",
    ""@angular/compiler"": ""^6.0.2"",
    ""@angular/core"": ""^6.0.2"",
    ""@angular/flex-layout"": ""^6.0.0-beta.15"",
    ""@angular/forms"": ""^6.0.2"",
    ""@angular/http"": ""^6.0.2"",
    ""@angular/material"": ""^6.0.2"",
    ""@angular/platform-browser"": ""^6.0.2"",
    ""@angular/platform-browser-dynamic"": ""^6.0.2"",
    ""@angular/router"": ""^6.0.2"",
    ""@ngrx/effects"": ""^6.0.0-beta.3"",
    ""@ngrx/entity"": ""^6.0.0-beta.3"",
    ""@ngrx/router-store"": ""^6.0.0-beta.3"",
    ""@ngrx/store"": ""^6.0.0-beta.3"",
    ""@ngrx/store-devtools"": ""^6.0.0-beta.3"",
    ""@ngx-translate/core"": ""^9.0.1"",
    ""core-js"": ""^2.5.2"",
    ""hammerjs"": ""^2.0.8"",
    ""lodash"": ""^4.17.4"",
    ""material-design-icons-iconfont"": ""^3.0.3"",
    ""nsp"": ""^3.2.1"",
    ""passport"": ""^0.4.0"",
    ""passport-azure-ad"": ""^3.0.12"",
    ""rxjs"": ""^6.1.0"",
    ""zone.js"": ""^0.8.26""
  },
</code></pre>

<p>The import for rxjs operators are in rxjs6 format:</p>

<pre><code>import { filter, map, merge, mergeMap } from 'rxjs/operators';
</code></pre>

<p>The statement that worked but now gives this error is:</p>

<pre><code>// Change page title on navigation or language change, based on route data
merge(this.translateService.onLangChange, onNavigationEnd)
  .pipe(
    map(() =&gt; {
      let route = this.activatedRoute;
      while (route.firstChild) {
        route = route.firstChild;
      }
      return route;
    }),
    filter(route =&gt; route.outlet === 'primary'),
    mergeMap(route =&gt; route.data)
  )
  .subscribe(event =&gt; {
    const title = event['title'];
    if (title) {
      this.titleService.setTitle(this.translateService.instant(title));
    }
  });
</code></pre>

<p>What have I missed?  Why is the pipe causing this error now where it was fine with rxJS 5.5?</p>
","8713457","","","","","2018-12-08 16:36:22","Angular v6, rxjs v6 error TS2339: Property 'pipe' does not exist on type 'OperatorFunction","<angular6><rxjs6>","3","0","0","","","CC BY-SA 4.0"
"50413121","1","50413189","","2018-05-18 14:05:48","","2","4585","<p>I don't quite understand how to handle observable correctly. So I have a problem with my code.</p>

<p>In service I have two methods:</p>

<pre><code>verify(): Observable&lt;any&gt; {
  return this.http.post(some_url);
}

// and

isAuthenticated(){
  this.verify().subscribe(
    data =&gt; {return true;},
    error =&gt; {return false;})
}
</code></pre>

<p>And in guard I call isAuthenticated method and I need to get boolean from it.</p>

<pre><code>canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
  return this.auth.isAuthenticated() //?
}
</code></pre>

<p>How to handle it correctly? Should I return isAuthenticated as Observable? And subscribe in guard?</p>
","9807047","","","","","2018-05-18 15:06:40","Angular 6 can I subscribe subscription","<angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50415719","1","","","2018-05-18 16:32:21","","3","3460","<p>Previously I was able to import only used operators with this code:</p>

<pre><code>import 'rxjs/Observable';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/finally';
import 'rxjs/add/observable/empty';
import 'rxjs/add/observable/throw';
</code></pre>

<p>This generates a small bundle (vendor.ts).<br>
How to do this with RxJS without requiring rxjs-compat?<br>
Changing the code above to <code>import 'rxjs';</code> generates a bigger bundle.</p>

<p>UPDATE:</p>

<p>I followed all the answers you've posted but nothing works well.
This is my updated vendor.ts:</p>

<pre><code>import 'rxjs/Observable';
import 'rxjs/Subscription';
import 'rxjs/Subject';
import 'rxjs/observable/throw';
import 'rxjs/operators/map';
import 'rxjs/operators/mergeMap';
import 'rxjs/operators/catchError';
import 'rxjs/operators/finalize';
</code></pre>

<p>I also tried using 'rxjs/add/operator/*'.</p>

<p>This is how I'm importing rxjs:</p>

<pre><code>import {Observable} from 'rxjs/Observable';
import {Subscription} from 'rxjs/Subscription';
import {Subject} from 'rxjs/Subject';
import {_throw} from 'rxjs/observable/throw';
import {map} from 'rxjs/operators/map';
import {mergeMap} from 'rxjs/operators/mergeMap';
import {catchError} from 'rxjs/operators/catchError';
import {finalize} from 'rxjs/operators/finalize';   
</code></pre>

<p>I changed my Webpack 3 configuration according to this document (<a href=""https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md#build-and-treeshaking"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/doc/pipeable-operators.md#build-and-treeshaking</a>) and nothing works.</p>

<p>Finally, take a look at the Webpack Bundle Analyzer result:</p>

<p><a href=""https://i.stack.imgur.com/LNiBD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LNiBD.png"" alt=""enter image description here""></a></p>

<p>The bundle includes all operators.
I found this related issue:
<a href=""https://github.com/angular/angular-cli/issues/9069"" rel=""nofollow noreferrer"">https://github.com/angular/angular-cli/issues/9069</a></p>
","1197865","","1197865","","2018-05-19 04:15:47","2019-04-09 10:51:04","How to import only used operators in RxJS 6 like older RxJS without requiring rxjs-compat?","<angular><typescript><rxjs><rxjs6>","4","5","","","","CC BY-SA 4.0"
"50416155","1","50498152","","2018-05-18 17:03:53","","3","970","<p>When using to angular 6 and swagger codegen, i'm getting typescript compiler errors related to <code>rxjs</code>:</p>

<p><code>
Cannot find module 'rxjs-compat/Observable'
</code></p>

<p>I found the following
<a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md#rxjs-v5x-to-v6-update-guide"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md#rxjs-v5x-to-v6-update-guide</a></p>

<p>I'm using <code>swagger-codegen: stable 2.3.1</code> on a mac (installed with brew).</p>

<p>I appreciate any guidance.</p>

<p>Update -----------------------</p>

<p>I added <code>rxjs-compat</code> to my angular6 project using</p>

<p><code>
npm install --save-dev rxjs-compat
</code></p>

<p>I now get compiler warnings, but the compiler errors are gone and the project seems to run</p>
","7085047","","7085047","","2018-05-18 17:12:21","2020-11-25 00:55:36","swagger codegen --> angular6: rxjs observable compile error","<angular><typescript><swagger><codegen><rxjs6>","3","0","2","","","CC BY-SA 4.0"
"50421831","1","","","2018-05-19 04:40:31","","1","88","<p>I have a series of requests and 4 web workers. I want to feed the responses to the workers and as soon as worker finishes feed another response and so on. I don't want to block the requests though.</p>

<p><a href=""https://i.stack.imgur.com/pEd6K.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pEd6K.png"" alt=""enter image description here""></a></p>

<p>The code that I have written doesn't show any difference between having 1 or 4 workers:</p>

<pre><code>const octrees$ = from(spatialKeys)
        .pipe(
            concatMap((spatialKey: string) =&gt; {
                console.log(""REQUEST"");
                return this.sgsApi
                    .getCellById(
                        sessionId,
                        volumetricModelQueryId,
                        spatialKey
                    )
                    .then(resp =&gt; resp.arrayBuffer())
                    .then(datBuffer =&gt; ({
                        datBuffer,
                        spatialKey
                    }));
            }),
            // SINGLE WEB WORKER
            // mergeMap(({ spatialKey, datBuffer }) =&gt;
            //  this.unpackWorkers[0].unpackDat(spatialKey, datBuffer)
            // )
            bufferCount(4),
            switchMap(values =&gt; {
                console.log(""UNPACK"");
                return values.map(({ datBuffer, spatialKey }, index) =&gt;
                    this.unpackWorkers[index].unpackDat(
                        spatialKey,
                        datBuffer
                    )
                );
            }),
            combineAll()
        )
        .subscribe(val =&gt; {
            const t1 = performance.now();
            console.log(""COMPLETED at :"", (t1 - t0) / 1000, val);
        });
</code></pre>
","2477487","","","","","2018-05-19 04:40:31","Rxjs requests with queue of webworkers in parallel","<typescript><web-worker><rxjs6>","0","0","","","","CC BY-SA 4.0"
"50426251","1","50426339","","2018-05-19 14:17:48","","2","4593","<p>I have recently upgraded to Angular 6 and rxjs 6, since the upgrade, the following code to set the page title dynamically is no longer working</p>

<pre><code>    ngOnInit(): void {
      this.router.events
      .filter((event) =&gt; event instanceof NavigationEnd)
      .map(() =&gt; this.activatedRoute)
      .map((route) =&gt; {
         while (route.firstChild) {
           route = route.firstChild;
         };

         return route;
      })
      .filter((route) =&gt; route.outlet === 'primary')
      .mergeMap((route) =&gt; route.data)
      .subscribe((event) =&gt; this.titleService.setTitle(event['title']));
};
</code></pre>

<p>This gives me an error</p>

<pre><code>this.router.events.filter is not a function
</code></pre>

<p>I tried wrapping the filter in a pipe like</p>

<pre><code>this.router.events
.pipe(filter((event) =&gt; event instanceof NavigationEnd))
</code></pre>

<p>But I get the error</p>

<pre><code>this.router.events.pipe(...).map is not a function
</code></pre>

<p>I have imported the filter like</p>

<pre><code>import { filter, mergeMap } from 'rxjs/operators';
</code></pre>

<p>What am I missing here?</p>
","4536345","","4536345","","2018-11-19 18:42:45","2018-11-19 18:42:45","Setting page title dynamically in Angular","<javascript><angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"50428084","1","","","2018-05-19 17:59:53","","0","39","<p>After loading the data through an http call to the server, I want to use the complete part of the subscription to open the material-sidenav. I have double checked and know that the subscribe part loads the data, but the complete section doesn't get called at all.
Here is the code:</p>

<pre><code>this.bs.getAddons().subscribe((data: any) =&gt; {//Done Loading packages -&gt; load addons
      this.bs.addons = data,
      error =&gt; console.log(error),
      () =&gt; sidenav.open();
    });
</code></pre>
","3826733","","13860","","2018-05-19 18:00:46","2018-05-19 18:00:46","Subscribe works & complete doesn't work","<angular><angular-material><rxjs6>","0","2","","","","CC BY-SA 4.0"
"50449078","1","","","2018-05-21 12:36:12","","0","358","<p>I have one epic</p>

<pre><code>type GetRailwaysEpic = Epic&lt;GetRailwaysActions, AppState&gt;;

const getRailwaysEpic: GetRailwaysEpic = (action$, state$) =&gt;
  action$.pipe(
    filter(isActionOf(getRailways.request)),
    switchMap(a =&gt;
      getRailways(state$.value.mileages.filters.date)
        .then(getRailways.success)
        .catch(getRailways.failure)
    )
  );
</code></pre>

<p>when I call anywhere actions.getRailways.request() it works as expected (REQUEST action first, SUCCESS of FAILURE next)</p>

<p>I have another epic</p>

<pre><code>const initEpic: Epic&lt;FiltersActions, AppState&gt; = (action$, state$) =&gt;
  action$.pipe(
    filter(isActionOf(init)),
    switchMap(({ payload: { date, depotId, locTypeId, railwayId } }) =&gt;
      of(selectDate(date)).pipe(
        concat(
          forkEpic(getRailwaysEpic, state$, getRailways.request())
        )
      )
    )
  );
</code></pre>

<p>my ForkEpic function:</p>

<pre><code>function forkEpic&lt;T extends Action, S&gt;(
  epicFactory: Epic&lt;T, S&gt;,
  state$: StateObservable&lt;S&gt;,
  ...actions: T[]
) {
  const actions$ = ActionsObservable.of(...actions);
  return epicFactory(actions$, state$, null);
}
</code></pre>

<p>What I want: 'init' action -> 'selectDate' action -> 'getRailways.request' action -> 'getRailways.success' | 'getRailways.failure' action</p>

<p>What I see: 'init' action -> 'selectDate' action -> 'getRailways.success' | 'getRailways.failure' action</p>

<p>'getRailways.request' action's missing somewhere.
What I do wrong?</p>

<p>P.S. getRailways - is a function which returns promise
P.P.S. I've found similar question here <a href=""https://stackoverflow.com/questions/47000384/how-to-chain-async-actions-and-wait-for-the-result-without-store-dispatch"">How to chain async actions and wait for the result without store.dispatch</a>
But it's not what I'm actualy looking for.  </p>
","7652684","","7652684","","2018-05-21 14:18:06","2018-05-23 17:34:28","forkEpic, redux-observable 1.0.0-alpha.2, typescript","<rxjs><redux-observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50452856","1","50457697","","2018-05-21 16:18:35","","1","462","<p>i am quite noob in rxjs.
i want a buffer which basically starts small in size (minSize) until it reaches a certain limit maxSize.</p>

<pre><code>buffer(minSize, maxSize, startEvery)
</code></pre>

<p>so it should emit e.g (rxjs 6 syntax).</p>

<pre><code>source(1,2,3,4,5,6,7,8).pipe(buffer(2, 4, 1))
.subscribe( res =&gt; console.log(res));

-&gt; [1,2]
-&gt; [1,2,3]
-&gt; [1,2,3,4]
-&gt; [2,3,4,5]
-&gt; [3,4,5,6] 
and so on
</code></pre>
","1389063","","","user5777975","2018-05-21 16:56:57","2018-05-21 23:12:02","RXJS buffer observable with max and min size","<javascript><rxjs><observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50465891","1","","","2018-05-22 10:52:38","","1","62","<p>I'm trying to construct the n-level treeview with rxjs. I achieved the same with plain javascript. Find the js code <a href=""https://plnkr.co/edit/CEryMRDeCkNOfPIozQJx?p=preview"" rel=""nofollow noreferrer"">here</a></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var x = [{""id"":1,""name"":""Admin"",""parentDepartmentId"":null},{""id"":2,""name"":""Development"",""parentDepartmentId"":1},{""id"":3,""name"":""Research and Development"",""parentDepartmentId"":1},{""id"":4,""name"":""FE"",""parentDepartmentId"":2},{""id"":5,""name"":""BE"",""parentDepartmentId"":2},{""id"":6,""name"":""Testing"",""parentDepartmentId"":1},{""id"":7,""name"":""Unit Test"",""parentDepartmentId"":6},{""id"":8,""name"":""Integration Test"",""parentDepartmentId"":6},{""id"":9,""name"":""HR"",""parentDepartmentId"":null}];

function getRecords(parents) {
    parents.forEach((parent) =&gt; {
      var result = getChildData(parent);
      parent.items = result;
      if (result.length &gt; 0) {
        getRecords(result);
      }
    })
  return parents;
}
  
function getChildData(parent) {
    return x.filter(record =&gt; record.parentDepartmentId == parent.id)
}

function getParents(x){
    return  x.filter(record =&gt; record.parentDepartmentId == null);
}

var parents = getParents(x)
var result = getRecords(parents);
console.log(result);</code></pre>
</div>
</div>
</p>

<p>Can someone show some lights on this.</p>
","6820922","","6820922","","2018-05-22 11:08:16","2018-05-22 11:08:16","Recursively construct JSON till nth level for tree view by using RXJS Operators","<javascript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50468446","1","50468661","","2018-05-22 13:03:10","","2","5609","<p>I'm having a problem with the import of the ""of"" method for observable in angular 6, even with a fresh project install, all updated packages, I still get the error.
So, i made a small project</p>

<p>this is the service giving </p>

<pre><code>import { Injectable } from '@angular/core';
import { TableRow } from './table-row';
import { Observable, of } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class TestTableService {

  private testData : TableRow[] = [
    {id:1, name:'pi', value:3.14},
    {id:2, name:'euler', value:2.71},
    {id:3, name:'Feigenbaum constant', value:2.50290},
    {id:4, name:'Mills constant', value:1.30637},
    {id:5, name:'one', value:1},
    {id:6, name:'square root of 2', value:1.41421}
  ];

  constructor() { }

  public getData() : Observable&lt;TableRow[]&gt;
  {
    return Observable.of(this.testData);
  }
}
</code></pre>

<p>this is the component using it:</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { TestTableService } from './../test-table.service';
import { TableRow } from './../table-row';

@Component({
  selector: 'app-test-table',
  templateUrl: './test-table.component.html',
  styleUrls: ['./test-table.component.css']
})
export class TestTableComponent implements OnInit {
  tableData : TableRow[] = [];

  constructor(private testTable : TestTableService) { }

  ngOnInit() {
    this.testTable.getData()
      .subscribe(table =&gt; this.tableData = table);
  }

}
</code></pre>

<p>Notice the imports are all the same as the other questions</p>

<p><a href=""https://i.stack.imgur.com/zXNWI.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zXNWI.png"" alt=""the error I get""></a></p>

<p>the projects package.json:</p>

<pre><code>{
  ""name"": ""angular-table-test"",
  ""version"": ""0.0.0"",
  ""scripts"": {
    ""ng"": ""ng"",
    ""start"": ""ng serve"",
    ""build"": ""ng build"",
    ""test"": ""ng test"",
    ""lint"": ""ng lint"",
    ""e2e"": ""ng e2e""
  },
  ""private"": true,
  ""dependencies"": {
    ""@angular/animations"": ""^6.0.2"",
    ""@angular/cdk"": ""^6.1.0"",
    ""@angular/common"": ""^6.0.2"",
    ""@angular/compiler"": ""^6.0.2"",
    ""@angular/core"": ""^6.0.2"",
    ""@angular/forms"": ""^6.0.2"",
    ""@angular/http"": ""^6.0.2"",
    ""@angular/material"": ""^6.1.0"",
    ""@angular/platform-browser"": ""^6.0.2"",
    ""@angular/platform-browser-dynamic"": ""^6.0.2"",
    ""@angular/router"": ""^6.0.2"",
    ""core-js"": ""^2.5.4"",
    ""hammerjs"": ""^2.0.8"",
    ""rxjs"": ""^6.0.0"",
    ""zone.js"": ""^0.8.26""
  },
  ""devDependencies"": {
    ""@angular/compiler-cli"": ""^6.0.2"",
    ""@angular-devkit/build-angular"": ""~0.6.3"",
    ""typescript"": ""~2.7.2"",
    ""@angular/cli"": ""~6.0.3"",
    ""@angular/language-service"": ""^6.0.2"",
    ""@types/jasmine"": ""~2.8.6"",
    ""@types/jasminewd2"": ""~2.0.3"",
    ""@types/node"": ""~8.9.4"",
    ""codelyzer"": ""~4.2.1"",
    ""jasmine-core"": ""~2.99.1"",
    ""jasmine-spec-reporter"": ""~4.2.1"",
    ""karma"": ""~1.7.1"",
    ""karma-chrome-launcher"": ""~2.2.0"",
    ""karma-coverage-istanbul-reporter"": ""~1.4.2"",
    ""karma-jasmine"": ""~1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""protractor"": ""~5.3.0"",
    ""ts-node"": ""~5.0.1"",
    ""tslint"": ""~5.9.1""
  }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/DoSL5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DoSL5.png"" alt=""the angular cli version output""></a></p>

<p>what could be the problem?</p>
","8856434","","","","","2019-04-29 20:43:18","Observable.of is not a function with correct import","<angular><angular6><rxjs6>","2","3","","","","CC BY-SA 4.0"
"50475213","1","50475771","","2018-05-22 19:31:20","","11","8446","<p>I am in the process of adding <code>rxjs_compat</code> to my project in order to move to v6 of libraries.</p>

<p>However the existing <code>HttpInterceptor</code> for global error handling no longer compiles. Not sure where to go with it. Tried all sorts. Getting type mismatches with everything tried.</p>

<pre><code>import { Injectable } from ""@angular/core"";
import {
  HttpEvent,
  HttpInterceptor,
  HttpHandler,
  HttpRequest,
  HttpResponse,
  HttpErrorResponse
} from ""@angular/common/http"";
import { Observable, of, empty } from ""rxjs"";
import { ToastrService } from ""ngx-toastr"";
import { environment } from ""../../environments/environment"";
import { catchError, map } from ""rxjs/operators"";

@Injectable()
export class HttpErrorInterceptor implements HttpInterceptor {
  constructor(private toastr: ToastrService) {}
  intercept(
    request: HttpRequest&lt;any&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    return next.handle(request).pipe(
      catchError(err =&gt; of(HttpErrorResponse)),
      map(err =&gt; {
        let message: string;
         this.toastr.error(`${message}`, ""Application Error"");
        return Observable.empty&lt;HttpEvent&lt;any&gt;&gt;();
      })
    );
  }
}
</code></pre>

<blockquote>
  <p>src/app/shared/http-error-interceptor.ts(26,27): error TS2339:
  Property 'empty' does not exist on type 'typeof Observable'.</p>
</blockquote>

<p><code>empty</code> is now a constant, but doesn't accept a type, so that does not work either. Also could not find much in <a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md#dep-methods"" rel=""noreferrer"">the upgrade notes</a> </p>

<p><strong>EDIT</strong></p>

<p>although interestingly this compiles:</p>

<pre><code>return Observable.of&lt;HttpEvent&lt;any&gt;&gt;();
</code></pre>
","220005","","220005","","2018-05-22 20:02:32","2018-08-10 21:52:16","RXJS 6: new version of HttpInterceptor","<angular><typescript><rxjs><angular6><rxjs6>","2","11","4","","","CC BY-SA 4.0"
"50503366","1","50503457","","2018-05-24 07:22:56","","0","16057","<p>After I updated angular/cli, I got an error:</p>

<pre><code>error TS2339: Property 'map' does not exist on type 'Observable&lt;Response&gt;'
</code></pre>

<p><img src=""https://i.stack.imgur.com/Rmdfh.png"" alt=""enter image description here""></p>

<p>I tried every possible solution from <a href=""https://stackoverflow.com/questions/37208801/property-map-does-not-exist-on-type-observableresponse?noredirect=1&amp;lq=1"">Property &#39;map&#39; does not exist on type &#39;Observable&lt;Response&gt;&#39;</a></p>

<p>but still the error exists.</p>
","9839062","","1791913","","2018-05-24 07:48:39","2020-08-16 08:44:47","Error: Property 'map' does not exist on type 'Observable'","<angular><rxjs><rxjs6>","3","3","","","","CC BY-SA 4.0"
"50503380","1","","","2018-05-24 07:23:39","","2","95","<p>I am trying to update my existing angular project from v5.x to v6.x along with angular material.</p>

<p>I have done the following steps - </p>

<ol>
<li><p>I deleted existing node_module folder</p></li>
<li><p>Followed all the steps mentioned here - <a href=""https://www.ngdevelop.tech/upgrade-angular-5-to-6/"" rel=""nofollow noreferrer"">update to ng 6</a> </p></li>
<li><p>Installed latest angular material and cdk and hammer.js as mentioned in latest angular material guide.</p></li>
<li><p>I re-ran - npm install - deleting earlier node_modules folder and clean npm cache.</p></li>
</ol>

<p>BUT When I run ng serve - I get the following errors - Please look at the screen shot attached.</p>

<p>Any help or clue will be highly appreciated!!</p>

<p><a href=""https://i.stack.imgur.com/rRqWY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rRqWY.png"" alt=""enter image description here""></a></p>

<p>Package.json screenshot-</p>

<p><a href=""https://i.stack.imgur.com/c8KZ6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/c8KZ6.png"" alt=""Package.json ""></a></p>
","5098656","","5098656","","2018-05-24 12:57:17","2018-05-24 12:57:17","Angular and Angular material upgrade from v5.x to v6.x","<angular><angular5><angular6><angular-material-5><rxjs6>","1","3","0","","","CC BY-SA 4.0"
"50505929","1","","","2018-05-24 09:37:26","","1","2006","<p>I am fetching an object from node server using a angular 6 service.</p>

<pre><code>getMasterObj () {

   this.http.get(this.url1).subscribe(
        (data) =&gt;{
        this.masterChartObj1 = data;
        console.log(this.masterChartObj1) // data is getting printed
    })
        console.log(this.masterChartObj1) // undefined

}
</code></pre>

<p>In same classs I have defined an object as </p>

<pre><code>public masterChartObj1;
</code></pre>

<p>I am initializing that object with the data received in subscribe method.
as checked in console.log it is printed but same is undefined outside subscriber method.</p>

<p>I have tried same in another way also, but still same output.</p>

<pre><code> getMasterObj () {
       let parent_scope = this;
       this.http.get(this.url1).subscribe(
            (data) =&gt;{
            parent_scope.masterChartObj1 = data;
            console.log(parent_scope.masterChartObj1) // data is getting printed
        })
            console.log(this.masterChartObj1) // undefined

    }
</code></pre>

<p>Please let me know, if I am doing anything wrong... </p>
","9735211","","","","","2018-05-24 09:40:19","unable to use fetched data outside subscribe() method in angular 6","<angular><observable><angular2-services><subscribe><rxjs6>","2","2","","2018-05-24 09:43:24","","CC BY-SA 4.0"
"50507671","1","50633753","","2018-05-24 11:01:26","","2","4787","<p>So what is the difference between <code>of</code> operator and <code>Observable.of</code> and what is the recommended way to create an observable?</p>

<pre><code>import { Observable } from 'rxjs/Observable';
const obs$ = Observable.of(3);
</code></pre>

<p>or</p>

<pre><code>import { of as observableOf } from 'rxjs';
const obs$ = observableOf(3);
</code></pre>
","1543885","","1543885","","2018-05-24 11:09:50","2018-05-31 22:38:57","Difference between `of` operator and `Observable.of`","<angular><rxjs><rxjs6>","1","5","1","","","CC BY-SA 4.0"
"50512031","1","","","2018-05-24 14:35:15","","5","3007","<p>I'm trying to test an Angular <code>Component</code> that basically receives an <code>Observable</code> and changes its <code>template</code> based on the values emitted from that Observable. Here's a simplified version:</p>

<pre><code>@Component({
    selector: 'async-text',
    template: `
        &lt;span&gt;{{ text | async }}&lt;/span&gt;
    `,
})
export class AsyncTextComponent {    
    @Input() text: Observable&lt;string&gt;;
}
</code></pre>

<p>I'd like to test it out, and currently this is what I have, using <a href=""https://github.com/cartant/rxjs-marbles"" rel=""noreferrer""><code>rxjs-marbles</code></a> (though it's not a must).</p>

<pre><code>import { async, ComponentFixture, TestBed } from '@angular/core/testing';
import { AsyncTextComponent } from './async-text.component';

describe('AsyncTextComponent', () =&gt; {
  let component: BannerComponent;
  let fixture: AsyncTextComponent&lt;AsyncTextComponent&gt;;

  it('...',
    marbles(m =&gt; {
      fixture = TestBed.createComponent(AsyncTextComponent);
      component = fixture.componentInstance;
      component.text = m.cold('-a-b-c|', {
        a: 'first',
        b: 'second',
        c: 'third',
      });

      fixture.detectChanges();
      expect(component.nativeElement.innerHTML).toContain('first');

      fixture.detectChanges();
      expect(component.nativeElement.innerHTML).toContain('second');

      fixture.detectChanges();
      expect(component.nativeElement.innerHTML).toContain('third');
    })
  );
});
</code></pre>

<p>Obviously this doesn't work. My issue is that I didn't find a way to advance the TestScheduler by a given amount of 'frames' between each <code>expect</code>.</p>

<p>How can I manually skip frames? Or alternatively, is there a better way to test the above component/scenario (Angular component that receives an <code>Observable</code> and I want to test it's behaviour given the Observable's emittions).</p>

<p>I did see <code>.flush()</code>, but as documented, it runs all of the Observable's emits, so I'd get to the final status, and can't test out different transitions between states.</p>

<p>Thanks</p>
","2677913","","2677913","","2018-05-24 14:45:37","2018-05-24 14:45:37","How to test Angular component with Observable Input","<angular><rxjs><angular-test><rxjs6>","1","9","0","","","CC BY-SA 4.0"
"50518543","1","50518934","","2018-05-24 21:38:59","","8","2146","<p>Before Rxjs 6 we could do:</p>

<pre><code>interface TypeA {
  payload: any;
}

source$.pipe(
  withLatestFrom(source2$, (source1: TypeA, source2: TypeB) =&gt; 
       ({ payload: source1.payload, source2 }) ),
)
</code></pre>

<p>We could, in the resultSelector method arguments, add proper types for <code>source1</code> and <code>source2</code>, passed along within the constructed object here.</p>

<p>But now we must do the following:</p>

<pre><code>source$.pipe(
  withLatestFrom(source2$),
  map(([source1, source2]) =&gt; ({ source1, source2 }) ),
)
</code></pre>

<p>Doing so we are unable to add type on source1 and source2 within array argument. The typing is then lost and IDE doesn't suggest <code>.payload</code> on <code>source1</code> for example.</p>

<p>How to be able, using the new syntax, to add proper typing with array arguments?</p>
","6361127","","","","","2018-05-24 22:15:53","How to type array map arguments from rxjs 6 withLatestFrom","<typescript><rxjs><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"50518742","1","","","2018-05-24 21:55:26","","1","3318","<p>Looks like imports are clearer in typescript for RxJS 6 now but in javascript how to import <code>take</code> operator?</p>

<p>Tried with</p>

<pre><code>import 'rxjs/operators/take';
</code></pre>

<p>Also tried with ES6:</p>

<pre><code>import { take } from 'rxjs/operators';
</code></pre>

<p>but did not work. Complains that take is not a function.</p>
","1139247","","1139247","","2018-05-30 20:19:33","2018-06-16 21:51:26","how to do import `take` in javascript for RxJS 6 now?","<import><rxjs6>","1","6","","","","CC BY-SA 4.0"
"50519200","1","51169586","","2018-05-24 22:45:01","","67","62803","<p>Why is the view not being updated when a variable changes within a subscribe?</p>

<p>I have this code:</p>

<p><strong>example.component.ts</strong></p>

<pre><code>testVariable: string;

ngOnInit() {
    this.testVariable = 'foo';

    this.someService.someObservable.subscribe(
        () =&gt; console.log('success'),
        (error) =&gt; console.log('error', error),
        () =&gt; {
            this.testVariable += '-bar';

            console.log('completed', this.testVariable);
            // prints: foo-Hello-bar
        }
    );

    this.testVariable += '-Hello';
}
</code></pre>

<p><strong>example.component.html</strong></p>

<pre><code>{{testVariable}}
</code></pre>

<p>But the view displays: <em>foo-Hello</em>.</p>

<p>Why won't it display: <em>foo-Hello-bar</em>?</p>

<p>If I call <code>ChangeDetectorRef.detectChanges()</code> within the subscribe it will display the proper value, but why do I have to do this?</p>

<p>I shouldn't be calling this method from every subscribe, or, at all (angular should handle this). Is there a right way?</p>

<p>Did I miss something in the update from Angular/rxjs 5 to 6?</p>

<p>Right now I have Angular version 6.0.2 and rxjs 6.0.0. The same code works ok in Angular 5.2 and rxjs 5.5.10 without the need of calling <code>detectChanges</code>.</p>
","2213798","","1541563","","2020-09-06 04:41:59","2021-06-30 08:51:04","Angular 6 View is not updated after changing a variable within subscribe","<typescript><angular6><observable><rxjs6><angular-changedetection>","6","2","17","","","CC BY-SA 4.0"
"50524711","1","50525062","","2018-05-25 08:24:00","","5","17007","<p>I do not understand how to handle the object I subscribe to. The object is the following structure:</p>

<pre><code>{
  data:{
       date: ""2018-02-20 13:10:23"",
       text: ""Описание"",
       id: 1,
       items: [
              0: {
                 date: ""2018-02-20 13:10:23"",
                 text: ""Описание"",
                 images: [
                         0: ""image1.jpg"",
                         1: ""image2.jpg""
                         ],
                 name: ""Изображения"",
                 type: ""images""
                 },
              1: {
                 date: ""2018-02-20 13:10:23"",
                 text: ""Описание"",
                 image: null,
                 type: ""video"",
                 url: ""https://www.youtube.com/embed/v64KOxKVLVg""
                 }
              ]
       }
}
</code></pre>

<p>I make an appeal through the service:</p>

<pre><code>import {HttpClient} from '@angular/common/http';
import {Injectable} from '@angular/core';
@Injectable()
export class VideoService {
    constructor(private http: HttpClient) {}

    getVideoTape() {
        return this.http.get(`http://ip_adress/api/v1/mixed_galleries/1`);
    }
}
</code></pre>

<p>There is an interface model:</p>

<pre><code>export class VideoListModel {
    constructor(
        public created_at: string,
        public description: string,
        public id: number,
        public items: any[],
        public name: string
    ) {}
}
</code></pre>

<p>And I do the processing in the component:</p>

<pre><code>import {Component, OnDestroy, OnInit} from '@angular/core';
import {Observable, Subscription} from 'rxjs';
import {filter} from 'rxjs/operators';
import {VideoService} from '../shared/services/video.service';
import {VideoListModel} from '../../shared/models/video-list.model';

@Component({
  selector: 'app-video-index',
  templateUrl: './video-index.component.html',
  styleUrls: ['./video-index.component.scss']
})

export class VideoIndexComponent implements OnInit, OnDestroy {
    private videoTape = [];
    private _subscription2: Subscription;

    constructor( private videoService: VideoService ) { }

  ngOnInit() {
      this._subscription2 = this.videoService.getVideoTape()
          .subscribe((data: VideoListModel[]) =&gt; {
          this.videoTape = data;
          console.log(this.videoTape);
      });
  }

    ngOnDestroy() {
        this._subscription2.unsubscribe();
    }

}
</code></pre>

<p>The task is to make a selection from objects by type: ""video"". Through AJAX + jQuery did it without problems, and in Angular I'm relatively new. Shoveled a bunch of video lessons yesterday, but nowhere are examples of filtering such complex objects.</p>

<p>Construction:</p>

<pre><code>this._subscription2 = this.videoService.getVideoTape()
          .pipe(filter((data: VideoListModel[]) =&gt; data.items.type === 'video'))
          .subscribe((data: any) =&gt; {
              this.videoTape = data.data;
              console.log(this.videoTape);
          });
</code></pre>

<p>does not work. The result is an error saying ""Property 'items' does not exist on type 'VideoListModel []'"". Intuitively, I understand that the matter is most likely in the interface, but I can not understand how to modify the interface so that the filtering works correctly. If someone encountered filtering complex objects, tell me please how to solve this problem.</p>
","8247592","","","","","2018-05-25 09:24:22","Processing a complex object by http get in Angular 6","<angular><typescript><filter><angular6><rxjs6>","4","0","4","","","CC BY-SA 4.0"
"50529240","1","","","2018-05-25 12:27:37","","2","310","<p><strong>Have following versions:</strong></p>

<pre><code>""angular"": 6.0.3 
""rxjs"": ""^6.2.0"",
""@mapbox/mapbox-gl-draw"": ""^1.0.4"",
</code></pre>

<blockquote>
  <p>While <strong>ng serve</strong> Getting error: 
  <a href=""https://i.stack.imgur.com/99Gvu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/99Gvu.png"" alt=""enter image description here""></a></p>
</blockquote>

<p>Could anyone help me out, will be appreciated..</p>
","4058808","","4058808","","2018-05-28 05:30:14","2019-09-13 08:55:07","Getting error while ng serve. Using mapbox/mapbox-gl-draw","<angular><mapbox><mapbox-gl><rxjs6><mapbox-gl-draw>","3","6","2","","","CC BY-SA 4.0"
"50530792","1","50587851","","2018-05-25 13:53:19","","2","780","<p>We've <a href=""https://github.com/ReactiveX/rxjs/blob/master/MIGRATION.md"" rel=""nofollow noreferrer"">updated</a> our project to use Angular &amp; Rxjs 6 and all works fine.  </p>

<p>We've also updated the code to use the pipe operators, so we would like to drop <code>rxjs-compat</code>.<br>
The only issue is that one of our dependencies still uses the old import syntax for Observable and Subject.</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
</code></pre>

<p>Is there any way to provide our own minimal rxjs-compat just for these two classes?</p>

<p>The library does not do anything fancy with Observable and Subject, and doesn't use any operators, so it seems overkill to import the full rxjs-compat package.</p>
","281252","","310726","","2018-05-25 14:03:41","2018-05-30 03:26:32","How to use only a part of rxjs-compat, or write a custom rxjs-compat?","<rxjs><rxjs6><rxjs-compat>","2","2","","","","CC BY-SA 4.0"
"50543848","1","","","2018-05-26 14:37:23","","0","275","<p>I have been working on an Ngrx app for weeks now trying to get this one observable to output to the component. Initially, I thought it was in issue with my ngrx entities and reducers so I have now tried to take this one specific call out of the ngrx framework and call it directly to output. It still won't work. The sequence goes as follows: </p>

<pre><code>this.pomos$ = this.pomoQuery.getTaskPomos(snapshot.params.id);
</code></pre>

<p>is called from <strong>app/tasks/containers/selected-task-page.ts</strong> and subscribed to for output to then pass into </p>

<pre><code>this.pomos$.subscribe(pomos =&gt; {
     this.pomos = pomos;
    });
</code></pre>

<p>a display component <strong>app/tasks/components/pomo-tracker.ts</strong></p>

<pre><code>&lt;div class=""pomo-container mat-elevation-z8""&gt;
    &lt;div class=""pomo-header""&gt;
    &lt;mat-list&gt;
      &lt;mat-list-item&gt;
          This is for the pomos
      &lt;/mat-list-item&gt;
    &lt;/mat-list&gt;
    &lt;mat-list *ngFor=""let pomo of pomos""&gt;
      &lt;mat-list-item&gt;{{ pomo.notes }}&lt;/mat-list-item&gt;
    &lt;/mat-list&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>It will not bind to the component and output no matter what I try. I tried adding json pipe. I tried taking off the async pipe. I have tried to subscribing to the observable in different ways. I have tried piping and mapping to it. I am completely at a loss. I am relatively new to rxjs. The observable outputs the the values to the console as you can see here. </p>

<p><a href=""https://i.stack.imgur.com/LNTad.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LNTad.png"" alt=""enter image description here""></a></p>

<p>One of the errors I keep getting is 
Error: Cannot find a differ supporting object '[object Object]' of type 'object'. NgFor only supports binding to Iterables such as Arrays.</p>

<p>which I am sure has to do with the json object returning but why does this observable not output but all the others do. This is why I tried adding the json pipe to the output but that didn't work either. </p>

<p>If there is anyone here who would be so kind as to help get over this final hurdle which I have spent days on I would be greatly appreciative. <a href=""https://stackblitz.com/github/djr-taureau/pomodoro-it-ngrx"" rel=""nofollow noreferrer"">My Code is on Stackblitz here</a></p>

<p>To reproduce the error: </p>

<ol>
<li>Login with test/test</li>
<li>From Sidenav: Find a Task</li>
<li>Search for Python</li>
<li>Add Task to Collection.</li>
<li>Hit the play button. Will time out after 5 seconds</li>
<li>Enter notes and submit</li>
<li>Refresh the page: View the error in the console.</li>
</ol>

<p>THANK YOU in advance.</p>
","9536803","","","","","2018-05-30 11:54:02","Cannot get Observable to output to component","<angular><observable><ngrx><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50544697","1","50544895","","2018-05-26 16:13:08","","1","182","<p>I have declared an observable variable </p>

<pre><code>workOrders: Observable&lt;IWorkOrders[]&gt;;
</code></pre>

<p>And then i load that observable this way. </p>

<pre><code>  this.bs.getWorkOrders()
  .pipe(map(data:IWorkOrders[]) =&gt; this.workOrders = data)),
    .subscribe((data: IWorkOrders[]) =&gt;
      // this.workOrders = data;
      this.woSubject.next(data),
  );
</code></pre>

<p>but when i do it i see a red squiggly under the this.workOrders = data line. And also when I hover it says
[ts] Type 'IWorkOrders[]' is not assignable to type 'Observable'
<a href=""https://i.stack.imgur.com/77N5G.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/77N5G.jpg"" alt=""enter image description here""></a></p>
","3826733","","3826733","","2018-05-26 16:36:50","2018-05-26 16:56:59","Angular RxJS Observable loading error","<angular><typescript><rxjs6>","2","0","","","","CC BY-SA 4.0"
"50561713","1","","","2018-05-28 08:03:08","","2","1227","<p>After upgrade:
 Angular ""5.2.0"" -> ""6.0.2"" and 
 rxjs"": ""^5.2.0"", -> ""rxjs"": ""^6.0"" and ""rxjs-compat"": ""^6.2.0"",</p>

<p>I've found this error on the browser:</p>

<pre><code>TypeError: this._subscribe is not a function
at PromiseObservable.Observable.subscribe (Observable.js:161)
at eval (subscribeTo.js:21)
</code></pre>

<p>Then I've installed: <strong>npm i -g rxjs-tslint</strong> 
and run <strong>rxjs-5-to-6-migrate -p path-to-tsconfig.ts</strong> 
all paths have been updated but still same error on browser.</p>
","7474446","","","","","2018-05-28 10:10:05","Upgrade rxjs 6: this._subscribe is not a function at PromiseObservable.Observable.subscribe","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50564066","1","","","2018-05-28 10:15:28","","7","5001","<p>Since I update my code to the new Rxjs 6, I had to change the interceptor code like this:</p>

<p>auth.interceptor.ts:</p>

<pre><code>...
return next.handle(req).pipe(
      tap((event: HttpEvent&lt;any&gt;) =&gt; {
        if (event instanceof HttpResponse) {
          // do stuff with response if you want
        }
      }),
      catchError((error: any) =&gt; {
        if (error instanceof HttpErrorResponse) {
          if (error.status === 401) {
            this.authService.loginRedirect();
          }
          return observableThrowError(this.handleError(error));
        }
      })
    );
</code></pre>

<p>and I'm not able to test the rxjs operators ""tap"" and ""catchError"".</p>

<p>Actually i'm only able to test if pipe is called:</p>

<pre><code>it('should intercept and handle request', () =&gt; {
    const req: any = {
      clone: jasmine.createSpy('clone')
    };

    const next: any = {
      handle: () =&gt; next,
      pipe: () =&gt; next
    };

    spyOn(next, 'handle').and.callThrough();
    spyOn(next, 'pipe').and.callThrough();

    interceptor.intercept(req, next);

    expect(next.handle).toHaveBeenCalled();
    expect(next.pipe).toHaveBeenCalled();
    expect(req.clone).toHaveBeenCalled();
  });
</code></pre>

<p>Any help is apreciated on how to spy the rxjs operators</p>
","4554305","","","","","2018-05-28 15:58:40","Angular 6 unit test rxjs 6 operator tap unit test interceptor","<rxjs><operators><interceptor><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50577108","1","50580288","","2018-05-29 05:46:57","","1","597","<p>In the following function, I am getting a runtime error <code>TypeError: this.authService.authServiceSigninUser(...).map(...).catch(...).finalize is not a function</code>. </p>

<p>Question 1) Why Typescript is not catching this error at compile time? How could I catch this error at compile time.</p>

<p>Question 2) How could I resolve the error? I tried using both <code>finally</code> and <code>finalize</code> but both are not working.</p>

<pre><code>public signinUser(user:UserSigninInfo):any{

    this.loaderService.show(); //this shows a spinner
    return this.authService.authServiceSigninUser(user)
      .map(response=&gt;{
        console.log('response from backend service',response);
        let result= &lt;HttpResponse&lt;any&gt;&gt;response; 
        let authToken = result.headers.get(""x-auth-token"")
        if(authToken == null) {
          console.log(""no authToken"")
        } else {
          console.log(""authToken is "",authToken)
          localStorage.setItem('id_token', authToken);
        }
        return result;
      })
      .catch(this.handleError)
    .finally(()=&gt; this.loaderService.hide()) //hide the spinner
  }
</code></pre>
","6703783","","","","","2018-05-29 09:05:28","getting TypeError: .finalize is not a function in Rxjs6","<angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50586394","1","","","2018-05-29 14:04:58","","0","53","<p>I moving implementation of draggable component from rxjs5 to 6. While testing i noticed that function onDragEnd is not called occasionally. What could be the reason for this ? Here is the code:</p>

<pre><code>    fromEvent(this.ref,""mousedown"")
        .pipe(
            filter(this.inside),
            debounceTime(300),
            tap((event) =&gt; { 
                this.onDragStart(event); 
            }),
            exhaustMap(() =&gt; 
                fromEvent(document.body,""mousemove"")
                .pipe(
                    takeUntil(
                        fromEvent(document.body,""mouseup"")
                        .pipe(tap(this.onDragEnd)) // &lt;--- my problem
                    )
                ) 
            )
        ) 
        .subscribe( 
            (event) =&gt; { 
                this.onDragMove(event);
            },
            this.onError
        )
</code></pre>

<p>Edit: just to clarify what i expect, mousedown event should be map to observable which (assuming i understood exhaustMap correctly) should not allow to outer observable emit again until inner observable completes. What i cant understand is why in one of 20-30 times onDragEnd is not fired, observable from document so as my intuition telling me mouse-up is inevitable in this case, am i wrong ? If you have some ideas what could possibly be wrong with this implementation please let me know, thank you!</p>
","5715298","","5715298","","2018-05-29 14:12:58","2018-05-29 14:12:58","Draggable component implementation with rxjs","<rxjs><rxjs6>","0","4","","","","CC BY-SA 4.0"
"50588626","1","50589219","","2018-05-29 16:06:26","","0","569","<p>so I have a scenario like this (simplyfied)</p>

<ul>
<li>main component</li>
<li>list component</li>
<li>list service</li>
</ul>

<p>where:</p>

<p><strong>main component</strong></p>

<pre><code>&lt;my-list [month]=""month""&gt;&lt;/my-list&gt;
</code></pre>

<p><strong>list component html</strong></p>

<pre><code>&lt;li *ngFor=""let item in list | async&gt;&lt;/li&gt;
</code></pre>

<p><strong>list component ts</strong></p>

<pre><code>list: Observable&lt;ListItem[]&gt;;
@Input() month: string;
...
ngOnInit() {
  this.list = this._listService.list;
}
ngOnChanges(changes: SimpleChanges) {
  if (changes.month &amp;&amp; !!this.month) {
     this._listService.getAllByMonth(this.month);
  }
}
</code></pre>

<p><strong>and finally list service</strong></p>

<pre><code>private _list: BehaviorSubject&lt;ListItem[]&gt;;
list: Observable&lt;ListItem[]&gt;;

private dataStore: {
  list: ListItem[]
};

constructor(private _http: HttpClient) {
  this.dataStore = { list: [] };
  this._list= &lt;BehaviorSubject&lt;ListItem[]&gt;&gt;new BehaviorSubject([]);
  this.list= this._list.asObservable();
}

public getAllByMonth(month: string) {
   this._http.get&lt;ListItem[]&gt;(environment.apiPath + 'list/' + month)
    .subscribe(
      data =&gt; {
        this.dataStore.list = data;
        this._list.next(Object.assign({}, this.dataStore).list);
      },
      error =&gt; console.log('Could not load the list.')
    );
}
</code></pre>

<p>For some reason getAllByMonth get's called many, many times... even though I change the month value only 1.</p>

<p>How should arrange things that getAllByMonth get's called ONCE when month value changes?</p>
","484025","","","","","2018-05-29 16:43:08","Angular: Observable subscribing in service - using it with ngOnChanges runs (too) many times","<angular><subscriber><rxjs6>","1","5","","","","CC BY-SA 4.0"
"50592218","1","","","2018-05-29 20:10:46","","2","1319","<p>I have a hard time understanding RxJs. The breaking changes between 5 and 6 are hard for me to understand.</p>

<p>I have the following code and the following issues.</p>

<ol>
<li>.interval method is no longer available from Observable</li>
<li>.switchMap method is no longer available from .interval</li>
</ol>

<p>I checked the changelog and the recommendations for fixing breaking changes and I wasn't able to sort out what I need to do. The way I understand it, the code I have is old and doesn't use the pipe operator but that's about all I've been able to figure out.</p>

<pre><code>let polling = Observable.interval(2000)
.switchMap(() =&gt; this.http.get(this.videoStatusURL + this.taskID))
.subscribe(
  (data) =&gt; {              
    if (data[""state""] === ""SUCCESS"") {
      //get final video here
      console.log(""polling succeeded"");
      this.downloadFinalVideo();
      polling.unsubscribe();
    }            
  },
  error =&gt; this.handleError(error));
</code></pre>
","1467034","","","","","2018-05-30 00:49:52","Migrating from RxJs 5 to 6: switchMap and Interval broken","<javascript><rxjs><rxjs5><angular6><rxjs6>","1","2","","","","CC BY-SA 4.0"
"50595898","1","50596243","","2018-05-30 03:21:30","","3","8695","<p>I meet some problem  about rxjs6 after update Angular 5 to Angular 6:</p>

<pre><code>TypeError: this.http.post(...).map is not a function

error TS2339: Property 'map' does not exist on type 'Observable&lt;Object&gt;'.

TypeError: rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable.of is not a function
</code></pre>

<p>I have tried some methods , like :</p>

<p>add this import to service.ts</p>

<blockquote>
  <p><strong>import { map } from 'rxjs/operators';</strong></p>
  
  <p><strong>change http.post().pipe(map(res => {...}))</strong></p>
</blockquote>

<p>However , all of thoes are not work for me .</p>

<p>My enviroment follow as:</p>

<pre><code> ""@angular/cli"": ""^6.0.3""
 ""rxjs"": ""^6.2.0""
 ""rxjs-compat"": ""^6.2.0""
</code></pre>

<p><strong>code show as below</strong>
     Service.ts</p>

<pre><code>import { Injectable } from '@angular/core';
import {environment} from '../../environments/environment';
import {HttpClient} from '@angular/common/http';
import {StorageService} from '../services/storage.service';

@Injectable()
export class VariationService {
ip = environment.url.management;
constructor(private http: HttpClient,
            private storageService: StorageService) { }
getFlowChart(status?) {
    status = status ? status : '';
    let token = this.storageService.getToken('token');
    return this.http.post(
        `${this.ip}/workflow`,
        {
            'access_token': token,
            'type': 'adjustment_workflow_get',
            'data': {
                'status': status
            }
        }
    ).map((res: Response) =&gt; {
      if ( res['errcode'] !== '00000') {
        return [];
      }
      return res['datas'];
    });
}
}
</code></pre>

<p>Another problem typscript file</p>

<pre><code>import {Injectable} from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { Observable } from 'rxjs';

@Injectable()
export class SelectivePreloadingStrategy implements PreloadingStrategy {
  preloadedModules: string[] = [];
  preload(route: Route, load: () =&gt; Observable&lt;any&gt;): Observable&lt;any&gt; {
    if (route.data &amp;&amp; route.data['preload']) {
      this.preloadedModules.push(route.path);
     return load();
    } else {
      return Observable.of(null);
    }
  }
}
</code></pre>
","5950855","","5950855","","2018-05-30 03:49:11","2018-05-30 04:40:07","TypeError: this.http.post(...).map is not a function after update angular 5 to angular 6","<angular><rxjs><angular6><rxjs6>","1","7","1","","","CC BY-SA 4.0"
"50605404","1","","","2018-05-30 13:00:59","","4","4547","<p>I have an observable that emits an array of objects. What pipe able operators do I need to use to transform it to an Observable so I can act on each object? </p>

<p>What do I need to do to obs$ to make it emit like obs2$ ?</p>

<pre><code>const obs$ = of([{ opponent: 'Walton', team: 'varsity', gametime: new Date() },
{ opponent: 'Scott', team: 'varsity', gametime: new Date() },
{ opponent: 'Dixie', team: 'varsity', gametime: new Date() },
{ opponent: 'Highlands', team: 'freshmen', gametime: new Date() }])
  .pipe(
    tap(console.log)
  );

obs$.subscribe(a =&gt;
  console.log(a)
);

const obs2$ = of({ opponent: 'Walton', team: 'varsity', gametime: new Date() },
  { opponent: 'Scott', team: 'varsity', gametime: new Date() },
  { opponent: 'Dixie', team: 'varsity', gametime: new Date() },
  { opponent: 'Highlands', team: 'freshmen', gametime: new Date() })
  .pipe(
    tap(console.log)
  );

obs2$.subscribe(a =&gt;
  console.log(a)
);
</code></pre>
","1247395","","431941","","2019-10-31 16:35:13","2019-11-03 10:59:17","rxjs 6 - Observable<Array(Objects)> to Observable<Objects>","<typescript><rxjs><observable><rxjs6>","3","0","","","","CC BY-SA 4.0"
"50606838","1","","","2018-05-30 14:08:52","","8","5478","<p>What is the best way to unsubscribe in RxJS 6?</p>

<p>My 'old' RxJS 5 code looks this</p>



<pre class=""lang-js prettyprint-override""><code>export class MyComponent implements OnInit, OnDestroy {
  private ngUnsubscribe: Subject&lt;any&gt; = new Subject();

  this.myService.myEventEmitter
    .takeUntil(this.ngUnsubscribe)
    .subscribe(this.onDataPolling.bind(this));

  public ngOnDestroy(): void {
    this.ngUnsubscribe.next();
    this.ngUnsubscribe.complete();
  }
}
</code></pre>

<p>On migration to RxJS 6 i run <code>rxjs-5-to-6-migrate</code> and got</p>

<pre class=""lang-js prettyprint-override""><code>this.myService.myEventEmitter.pipe(
  takeUntil(this.ngUnsubscribe))
  .subscribe(this.onDataPolling.bind(this));
</code></pre>

<p>but this is not working because EventEmitter has no pipe method.</p>

<p>What is the best way to unsubscribe in RxJS 6?</p>

<p><strong>Edit: This did work after a clean install and is the best way to unsubscribe in RxJS 6.</strong></p>
","5321299","","542251","","2019-12-05 09:43:33","2019-12-05 09:43:33","RxJS Migration 5 to 6 - Unsubscribe with TakeUntil","<migration><rxjs><subscription><rxjs6>","2","9","","","","CC BY-SA 4.0"
"50609904","1","","","2018-05-30 16:54:06","","2","892","<p>I am attempting to login using cordova plugins with Google Plus and Facebook. Both of these npm packages are giving me the issue:</p>

<p>core.js:1598 ERROR Error: Uncaught (in promise): TypeError: Object(...) is not a function
TypeError: Object(...) is not a function
    at index.js:245
    at Object../node_modules/@ionic-native/facebook/index.js (index.js:313)
    at <strong>webpack_require</strong> (bootstrap:81)
    at Object../src/app/services/auth.service.ts (chunk-fe7f197d.js:144)
    at <strong>webpack_require</strong> (bootstrap:81)
    at Object../src/app/pages/login/login.page.ts (pages-login-login-module.js:115)
    at <strong>webpack_require</strong> (bootstrap:81)
    at Object../src/app/pages/login/login.module.ts (pages-login-login-module.js:21)
    at <strong>webpack_require</strong> (bootstrap:81)
    at $_lazy_route_resource lazy namespace object:37
    at index.js:245
    at Object../node_modules/@ionic-native/facebook/index.js (index.js:313)
    at <strong>webpack_require</strong> (bootstrap:81)
    at Object../src/app/services/auth.service.ts (chunk-fe7f197d.js:144)
    at <strong>webpack_require</strong> (bootstrap:81)
    at Object../src/app/pages/login/login.page.ts (pages-login-login-module.js:115)
    at <strong>webpack_require</strong> (bootstrap:81)
    at Object../src/app/pages/login/login.module.ts (pages-login-login-module.js:21)
    at <strong>webpack_require</strong> (bootstrap:81)
    at $_lazy_route_resource lazy namespace object:37
    at resolvePromise (zone.js:814)
    at resolvePromise (zone.js:771)
    at zone.js:873
    at ZoneDelegate.push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invokeTask (zone.js:421)
    at Object.onInvokeTask (core.js:4053)
    at ZoneDelegate.push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invokeTask (zone.js:420)
    at Zone.push../node_modules/zone.js/dist/zone.js.Zone.runTask (zone.js:188)</p>

<p>My Info is:</p>

<p>@ionic/cli-utils  : 2.0.0-rc.6
   ionic (Ionic CLI) : 4.0.0-rc.6</p>

<p>global packages:</p>

<p>cordova (Cordova CLI) : 8.0.0</p>

<p>local packages:</p>

<p>@angular-devkit/core       : 0.6.0
   @angular-devkit/schematics : 0.6.0
   @angular/cli               : 6.0.1
   @ionic/schematics-angular  : 1.0.0-rc.6
   Cordova Platforms          : none
   Ionic Framework            : @ionic/angular 4.0.0-alpha.7</p>

<p>System:</p>

<p>Android SDK Tools : 26.1.1
   NodeJS            : v8.9.4
   npm               : 6.1.0
   OS                : Windows 10</p>

<p>Environment Variables:</p>

<p>ANDROID_HOME : D:\SumTech Solutions\Software\Android_SDK</p>

<p>This becomes an issue only when i add the Imports to the constructor in my auth.service.</p>
","7511732","","","","","2018-07-30 13:25:01","Ionic-Native, Angular 6, Ionic 4 - Facebook and Google Signin Issue - Object not a Function","<facebook><google-plus><angular6><rxjs6><ionic4>","1","1","","","","CC BY-SA 4.0"
"50616485","1","50616598","","2018-05-31 04:05:30","","1","305","<p>Recently i came to know about forkJoin where we could combine multiple http calls and make the code neater. But for some reason I get a red squiggly under the forkJoin part.
I have imported the observable this way</p>

<pre><code>import { Observable } from 'rxjs';
</code></pre>

<p>And this is how I am using forkJoin
<a href=""https://i.stack.imgur.com/ftJLj.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ftJLj.jpg"" alt=""enter image description here""></a></p>
","3826733","","","","","2018-05-31 05:18:20","Observable.forkJoin shows a squiggly under forkJoin","<angular><rxjs6>","2","4","","","","CC BY-SA 4.0"
"50619337","1","50619402","","2018-05-31 07:52:39","","1","3057","<p>I have the data pull perfectly working, but cannot get the reload work after a new record is added. According to my knowledge, whenever a next method is called on a behaviorsubject all the observers would get notified of it and data reload would happen autmatically. But not happening that way.</p>

<p>Component.ts</p>

<pre><code>dataSource = new MatTableDataSource&lt;IWorkOrders&gt;();
  ngOnInit() {
    this.bs.wobSubject$.subscribe((data:IWorkOrders[]) =&gt; {
      this.dataSource.data = data;
    })
</code></pre>

<p>Here is the code called to post a new record</p>

<pre><code>this.bs.postWorkOrder(this.saleForm.value);
</code></pre>

<p>Service.ts</p>

<pre><code>      public wobSubject$ = new BehaviorSubject&lt;IWorkOrders[]&gt;([]);
    constructor(private http: HttpClient) {
     this.getWorkOrder(); 
    }
      getWorkOrder() {
        this.http.get(this.BASE_URL + '/getworkorders/')
        .subscribe((data:IWorkOrders[]) =&gt; {
          this.wobSubject$.next(data);
        });
      }
  postWorkOrder(workOrder: IWorkOrders) {
    this.http.post&lt;IWorkOrders&gt;(this.BASE_URL + '/addworkorder/', workOrder)
    .subscribe((data: any) =&gt; {
      this.wobSubject$.next(data);
    });
  }
</code></pre>
","3826733","","","","","2018-05-31 08:34:18","MatTableDataSource - how to refresh table when a new record is added to the server","<angular><angular-material><rxjs6>","2","0","","","","CC BY-SA 4.0"
"50637264","1","","","2018-06-01 06:26:34","","1","111","<p>I am listening to socket with Observable and subscribing it in one of my component. If I don't unsubscribe it in <code>ngOnDestroy</code>, when I go to that component again it will fire N times(N being the number of times I switch back to that component) but if I unsubscribe it in <code>ngOnDestroy</code> then it will listen first time I go to that component and when I go to other component and return back, it will not fire.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>//in socket service
updateOrder() {
  if (!this.socket.connected)
    this.socket.connect();
  let observable = new Observable &lt; any &gt; (observer =&gt; {
    this.socket.on('test', (data) =&gt; {
      observer.next(data); //going into here
    });
    return () =&gt; {
      this.socket.disconnect();
    };
  })
  return observable;
}</code></pre>
</div>
</div>
</p>

<p>In constructor of listening component</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>this.orderSubscriber = this.socketService.updateOrder().subscribe(data =&gt; {
  console.log('socket fired', data);
})</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>ngOnDestroy() {
  this.orderSubscriber.unsubscribe();
}</code></pre>
</div>
</div>
</p>
","8536856","","8536856","","2018-06-04 07:53:01","2018-06-04 08:32:59","Angular Rxjs observable wont fire again after unsubscribed","<angular><socket.io><rxjs6>","1","7","","","","CC BY-SA 4.0"
"50640570","1","","","2018-06-01 09:43:06","","1","188","<p>I was <a href=""https://github.com/ReactiveX/rxjs/issues/3379#issuecomment-393567067"" rel=""nofollow noreferrer""><em>told</em></a> by Ben Lesh that  in rxjs6 ,  weh shouldn't do : </p>

<p><code>import { Observable } from 'rxjs/Observable';</code></p>

<p>But </p>

<pre><code>import { Observable } from 'rxjs';
</code></pre>

<p>Also for operators : </p>

<pre><code>import {first, skipWhile}      from ""rxjs/operators"";
</code></pre>

<p>So I've changed my proj to v6 .</p>

<p>Here are the usages : </p>

<p><a href=""https://i.stack.imgur.com/zVERO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zVERO.png"" alt=""enter image description here""></a></p>

<p>But look how many operators are in the bundle :</p>

<p><a href=""https://i.imgur.com/UFcWvjJ.jpg"" rel=""nofollow noreferrer""><img src=""https://i.imgur.com/UFcWvjJ.jpg"" alt=""enter image description here""></a></p>

<pre><code>* Operator exports */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
export { audit } from '../internal/operators/audit';
export { auditTime } from '../internal/operators/auditTime';
export { buffer } from '../internal/operators/buffer';
export { bufferCount } from '../internal/operators/bufferCount';
...
...
</code></pre>

<p><a href=""https://pastebin.com/ZqpfV6pX"" rel=""nofollow noreferrer"">Full list is here</a> </p>

<p><strong>Question:</strong></p>

<p>Why is that ? Am I importing the operators incorrectly ? And why do I see all those unused operators ?</p>

<p><a href=""https://gist.github.com/RoyiNamir/fbf49b7083d337425da932f1e45fd8f0"" rel=""nofollow noreferrer"">webpack file</a> </p>
","859154","","859154","","2018-06-01 15:42:35","2018-06-01 15:42:35","RXJS v6 loads many unnecessary modules?","<javascript><rxjs><rxjs6>","0","0","","","","CC BY-SA 4.0"
"50642509","1","50642826","","2018-06-01 11:33:35","","2","1065","<p>After migrating rxjs from v5 to v6 I experience an error when using mergeMap: </p>

<pre><code>of('foobar').pipe(
  mergeMap(() =&gt; of('baz'))
).subscribe(console.log);  
</code></pre>

<p>Error:</p>

<pre><code>core.js:1598 ERROR TypeError: You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at Object.push../node_modules/rxjs/internal/util/subscribeTo.js.exports.subscribeTo (subscribeTo.js:42)
    at Object.subscribeToResult (subscribeToResult.js:7)
    at MergeMapSubscriber.push../node_modules/rxjs/internal/operators/mergeMap.js.MergeMapSubscriber._innerSub (mergeMap.js:132)
    at MergeMapSubscriber.push../node_modules/rxjs/internal/operators/mergeMap.js.MergeMapSubscriber._tryNext (mergeMap.js:129)
    at MergeMapSubscriber.push../node_modules/rxjs/internal/operators/mergeMap.js.MergeMapSubscriber._next (mergeMap.js:112)
    at MergeMapSubscriber.push../node_modules/rxjs/internal/Subscriber.js.Subscriber.next (Subscriber.js:103)
    at Observable._subscribe (scalar.js:5)
    at Observable.push../node_modules/rxjs/_esm5/internal/Observable.js.Observable._trySubscribe (Observable.js:176)
    at Observable.push../node_modules/rxjs/_esm5/internal/Observable.js.Observable.subscribe (Observable.js:161)
    at MergeMapOperator.push../node_modules/rxjs/internal/operators/mergeMap.js.MergeMapOperator.call (mergeMap.js:87)
</code></pre>

<p><code>of('baz')</code> is a stream, right? So why do I get this error? </p>
","401025","","","","","2018-06-01 11:52:26","mergeMap throws 'invalid object where a stream was expected' error in rxjs6","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"50653455","1","","","2018-06-02 04:16:49","","10","2502","<p>I have an angular material select component and I would like to bind the selected value of the dropdown to an Observable of scalar from firebase. I would like to do this without unwrapping the observable in component. It looks I cannot bind the value using async pipe. The code below throws an exception because the value of mat-select cannot be bound to ""uiStateSvc.currentClient$ | async"".</p>

<pre><code>&lt;mat-form-field *ngIf=""(store.authorizedClients$ | async)?.length &gt; 0""&gt;
  &lt;mat-select [(value)]=""uiStateSvc.currentClient$ | async"" [compareWith]=""compareFn""&gt;
    &lt;mat-option *ngFor=""let client of store.authorizedClients$ | async"" [value]=""client""
    (onSelectionChange)=""changeCurrentClient($event, client)""&gt;
      {{ client.name}}
    &lt;/mat-option&gt;
  &lt;/mat-select&gt;
&lt;/mat-form-field&gt;
</code></pre>

<p>I am pulling the current selected value of the dropdown from firebase like so:</p>

<pre><code>this.selectedClient$ = this.authSvc.currentUser$.pipe(
      switchMap((x: firebase.User) =&gt; {
        if (x != null) {
          return this.afs.doc(`uistate/${x.uid}`).valueChanges().map((y: any) =&gt; y.selectedclient);
        } else {
          return Observable.of(null);
        }
      })
    );
</code></pre>
","2202866","","","","","2020-12-14 00:14:05","How to bind the selected value of angular dropdown to an Observable of scalar value?","<angular><firebase><observable><angularfire2><rxjs6>","1","0","0","","","CC BY-SA 4.0"
"50661988","1","","","2018-06-02 23:16:42","","0","320","<p>I updated to Angular 6. Did not install rxjs-compat.
Change in my code</p>

<pre><code>import {Observable} from ""rxjs/Observable"";
</code></pre>

<p>to</p>

<pre><code>import {Observable} from ""rxjs"";
</code></pre>

<p>and so on.
<br>But if I do ng serve I get an error</p>

<pre><code>ERROR in node_modules/primeng/components/accordion/accordion.d.ts(4,10): error TS2305: Module '""../JetBrains/WebstormProjects/test5/node_modules/rxjs/Subscription""' has no exported member 'Subscription'.
node_modules/primeng/components/common/confirmationservice.d.ts(1,10): error TS2305: Module '""../JetBrains/WebstormProjects/test5/node_modules/rxjs/Observable""' has no exported member 'Observable'.
node_modules/primeng/components/common/messageservice.d.ts(1,10): error TS2305: Module '"".../JetBrains/WebstormProjects/test5/node_modules/rxjs/Observable""' has no exported member 'Observable'.
...
</code></pre>

<p>and so on.
<br>How to fix these errors?</p>
","9431624","","","","","2019-08-01 12:04:33","RxJS v6 migration, I don't understand what wrong?","<angular><rxjs6>","1","4","","","","CC BY-SA 4.0"
"50662530","1","50663017","","2018-06-03 01:21:41","","3","749","<p>let is something that existed in the past can see it <a href=""https://www.learnrxjs.io/operators/utility/let.html"" rel=""nofollow noreferrer"">here in action</a> </p>

<p>I don't see it in either rxjs or rxjs/operators</p>

<p>nor do I see it inside what appears to be the <a href=""https://rxjs-dev.firebaseapp.com/api?query=let"" rel=""nofollow noreferrer"">RxJS docs</a></p>

<p>Assuming it did exist, I figured this would've worked since it's meant to be an observable</p>

<pre><code>import {interval, let} from 'rxjs';

interval(1000).pipe(
  let(source =&gt; interval(1000))
)
.subscribe(a=&gt;console.log(a));
</code></pre>
","1879665","","1879665","","2018-06-03 01:28:17","2018-06-03 03:34:28","Does let exist in rxjs6?","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"50666669","1","","","2018-06-03 12:58:06","","2","5077","<p>In below code, my country select options are fired so many times that browser stopped responding.</p>

<pre><code>&lt;div [formGroup]=""countryForm""&gt;
  &lt;mat-form-field&gt;
    &lt;mat-select formControlName=""selectedCountry"" class=""my-item-text"" placeholder=""Country""&gt;
      &lt;mat-option (onSelectionChange)=""onCountrySelectionChanged($event)"" *ngFor=""let myCountry of countries"" [value]=""myCountry.short"" class=""my-item-text""&gt;{{ myCountry.name }}
      &lt;/mat-option&gt;
    &lt;/mat-select&gt;
  &lt;/mat-form-field&gt;
&lt;/div&gt;
</code></pre>

<p>and my component code as below</p>

<pre><code>  onCountrySelectionChanged(changeEvent) {
    if (changeEvent &amp;&amp; changeEvent.isUserInput &amp;&amp; this.selectedCountry != changeEvent.source.value) {
      this.countrySelected.emit( changeEvent.source.value);
    }
  }
</code></pre>

<p>I tried to restrict by checking if its user change event [isUserInput] and also checking if the value really changed! Now am able to reduce the fire-events and the application works normal.</p>

<p>Is there a better way to use select-option as am now including above logic everywhere am using mat-select component.</p>
","3126520","","","","","2018-06-04 11:07:51","After upgrading to Angular 6, material 6, select option event fired continuously and browser hangs. How to stop unwanted emit events?","<angular-material><angular-material2><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50666963","1","","","2018-06-03 13:34:19","","0","83","<p>Consider the following code that getting an entity and load the relevant model for each ID property (Load the foreign keys objects) :</p>

<pre><code>if (!lazyLoad) {
    return this.http.get(`${environment.endpoint}/file`, {
          params: params
        }).pipe(
          mergeMap(res =&gt; this.loadModel(res, 'prop1ID')),
          mergeMap(res =&gt; this.loadModel(res, 'prop2ID')),
          mergeMap(res =&gt; this.loadModel(res, 'prop2ID'))
        )
      }
}
</code></pre>

<p>the first merge working, the second get <code>undefind</code>.
tried to read about <code>merge</code> and <code>mergeAll</code> with no success.</p>

<p>the object from <code>http</code> request looks like:</p>

<pre><code>{
        id: '1',
        name: 'user',
        prop1ID: 34,
        prop2ID: 44,
        prop3ID: 54
}
</code></pre>

<p>After those 3 actions i want it to look like (with help of <code>loadModel()</code> function):</p>

<pre><code>{
        id: '1',
        name: 'user',
        prop1ID: 34,
        prop1IDModel: { ... },
        prop2ID: 44,
        prop2IDModel: { ... },
        prop3ID: 54
        prop3IDModel: { ... },
}
</code></pre>

<p>My <code>loadModel</code> function:</p>

<pre><code>private loadModel(entity, modelProperty): Observable&lt;object&gt; {
    switch (modelProperty) {
      case 'prop1ID':
          this.generalService.getProp1ID(entity.prop1ID).subscribe((data) =&gt; {
            entity.prop1IDModel = data;
            return of(entity);
          });
        break;
      case 'prop2ID':
        ...
        break;
      case 'prop3ID':
        ...
        break;
      default:
        return of(entity);
    }
  }
</code></pre>
","1727357","","1727357","","2018-06-03 13:50:07","2018-06-04 09:29:06","Combine obserables rxjs 5.5+","<typescript><rxjs><angular6><rxjs6>","1","5","","","","CC BY-SA 4.0"
"50667835","1","","","2018-06-03 15:06:50","","1","398","<p>Before the update, I used this function for getting user data from firestore service on user login state changing:</p>

<pre><code>constructor(private firebaseAuth: AngularFireAuth,
              private db: AngularFirestore,
              private router: Router,
              private firestoreService: FirestoreService) {
    this.user = firebaseAuth.authState;
    this.auth = this.firebaseAuth;

    this.user.map(user =&gt; {
      console.log('user subscribing', user);

      if (isNullOrUndefined(user))
        return Observable.empty();

      this.userUID = user.uid;
      this.userEmail = user.email;

      return this.firestoreService.GetCollection('employees', true, ref =&gt; ref.where('uid', '==', user.uid)); // return Observable&lt;any[]&gt; 
    }).mergeAll().subscribe(
           ..working with user data
        }
      }
    );
  }
</code></pre>

<p>Now I'm trying to remake it in RxJS 6, but it not working:</p>

<pre><code>firebaseAuth.authState.pipe(
      switchMap(user =&gt; {

      if (isNullOrUndefined(user)) {
        return EMPTY;
      }

      this.userUID = user.uid;
      this.userEmail = user.email;

      return this.firestoreService.GetCollection('/employees', false, ref =&gt; ref.where('uid', '==', this.userUID));
    }),
      mergeAll()
    )
      .subscribe(
           ..working with user data
        }
      }
    );
</code></pre>

<p>What's wrong?</p>
","6246455","","7685107","","2018-06-03 15:11:39","2018-06-05 01:25:05","Migrate to RxJs 6 and Angular 6, help me understand the changes of RxJs","<angular6><rxjs6>","0","1","","","","CC BY-SA 4.0"
"50693706","1","","","2018-06-05 06:45:31","","0","33","<p>So I currently have the following code that waits for the input element to finish typing which then does an ajax.</p>

<p>input = input element e.g. <code>&lt;input&gt;</code><br>
axiosAjax = just my ajax</p>

<pre><code>fromEvent(input, ""keyup"")
    .pipe(
        map(i =&gt; i.currentTarget.value),
        debounceTime(delay),
        distinctUntilChanged(),
        switchMap(value =&gt; 
        {
            this.page = 1
            return this.axiosAjax({
                path,
                method,
                data: {
                    ...data,
                    [term]: value
                }
            })
        })
    )
</code></pre>

<p>I'm trying to move the ajax out of the switchMap so that I can call an ajax outside of this function. E.g. <code>.subscribe( () =&gt; this.aDifferentAjax() )</code>. However, I'd still like to maintain the ability to discard older ajaxes. </p>

<p>How should I go about this?</p>

<p>Maybe looks something like this:</p>

<pre><code>fromEvent(input, ""keyup"")
    .pipe(
        map(i =&gt; i.currentTarget.value),
        debounceTime(delay),
        distinctUntilChanged(),
        switchMap(value =&gt; 
        {
            this.page = 1
            return value
        })
    )
    .subscribe(
        () =&gt; this.aDifferentAjax()
        // ^This ajax can be discarded if new input is detected
    )
</code></pre>
","6554121","","6554121","","2018-06-05 14:15:04","2018-06-05 14:15:04","using a subscribed return value to create subscribable promises","<javascript><rxjs><rxjs6>","0","2","","","","CC BY-SA 4.0"
"50712133","1","50732928","","2018-06-06 04:09:00","","0","330","<p>I have the following code in Angular 6, that worked fine before.  </p>

<pre><code> getNavigation(db): any {
    return db.list('/pages', ref =&gt; {
        let query = ref.limitToLast(100).orderByChild('sortOrder');
        return query;
    }).snapshotChanges().map(changes =&gt; {
        return changes.map(change =&gt; ({key: change.payload.key, ...change.payload.val()}));
    });
}
</code></pre>

<p>Suddenly, with some recent library update (rxjs ??)  it throws an error?   What syntax has changed that suddenly broke my code? </p>

<blockquote>
  <p>ERROR TypeError: db.list(...).snapshotChanges(...).map is not a
  function
      at NavigationComponent.push../src/app/navigation.component.ts.NavigationComponent.getNavigation</p>
</blockquote>

<p>Or more importantly, how do I fix it? :-(</p>
","3389346","","3389346","","2018-06-07 04:29:39","2018-06-07 04:29:39","Was there a recent breaking change in RXJS?","<rxjs><angularfire2><angular6><rxjs6>","2","6","","","","CC BY-SA 4.0"
"50730598","1","50730665","","2018-06-06 22:40:19","","3","3278","<p>Went from angular 5 to 6(using angular 6 &amp; rxjs 6), getting the following two errors in my linter. Anybody have any ideas, please and thank you.</p>

<pre><code>[ts] 'catchError' is declared but its value is never read.
[ts] Property 'catchError' does not exist on type 'Observable&lt;HttpEvent&lt;any&gt;&gt;'.
</code></pre>

<pre class=""lang-ts prettyprint-override""><code>import { Injectable, Injector } from '@angular/core';
import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';
import { catchError } from 'rxjs/operators';
import { Observable } from 'rxjs';



@Injectable()
export class HttpInterceptorService implements HttpInterceptor {
  constructor() { }

  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

    return next.handle(authReq)
      .catchError((error, caught) =&gt; {
        console.log('Error Occurred');
        console.log(error);
        return Observable.throw(error);
      }) as any;
  }
}
</code></pre>


","4812515","","","","","2018-06-06 22:48:34","Property 'catchError' does not exist on type 'Observable<HttpEvent<any>>'","<angular><typescript><rxjs><observable><rxjs6>","1","1","","","","CC BY-SA 4.0"
"50730763","1","50731612","","2018-06-06 22:58:33","","1","68","<p>I have this piece of code where I am trying to capture all the drag events. This code works only for the first drag and stop will not work for successive drags.</p>

<p>Is it because takeUntil cancelling the outer observable? How can I make the code work.</p>

<pre><code>const { Observable, fromEvent } = rxjs;
const { takeUntil, switchMap } = rxjs.operators;

const mouseups = fromEvent(document.querySelector('.container'), 
'mouseup'); 
const mousedowns = fromEvent(document.querySelector('.container'), 
'mousedown');
const mousemoves = fromEvent(document.querySelector('.container'), 
'mousemove');

const source = mousedowns.pipe(
  switchMap(e =&gt; mousemoves),
  takeUntil(mouseups)
);

source.subscribe(e =&gt; console.log(e));
</code></pre>
","2550802","","","","","2018-06-07 01:05:28","RXJS: Capture drag events not working after first drag","<javascript><rxjs><reactive-programming><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50751254","1","50751264","","2018-06-07 23:01:31","","21","17055","<p>Just moved from rxjs 5/angular 5 to rxjs 6/ angular 6, went through this <a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md"" rel=""noreferrer"">migration-guide</a>. Can't seem to figure out what it should be now, any help appreciated.</p>

<pre class=""lang-js prettyprint-override""><code>import { Observable, of } from 'rxjs';
[ts] 'of' is declared but its value is never read.

// trivial example of what im trying to replace
  isLoggedIn(): Observable&lt;boolean&gt; {
    return Observable.of(true);
  }
</code></pre>


","4812515","","4812515","","2018-06-07 23:05:18","2020-04-17 12:14:52","rxjs 6 Property 'of' does not exist on type 'typeof Observable'","<angular><rxjs><rxjs6>","2","0","3","","","CC BY-SA 4.0"
"50752237","1","50752619","","2018-06-08 01:44:39","","2","2657","<p>I've tried:</p>

<pre><code>import { Observable } from 'rxjs/Observable';
</code></pre>

<p>which gives me the error:</p>

<blockquote>
  <p>node_modules/rxjs/Obserable has no exported member 'Observable'</p>
</blockquote>

<p>and I've tried:</p>

<pre><code>import { Observable } from 'rxjs';
</code></pre>

<p>which gives me the TSLINT error:</p>

<blockquote>
  <p>This import is blacklisted</p>
</blockquote>

<p>I know I can fix this by removing the 'rxjs' <code>import-blacklist</code> entry from tslint.json but I don't want to do that. I'm sure its there for a good reason. How do I correctly do the import? thanks</p>

<p>EDIT: Changed to capital O - see comment</p>
","1205871","","1205871","","2018-06-08 02:55:14","2018-06-08 02:57:50","rxjs Observable import issue","<angular><typescript><rxjs><tslint><rxjs6>","1","2","","","","CC BY-SA 4.0"
"50759384","1","","","2018-06-08 11:12:58","","0","1089","<p>I have updated my app from Angular 5 to Angular 6, and also I had to update rxjs from 5 to 6. I used this <a href=""https://github.com/ReactiveX/rxjs-tslint"" rel=""nofollow noreferrer"">LINK</a>.</p>

<p>In my code I have: <code>Observable.of(years)</code> and I've changed imports from this: <code>import ""rxjs/add/observable/of"";</code> to this:  <code>import { Observable, of } from ""rxjs"";</code> and still <code>of</code> cannot be found. </p>

<p>I have an error: <code>Property 'of' does not exist on type 'typeof Observable'</code></p>
","5515945","","","","","2018-06-08 11:23:05","Observable 'of' not exist after update rxjs5 > 6 in Angular 6","<angular><rxjs><angular6><rxjs6>","1","3","","2018-06-08 11:21:02","","CC BY-SA 4.0"
"50759469","1","50770564","","2018-06-08 11:17:01","","12","6362","<p>We've recently updated from Angular 5 to Angular 6, and with it RxJs 6.
As part of the migration, the timer usage has changed from:</p>

<pre><code>Observable.timer()
</code></pre>

<p>to</p>

<pre><code>timer()
</code></pre>

<p>There are a number of places in our tests where we mock timer observables with the following pattern.</p>

<pre><code>let timerObserver: Observer&lt;any&gt;;

 beforeEach(() =&gt; {
 spyOn(Observable, 'timer').and.returnValue(Observable.create(
    ((observer: Observer&lt;any&gt;) =&gt; {
      timerObserver  = observer;
    })
  ));
});

it(`should not have any notifications by default`, () =&gt; {
   timerObserver.next('');
   ...
});
</code></pre>

<p>Does anybody know how to migrate this pattern across?</p>

<hr>

<p><strong>Edit:</strong> I've created a simplified illustration of the problem here:</p>

<p><a href=""https://stackblitz.com/edit/angular-v6-testing-template-nm7add"" rel=""noreferrer"">https://stackblitz.com/edit/angular-v6-testing-template-nm7add</a></p>

<pre><code>// Hello.Component
      ngOnInit() {
        const timer$ = timer(30);
        timer$.subscribe(() =&gt; {
          this.testMe = 'this has been changed';
        });
      }

// Hello.component.spec
  it('should set testMe after a given timer', fakeAsync(() =&gt; {
    tick(50);
    expect(fixture.componentInstance.testMe).toBe('this has been changed');
  }));
</code></pre>

<p>In this example, I'm trying to get timer to trigger without waiting for the timer to resolve.</p>
","5801657","","5801657","","2018-06-08 15:07:31","2018-08-20 07:43:19","How do I mock RxJs 6 timer?","<angular><jasmine><rxjs6>","1","3","3","","","CC BY-SA 4.0"
"50761948","1","50906676","","2018-06-08 13:39:54","","3","4268","<p><strong>EDIT: described bug is gone in version 6.2.1</strong></p>

<p>I migrated a Project from rxjs5 to rxjs6 with the (well working(!)) migration tool in the rxjs-tslint package. In some cases my error handling, which works fine before, didn't catch the error anymore.</p>

<p>Is there anything new about scoping and/or error propagation when using switchMap? And how can I catch the error again?</p>

<p>Here is a working example</p>

<pre><code>Rx.of(undefined).pipe(
  tap(() =&gt; console.log(""WORKING"")),
  mergeMap(boom =&gt; boom),
  catchError(err =&gt; Rx.throwError(""ERROR CATCHED""))
).subscribe((data) =&gt; {
  console.log(data);
},(err) =&gt; {
  console.log(""ERROR:"", err);
})
</code></pre>

<p>Output:</p>

<pre><code>WORKING
ERROR: ERROR CATCHED
</code></pre>

<p>Not working example:</p>

<pre><code>Rx.of(""foo"").pipe(
  switchMap(() =&gt; Rx.of(undefined).pipe(
    tap(() =&gt; console.log(""NOT WORKING"")),
    mergeMap(boom =&gt; boom),
    catchError(err =&gt; Rx.throwError(""ERROR NOT CATCHED""))
  ))
).subscribe((data) =&gt; {
  console.log(data);
},(err) =&gt; {
  console.log(""ERROR:"", err);
})
</code></pre>

<p>Output:</p>

<pre><code>NOT WORKING
ERROR: TypeError: You provided 'undefined' where a stream was expected.
       You can provide an Observable, Promise, Array, or Iterable.
</code></pre>
","1280664","","1280664","","2018-06-18 10:15:55","2018-06-18 10:15:55","rxjs6 error handling when using switchMap","<rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"50778297","1","","","2018-06-09 20:32:43","","1","182","<p>I was wondering... How should I use fetch or aws-amplify Auth.sigIn instead of ajax with redux-observable?</p>

<p>Running the following create-react-app based code below I am hitting the following error:</p>

<pre><code>TypeError: __WEBPACK_IMPORTED_MODULE_2_rxjs__.a.from is not a function
</code></pre>

<p><a href=""https://i.stack.imgur.com/7UOQq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7UOQq.png"" alt=""error""></a></p>

<p>The App that I am currently extending uses the following packages and redux approach:</p>

<p><strong>package.json</strong></p>

<pre><code>...
    ""redux"": ""^4.0.0-rc.1"",
    ""redux-observable"": ""^1.0.0-beta.1"",
    ""rxjs"": ""^6.2.0"",
    ""rxjs-compat"": ""^6.2.0"",
    ""styled-components"": ""^3.3.2""
...
</code></pre>

<p><strong>types.js</strong></p>

<pre><code>export default {
  LOGIN_REQUEST: 'LOGIN_REQUEST',
  LOGIN_SUCCESS: 'LOGIN_SUCCESS',
  LOGIN_FAILURE: 'LOGIN_FAILURE',
};
</code></pre>

<p><strong>actions.js</strong></p>

<pre><code>import Types from './types';

export const loginRequest = (payload) =&gt; ({
  type: Types.LOGIN_REQUEST,
  payload,
});

export const loginSuccess = (payload) =&gt; ({
  type: Types.LOGIN_SUCCESS,
  payload,
});

export const loginFailure = (payload) =&gt; ({
  type: Types.LOGIN_FAILURE,
  payload,
});
</code></pre>

<p><strong>epics.js</strong></p>

<pre><code>import { ajax } from 'rxjs/observable/dom/ajax';
import { ofType } from 'redux-observable';
import { Observable, from } from 'rxjs';
import { catchError, mergeMap, switchMap, map } from 'rxjs/operators';

import { Auth } from 'aws-amplify';

import Types from './types';

const loginSuccess = payload =&gt; ({
  type: Types.LOGIN_SUCCESS,
  payload,
});

const loginFailure = payload =&gt; ({
  type: Types.LOGIN_FAILURE,
  payload,
});

const api = {
  signIn: (username, password) =&gt; {
    const request = Auth.signIn(username, password)
      .then(user =&gt; user.json())
      .catch(err =&gt; err);

    return Observable.from(request);
  }
};

const loginRequest = (action$, state$) =&gt;
    action$.pipe(
    ofType(Types.LOGIN_REQUEST),
    mergeMap(action =&gt; {
      console.log('===&gt; Epic - action.payload', action.payload);
      // This returns our Observable wrapping the Promise.
      return api.signIn(action.payload.username, action.payload.password)
        .map(payload =&gt; ({ type: Types.LOGIN_SUCCESS, payload }))
        .catchError(payload =&gt; ({ type: Types.LOGIN_FAILURE, payload }))
    })
  );

export default loginRequest;
</code></pre>

<p><strong>Signin.js</strong></p>

<pre><code>import React, { Component } from 'react';
import { bindActionCreators, compose } from 'redux';
import { connect } from 'react-redux';

import classNames from 'classnames';
import PropTypes from 'prop-types';

import { Auth } from 'aws-amplify';

import { withStyles } from '@material-ui/core/styles';
import Button from '@material-ui/core/Button';
import IconButton from '@material-ui/core/IconButton';
import Input from '@material-ui/core/Input';
import InputLabel from '@material-ui/core/InputLabel';
import InputAdornment from '@material-ui/core/InputAdornment';
import FormHelperText from '@material-ui/core/FormHelperText';
import FormControl from '@material-ui/core/FormControl';
import TextField from '@material-ui/core/TextField';
import Visibility from '@material-ui/icons/Visibility';
import VisibilityOff from '@material-ui/icons/VisibilityOff';

import { loginRequest } from './redux/actions';

const styles = theme =&gt; ({
  root: {
    display: 'flex',
    flexWrap: 'wrap',
  },
  margin: {
    margin: theme.spacing.unit,
  },
  withoutLabel: {
    marginTop: theme.spacing.unit * 3,
  },
  textField: {
    flexBasis: 200,
  },
});

class SignIn extends Component {
  static propTypes = {
    auth: PropTypes.object,
    classes: PropTypes.object,
    data: PropTypes.array,
    isLoading: PropTypes.bool,
    loginRequest: PropTypes.func,
  }

  handleChange = prop =&gt; event =&gt; {
    this.setState({ [prop]: event.target.value });
  }

  handleMouseDownPassword = event =&gt; {
    event.preventDefault();
  }

  handleClickShowPassword = () =&gt; {
    this.setState({ showPassword: !this.state.showPassword });
  }

  handleSubmit = event =&gt; {
    event.preventDefault();

    console.log('handleSubmit - this.state', this.state);

    const payload = {
      username: this.state.username,
      pasword: this.state.password,
    }

    console.log('handleSubmit - payload', payload);

    this.props.loginRequest(payload);
  }

  state = {
    username: '',
    password: '',
    showPassword: false,
  }

  render() {
    const {
      auth,
      classes,
      data,
      isLoading,
    } = this.props

    return(
      &lt;form
        noValidate
        autoComplete=""off""
        onSubmit={(e) =&gt; { this.handleSubmit(e) } }
      &gt;
        &lt;TextField
          id=""username""
          label=""Username""
          onChange={this.handleChange('username')}
          value={this.state.username}
          margin=""normal""
        /&gt;
        &lt;FormControl className={classNames(classes.margin, classes.textField)}&gt;
          &lt;InputLabel htmlFor=""password""&gt;Password&lt;/InputLabel&gt;
          &lt;Input
            id=""password""
            type={this.state.showPassword ? 'text' : 'password'}
            value={this.state.password}
            onChange={this.handleChange('password')}
            endAdornment={
              &lt;InputAdornment position=""end""&gt;
                &lt;IconButton
                  onClick={this.handleClickShowPassword}
                  onMouseDown={this.handleMouseDownPassword}
                &gt;
                  {this.state.showPassword ? &lt;VisibilityOff /&gt; : &lt;Visibility /&gt;}
                &lt;/IconButton&gt;
              &lt;/InputAdornment&gt;
            }
          /&gt;
        &lt;/FormControl&gt;
        &lt;Button
          variant=""contained""
          color=""primary""
          type=""submit""
          label=""Submit""
          className={classes.button}
        &gt;
          Login
        &lt;/Button&gt;
      &lt;/form&gt;
    )
  }
}

const mapDispatchToProps = dispatch =&gt; (
  bindActionCreators({ loginRequest }, dispatch)
);

const mapStateToProps = state =&gt; ({
  auth: state.auth,
  data: state.user.data,
  isLoading: state.user.isLoading,
});

export default compose(withStyles(styles, { name: 'SignIn' }), connect(mapStateToProps, mapDispatchToProps))(SignIn);
</code></pre>

<p>Useful resources:</p>

<ul>
<li><p><a href=""https://stackoverflow.com/questions/38589383/use-fetch-instead-of-ajax-with-redux-observable"">Use fetch instead of ajax with redux-observable</a></p></li>
<li><p><a href=""https://medium.com/dailyjs/using-redux-observable-to-handle-asynchronous-logic-in-redux-d49194742522"" rel=""nofollow noreferrer"">https://medium.com/dailyjs/using-redux-observable-to-handle-asynchronous-logic-in-redux-d49194742522</a></p></li>
</ul>

<p>Thanks!</p>
","547908","","547908","","2018-06-09 21:06:10","2018-06-09 21:06:10","How should I use aws-amplify Auth.sigIn instead of ajax with redux-observable and rxjs 6?","<javascript><rxjs><redux-observable><rxjs6>","0","0","","","","CC BY-SA 4.0"
"50780809","1","","","2018-06-10 05:26:30","","1","614","<p>I'm trying to use flatMap in order to fulfill requests one by one using result of the first request in the second one. Via debugger i do see that reach first service, but not the second one. What's wrong?
Thanx in advance!</p>

<pre><code>resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable &lt; MedicalCheckup[] &gt; {
  return this.appStateService.getSelectedPatient()
    .pipe(flatMap(
      patient =&gt;
      this.examinationService.getExaminations(patient.id, ExaminationsSelectionPeriod.THREE_MONTHS.toString())
    ));
}
</code></pre>
","6151279","","2622292","","2018-08-26 17:25:47","2018-08-26 17:25:47","angular 6 issue uisng flatMap. What's wrong?","<angular><rxjs6>","0","4","","","","CC BY-SA 4.0"
"50782949","1","50783005","","2018-06-10 10:56:01","","0","2721","<p>I am using Angular 6 and I want to check a variable for changes and the stop or unsubscribe when the variable has a value.</p>

<p>So I was thinking of an Observable:</p>

<pre><code>myValue; // variable to be checked

myObservable = Observable.timer(2000); // every 2 seconds

myObservable.subscribe(); // start
</code></pre>

<p>Then keep checking myValue and if the value is not empty</p>

<pre><code>myObservable.unsubscribe(); // stop
</code></pre>

<p>This is the idea anyway...</p>

<p>How can I do this?</p>
","","user9855223","","","","2018-06-10 11:03:01","Angular 6 Create an observable to check a variable for change","<angular><typescript><rxjs><angular6><rxjs6>","1","5","","","","CC BY-SA 4.0"
"50791260","1","","","2018-06-11 05:58:29","","2","2149","<p>I have @ngrx entities based on following models:</p>

<pre><code>export interface Product {
  id: number;
  code: string;
  text: string;
  brand: any;
  quantity_available: number;
  rate: number;
  // ... other variables
}

export interface BasketProduct {
  id: number; /*Product ID*/
  quantity: number;
  rate: number;
  value: number;
}
</code></pre>

<p>I store the user's profile in the Settings state, and the selected filters (coming from UI) in the products state:</p>

<pre><code>export interface State extends EntityState&lt;Setting&gt; {
  // additional properties here
  user: {
    currency: {
      code: string,
      name: string,
    }
  };
}

export interface State extends EntityState&lt;Product&gt; {
  // additional properties here
  filters: {
    just_arrived: boolean;
    newly_launched: boolean;
    discounted: boolean;
    celebrity: boolean;
    niche: boolean;
    wish_list: boolean;
    search_text: string;
    brands;
    product_types;
    parent_companies;
  };
}
</code></pre>

<p>Excerpt of my reducer goes like this: </p>

<pre><code>export const selectAllProducts = createSelector(
  selectProductState,
  fromProduct.selectAllProducts
);

export const selectBasketProductEntities = createSelector(
  selectBasketState,
  fromBasket.selectBasketProductEntities
);

export const selectUserProfile = createSelector(
  selectSettingState,
  fromSetting.selectUserProfile
);

export const selectAllFilters = createSelector(
  selectProductState,
  fromProduct.selectAllFilters
);
</code></pre>

<p>I then created a selector that merges data from the selectors above:</p>

<pre><code>// Returns the List of Products after applying Filters
    export const selectFilteredProducts = createSelector(
      selectAllProducts,
      selectAllFilters,
      selectBasketProductEntities,
      selectUserProfile,
      (products, filters, basket, userProfile) =&gt; {
        // Step 1: Filter the Products based on the Parameters
        const filtered = products.filter(
          product =&gt;
            ((filters.just_arrived === false) ||
            (product.is_just_arrived === 1 &amp;&amp; filters.just_arrived === true)) &amp;&amp;
            // ..... Additional Filters
        );

        // Step 2: Map the Quantity Selected / Currency Information
        return filtered.map(product =&gt; Object.assign({}, product, {
          quantity_selected: basket[product.id],
          currency: userProfile.currency.code
        }));
      }
    );
</code></pre>

<p>The solution works well, but whenever a product is added to the Basket, my entire products list gets re-initialized (probably because I'm re-assigning the product using map). This is likely to create performance issues as the list of product grows. I want to limit the change detection to only the product that has changes.</p>

<p>Is my implementation of map / filter in the createSelector correct? How can I improve the performance?</p>
","2760556","","2760556","","2018-06-11 06:08:27","2018-06-13 16:01:36","creating @ngrx selector with data from multiple entities (Angular)","<angular><rxjs><ngrx><rxjs6><ngrx-entity>","1","0","","","","CC BY-SA 4.0"
"50798783","1","","","2018-06-11 13:23:31","","0","67","<p>I'm migrating my app from <strong>Angular 5.2.9</strong> to <strong>Angular 6.0.4</strong></p>

<p>I ve upgraded from <strong>rxjs v5</strong> to <strong>v6</strong>
And I've uninstalled : <strong>rxjs-compat</strong> (as I was told that it's no more needed)</p>

<p>So in the old syntax, I was used to return custom observable like this: </p>

<pre><code>  public myObservable() {
    return Observable.of(true);
  }
</code></pre>

<p>It seems that this syntax is no more usefull as there is no more the operator <strong>""of""</strong> </p>

<p>the error is the following: </p>

<blockquote>
  <p>error TS2339: Property 'of' does not exist on type 'typeof
  Observable'.</p>
</blockquote>

<p>So what is the alternative? 
<strong>Suggestions?</strong></p>
","4957388","","13860","","2018-06-11 13:27:02","2018-06-11 13:27:02","Cannot use ""Observable.Of(value)""","<javascript><typescript><observable><angular6><rxjs6>","2","1","","2018-06-11 13:26:18","","CC BY-SA 4.0"
"50806619","1","","","2018-06-11 21:59:08","","0","448","<p>this is my setup:</p>

<pre><code>Angular CLI: 6.0.8
Node: 8.10.0
OS: win32 x64
Angular: 5.2.11
... animations, common, compiler, compiler-cli, core, forms
... http, language-service, platform-browser
... platform-browser-dynamic, platform-server, router

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.6.8
@angular-devkit/core         0.6.8
@angular-devkit/schematics   0.6.8
@angular/cli                 6.0.8
@schematics/angular          0.6.8
@schematics/update           0.6.8
rxjs                         5.5.11
typescript                   2.4.2
</code></pre>

<p>And I've tried:</p>

<ul>
<li>ng build </li>
<li>ng build --prod </li>
<li>ng build --environment=prod </li>
<li>ng build --target=production --environment=prod </li>
<li>ng build --prod --env=prod </li>
<li>npm run build etc. etc.</li>
</ul>

<p>I am now at a complete loss as to why the dist is not getting built, I'd really appreciate it if anybody could help</p>
","2225803","","5535245","","2018-06-12 00:35:04","2018-06-18 12:17:26","updated from angular 5 to angular 6 and can't build a dist folder anymore","<angular><build><production-environment><angular6><rxjs6>","2","1","","","","CC BY-SA 4.0"
"50810623","1","","","2018-06-12 06:34:02","","0","475","<p>When I run the app using ""tns run android --emulator"", I encounter the error below</p>

<blockquote>
  <p>Successfully synced application org.nativescript.ema on device
  emulator-5554. ActivityManager: Start proc
  1005:org.nativescript.ema/u0a90 for activity
  org.nativescript.ema/com.tns.NativeScriptActivity JS: Sam Activity
  Event: activityCreated, Activity:
  com.tns.NativeScriptActivity@2689395, Bundle: null JS: Launched
  Android application with the following intent: Intent { flg=0x10000000
  cmp=org.nativescript.ema/com.tns.NativeScriptActivity }. JS:
  bootstrap: ERROR BOOTSTRAPPING ANGULAR JS: bootstrap:
  StaticInjectorError(AppModule)[EffectSources -> ErrorHandler]: JS:<br>
  StaticInjectorError(Platform: core)[EffectSources -> ErrorHandler]:
  JS:     NullInjectorError: No provider for ErrorHandler! JS: JS:
  Error: NullInjectorError: No provider for ErrorHandler! JS:     at
  NullInjector.get
  (file:///data/data/org.nativescript.ema/files/app/tns_modules/@angular/core/bundles/core.umd.js:1035:19)
  [angular] JS:     at resolveToken
  (file:///data/data/org.nativescript.ema/files/app/tns_modules/@angular/core/bundles/core.umd.js:1279:24)
  [angular] JS:     at tryResolveToken
  (file:///data/data/org.nativescript.ema/files/app/tns_modules/@angular/core/bundles/core.umd.js:1224:16)
  [angular] JS:     at StaticInjector.get
  (file:///data/data/org.nativescript.ema/files/app/tns_modules/@angular/core/bundles/core.umd.js:1119:20)
  [angular] JS:     at resolveToken
  (file:///data/data/org.nativescript.ema/files/app/tns_modules/@angular/core/bundles/core.umd.js:1279:24)
  [angular] JS:     at tryResolveToken
  (file:///data/data/org.nativescript.ema/files/app/tns_mod... JS: Sam
  Activity Event: activityStarted, Activity:
  com.tns.NativeScriptActivity@2689395 JS: Resume Event Activity:
  com.tns.NativeScriptActivity@2689395 JS: Sam Activity Event:
  activityResumed, Activity: com.tns.NativeScriptActivity@2689395</p>
</blockquote>

<p>Here is my package.json file</p>

<pre><code>{
  ""name"": ""ema"",
  ""description"": ""Employer Maid Agency"",
  ""license"": ""SEE LICENSE IN &lt;your-license-filename&gt;"",
  ""readme"": ""NativeScript Application"",
  ""repository"": ""&lt;fill-your-repository-here&gt;"",
  ""nativescript"": {
    ""id"": ""org.nativescript.ema"",
    ""tns-android"": {
      ""version"": ""4.1.2""
    }
  },
  ""dependencies"": {
    ""@angular/animations"": ""^6.0.4"",
    ""@angular/common"": ""^6.0.4"",
    ""@angular/compiler"": ""^6.0.4"",
    ""@angular/core"": ""^6.0.4"",
    ""@angular/http"": ""^6.0.4"",
    ""@angular/platform-browser"": ""^6.0.4"",
    ""@angular/platform-browser-dynamic"": ""^6.0.4"",
    ""@angular/router"": ""^6.0.4"",
    ""@ngrx/effects"": ""^6.0.1"",
    ""@ngrx/store"": ""^6.0.1"",
    ""nativescript-angular"": ""^6.0.0"",
    ""nativescript-background-http"": ""^3.2.7"",
    ""nativescript-camera"": ""^4.0.2"",
    ""nativescript-fancyalert"": ""^1.2.0"",
    ""nativescript-feedback"": ""^1.2.0"",
    ""nativescript-loading-indicator"": ""^2.4.0"",
    ""nativescript-ngx-fonticon"": ""^4.2.0"",
    ""nativescript-snackbar"": ""^3.1.0"",
    ""nativescript-theme-core"": ""^1.0.4"",
    ""ramda"": ""^0.25.0"",
    ""reflect-metadata"": ""~0.1.10"",
    ""rxjs"": ""^6.2.0"",
    ""rxjs-compat"": ""^6.2.0"",
    ""tns-core-modules"": ""^4.1.0"",
    ""zone.js"": ""~0.8.18""
  },
  ""devDependencies"": {
    ""@angular-devkit/core"": ""^0.6.8"",
    ""@angular/compiler-cli"": ""^6.0.4"",
    ""@ngtools/webpack"": ""^6.0.8"",
    ""babel-traverse"": ""^6.26.0"",
    ""babel-types"": ""^6.26.0"",
    ""babylon"": ""^6.18.0"",
    ""clean-webpack-plugin"": ""~0.1.19"",
    ""copy-webpack-plugin"": ""^4.5.1"",
    ""css-loader"": ""^0.28.11"",
    ""extract-text-webpack-plugin"": ""^3.0.2"",
    ""lazy"": ""^1.0.11"",
    ""nativescript-dev-typescript"": ""^0.7.1"",
    ""nativescript-dev-webpack"": ""^0.12.0"",
    ""nativescript-worker-loader"": ""^0.9.0"",
    ""raw-loader"": ""^0.5.1"",
    ""resolve-url-loader"": ""^2.3.0"",
    ""sass-loader"": ""^7.0.3"",
    ""typescript"": ""~2.7.2"",
    ""uglifyjs-webpack-plugin"": ""^1.2.5"",
    ""webpack"": ""^4.12.0"",
    ""webpack-bundle-analyzer"": ""^2.13.1"",
    ""webpack-cli"": ""~2.1.3"",
    ""webpack-sources"": ""^1.1.0""
  }
}
</code></pre>

<p>I try to search for the solution online but it seems it has never be reported before. I struggle for the whole morning but I am not to solve it. If you do require source code, do let me know.</p>

<p>I am much appreciate if you can guide me ""where"" should I look into. </p>

<p>thanks in advance.</p>
","4115248","","","","","2018-06-12 06:34:02","Nativescript procudes bootstrap: StaticInjectorError(AppModule)[EffectSources -> ErrorHandler]:","<angular><nativescript><rxjs6>","0","2","","","","CC BY-SA 4.0"
"50821243","1","","","2018-06-12 15:51:36","","1","200","<p>I want to create a regex that match the .map function of RxJS and transforms it into a pipe.</p>

<p>For now I have this regex :</p>

<blockquote>
  <p>/.map(([^)]+))/g</p>
</blockquote>

<p>That will match :</p>

<p><a href=""https://i.stack.imgur.com/DjmOB.png"" rel=""nofollow noreferrer"">Regex result</a></p>

<p>But It doesn't work when I have a map inside a map with : .pipe(map($1))</p>

<p><strong>Output :</strong> </p>

<p><a href=""https://i.stack.imgur.com/DjmOB.png"" rel=""nofollow noreferrer"">Output with pipe</a></p>

<p>I need to know if the .map is chained with another operator or is ended with a semicolon.</p>
","9333800","","9333800","","2018-06-12 15:57:28","2018-06-12 15:57:28","regex - RxJS 6 migration pipe","<javascript><regex><replace><match><rxjs6>","0","4","","","","CC BY-SA 4.0"
"50821752","1","","","2018-06-12 16:19:45","","0","1182","<p>my map/filter function aren't returning an object that I am recieving from my in-memory-service.</p>

<pre><code>this.myService.getEventMedia().subscribe(
  (response) =&gt; {
    return response.map((res) =&gt; {
      this.returnObj = res.dataObj.filter((data) =&gt; {
       if(data.id === id) {
         console.log('event is ', data)
         return data;
       }

      })
    })
  }
);
</code></pre>

<p>after this response and/or ngAfterViewInit() returnObj is console logging undefinded. My data from the filter function has value in it and i can console log data.id</p>

<p>my model looks like below</p>

<pre><code>export interface Model {
  id: number;
  name: string;
  data: Data[];
}
</code></pre>
","6110621","","","","","2018-06-12 19:18:34","Angular 6, RxJS return undefined object","<angular><rxjs><observable><rxjs6>","2","7","","","","CC BY-SA 4.0"
"50824815","1","50881019","","2018-06-12 19:49:34","","0","621","<p>I want to subtract 2 observable numbers </p>

<pre><code>this.num1:Observable&lt;number&gt;
this.num2:Observable&lt;number&gt;
this.num3:Observable&lt;number&gt;

this.num1 = this.store.select(getNum1Count);
this.num2 = this.store.select(getNum2Count);
// this.num3 = difference of this.num1 and this.num2 
</code></pre>

<p>in RXJS5 I was doing the below command</p>

<pre><code> this.num3 = Observable.combineLatest(this.num1,this.num2,(c1,c2)=&gt; Math.abs(c1 - c2));
</code></pre>

<p>But in RXJS6, combineLatest is deprecated: Deprecated in favor of static combineLatest <a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md#dep-methods"" rel=""nofollow noreferrer"">as shown here</a></p>

<p>How do we make this to work in RXJS 6?</p>

<p>On trying the RXJS6 format of combineLatest, </p>

<pre><code>combineLatest(this.num3,this.num2, this.num1, (c1,c2) =&gt;  Math.abs(c1 - c2 )),filter(x =&gt; x !== NaN);
</code></pre>

<p>I get an error
<a href=""https://i.stack.imgur.com/Cskqm.jpg"" rel=""nofollow noreferrer""> The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.</a></p>
","7290236","","7290236","","2018-06-12 20:26:04","2018-06-15 18:32:31","How to subtract 2 observables in RXJS 6","<angular><rxjs><angular6><rxjs6><combinelatest>","1","2","","","","CC BY-SA 4.0"
"50826677","1","","","2018-06-12 22:26:47","","0","64","<p>I recently combined two array using rxjs </p>

<pre><code>  MyArray =  [{
        ""Field"": [""Cars""],
        ""Type"": [""BMW"", ""Toyota"", ""Volvo""]
          },
         {
        ""Field"": [""House""],
        ""Type"": [""Condominium"", ""TownHouse""],
         }


   PriceArray = [
             {
            field: Cars,
            distribution: [{""name"" : ""BMW"",""price"":2},{""name"" : ""Toyota"",""price"":3}]
            },
            {
            field: People,
            distribution: [{""name"" : ""Condominium"",""price"":3},{""name"" : ""TownHouse"",""price"":2}]
           }]
</code></pre>

<p>using rxjs filter</p>

<pre><code>const $MergeData = MyArray.map(val =&gt; {
  return Object.assign({}, val,this.PriceArray.filter(v =&gt; v.Field === val.field)[0])
});
 this.mergedArray = $MergeData;
</code></pre>

<p>Now it looked this..</p>

<pre><code>mergedArray =  [{
    ""Field"": ""Cars"",
    ""Type"": [""BMW"", ""Toyota"", ""Volvo""],
    ""field"" : ""Cars"",
    ""distribution"" : [ 
        {
         ""name"" : ""BMW""
         ""price"": 2 ,
        },
        {
         ""name"" : ""Toyota""
         ""price"": 3 ,
        },
        {
         ""name"" : ""Toyota""
         ""price"": 4 ,
        }
       ]
    }, .... (house array here)];
</code></pre>

<p>Then I tried to show the item price but its not working</p>

<pre><code>&lt;div *ngFor=""let item of mergedArray""&gt;  
    &lt;div *ngFor=""let car of item.Field; let i = index""&gt; 
        &lt;p&gt;{{car}} &lt;/p&gt;
        &lt;p&gt;{{item.distribution.price[i]}} &lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>I am hoping for a fix or better if the array should look like this instead</p>

<pre><code>mergedArray =  [{
    ""Field"": ""Cars"",
     ""Type"": [""BMW"": 2, ""Toyota"" : 3, ""Volvo"" : 4],
    }]
</code></pre>

<p>Hoping it would me possible as it is much easier to loop.</p>
","9877913","","9877913","","2018-06-13 16:42:42","2018-06-13 16:42:42","rxjs/Angular2 Loop but show different object of a single associative array","<arrays><angular><rxjs6>","1","3","","","","CC BY-SA 4.0"
"50837367","1","50988307","","2018-06-13 12:31:47","","-1","8372","<p>I am using Angular 6 where I am getting two errors - </p>

<ol>
<li><p>ERROR in ./src/app/app/img/img.service.ts
Module not found: Error: Can't resolve 'rxjs/add/operator/map' in '/Users/user/Projects/A4/imageSearch/src/app/app/img'</p></li>
<li><p>ERROR in src/app/app/img/img.service.ts(21,9): error TS2339: Property 'map' does not exist on type 'Observable'.</p></li>
</ol>
","9278807","","","","","2019-01-24 08:29:29","Angular 6 : where getting error module ""rxjs/add/operator/map"" and another error 'map' does not exist on type 'Observable<Response>'","<angular><npm><rxjs><angular6><rxjs6>","4","6","1","","","CC BY-SA 4.0"
"50842163","1","50845764","","2018-06-13 16:31:42","","0","3915","<p>I don't understand what's wrong with this code
can you help me, please ?</p>

<pre><code>import { Injectable } from '@angular/core';
import {
  HttpEvent, HttpInterceptor, HttpHandler, HttpRequest
} from '@angular/common/http';

import { Observable } from 'rxjs';
import { switchMap, map } from 'rxjs/operators';

import { AuthenticationSharedStorage } from '../storages/authentication.storage';
import { AuthenticationToken } from '../../models/authentication.model';

@Injectable()
export class AuthenticationInterceptor implements HttpInterceptor {

  constructor(private storage: AuthenticationSharedStorage) {}
  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {
    this.storage.getData()
    .pipe(
      switchMap((data:AuthenticationToken )=&gt; {
      if(data){
        const authToken = data.token;
        const authReq = req.clone({ setHeaders: { Authorization: authToken } });
        return next.handle(authReq);
      }
      return next.handle(req);
      })
    );
  }
}
</code></pre>

<p>The complete error is:</p>

<blockquote>
  <p>Property 'intercept' in type 'AuthenticationInterceptor' is not
  assignable to the same property in base type 'HttpInterceptor'. Type
  '(req: HttpRequest, next: HttpHandler) => void' is not assignable
  to type '(req: HttpRequest, next: HttpHandler) =>
  Observable>'. Type 'void' is not assignable to type
  'Observable>'. 16:3</p>
</blockquote>
","356380","","356380","","2018-06-13 20:17:47","2021-06-28 10:34:54","HttpInterceptor with observable 'intercept' in type 'AuthenticationInterceptor' is not > same property in base type 'HttpInterceptor'","<angular><angular-http><rxjs6>","2","0","","","","CC BY-SA 4.0"
"50845983","1","50850777","","2018-06-13 20:43:50","","29","58724","<p>This is <code>app.module.ts</code> I have tried to done the Import of map in different project and it worked fine, but in this project it's not working.</p>

<pre><code>    import { BrowserModule } from '@angular/platform-browser';
    import { NgModule } from '@angular/core';
    import {HttpModule} from '@angular/http';

    import { AppComponent } from './app.component';
    import { PagesComponent } from './pages/pages.component';

    @NgModule({
      declarations: [
        AppComponent,
        PagesComponent
      ],
      imports: [
        BrowserModule,
        HttpModule

      ],
      providers: [],
      bootstrap: [AppComponent]
    })
    export class AppModule { }
</code></pre>

<p><strong>app.component.ts</strong></p>

<pre><code>import { Component } from '@angular/core';
import {PageService} from './page.service';

@Component({

  selector: 'app-root',
   templateUrl: './app.component.html',
   styleUrls: [""../assets/public/css/adminstyle.css"",
            ""../assets/public/css/demo.css"",
          ""../assets/public/css/style.css""
        ,""../assets/public/css/stylesheet.css""],
  providers:[PageService]
})
export class AppComponent {
  title = 'app';
}
</code></pre>

<p><strong>page.service.ts</strong></p>

<pre><code>import {Injectable} from '@angular/core';
import {Http,Headers} from '@angular/http';

import 'rxjs/add/operator/map';

@Injectable({
  providedIn: 'root'
})
export class PageService {

  constructor(private http:Http) { 
  console.log('Task Service Initialized');

  }
}
</code></pre>
","9723019","","479251","","2018-09-26 07:57:39","2021-01-25 13:56:17","Error: Can't resolve 'rxjs/add/operator/map'","<angular><rxjs><rxjs6>","4","1","6","","","CC BY-SA 4.0"
"50847173","1","50867181","","2018-06-13 22:28:44","","1","233","<p>I want to create a rate limiter for an observable that conditionally changes the way that it limits a value. The use case is for a downloader that is continually receiving new urls to download. I want to be able to queue up incoming urls and switch between two methods of queueing. The two methods are by limiting a rate (e.g. no more than 10 requests every 2 seconds) and by number of concurrent requests (e.g. no more than 10 requests can be fired at a time).</p>

<p>A simple rate limiter can be implemented like below (borrowed from <a href=""https://github.com/gsipos/rxjs-ratelimit/blob/master/src/rxjs-ratelimit.ts"" rel=""nofollow noreferrer"">here</a>):</p>

<pre><code>const rateLimit = (limit, rate, scheduler = asyncScheduler) =&gt; {
  let tokens = limit
  const tokenChanged = new BehaviorSubject(tokens)
  const consumeToken = () =&gt; tokenChanged.next(--tokens)
  const renewToken = () =&gt; tokenChanged.next(++tokens)
  const availableTokens = tokenChanged.pipe(filter(() =&gt; tokens &gt; 0))
  return source =&gt;
    source.pipe(
      mergeMap(val =&gt;
        availableTokens.pipe(
          take(1),
          map(() =&gt; {
            consumeToken()
            timer(rate, scheduler).subscribe(renewToken)
            return val
          })
        )
      )
    )
}
const o = urlSource.pipe(
  rateLimit(10, 2000),
  mergeMap(downloadUrl)
)
o.toPromise()
</code></pre>

<p>And this is a simple concurrent limiter:</p>

<pre><code>const o = urlSource.pipe(
  mergeMap(downloadUrl, maxConcurrent)
)
o.toPromise()
</code></pre>

<p>Finally, I can create this combined switcher to choose which type of limiter to use:</p>

<pre><code>const toggleableLimiter = (func, limit, rate, concurrent, toggleObservable) =&gt; {
  let useRateLimiter = true
  toggleObservable.subscribe(() =&gt; (useRateLimiter = !useRateLimiter))
  const rateLimiter = rateLimit(limit, rate)
  return source =&gt; {
    const operators = useRateLimiter
      ? [rateLimiter, mergeMap(func)]
      : [mergeMap(func, concurrent)]
    return source.pipe(...operators)
  }
}

const e = new EventEmitter()
const toggler = fromEvent(e, 'toggle')
const o = urlSource.pipe(
    toggleableLimiter(downloadUrl, 2, 1000, 2, toggler)
)
o.toPromise()
// using rate limiter
e.emit('toggle')
// incoming values now use concurrent limiter
</code></pre>

<p>This all works as a decent solution to my problem. I can toggle between two methods using an event emitter. The issue however, is that whatever has been passed to the <code>toggleableLimiter</code> <em>before</em> the event is emitted, will have to adhere to that limiter operator. What I want to know, is if I can conditionally keep values in a queue and choose how to limit the queued values on a whim.</p>
","3795137","","","","","2018-06-14 23:17:51","conditionally active rxjs observable rate limiter","<javascript><node.js><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50851699","1","","","2018-06-14 07:17:49","","1","179","<p>I have a hot observable that emits messages. Currently I'm using <code>publishReplay(1).refCount()</code> so everyone subscribing will receive the last message. Now, the messages passing through May have a field containing a boolean to determine if it should be just passed through to all subscribers, or if it should be stored in the replay to be emitted to all new sebscribers too.</p>

<p>Has anyone any idea, how to achieve this usecase?</p>
","1186907","","1186907","","2018-06-15 05:12:21","2018-06-17 13:03:08","rxjs publishReplay with conditional storage","<javascript><rxjs><rxjs6>","1","7","","","","CC BY-SA 4.0"
"50857298","1","50857643","","2018-06-14 12:13:03","","9","2552","<p>When I try to use rxjs6 <code>partition</code> in typescript a type missmatch error is thrown. Also the example from the official documentation throws that error. I think I have to cast something, but I don't know what. Any suggestions?</p>

<pre><code>import {fromEvent} from 'rxjs';
import {partition} from 'rxjs/operators';

document.body.innerHTML = ""&lt;DIV width=100 height=100&gt;&lt;/DIV&gt;""


//Example Code from https://rxjs-dev.firebaseapp.com/api/operators/partition
const clicks = fromEvent(document, 'click');
const parts = clicks.pipe(partition(ev =&gt; ev.target.tagName === 'DIV'));
const clicksOnDivs = parts[0];
const clicksElsewhere = parts[1];
clicksOnDivs.subscribe(x =&gt; console.log('DIV clicked: ', x));
clicksElsewhere.subscribe(x =&gt; console.log('Other clicked: ', x)); 
</code></pre>

<p>Error:</p>

<blockquote>
  <p>Argument of type 'UnaryFunction, [Observable,
  Observable]>' is not assignable to parameter of type
  'OperatorFunction'.   Type '[Observable,
  Observable]' is not assignable to type 'Observable'.
      Property '_isScalar' is missing in type '[Observable, Observable]'.</p>
</blockquote>

<p>See <a href=""https://stackblitz.com/edit/typescript-fdqhws"" rel=""noreferrer"">https://stackblitz.com/edit/typescript-fdqhws</a></p>
","1280664","","","","","2018-11-29 10:44:06","How to use rxjs6 partition in typescript?","<typescript><rxjs><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"50857301","1","50858240","","2018-06-14 12:13:16","","0","831","<p>In my Angular 6 project I have 3 components, Login, Registration and Home.</p>

<p><a href=""https://i.stack.imgur.com/ip6Aq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ip6Aq.png"" alt=""enter image description here""></a></p>

<p>When user successfully register in the app, I want to show this ""Registration successful"" message inside green area. For that I have made a BehaviorSubject inside shared.service.ts</p>

<pre><code>private isRegistrationSuccessfully: BehaviorSubject&lt;boolean&gt; = new BehaviorSubject&lt;boolean&gt;(false);

/* Successful registration */
  getSuccessMessage(): Observable&lt;boolean&gt; {
    return this.isRegistrationSuccessfully.asObservable();
  }

  setSuccessMessage(value: boolean): void {
    this.isRegistrationSuccessfully.next(value);
  }
</code></pre>

<p>in register.component.ts file on successful registration I am calling set method,</p>

<pre><code>onSubmitRegistrationForm() {
// some code
this._sharedService.setSuccessMessage(true);
this._router.navigate(['/' + RouteConstants.LOGIN]);
}
</code></pre>

<p>and in the login.component.ts file I am calling <code>getSuccessMessage()</code> method,</p>

<pre><code>successMessageSubscriber: any;

ngOnInit() {
    this.successMessageSubscriber = this._sharedService.getSuccessMessage().subscribe((flag) =&gt; {
      if (flag) {
          // code for showing div
      }
    });
  }

ngOnDestroy() {
    if (this.successMessageSubscriber) {
      this.successMessageSubscriber.unsubscribe();
    }
  }
</code></pre>

<p>as per this code, after successful registration I am getting expected result and if I refresh the page then also <code>getSuccessMessage()</code> returns false, which is again expected result. But after successful registration and after login (redirecting to home component), if I logout straight away, I am still getting true value for <code>getSuccessMessage()</code>. Is it suppose to happened? or am I missing something here?</p>

<p><strong>Edit</strong><br>
Also is there any other/better way, with that I can do this operations, with or without Behavior Subject?</p>
","7693348","","7693348","","2018-06-14 12:51:03","2018-06-14 15:26:55","BehaviorSubject indifferent behavior","<angular><angular6><behaviorsubject><rxjs6>","2","4","","","","CC BY-SA 4.0"
"50860619","1","","","2018-06-14 15:06:39","","0","727","<p>I have three observables, returned by get() method of HttpClient. I use forkJoin operator in order to get a signal when all petitions have ended.</p>

<pre><code>const responses = [
  this.http.get('http://localhost:3000/articles').pipe(
    map( data =&gt; this.articles = data ),
    catchError( err =&gt; throwError(""Can't get the articles list"") )
  ),
  this.http.get('http://localhost:3000/notas').pipe(
    map( data =&gt; this.news = data ),
    catchError( err =&gt; throwError(""Can't get the news list"") )
  ),
  this.http.get('http://localhost:3000/users').pipe(
    map( data =&gt; this.users = data ),
    catchError( err =&gt; throwError(""Can't get the users list"") )
  )
];

forkJoin(responses).pipe(
  catchError( err =&gt; throwError(err) )
).subscribe(
  response =&gt; console.log('All data loaded')
);
</code></pre>

<p>If the first HTTP request throws an error, the other HTTP requests are made, but the corresponding callbacks are not executed. I read on <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-forkJoin"" rel=""nofollow noreferrer"">rxjs docs</a> ""If any input Observable errors at some point, forkJoin will error as well and all other Observables will be immediately unsubscribed."". So I guess that my forkJoin is working as it's expected, but then I'm not getting the funcionality I need.</p>

<p>So: how do I ensure, with forkJoin or any equivalent method, that all requests are made and all callbacks are executed, even when one of them throws an error?</p>
","574218","","","","","2018-06-15 17:07:19","How can I subscribe to multiple HTTP requests in Angular 6 (with rxjs 6) and ensure that all requests are made even one of them throws an error","<angular><observable><rxjs6>","1","5","0","","","CC BY-SA 4.0"
"50860934","1","","","2018-06-14 15:21:35","","0","253","<p>I am upgrading from rxjs 5.5 to 6.2.1. I went through the code base and made all the changes suggested in the rxjs migration document, changed imports, piping instead of chaining, etc. When I run my <code>npm install</code> the <code>build.bundle.rxjs</code> script throws an error on fetch for rxjs-compat and says it is loading rxjs/Rx, which I can find no reference to in my code base. Has anyone else seen similar problems when upgrading their rxjs?</p>

<p>EDIT:</p>

<p>I found that the source of the error is coming from various packages inside of my node_modules. They are using the deprecated import paths. </p>
","6915873","","6915873","","2018-06-14 16:03:47","2018-06-14 16:03:47","When migrating to rxjs 6 gulp build.bundle.rxjs throws error","<angular><rxjs5><rxjs6><rxjs-compat>","0","2","","","","CC BY-SA 4.0"
"50864978","1","50866975","","2018-06-14 19:56:52","","39","43675","<p>Currently have a scenario where a method within a shared service is used by multiple components. This method makes an HTTP call to an endpoint that will always have the same response and returns an Observable. Is it possible to share the first response with all subscribers to prevent duplicate HTTP requests?</p>

<p>Below is a simplified version of the scenario described above: </p>

<pre class=""lang-js prettyprint-override""><code>class SharedService {
  constructor(private http: HttpClient) {}

  getSomeData(): Observable&lt;any&gt; {
    return this.http.get&lt;any&gt;('some/endpoint');
  }
}

class Component1 {
  constructor(private sharedService: SharedService) {
    this.sharedService.getSomeData().subscribe(
      () =&gt; console.log('do something...')
    );
  }
}

class Component2 {
  constructor(private sharedService: SharedService) {
    this.sharedService.getSomeData().subscribe(
      () =&gt; console.log('do something different...')
    );
  }
}
</code></pre>
","7411555","","","","","2021-03-04 19:30:14","Angular/RxJS 6: How to prevent duplicate HTTP requests?","<angular><rxjs><angular6><rxjs6>","6","5","8","","","CC BY-SA 4.0"
"50865797","1","","","2018-06-14 20:55:06","","4","870","<p>I have a large (hundreds of components) angular (5.2.4) app.  I upgraded the following, and am able to build clean, but the resulting bundle sizes are larger than with v5:</p>

<ul>
<li>Node.js and Angular CLI updated</li>
<li>Http converted to use HttpClient</li>
<li>rxjs conversion from 5 to 6 (pipe operators)</li>
<li>converted .angular-cli.json to new angular.json</li>
<li>removed/replaced any deprecated usage (minimal)</li>
</ul>

<p>We build using an npm script like the following due to a known issue with the JS heap causing grief:</p>

<pre><code>node --max_old_space_size=4096 ./node_modules/@angular/cli/bin/ng build --target=production --aot=true --progress=false --env=STAGING
</code></pre>

<p>I revised this script to the following based on commands changing in the angular cli:</p>

<pre><code>node --max_old_space_size=4096 ./node_modules/@angular/cli/bin/ng build --prod --aot --progress=false --c=USER
</code></pre>

<p>Prior to upgrading, our main bundle size was ~9MB.  After upgrading, it's ~21MB.  Any thoughts or suggestions to diagnose this would be greatly appreciated!</p>
","6831482","","","","","2018-07-09 14:42:15","Bundle size increased after upgrading to Angular 6 (from 5)","<angular><angular-cli><rxjs6><angular-cli-v6>","1","2","","","","CC BY-SA 4.0"
"50870736","1","50872167","","2018-06-15 07:12:08","","9","18573","<p>I am using <strong>Angular 6</strong> 
using <strong>""rxjs"": ""^6.0.0"",</strong></p>

<p><strong>ERROR</strong> : Property 'of' does not exist on type 'typeof Observable'.</p>

<pre><code>import { Injectable } from '@angular/core';
import { TranslateLoader } from '@ngx-translate/core';
import { Observable, Subject, pipe, of } from 'rxjs';


@Injectable()
export class MiTranslateLoaderService implements TranslateLoader {

  getTranslation(lang: string): Observable&lt;any&gt; {
    return Observable.of({
      lbl_select: 'Select',
    });
  }
}
</code></pre>
","2769016","","1034105","","2018-06-21 12:05:29","2019-02-05 13:53:34","Angular 6: Property 'of' does not exist on type 'typeof Observable'","<rxjs><angular6><rxjs6>","6","0","","","","CC BY-SA 4.0"
"50885900","1","","","2018-06-16 07:29:56","","1","606","<p>I have this code:</p>

<pre><code>import { SubscriptionLike } from 'rxjs';
</code></pre>

<p>After importing this, I get the error</p>

<blockquote>
  <p>node_modules/rxjs/Rx""' has no exported member 'SubscriptionLike'.</p>
</blockquote>
","9363864","","3092377","","2018-06-16 07:38:48","2018-06-16 07:38:48","has no exported member 'SubscriptionLike'","<angular><ionic3><rxjs6>","0","2","0","","","CC BY-SA 4.0"
"50886417","1","50900223","","2018-06-16 08:53:05","","6","1001","<p>I wrote the following code following RxJS 6 documentation. I'm currently running angular 5, RxJS 6 and angularfire2 rc.10. The error I get is</p>
<pre><code>[ts] property 'pipe' does not exist on type 'OperatorFunction&lt;{}, [{}, user, string]&gt;'.
</code></pre>
<p>This is the code</p>
<pre><code>this.companies$ = combineLatest(this.authService.user$, this.filter$).pipe(
  switchMap(([user, filter]) =&gt;
    this.afs.collection(&quot;companies&quot;, ref =&gt; {
        if (user) {
          ref.where(&quot;owner.network&quot;, &quot;==&quot;, user.activeNetworkProfile.id);
        }
        if (user) {
          ref.where(&quot;name&quot;, &quot;==&quot;, filter);
        }
        return ref;
      }).valueChanges()
  )
);
</code></pre>
<p>this.authService.user$ and this.filter$ are observables.</p>
<pre><code>public filter$: Observable&lt;string&gt;;
public user$ : Observable&lt;User&gt;;
</code></pre>
","9581414","","74089","","2021-05-03 13:25:48","2021-05-03 13:25:48","How do I fix the following error? property 'pipe' does not exist on type OperatorFunction","<angular><typescript><rxjs><angularfire2><rxjs6>","1","1","","","","CC BY-SA 4.0"
"50897673","1","50898250","","2018-06-17 14:40:33","","2","1378","<p>I'm using <code>combineLatest</code> to merge data from <code>websocket</code> and <code>database</code> into one object. Each time the <code>websocket</code> sends data my data are refreshing. Although I'd like to refresh data at page manually also by pressing the button. Unfortunately <code>combineLatest</code> isn't detect that I made <code>HttpGet</code> request to get newest data.</p>

<pre><code>export class ShowTestDataComponent implements OnInit {
  stockData: RootObject;

  private stocksData$: WebSocketSubject&lt;MessageEvent&gt;;
  private stocksResources$: Observable&lt;DbObject[]&gt;;

  constructor(private stockService: StockService, private webSocketService: WebSocketServiceService) {
    this.stocksData$ = this.webSocketService.connect();
    this.stocksResources$ = this.stockService.getStocksResources();
  }

  buyStock(code, quantityToBuy): void {
    const dto: DbObject = {
      code: code,
      quantity: quantityToBuy
    };

    this.stockService.buyStock(dto).pipe(
      mergeMap(() =&gt; this.stockService.getStocksResources())
    ).subscribe((res) =&gt; this.stocksResources$ = of(res));    
  }

  prepareStockData(): void {
    combineLatest(
      this.stocksData$,
      this.stocksResources$,
      (stockData: RootObject, stockResources: DbObject[]) =&gt; ({
        stockData,
        stockResources
      })
    ).subscribe((pair) =&gt; {
      this.stockData = JSON.parse(pair.stockData.data);

      this.stockData.Items.forEach(item =&gt; {
        item.Quantity = pair.stockResources.find(d =&gt; d.code === item.Code).quantity;
      });
    });
  }

  ngOnInit() {
    this.prepareStockData();
  }
}
</code></pre>

<p>So as you can see If I'll press <code>BUY</code> on UI then method <code>buyStock</code> will be executed and there are executing <code>this.stockService.buyStock(dto)</code> to change data in DB, and then <code>this.stockService.getStocksResources()</code> to refresh data from DB. Everything works, data are changed but data isn't refreshing (comibneLatest isn't detect any message from <code>stocksResources$</code></p>

<p>Here is my service, I think that problem is in componenet though.</p>

<pre><code>export class StockService {
  apiUrl = ""http://localhost:5001/api/values"";
  constructor(private http: HttpClient) { }

  getStocksResources(): Observable&lt;DbObject[]&gt; {
    return this.http.get&lt;DbObject[]&gt;(this.apiUrl + ""/stocks"");
  }

  buyStock(data: DbObject){
    return this.http.post&lt;DbObject&gt;(this.apiUrl + ""/quantity"", data);
  }
}
</code></pre>
","9872301","","","","","2018-06-17 15:56:27","How to trigger again HttpGet request in Angular 6?","<angular><rxjs><angular6><rxjs6><combinelatest>","1","2","0","","","CC BY-SA 4.0"
"50900469","1","50900918","","2018-06-17 21:06:33","","0","1668","<p>In the ""search"" service method, I am returning items where the name includes the search keyword:</p>

<pre><code>// data.service.ts
import { Injectable } from '@angular/core';
import { Observable, pipe, of } from 'rxjs';
import { map, filter, flatMap  } from 'rxjs/operators';
import { Goodie } from './models/Goodie';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  public goodies = [
    { name: 'Brownie Pillow Cookie'},
    { name: 'Talenti Pistachio' },
    { name: 'SnickerDoodle' }
];
  constructor() {}

  public getGoodies(): Observable&lt;Goodie[]&gt; {
    return of(this.goodies);
  }

  public search(keyword): Observable&lt;Goodie&gt; {
    return this.getGoodies().pipe(
      flatMap(data =&gt; data),
      filter(g =&gt; g.name.toLowerCase().includes(keyword.toLowerCase()))
    );
  }
}
</code></pre>

<p>This works (returns items), when there is a keyword match on name. For example, searching for ""e"" returns results, which I can see displayed in the console:</p>

<pre><code>// app.component.ts
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { DataService } from './data.service';
import { Goodie } from './models/Goodie';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  public searchResult: Goodie[] = [];

  constructor(private storeService: DataService) {}

  handleSearch(type, keyword) {
      this.searchResult = [];
      this.storeService.search(keyword).subscribe(data =&gt; {
      console.log('-----------');
      this.searchResult.push(data);
      console.log(this.searchResult);
      console.log('-----------');
    });
  }
}
</code></pre>

<p>But if I search for a keyword that does not match any items, for example ""x"", then not only are no results returned, but nothing is logged to the console from inside the this.storeService.search(keyword).subscribe method - the console does not even print the statement console.log('-----------'). </p>

<p>As a result, I'm hoping to get clarification on two things:</p>

<ol>
<li>Does the body of the handleSearch subscribe method even run if rxjs operations yield no results for filter?</li>
<li>What is a recommended way to get this to work so that tthis.storeService.search(keyword).subscribe always returns results, even if it is an empty list (similar to es6 array filter where an empty array is returned if no matches, but an object is always returned).</li>
</ol>

<p>Here is the example on StackBlitz: 
<a href=""https://stackblitz.com/edit/cookies-bakery"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/cookies-bakery</a>  </p>
","971823","","","","","2018-06-17 22:25:27","Angular RxJS filter - Return an empty or populated Observable list","<angular><rxjs6>","1","1","","","","CC BY-SA 4.0"
"50905033","1","","","2018-06-18 08:02:02","","4","4011","<p>We're facing an issue while updating our application to RxJs 6 (with rxjs-compat). 
A referenced library, which is still on RxJs 5 is using ErrorObservable as a return type of a method.</p>

<pre><code>public handleError(error: Error): ErrorObservable {
    ...
    return Observable.throw('some error message');
}
</code></pre>

<p>As of now ErrorObservable is a non-generic type in RxJs:
<a href=""https://github.com/ReactiveX/rxjs/blob/5.5.11/src/observable/ErrorObservable.ts"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/5.5.11/src/observable/ErrorObservable.ts</a></p>

<pre><code>export class ErrorObservable extends Observable&lt;any&gt; {
  ...
}
</code></pre>

<p>This has changed with RxJs 6<br>
(see <a href=""https://github.com/ReactiveX/rxjs/blob/master/compat/observable/ErrorObservable.ts"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/compat/observable/ErrorObservable.ts</a>)</p>

<pre><code>export class ErrorObservable&lt;T&gt; extends Observable&lt;T&gt; {
  static create&lt;T&gt;(error: any, scheduler?: SchedulerLike) {
    return throwError(error, scheduler);
  }
}
</code></pre>

<p>Which of course leads to a compile error:</p>

<pre><code>ERROR in ... : error TS2314: Generic type 'ErrorObservable&lt;T&gt;' requires 1 type argument(s).
</code></pre>

<p>Is this a case, which is not covered by <code>rxjs-compat</code> or is it an issue with the type definition in <code>rxjs-compat</code>?</p>
","9955459","","","","","2018-06-18 09:26:43","Breaking change in RxJs ErrorObservable (Migration 5 -> 6)","<typescript><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50910446","1","53016483","","2018-06-18 13:17:42","","0","1863","<p>had to delete a previous question in case you are wondering, to reformulate:</p>

<p>I have this component set up:</p>

<pre><code>@Component({
  selector: 'app-async',
  templateUrl: './async.component.html',
  styleUrls: ['./async.component.scss']
})
export class AsyncComponent implements OnInit {

  title$: Observable&lt;string&gt;;
  constructor(private stringService: AsyncStringService) { }

  ngOnInit() {
    this.title$ = this.stringService.getString();
  }
}
</code></pre>

<p>where <code>AsyncStringService.getString</code> is this:</p>

<pre><code>getString(): Observable&lt;string&gt;
</code></pre>

<p>and the template for the component is:</p>

<pre><code>&lt;h1 id=""title""&gt;{{title$ | async}}&lt;/h1&gt;
</code></pre>

<p>I want to test the components behaviour with jasmines async features, but my tests also work if I do not take any async continuation into account:</p>

<pre><code>describe('AsyncComponent', () =&gt; {
  let fixture: ComponentFixture&lt;AsyncComponent&gt;;

  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [ AsyncComponent ],
      providers: [ AsyncStringService ]
    })
    .compileComponents().then(() =&gt;
      fixture = TestBed.createComponent(AsyncComponent));

  }));

  it('should not have resolved observable immedeatly', () =&gt; {
    const spy = spyOn(fixture.debugElement.injector.get(AsyncStringService), 'getString')
      .and.returnValue(of( 'value 1'));
    fixture.detectChanges();
    expect(fixture.debugElement.query(By.css('#title')).nativeElement.innerText).toEqual('value 1');
  });

  it('should have all observables resolved in whenStable', async(() =&gt; {
    const spy = spyOn(fixture.debugElement.injector.get(AsyncStringService), 'getString')
      .and.returnValue(of( 'value 1'));
    fixture.detectChanges();
    fixture.whenStable().then(() =&gt; {
      fixture.detectChanges();
      expect(fixture.debugElement.query(By.css('#title')).nativeElement.innerText).toEqual('value 1');
    });
  }));


  it('should have all observables resolved when ticking', fakeAsync(() =&gt; {
    const spy = spyOn(fixture.debugElement.injector.get(AsyncStringService), 'getString')
      .and.returnValue(of( 'value 1'));
    fixture.detectChanges();
    tick();

    expect(fixture.debugElement.query(By.css('#title')).nativeElement.innerText).toEqual('value 1');
  }));
});
</code></pre>

<p>all three tests succeed, I want the spy to return an observable that fails the first test, as it does not take asynchronicity into account.</p>

<p>Also, any hints if I use these features (async / fakeAsync) incorrectly are appreciated!</p>

<p>edit.:</p>

<p>I tried of('value 1').pipe(delay(100)), which causes all tests to fail. I assume this is somehow connected to the async pipe not being seen by the async/fakeAsync flows?</p>

<p>Edit.:</p>

<p>I got the synchronous task to fail, while done() and async() pass by returning <code>timer(10).pipe(map(() =&gt; 'value 1'))</code> from my spy.</p>

<p>the fake async test however behaves strange:</p>

<p>it passes if I check the observable values in subscribers, even if I do not call tick() at all - so no time should pass and the time should never emit a value.</p>

<p>and calling tick(100), which should make the time(10) to emit, does NOT cause the value to land in the template outside the subscribers.</p>

<pre><code> it('should have all observables resolved when ticking the appropriate amount of time', fakeAsync(() =&gt; {
    const spy = spyOn(fixture.debugElement.injector.get(AsyncStringService), 'getString')
      .and.returnValue(timer(10).pipe(map(() =&gt; 'value 1')));
    fixture.componentInstance.ngOnInit();
    fixture.componentInstance.title$.subscribe(value =&gt; expect(value).toEqual('value 1'));
    fixture.componentInstance.title$.subscribe(() =&gt; {
      fixture.detectChanges();
      expect(fixture.debugElement.query(By.css('#title')).nativeElement.innerText).toEqual('value 1');
    });
    tick(100); // this does nothing
    fixture.detectChanges();
    expect(fixture.debugElement.query(By.css('#title')).nativeElement.innerText).toEqual('value 1');
    discardPeriodicTasks();
  }));
</code></pre>
","1495550","","1495550","","2018-06-19 06:45:01","2018-10-26 21:23:49","angular 6 unittest, observable of() is synchronous","<angular><jasmine><rxjs><karma-jasmine><rxjs6>","1","2","","","","CC BY-SA 4.0"
"50914597","1","50935128","","2018-06-18 17:22:03","","2","614","<p>I just updated from <em>Angular5</em> to <em>6</em>. After updating I ran the code to migrate to <em>rxjs6</em> and it changed my code where I was using <code>takeWhile</code>. Now in order to subscribe to a service my code looks like this:</p>

<pre><code>this.menuService.currentMenu.pipe(takeWhile(() =&gt; this.isAlive))
   .subscribe(result =&gt; { 
      if(result &amp;&amp; result.name)
      {
         //do stuff
      }
   }
);
</code></pre>

<p>using this <code>import</code> statement</p>

<pre><code>import { takeWhile } from 'rxjs/operators';
</code></pre>

<p>After looking at the docs for <em>rxjs6</em> it looks like this is the correct way to use <code>takewhile</code> now; however I am getting errors saying:</p>

<blockquote>
  <p>Property 'name' does not exist on type '{}'</p>
</blockquote>

<p>It looks like the <code>takewhile</code> operation is stripping the <code>observable</code> of its typing. It also happens with <code>filter</code> so I assume that <code>pipe</code> is the issue.</p>

<p>When I set up a test in <a href=""https://stackblitz.com/edit/angular-6-subscription-example-takewhile?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">stackblitz</a> I dont get the error, I expect this is might be do to the project in stackblitz not being on the same <em>typescript</em> version?</p>

<p>This is the version I am using:</p>

<pre><code>     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/


Angular CLI: 6.0.8
Node: 10.4.1
OS: darwin x64
Angular: 6.0.5
... animations, common, compiler, compiler-cli, core, forms
... http, language-service, platform-browser
... platform-browser-dynamic, router

Package                            Version
------------------------------------------------------------
@angular-devkit/architect          0.6.8
@angular-devkit/build-angular      0.6.8
@angular-devkit/build-optimizer    0.6.8
@angular-devkit/core               0.6.8
@angular-devkit/schematics         0.6.8
@angular/cdk                       6.2.1
@angular/cli                       6.0.8
@angular/material                  6.2.1
@angular/material-moment-adapter   6.2.1
@ngtools/webpack                   6.0.8
@schematics/angular                0.6.8
@schematics/update                 0.6.8
rxjs                               6.2.1
typescript                         2.7.2
webpack                            4.8.3
</code></pre>

<p><strong>Edit:</strong>
Explicitly specifying a type fixes the issue. But I don't see why I should have to, why it cant just keep its typing.</p>

<pre><code>this.menuService.currentMenu.pipe(takeWhile(() =&gt; this.isAlive))
   .subscribe((result: ResultClass) =&gt; { 
      if(result &amp;&amp; result.name)
      {
         //do stuff
      }
   }
);
</code></pre>
","2502360","","2502360","","2018-06-20 16:41:42","2018-06-20 18:23:36","Angular 6 pipe operations remove typing from observable","<angular><rxjs><angular6><rxjs6>","1","10","1","","","CC BY-SA 4.0"
"50915639","1","50915760","","2018-06-18 18:41:18","","0","400","<p>My app written in Angular uses several RxJS 6 operators in almost every file, such as <code>filter</code>, <code>take</code>, and <code>takeUntil</code>. Explicitly importing these operators is a real pain. I would prefer to have them globally available.</p>

<p>For example, this code would no longer be needed in every file in the project.</p>

<pre><code>import { filter, take, takeUntil } from 'rxjs/operators';
</code></pre>

<p>Is there a way to import these operators by default?</p>
","3357958","","","","","2018-06-18 18:50:16","Importing RxJS 6 operators into Angular 6 files by default","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50929161","1","50929321","","2018-06-19 13:02:13","","10","4480","<p>I'm upgrading my Angular 5 app to Angular 6 and consequently from rxjs 5 to rxjs 6, I'm experiencing troubles in migrating the following piece of code:</p>

<pre><code>const myObservable = Observable.create(subscriber =&gt; {
    // do something with the subscriber
}).share();
</code></pre>

<p>in particular I'm getting this error:</p>

<blockquote>
  <p>TypeError: Observable_1.Observable.create(...).share is not a
  functionTypeError: Observable_1.Observable.create(...).share is not</p>
</blockquote>
","3497671","","","","","2018-06-19 13:24:57","Rxjs 6 equivalent of Observable.create(subscriber -> {...}).share()","<angular><typescript><rxjs><observable><rxjs6>","2","1","1","","","CC BY-SA 4.0"
"50930249","1","","","2018-06-19 13:56:14","","3","1637","<p>We recently upgraded to Angular 6.0.3, RxJs 6.2.0 and jest 23.1.0 (upgrading from RxJS 5 &amp; Angular 4). </p>

<p>There seems to be a problem with Jest &amp; RxJs as failing expect-statements inside a subscribe-Block do not mark the test as failed. Here's a minimal example:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    it(""should fail"", () =&gt; {

        const obs = Observable.create((observer) =&gt; {
            observer.next(false);
        });

        obs.subscribe((value) =&gt; {
            console.log(value); // =&gt; false
            expect(value).toBeTruthy();
        });

    });</code></pre>
</div>
</div>
</p>

<p>The expect-Statement gets executed, but the test still passes. We didn't observe this behaviour with the previous RxJs version and Jest.</p>
","7080434","","","","","2018-07-19 11:04:21","Failing expect() inside subscribe() does not mark test as invalid","<jestjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50931121","1","50931327","","2018-06-19 14:40:43","","4","944","<p>Rxjs pipeable operators should be imported from 'rxjs/operators', e.g. </p>

<pre><code>import {catchError, filter, map} from 'rxjs/operators';
</code></pre>

<p>However, when using IntelliJ's auto-import, the import statement that is generated is like so: </p>

<pre><code>import {catchError, filter, map} from 'rxjs/internal/operators';
</code></pre>

<p>Is this a bug? Am I doing something wrong?</p>
","45671","","","","","2019-06-17 10:26:08","In IntelliJ, how to auto-import rxjs operators from 'rxjs/operators' i.s.o. 'rxjs/internal/operators'?","<angular><intellij-idea><rxjs><webstorm><rxjs6>","2","1","","","","CC BY-SA 4.0"
"50937426","1","51248359","","2018-06-19 21:52:42","","3","6483","<p>I have an issue which given my inexperience with Angular (v6.0), RxJs (v6.0) and observables in general is causing some considerable headache over the past week.</p>

<p>A service used by a component needs to output a data model collection but to do so will require four separate api calls, and I am having issues with related data that is optional stopping the return of the data model.</p>

<p><strong>Basic flow</strong>  </p>

<ul>
<li>The first api call gets the main entity and creates the initial data
model collection.   </li>
<li>The second api call will go and get related data
and add it to the data model.   </li>
<li>The third api call will  go and get
related data if it exists and add it to the data model.     </li>
<li>The fourth
api call will go and get data related to the most recent related
entry from the third api call.  Data model collection is then
returned.</li>
</ul>

<p><strong>Design</strong>  </p>

<ul>
<li>For the second, third and fourth api calls a batch query method is
used based on the an ID collection to reduce the number of calls,
this is okay as we only request 10, 20 records at a time.</li>
</ul>

<p><strong>Expectations</strong>  </p>

<ul>
<li>If there are no main entities returned from the first api call all
following calls will not occur.  </li>
<li>There will always be data returned for the second api call. </li>
<li>If no related data was returned from the third api call this is not a problem but the data model collection should be returned.</li>
<li>If no related data was returned from the third api call the fourth api call will not happen but the data model collection should be returned.</li>
</ul>

<p><strong>Issues</strong>  </p>

<ul>
<li>Ensuring the data model collection is returned when no results are
found for the third and forth api calls occur.   </li>
<li>I can't change the api.</li>
</ul>

<p><strong>Known</strong>  </p>

<ul>
<li>I do not have much in the way of error handling.</li>
<li>There is a likely a lot of bugs, sorry.  </li>
<li>It is one long chain it would be better to be broken into smaller chunks.</li>
<li>My experience with JavaScript is rusty.</li>
</ul>

<p><strong>Tried</strong>  </p>

<ul>
<li>I have looked extensively at the '*map' functions and 'forkJoin' but
have not been able to get anything working correctly, and with RxJs
most examples are for versions less than 6.0 making it hard to
translate.</li>
</ul>

<p><strong>Code</strong><br>
I would love to make this shorter but the way we call the api is important here.</p>

<pre><code>return this.agentService.GetByFilter(query)
  .pipe(
    map(agents =&gt; {
      let deployments : AgentDeployment[] = [];

      for(let i = 0; i &lt; agents.length; ++i) {          
        deployments.push(new AgentDeployment(agents[i].id, agents[i].name, agents[i].tags));
      };

      return deployments;
    }),
    map(deployments =&gt; {
      // Getting related tags assoiciated with the agent

      let tagIds : Array&lt;number&gt; = [];

      // Get tag id's
      for(let i = 0; i &lt; deployments.length; ++i) {          
        if (deployments[i].tagIds) {
          for(let y = 0; y &lt; deployments[i].tagIds.length; ++y) {
            if (!tagIds.includes(deployments[i].tagIds[y])) {
              tagIds.push(deployments[i].tagIds[y]);
            }              
          };
        }
      }

      // Get the tags associated with the agents
      let filter = new Filter();
      filter.Field = 'ID';
      filter.Value = tagIds.join(',');

      // Get tags using list of tag id's
      return this.tagService.GetByFilter(filter).pipe(
        map(tags =&gt; {        
          if (tags.length) {
            for(let i = 0; i &lt; tags.length; ++i) {     
              // Find the agent
              deployments.forEach(deployment =&gt; {
                if (deployment.tagIds &amp;&amp; deployment.tagIds.includes(tags[i].id)) {
                  deployment.tags.push(tags[i]);
                }
              });
            }              
          }
          return deployments;
        }));
    }),
    mergeMap(deployments =&gt; deployments),
    map(deployments =&gt; {
      // Getting deployments related to the agent, an agent may not have any deployment packages associated

      let agentIds : Array&lt;number&gt; = [];

      // Get tags
      for(let i = 0; i &lt; deployments.length; ++i) {          
        if (deployments[i].id) {
            agentIds.push(deployments[i].id);
        }
      }

      // Get the deployment packages for the agents
      let filter = new Filter();
      filter.Field = 'AgentId';
      filter.Value = agentIds.join(',');

      // Get agent deployment packages using list of agent id's
      return this.agentDeploymentPkgService.GetByFilter(filter)
        .mergeMap(packages =&gt;  packages)
        .groupBy(pkg =&gt; pkg.id)            
        .map(pkg$ =&gt; {
          if (pkg$) {
            // Add packages to agent deployment
            pkg$.map(pkg =&gt; {
            // Find the agent
            let i : number = deployments.findIndex(agent =&gt; agent.id == pkg$.key);

              if (pkg.deploymentPackageIds) {
                // Keep last deployment ID handy
                deployments[i].lastDeploymentId = Math.max.apply(null, pkg.deploymentPackageIds);;
                deployments[i].deployments.push(new Deployment(pkg.id, pkg.name))
              }
            }); 
          }
          return deployments;
        });
    }),
    mergeMap(deployments =&gt; deployments),
    map(deployments =&gt; {
      // Get the logs for the most recent deployment package for the agent, may not exist if no recent deployment package

      let deploymentPackageIds : Array&lt;number&gt; = [];

      // Get tags
      for(let i = 0; i &lt; deployments.length; ++i) {          
        if (deployments[i].id) {
          deploymentPackageIds.push(deployments[i].lastDeploymentId);
        }
      }

      // Get the deployment packages for the agents
      let filter = new Filter();
      filter.Field = 'DeploymentPackageId';
      filter.Value = deploymentPackageIds.join(',');

      // Get agent deployment log based on the last 
      this.logService.GetByFilter(filter)
        .map(logs =&gt; {
          logs.forEach(log =&gt; {
            // Find the agent
            let i : number = deployments.findIndex(agent =&gt; agent.lastDeploymentId == log.deploymentPackageId);

            deployments[i].logId = log.id;
            deployments[i].status = log.lastReportedStatusMessage;
          });

          return deployments;
        });


      return deployments;
    })
  );
</code></pre>
","1402022","","","","","2018-07-09 14:50:02","Need to make multiple HTTP calls and merge results","<angular><rxjs6>","1","2","0","","","CC BY-SA 4.0"
"50950737","1","50990118","","2018-06-20 14:33:32","","0","538","<p>So I have a material DatePicker and form abbreviated in HTML like so:</p>

<pre><code>&lt;form novalidate (ngsubmit)=""submit""
 [formGroup]=""moneyForm""&gt;
    &lt;mat-form-field&gt;
       &lt;input matInput [matDatepicker]=""datePicker"" 
          placeholder=""Entry Date"" 
          [formControl]=""moneyForm.get('dateFormControl')""&gt;
        &lt;mat-datepicker-toggle matSuffix [for]=""datePicker""&gt;&lt;/mat-datepicker-toggle&gt;
       &lt;mat-datepicker #datePicker&gt;&lt;/mat-datepicker&gt;
    &lt;/mat-form-field&gt;
    {{startDate}} - {{endDate}}
&lt;/form&gt;
</code></pre>

<p>And the component wire up abbreviated is like so:</p>

<pre><code>startDate: Date = new Date();
endDate: Date = new Date();
moneyForm: FormGroup;

constructor(private transactionService: TransactionsService, 
          private fb: FormBuilder) { 
}

ngOnInit() {
  this.transactionService.getLastDate(1)
    .subscribe(x =&gt; this.startDate = x);

this.moneyForm = this.fb.group({
  dateFormControl: [this.startDate]
})
</code></pre>

<p>The problem is the timing appears to be delayed in getting the startDate till AFTER the the subscribe has obtained the observable date field.  Yes I observed the date is really getting obtained as the {{startDate}} in the HTML gets generated with it and I can use DevTools-Networking to see the call is successful as well.  If I change the code above my reactive form control to simply do a static assign like</p>

<pre><code>this.startDate = new Date(2018, 5, 5);
</code></pre>

<p>It works right away and sets a default date in rendered content.  However another weird issue is that it sets the date one month forward like it's a zero based index of the months.  I just recently updated so I am pretty current using Angular 6.0.5 and Angular Material 6.3.0.  This problem did exist with Angular 6.0.0 and Angular Material 6.0 as well.</p>

<p>Really I just want to know if you can set up a pipe to map or similar so that the reactive control knows to not assign value till the subscribe is done.  I have tried extensions off of 'value' and 'valuechanged' to no avail.  Any help is appreciated thanks.</p>
","580428","","","","","2018-06-22 14:25:51","Angular Material Date Picker selecting a start date from an injected service value","<angular><angular-material><angular-reactive-forms><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50953056","1","","","2018-06-20 16:30:29","","0","438","<p>the following is an extension to observable to provide a <code>safeSubscribe</code> method that results in a subscription that each component's <code>onDestroy</code> method automatically unsubscribes.</p>

<pre><code>// once _takeUntilDestroy$ on target emits, the subscription gets canceled
export function safeSubscribe&lt;T&gt;(target: any,
                                 next?: (value: T) =&gt; void,
                                 error?: (error: T) =&gt; void,
                                 complete?: () =&gt; void): Subscription {
  target._takeUntilDestroy$ = target._takeUntilDestroy$ || new Subject(); // our kill-switch for the subscription being defined
  return this.pipe(
    takeUntil(target._takeUntilDestroy$.asObservable()) // takeUntil enables the kill-switch
  ).subscribe(next, error, complete);
}

/****  add safeSubscribe to Observable ****/
(Observable as any).prototype.safeSubscribe = safeSubscribe;
declare module 'rxjs/internal/Observable' { // rxjs5 would be rxjs/Observable
 export interface Observable&lt;T&gt; {
    safeSubscribe: typeof safeSubscribe;
  }
}
</code></pre>

<p>I have taken the merge declaration part from <a href=""https://stackoverflow.com/questions/50321926/typescript-module-augmentation/50322026#50322026"">this SO</a>.</p>

<p>This implementation works perfectly when subscribing to Angular HTTPClient requests, but it fails when I try to <code>safeSubscribe</code> to observables created using factory methods like <code>fromEvent</code>:</p>

<pre><code>fromEvent(this.fileInput.nativeElement, 'change').safeSubscribe&lt;any&gt;(this, (x) =&gt; { console.log(x); });
</code></pre>

<p>yielding a <code>safeSubscribe is not a function</code> error.</p>

<p>Am I extending Observable in the wrong way?</p>

<p><strong>Output of npm list rxjs</strong></p>

<pre><code>+-- @angular-devkit/build-angular@0.6.3
| +-- @angular-devkit/architect@0.6.3
| | `-- rxjs@6.2.0  deduped
| +-- @angular-devkit/core@0.6.3
| | `-- rxjs@6.2.0  deduped
| `-- rxjs@6.2.0  deduped
+-- @angular/cli@6.0.3
| +-- @angular-devkit/schematics@0.6.3
| | `-- rxjs@6.2.0  deduped
| +-- @schematics/update@0.6.3
| | `-- rxjs@6.2.0  deduped
| `-- rxjs@6.2.0  deduped
`-- rxjs@6.2.0
</code></pre>
","1336263","","1336263","","2018-06-25 07:12:02","2018-06-25 07:12:02","angular rxjs 6 safeSubscribe is not a function","<angular><typescript><rxjs><observable><rxjs6>","0","9","1","","","CC BY-SA 4.0"
"50957701","1","50958670","","2018-06-20 22:02:54","","8","4894","<p>I have an array of observables that need to fire off sequentially. Once an error happens, I need the to catch the error, log it, and continue observing.</p>

<p>At the moment, once an error occurs, the observer stops. It's essential that the observer continues and does not restart or complete on error.</p>

<pre><code>import * as Rx from ""rxjs"";
const source = [
  Rx.Observable.from(""1"").delay(200),
  Rx.Observable.from(""2"").delay(150),
  Rx.Observable.throw(""error""),
  Rx.Observable.from(""3"").delay(124),
  Rx.Observable.from(""4"").delay(201),
];
let sSource = Rx.Observable.concat(...source);
sSource.subscribe((v) =&gt; {console.log(v)}, (e) =&gt; {console.log(e)});
</code></pre>

<p>Current output:</p>

<pre><code>1
2
error
</code></pre>

<p>Expected output:</p>

<pre><code>1
2
error
3
4
</code></pre>

<p>The only solution that we could come up with was to pre-loop through the <code>source</code> observables and add catch handlers to them individually, then once an error occurs, it's handled correctly and the observer can continue without completing the entire concatenated observable.</p>

<p>We feel like there should be a more elegant solution to this. I'll post the solution we have at the moment if need be.</p>
","3345621","","","","","2019-02-14 10:24:56","RXJS Continue with concat subscribe after error","<typescript><rxjs><rxjs5><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"50967309","1","50969201","","2018-06-21 11:20:49","","19","35701","<p>I am upgrading my app to <strong>Angular 6</strong>. I am upgrading from <strong>Angular 4</strong>, but the code below is causing errors in Angular 6, where it worked fine in Angular 4.</p>
<hr />
<p>The errors I am getting:</p>
<blockquote>
<p>Property 'of' does not exist on type 'typeof Observable'</p>
<p>Error: Property 'catch' does not exist on type 'Observable'</p>
</blockquote>
<p>How should I resolve these errors?</p>
<pre><code>  private authInterceptor(observable: Observable&lt;Response&gt;): Observable&lt;Response&gt; {
    return observable.catch((error, source) =&gt; {
      if (error.status == 401) {
        this.router.navigateByUrl('/login');
        return Observable.of();
      } else {
        return Observable.throw(error);
      }
    });
  }
</code></pre>
","7193018","","-1","","2020-06-20 09:12:55","2019-12-01 12:57:37","Angular 6: Property 'catch' does not exist on type 'Observable<Response>'?","<angular><rxjs><angular6><rxjs6><angular-observable>","8","0","4","","","CC BY-SA 4.0"
"50972811","1","50973051","","2018-06-21 15:52:58","","4","6255","<p>I'm using the new syntax to comply with RxJS 6 <code>pipe()</code>. Also using Angular 6. I have a service that handles http requests, and it pipes map and <code>catchError</code> to display a toast in case of connection error. Nevertheless, If I add <code>catchError</code> I get in console <strong>You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.</strong></p>

<pre><code>  getDataHttpRequest(url, returnType) {
    return this.http.get(url, this.getRequestOptions())
    .pipe(
      map((response) =&gt; {

        if(response){

        if (returnType === 'object') {
          return response[0] == undefined ? response : response[0];
        } else {
          return response;
        }

      }
      }),
      catchError((error):any =&gt; {

      if(error instanceof HttpErrorResponse &amp;&amp; error.status === 0){
        //no connection error(either user has no connection or the server is down)
       this.toastr.error('Chequee su conexión e intente de nuevo en unos momentos. Contáctenos para reportar el problema a &lt;a href=""mailto:dev@info.com""&gt;dev@info.com&lt;/a&gt;',""Error de Conexión"",{tapToDismiss:true, disableTimeOut: true});
      }
       throwError(`Connection Error: ${error}`);
      })


    );

  }
</code></pre>

<p>If I remove the <code>catchError</code> function the errors disappear in console, so that is the breaking piece of code. Any ideas on what could be wrong?</p>
","5935343","","310726","","2018-06-21 16:08:12","2018-06-21 16:08:12","Rxjs 6: using catchError() gives You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable","<angular><rxjs><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"50975120","1","50975511","","2018-06-21 18:11:30","","1","1454","<h1>Service</h1>

<pre><code>mode: Subject&lt;any&gt; = new Subject&lt;any&gt;();

constructor(public http: HttpClient) {
    this.setMode({ // defaults
        admin: this.admins.includes(localStorage.getItem(""email"")),
        edit: false,
        dev: false
    });
}

getMode() {
    return this.mode.asObservable();
}

setMode(value) {
    this.mode.next(value);
}
</code></pre>

<h2>Component</h2>

<pre><code>constructor(private bcAuthService: BcAuthService) {}

ngOnInit() {
  this.bcAuthService.getMode().subscribe(mode =&gt; {
    console.log('mode: ', mode); // never logs or prints in the template
    this.mode = mode;
  });
}
editToggle(e) {
  this.mode.edit = e.target.checked; // err: cant edit `mode` because it never set.
  this.bcAuthService.mode.next(this.mode);
}
</code></pre>

<h2>Question</h2>

<p>I am trying to set up an Observable to be read and wrote from many components. As seen above; I set up the observable in my service but my component <code>getMode()</code> doesnt work. Any ideas why?</p>
","3066142","","3066142","","2018-06-21 18:35:56","2018-06-21 19:00:08","Angular 6 RxJs: Trying to make an obj as observable to be use in other components","<angular><rxjs6><subject-observer>","2","4","0","","","CC BY-SA 4.0"
"50981109","1","50981230","","2018-06-22 05:18:42","","3","3279","<p>I have difficulties using the power of <code>Observables</code> i.e. <code>RxJs 6</code> to correctly <code>pipe, tap, map, mergemap</code> or whatever my <code>HttpClient</code> requests. The version hell with all the different functions makes it not very easy...</p>

<p>So what I need is to first make a REST call, then depending on the result probably do a second REST call and map the potentially two received data objects in one new data object. The function should return an <code>Observable</code>.</p>

<p>So currently, I solved it with a <code>subject</code> that I am be able to do manually / sequentially what I need. The function returns a <code>Subject</code>, not an Observable in this case. But since the caller just subscribes to this function, it works.
To mention is that the two service functions below (<code>userService.loadUserDetails()</code> and <code>adminService.getAdminData()</code>) just returns observables they get from <code>HttpClient</code>.</p>

<p>So can anybody help me translate this example code below into typically <strong>RxJs 6</strong> code?</p>

<pre><code>myFunction(): Observable&lt;any&gt; {
   const s = new Subject();
    let obj: any = {};

    this.userService.loadUserDetails().subscribe((userDetails) =&gt; {
        obj.user = userDetails;
        if (userDetails.authorities.includes('ADMIN')) {
            this.adminService.getAdminData().subscribe((adminData) =&gt; {
                obj.adminData = adminData;
                s.next(obj);
                s.complete();
            });
        } else {
            s.next(obj);
            s.complete();
        }
    });

    return s;
}
</code></pre>
","4106030","","5677886","","2018-06-22 05:40:03","2018-06-22 12:56:22","Sequential cascade Observables according result from previous response and remap to new data object","<angular><rxjs><angular6><rxjs6>","2","0","","","","CC BY-SA 4.0"
"50985563","1","51024607","","2018-06-22 10:04:19","","0","254","<p>I'm new to RxJS and am asking for conceptual help on how to approach the following process:</p>

<ol>
<li>Backend is secured with short lived JWT access tokens. Upon authentication, client is issued initial access token and long lived refresh token. Refresh token can be used to create a new access token.</li>
<li>The client can decode the tokens and <em>knows</em> if a token is expired or not. The client shall refresh access tokens lazily when they are expired; not retry a a failing request.</li>
<li>The client shall not issue multiple refresh-requests simultaneously.</li>
</ol>

<p>The last part I struggle with. I imagine a semaphore, or ""gate"" of some kind:</p>

<ul>
<li>The first refresh-request passes through the gate and locks it behind itself. It then initiates the actual token-refresh.</li>
<li>Other refresh-requests are blocked at the gate, waiting to pass.</li>
<li>The completion of the token-refresh stores the new access token and lifts the gate.</li>
<li>All refresh-requests return the new access token.</li>
</ul>

<p>I found <a href=""https://github.com/auth0/angular2-jwt/issues/15#issuecomment-377681482"" rel=""nofollow noreferrer"">this code</a> that uses redux to implement the gate. Is that necessary?</p>

<p>Alternatively, could the gate be implemented by a <code>BehaviorSubject</code>?</p>
","295962","","","","","2018-06-25 13:25:43","RxJS conceptual help: access and refresh tokens, non-simultaneous refresh","<jwt><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51002250","1","51003322","","2018-06-23 14:45:18","","0","173","<p><a href=""https://rxjs-playground.github.io/#/?html=%3Cbutton%20onclick%3D%22addFilter%28%29%22%3Eadd%3Cbutton%3E&amp;js=let%20filters%24%20%3D%20new%20Rx.BehaviorSubject%28%5B%5D%29%3B%20%0Alet%20id%20%3D%200%3B%0A%0Afilters%24.subscribe%28f%20%3D%3E%20console.log%28f%29%29%3B%0A%0Afunction%20addFilter%28%29%20%7B%0A%20%20filters%24.first%28%29%0A%20%20%20%20.map%28filters%20%3D%3E%20%28%5B...filters%2C%20%7B%20id%20%7D%5D%29%29%0A%20%20%20%20.subscribe%28filters%24%29%3B%0A%20%20id%2B%2B%3B%0A%7D"" rel=""nofollow noreferrer"">live example</a></p>

<p>I've an Array of Filters as an <code>Observable</code> and I'd like to add/remove filters from it. Here is the code I have that is currently only adding a <code>Filter</code> the first time the function runs.</p>

<p>The second time nothing happens.</p>

<pre><code>private _filters$ = new BehaviorSubject&lt;Filter[]&gt;([]);

addFilter(added: Filter) {
    debugger
    // adding to array of filters
    this._filters$.pipe(
        tap(d =&gt; { debugger; }),
        first(), 
        map(filters =&gt; ([...filters, added]))
    ).subscribe(this._filters$);
}
</code></pre>

<p>So my question is: why does this happen ? Why does it run only once ? (By the way <code>first()</code> is not the reason). </p>

<p>I know I can make the code work like so: </p>

<pre><code>private _filters$ = new BehaviorSubject&lt;Filter[]&gt;([]);

currentFilters;

init() {
   this._filters$.subscribe(f =&gt; this.currentFilters = f);
}

addFilter(added: Filter) {
    this._filters$.next([...this.currentFilters, added]);
}
</code></pre>
","4299560","","","","","2018-06-23 17:01:58","Adding to previous result, Observable pipeline only running once","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51009864","1","","","2018-06-24 12:14:28","","1","448","<p>This is a two-part question. With Angular 6, I'm returning an observable with a nested collection. I need the nested collection to serve as the selected values in a reactive forms multiple select list. 1) Using patchValue, I can't get the values to show as selected items. 2) How do I flatten the observable, or push the nested collection into the control?</p>

<p><strong>HTML</strong>:</p>

<pre><code>&lt;mat-form-field&gt;
&lt;mat-select [compareWith]=""compareFn"" placeholder=""Menus"" formArrayName=""menus"" multiple &gt;
&lt;mat-option *ngFor=""let menu of menus"" [value]=""menu""&gt;{{menu.name}}&lt;/mat-option&gt;
&lt;/mat-select&gt;
&lt;/mat-form-field&gt;
</code></pre>

<p><strong>menuItem Class</strong>:</p>

<pre><code>id: string
name: string
menus: [id: string, name: string]
</code></pre>

<p>...'menus' is the nested collection which holds the id and name of the menus to which this menuItem is assigned.</p>

<p><strong>API call</strong>:</p>

<pre><code>getMenuItem(id: string) : Observable&lt;MenuItem&gt;{
    return this.http.get&lt;MenuItem&gt;(`${this.URL}/${id}`)
    .pipe(catchError(this.handleError&lt;MenuItem&gt;('getMenuItem')));}
</code></pre>

<p><strong>Component</strong></p>

<p>Relevants parts of the component:</p>

<pre><code>createForm(){
this.menuItemForm = this.formBuilder.group({
  itemName: ['', Validators.required ],
  itemDescription: ['', Validators.required ],
  active: true,
  menus: this.menus
})
</code></pre>

<p>'this.menus' is the select list of all menus</p>

<p><strong>Subscription</strong></p>

<pre><code>getMenuItem(id: string){
this.menuItemService.getMenuItem(id)
  .subscribe(
  (data: MenuItem) =&gt; this.onItemRetrieved(data),
  (err: any) =&gt; console.log(err));}
</code></pre>

<p>I think this is where I need to flatten the observable in order to take the nested collection out of being nested, but I'm not sure how to do it and still retain my class definition.</p>

<p><strong>OnItemRetrieved</strong></p>

<pre><code>onItemRetrieved(menuItem: MenuItem): void {
if (this.menuItemForm){
  this.menuItemForm.reset();
}

this.menuItem = menuItem;

this.menuItemForm.patchValue({
  ...
  menus: this.menuItem.menus      

});
</code></pre>

<p>Nothing I've tried is getting the values in this.menuItem.menus to show as selected in my select list. In the sample data, I have one menu(id/name) and I've tried this.menuItem.menus[0], and that doesn't work either, which is why I have two problems. :)</p>

<p>Thanks in advance!</p>
","9864424","","5437671","","2018-06-24 12:31:45","2018-06-24 14:51:45","select dropdown/flatten observable","<angular><rxjs6>","0","5","","","","CC BY-SA 4.0"
"51031301","1","51031415","","2018-06-25 20:23:25","","1","597","<p>Why this doesn't work?</p>

<pre><code>import { forkJoin } from 'rxjs';
import { ActivatedRoute } from '@angular/router';

constructor(
  private route: ActivatedRoute
) {}

ngOnInit(): void {

  let parent = this.route.parent.params;
  let child = this.route.params;

  forkJoin(
     parent,
     child,
     (p, c) =&gt; {
        console.log(p);
        console.log(c);
     }
  )
}
</code></pre>

<p>FYI (rxjs6)</p>
","913951","","","","","2018-06-26 05:58:02","Angular 6 - Combine route.params with route.parent.params","<angular><rxjs6>","1","3","","","","CC BY-SA 4.0"
"51032715","1","51042889","","2018-06-25 22:45:54","","1","746","<p>How can I create an RxJs observable that only emits a <code>complete</code> event and no <code>next</code> events? </p>

<p>I have an observable that performs some operations which has a side effect in which it populates an in-memory cache. I would like to use this observable as a semaphore so that a second observable only starts executing when it is complete. Then a second observable can use this cache to decorate incoming data. My idea is to use <a href=""http://rxmarbles.com/#concat"" rel=""nofollow noreferrer"">concat</a> where the first observable only emits a <code>complete</code> event:</p>

<pre><code>const cache = {};
const firstObservable = // fetch data to be cached
const secondObservable = // fetch other data that will be decorated with cached data

// add all next events of the first observable to the cache
const promise = firstObservable
   .forEach(
      data =&gt; {
         cache[data.key] = data;
      }
   );

// create a new observable that only emits a complete event
const waitForCache = of(promise)
   .pipe(
      // skip the first event from waitForCache (the empty promise event), 
      // since we are only interested in when the population of the cache is complete
      skip(1)
   );

// create a semaphore that waits for the complete event from the cache population 
// before dealing with the second observable
const decorated = concat(waitForCache, secondObservable)
   .pipe(
      map(
         data =&gt; {
            // decorate objects with data from cache
            return Object.assign({}, data, cache[data.key]);
         }
      ));
</code></pre>

<p>My assumption is that the problem is the <code>skip(1)</code> call. </p>

<ul>
<li>With the implementation above, the <code>waitForCache</code> completes too early and the cache is empty when the second observable attempts to fetch the value. Notably, the cache will be populated <em>after</em> the decoration has been made.</li>
<li>When removing skip, the <code>waitForCache</code> observable will add an additional (empty) event to the <code>decorated</code> observable</li>
</ul>
","303598","","","","","2018-06-30 20:26:36","RxJs Observable without next events?","<javascript><rxjs><semaphore><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51044291","1","51044495","","2018-06-26 13:37:46","","41","19950","<p>I've created a demo (<a href=""https://ng-run.com/edit/dYatmtw7gNhqHPEthWRn"" rel=""noreferrer""><strong>ng-run</strong></a>) where I have a button which invokes an Http request.</p>

<p>When the button is clicked, I invoke this method : </p>

<pre><code>public getData(){
 this._jokeService.getData().subscribe();
}
</code></pre>

<p>Which in turn invokes this ( from a service) : </p>

<pre><code> public getData() {
    return this.http.get(API_ENDPOINT).pipe(shareReplay(1))
  }
</code></pre>

<p>The problem is that on every click -  I still see a new http request initiated :</p>

<p><a href=""https://i.stack.imgur.com/b3RF1.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/b3RF1.png"" alt=""enter image description here""></a></p>

<p><strong>Question:</strong></p>

<p>Why doesn't shareReplay keeps the last value of the response?<br>
How can I make my code to invoke the http only once and keep that value for future subscriptions  ?</p>

<p>Edit: <a href=""https://stackblitz.com/edit/angular-yj3uwk?file=src%2Fapp%2Fapp.component.ts"" rel=""noreferrer"">solution is here</a></p>
","859154","","859154","","2018-08-27 08:41:16","2019-10-28 21:07:16","Using shareReplay(1) in Angular - still invokes http request?","<javascript><angular><rxjs><rxjs6>","2","5","11","","","CC BY-SA 4.0"
"51071945","1","51072579","","2018-06-27 21:53:05","","0","1063","<p>I have the following code and it is not firing the switchMap. Not sure what im doing wrong. </p>

<pre><code>import { switchMap} from ""rxjs/operators"";
import { combineLatest } from 'rxjs';

this.companies$ = combineLatest(this.authService.user$, this.filter$ ).pipe(
            switchMap(([user, filter]) =&gt;{
                return this.afs.collection&lt;CompanyProfile&gt;('companies', ref =&gt; {
                console.log(""this doesnt fire""); 
                if (user) { ref.where('owner.network', '==', user.activeNetworkProfile.id) };
                if (filter) { ref.where('name', '==', filter) };
                return ref;
                }).valueChanges();
            } 
        ));
</code></pre>
","10002455","","","","","2018-06-27 23:04:59","How do I get switchMap to fire inside a combineLatest?","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51072691","1","51073886","","2018-06-27 23:20:54","","2","3417","<p>I'm trying to put a timer from rxjs 6 in an angular 6 service. And it's  not being triggered. I looked in the documentation without any luck. This is my service code(only the relevant part:</p>

<pre><code>import { map,flatMap, catchError, take } from 'rxjs/operators';
import { BehaviorSubject, of, throwError,timer, Observable } from ""rxjs"";

.....

  countdownTimer = new Observable&lt;number&gt;();


  formatCountdownTime(count) {
    const seconds = count % 60 &lt; 10 ? '0' + Math.floor(count % 60) : Math.floor(count % 60);
    /*    if(count &lt;= 1000){
         //set timer to NOT RUNNING state so it updates UI components like the button that depends on the count
          this.contributorManagerService.countdownTimerIsRunning.next(false);
       } */
       return Math.floor(count / 60) + ':' + seconds;
  }

  createCountdownTimerObservable(count){
    this.countdownTimer =  timer(0, 1000);

  }
</code></pre>

<p>and this is the consumption of the timer. I need to know when time has elapsed and that's why I'm passing that 3rd function parameter to the subscription since I need to enable a button when the time is up.</p>

<pre><code>import { map,take } from 'rxjs/operators';


export class CampaignDataComponent implements OnInit, OnDestroy {

 countdownTimerIsRunning = false ;
 count: number;


ngOnInit(){

/* I subscribe to the timer and the 3rd parameter indicates what to do when time has elapsed */
      this.sharedHelpersService.countdownTimer.
      pipe(
        take(this.count),
        map(() =&gt; {
          --this.count;

          return this.count;
        })
      ).subscribe(count=&gt;{
        console.log(""New count"",count);

          if(count&gt;0){
             this.countdownTimerIsRunning = true;
          }
      },
      err=&gt;{
        console.log(""Countdown timer error"", err);
      },
      ()=&gt;{
        console.log(""Time has elapsed"");
        this.countdownTimerIsRunning = false;
      });

}

}
</code></pre>

<p>Do you know why is not being triggered? It used to work when I used the whole chain on the component but since I need to consume it from other components I had to put it in a service and that broke it. Any ideas?. Thank you very much in advance</p>

<p>EDIT: Just to clarify, they all the components should consume the same countdown</p>
","5935343","","5935343","","2018-06-28 00:50:21","2018-06-28 03:50:25","rxjs6 Timer not being triggered in Angular 6 subscription to observable timer placed in service","<timer><rxjs><angular6><rxjs6>","3","0","2","","","CC BY-SA 4.0"
"51074018","1","","","2018-06-28 02:53:44","","2","269","<h2>I use</h2>

<p>Angular CLI: 6.0.8 </p>

<p>Node: 8.11.3</p>

<p>I just learned Udemy - Angular (Full App) with Angular Material, Angularfire &amp; NgRx.
Up on lesson 72 Listening to Value Changes (of_Firestore) I have an error</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class NewTrainingComponent implements OnInit {
  exercises: Observable&lt;Exercise[]&gt;;

  constructor(
    private trainingService: TrainingService,
    private db: AngularFirestore) { }

  ngOnInit() {
    this.exercises = this.db
      .collection('availableExercises')
      .snapshotChanges()
      .pipe(
          map(docArray =&gt; {
          return docArray.map(doc =&gt; {
            return {
              id: doc.payload.doc.id,
              name: doc.payload.doc.data().name,
              duration: doc.payload.doc.data().duration,
              calories: doc.payload.doc.data().calories
            };
          });
        })
      ).subscribe(result =&gt; {
        console.log(result);
      });
  }

  onStartTraining(form: NgForm) {
    this.trainingService.startExercise(form.value.exercise);
  }

}</code></pre>
</div>
</div>
</p>

<blockquote>
  <p>error TS2322: Type 'Subscription' is not assignable to type 'Observable'.</p>
  
  <p>error TS2339: Property 'name' does not exist on type '{}'.</p>
  
  <p>error TS2339: Property 'duration' does not exist on type '{}'.</p>
  
  <p>error TS2339: Property 'calories' does not exist on type '{}'.</p>
</blockquote>
","5885917","","9816472","","2018-06-28 03:02:50","2018-06-28 03:02:50","Type 'Subscription' is not assignable to type 'Observable<Exercise[]>'","<javascript><angular><typescript><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51080789","1","51082958","","2018-06-28 10:37:58","","4","5390","<p>I am trying to upgrade my project based on some template from angular 5 to 6</p>

<p>one of the method return mergeMap in this way</p>

<pre><code>return this.accountEndpoint.getUserByUserNameEndpoint&lt;User&gt;(userOrUserId.userName)
                    .mergeMap(user =&gt; this.deleteUser(user.id));
</code></pre>

<p>and some other in this way return </p>

<pre><code> this.accountEndpoint.getDeleteUserEndpoint&lt;User&gt;(&lt;string&gt;userOrUserId)
                 .do(data =&gt; this.onRolesUserCountChanged(data.roles));
</code></pre>

<p>unfortunately mergeMap and do does not exists on observable in rxjs 6</p>

<p>Couuld give me a hint how should this be mapped in new worlds of rxjs 6 ? </p>
","428547","","428547","","2018-06-28 11:03:05","2019-04-30 18:28:05","mergeMap service in rxjs 6","<angular><rxjs><angular6><rxjs6>","1","1","1","","","CC BY-SA 4.0"
"51089579","1","","","2018-06-28 18:52:50","","7","1081","<p>The documentation to use rxjs-5-to-6-migrate states the following: </p>

<pre><code>To refactor TypeScript code so that it doesn't depend on rxjs-compat, you can use rxjs-tslint.

npm i -g rxjs-tslint
rxjs-5-to-6-migrate -p [path/to/tsconfig.json]
</code></pre>

<p>So I did that and then copied the </p>

<p>root path to my tsconfig file</p>

<pre><code>rxjs-5-to-6-migrate -p [/home/ri
ckus/Documents/softwareProjects/211hospitality/suitsandtables/frontend/frontendsuitsandtables/suitsandtables/tsconfig.json]
</code></pre>

<p>But when I run the command I get the following <strong>error</strong>.</p>

<pre><code>Running the automatic migrations. Please, be patient and wait until the execution completes.
child_process.js:643
    throw err;
    ^

Error: Command failed: ""/usr/local/lib/node_modules/rxjs-tslint/node_modules/.bin/tslint"" -c ""/usr/local/lib/node_modules/rxjs-tslint/rxjs-5-to-6-migrate.json"" -p ""[home/rickus/Documents/softwareProjects/211hospitality/suitsandtables/frontend/frontendsuitsandtables/suitsandtables/tsconfig.json"" --fix
    at checkExecSyncError (child_process.js:603:11)
    at Object.execSync (child_process.js:640:13)
    at migrate (/usr/local/lib/node_modules/rxjs-tslint/rxjs-5-to-6-migrate.js:18:34)
    at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/rxjs-tslint/rxjs-5-to-6-migrate.js:25:14)
    at Module._compile (internal/modules/cjs/loader.js:702:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:713:10)
    at Module.load (internal/modules/cjs/loader.js:612:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:551:12)
    at Function.Module._load (internal/modules/cjs/loader.js:543:3)
    at Module.require (internal/modules/cjs/loader.js:650:17)
</code></pre>

<p>But for why? It seems this  code is more fickle than my ex and unfortunately I can't run away from this.</p>

<p>I checked this answer and it did not help: 
<a href=""https://stackoverflow.com/questions/50639923/rxjs-5-to-6-migrate-crashes"">RxJs-5-to-6-migrate crashes</a></p>
","10001823","","5859957","","2018-06-29 02:39:11","2019-11-11 09:50:03","usng rxjs-5-to-6-migrate correctly. issues with tsconfig path","<angular><rxjs><rxjs5><tsconfig><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"51095874","1","51100327","","2018-06-29 06:50:10","","3","6870","<p><strong>Using rxjs v6</strong></p>

<p>So I have multiple variables that I want to track/observe, and when any of them change, trigger an Observable to call an API, which then updates something else based on those variables.</p>

<p>I thought I could maybe trigger an event on a <code>div</code> to force the observable to do something, but it's not returning results based on what I want</p>

<p>E.g.</p>

<pre><code>var a, b, c, d // if any updates, should trigger div ""update"" event

let obs = fromEvent(this.$refs.updater, ""update"")
    .pipe(
        switchMap(i =&gt; {return this.callAnAPI()})
    )
obs.subscribe()

var update = new Event(""update"")
this.$refs.updater.dispatchEvent(update)
</code></pre>

<p>However, there is no subscribe method on the observable. I was trying to modify one of my other Observables (which works)</p>

<pre><code>fromEvent(input, ""keyup"")
    .pipe(
        map(i =&gt; i.currentTarget.value),
        debounceTime(delay),
        distinctUntilChanged(),
        switchMap(value =&gt; 
        {
            this.page = 1
            if (ajax)
            {
                return ajax
            }   
            else
            {
                return this.axiosAjax({
                    path,
                    method,
                    data: {
                        ...data,
                        [term]: value
                    }
                })
            }    
        })
    )
</code></pre>
","6554121","","6554121","","2018-06-29 07:03:03","2018-06-29 11:19:51","How to trigger an rxjs observable","<javascript><rxjs><rxjs6>","1","3","1","","","CC BY-SA 4.0"
"51104776","1","51104947","","2018-06-29 15:12:13","","0","200","<p>I use angular cli 6 and angularfire2. My code works very well to display the data in the template with a classic ngfor loop and an asynchronous pipe. But I also have to use the data for a Google graph. This one needs data from the typescript. How can I convert my observable into an array in the typescript as described below?</p>

<p>I can use a plunker if you need it</p>

<p>I have in my firedatabase :</p>

<pre><code>--ppss
  --pps1key
    --treatement : value1
    --DateA : DateA1
    --Date B : DateB1
  --pps2key
    --treatement : value2
    --DateA : DateA2
    --Date B : DateB2
</code></pre>

<p>I want display data in my //component.ts like this :</p>

<pre><code> this.data1 = [
 ['treatement','dateA', 'dateB'],
 [ 'Treatement.value1',  new DateA1(), new DateB1()],
 [ 'Treatement.value2',  new DateA2(), new DateB2()]
 ];
</code></pre>

<p>From my service, i send an observable like that :</p>

<pre><code>getPPSByPatientid(Patientid: string)
{
return this.database.list('/ppss', ref =&gt; 
ref.orderByChild(""Patientid"").equalTo(Patientid)).valueChanges();
}
</code></pre>

<p>I try this but i have many error :</p>

<pre><code>patientid: string;
ppssToDisplay;
data1: any[];

    ngOnInit() {
      this.route.params.forEach((urlParameters) =&gt; {
      this.patientid = urlParameters['id'];});
      this.ppssToDisplay = this.ppssService.getPPSByPatientid(this.patientid);

let interestingFields = [ 'treatement','dateA', 'dateB'];
this.ppssToDisplay.subscribe(obj =&gt; {
  this.data1 = [
    interestingFields,
    interestingFields.map(field =&gt; obj[field]),
  ];
console.log(this.data1);
});
</code></pre>

<p>Error:</p>

<pre><code>core.js:1598 ERROR Error: Uncaught (in promise): Error: Not an array Error: Not an array
</code></pre>
","9962015","","9962015","","2018-07-03 17:26:24","2018-07-03 17:26:24","Transform an observable to array in order to draw googlechart","<angular><typescript><angularfire2><google-visualization><rxjs6>","1","5","","","","CC BY-SA 4.0"
"51126254","1","51128417","","2018-07-01 19:13:06","","3","1028","<p>I'm trying to display the first 3 numbers each one delayed by 1 second and the fourth one by 4 seconds. Unfortunately, my code displays the four numbers by 1 second</p>

<pre><code>import { from, of, race, timer, interval } from 'rxjs';
import { groupBy, mergeMap, toArray, map,merge, reduce, concatMap, delay, concat, timeout, catchError, take } from 'rxjs/operators';

const obs$ = from([1,2,3]).pipe(concatMap(a =&gt; of(a).pipe(delay(1000)))); 
const obs2$ = of(4).pipe(delay(4000)); 
const result$ = obs$.pipe(merge(obs2$));

const subscribe = result$.subscribe(val =&gt; console.log(val));  
</code></pre>

<p>It displays
1234|</p>

<p>instead of
123----4|</p>

<p>this question is entirely for learning rxjs as beginner and has been tested on <a href=""https://stackblitz.com"" rel=""nofollow noreferrer"">https://stackblitz.com</a></p>
","717058","","717058","","2018-07-01 20:49:53","2018-07-03 04:42:57","Delay first 3 items by 1 second and the fourth by 4 seconds","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51126603","1","51141918","","2018-07-01 19:59:34","","1","345","<p>I'm trying to understand why my code is not working what I'm expecting it to behave.</p>
<p>If you copy and paste the following code in <a href=""https://stackblitz.com"" rel=""nofollow noreferrer"">https://stackblitz.com</a>, you will see it wait 4 seconds then it displays 'aaaa' every second instead of 'bbbb' every second. Why?</p>
<pre class=""lang-ts prettyprint-override""><code>import { from, of, race, timer, interval } from 'rxjs';
import { groupBy, mergeMap, toArray, map,merge, reduce, concatMap, delay, concat, timeout, catchError, take } from 'rxjs/operators';

const obs$ = interval(4000).pipe(map(() =&gt; 'aaaa'));
const obs2$ = interval(1000).pipe(map(() =&gt; 'bbbb'));
 
const result$ = obs$.pipe(concatMap(() =&gt; obs2$));
 
const subscribe = obs$.subscribe(val =&gt; console.log(val + ' ' + new Date().toLocaleTimeString()));  
</code></pre>
","717058","","74089","","2021-03-10 22:06:54","2021-03-10 22:06:54","concatMap with interval is not working as expected","<rxjs><rxjs6>","1","4","1","","","CC BY-SA 4.0"
"51128911","1","51136802","","2018-07-02 03:48:25","","14","12972","<p>I just recently updated A LOT of packages in my angular project.</p>

<p>Old package.json:</p>

<pre><code>{
  ""name"": ""data-jitsu"",
  ""version"": ""0.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""ng"": ""ng"",
    ""start"": ""ng serve"",
    ""build"": ""ng build"",
    ""test"": ""ng test"",
    ""lint"": ""ng lint"",
    ""e2e"": ""ng e2e""
  },
  ""private"": true,
  ""dependencies"": {
    ""@angular/animations"": ""^5.2.10"",
    ""@angular/cdk"": ""^5.2.5"",
    ""@angular/common"": ""5.2.7"",
    ""@angular/compiler"": ""5.2.7"",
    ""@angular/core"": ""5.2.7"",
    ""@angular/forms"": ""5.2.7"",
    ""@angular/http"": ""5.2.7"",
    ""@angular/material"": ""^5.2.5"",
    ""@angular/platform-browser"": ""5.2.7"",
    ""@angular/platform-browser-dynamic"": ""5.2.7"",
    ""@angular/router"": ""5.2.7"",
    ""@types/youtube"": ""0.0.29"",
    ""angular-froala-wysiwyg"": ""^2.7.2-1"",
    ""angular2-materialize"": ""^15.1.10"",
    ""angularfire2"": ""^4.0.0-rc0"",
    ""core-js"": ""^2.4.1"",
    ""d3"": ""^4.13.0"",
    ""firebase"": ""^3.9.0"",
    ""hammerjs"": ""^2.0.8"",
    ""jquery"": ""^3.0.0"",
    ""materialize-css"": ""^0.100.2"",
    ""ngx-youtube-player"": ""0.0.41"",
    ""rxjs"": ""^5.5.6"",
    ""zone.js"": ""^0.8.4""
  },
  ""devDependencies"": {
    ""@angular/cli"": ""1.7.2"",
    ""@angular/compiler-cli"": ""5.2.7"",
    ""@types/bootstrap"": ""^3.3.36"",
    ""@types/d3"": ""^4.13.0"",
    ""@types/jasmine"": ""2.5.38"",
    ""@types/node"": ""~6.0.60"",
    ""codelyzer"": ""~2.0.0"",
    ""jasmine-core"": ""~2.5.2"",
    ""jasmine-spec-reporter"": ""~3.2.0"",
    ""karma"": ""~1.4.1"",
    ""karma-chrome-launcher"": ""~2.0.0"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^0.2.0"",
    ""karma-jasmine"": ""~1.1.0"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""protractor"": ""~5.1.0"",
    ""ts-node"": ""~2.0.0"",
    ""tslint"": ""~4.5.0"",
    ""typescript"": ""2.6.2""
  }
}
</code></pre>

<p>New package.json:</p>

<pre><code>{
  ""name"": ""data-jitsu"",
  ""version"": ""0.0.0"",
  ""license"": ""MIT"",
  ""scripts"": {
    ""ng"": ""ng"",
    ""start"": ""ng serve"",
    ""build"": ""ng build"",
    ""test"": ""ng test"",
    ""lint"": ""ng lint"",
    ""e2e"": ""ng e2e""
  },
  ""private"": true,
  ""dependencies"": {
    ""@angular/animations"": ""^6.0.3"",
    ""@angular/cdk"": ""^6.3.1"",
    ""@angular/common"": ""^6.0.3"",
    ""@angular/compiler"": ""^6.0.3"",
    ""@angular/core"": ""^6.0.3"",
    ""@angular/forms"": ""^6.0.3"",
    ""@angular/http"": ""^6.0.3"",
    ""@angular/material"": ""^6.2.0"",
    ""@angular/platform-browser"": ""^6.0.3"",
    ""@angular/platform-browser-dynamic"": ""^6.0.3"",
    ""@angular/router"": ""^6.0.3"",
    ""@types/youtube"": ""^0.0.29"",
    ""angular-froala-wysiwyg"": ""^2.7.2-1"",
    ""angular2-materialize"": ""^15.1.10"",
    ""angularfire2"": ""^5.0.0-rc.11"",
    ""core-js"": ""^2.4.1"",
    ""d3"": ""^4.13.0"",
    ""firebase"": ""^5.0.3"",
    ""hammerjs"": ""^2.0.8"",
    ""jquery"": ""^3.0.0"",
    ""materialize-css"": ""^0.100.2"",
    ""ngx-youtube-player"": ""0.0.41"",
    ""rxjs"": ""^6.2.1"",
    ""zone.js"": ""^0.8.26""
  },
  ""devDependencies"": {
    ""@angular-devkit/build-angular"": ""~0.6.8"",
    ""@angular/cli"": ""~6.0.8"",
    ""@angular/compiler-cli"": ""^6.0.3"",
    ""@angular/language-service"": ""^6.0.3"",
    ""@types/bootstrap"": ""^3.3.36"",
    ""@types/d3"": ""^4.13.0"",
    ""@types/jasmine"": ""~2.8.6"",
    ""@types/jasminewd2"": ""~2.0.3"",
    ""@types/node"": ""^10.5.1"",
    ""codelyzer"": ""~4.2.1"",
    ""jasmine-core"": ""~2.99.1"",
    ""jasmine-spec-reporter"": ""~4.2.1"",
    ""karma"": ""~1.7.1"",
    ""karma-chrome-launcher"": ""~2.2.0"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""~2.0.0"",
    ""karma-jasmine"": ""~1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""protractor"": ""~5.3.0"",
    ""ts-node"": ""~5.0.1"",
    ""tslint"": ""~5.9.1"",
    ""typescript"": ""~2.7.2""
  }
}
</code></pre>

<p>When I run <code>npm install</code> using the new package.json updates and then <code>ng serve</code>, I get many compilation errors:</p>

<blockquote>
  <p>ERROR in src/app/all-matches/all-matches.component.ts(35,39): error
  TS2339: Property 'takeUntil' does not exist on type
  'Observable'. src/app/app.component.ts(28,39): error TS2339:
  Property 'takeUntil' does not exist on type 'Observable'.
  src/app/authorization.service.ts(19,41): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(29,37): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(42,39): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(66,39): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(74,37): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/authorization.service.ts(82,39): error TS2339: Property 'of'
  does not exist on type 'typeof Observable'.
  src/app/database.service.ts(7,31): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseListObservable'.
  src/app/database.service.ts(7,55): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseObjectObservable'.
  src/app/match-display/match-display.component.ts(27,49): error TS2339:
  Property 'takeUntil' does not exist on type 'AngularFireObject&lt;{}>'.
  src/app/new-match/new-match.component.ts(10,30): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseListObservable'.
  src/app/new-match/new-match.component.ts(10,54): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseObjectObservable'.
  src/app/new-match/new-match.component.ts(130,37): error TS2339:
  Property 'switchMap' does not exist on type 'Observable'.
  src/app/protection.guard.ts(14,34): error TS2339: Property 'map' does
  not exist on type 'Observable'.
  src/app/test-db/test-db.component.ts(7,30): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseListObservable'.
  src/app/test-db/test-db.component.ts(7,54): error TS2305: Module
  '""/Users/mf/Desktop/dataJitsu/node_modules/angularfire2/database/index""'
  has no exported member 'FirebaseObjectObservable'.
  src/app/user-status-report/user-status-report.component.ts(28,39):
  error TS2339: Property 'takeUntil' does not exist on type
  'Observable'.
  src/app/user-status-report/user-status-report.component.ts(33,45):
  error TS2339: Property 'subscribe' does not exist on type
  'AngularFireObject&lt;{}>'.
  src/app/user-status-report/user-status-report.component.ts(35,56):
  error TS2339: Property 'takeUntil' does not exist on type
  'AngularFireObject&lt;{}>'.
  src/app/user-status-report/user-status-report.component.ts(43,66):
  error TS2339: Property 'takeUntil' does not exist on type
  'AngularFireObject&lt;{}>'.</p>
</blockquote>

<p>Most of these errors seemed like they had to do with rxjs, and I think rightly so because I'm using rxjs v.6 in the update, and my understanding is that many things were broken between v.5 and v.6. </p>

<p>I played around with installing rxjs-compat
<code>npm install rxjs@6 rxjs-compat@6 --save</code>, and I can confirm that this package, in addition to being a hefty addition, does not resolve any of the errors I'm seeing.</p>

<p>I also automated some of the updating by running ts-lint, per the advice <a href=""https://auth0.com/blog/whats-new-in-rxjs-6/"" rel=""noreferrer"">here</a> and <a href=""https://rxjs-dev.firebaseapp.com/guide/v6/migration"" rel=""noreferrer"">here</a>: </p>

<pre><code>npm i -g rxjs-tslint
rxjs-5-to-6-migrate -p [path/to/tsconfig.json]
</code></pre>

<p>I get the following message:</p>

<blockquote>
  <p>No valid rules have been specified for JavaScript files</p>
</blockquote>

<p>I'm guessing this means that I didn't use proper ts conventions when using rxjs?</p>

<p>I'm still pretty incompetent when it comes to rxjs, so it's not clear to me exactly what else needs to be refactored.</p>

<p>But I think that my issue actually occurs before the refactoring can of worms:</p>

<p>I took a look at the first error (the </p>

<blockquote>
  <p>error TS2339: Property 'takeUntil' does not exist on type 'Observable'</p>
</blockquote>

<p>one). The error came from a method in my authentication service. In the import statements at the top of this service (and most of the other .ts files, for that matter), my IDE is highlighted a lot of, ""cannot find module foo"" errors (e.g., ""cannot find module, 'rxjs'"" for the import statement, <code>import { Observable } from 'rxjs';</code>).</p>

<p>Similar errors in the same file:</p>

<p><code>import { Injectable, EventEmitter } from '@angular/core';</code> (""Cannot find module, ""@angular/core"")</p>

<p><code>import * as firebase from 'firebase/app';</code> (""Cannot find module, ""firebase/app)</p>

<p><code>import { Router } from '@angular/router';</code> (""Cannot find module, ""@angular/router"")</p>

<p>Here's my app.module.ts file, in case that's useful:</p>

<pre><code>import { MaterializeModule } from 'angular2-materialize'
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';
import { masterFirebaseConfig } from './api-keys';
import { AngularFireModule } from 'angularfire2';
import { AngularFireDatabaseModule } from 'angularfire2/database';
import { AppComponent } from './app.component';
import { YoutubeComponent } from './youtube/youtube.component';
import { routing } from './app.routing';
import { NewMatchComponent } from './new-match/new-match.component';
import { CreateAccountComponent } from './create-account/create-account.component';
import { TestDbComponent } from './test-db/test-db.component';
import { LandingComponent } from './landing/landing.component';
import { MatchDisplayComponent } from './match-display/match-display.component';
import { AuthorizationService } from './authorization.service';
import { AngularFireAuthModule } from 'angularfire2/auth';
import { DatabaseService } from './database.service';
import { TextTransformationService } from './text-transformation.service';
import { ValidationService } from './validation.service';
import { LoginComponent } from './login/login.component';
import { ProtectionGuard } from './protection.guard';
import { AllMatchesComponent } from './all-matches/all-matches.component';
import { AnnotationDisplayComponent } from './annotation-display/annotation-display.component';
import { D3Service } from './d3.service';
import { NotfoundComponent } from './notfound/notfound.component';
import { UserStatusReportComponent } from './user-status-report/user-status-report.component';
import { PaymentOrAnnotationDetailsComponent } from './payment-or-annotation-details/payment-or-annotation-details.component';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatSelectModule } from '@angular/material/select';
import { MatOptionModule } from '@angular/material/core';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material';
import { MatTableModule } from '@angular/material/table';
// import { MatTreeModule } from '@angular/material';
import { MatTreeModule } from '@angular/material/tree';
import { MatSortModule } from '@angular/material';
import { MatDatepickerModule, MatNativeDateModule, MatPaginatorModule } from '@angular/material';
import {MatProgressSpinnerModule} from '@angular/material/progress-spinner';
import { CdkTreeModule } from '@angular/cdk/tree';


export const firebaseConfig = {
  apiKey: masterFirebaseConfig.apiKey,
  authDomain: masterFirebaseConfig.authDomain,
  databaseURL: masterFirebaseConfig.databaseURL,
  storageBucket: masterFirebaseConfig.storageBucket
};

@NgModule({
  declarations: [
    AppComponent,
    YoutubeComponent,
    NewMatchComponent,
    CreateAccountComponent,
    TestDbComponent,
    LandingComponent,
    MatchDisplayComponent,
    LoginComponent,
    AllMatchesComponent,
    AnnotationDisplayComponent,
    NotfoundComponent,
    UserStatusReportComponent,
    PaymentOrAnnotationDetailsComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    routing,
    MaterializeModule,
    ReactiveFormsModule,
    AngularFireModule.initializeApp(firebaseConfig),
    AngularFireDatabaseModule,
    AngularFireAuthModule,
    BrowserAnimationsModule,
    MatSlideToggleModule,
    CdkTreeModule,
    MatSelectModule,
    MatOptionModule,
    MatInputModule,
    MatNativeDateModule,
    MatDatepickerModule,
    MatTableModule,
    MatSelectModule,
    MatSortModule,
    MatProgressSpinnerModule,
    MatPaginatorModule,
    MatTreeModule
  ],
  providers: [AuthorizationService, DatabaseService, ProtectionGuard, D3Service, ValidationService, TextTransformationService],
  bootstrap: [AppComponent]
})
export class AppModule { }
</code></pre>

<p>And here's the branch of the repo containing all of these issues.</p>

<pre><code>git clone https://github.com/Atticus29/dataJitsu.git
cd dataJitsu
git checkout version-hell-SO 
npm install
ng serve
</code></pre>

<p>Any troubleshooting hints or outright solutions to the importing issues are welcome and encouraged!</p>
","1009215","","1009215","","2018-07-02 04:21:46","2019-01-17 12:08:06","error TS2339: Property 'takeUntil' does not exist on type 'Observable<Foo>' and other rxjs v.6 errors","<angular><typescript><rxjs><rxjs5><rxjs6>","1","1","5","","","CC BY-SA 4.0"
"51132081","1","","","2018-07-02 08:39:34","","1","46","<p>This is my <code>registerOrde</code>, that saves and Order then a list of OrderedProduct, and then ""returns"" an Order.</p>

<pre><code>private createOrder(order: Order): Observable&lt;Order&gt; {...}
    private createOrderedProduct(orderedProduct: OrderedProduct): Observable&lt;OrderedProduct&gt; {...}
    public registerOrder(order: Order): Observable&lt;Order&gt; {
    return new Observable&lt;Order&gt;(subscriber =&gt; {
      this.createOrder(order).subscribe(
        createdOrder =&gt; {
          if (order.orderedProducts) {
            let observableBatch = [];
            order.orderedProducts.forEach(orderedProduct =&gt; {
              orderedProduct.order = createdOrder;
              observableBatch.push(this.createOrderedProduct(orderedProduct));
            });
            forkJoin(observableBatch).subscribe(
              products =&gt; {
                createdOrder.orderedProducts = products;
                subscriber.next(createdOrder);
                subscriber.complete();
              },
              error =&gt; {
                subscriber.error(error);
                subscriber.complete();
              }
            );
          } else {
            subscriber.next(createdOrder);
            subscriber.complete();
          }
        },
        error =&gt; {
          subscriber.error(error);
          subscriber.complete();
        }
      );
    });
}
</code></pre>

<p>I would like to have the same behaviour but in a more correct way (i.e. using operators and removing the 'new Observable' instruction). I'm using Angular 6.</p>

<p>What operators should I use? Any advice?</p>
","2378730","","4134099","","2018-07-02 09:15:25","2018-07-02 09:15:25","RXJS 6 - saving collection after one entity","<angular><rxjs6>","0","0","","","","CC BY-SA 4.0"
"51142825","1","","","2018-07-02 19:45:29","","1","77","<p>rxjs 6.2.1</p>

<p>I'm getting <code>ClusterStreams__.a.subscribe is not a function</code></p>

<p>I'm trying to pipe the results of <code>getClusterArns()</code> into <code>describeClusters()</code> with the below code ... </p>

<pre><code>function getClusterArns() {
        const ecs = new AWS.ECS();
        return ecs.listClusters().promise();
}

function describeClusters(clusterArns) {
    const params = { clusters: clusterArns };
        const ecs = new AWS.ECS();
        return ecs.describeClusters(params).promise();
}


export const ClusterArnStream = from(getClusterArns());
export const ClusterStream = pipe(
  combineLatest(ClusterArnStream),
  mergeMap(([_, clusterArnsResponse]) =&gt; describeClusters(clusterArnsResponse.clusterArns)),
  map(x =&gt; x.clusters),
  multicast(() =&gt; new ReplaySubject(1))
);
</code></pre>
","215800","","","","","2018-07-03 01:06:26","rxjs6 Piping two observables gives subscribe is not a function","<javascript><reactjs><ecmascript-6><observable><rxjs6>","0","0","","","","CC BY-SA 4.0"
"51149424","1","51149655","","2018-07-03 08:00:31","","1","1316","<p>I would like to know what is the best practice when making http request one after another, especially, I'll be required to use the return value from the first request. Currently, I've a nested subscription to achieve this issue [See the code below]. </p>

<p>I tried with siwtchMap, mergeMap &amp; concat from RxJS, but it didn't seem to work. Any suggestion will be help for. </p>

<pre><code>onStartUp() {
    this.recordingService.getRecording(this.id)
     .subscribe(x =&gt; {
       this.recording = x;
       const params = new Chunk(this.recording, 0, 30);
       this.recordingService.getSignal(params)
        .subscribe(data =&gt; console.log(data));
     });
  }
</code></pre>
","7688608","","","","","2018-07-03 15:03:28","Angular RxJS Nested Subscribe with multiple Http Requests","<angular><http><rxjs><rxjs6>","1","1","1","","","CC BY-SA 4.0"
"51150889","1","51150982","","2018-07-03 09:20:36","","9","5054","<p>On upgrade of rx js from 5 to 6, throws below error </p>

<p>[ts] Property 'filter' does not exist on type 'BehaviorSubject'.</p>

<p><strong>Current Behavior</strong></p>

<pre><code>import {BehaviorSubject} from 'rxjs';

tokenSubject: BehaviorSubject&lt;string&gt; = new BehaviorSubject&lt;string&gt;(null);
return this.tokenSubject
                .filter(token =&gt; token != null)
                .take(1)
                .switchMap(token =&gt; {
                    return next.handle(this.addToken(req));
                });
</code></pre>

<p>[ts] Property 'filter' does not exist on type 'BehaviorSubject'.</p>

<p><strong>Environment</strong> </p>

<pre><code> ""@angular/common"": ""^6.0.3"",
   ""rxjs"": ""^6.0.0"",
</code></pre>

<p>Expected behavior</p>

<p>No error and working fine</p>

<p><strong>Previous Behavior</strong> </p>

<pre><code>import { BehaviorSubject } from ""rxjs/BehaviorSubject"";
tokenSubject: BehaviorSubject&lt;string&gt; = new BehaviorSubject&lt;string&gt;(null);
return this.tokenSubject
                .filter(token =&gt; token != null)
                .take(1)
                .switchMap(token =&gt; {
                    return next.handle(this.addToken(req));
                });
</code></pre>

<p>[ts] Property 'filter' does not exist on type 'BehaviorSubject'.</p>

<p><strong>Environment</strong> </p>

<pre><code>""@angular/common"": ""^5.0.3"",
  ""rxjs"": ""^5.4.3""
</code></pre>
","630209","","","","","2018-07-03 09:24:56","Property 'filter' does not exist on type 'BehaviorSubject<string>'. in rxjs 6","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51157064","1","","","2018-07-03 14:26:50","","0","478","<p>Could some one help me, because I am stuck in this function but is very important in the application.</p>

<p><strong>Typescript File</strong></p>

<pre><code>get $approved(): Observable&lt;boolean&gt; {
  return this.$entries.map(entries =&gt; {
    if (entries.length &gt; 0) {
      return false;
    } else {
      entries.every(entry =&gt; {
        return entry.approved != null;
      })
    }
  });
}
</code></pre>

<p><strong>HTML file</strong></p>

<pre><code>&lt;h1 *ngIf=""$approved | async""&gt;PLANT&lt;/h1&gt;
</code></pre>

<p>The problem is, that it will never show the H1 tag. And I don't have a clue why not.</p>
","10027358","","9040953","","2018-07-03 16:43:18","2018-07-03 16:43:18","Observable<boolean> not working","<angular><typescript><firebase><rxjs6>","3","5","","","","CC BY-SA 4.0"
"51157294","1","","","2018-07-03 14:39:13","","1","901","<p>Here is a simple post function, I am able to unit test success and catchError 
in jasmine. Is it possible to test the finalize in jasmine? i.e in finalize, can we expect loader to be closed or not?</p>

<pre><code> post(url,requestData){
    this.http.post(url, requestData).pipe(
          response =&gt; this.Response(response),
          catchError((error: Response) =&gt; this.Error(error, msg)),
          finalize(() =&gt; {
            loader.close();
          })
    }
</code></pre>

<p>In finalize I am closing loader. I need to unit test the close loader to be called in finalize.</p>
","4031891","","2117156","","2020-06-10 13:00:30","2020-06-10 13:00:30","RXjs 6 callbacks testing with jasmine","<rxjs><karma-jasmine><jasmine2.0><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"51171216","1","51174327","","2018-07-04 10:14:36","","1","471","<p>In a web app I'm using Angular and RxJS 6. The application has a login, the response of the login is a token so, after the login, I save the token in the sessionStorage and then I decode the token to save the current logged in user. This is the state after the login:</p>

<p><a href=""https://i.stack.imgur.com/XTgsA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XTgsA.png"" alt=""enter image description here""></a></p>

<p>I'm trying to develop this behaviour: if the user go to page ""..login"" (so in login.components.ts) and if he is already logged in, the application will redirect to the home page.
This is my code inside ngOnInit() in <strong>login.component.ts</strong>:</p>

<pre><code>  ngOnInit() {
   this.store.select('auth')
     .pipe(take(1),
       map((authState: fromAuth.State) =&gt; {
         console.log('test');
         if (authState.authenticated) {
           this.router.navigate(['/home']);
         }
      }));
}
</code></pre>

<p>This is the Interface of AppState:</p>

<pre><code>export interface AppState {
  user: fromProfile.State,
  auth: fromAuth.State,
  core: fromCore.State
}
</code></pre>

<p>Testing it, I login, I go to home, then I go to login page, I put a breakpoint in the console.log() but it doesn't reach the breakpoint, it doesn't even enter it, and so it doesn't redirect to home page. Why?</p>

<p><strong>* UPDATED *</strong>: this is the screen of debug
<a href=""https://i.stack.imgur.com/0CK7b.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0CK7b.png"" alt=""enter image description here""></a></p>
","5210601","","5210601","","2018-07-04 10:40:19","2020-06-21 18:53:45","Select a State with RxJS in Angular 6 doesn't work","<angular><redux><rxjs><rxjs6><ngoninit>","1","17","","","","CC BY-SA 4.0"
"51174548","1","","","2018-07-04 13:10:47","","0","114","<p>I've upgraded my app from Angular 5 to 6 following <a href=""https://update.angular.io"" rel=""nofollow noreferrer"">https://update.angular.io</a> tutorial. The app doesn't load producing errors:</p>

<pre><code>zone.js:1050 GET http://localhost:9000/node_modules/rxjs/scheduler/VirtualTimeScheduler.js 404 (Not Found)
zone.js:1050 GET http://localhost:9000/node_modules/rxjs/testing/TestScheduler.js 404 (Not Found)
zone.js:1050 GET http://localhost:9000/node_modules/rxjs/scheduler/AsyncScheduler.js 404 (Not Found)
zone.js:1050 GET http://localhost:9000/node_modules/rxjs/scheduler/AsyncAction.js 404 (Not Found)
</code></pre>

<p>package.json: <a href=""https://pastebin.com/Qwhi63VR"" rel=""nofollow noreferrer"">https://pastebin.com/Qwhi63VR</a></p>

<p>systemjs.config.js: <a href=""https://pastebin.com/3U7Qih1g"" rel=""nofollow noreferrer"">https://pastebin.com/3U7Qih1g</a></p>

<p>Any ideas what could be wrong here and how to fix it?</p>
","717839","","","","","2018-07-04 13:24:51","rxjs/scheduler/VirtualTimeScheduler.js 404 Not Found","<javascript><angular><rxjs><systemjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"51174949","1","","","2018-07-04 13:31:33","","1","284","<p>We are querying <code>graphql</code> over websocket to have a subscription to a list of entities. We use pagination as the list is supposed to be scrollable indefinitely. We also want to see changes made in db in real time in the list on the front-end.</p>

<p>This list can be <code>filtered</code>, <code>sorted</code> and <code>paginated</code>.</p>

<p>We have the class <code>SelectParams</code> that helps us to do that: </p>

<pre><code>export class SelectParams {
    page = 0;
    query = '';
    sort: Sort = { sortBy: 'creationDate', sortOrder: 'DESC' };
    take = 30;
}
</code></pre>

<p>Then when we want to subscribe to a list we just give a <code>selectParams$ = Observable&lt;SelectParams&gt;</code> to get the list that is ""reactive"" and reacts to the changes in <code>selectParams$</code>. This is used like this:</p>

<pre><code>    this.items$ = this.featureSrv.selectMany(this.selectParams$)
</code></pre>

<p>Under the hood the <code>selectMany</code> works like this:</p>

<pre><code>// when we call selectMany we just push the params to the pipeline
selectMany(params$: Observable&lt;SelectParams&gt; = of(new SelectParams())): Observable&lt;T[]&gt; {
    this.selectManyParams$.next(params$);
    return this.selectMany$;
}

// subject where we push params to sort, paginate and filter
selectManyParams$ = new ReplaySubject&lt;Observable&lt;SelectParams&gt;&gt;(1);
// when the params change then so does this observable, which is returned by the selectMany function
selectMany$ = this.selectManyParams$.asObservable().pipe(
    // retrieve params from their observable form
    flatMap(params$ =&gt; params$),
    // when the params haven't changed we shouldn't do anything
    distinctUntilChanged(),
    // then we query graphql to get a suscription to some part of the data
    switchMap(({ page, sort, query, take }: SelectParams) =&gt; {
    // the selectMany here is a subscription to some data on the server
        return this.apolloWrapper.selectMany(this.gql, page, sort, query, take ).pipe(
    // we add page data so we can use it in the scan
            map(data =&gt; ({ data, page }) as any)
        );
    }),
    // we append the result if page was incremented
    // else we just return the result
    scan((acc: any, curr: any) =&gt; curr.page === 0 ? curr.data : acc.concat(curr.data), [])
);
</code></pre>

<p>The method <code>this.apolloWrapper.selectMany</code> is a method we created that just does a subscription over websocket to some slice of the data.
Say we had <code>page = 0</code> then <code>this.apolloWrapper.selectMany</code> will return a subscription to the first slice of data, then when <code>page = 1</code>, <code>this.apolloWrapper.selectMany</code> returns a subscription to the second slice of data.</p>

<p>The problem arise when we load the second page and make a modification to items to the first slice, the <code>scan</code> is then triggered and items are readded to the end of the list.</p>
","4299560","","4299560","","2018-07-10 06:45:00","2018-07-10 06:45:00","rxjs pagination with subscription to each page","<typescript><rxjs><graphql><apollo><rxjs6>","0","0","","","","CC BY-SA 4.0"
"51181023","1","","","2018-07-04 21:39:33","","1","1454","<p>I'm new in Rxjs and I have faced with a strange behavior of BehaviorSubject with scan and combineLatest operator. Below the code of simple component:</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { BehaviorSubject, of, combineLatest } from 'rxjs';
import { switchMap, scan} from 'rxjs/operators';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit {

  stream1 = new BehaviorSubject('');
  stream2 = new BehaviorSubject(0);
  result: any;
  counter = 1;

  sub: any;

  constructor() {}

  ngOnInit() {
    this.sub = this.stream2.pipe(
      scan((acc, v) =&gt; [...acc, v], []),
    );
    this.result = this.stream1.pipe(
      switchMap(data =&gt; combineLatest(of(data), this.sub))
    ).subscribe(val =&gt; console.log(val));
    this.stream1.next('init');
    this.stream2.pipe(scan((acc, v) =&gt; [...acc, v], [])).subscribe(val =&gt; console.log('Track Stream 2: ', val));
  }

  onClick() {
    this.stream2.next(this.counter++);
  }

  onClick2() {
    this.stream1.next('test ' + this.counter);
  }
}


&lt;button (click)=""onClick()""&gt;Test&lt;/button&gt;
&lt;button (click)=""onClick2()""&gt;Test2&lt;/button&gt;
</code></pre>

<p>As result of ""this.result"" stream I expect array where the first value - the latest value from 'this.stream1' and the 2nd value is an array with all values which were collected by 'this.sub', but on fact from ""this.sub"" I get only the latest value, as if my scan operator was ignored..
See attached img:</p>

<p><a href=""https://i.stack.imgur.com/UKv8L.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UKv8L.png"" alt=""enter image description here""></a></p>

<p>Could you please explain how to reach desired result?
Thank you all!</p>

<p>Ps. Angular v6.0.7 and RxJs v6.2.1</p>
","6874350","","9801830","","2018-07-05 03:58:25","2018-07-05 03:58:25","Strange behavior of BehaviorSubject with combineLatest","<javascript><angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51192925","1","51193046","","2018-07-05 13:43:58","","31","25207","<p>I was using RXJS 5, now as I upgraded it to 6, I am facing some problems.</p>

<p>Previously I was able to use catch and finally but as per update catch is replaced with catchError (with in the pipe) now how to use finally?</p>

<p>Also I have some questions :</p>

<p>Do I need to change throw->throwError (in below code Observable.throw(err);)</p>

<pre><code>import { Observable, Subject, EMPTY, throwError } from ""rxjs"";
import { catchError } from 'rxjs/operators';

return next.handle(clonedreq).pipe(
          catchError((err: HttpErrorResponse) =&gt; {
        if ((err.status == 400) || (err.status == 401)) {
            this.interceptorRedirectService.getInterceptedSource().next(err.status);
            return Observable.empty();
        } else {
            return Observable.throw(err);
        }
       }) 
        //, finally(() =&gt; {
        //  this.globalEventsManager.showLoader.emit(false);
        //});
      );
</code></pre>

<p>Also how to use publish().refCount() now ?</p>
","9870625","","","","","2019-05-31 10:16:48","Angular : how to call finally() with RXJS 6","<angular><rxjs><angular6><rxjs6>","3","0","5","","","CC BY-SA 4.0"
"51196886","1","","","2018-07-05 17:20:30","","2","2650","<p>I have an Angular 6 with Mat Tables retrieving related data from two different services. The first service retrieves all data it's data and then passes 
 criteria to the second through mergeMap to retrieve the addition data for each record returned in the first. </p>

<p>My issue is that I can see the data being returned w/o error and the table iterating rows in the output <strong>but</strong> nothing being displayed in the table. The two relevant classes are:</p>

<pre><code>export class GetMyShizz implements OnInit{
     dataSource = new IssueDataSource(this.issueService);
     displayedColumns: string[] = ['created', 'updated', 'number', 'title', 'pipeline', 'estimate'];
     constructor(private issueService: IssueService) {}
     ngOnInit() {}
}
export class IssueDataSource extends DataSource&lt;any&gt; {
      constructor(private issueService: IssueService) {
        super();
      }
      connect(): Observable&lt;any&gt; {
        return this.issueService.getIssues()
        .pipe(
            mergeMap((ghIssues) =&gt; {
                const zhIssuesQueries: Observable&lt;any&gt;[] = [];
                for (let ghIssue of ghIssues) {
                    zhIssuesQueries.push(this.issueService.getZHIssue(ghIssue.number));
                }
                return forkJoin(...zhIssuesQueries);
            })
        )
      }
      disconnect() {
      }
}
</code></pre>

<p>I'm fairly certain it has to do with the way i am assigning the DataSource (issueDataSource) for the table in the first class but not sure how to make the reference. It worked when I was only calling one service (before I added the mergeMap stoof.)</p>

<h3>Edit (w/ HTML template)</h3>

<pre><code>  &lt;div class=""issue-table-container""&gt;
    &lt;table mat-table [dataSource]=""dataSource"" class=""issue-table""
           matSort matSortActive=""created"" matSortDisableClear matSortDirection=""asc""&gt;

      &lt;ng-container matColumnDef=""number""&gt;
        &lt;th mat-header-cell *matHeaderCellDef&gt;Issue #&lt;/th&gt;
        &lt;td mat-cell *matCellDef=""let row""&gt;{{row.number}}&lt;/td&gt;
      &lt;/ng-container&gt;

      &lt;ng-container matColumnDef=""title""&gt;
        &lt;th mat-header-cell *matHeaderCellDef&gt;Title&lt;/th&gt;
        &lt;td mat-cell *matCellDef=""let row""&gt;&lt;b&gt;{{row.title}}&lt;/b&gt;
        &lt;button mat-raised-button class=""label-button"" *ngFor=""let label of row.labels"" [ngStyle]=""setBadgeStyles(label.color)""&gt;{{label.name}}&lt;/button&gt;&lt;/td&gt;
      &lt;/ng-container&gt;

      &lt;ng-container matColumnDef=""created""&gt;
        &lt;th mat-header-cell *matHeaderCellDef mat-sort-header disableClear&gt;
          Created
        &lt;/th&gt;
        &lt;td mat-cell *matCellDef=""let row""&gt;{{row.created_at | date:'shortDate'}}&lt;/td&gt;
      &lt;/ng-container&gt;

      &lt;ng-container matColumnDef=""updated""&gt;
        &lt;th mat-header-cell *matHeaderCellDef mat-sort-header disableClear&gt;
          Updated
        &lt;/th&gt;
        &lt;td mat-cell *matCellDef=""let row""&gt;{{row.updated_at | date:'shortDate'}}&lt;/td&gt;
      &lt;/ng-container&gt;

      &lt;ng-container matColumnDef=""estimate""&gt;
        &lt;th mat-header-cell *matHeaderCellDef mat-sort-header disableClear&gt;
          Estimate
        &lt;/th&gt;
        &lt;td mat-cell *matCellDef=""let row""&gt;{{row.estimate}}&lt;/td&gt;
      &lt;/ng-container&gt;

      &lt;ng-container matColumnDef=""pipeline""&gt;
        &lt;th mat-header-cell *matHeaderCellDef mat-sort-header disableClear&gt;
          Pipeline
        &lt;/th&gt;
        &lt;td mat-cell *matCellDef=""let row""&gt;{{row.pipeline}}&lt;/td&gt;
      &lt;/ng-container&gt;

      &lt;tr mat-header-row *matHeaderRowDef=""displayedColumns""&gt;&lt;/tr&gt;
      &lt;tr mat-row *matRowDef=""let row; columns: displayedColumns;""&gt;&lt;/tr&gt;
    &lt;/table&gt;
  &lt;/div&gt;
</code></pre>
","1226288","","1226288","","2018-07-05 23:27:39","2018-07-05 23:27:39","Angular 6 Mat Table DataSource w/ Observables","<angular><angular-httpclient><rxjs6>","0","2","","","","CC BY-SA 4.0"
"51198556","1","","","2018-07-05 19:26:09","","0","146","<p>I just updated my app to Angular 6 and all of my observable imports need to be changed to import {Observable} from 'rxjs' instead of 'rxjs/Observable'</p>

<p>Is there a fast way I can do this? Instead of going in every file and fixing the path.</p>
","8407973","","","","","2019-11-11 09:55:04","Angular 6 Refactoring","<observable><angular6><rxjs6>","2","0","","","","CC BY-SA 4.0"
"51199651","1","","","2018-07-05 20:47:03","","0","2325","<p>Here is extract of my service, I would like <code>getIssues</code> metod to return observable, rather than promise resolving into observable as it would seem so much more clean. I am confident there is a way, I am just a bit too new to this. </p>

<pre><code>import { Injectable } from '@angular/core'; (...)

@Injectable({ providedIn: 'root', })
export class IssueService {
    private users!: Promise&lt;Map&lt;number, Users&gt;;
    constructor(private http: HttpClient, private userService: UserService) {
        this.users = this.userService.getUsers()
    }

    getIssues() {
        return this.users.then(users =&gt; {
            return this.http.get&lt;Iissue[]&gt;(URL, OPTIONS).pipe(
                map(issues =&gt; new Issue(issue, users)),
            );
        });
    }
}
</code></pre>
","3001856","","","","","2018-07-06 07:15:10","Merge promise with observable","<angular><rxjs><rxjs6>","3","1","","","","CC BY-SA 4.0"
"51201998","1","51202065","","2018-07-06 01:47:34","","2","1031","<p>i have define a behaviorSubject:</p>

<pre><code>measurementSearchChange$ = new BehaviorSubject('');
this.measurementSearchChange$
  .asObservable()
  .pipe(debounceTime(500))
  .pipe(
    switchMap((keyword: string) =&gt;
      this.warningService.getInfluxdbQuery(
        this.selectedMonitorOption,
        'measurement',
        { search_name: keyword }
      )
    )
  )
  .subscribe((data: any) =&gt; {
    this.measurementOptions = data;
    this.isLoading = false;
  });
</code></pre>

<p>when some action, will do that:</p>

<pre><code>this.measurementSearchChange$.next(keyword);
</code></pre>

<p>it work well now, but i want add a switchMap and zip them so that i can subscribe two different data, like：</p>

<pre><code>this.measurementSearchChange$
  .asObservable()
  .pipe(debounceTime(500))
  .pipe(
    switchMap((keyword: string) =&gt;
      this.warningService.getInfluxdbQuery(
        this.selectedMonitorOption,
        'measurement',
        { search_name: keyword }
      )
      // another 
      this.warningService.getInfluxdbQuery2(
        this.selectedMonitorOption,
        'measurement2',
        { search_name: keyword }
      )
    )
  )
  .subscribe((data1: any, data2: any) =&gt; {
    this.measurementOptions = data;
    this.isLoading = false;
  });
</code></pre>

<p>so how can do that? any help is appreciate</p>
","6408449","","","","","2018-07-06 03:03:25","rxjs zip two switchMap?","<angular><rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51204503","1","51204530","","2018-07-06 06:48:03","","1","5419","<p>I am calling an API which returns me a JSON Object. I need to map this object to an array.</p>

<p>Below is my code but after API call neither am getting any response nor any error.</p>

<pre><code>export class Features {
  MenuId: number;
  MenuName: string;
  Description: string;
  RoutePath: string;
}

featureList: Features[] = [];
 constructor(private http: HttpClient)

 getFeatureListByLoggedInUser(userID: number) { debugger;       
    return this.http.get(this.myAppUrl + ""api/Employee/GetMenusByUID/"" + userID)     
      .pipe(
      map(
        (data: any[]) =&gt; {
        debugger;
        this.featureList = data;
        //return true;
      }), catchError(error =&gt; {
        debugger;
        return throwError('Something went wrong!')
      })
    );
 }
</code></pre>

<p>Also tried below code but its giving me an error :</p>

<blockquote>
  <p>Type object is not assignable to type 'any[]'</p>
</blockquote>

<pre><code> featureList: Array&lt;any&gt; = [];

 getFeatureListByLoggedInUser(userID: number) { debugger;  
    return this.http.get(this.myAppUrl + ""api/Employee/GetMenusByUID/"" + userID)
      .subscribe(
        data =&gt; {
          debugger;
          this.featureList = data;            
      });
 }
</code></pre>

<p><strong>Edit :</strong></p>

<pre><code> return this.http.get&lt;Array&lt;Features&gt;&gt;(this.myAppUrl + ""api/Employee/GetMenusByUID/"" + userID)   
      .subscribe(
        data =&gt; {
          debugger;
          //this.featureList = data;  
      });
</code></pre>
","9870625","","9870625","","2018-07-06 07:16:52","2018-07-06 07:21:39","Angular-HttpClient: Map object to array properties","<angular><rxjs><angular6><angular-httpclient><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51205810","1","51205938","","2018-07-06 08:12:00","","4","10571","<p>I have a login guard which basically check if the user il logged in. If he is logged, it skips the login and go to home page. I wrote this code, and this works:</p>

<pre class=""lang-typescript prettyprint-override""><code>canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    return this.store.select(fromApp.isAuthenticated)
        .pipe(take(1),
            map(isAuthenticated =&gt; {
                if (isAuthenticated) {
                    this.router.navigate(['/home']);
                    return false;
                } else {
                    return true;
                }
            })
        )
}
</code></pre>

<p>Now, since I don't have to change or edit the output data (isAuthenticated boolean), I thought: well, why don't use tap operator? So, I re-write my code:</p>

<pre class=""lang-typescript prettyprint-override""><code>canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    return this.store.select(fromApp.isAuthenticated)
        .pipe(take(1),
   HERE------&gt; tap(isAuthenticated =&gt; {   &lt;------ HERE
                if (isAuthenticated) {
                    this.router.navigate(['/home']);
                    return false;
                } else {
                    return true;
                }
            })
        )
}
</code></pre>

<p>Then I went to Chrome, and I saw black page and this was the case:</p>

<ul>
<li>I open the app</li>
<li>I'm not logged in</li>
<li>The url becomes <a href=""http://localhost:4200/#/"" rel=""nofollow noreferrer"">http://localhost:4200/#/</a> instead of
<a href=""http://localhost:4200/#/login"" rel=""nofollow noreferrer"">http://localhost:4200/#/login</a>, result: blank page</li>
<li>If I try to go manually in <a href=""http://localhost:4200/#/login"" rel=""nofollow noreferrer"">http://localhost:4200/#/login</a>, it stays in
that page but I see a blank page</li>
<li>If I try to go home, it redirects on <a href=""http://localhost:4200/#/"" rel=""nofollow noreferrer"">http://localhost:4200/#/</a> instead
of <a href=""http://localhost:4200/#/login"" rel=""nofollow noreferrer"">http://localhost:4200/#/login</a></li>
</ul>

<p>In any case, I see blank page. So, I went in debug and I noticed that it correctly jump inside the if/else block... so, why tap() is breaking the app?</p>
","5210601","","430885","","2019-01-14 11:35:34","2019-01-14 11:35:46","Use tap() instead of map() RxJS and Angular","<angular><redux><rxjs><observable><rxjs6>","2","7","","","","CC BY-SA 4.0"
"51212294","1","51287925","","2018-07-06 14:11:02","","0","105","<p>This can't be the only way to unsub Behavior Subjects : </p>

<pre><code>  maxSub;
  fromSub;
  toSub;
  pageNumberSub;
  originalMaxSub;
  selectionSub;
  selectionOfInterestSub;

  constructor(private store: StoreService) {}

  ngAfterContentChecked(){
    this.maxSub = this.store.max$.subscribe((max) =&gt; {
      if(max !== null &amp;&amp; max !== undefined){
        this.max = max;
        this.maxPages = Math.floor(this.max / Variables.to);
        this.pages = Array.from(Array(this.maxPages), (x, i) =&gt; i + 1);
      }
    }, (error) =&gt; console.log(error), () =&gt; {});

    this.fromSub = this.store.from$.subscribe((from) =&gt; {
      if(from !== null &amp;&amp; from !== undefined) {this.from = from; this.split = this.to - (this.from - 1)}
    }, (error) =&gt; console.log(error), () =&gt; {});

    this.toSub = this.store.to$.subscribe((to) =&gt; {
      if(to !== null &amp;&amp; to !== undefined) {this.to = to; this.split = this.to - (this.from - 1)}
    }, (error) =&gt; console.log(error), () =&gt; {});

    this.pageNumberSub = this.store.pageNumber$.subscribe((pageNumber) =&gt; {
      if(pageNumber !== null &amp;&amp; pageNumber !== undefined) {this.page = pageNumber;}
    }, (error) =&gt; console.log(error), () =&gt; {});

    this.originalMaxSub = this.store.originalMax$.subscribe((originalMax) =&gt; {
      if(originalMax !== null &amp;&amp; originalMax !== undefined) {this.originalMax = originalMax;}
    }, (error) =&gt; console.log(error), () =&gt; {});

    this.selectionSub = this.store.selection$.subscribe((selection) =&gt; {
      if(selection !== null &amp;&amp; selection !== undefined) this.selectedAmount = selection.length;
    }, (error) =&gt; console.log(error), () =&gt; {});

    this.selectionOfInterestSub = this.store.selectionOfInterest$.subscribe((selectionOfInterest) =&gt; {
      if(selectionOfInterest !== null &amp;&amp; selectionOfInterest !== undefined) this.selectionOfInterest = selectionOfInterest;
    }, (error) =&gt; console.log(error), () =&gt; {});
  }

  ngOnDestroy(){
    this.maxSub.unsubscribe();
    this.fromSub.unsubscribe();
    this.toSub.unsubscribe();
    this.pageNumberSub.unsubscribe();
    this.originalMaxSub.unsubscribe();
    this.selectionSub.unsubscribe();
    this.selectionOfInterestSub.unsubscribe();
  }
</code></pre>

<p>in regular old Observables you can just : </p>

<pre><code>alive = true;

constructor(private store: StoreService) {}

  ngAfterContentChecked(){
     this.store.thing.subscribe().takeWhile(this.alive)...
  }

  ngOnDestroy(){
    this.alive = false;
  }
</code></pre>

<p>which is much simpler.</p>

<p>Isn't there a way to do the same with Behavior Subjects?</p>

<p>Another thing : am I missing a fundamental property of Behavior Subjects that they only subscribe once within an class no matter how many times the subscribe is called and that's why there's no such thing as <code>takeWhile()</code> on Behavior Subjects?</p>
","4770754","","","","","2018-07-11 14:19:50","Behavior Subject unsubscribe refactor","<behaviorsubject><rxjs6><unsubscribe>","1","0","","","","CC BY-SA 4.0"
"51213983","1","","","2018-07-06 15:56:35","","0","72","<p>I'm trying to use Angular6 and combine a number of httpclient.get calls using forkjoin.</p>

<p>Currently forkjoin works well if all the http calls are successful. however i would like to catch and exception, return something, maybe the array item and continue on to the next http call.</p>

<pre><code>import { HttpClient } from '@angular/common/http';
import { Observable, Observer, forkJoin, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators'

public list = [
            {""id"": 1, ""img"" : ""image.png"",  ""color"": ""DodgerBlue"", ""network"": {}, ""config"": {}, ""name"": ""myname"", ""statsurl"": ""https://somewhere.com:8119"", ""poolurl"": ""https://somewhere.com""}}
    ];


let m = [...this.poollist];

let staturls = this.list.map(item =&gt; this.http.get(item.statsurl)
                                            .pipe(map((res:Response) =&gt; res)),
                                            .catchError(res =&gt; of({}))));


forkJoin(staturls).subscribe(data =&gt; {
  data.forEach(function(v, i) {
    m[i].config = v['config'];
  })
</code></pre>

<p>Thanks
Gary</p>
","5399779","","","","","2018-07-06 16:08:28","How to catch unsuccessful httpclient calls when using forkJoin","<angular6><angular-httpclient><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51226667","1","51226907","","2018-07-07 20:16:41","","1","164","<p>I want to make SR latch via RxJS. It should take 2 streams (#1 and #2) and emit only if #1 emit something. </p>

<p>Then it should ignore #1 and listen to #2 until it emits something. Then it should ""reset"" (EDIT: means stop emitting observables, but keep the subscription) and start listening to #1.</p>

<p>I made a quick jsfiddle: <a href=""https://jsfiddle.net/fczjusqn/11/"" rel=""nofollow noreferrer"">https://jsfiddle.net/fczjusqn/11/</a> with the bug - if you press start several times it will make interval start several times.</p>

<p>This is emulation of pausable process with a bit complex setup logic in my real app.</p>

<p>Obligatory code:</p>

<pre><code>// const start$ = ...
// const stop$ = ...

start$.pipe(
  flatMap(() =&gt; {
    // some setup logic...
    // ...creating another stream...
    // ...still setting up...
    return Rx.interval(1000)
      .pipe(
        takeUntil(stop$)
      )
    })    
  ).subscribe(() =&gt; console.log('interval'))
</code></pre>
","3099539","","3099539","","2018-07-07 21:28:29","2018-07-07 22:21:50","How to make SR Latch via RxJS 6?","<javascript><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51231734","1","51244455","","2018-07-08 11:53:27","","0","711","<p>i'm trying to implement play and pause button using Rxjs library. </p>

<pre><code>const play$ = fromEvent(playerImplementation, PLAYER_EVENTS.PLAY).pipe(mapTo(true));
const pause$ = fromEvent(playerImplementation, PLAYER_EVENTS.PAUSE).pipe(mapTo(false));
const waiting$ = fromEvent(playerImplementation, PLAYER_EVENTS.WAITING).pipe(mapTo(false));

let counterTime = 0;
const currentTime$ = interval(30).pipe(
 map(()=&gt;counterTime += 30));

const player$ = merge(play$, pause$, waiting$).pipe(
        switchMap(value =&gt; (value ? currentTime$ : EMPTY)));

// DIFFERENCE IN RESULTS
currentTime$.subscribe((v)=&gt; console.log(""Regular Count "" + v)); // get correctly 30,60,90,120...
player$.subscribe((v)=&gt;console.log(""Condition Count"" + v)); // get wrongly 30,150,270, 390
</code></pre>

<p>can anyone help in understanding why there is a difference between the results? </p>
","9015804","","","","","2018-07-09 11:27:18","Play and Pause interval rxjs","<rxjs><intervals><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51243029","1","","","2018-07-09 10:10:55","","0","1460","<pre><code> return auth.refreshToken().switchMap((token) =&gt; {
                if (token) {

                    return next.handle(this.addToken(req));
                }

                // If we don't get a new token, logout.
                auth.logoutUser(0);
                return empty;

            }).catch((e: any) =&gt; {
                // If there is an exception calling 'refreshToken', logout.
                auth.logoutUser(0);
                return empty;
            }).finally(() =&gt; {
                this.isRefreshingToken = true;
            });
</code></pre>

<p>This was working perfectly fine with Angular.</p>

<p><strong>""rxjs"": ""^5.4.3"",
    ""@angular/common"": ""^5.0.3"",</strong></p>

<p>Once upgraded,</p>

<p><strong>""@angular/common"": ""^6.0.3"",
 ""rxjs"": ""^6.0.0""</strong></p>

<p>I'm getting run time error </p>

<pre><code>""ApiService::handleError TypeError: auth.refreshToken(...).switchMap is not a function
"".
</code></pre>

<p>On searching found out the solution is to add pipe, So added</p>

<pre><code> return auth.refreshToken().pipe(switchMap((token) =&gt; {
                if (token) {

                    return next.handle(this.addToken(req));
                }

                // If we don't get a new token, logout.
                auth.logoutUser(0);
                return empty;

            }).catch((e: any) =&gt; {
                // If there is an exception calling 'refreshToken', logout.
                auth.logoutUser(0);
                return empty;
            }).finally(() =&gt; {
                this.isRefreshingToken = true;
            });
</code></pre>

<p>But it throws new compile time error </p>

<pre><code>Argument of type '(token: {}) =&gt; Observable&lt;HttpEvent&lt;any&gt;&gt; | ((scheduler?: SchedulerLike) =&gt; Observable&lt;never&gt;)' is not assignable to parameter of type '(value: {}, index: number) =&gt; ObservableInput&lt;HttpEvent&lt;any&gt;&gt;'.""
</code></pre>

<p>It looks like the problem with rxjs upgrade , what will be the fix for this ?</p>

<p>Modified import from,</p>

<pre><code>import { switchMap } from ""rxjs/operators""; to 
import 'rxjs/add/operator/switchMap'; 
</code></pre>

<p>Now it gives error to below section of code <strong>"" error TS2304: Cannot find name 'switchMap'.""</strong></p>

<pre><code> return this.tokenSubject.pipe(
                filter(token =&gt; token != null),
                take(1),
                switchMap(token =&gt; {
                    return next.handle(this.addToken(req));
                })
            );
</code></pre>
","630209","","630209","","2018-07-09 10:20:03","2018-07-09 14:00:51","Error related to rxjs uprade to 6 ""switchMap is not a function""","<angular><typescript><angular6><rxjs6>","1","4","","","","CC BY-SA 4.0"
"51243204","1","","","2018-07-09 10:20:11","","8","3638","<p>I have a rxjs@6 BehaviorSubject <code>source$</code>, I want get subvalue from <code>source$</code></p>

<pre><code>  const source$ = new BehaviorSubject(someValue);
  const subSource$ = source$.pipe(map(transform));
</code></pre>

<p>I expect the <code>subSource$</code> also is a BehaviorSubject, but is not and How can I get the <code>subSource$</code> is a BehaviorSubject ?</p>
","6497005","","","","","2018-12-13 13:22:22","BehaviorSubject map a BehaviorSubject","<rxjs><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"51255968","1","","","2018-07-10 01:11:37","","2","146","<p>I have 2 observables and I want to get a value from X if it exists, else get it from Y. The following works for me, but I am looking for a more succinct pattern.</p>

<pre><code>import {of} from 'rxjs';
import {map, mergeMap} from 'rxjs/operators';
import {getX, getY} from './getXY';

// getX(id: string): Observable&lt;X&gt;; // gets an X asyncronously
// getY(id: string): Observable&lt;Y&gt;; // gets a Y asyncronously

let id = ""abc"";

// get an X, or a Y if not X, that matches the id
getX(id).pipe(mergeMap((x: X) =&gt; {
  if (x) {
    return of(x);
  } else {
    return getY(id).pipe(map((y: Y) =&gt; {
      if (y) {
        return y;
      }
    }));
  }
})).subscribe((xy: X | Y) =&gt; { ... }
</code></pre>

<p>It seems to me that the of(x) is going in the wrong direction - that perhaps instead of mergeMap, there is a way to conditionally extract the Y from the getY without the need for the of(x).</p>

<p>Ideally I will write a getXY that does all that and returns an Observable&lt;X | Y&gt; that can be subscribed to.</p>

<hr>

<p>I create a <a href=""https://codepen.io/neonguru/pen/XBJPVo"" rel=""nofollow noreferrer"">codepen</a> with the original example and cartant's answer. Notice that when getX returns 'x', cartant's still calls getY - that is why I did not mark his answer as the solution. Feel free to fork and add your own solution.</p>
","784947","","784947","","2018-07-11 18:55:55","2018-07-12 15:20:07","Better Observable typescript pattern for if x of Observable<X> else y of Observable<Y>","<javascript><typescript><rxjs><observable><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"51260060","1","","","2018-07-10 08:04:22","","1","466","<p>In my angular app i'm using a resolver that in the method resolve returns an observable of promise. (true (routed) or false (routing failed))</p>

<p>In the version of rxjs6 the function ""Observable.fromPromise"" is replaced by ""from"" that looks for promise type/instance and will handle as one.</p>

<p><s>Why did i have another behavior in rxjs6 with ""from"", In the under example the router will not navigate to 'home', it seems that the promise doesn't emit/end</s></p>

<p>If i return it as Observable it will not route, to the given link, if i call it without evaluating the return value it works. </p>

<p>Example:</p>

<pre><code>import { from } from 'rxjs';

@Injectable()
export class ExampleResolver implements Resolve&lt;boolean&gt; {

  constructor(private router: Router) {
  }

  resolve(activatedRouteSnapshot: ActivatedRouteSnapshot): Observable&lt;boolean&gt; {
    return from(this.router.navigate(['/home'])); // not working
    // return Observable.fromPromise(this.router.navigate(['/home'])); works
  }
}
</code></pre>
","8757350","","8757350","","2018-07-10 12:01:31","2018-07-10 12:32:56","Angular router does not route if returned as Rxjs observable in Resolver","<angular><rxjs><rxjs6>","1","4","","","","CC BY-SA 4.0"
"51281017","1","51301958","","2018-07-11 08:45:14","","0","430","<p>I'm having an issue upgrading from RxJS5 to version 6.  I've got the following code:</p>

<pre><code>  private captureEvents(canvasEl: HTMLCanvasElement) {

    Observable
      .fromEvent(canvasEl, 'mousedown')
      .switchMap((e) =&gt; {
        return Observable
          .fromEvent(canvasEl, 'mousemove')
          .takeUntil(Observable.fromEvent(canvasEl, 'mouseup'))
          .pairwise()
      })
      .subscribe((res: [MouseEvent, MouseEvent]) =&gt; {
        const rect = canvasEl.getBoundingClientRect();

        const prevPos = {
          x: res[0].clientX - rect.left,
          y: res[0].clientY - rect.top
        };

        const currentPos = {
          x: res[1].clientX - rect.left,
          y: res[1].clientY - rect.top
        };

        this.drawOnCanvas(prevPos, currentPos);
      });
  }
</code></pre>

<p>But when I upgrade to RxJS6 I get the following error:</p>

<blockquote>
  <p>Property 'fromEvent' does not exist on type 'typeof Observable'.</p>
</blockquote>

<p>I tried to change my imports from this (RxJS5):</p>

<pre><code>import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/takeUntil';
import 'rxjs/add/operator/pairwise'; 
import 'rxjs/add/operator/switchMap';
</code></pre>

<p>To this (RxJS6):</p>

<pre><code>import { Observable, fromEvent } from 'rxjs';
import { switchMap, takeUntil, pairwise } from 'rxjs/operators';
</code></pre>

<p>This was my best attempt up upgrading the code:</p>

<pre><code>  private captureEvents(canvasEl: HTMLCanvasElement) {

    const obsMouseDown = fromEvent(canvasEl, 'mousedown').pipe(
      switchMap((e) =&gt; {
        const obsMouseMove = fromEvent(canvasEl, 'mousemove').pipe(
          takeUntil(a =&gt; {
            const obsMouseUp = fromEvent(canvasEl, 'mouseup').pipe(
              pairwise()
            );
            return obsMouseUp;
          }));

        return obsMouseMove;
      }))
      .subscribe((res: [MouseEvent, MouseEvent]) =&gt; {
        const rect = canvasEl.getBoundingClientRect();

        const prevPos = {
          x: res[0].clientX - rect.left,
          y: res[0].clientY - rect.top
        };

        const currentPos = {
          x: res[1].clientX - rect.left,
          y: res[1].clientY - rect.top
        };

        this.drawOnCanvas(prevPos, currentPos);
      });
  }
</code></pre>

<p>But this isn't working - I get an error for the ""takeUntil"" code:</p>

<blockquote>
  <p>Argument of type '(a: any) => Observable&lt;[Event, Event]>' is not
  assignable to parameter of type 'Observable'</p>
</blockquote>

<p>plnkr example of original code here:<br>
<a href=""https://embed.plnkr.co/QSvJxi/"" rel=""nofollow noreferrer"">https://embed.plnkr.co/QSvJxi/</a></p>
","1659806","","","","","2018-07-18 14:57:46","Upgrading from RxJS5 to RxJS6","<angular5><observable><rxjs5><angular6><rxjs6>","3","0","","","","CC BY-SA 4.0"
"51285635","1","51287638","","2018-07-11 12:35:51","","1","10584","<p>Recently I have upgraded angular 5 to angular 6 &amp; as a result i have upgraded service code as follows: </p>

<pre><code>register(postBody: any): Observable&lt;any&gt; {
return this.http
  .post(this.remoteUrl + ""auth/register"", postBody)
  .pipe(
    catchError(this.handleError(""register"", []))
  );
}

this.authService.register(this.formObj.value).subscribe(
    response =&gt; {

    }
)
</code></pre>

<p>Now when I am getting 400 error from the API. I am able to capture this error in error handler but still subscribe executed, why? Subscribe should be call only when getting response with no error.</p>

<p>I am new to this, but in angular 5 it was not happening. So Can anyone correct me what i am doing wrong?</p>
","2196513","","","","","2018-07-11 14:07:26","Subscribe executed while getting error in angular 6","<angular6><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51287460","1","53173827","","2018-07-11 13:59:53","","5","889","<p><code>getTestScheduler().flush()</code> flushes all the observables in the test. Is there a way to granularly flush observables?</p>

<p>e.g. <code>cold('--x', {x: {}}).flush()</code></p>
","5086286","","","","","2018-11-06 14:22:15","How to flush one cold observable as opposed to all observables in the test?","<unit-testing><rxjs6><jasmine-marbles>","1","1","","","","CC BY-SA 4.0"
"51288031","1","51288740","","2018-07-11 14:25:32","","1","5073","<p>I have an Angular 6 app. I'm upgrading rxjs to 6.</p>

<p>In the previous version of the app I had to make a call like this...</p>

<p>I call an observable 
 Do something with its result
 Then call another observable using the value from the last
 Do something with its result  </p>

<p>Do do this used concatmap. The code looked like this...</p>

<pre><code>this.service1.getData().concatMap(d1 =&gt; {
            this.d1Local = d1;
            return this.service2.getData(d1);
        }).subscribe(
            this.d2Local = d2,
            error =&gt; errorFunction);
</code></pre>

<p>I'm trying to rewrite this using rxjs6 and the pipe keyword and without concatmap.</p>

<p>I currently have...</p>

<pre><code>this._LocationService.getLocation()
    .pipe(           
        map(location =&gt; {
            console.log(1);
            this.location = location;
            return this._GeoCoderService.getAddress(location)
                .pipe
                (map(address =&gt; {
                this.address = ""You are near "" + address;
                    this.showSpinner = false;
                }
                ))
            }
        )   
);
</code></pre>

<p>I am never seeing '1' being logged to the console.
Any ideas how I should be doing this?</p>

<hr>

<p>UPDATE:</p>

<p>I know have the below code. I think its almost right how ever I am not seeing the last condole.log print 1....</p>

<pre><code>this._LocationService.getLocation()
    .pipe(map((location: ILocation) =&gt; {
        this.location = location;
        return this._GeoCoderService.getAddress(location);
    })
        , catchError(error =&gt; { this.showSpinner = false; return throwError('Something went wrong!') })
    ).subscribe(
        tap((address: string) =&gt; { console.log(1) })
    );
</code></pre>

<p>What am I missing?</p>
","574130","","574130","","2018-07-11 15:34:49","2018-07-11 15:34:49","RxJs 6 chaining multiple subscriptions","<angular><rxjs><rxjs6>","2","3","","","","CC BY-SA 4.0"
"51289263","1","51423055","","2018-07-11 15:28:48","","0","1872","<p>I have a form that creates an item in the backend, and optionally another resource depending if the user selects a checkbox. The second resource has to be created only after the first one is. I have come up with this code, but I don't think it's the right way to do it, especially the part where the checkbox hasn't been checked and I have to return a nonsense Observable. Any help? </p>

<pre><code>this.myService.createArticle(article)
  .flatMap(_ =&gt; {
    if (this.checkbox) {
      return this.mailer.createOtherResource(data);
    } else {
      return Observable.of('done');
    }
  });
</code></pre>

<p>I also tried returning an EmptyObservable, but it doesn't work.</p>
","651555","","","","","2018-07-23 09:44:48","RxJS 6 - flatMap condition","<javascript><flatmap><rxjs6>","1","3","","","","CC BY-SA 4.0"
"51315093","1","","","2018-07-12 22:01:26","","0","1274","<p>I suppose that the answer will be very obvious, but still it evades me. I'm new on working with observables, and now I'm facing issues assigning a value from one. I had success if I define it (this._apps) as an Observable and asking from the view to the service using subscribe (But for my taste is was way convoluted (three levels inside a map just to return another observable with the array and then another function to subscribe the previous to assign the variable and another subscription in the view to finally show the information), inefficient and on top of that I could not get it ""right"" again). The task is very simple. Given the class Application</p>

<pre><code>export class Application {
  name: string;
  baseUrl: string;
  deprecated: boolean;
}
</code></pre>

<p>And the service (just the relevant code)</p>

<pre><code>private _apps: Application[] = [];

constructor(private _http: HttpClient) {
  this.getAllApplications().subscribe(apps =&gt; {
    console.log('Apps subscriber');
    this._apps = apps;
    console.log('Apps subscriber Ends ' + apps);
  },
  err =&gt; {
    console.log(err.status); // 401
    console.log(err.error.error); // undefined
    console.log(JSON.parse(err.error).error); // unauthorized
  });
}

private getAllApplications() {
  return this._http.get&lt;Application[]&gt;('http://development:4300/api/v1/apps');
}
</code></pre>

<p>From the constructor the function which gets the information from WebAPI is triggered, and the remote call is successful, but the variable this._apps is an empty array if I try to call it from anywhere in the code. I could not determine the type of the parameter ""apps"" in the subscribe function, but for some reason it cannot be assigned and the best answer given is that it is a function (See my first update) in one of my tries. Currently it returns in the console ""[object Object]"", but apps[0] gives undefined, so it is an empty Array.</p>

<p>This is the console output, just starting the application:</p>

<p>Angular is running in the development mode. Call enableProdMode() to enable the production mode.
Refreshing apps cache calling <a href=""http://development:4300/api/v1/atbc-apps"" rel=""nofollow noreferrer"">http://development:4300/api/v1/atbc-apps</a> 
Apps subscriber
Apps subscriber Ends [object Object]</p>

<p>I was trying <a href=""https://stackoverflow.com/questions/44940695/how-to-convert-observableany-to-array#44940857"">this solution</a> among many others that I forget (to use the more modern HttpClient instead the Http I used before), so what I'm doing wrong? </p>

<p><strong>Update 1</strong></p>

<p>I changed the constructor to this:</p>

<pre><code>constructor(private _http: HttpClient) {
  this.getAllApplications().subscribe(apps =&gt; {
    console.log('apps length ' + apps.length);
    this._apps = apps;  // Remember private _apps: Application[] = [];
    console.log('Apps subscriber Ends ' + apps.toString);
  },
    err =&gt; {
      console.log(err.status); // 401
      console.log(err.error.error); // undefined
      console.log(JSON.parse(err.error).error); // unauthorized
    });
}
</code></pre>

<p>and the declaration of the function called into this:</p>

<pre><code>private getAllApplications(): Observable&lt;Application[]&gt; {
   // the exactly the same as before
}
</code></pre>

<p>And now I got from the console this:</p>

<p><em>apps length undefined</em></p>

<p><em>Apps subscriber Ends 
    <code>function () {
        if (this instanceof Promise) {
            return PROMISE_OBJECT_TO_STRING;
        }
        return originalObjectToString.apply(this, arguments);
    }</code></em></p>

<p>That is the function I was talking about. Any ideas about why even though there is no errors (nor at compile time, neither at runtime), the returning object is not a real Application array?</p>
","5911035","","5911035","","2018-07-13 16:06:07","2018-07-16 18:49:58","Angular 6 HttpClient.get Observable does not assign value","<angular6><angular-httpclient><rxjs6>","2","0","","","","CC BY-SA 4.0"
"51327587","1","","","2018-07-13 14:36:13","","1","140","<p>I have created a <code>new Map()</code> which is <code>&lt;string, string&gt;</code>. I have created an <code>Rx.Observable</code> from it. <code>Rx.from(Map)</code>. Say it has 5 entries.</p>

<p>I want to be able to consume the entries 1 at a time and on demand. So I take the first entry, which is a string, and send it as a message. I wait for a reply and if the reply is <code>OK</code> I take the second entry and send it, and so on. </p>

<pre><code>const source: Rx.Observable&lt;[string, string]&gt; = Rx.from(myMap);

function handleSending(): void {
    source.pipe(map((x: any) =&gt; x.join(''))).subscribe((x: string) =&gt; client.write(x));
}
</code></pre>

<p>This implementation pulls all the entries in a continuous stream, where as I want to take one and wait. I think what I need is the functionality of a generator but I am unsure how to do this in RxJS</p>
","1329477","","","","","2018-07-13 14:51:54","Generator like stream from RxJS from JS Map","<rxjs><observable><generator><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51329300","1","","","2018-07-13 16:21:48","","0","26","<p>I have searched the RXJS6 repository, and I have found links going back to RxJS5 and RxJS4 which describe an <code>asyncScheduler</code>, but no answer gets right to the point of whether you can process a notification in a WebWorker thus achieving actual parallelization.</p>
","326532","","","","","2018-07-13 16:21:48","Is there a scheduler for RxJS6 which handles the notification on a WebWorker?","<rxjs6>","0","2","","","","CC BY-SA 4.0"
"51345992","1","51348234","","2018-07-15 06:49:56","","2","140","<p>Suppose I have a directory structure similar to following:</p>

<pre><code>foo
|
+---one
|   +---tmp
|
+---two
|
+---three
    |
    +---tmp
</code></pre>

<p>I want to get the list of sub-directories under <code>foo</code> which has a <code>tmp</code> (sub-)sub-directory underneath. I do have the following code which does that:</p>

<pre><code>const { bindNodeCallback, from } = require('rxjs');
const { map, flatMap, filter } = require('rxjs/operators');
const { readdir, access, accessSync, constants: { F_OK, R_OK }} = require('fs');
const { join } = require('path');

const readdirRx = bindNodeCallback(readdir);

const FOO = './foo';

const result = readdirRx(FOO)
    .pipe(
        // readdir will return an array of files. Convert each
        // file into an observable, and then flatten it.
        flatMap(from),

        // get rid of directories that do not have a `tmp` dir underneath
        filter(dir =&gt; {
            try {
                accessSync(join(FOO, dir, 'tmp'), F_OK | R_OK);
                return true;
            } catch (err) {
                return false;
            }
        })
    );
result.subscribe(console.log, console.error, () =&gt; console.log('Done!'));
// outputs (correctly):
//   one
//   three
//   Done!
</code></pre>

<p>However, this code looks awful to me because (a) I am using exceptions for control flow, and (b) there is a synchronous <code>accessSync</code> call, both of which are detrimental to performance.</p>

<p>I do have the following reactive piece of code that checks the same thing:</p>

<pre><code>const fileExistsAndReadableRx = bindNodeCallback(
    // check if file exists and readable
    (file, cb) =&gt; access(file, F_OK | R_OK,
        // call the callback with true if no errors found
        err =&gt; cb(!err)
    )
);
</code></pre>

<p>However, I cannot figure out how I can plug <code>fileExistsAndReadableRx</code> into the above program. My objective is to remove the try-catch block and use <code>fileExistsAndReadableRx</code> instead to filter out sub-directories that do not have a <code>tmp</code> (sub-)sub-directory. How can I do that?</p>

<p>(Please note that the actual task I am trying to do is not reading the disk. What I am trying to do is a complex async operation, and I had to come up with a simpler example to illustrate my problem).</p>

<h3>What I have tried so far:</h3>

<p>I tried to use <code>map</code>, but it emits a stream of Observables, as one would expect:</p>

<pre><code>const result = readdirRx(FOO)
    .pipe(
        flatMap(from),
        map(dir =&gt;
            fileExistsAndReadableRx(join(FOO, dir, 'tmp'))
        )
    );
result.subscribe(console.log, console.error, () =&gt; console.log('Done!'));
// Outputs:
//   Observable { _isScalar: false, _subscribe: [Function] }
//   Observable { _isScalar: false, _subscribe: [Function] }
//   Observable { _isScalar: false, _subscribe: [Function] }
//   Done!
</code></pre>

<p>So I thought, <em>I know! I'd use <code>flatMap</code> to flatten the Observables. That should produce three boolean values that are eventually emitted from those Observables</em>. But that did not work either. It only emits a single value:</p>

<pre><code>const result = readdirRx(FOO)
    .pipe(
        flatMap(from),
        flatMap(dir =&gt;
            fileExistsAndReadableRx(join(FOO, dir, 'tmp'))
        )
    );
result.subscribe(console.log, console.error, () =&gt; console.log('Done!'));
// Outputs:
//   true
//   Done!
</code></pre>

<h3>Edit:</h3>

<p>I tried <a href=""https://stackoverflow.com/users/1675492/ingo-b%C3%BCrk"">@IngoBurk</a>'s <a href=""https://stackoverflow.com/a/51348234/1461424"">answer</a>, but that produces a single boolean value. Not a list of strings as I would expect:</p>

<pre><code>const result = readdirRx(FOO)
    .pipe(
        flatMap(from),
        flatMap(dir =&gt; fileExistsAndReadableRx(join(FOO, dir, 'tmp'))
            .pipe(
                filter(Boolean),
                map(() =&gt; dir),
            )
        ),
    );
result.subscribe(console.log, console.error, () =&gt; console.log('Done!'));
// Outputs:
//   true
//   Done!
</code></pre>
","1461424","","1461424","","2018-07-16 00:16:28","2018-07-17 01:19:35","How to use an observable within `filter`?","<javascript><node.js><rxjs><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"51391383","1","","","2018-07-17 23:10:30","","0","57","<p>I'm using Angular 6, HttpClient and Rxjs6. I'm trying to add a property with map but I get <code>Property 'id' does not exist on type 'Object'</code>.</p>

<pre><code>public onSelectName = $event =&gt; {
    this.nameTable$ = this.apiNamesService
        .getNamesById($event.item.id)
        .pipe(map(res =&gt; (res.id = $event.item.id)));
};
</code></pre>

<p>The <code>res.id</code> is causing the issue. I have tried casting to any which gives me another error <code>Cannot find name 'res'</code></p>

<p>The apiNamesService looks something like this:</p>

<pre><code>public getNamesById = id =&gt; this.http.get(`/api/etc/${id}`)
</code></pre>
","206317","","","","","2018-07-18 06:32:30","Adding a value to an observable with map","<angular><rxjs><observable><angular-httpclient><rxjs6>","2","1","","","","CC BY-SA 4.0"
"51393815","1","","","2018-07-18 04:54:14","","1","360","<p>I want to implement <a href=""https://ng-bootstrap.github.io/#/components/typeahead/examples#focus"" rel=""nofollow noreferrer"">NgbTypeAhead</a> with in Angular Material <a href=""https://material.angular.io/components/table/overview"" rel=""nofollow noreferrer"">Table</a>. And, I want TypeAhead to show when the input is onClick() or onFocus(). However, following API document of <a href=""https://ng-bootstrap.github.io/#/components/typeahead/examples#focus"" rel=""nofollow noreferrer"">NgbTypeAhed::Open on focus</a>, it's open TypeAhead on all input in every row. </p>

<p>I think it's because of <code>click$</code> and <code>focus$</code> observable, but still not find out a way to achieve it.</p>

<p><strong>HTML</strong></p>

<pre><code>&lt;!-- Section table --&gt;
&lt;div&gt;
  &lt;!-- &lt;table datatable [dtOptions]=""dtOptions"" class=""hover"" width=""100%""&gt;&lt;/table&gt; --&gt;
  &lt;table mat-table [dataSource]=""dataSource"" class=""mat-elevation-z8""&gt;

    &lt;!--- Note that these columns can be defined in any order.
        The actual rendered columns are set as a property on the row definition"" --&gt;

    &lt;ng-container matColumnDef=""position""&gt;
      &lt;th mat-header-cell *matHeaderCellDef&gt; No. &lt;/th&gt;
      &lt;td mat-cell *matCellDef=""let element""&gt; {{element.position}} &lt;/td&gt;
    &lt;/ng-container&gt;

    &lt;ng-container matColumnDef=""data""&gt;
      &lt;th mat-header-cell *matHeaderCellDef&gt; data &lt;/th&gt;
      &lt;td mat-cell *matCellDef=""let element""&gt;
        &lt;input
        type=""text""
        class=""form-control""
        [ngbTypeahead]=""searchData""
        (focus)=""focus$.next($event.target.value)""
        (click)=""click$.next($event.target.value)""
        #instance=""ngbTypeahead""
      /&gt;
      &lt;/td&gt;
    &lt;/ng-container&gt;

    &lt;tr mat-header-row *matHeaderRowDef=""displayedColumns""&gt;&lt;/tr&gt;
    &lt;tr mat-row *matRowDef=""let row; columns: displayedColumns;""&gt;&lt;/tr&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>

<p><strong>COMPONENT</strong></p>

<pre><code>const ELEMENT_DATA: PeriodicElement[] = [
  { position: 1, data: ''},
  { position: 2, data: ''},
  { position: 3, data: ''},
  { position: 4, data: '' },
  { position: 5, data: ''},
  { position: 6, data: '' },
  { position: 7, data: '' },
  { position: 8, data: '' },
  { position: 9, data: '' },
  { position: 10, data: '' }
];

const states = ['Alabama', 'Alaska', 'American Samoa', 'Arizona', 'Arkansas', 'California', 'Colorado',
  'Connecticut', 'Delaware', 'District Of Columbia', 'Federated States Of Micronesia', 'Florida', 'Georgia',
  'Guam', 'Hawaii', 'Idaho', 'Illinois', 'Indiana', 'Iowa', 'Kansas', 'Kentucky', 'Louisiana', 'Maine',
  'Marshall Islands', 'Maryland', 'Massachusetts', 'Michigan', 'Minnesota', 'Mississippi', 'Missouri', 'Montana',
  'Nebraska', 'Nevada', 'New Hampshire', 'New Jersey', 'New Mexico', 'New York', 'North Carolina', 'North Dakota',
  'Northern Mariana Islands', 'Ohio', 'Oklahoma', 'Oregon', 'Palau', 'Pennsylvania', 'Puerto Rico', 'Rhode Island',
  'South Carolina', 'South Dakota', 'Tennessee', 'Texas', 'Utah', 'Vermont', 'Virgin Islands', 'Virginia',
  'Washington', 'West Virginia', 'Wisconsin', 'Wyoming'];

@Component({
  selector: 'app-table',
  templateUrl: './app-table.component.html',
  styleUrls: ['./app-table.component.css']
})
export class TableComponent implements OnInit {
  displayedColumns: string[] = ['position', 'data'];
  dataSource = ELEMENT_DATA;

  @ViewChild('instance') instance: NgbTypeahead;
  focus$ = new Subject&lt;string&gt;();
  click$ = new Subject&lt;string&gt;();

  constructor() {}

  ngOnInit() {
  }

  searchData = (text$: Observable&lt;string&gt;) =&gt; {
    const debouncedText$ = text$.pipe(debounceTime(200), distinctUntilChanged());
    const clicksWithClosedPopup$ = this.click$.pipe(filter(() =&gt; !this.instance.isPopupOpen()));
    const inputFocus$ = this.focus$.pipe(filter(() =&gt; !this.instance.isPopupOpen()));

    return merge(debouncedText$, inputFocus$, clicksWithClosedPopup$).pipe(
      map(term =&gt; (term === '' ? states
        : states.filter(v =&gt; v.toLowerCase().indexOf(term.toLowerCase()) &gt; -1)).slice(0, 10))
    );
  }

}
</code></pre>
","2077479","","","","","2018-07-18 04:54:14","NgbTypeAhead in Angular Material Table","<angular><angular-material><rxjs6>","0","1","","","","CC BY-SA 4.0"
"51403387","1","","","2018-07-18 13:33:15","","4","7488","<p>I'm curious. I just tried to delay a HTTP Request in Angular (6.x) with <code>.pipe( delay( 5000 ) )...</code> but it looks like, that RxJS just delays the final response not the server call. But I really need to delay the real server call. That wasn't a problem in AngularJS via HttpInterceptor but I can't get it to work. Any ideas?</p>

<p>Thx in advance.</p>

<p>Update:</p>

<p>I already tried the HttpInterceptor but that doesnt work either. I have a CustomHttpClient which puts running request urls in an array and removes them after its done. Some request cannot run in parallel so I've to check the list for pending calls from e.g. /api/somePath. If such an url is in the list the current request has to be delayed. Works fine within the HttpInterceptor of AngularJS.</p>
","10099877","","10099877","","2018-07-18 13:52:11","2018-07-18 16:16:55","Delayed HTTP Request in Angular","<angular><rxjs><rxjs6>","5","3","","","","CC BY-SA 4.0"
"51413699","1","51414247","","2018-07-19 03:00:18","","1","3978","<p>I am attempting to catch errors from a HTTP request and based on error code I am displaying error messages to the user.To achieve this I am using the catchError operator from rxjs. </p>

<p>But I get this error which states <strong>Property 'catchError' does not exist on type Observable &lt; Response ></strong> </p>

<p>Follwing is my package.json</p>

<pre><code>""dependencies"": {
""@angular/animations"": ""^6.0.3"",
""@angular/common"": ""^6.0.3"",
""@angular/compiler"": ""^6.0.3"",
""@angular/core"": ""^6.0.3"",
""@angular/forms"": ""^6.0.3"",
""@angular/http"": ""^6.0.3"",
""@angular/platform-browser"": ""^6.0.3"",
""@angular/platform-browser-dynamic"": ""^6.0.3"",
""@angular/router"": ""^6.0.3"",
""bootstrap"": ""^3.3.7"",
""core-js"": ""^2.5.4"",
""rxjs"": ""^6.0.0"",
""zone.js"": ""^0.8.26""
</code></pre>

<p>Following are the imports I have used in the service I am implementing to handle the http requests.</p>

<pre><code>import { catchError } from 'rxjs/operators';
import { Injectable } from '@angular/core';
import { Http } from '../../../node_modules/@angular/http';
import { Observable } from 'rxjs';
import { AppError } from './../common/app-error';
import { NotFoundError } from '../common/not-found-error';
</code></pre>

<p>This is the function which i delete a post from the server and return a custom error for expected and unexpected errors to my component.</p>

<pre><code>deletePost(id:number){
return this.http.delete(this._url+""/""+id).catchError(
  (error:Response)=&gt;{
    if(error.status===404){
      return Observable.throw(new NotFoundError());
    }
    return Observable.throw(new AppError(error));
  }
);
</code></pre>

<p>}</p>

<p>But when I try to delete a post I get the following error.</p>

<pre><code>this.http.delete(...).catchError is not a function
</code></pre>

<p>I referred the following <a href=""https://rxjs-dev.firebaseapp.com/api/operators/catchError"" rel=""nofollow noreferrer"">API for rxjs</a> , in there as well according to my understanding catchError function expects an Observable as input. If anyone can help me resolve this issue I would highly appreciate it. Thank you.</p>
","2457129","","2457129","","2018-07-19 03:05:49","2018-07-19 04:30:35","catchError is not found in Observable<Response>","<http><angular6><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"51414442","1","51414555","","2018-07-19 04:36:53","","2","10346","<p>My application works well in local but when I want to go to production with <code>ng build --prod</code> I get the following error:</p>

<p>Any idea what may be happening?</p>

<blockquote>
  <p>ERROR in ./node_modules/rxjs/_esm5/operators/index.js
  Module not found: Error: Can't resolve '../internal/operators/endWith' in /Users/.../node_modules/rxjs/_esm5/operators'</p>
</blockquote>

<p><strong>package.json</strong></p>

<pre><code>{
""name"": ""myApp"",
""version"": ""0.0.0"",
""scripts"": {
  ""ng"": ""ng"",
  ""start"": ""ng serve"",
  ""build"": ""ng build"",
  ""test"": ""ng test"",
  ""lint"": ""ng lint"",
  ""e2e"": ""ng e2e""
},
""private"": true,
""dependencies"": {
  ""@angular/animations"": ""6.0.5"",
  ""@angular/cdk"": ""^6.3.3"",
  ""@angular/common"": ""^6.0.0"",
  ""@angular/compiler"": ""^6.0.0"",
  ""@angular/core"": ""^6.0.0"",
  ""@angular/forms"": ""^6.0.0"",
  ""@angular/http"": ""^6.0.0"",
  ""@angular/material"": ""^6.3.3"",
  ""@angular/platform-browser"": ""^6.0.0"",
  ""@angular/platform-browser-dynamic"": ""^6.0.0"",
  ""@angular/router"": ""^6.0.0"",
  ""angularfire2"": ""^5.0.0-rc.10"",
  ""bootstrap"": ""^4.1.1"",
  ""core-js"": ""^2.5.4"",
  ""firebase"": ""^5.0.4"",
  ""jquery"": ""^3.3.1"",
  ""popper.js"": ""^1.14.3"",
  ""rxjs"": ""^6.0.0"",
  ""rxjs-compat"": ""^6.2.2"",
  ""zone.js"": ""^0.8.26""
},
""devDependencies"": {
  ""@angular/compiler-cli"": ""^6.0.0"",
  ""@angular-devkit/build-angular"": ""~0.6.0"",
  ""typescript"": ""~2.7.2"",
  ""@angular/cli"": ""~6.0.0"",
  ""@angular/language-service"": ""^6.0.0"",
  ""@types/jasmine"": ""~2.8.6"",
  ""@types/jasminewd2"": ""~2.0.3"",
  ""@types/node"": ""~8.9.4"",
  ""codelyzer"": ""~4.2.1"",
  ""jasmine-core"": ""~2.99.1"",
  ""jasmine-spec-reporter"": ""~4.2.1"",
  ""karma"": ""~1.7.1"",
  ""karma-chrome-launcher"": ""~2.2.0"",
  ""karma-coverage-istanbul-reporter"": ""~1.4.2"",
  ""karma-jasmine"": ""~1.1.1"",
  ""karma-jasmine-html-reporter"": ""^0.2.2"",
  ""protractor"": ""~5.3.0"",
  ""ts-node"": ""~5.0.1"",
  ""tslint"": ""~5.9.1""
}
}
</code></pre>

<p>These are the places where I am using RXJS</p>

<p><strong>productos.service.ts</strong></p>

<pre><code>import { of } from 'rxjs';
...
getProductos() {
  return of(this.productos);
}

getProducto&lt;Producto&gt;(id) {
  return of(this.productos.find(p =&gt; p.id === id));
}
</code></pre>

<p>producto.resolver.service.ts</p>

<pre><code>import { Injectable } from '@angular/core';
import { Router, Resolve, RouterStateSnapshot,
  ActivatedRouteSnapshot } from '@angular/router';
import { Observable } from 'rxjs';
import { map, take } from 'rxjs/operators';
import { Producto, ProductosService } from './productos.service';

@Injectable({
  providedIn: 'root'
})
export class ProductoResolver implements Resolve&lt;Producto&gt; {

constructor(private ps: ProductosService, private router: Router) { }

resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): 
Observable&lt;Producto&gt; {
let id = route.paramMap.get('id');

return this.ps.getProducto(id).pipe(
  take(1),
  map(producto =&gt; {
    if (producto) {
      return producto;
    } else { // id not found
      console.error('id not found');
      this.router.navigate(['/productos']);
      return null;
    }
  })
);
}
}
</code></pre>
","8312532","","","","","2019-06-24 07:55:56","ERROR in ./node_modules/rxjs/_esm5/operators/index.js Angular 6 ng build --prod of / Resolve","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"51414921","1","51415785","","2018-07-19 05:25:35","","0","958","<pre><code>@Effect()    
initDomain$: Observable&lt;Action&gt; = this.actions$.pipe(
  ofType('INIT_DOMAIN'),
  mergeMap((action: any) =&gt;
     this.http.get('https://demo.api/url1.php').pipe(
        switchMap((data) =&gt; [
           {type: 'INIT_IT', payload: data}
        ]),
        catchError(() =&gt; of({type: 'INIT_IT_FAILED'}))
     )
  )
);
</code></pre>

<p>I have this angular effect (ngrx) that makes 1 request before continue. How can I make 2 requests and wait for both responses before continue? I know that forkJoin() is the answer but I'm little confused about the syntax</p>
","913951","","","","","2018-07-19 06:30:48","RxJs 6 - Make 2 http calls and wait for all responses","<rxjs><ngrx><ngrx-effects><fork-join><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51434236","1","","","2018-07-20 02:28:12","","4","21726","<p>I am working on <strong>Angular 6 with Rxjs 6</strong> while I have a question regarding returning a null/empty Observable if response failed or has exception, Here is my assumption, my remote api will return an object of <strong>IOptionResponse</strong>, <strong>it contains a message string which could be indicated like 'SUCCESS' or 'FAILED', it also contains a model which is an array of 'IOption' object</strong></p>

<pre><code>export interface IOptionResponse {
    message: string;
    model: IOption[];
}
</code></pre>

<p>Here is my service method name, <strong>it will return a Observable of IOption array which is the ""model"" of my remote API result</strong></p>

<pre><code>loadIOptionMembersRelationship(): Observable&lt;IOption[]&gt; {
    return this.httpClient.get&lt;IOptionResponse&gt;('${environment.apiUrl}/api/member/XXX')
        .map(
            (response) =&gt; {
                console.log(response);
                // if response.message is success, return IOption[] model
                if (response.message == responseMessage.Success) {
                    return response.model;
                }
                else {
                    // return Observable.empty&lt;IOption[]&gt;(); failed
                    // return new Observable.empty&lt;IOption[]&gt;(); failed
                    // return new EmptyObservable&lt;IOption[]&gt;(); failed
                    // return new Observable&lt;IOption[]&gt;.from([]); failed
                    // Otherwise return a NULL/EMPTY Observable
                    //What should be the correct way to implement here???
                }
            }
        );
}
</code></pre>

<p>I've read the post <a href=""https://stackoverflow.com/questions/38548407/how-to-return-an-empty-observable-in-rxjs"">here</a> which is similar, however I tried all the possible solution and they do not work, I am not sure if it's because that posted solutions are out of date or maybe some method changed in rxjs 6 or maybe it's a typescript issue...</p>
","6524600","","2829204","","2018-07-20 04:05:02","2020-08-06 13:25:54","Return a null/empty Observable in Angular 6 with Rxjs 6","<typescript><rxjs><angular6><rxjs6>","5","2","5","","","CC BY-SA 4.0"
"51434876","1","","","2018-07-20 04:00:15","","1","604","<p>I am using Angular 6 with RxJs 6 and I have a backend api which will <strong>send the response with generic class object</strong>, which means the response data model is not static, <strong>but I have one more indicator that can tell me what model is passing in</strong>, code example are:</p>

<pre><code>interface orderSummary {...}
interface orderDetail {...}
interface IResponse {
    objectType: string;
    objectData: any
}

GetGenericDataModel() {
    return this.httpClient.get&lt;IResponse&gt;(`../api/method`)
        .map?flatmap?pipe?( --&gt;what should I use here?
            (response) =&gt; {
                 if (response.objectType === 'orderSummary')
                    return response.objectData.ToOrderSummary --&gt; how to convert to orderSummary
                 else if (response.objectType === 'orderDetail')
                    return response.objectData.ToOrderDetail --&gt; how to convert to orderDetail                           
            }
        );
}
</code></pre>

<p>On client side when I use http.get to fetch my result and <strong>depend on my response indicator(objectType), I need to convert/transform the response data(objectData) into my interface(either orderSummary or orderDetail)</strong>, How should I work with rxjs to convert/transform my response data into my pre-defined interface in Angular 6? </p>
","6524600","","","","","2018-07-20 04:37:05","How should I transform generic observable into specific data model in rxjs 6/Angular 6?","<typescript><angular5><angular6><rxjs5><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"51435094","1","","","2018-07-20 04:30:03","","0","214","<p>Traditionally httpService.post(url, payload, options) returned an  <code>Observable&lt;T&gt;</code> whose could be easily accessed within the subscription. For example in the following example, the post would return an <code>Observable&lt;string&gt;</code> which could be easily used as</p>

<pre><code>this.httpClientService.post&lt;string&gt;(url, payload, options)
.subscribe(x=&gt; console.log(x));
</code></pre>

<p>But now, after the upgrade, the return type has changed to <code>Observable&lt;HttpEvent&lt;string&gt;&gt;</code> which throws the error </p>

<pre><code>'Observable&lt;HttpEvent&lt;{}&gt;&gt;' is not assignable to type 'Observable&lt;string&gt;'
</code></pre>

<p>in my old code.</p>

<p>Can someone help me with how this new <code>Observable&lt;HttpEvent&lt;T&gt;&gt;</code> is parsed</p>
","1773900","","1773900","","2018-07-20 04:37:36","2018-07-20 04:38:12","Upgrade to Angular 6- Rxjs 6 breaks HttpPost","<angular><rxjs><angular6><angular-httpclient><rxjs6>","2","1","","","","CC BY-SA 4.0"
"51435360","1","51435421","","2018-07-20 05:01:27","","7","5390","<p>After upgrading to angular6 fews problem while using rxjs </p>

<pre><code>import {
  Observable,
  Subject,
  asapScheduler,
  pipe,
  of,
  from,
  interval,
  merge,
  fromEvent
} from ""rxjs"";

import { delay } from ""rxjs/operators"";

let obser = from([ 1, 2, 3 ]).delay( 3000 );
</code></pre>

<p>Getting Property 'delay' does not exist on type 'Observable'</p>

<p>on angular 5 this works fine</p>

<pre><code>  import { Observable } from 'rxjs/Observable';
  let obser = Observable.from([ 1, 2, 3 ]).delay(3000);
</code></pre>
","2476238","","2476238","","2018-07-20 05:19:08","2020-03-29 12:28:56","Property 'delay' does not exist on type 'Observable<string[]>'","<angular><angular6><rxjs6>","2","1","","","","CC BY-SA 4.0"
"51439333","1","","","2018-07-20 09:24:42","","0","44","<p>This is the component</p>

<pre><code>export class ButtonGroupComponent implements OnInit {

@Input() items: Array&lt;Object&gt;;

constructor(private el: ElementRef) {
}

ngOnInit(){
    console.log('this.constructor.name ' + this.constructor.name);
    console.log(this.items);

}

onParentClick(index) {
    let items = this.items;
    Observable.of(items).subscribe(items =&gt; {
        this.el.nativeElement.dispatchEvent(new CustomEvent(items[index].eventName, {}));
        console.log( items[index].eventName );
    });
}
</code></pre>

<p>And this is the template:</p>

<pre><code>&lt;custom-button  *ngFor=""let el of items ; let i = index""
            type=""{{el.type}}""
            btnName=""{{el.btnName}}""
            btnIcon=""{{el.btnIcon}}""
            disabled=""{{el.disabled}}""

            (childClickEvent)=""onParentClick($event)""
            [index]=""i""
            [item]=""item""
&gt;
&lt;/custom-button&gt;
</code></pre>

<p>'items' is an array of object that arrives from host of pt-button-group and describes what kind of buttons the page will have. </p>

<p>In order to know which button of the group have been clicked the component dispatch the index of the object that correspond to the button clicked and the description of the event name of that button.</p>

<p>When I compile I get twice the error:</p>

<pre><code>error TS2339: Property 'eventName' does not exist on 
type 'Object'
</code></pre>

<p>but how is this possible? Observables are suppose to be sync right? Did I wrote that Observable wrong? How can I get the eventName value without getting errors?</p>
","5691255","","","","","2018-07-20 09:38:29","How can I use an Observable correctly in order to not get errors when I try to access an Object key value?","<angular><observable><rxjs6>","2","0","","","","CC BY-SA 4.0"
"51440812","1","51441569","","2018-07-20 10:45:40","","0","2085","<p>i can't limit the showed result in the template using the rxjs take() operator, the template shows me always all records.</p>

<p>The api <a href=""http://jsonplaceholder.typicode.com/users"" rel=""nofollow noreferrer"">http://jsonplaceholder.typicode.com/users</a> returns 10 elements, i'd like to take only four of them.</p>

<pre><code>[service]
public getData(): Observable&lt;User[]&gt; {
    return this.http.get&lt;User[]&gt;(`http://jsonplaceholder.typicode.com/users`).pipe(
       take(4)
      );
  }

[component]
export class GridComponent implements OnInit {

  _data : Observable&lt;User[]&gt;;

  constructor(public _ds : DataService) {  
  }

  ngOnInit() {
    this._data = this._ds.getData();
  }
}

[template]
&lt;tr *ngFor=""let d of _data | async""&gt;
        &lt;td&gt;{{d.id}}&lt;/td&gt;
        &lt;td&gt;{{d.name}}&lt;/td&gt;
        &lt;td&gt;{{d.email}}&lt;/td&gt;
        &lt;td&gt;{{d.phone}}&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
","1820422","","","","","2018-07-20 11:30:12","rxjs take operator - to limit results with async pipe","<angular><rxjs><angular-httpclient><rxjs6><angular-observable>","1","0","","","","CC BY-SA 4.0"
"51459030","1","51487309","","2018-07-21 18:34:57","","1","736","<p>I need some help with an auto-complete field using angular materials. First off when the page loads I have a service making an API call to a backend node app that sends requests to a sanbox api. This call brings a list of supported cities. It then feeds the city list component that has a form. When a user types I want to narrow down the cities into an auto-complete box. So far I have set up a new variable as a subject and use the .filter() and .include() methods to filter an array and return it to my subject variable. The return is in the form of an object to my subscription variable, but now on the template I cannot use the returned values to narrow down my results. I figure its because I need to return my results into an array. Can someone help me conceptualize this (currently I can get the filter to narrow down results, but the array doesn't reload the values after it removes them)</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>city-list Component.ts




import { CityService } from ""./services/city-list.service"";
import { Component, OnInit, OnDestroy } from ""@angular/core"";
import { City } from ""../cities/models/city"";
import { Subscription, Observable } from ""rxjs"";
import { map, startWith, debounceTime } from ""rxjs/operators"";
import {FormGroup, FormControl, Validators, NgForm} from '@angular/forms';


@Component({
  selector: ""&lt;app-cities&gt;&lt;/app-cities&gt;"",
  templateUrl: ""./city-list.component.html""
})
export class CityListComponent implements OnInit, OnDestroy {

  cities: City[];
  private citiesSub: Subscription;
  destinationCity: FormControl = new FormControl();
  currentCity: Subscription;
  filteredCities: City[];

  constructor(public cityService: CityService) {}

  ngOnInit() {

    this.cityService.getCities();
    this.citiesSub = this.cityService
      .getCityUpdateListener()
      .subscribe((cities) =&gt; {
       this.cities = cities;

      });
   this.currentCity = this.destinationCity.valueChanges.pipe(
    debounceTime(400),
      startWith(''),
  ).subscribe(term=&gt;{
    if(!term){
      return;
    }
    this._filter(term);
  }
  );
  }
  private _filter(value: string): City[] {
    const filterValue = value.toLowerCase();
    return this.filteredCities = this.cities.filter(option =&gt; option.name.toLocaleLowerCase().includes(filterValue));
  }
  ngOnDestroy() {
    this.citiesSub.unsubscribe();
  }

  onSearch(form: NgForm){
    console.log(form.value);
  }
}</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>city service.ts

import { Subject } from 'rxjs';
import {Injectable} from '@angular/core';
import {HttpClient} from '@angular/common/http';

import { map } from ""rxjs/operators"";

import {City} from '../models/city';


@Injectable({ providedIn: ""root"" })
export class CityService {
  cities: City[] = [];
  private updatedCities = new Subject&lt;City[]&gt;();


  constructor(private http: HttpClient) {}

 getCities() {
  this.http.get&lt;{message: string; cities: City[]}&gt;('http://localhost:3000/cities')
  .pipe(
    map((cityData)=&gt;{
      return cityData.cities.map(city=&gt;{
        return{
          code: city.code,
          name: city.name
        };
      });
    })
)
  .subscribe((transCity) =&gt; {
    this.cities = transCity;
   // console.log(this.cities);
    this.updatedCities.next([...this.cities]);

  });
  }

  getCityUpdateListener() {
    return this.updatedCities.asObservable();
  }

}</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>city-list.html

&lt;mat-card&gt;
  &lt;form #instantFlight=""ngForm""&gt;
    &lt;mat-form-field&gt;
      &lt;input  type=""text"" id=""destinationCity"" name=""destinationCity"" matInput [formControl]=""destinationCity"" [matAutocomplete]=""autoDestination""&gt;

      &lt;mat-autocomplete #autoDestination=""matAutocomplete""&gt;
        &lt;mat-option *ngFor=""let c of cities"" [value]=""c.code""&gt;
          {{c.name}} - {{c.code}}
        &lt;/mat-option&gt;
      &lt;/mat-autocomplete&gt;
    &lt;/mat-form-field&gt;
    &lt;button mat-raised-button type=""submit""&gt;Search&lt;/button&gt;
  &lt;/form&gt;
&lt;/mat-card&gt;</code></pre>
</div>
</div>
</p>
","7953755","","7953755","","2018-07-21 18:47:53","2018-07-23 21:13:23","Autocomplete with angular materials","<angular><rxjs6><angular-material-5>","1","0","","","","CC BY-SA 4.0"
"51459073","1","","","2018-07-21 18:40:59","","3","3236","<p>I created a new angular6 project with angularfire2 and rxjs 6. I am debugging the loading bar to be shown while loading observables.</p>

<p>my ts code:</p>

<pre><code>import { combineLatest, Observable } from 'rxjs';

groups: Observable&lt;Array&lt;any&gt;&gt;;
singles: Observable&lt;Array&lt;any&gt;&gt;;
combined: Observable&lt;Object&gt;;

public loadall()
{
    this.groups= this.db.collection('groups').valueChanges();
    this.singles= this.db.collection('singles').valueChanges();
    this.combined = combineLatest(this.groups, this.singles);
    //took this from https://auth0.com/blog/whats-new-in-rxjs-6/
}
</code></pre>

<p>my html template:</p>

<pre><code>&lt;ng-template #loading&gt;
  &lt;div class=""loader""&gt;&lt;/div&gt;
&lt;/ng-template&gt;

&lt;div *ngIf=""combined | async; else loading""&gt; //this div
  &lt;div *ngFor=""let group of groups | async""&gt;
    {{ group.name }}
    &lt;div *ngFor=""let single of singles | async""&gt;
      {{ single.name }}
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Currently without the //this div bracket, the output will be displayed. However, with the //this div bracket, output does not get displayed.</p>

<p>With the previous version of rxjs, I used:</p>

<pre><code>this.combined = Observable.combineLatest(query$);
</code></pre>

<p>And this works. So I figure my implementation of the combineLatest operator is wrong. Appreciate help to further debug this.</p>
","776914","","","","","2018-07-21 18:40:59","combineLatest not working","<angular><rxjs6><combinelatest>","0","9","1","","","CC BY-SA 4.0"
"51459142","1","","","2018-07-21 18:50:40","","0","243","<p>I'm making a service that has multiple methods triggering HTTP calls. I want to reveal an Observable to clients that tells them whether there are any pending calls.</p>

<p>I think this approach would generally would work, but feels hacky and not very RxJs-like. I've searched all over StackOverflow and through the RxJs docs, but can't find a better way. Any advice? Thanks!</p>

<pre><code>let pendingCountSubject = new BehaviorSubject&lt;number&gt;(0);
let pendingCount$ = pendingCountSubject.asObservable();

let pendingSubject = new Subject&lt;Observable&lt;any&gt;&gt;();
pendingSubject.pipe(
  finalize(() =&gt; {
    pendingCountSubject.next(pendingCountSubject.value - 1);
  }))
  .subscribe();

function trackPendingObservable(obs) {
  pendingCountSubject.next(pendingCountSubject.value + 1);
  pendingSubject.next(obs);
}

trackPendingObservable(httpCall1);
trackPendingObservable(httpCall2);
trackPendingObservable(httpCall3);
</code></pre>

<p>And in template:</p>

<pre><code>Pending calls: {{ pendingCount$ | async }}
</code></pre>
","2925870","","","","","2018-07-22 07:13:17","Transform RxJs Observable of Observables into count of how many Observables are pending?","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51460608","1","51463280","","2018-07-21 22:30:03","","1","380","<p>I've got an NGRX effect (heavily uses RxJS) as follows:</p>

<pre><code>@Effect()
allFiltersRequested$ = this.actions$.pipe(
  ofType&lt;AllFiltersRequestedAction&gt;(FiltersActionTypes.AllFiltersRequested),
  tap((action) =&gt; debug(action)),
  withLatestFrom(this.store.pipe(select(selectAllFilters))),
  filter(([action, allFilters]) =&gt; isEmpty(allFilters)),
  mergeMap(() =&gt;
    this.simService.getAllFilters().pipe(
      catchError(() =&gt; {
        return of({})
      })
    )
  ),
  map((allFilters) =&gt; new AllFiltersLoadedAction(allFilters))
)
</code></pre>

<p>I am using <code>filter</code> to prevent an HTTP request being made (see <code>mergeMap</code>) if the store is already populated (since the data from the API does not change)</p>

<p>However, I always want to execute:</p>

<pre><code>map((allFilters) =&gt; new AllFiltersLoadedAction(allFilters))
</code></pre>

<p>regardless as to whether the HTTP request was made or not. It can't however be executed before <code>mergeMap</code> because <code>mergeMap</code> ensures that the <code>allFilters</code> data is available.</p>

<p>Are there any RxJS <code>always do this</code> type operators? If not, how should I refactor this code to achieve what I want?</p>

<p>At the moment, the only solution is to remove <code>filter</code> but that will result in needless HTTP requests being made.</p>

<p>Thanks</p>
","1205871","","","","","2018-07-22 08:23:26","rxjs - is there an always operator? how do you always do something?","<angular><rxjs><ngrx><rxjs6>","1","7","1","","","CC BY-SA 4.0"
"51471190","1","51477894","","2018-07-23 03:20:43","","3","1304","<p>When using Rxjs 6, IDE's report an error while using <code>partition</code> method - even though function works fine.</p>

<p>For example: I have this sample code:</p>

<pre><code>import { of } from 'rxjs';
import { filter, partition } from 'rxjs/operators';

let obs = of(1,2,3,4,6,9,111,13,10,12);

let [a, b] = obs.pipe(
  filter(v =&gt; v &gt; 3),
  partition(p =&gt; p % 2 == 0)
);

a.subscribe(v =&gt; {
  console.log(v);
});

b.subscribe(v =&gt; {
  console.log(v);
});
</code></pre>

<p>The code works fine and separates inputs in odd and even numbers.  However, VSCode and StackBlitz reports an error on the line where <code>partition</code> method is called:</p>

<blockquote>
  <p>Argument of type 'UnaryFunction,
  [Observable, Observable]>' is not assignable to
  parameter of type 'OperatorFunction'.   Type
  '[Observable, Observable]' is not assignable to type
  'Observable'.
      Property '_isScalar' is missing in type '[Observable, Observable]'.</p>
</blockquote>

<p>Here is stackblitz URL: 
<a href=""https://stackblitz.com/edit/rxjs6-learn"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs6-learn</a></p>
","794242","","794242","","2018-07-23 03:27:37","2018-07-23 11:38:54","rxjs6 partition method: Argument of type 'UnaryFunction' is not assignable to parameter of type 'OperatorFunction'","<rxjs6>","1","1","","","","CC BY-SA 4.0"
"51473750","1","","","2018-07-23 07:37:57","","0","1370","<p>I have a table that shows ticket information, and the users may able to add new ticket and send it to the backend. The problem is the table is not updated with the new ticket that the user adds and the other user and the user itself must always refresh the page for it to show </p>

<p>How do I force to update the observable upon insertion of the new ticket?</p>

<p>Here is the code. for the ADD Component</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { AddService } from '../../services/add.service';
import { Client, Product, ListTracker } from '../../list';

@Component({
  selector: 'app-add',
  templateUrl: './add.component.html',
  styleUrls: ['./add.component.css']
})
export class AddComponent implements OnInit {
  public client_data = [];
  public product_data = [];
  public errorMsg;
  form = {
    title: '',
    client_pk: '',
    product_pk: '',
    severity: '',
    desc: '',
    res: '',
    email: ''
  };
  constructor(private addService: AddService) {

  }

  ngOnInit() {
    this.getClient();
    this.getProduct();
  }

  getClient() {
    this.addService.getClient()
      .subscribe(data =&gt; this.client_data = data,
        error =&gt; this.errorMsg = error);
  }

  getProduct() {
    this.addService.getProduct()
      .subscribe(data =&gt; this.product_data = data,
        error =&gt; this.errorMsg = error);
  }

  onSubmit() {
    this.addService.addTicket(this.form).subscribe();
  }
}
</code></pre>

<p>Here is the ADD Service to Backend</p>

<pre><code>import { Injectable } from '@angular/core';
import { Http } from '@angular/http';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable } from 'rxjs/Observable';
import { Client, Product,ListTracker } from '../list';
import 'rxjs/add/operator/catch';
import 'rxjs/add/observable/throw';

@Injectable({
  providedIn: 'root'
})
export class AddService {
  constructor(private http: HttpClient) {

  }
  getClient(): Observable&lt;Client[]&gt; {
    return this.http.get&lt;Client[]&gt;('http://localhost:3000/api/v1/inuka/getClient')
      .catch(this.errorHandler);
  }

  getProduct(): Observable&lt;Product[]&gt; {
    return this.http.get&lt;Product[]&gt;('http://localhost:3000/api/v1/inuka/getProduct')
      .catch(this.errorHandler);
  }

  errorHandler(error: HttpErrorResponse) {
    return Observable.throw(error.message || ""Server Error"");
  }

  addTicket(form):Observable&lt;ListTracker[]&gt; {
    return this.http.post&lt;ListTracker[]&gt;('http://localhost:3000/api/v1/inuka/addTicket', form)
      .catch(this.errorHandler);

  }
}
</code></pre>

<p>Here is the List Component</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { ListService } from '../../services/list.service';

@Component({
  selector: 'app-list',
  templateUrl: './list.component.html',
  styleUrls: ['./list.component.css']
})

export class ListComponent implements OnInit {
  public list_data = [];
  public errorMsg;

  constructor(private listService:ListService) { 

  }

  ngOnInit() {
    this.listService.getAllTrackerData()
    .subscribe(data =&gt; this.list_data = data,
                error =&gt; this.errorMsg = error);
  }
}
</code></pre>

<p>Here is the List Service</p>

<pre><code>import { Injectable } from '@angular/core';
import { Http } from '@angular/http';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable } from 'rxjs/Observable';
import { ListTracker } from '../list';
import 'rxjs/add/operator/catch';
import 'rxjs/add/observable/throw';

@Injectable({
  providedIn: 'root'
})
export class ListService {
  constructor(private http: HttpClient) {

  }

  getAllTrackerData(): Observable&lt;ListTracker[]&gt; {
    return this.http.get&lt;ListTracker[]&gt;('http://localhost:3000/api/v1/inuka/getAllTrackerData')
      .catch(this.errorHandler);
  }
  errorHandler(error: HttpErrorResponse) {
    return Observable.throw(error.message || ""Server Error"");
  }
}
</code></pre>
","8089518","","6453371","","2018-07-23 08:20:52","2018-07-23 09:34:29","How to refresh an observable on angular 6 after POST","<angular><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51478317","1","","","2018-07-23 12:01:07","","0","371","<p>I have moved own project to angular 6, @angular-redux/store 9 from 5 version. All was fine, but way for registrate epics in middleware not worked. I remove all epics from middleware except logger and startup was fine with all actions executed. Then i try add one epic and get error like </p>

<pre><code>TypeError: action$.pipe is not a function
at SecurityUserEpics.loadSecurityUser (security-user.epic.ts:31)
at combineEpics.js:19
</code></pre>

<p>Then i try to solve this and search many examples and docs about, but cant find solution. After deciding to ask question here and while prepare code for question the solution was found. Soo, i post here that solution in hope that this will save time for someone.
epic:</p>

<pre><code>loadSecurityUser = (action$) =&gt; {
  debugger;
  // here i have object of type : {getState: ƒ, dispatch: ƒ} and thats was pain from older version. pipe helps!
  return action$.pipe(
     ofType(SecurityUserActions.LoadSecurityUsers),
     switchMap(q =&gt; this._dataSrv.getUserInfo()
        .pipe(map(data =&gt; {
           localStorage.setItem('isNeedRelogin', '0');
           return this._securityUserActions.loadSecurityUserComplete(data);
        }))));
</code></pre>

<p>}</p>

<p>And final config store:</p>

<pre><code>const epicMiddleware = createEpicMiddleware();
const middleware = [epicMiddleware];
middleware.push(createLogger());
ngRedux.configureStore(combinedReducer, INITIAL_STATE, middleware, storeEnhancers);
const rootEpic = combineEpics(this._securityUserEpics.loadSecurityUser);
// this is new way of middleware registration
epicMiddleware.run(rootEpic);
</code></pre>
","2119517","","","","","2018-08-06 07:47:03","correct registartion of epics in @angular-redux/store configureStore 9 ver","<redux><angular6><rxjs6><angular-redux>","1","0","","","","CC BY-SA 4.0"
"51478933","1","","","2018-07-23 12:33:58","","0","398","<p>I'm having trouble getting the below code to work. </p>

<p>I can get the data using just SocketIO but not with RxJS 6. </p>

<pre><code>class App extends Component {
  constructor(props){
    super(props);
  }
    state = {
      clusterdata: {}
    }
  componentDidMount(){
    const socket = io('http://localhost:5000',{
      path: '/stream',
      transports: ['websocket']
    });
    socket.emit('json', 'my-ecs-cluster');
      const clusterStream = Observable.create(observer =&gt; {
        socket.on('connect', socket =&gt; {
            console.log(socket);
          socket.on('json', data =&gt; {
            observer.next(data)
          })
      })
        this.clusterStreamObserver = clusterStream.subscribe(this.setClusterData.bind(this));
    })
</code></pre>

<p>... the setState part </p>

<pre><code>setClusterData(clusterdata){
     if (!clusterdata || clusterdata.length === 0) {
       return;
       this.setState({clusterdata: clusterdata});
     }
  }
</code></pre>

<p>... the render part </p>

<pre><code>render() {
    return (
      &lt;div className=""App""&gt;
        &lt;header className=""App-header""&gt;
          &lt;h1 className=""App-title""&gt;Welcome to React&lt;/h1&gt;
        &lt;/header&gt;
        &lt;p className=""App-intro""&gt;
          {JSON.stringify(this.state.clusterdata)}

        &lt;/p&gt;
      &lt;/div&gt;
    );
  }
}

export default App;
</code></pre>
","215800","","","","","2018-07-23 13:39:14","Getting ReactJS to work with SocketIO and RxJS","<reactjs><socket.io><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"51486306","1","51487152","","2018-07-23 19:52:42","","0","110","<p>The data in the API changes constantly. What is the best way to refresh data in Angular? <a href=""https://api.bitfinex.com/v2/candles/trade:5m:tBTCUSD/hist?start=%7B$start%7D&amp;end=%7B$end%7D&amp;limit=1"" rel=""nofollow noreferrer"">bitfinex.com API</a></p>

<p>I have a service and component. In the service I download data using 'get'.</p>

<p><strong>service:</strong> </p>

<pre><code>getPrice(){

  return this.http.get('xxx');

}
</code></pre>

<p><strong>component:</strong> </p>

<pre><code>ngOnInit() {

   this.getPrices();

    setInterval(() =&gt; {
      this.getPrices();
    }, 5000);

  }

  getPrices(){
    this.tick.getPrice().subscribe(prices =&gt; {
      console.log(prices);
    });
  }
</code></pre>

<p>As you can see in the component I use 'setInterval' and refresh every 5 seconds.</p>

<p>I tried to refresh the data directly in the service.</p>

<pre><code>return interval(5000).pipe(

      // ignore new term if same as previous term
      distinctUntilChanged(),

      // switch to new search observable each time the term changes
      switchMap(() =&gt; this.http.get('xxx')),
    );
</code></pre>

<p>But it shows data only after 5 seconds.</p>
","5056259","","","","","2018-07-23 21:04:26","Refreshing data in service","<angular><rxjs6>","4","1","","","","CC BY-SA 4.0"
"51487532","1","51489696","","2018-07-23 21:36:50","","3","638","<p>Working on AutoComplete that pulls cities from an API and then allows users to search for trips. 
The problem  is, even though I am using startWith, I first have to click in the field and then start typing for it to work but I can't get the drop down to immediately show as the user focuses on that input box. 
As a solution I want to call it after the subscription that populates the cities variable. How would I do this? Should the list as an observable? and then go ahead and resubscribe?</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { CityService } from ""./services/city-list.service"";
import { Component, OnInit, OnDestroy } from ""@angular/core"";
import { City } from ""../cities/models/city"";
import { Subscription, Observable } from ""rxjs"";
import { map, startWith, debounceTime } from ""rxjs/operators"";
import { FormGroup, FormControl, Validators, NgForm } from ""@angular/forms"";

@Component({
  selector: ""&lt;app-cities&gt;&lt;/app-cities&gt;"",
  templateUrl: ""./city-list.component.html"",
  styleUrls: [""./cities-list.component.css""]
})
export class CityListComponent implements OnInit, OnDestroy {
  cities: City[]=[];
  private citiesSub: Subscription;
  currentCity: Observable&lt;City[]&gt;;


  destinationCity: FormControl =  new FormControl();
  originCity: FormControl =  new FormControl();
  startDate: FormControl = new FormControl();



  constructor(public cityService: CityService) {}


  ngOnInit() {
    this.cityService.getCities();
    this.citiesSub = this.cityService
      .getCityUpdateListener()
      .subscribe(cities =&gt; {
        this.cities = cities;
    });
    this.currentCity = this.destinationCity.valueChanges
    .pipe(
      debounceTime(100),
      startWith(''),
      map(x=&gt;{
        return this._filter(x);
      }
    ));
  }
private _filter(value: string): City[]{
  const filterValue = value.toLowerCase();
  return(this.cities.filter(option =&gt; option.name.toLowerCase().includes(filterValue)));
}

  ngOnDestroy() {
    this.citiesSub.unsubscribe();
  }
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;mat-card&gt;
  &lt;form (submit)=""onLogin(instantFlight)"" #instantFlight=""ngForm""&gt;
    &lt;mat-form-field&gt;
      &lt;input  type=""text"" id=""destinationCity"" name=""destinationCity"" matInput [formControl]=""destinationCity"" [matAutocomplete]=""autoDestination""&gt;

      &lt;mat-autocomplete #autoDestination=""matAutocomplete""&gt;
        &lt;mat-option *ngFor=""let c of currentCity | async"" [value]=""c.code""&gt;
          {{c.name}} - {{c.code}}
        &lt;/mat-option&gt;
      &lt;/mat-autocomplete&gt;
    &lt;/mat-form-field&gt;
    &lt;mat-form-field&gt;
    &lt;input  type=""text"" id=""originCity"" name=""originCity"" matInput [formControl]=""originCity"" [matAutocomplete]=""autoOrigin""&gt;

    &lt;mat-autocomplete #autoOrigin=""matAutocomplete""&gt;
      &lt;mat-option *ngFor=""let c of cities"" [value]=""c.code""&gt;
        {{c.name}} - {{c.code}}
      &lt;/mat-option&gt;
    &lt;/mat-autocomplete&gt;
  &lt;/mat-form-field&gt;
  &lt;mat-form-field&gt;
      &lt;input matInput id=""startDate"" name=""startDate"" [formControl]=""startDate"" [matDatepicker]=""picker"" placeholder=""Choose a date""&gt;
      &lt;mat-datepicker-toggle matSuffix [for]=""picker""&gt;&lt;/mat-datepicker-toggle&gt;
      &lt;mat-datepicker #picker&gt;&lt;/mat-datepicker&gt;
    &lt;/mat-form-field&gt;
    &lt;button mat-raised-button type=""submit"" color=""accent""&gt;Search&lt;/button&gt;
  &lt;/form&gt;
&lt;/mat-card&gt;</code></pre>
</div>
</div>
</p>

<p>WITH UPDATED CODE</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { CityService } from ""./services/city-list.service"";
import { Component, OnInit, OnDestroy } from ""@angular/core"";
import { City } from ""../cities/models/city"";
import { Subscription, Observable } from ""rxjs"";
import { map, filter, startWith, withLatestFrom, debounceTime } from ""rxjs/operators"";
import { FormGroup, FormControl, Validators, NgForm } from ""@angular/forms"";
import {forkJoin} from 'rxjs';
import { pipe } from ""../../../node_modules/@angular/core/src/render3/pipe"";

@Component({
  selector: ""&lt;app-cities&gt;&lt;/app-cities&gt;"",
  templateUrl: ""./city-list.component.html"",
  styleUrls: [""./cities-list.component.css""]
})
export class CityListComponent implements OnInit, OnDestroy {
  cities: City[]=[];
  private citiesSub: Subscription;
  currentCity: Observable&lt;City[]&gt;;
  testCities: Observable&lt;City[]&gt;;

  destinationCity: FormControl =  new FormControl();
  originCity: FormControl =  new FormControl();
  startDate: FormControl = new FormControl();

  constructor(public cityService: CityService) {}

  ngOnInit() {
    this.cityService.getCities();
    this.testCities = this.cityService
      .getCityUpdateListener();

    this.currentCity = this.destinationCity.valueChanges
    .pipe(
      withLatestFrom(this.testCities),
      debounceTime(100),
      map((x) =&gt;{
       return this._filter(x);
            }
    ));

  }

private _filter(value): City[]{
  const filterValue = value.toLowerCase();
  return(this.testCities.filter(option =&gt; option.name.toLowerCase().includes(filterValue)));
}

  ngOnDestroy() {
    this.citiesSub.unsubscribe();
  }
}</code></pre>
</div>
</div>
</p>
","7953755","","7953755","","2018-07-24 18:07:09","2018-07-25 16:03:58","startWith on first click of focus","<angular><rxjs6><angular-material-5>","2","0","1","","","CC BY-SA 4.0"
"51492577","1","","","2018-07-24 07:11:20","","5","3713","<p>I have an application with an globalError handler like this:</p>

<pre><code>import { Injectable, ErrorHandler, Injector } from ""@angular/core"";
import { Router } from ""@angular/router"";

@Injectable()
export class GlobalErrorHandler implements ErrorHandler {

  constructor(
    private injector: Injector) { }


  public handleError(error: any) {
    console.error(""Something went wrong"");
    //.. Handle error here
  }
}
</code></pre>

<p>This always worked in every constallation. If an error was thrown the global handler caught it and handled it.</p>

<p>Now after upgrading to RxJs 6.2.2 I understood that catching http errors changed.</p>

<p>Code errors still keep working but errors thrown by the HttpClient are not globally caught. The GlobalErrorHandler is not fired any more.</p>

<p>I am aware that I can handle errors within my service and that works fine like this:</p>

<pre><code>doSomething() {
    return this.http
      .get(""http://someURL"").pipe(
      map((res: any) =&gt; { console.log(res) }),
        catchError(this.handleError&lt;any&gt;(`blabla`))
      );
  }

  /**
 * Handle Http operation that failed.
 * Let the app continue.
 * @param operation - name of the operation that failed
 * @param result - optional value to return as the observable result
 */
  private handleError&lt;T&gt;(operation = 'operation', result?: T) {
    return (error: any): Observable&lt;T&gt; =&gt; {
      console.log(""Now throwing error"");
      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead
      // Let the app keep running by returning an empty result.
      // ToDo: Global Error handler hier aufrufen....
      return of(result as T);
    };
  }
</code></pre>

<p>But I actually would like to handle all errors centrally.</p>

<p><strong>What is the correct way with Angular 6 and RxJs 6 to handle errors centrally?</strong></p>
","7579716","","3345644","","2018-12-28 18:55:30","2018-12-28 18:55:30","ErrorHandler & RxJS 6.2.2","<angular><rxjs><angular6><rxjs6><angular-errorhandler>","1","2","1","","","CC BY-SA 4.0"
"51499252","1","","","2018-07-24 12:58:16","","0","812","<p>I want to take Item from observable and transform it by <code>foreach</code> then result should be saved to new variable.</p>

<p>I'm not sure why this code doesn't work:</p>

<pre><code>policYears$: Observable&lt;PolicyYear[]&gt;;
policYearsSelector$: Observable&lt;YearSelector.PolicyYear[]&gt;;

this.policYearsSelector$ = this.policYears$.pipe(
    map((year: YearSelector.PolicyYear[]) =&gt; year.forEach(y =&gt; y.isActive = this.params.policyYearIds.indexOf(y.id) !== -1))
);
</code></pre>

<p>I have an error: <code>Type 'Observable&lt;void&gt;' is not assignable to type 'Observable&lt;PolicyYear[]&gt;'.
  Type 'void' is not assignable to type 'PolicyYear[]'.</code>
Why it returns void?</p>
","5515945","","","","","2018-07-24 13:32:25","Foreach in Observable for transformation","<rxjs><rxjs6>","3","0","","","","CC BY-SA 4.0"
"51501299","1","51502573","","2018-07-24 14:34:31","","6","6307","<p>I have an HTTP GET request that returns multiple objects that I want to turn into multiple observables.  Here is an example of the response:</p>
<pre><code>{
    lookup1: 
    [
      {
        &quot;label&quot;: &quot;lookup1 option 1&quot;,
        &quot;value&quot;: 1
      },
      {
        &quot;label&quot;: &quot;lookup1 option 2&quot;,
        &quot;value&quot;: 2
      }
    ],
    lookup2: 
    [
      {
        &quot;label&quot;: &quot;lookup2 option 1&quot;,
        &quot;value&quot;: 1
      },
      {
        &quot;label&quot;: &quot;lookup2 option 2&quot;,
        &quot;value&quot;: 2
      }
    ]
}
</code></pre>
<p>Here is my service that gets two observables:</p>
<pre><code>this.lookup1 = this.apiService.get('/lookups/')
  .pipe(map(response =&gt; response[&quot;lookup1&quot;]));
this.lookup2 = this.apiService.get('/lookups/')
  .pipe(map(response =&gt; response[&quot;lookup2&quot;]));
</code></pre>
<p>How do I do this with one HTTP GET request?</p>
<h2>EDIT</h2>
<p>Note that code like this will do 2 HTTP GET requests:</p>
<pre><code>let lookups = this.apiService.get('/lookups/');
this.lookup1 = lookups
  .pipe(map(response =&gt; response[&quot;lookup1&quot;]));
this.lookup2 = lookups
  .pipe(map(response =&gt; response[&quot;lookup2&quot;]));
</code></pre>
","1804678","","-1","","2020-06-20 09:12:55","2018-07-26 17:04:35","Multiple map() calls in an Angular 6 service","<angular><rxjs><rxjs6>","1","2","2","","","CC BY-SA 4.0"
"51514803","1","","","2018-07-25 08:56:33","","0","416","<p>I'm learning Angular and I don't understand what happens in my HTTP <code>get()</code> request to cause an <code>undefined TypeError</code>.</p>

<p>In an Angular service, I have the following two methods. <code>searchForCountries()</code> is called first successfully and <code>searchForCyties()</code> is called after and fails.
I tried to put a breakpoint on a <code>console.log(response)</code> and I never reach it.</p>

<pre><code>// That first one perfectly works and return the expected Observable
searchForCountries(): Observable&lt;CountryResult[]&gt; {
  const queryUrl = `${this.geoNamesCountriesUrl}`;
  console.log('query url: ', queryUrl);
  return this.http.get(queryUrl).pipe( map( response =&gt; {
    return &lt;any&gt;response['geonames'].map( result =&gt; {
      return new CountryResult ({
        name: result.countryName,
        code: result.fipsCode
      });
    });
  }));
}

// That one causes the message given below
searchForCities(query: string, country: string): Observable&lt;CityResult[]&gt; {
  const queryUrl = `${this.geoNamesCitiesUrl}&amp;postalcode=${query}&amp;country=${country}`; 
  console.log('query url: ', queryUrl); // &lt;&lt; -- I verified that the queryUrl returns an expected answer
  return this.http.get(queryUrl).pipe( map( response =&gt; {
    console.log(response); // &lt;&lt; --- Why never reach that line and get the error below ??
    return &lt;any&gt;response['postalcodes'].map( result =&gt; {
      console.log(result);
      return new CityResult ({
        name: result.placeName,
        cp: result.postalcode
      });
    });
  }));
}
</code></pre>

<p>Calling <code>searchForCities()</code> causes the following error:</p>

<pre><code>ERROR TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at subscribeTo (subscribeTo.js:41)
    at subscribeToResult (subscribeToResult.js:6)
    at SwitchMapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/switchMap.js.SwitchMapSubscriber._innerSub (switchMap.js:47)
    at SwitchMapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/switchMap.js.SwitchMapSubscriber._next (switchMap.js:40)
    at SwitchMapSubscriber.push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next (Subscriber.js:54)
    at MapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/map.js.MapSubscriber._next (map.js:41)
    at MapSubscriber.push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next (Subscriber.js:54)
    at DebounceTimeSubscriber.push../node_modules/rxjs/_esm5/internal/operators/debounceTime.js.DebounceTimeSubscriber.debouncedNext (debounceTime.js:48)
    at AsyncAction.dispatchNext (debounceTime.js:62)
    at AsyncAction.push../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js.AsyncAction._execute (AsyncAction.js:63)
defaultErrorLogger @ core.js:1633
push../node_modules/@angular/core/fesm5/core.js.ErrorHandler.handleError @ core.js:1679
next @ core.js:4255
schedulerFn @ core.js:3491
push../node_modules/rxjs/_esm5/internal/Subscriber.js.SafeSubscriber.__tryOrUnsub @ Subscriber.js:195
push../node_modules/rxjs/_esm5/internal/Subscriber.js.SafeSubscriber.next @ Subscriber.js:133
push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber._next @ Subscriber.js:77
push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next @ Subscriber.js:54
push../node_modules/rxjs/_esm5/internal/Subject.js.Subject.next @ Subject.js:47
push../node_modules/@angular/core/fesm5/core.js.EventEmitter.emit @ core.js:3483
(anonymous) @ core.js:3782
push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invoke @ zone.js:388
push../node_modules/zone.js/dist/zone.js.Zone.run @ zone.js:138
push../node_modules/@angular/core/fesm5/core.js.NgZone.runOutsideAngular @ core.js:3719
onHandleError @ core.js:3782
push../node_modules/zone.js/dist/zone.js.ZoneDelegate.handleError @ zone.js:392
push../node_modules/zone.js/dist/zone.js.Zone.runTask @ zone.js:191
push../node_modules/zone.js/dist/zone.js.ZoneTask.invokeTask @ zone.js:496
ZoneTask.invoke @ zone.js:485
timer @ zone.js:2054
setInterval (async)
scheduleTask @ zone.js:2075
push../node_modules/zone.js/dist/zone.js.ZoneDelegate.scheduleTask @ zone.js:407
onScheduleTask @ zone.js:297
push../node_modules/zone.js/dist/zone.js.ZoneDelegate.scheduleTask @ zone.js:401
push../node_modules/zone.js/dist/zone.js.Zone.scheduleTask @ zone.js:232
push../node_modules/zone.js/dist/zone.js.Zone.scheduleMacroTask @ zone.js:255
scheduleMacroTaskWithCurrentZone @ zone.js:1114
(anonymous) @ zone.js:2090
proto.(anonymous function) @ zone.js:1394
push../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js.AsyncAction.requestAsyncId @ AsyncAction.js:35
push../node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js.AsyncAction.schedule @ AsyncAction.js:28
push../node_modules/rxjs/_esm5/internal/Scheduler.js.Scheduler.schedule @ Scheduler.js:13
push../node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js.AsyncScheduler.schedule @ AsyncScheduler.js:31
push../node_modules/rxjs/_esm5/internal/operators/debounceTime.js.DebounceTimeSubscriber._next @ debounceTime.js:36
push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next @ Subscriber.js:54
push../node_modules/rxjs/_esm5/internal/operators/filter.js.FilterSubscriber._next @ filter.js:38
push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next @ Subscriber.js:54
push../node_modules/rxjs/_esm5/internal/operators/map.js.MapSubscriber._next @ map.js:41
push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next @ Subscriber.js:54
handler @ fromEvent.js:21
push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invokeTask @ zone.js:421
onInvokeTask @ core.js:3751
push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invokeTask @ zone.js:420
push../node_modules/zone.js/dist/zone.js.Zone.runTask @ zone.js:188
push../node_modules/zone.js/dist/zone.js.ZoneTask.invokeTask @ zone.js:496
invokeTask @ zone.js:1540
globalZoneAwareCallback @ zone.js:1566
</code></pre>

<p>I also tried to add a <code>catchError</code> on <code>map()</code> but obviously, I don't reach <code>map()</code>:</p>

<pre><code>searchForCities(query: string, country: string): Observable&lt;CityResult[]&gt; {
  const queryUrl = `${this.geoNamesCitiesUrl}&amp;postalcode=${query}&amp;country=${country}`;
  console.log('query url: ', queryUrl);
  return this.http.get(queryUrl).pipe(
    map( (response) =&gt; {
      console.log(response);
      return &lt;any&gt;response['postalcodes'].map( (result) =&gt; {
        ...
      });
    }),
    catchError((error): any =&gt; {
     throw Error(`HTTP Error: ${error}`);
    })
  );
}
</code></pre>

<p><strong>EDIT</strong>
<code>searchForCities()</code> is called like that in <code>ngOnInit()</code>:</p>

<pre><code>fromEvent(this.el.nativeElement, 'keyup')
.pipe(
  map((e: any) =&gt; e.target.value),
  filter((text: string) =&gt; text.length &gt; 2),
  debounceTime(250),
  map((query: string) =&gt; {
    console.log('query ' + query);
    this.citysearch.searchForCities(query, this.countrycode);
  }),
  switchAll()
)
.subscribe(
  (results: CityResult[]) =&gt; {
    this.cities = results;
  },
  (err: any) =&gt; {
    console.log(err);
  },
  () =&gt; {

  }
);
</code></pre>

<p>Any idea ?</p>
","3004821","","1505120","","2018-07-27 03:44:28","2018-07-27 03:44:28","Why do I get ""undefined"" on `http.get().pipe()`","<angular6><rxjs6>","0","5","","","","CC BY-SA 4.0"
"51528076","1","","","2018-07-25 21:40:05","","0","289","<p>I have an existing project that uses ImmutableJS for state, Redux Observable middleware, and RXJS 5.x. I noticed that latest version of Redux Observable that uses RXJS 6.x has a different dependency injection pattern than before. Specifically, that the store injection has been replaced with ""state$"" stream. My question is can I use RXJS 6.x with ImmutableJS? Would I treat ""state$"" as a normal immmutable object and use things like ""state$.get('username')""?</p>
","6545286","","","","","2019-06-07 23:18:21","ImmutableJS and Redux Observable with RXJS 6.x","<redux><rxjs><immutable.js><redux-observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51529297","1","51529429","","2018-07-26 00:09:13","","1","1611","<p>I have two sets of code that work, but I can't get either to work as I want it. So I was hoping for some conceptual insights. </p>

<p>I have a service grabbing cities from an API. This service auto-completes filter results. When I use <code>form builder</code>, I cannot get the data to filter because it isn't executing the <code>fromLatestWith</code>. </p>

<p>I am using <em>from latest with</em> to use both observables <code>valueChange</code> and the service that is bringing in the cities. It works when I use <code>formControl</code> but not with <code>formBuilder</code>.</p>

<p>When I do not use <code>fromLatestWith</code> I can get the service and autocomplete to work but, since the service loads first I have to type before the autocomplete dropdown shows.  </p>

<p>Ideally what I'd like is to use <code>formbuilder</code> and have the <strong>autocomplete drop down</strong> on initialization. What am I missing?</p>

<p>Here are copies of both instances:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>//using formBuilder with latestWith lets me see valueChange but doesnt
//load cities if I don't use formBuilder and use formControl it works

import { CityService } from ""../services/city-list.service"";
import { Component, OnInit, OnDestroy } from ""@angular/core"";
import { City } from ""../models/city"";
import { Subscription, Observable } from ""rxjs"";
import {
  map,
  filter,
  startWith,
  withLatestFrom,
  debounceTime
} from ""rxjs/operators"";
import {
  FormGroup,
  FormControl,
  FormBuilder,
  Validators,
  NgForm,
  Form
} from ""@angular/forms"";

@Component({
  selector: ""app-city-list"",
  templateUrl: ""./city-list.component.html"",
  styleUrls: [""./city-list.component.css""]
})
export class CityListComponent implements OnInit {
  cities: Observable&lt;City[]&gt;;

  destinationCitySub: Observable&lt;City[]&gt;;
  originCitySub: Observable&lt;City[]&gt;;

  instantFlightForm: FormGroup;


  constructor(public cityService: CityService, private fb: FormBuilder) {

  }

  ngOnInit() {
    this.instantFlightForm = this.fb.group({
      destinationCity: [""""],
      originCity: ["""", Validators.required],
      startDate: []
    });



    this.cityService.getCities();
    this.cities = this.cityService.getCityUpdateListener();
   this.destinationCitySub = this.valueChange('destinationCity');

  }

  private valueChange(string) {
    console.log(string);
    return this.instantFlightForm.get(string).valueChanges.pipe(
      withLatestFrom(this.cities),
      debounceTime(100),
      map(([term, city]) =&gt; {
        console.log(term);
        return this._filter(term, city);
      })
    );
  }

  private _filter(first, second): City[] {
    const filterValue = first.toLowerCase();
    return second.filter(option =&gt;
      option.name.toLowerCase().includes(filterValue)
    );
  }

  onInstantSearch(form: FormGroup) {
    console.log(form.value);
  }
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;mat-card&gt;

  &lt;form [formGroup]=""instantFlightForm"" (submit)=""onInstantSearch(instantFlightForm)""&gt;
    &lt;mat-form-field&gt;
      &lt;input  type=""text"" id=""destinationCity"" name=""destinationCity"" matInput formControlName=""destinationCity"" [matAutocomplete]=""autoDestination""&gt;

      &lt;mat-autocomplete #autoDestination=""matAutocomplete""&gt;
        &lt;mat-option *ngFor=""let c of destinationCitySub|async"" [value]=""c.code""&gt;
          {{c.name}} - {{c.code}}
        &lt;/mat-option&gt;
      &lt;/mat-autocomplete&gt;
    &lt;/mat-form-field&gt;
    &lt;mat-form-field&gt;
    &lt;input  type=""text"" id=""originCity"" name=""originCity"" matInput formControlName=""originCity"" [matAutocomplete]=""autoOrigin""&gt;

    &lt;mat-autocomplete #autoOrigin=""matAutocomplete""&gt;
      &lt;mat-option *ngFor=""let c of originCitySub|async"" [value]=""c""&gt;
        {{c}}
      &lt;/mat-option&gt;
    &lt;/mat-autocomplete&gt;
  &lt;/mat-form-field&gt;
  &lt;mat-form-field&gt;
      &lt;input matInput id=""startDate"" name=""startDate"" formControlName=""startDate"" [matDatepicker]=""picker"" placeholder=""Choose a date""&gt;
      &lt;mat-datepicker-toggle matSuffix [for]=""picker""&gt;&lt;/mat-datepicker-toggle&gt;
      &lt;mat-datepicker #picker&gt;&lt;/mat-datepicker&gt;
    &lt;/mat-form-field&gt;
    &lt;button mat-raised-button type=""submit"" color=""accent""&gt;Search&lt;/button&gt;
  &lt;/form&gt;
&lt;/mat-card&gt;</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>//using it without latestWith - lets me autocomplete but requires
//typing first

import { CityService } from ""../services/city-list.service"";
import { Component, OnInit, OnDestroy } from ""@angular/core"";
import { City } from ""../models/city"";
import { Subscription, Observable } from ""rxjs"";
import {
  map,
  filter,
  startWith,
  withLatestFrom,
  debounceTime
} from ""rxjs/operators"";
import {
  FormGroup,
  FormControl,
  FormBuilder,
  Validators,
  NgForm,
  Form
} from ""@angular/forms"";

@Component({
  selector: ""app-city-list"",
  templateUrl: ""./city-list.component.html"",
  styleUrls: [""./city-list.component.css""]
})
export class CityListComponent implements OnInit {
  cities: City[];
citySub: Subscription;
  destinationCitySub: Observable&lt;City[]&gt;;
  originCitySub: Observable&lt;City[]&gt;;

  instantFlightForm: FormGroup;

  constructor(public cityService: CityService, private fb: FormBuilder) {

  }

  ngOnInit() {
    this.instantFlightForm = this.fb.group({
      destinationCity: [""""],
      originCity: ["""", Validators.required],
      startDate: []
    });



    this.cityService.getCities();
    this.citySub = this.cityService.getCityUpdateListener().subscribe(c=&gt;this.cities=c);
   this.destinationCitySub = this.valueChange('destinationCity');

  }

  private valueChange(string) {
    return this.instantFlightForm.get(string).valueChanges.pipe(
     // withLatestFrom(this.cities),
      debounceTime(100),
      map((term) =&gt; {
        console.log(term);
        return this._filter(term);
      })
    );
  }

  private _filter(term): City[] {
    const filterValue = term.toLowerCase();
    return this.cities.filter(option =&gt;
      option.name.toLowerCase().includes(filterValue)
    );
  }

  onInstantSearch(form: FormGroup) {
    console.log(form.value);
  }
}</code></pre>
</div>
</div>
</p>
","7953755","","2195596","","2018-07-26 05:02:17","2018-07-26 05:02:17","form builder with autocomplete in angular 6","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51537230","1","","","2018-07-26 10:58:57","","2","89","<p>I'm looking for <code>observable</code> operator that after emitting value will wait for 500ms. 
If new value is emitted in that time it takes the new value and forget last. 
If no new value is emitted it passes this value further. </p>

<p>I tried:
<code>delay</code> - it only delays <em>every</em> value
<code>debounceTime</code> - it creates gaps between values and emits every one.</p>
","979911","","","","","2018-09-11 15:18:41","Operator that waits for new value in certain amount of time","<rxjs><observable><rxjs6>","2","4","","","","CC BY-SA 4.0"
"51552754","1","51553118","","2018-07-27 07:19:52","","0","26","<p>I found cstom operator that I want to use.</p>

<p>This is an operator that retries http requests. Code is from Stephen Fluin: <a href=""https://github.com/StephenFluin/http-operators/blob/master/operators/retryExponentialBackoff.operator.ts"" rel=""nofollow noreferrer"">https://github.com/StephenFluin/http-operators/blob/master/operators/retryExponentialBackoff.operator.ts</a>. </p>

<p>Problem is that if after all these reties it does not puts error in stream only completes.
I want it to throw an error. How to do it?
I think this part should be modified:</p>

<pre><code>     error(err: any) {
        if (count &lt;= maxTries) {
          subscription.add(scheduler.schedule(subscribe, initialWait * Math.pow(2, count++)));
        }
      },
</code></pre>

<p>Here is whole operator's class</p>

<pre><code>/**
 * Repeats underlying observable on a timer
 *
 * @param maxTries The maximum number of attempts to make, or -1 for unlimited
 * @param initialWait Number of seconds to wait for refresh
 */
export const retryExponentialBackoff = (
  maxTries = -1,
  initialWait = 1,
  scheduler: SchedulerLike = asyncScheduler
) =&gt; &lt;T&gt;(
  source: Observable&lt;T&gt;
) =&gt; {
  return new Observable&lt;T&gt;(subscriber =&gt; {
    let count = 1;
    const subscription = new Subscription();

    const subscribe = () =&gt;
      subscription.add(
        source.subscribe({
          next(value: T) {
            count = 1;
            subscriber.next(value);
          },
          error(err: any) {
            if (count &lt;= maxTries) {
              subscription.add(scheduler.schedule(subscribe, initialWait * Math.pow(2, count++)));
            }
          },
          complete() {
            subscriber.complete();
          },
        })
      );

    subscribe();

    return subscription;
  });
};
</code></pre>
","979911","","","","","2018-07-27 07:40:39","How to throw stream error in custom operator?","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51558734","1","","","2018-07-27 13:12:55","","2","1548","<p>I want to change nested flag in my <code>ships$</code> when flag <code>areShipsExpanded$</code> will change.
How can I do this. This is what I have so far:</p>

<pre><code>areShipsExpanded$: Observable&lt;boolean&gt;;
ships$: Observable&lt;Ship&gt;;

constructor() {
   this.ships$ = this.shipsDataSource.getData().pipe(shareReplay());
}

ngOnInit(): void {
    this.areShipsExpanded$.pipe(
        map(flag =&gt; {
            if (flag) {
                this.ships$.pipe(map(s =&gt; s.items.forEach(r =&gt; r.isExpanded = flag)));
            }
        })
    ).subscribe();
}
</code></pre>

<p>Unfortunately it seems that ships$ isn't modified, or maybe I should somehow refresh this <code>ships$</code> observable since I'm using it on my view in that way: <code>&lt;ng-container *ngFor=""let ship of (ships$ | async)?.items""&gt;</code></p>

<hr>

<p>@EDIT</p>

<p>I did it in that way, is it correct, or is the bad practice?</p>

<pre><code>this.areShipsExpanded$.pipe(
    map(flag =&gt; {
        if (flag) {
            this.ships$ = this.ships$.pipe(map(s =&gt; {
                s.items.forEach(r =&gt; r.isExpanded = flag);
                return s;
            }));
        }
    })
).subscribe();
</code></pre>

<hr>

<p>@EDIT2</p>

<p>I used <code>combineLatest</code>, should be fine now?</p>

<pre><code>shipsData$: Observable&lt;Ship&gt;;
ships$: Observable&lt;Ship&gt;;

constructor() {
   this.shipsData$ = this.shipsDataSource.getData().pipe(shareReplay());
}

this.ships$ = combineLatest(this.areShipsExpanded$, this.shipsData$).pipe
    map(([shipsExpanded, ships]) =&gt; {
        ships.items.forEach(r =&gt; r.isExpanded = shipsExpanded);
        return ships;
    }),
    share()
);
</code></pre>

<p>But problem of <code>combineLatest</code> that at the beginning functions will be runned 2 times since, both observables emits values. Is there any alternative operator that behaves like <code>combineLatest</code> - so when any observable emits a value, emit the latest value from each but <strong>ONLY WHEN all observables will be ready</strong>. To avoid repeating at the beginning.</p>
","5515945","","5515945","","2018-07-27 22:14:44","2018-07-31 01:45:14","How to modify observable stream by another observable in RXJS? Angular","<angular><rxjs><rxjs6>","1","10","","","","CC BY-SA 4.0"
"51559799","1","51571922","","2018-07-27 14:12:04","","0","248","<p>I've tried countless times upgrading to webpack 4 in one of our big projects, but each time I do I end up getting multiple errors, which I tracked back to rxjs. I haven't opened this issue until after I read so many similar looking problems, but none resolved my issue, and I'm still confused as to why this is happening in the first place.</p>

<p>In someplace, I do:</p>

<pre><code>import { Observable } from 'rxjs/Observable';

// Use Observable.fromPromise()
</code></pre>

<p>In <code>vendor.ts</code>, which is an entry module that I use to import things, I do this:</p>

<pre><code>import 'rxjs/add/observable/fromPromise';
</code></pre>

<p>Please note that this worked completely fine with webpack 3. Only after I update to webpack 4 do I get the problem. Furthermore, if I import from <code>rxjs/Rx</code> instead, this particular problem seems to be fixed, which means it's a problem related to <code>fromPromise</code> not being imported.</p>

<p>I had the following webpack config before I updated, in webpack 3:</p>

<pre><code>new webpack.optimize.CommonsChunkPlugin({
  names: ['vendor', 'polyfills'],
}),
</code></pre>

<p>I have this after the update, in webpack 4:</p>

<pre><code>optimization: {
    splitChunks: {
        cacheGroups: {
            vendor: {
                test: /[\\/]node_modules[\\/]/,
                name: 'vendor',
                chunks: 'all',
            },
        },
    },
},
</code></pre>

<p><strong>Environment</strong></p>

<ul>
<li><p>Runtime: all major browsers</p></li>
<li><p>RxJS version: 6.2.2</p></li>
<li><p>Webpack: 4.16.3 (and all versions of webpack 4)</p></li>
</ul>

<p><img src=""https://user-images.githubusercontent.com/4404199/43324775-a2ce3a8e-91bd-11e8-8961-b79b004bb465.png"" alt=""image""></p>
","2172786","","","","","2018-07-28 13:39:27","Adding things like `fromPromise` from rxjs doesn't work in webpack 4","<angular><webpack><rxjs><webpack-4><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51566088","1","51567729","","2018-07-27 22:03:40","","8","7132","<p>I have a server call which may return <code>HTTP 202</code>. Influenced by <a href=""https://stackoverflow.com/questions/44979131/rxjs-retry-with-delay-function"">this SO</a> thread, I have the following:</p>

<pre><code>this.http.get(url)
  .pipe(
    map(response =&gt; {
      if (response.status === 202) {
        throw response;
      }
      return response;
    }),
    retryWhen(errors =&gt; {
      return errors.pipe(
        delay(1000),
        take(3),
        concat(response =&gt; Observable.throw('Retries exceeded'))
      );
    }),
    catchError(handleError)
  );
</code></pre>

<p>Getting a <code>deprecated</code> warning on the use of <code>concat</code>. I understand the new <code>concat</code> is in <code>rxjs</code> and not <code>rxjs/operator</code>.</p>

<p>But, what is the right way to use the new <code>static concat</code> operator here? </p>

<p>Found the following <a href=""https://auth0.com/blog/whats-new-in-rxjs-6/"" rel=""noreferrer"">from this site</a></p>

<pre><code>import { concat } from 'rxjs/operators';
a$.pipe(concat(b$, c$));

// becomes

import { concat } from 'rxjs';
concat(a$, b$, c$);
</code></pre>

<p>I'm not able to wrap my head around which <code>Observable</code>s are being concatenated in my example code?</p>

<p><strong>UPDATE 1</strong></p>

<p>Changed the code to:</p>

<pre><code>return concat(this.http.get(url)
  .pipe(
    map(response =&gt; {
      if (response.status === 202) {
        throw response;
      }
      return response;
    }),
    retryWhen(errors =&gt; {
      return errors.pipe(
        delay(1000),
        take(3)
      );
    }),
    catchError(handleError)
  ), response =&gt; Observable.throw('Retries exceeded'));
</code></pre>

<p>But this results in:</p>

<pre><code>core.js:1598 ERROR TypeError: You provided 'function (response) { return rxjs__WEBPACK_IMPORTED_MODULE_2__[""Observable""].throw('Retries exceeded'); }' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
at subscribeTo (subscribeTo.js:41)
at subscribeToResult (subscribeToResult.js:6)
at 
</code></pre>
","688202","","688202","","2018-07-27 22:16:35","2018-07-28 20:33:07","What is the correct way to use concat along with pipe in Rxjs 6?","<angular><rxjs><angular-httpclient><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"51580071","1","51580123","","2018-07-29 11:52:09","","0","287","<p>How can I edit my observable values based on boolean Observable, any time that this boolean observable will be changed then <code>$ships</code> observable will be transformed.</p>

<pre><code>areShipsExpanded$: Observable&lt;boolean&gt;;
ships$: Observable&lt;Ship&gt;;

this.ships$ = this.shipsDataSource.getData().pipe(
    map(s =&gt; {
          if(this.areShipsExpanded$) {
              // do something with s
          } else {
              // do something else with s
          }
    return s;
})
</code></pre>

<p>and of course on view will be used <code>ships$ | async</code></p>

<p>Above code is incorrect because Observable isn't transformed again when <code>this.areShipsExpanded$</code> would change.</p>
","5515945","","5515945","","2018-07-29 11:56:12","2018-07-29 12:34:15","Conditional observable transformation based on boolean observable in rxjs","<angular><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"51590074","1","","","2018-07-30 08:42:51","","0","55","<p>Ok so here is the context.</p>

<p>Consider an e-commerce category page which loads products as <strong>Infinite Scroll</strong>.</p>

<p>Now as the user scrolls down, we change the query params to page=2 and we call the http service to load products of page 2 and then similiar process for page 3 and so on.</p>

<p>Now say the user is on page 3 and he clicks on a product, which takes him to the product detail component. And from there he clicks on the <strong>browser's back button</strong>.</p>

<p>So now he comes back to the category component with query param page=3, and the component makes the http call for page 3 onInit.</p>

<p>What I want to do is, that after the products for page 3 are loaded, I want to make the same call again for page=2 and on success of that make the third call for page=1.</p>

<p>On each call, I want to load the products of page 2 and page 1 on top of the page 3 products obviously.</p>

<p>My HTTP call looks like this:</p>

<pre><code>this._categoryService.get(
        this.categoryId,
        this.currentPage - 1,
        this.pageSize,
        sorting.sort,
        sorting.order,
        this._filterService.getFilter().getValue()
 ).subscribe(res =&gt; {
     if(this.pagination.type === 'standard' || this.items.length === 0){
       this.totalCount = res.total;
       this.items = res.data;
       this.filter = [...res.filter];
     }else{
       this.totalCount = res.total;
       this.items.push(...res.data);
       this.filter = [...res.filter];
     }
      });
</code></pre>

<p>So what I am doing on the success call back is to check that if the item's list is empty, just assign the response data to the array.</p>

<p>But if it is not empty, I am pushing the values to the already existing array.</p>

<p>I want to know, what is the proper way of doing this in rxJS 6. Is there an obvious operator that I can use to call page 3, then page 2 and then page 1, subsequently on each success callback?</p>

<p>Also, what is the best way to <strong>prepend (Append before/Unshift)</strong> the products on the items array?</p>

<p><strong>Please note, I have not yet implemented this, because I don't want to chain HTTP calls inside subscribe for obvious reasons.</strong></p>

<p>Thank you so much for your help in advance.</p>

<p><strong>EDIT BASED ON COMMENTS</strong></p>

<p>The infinite scroll will be applied only if products are less in number. Say for example maximum 10 pages of products.</p>

<p>If there are more, the category page will have normal pagination.</p>

<p>I am using both ngx-paginate and ngx-infinite-scroll for this project.</p>
","1504265","","1504265","","2018-07-30 08:58:06","2018-07-30 08:58:06","Call the same HTTP service with different page number parameters in Angular and RxJS 6","<javascript><angular><angular2-observables><rxjs6>","0","17","","","","CC BY-SA 4.0"
"51599873","1","","","2018-07-30 18:06:55","","0","417","<p>i have the following code to use ngx-bootstrap typeahed.</p>

<p>My html template:</p>

<pre><code>&lt;input [typeahead]=""dataSource""
       typeaheadWaitMs=""1000""
       (valueChanged)=""selectMember($event)""
       [formControl]=""form.controls['membernumber']"" class=""form-control"" id=""member""&gt;
</code></pre>

<p>And this is my typescript code:</p>

<pre><code> this.dataSource = Observable.create((observer: any) =&gt; {
   // Runs on every search
   observer.next(this.form.controls['membernumber'].value);
 })
  .pipe(
    mergeMap((token: string) =&gt; this.memberService.getMembersBySearchQuery2(token))
  );
</code></pre>

<p>The service implementation for getMemberBySearchQuery2 is this:</p>

<pre><code>public getMembersBySearchQuery2(query: string) : Observable&lt;Member[]&gt;{
let params = new HttpParams().set('query', query);
let options = this.authenticationService.getAuthenticationOptions();
return this.http.get&lt;Member[]&gt;(this.urlService.getMemberServiceUrl(), {
   headers: options,
   params: params
  });
}
</code></pre>

<p>In the network traffi i can see that the request is sening to the backend and i get a response. The response is a array of members.</p>

<p>But nothing is showing in the browser. Nothing happens. </p>

<p>I use Angular6 and ngx-bootsrap 2.0.0</p>
","10156780","","9692235","","2018-07-30 20:22:10","2018-07-30 20:22:10","ngx-bootstrap typeahead does't work","<angular><typescript><rxjs><ngx-bootstrap><rxjs6>","0","5","","","","CC BY-SA 4.0"
"51603801","1","","","2018-07-31 00:08:27","","12","4176","<p>Using Rxjs 6 I keep getting,</p>

<blockquote>
  <p>Error: CORS is not supported by your browser</p>
</blockquote>

<p>My code is pretty simple,</p>

<pre><code>import { ajax } from 'rxjs/ajax';

const ajax$ = ajax({
  url: genURL_chan(179),
  crossDomain: true,
  withCredentials: false,
  method: 'POST',
  body: { 'since': 0, 'mode': 'Messages', 'msgCount': 5000},
});
</code></pre>

<p>My code is pretty simple,</p>

<pre><code>/node_modules/rxjs/internal/util/hostReportError.js:4
    setTimeout(function () { throw err; });
                             ^

Error: CORS is not supported by your browser
    at getCORSRequest (/node_modules/rxjs/internal/observable/dom/AjaxObservable.js:27:15)
    at Object.createXHR (/node_modules/rxjs/internal/observable/dom/AjaxObservable.js:93:43)
    at Object.tryCatcher (/node_modules/rxjs/internal/util/tryCatch.js:7:31)
    at AjaxSubscriber.send (/node_modules/rxjs/internal/observable/dom/AjaxObservable.js:159:50)
    at new AjaxSubscriber (/node_modules/rxjs/internal/observable/dom/AjaxObservable.js:147:15)
    at AjaxObservable._subscribe (/node_modules/rxjs/internal/observable/dom/AjaxObservable.js:116:16)
    at AjaxObservable.Observable._trySubscribe (/node_modules/rxjs/internal/Observable.js:43:25)
    at AjaxObservable.Observable.subscribe (/node_modules/rxjs/internal/Observable.js:29:22)
    at Object.&lt;anonymous&gt; (/index.js:17:7)
    at Module._compile (internal/modules/cjs/loader.js:702:30)
</code></pre>
","124486","","","","","2019-03-15 23:44:13","Using rxjs ajax() I get ""CORS is not supported by your browser""","<node.js><ajax><cors><rxjs><rxjs6>","2","0","2","","","CC BY-SA 4.0"
"51605024","1","","","2018-07-31 03:23:53","","3","766","<p>I'm trying to build up a list of paged results. I have the loop working but I can get the observable to emit the final result. It loops completes but never emits to the subscribe. Not sure if using EMPTY is the wrong way to finish, or if the reduce isn't hit because of the EMPTY and just never fires the last result?</p>

<pre><code>getReportsAll(collection: Collection): Observable&lt;PagedResult&lt;ReportView&gt;&gt; {
return Observable.create(observer =&gt; {
  this.collectionService.collectionBy(collection)
  const url = this.collectionService.buildUrl(this.reportsUrl)
  const newPage = new PagedResult&lt;ReportView&gt;([], null, null, 0)
  this.getReportPage(url)
    .pipe(
      expand(result =&gt; {
        const skip = collection.pageBy.skip + collection.pageBy.top
        collection.pageBy = new PageBy(collection.pageBy.top, skip)
        this.collectionService.collectionBy(collection)
        const nextUrl = this.collectionService.buildUrl(this.reportsUrl)
        const test = result.count &gt;= collection.pageBy.top ? this.getReportPage(nextUrl) : EMPTY
        console.log('test', test)
        return test
      }),
      reduce((next: PagedResult&lt;ReportView&gt;, data: PagedResult&lt;ReportView&gt;, index: number) =&gt; {
        next.value = [...next.value, ...data.value]
        next.count = next.value.length
        console.log('next', next, index)
        return next
      }, newPage),
    )
    // .catch(error =&gt; observer.error(error))
    .subscribe(results =&gt; {
      console.log('results', results)
    })
})
</code></pre>

<p>}</p>
","1481571","","","","","2018-07-31 05:34:05","RxJS Expand Reduce Loop not returning result","<angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51605056","1","51605205","","2018-07-31 03:30:02","","0","251","<p>I am brand-spanking new to rxjs and Angular, and I've just discovered (thanks to my WebStorm giving me tons of red error messages) that rxjs5 is way different from version 6.</p>
<p>So I'm following this <a href=""https://www.sitepoint.com/angular-rxjs-create-api-service-rest-backend/"" rel=""nofollow noreferrer"">tutorial</a>, which guides users through assembling the API service with rxjs. The problem is, it's written for version 5.</p>
<p>Here is a sample API route written in <strong>version 5</strong>:</p>
<pre><code>public getAllTodos(): Observable&lt;Todo[]&gt; {
  return this.http
   .get(API_URL + '/todos')
   .map(response =&gt; {
     const todos = response.json();
     return todos.map((todo) =&gt; new Todo(todo));
   })
   .catch(this.handleError);
}
</code></pre>
<p>After reading the documentation, I've gotten the <strong>version 6</strong> route re-written to this point:</p>
<pre><code>public getAllTodos(): Observable&lt;Todo[]&gt; {
  return this.http
   .get(API_URL + '/todos')
   .pipe(
     map(response =&gt; {
      return response.map((todo) =&gt; new Todo(todo));
     }),
     catchError(this.handleError)
  );
}
</code></pre>
<p>The problem is, I'm getting:</p>
<blockquote>
<p>Property 'map' does not exist on type 'Object'.</p>
</blockquote>
<p>I am guessing this has to do with the response not being in json format, although the response does not seem to have a .json() method.</p>
","2908514","","-1","","2020-06-20 09:12:55","2018-07-31 03:51:22","Rxjs6 from rxjs5: Handling Observables in REST API method","<angular><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51613176","1","51613471","","2018-07-31 12:15:34","","1","38","<pre><code>return this.http.get(environment.remoteUrl + '/client').pipe(pluck('rows'), map((i: any) =&gt; i.doc));
</code></pre>

<p>I get data in the following structure: </p>

<pre><code>{ 
   rows: [
       {x: 123, doc: {a: 2}}, 
       {x:222, doc: {a: 1}}
   ], 
   c: 'hello', 
   b: 3 
}
</code></pre>

<p>I will only return the both docs under rows to the subscriber.</p>

<p>But it seems the map function did not work as i expect, because undefined is returned.</p>

<p>I expect <code>[ {a: 2}, {a: 1} ]</code></p>

<p>I found a solution:</p>

<pre><code>.pipe(pluck('rows'), flatMap((i: any) =&gt; i), map((i: any) =&gt; i.doc), toArray());
</code></pre>

<p>But hope there is a shorter way!?</p>
","5657968","","5657968","","2018-07-31 12:25:16","2018-07-31 12:31:13","Alter nested observable values","<angular><observable><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51618284","1","51618654","","2018-07-31 16:43:06","","1","215","<p>I'm trying to refactor my code from rxjs 5.x to rxjs 6 and Angular 6. I had a code that essentially triggers a search:</p>

<pre><code>  startAt = new Subject();
  endAt = new Subject();

  startobs = this.startAt.asObservable();
  endobs = this.endAt.asObservable();

  constructor() {}

  ngOnInit(){

    var that = this;

    Observable.combineLatest(this.startobs, this.endobs)
    .subscribe((value) =&gt; {
      this.acctServ.searchAccounts(value[0], value[1])
      .subscribe((accounts) =&gt; {
console.log(""accounts : "", accounts);
          });


      })


    });
  }
</code></pre>

<p>In order to refactor this I did the following:</p>

<pre><code>startAt = new Subject();
  endAt = new Subject();

  startobs = this.startAt.asObservable();
  endobs = this.endAt.asObservable();

  constructor() { 

  }//End of Constructor

  ngOnInit() {

    Observable.create().pipe(combineLatest(this.startobs, this.endobs))
    .subscribe((value) =&gt; {
      console.log(""Search Box Obersable : "", value);

      this.acctServ.searchAccounts(value[0], value[1])
      .subscribe((accounts) =&gt; {

        console.log(""accounts : "", accounts);
          });


      })


    });

  }//End of ngOnInit
</code></pre>

<p>However, this doesn't seem to have helped and the search is no longer being triggered. I was wondering how to actually refactor this code to work with rxjs 6 ?</p>
","3836415","","","","","2018-07-31 17:05:10","refactoring combinelatest for rxjs","<angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51632485","1","51646410","","2018-08-01 11:46:05","","0","128","<p>I am able to add asynchronous reducer, but unable to add asynchronous epics</p>

<p>Following this link <a href=""https://redux-observable.js.org/docs/recipes/AddingNewEpicsAsynchronously.html"" rel=""nofollow noreferrer"">Adding New Epics Asynchronously</a>, I tried using <code>epic$.next()</code> but was unable to add new epic.</p>

<pre><code>import { applyMiddleware, createStore, compose } from 'redux';
import { createEpicMiddleware, combineEpics } from 'redux-observable';
import { BehaviorSubject } from 'rxjs';
import { mergeMap } from 'rxjs/operators';
import createReducer from '../reducers';
import mainEpic from '../config/epics';
</code></pre>

<p>Middleware configuration is given below:</p>

<pre><code>const epicMiddleware = createEpicMiddleware();

const epic$ = new BehaviorSubject(mainEpic);
const rootEpic = (action$, state$) =&gt;
  epic$.pipe(mergeMap(epic =&gt; epic(action$, state$)));
</code></pre>

<p>Store Enhancers for redux dev tools</p>

<pre><code>const composeEnhancers =
  // compose;
  process.env.NODE_ENV === 'development' &amp;&amp;
  window.navigator.platform !== 'iPad' &amp;&amp;
  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
    ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
    : compose;
</code></pre>

<p>This is the instantiation of store</p>

<pre><code>export default () =&gt; {
  const store = createStore(
    createReducer(),
    composeEnhancers(applyMiddleware(epicMiddleware))
  );

  epicMiddleware.run(rootEpic);

  // Extra functionality to the store
  store.asyncReducers = {};
</code></pre>

<p>Here, I call injectRepics (Repics for reducer and epics) with parameters <code>key</code>, <code>reducer</code>, <code>newEpic</code> when new component is bound asynchronously</p>

<pre><code>  store.injectRepics = (key, reducer, newEpic) =&gt; {
    if (!store.getState()[key]) {

      // here I get newEpic
      console.log(newEpic);

      // new reducer is added to asyncreducer object
      store.asyncReducers[key] = reducer;
      // new reducer is created and replaced
      store.replaceReducer(createReducer(store.asyncReducers));

      // -------------------------------------
            But, I'm unable to replace epic
      // -------------------------------------
      newEpic &amp;&amp; epic$.next(newEpic);

      // epicMiddleware.run(rootEpic);
      // newEpic &amp;&amp; addNewEpic(newEpic);
    }
  };

  return store;
};
</code></pre>
","6892277","","","","","2018-08-02 05:54:57","How to add epics asynchronously?","<reactjs><redux><redux-observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51658675","1","51659074","","2018-08-02 16:50:02","","0","588","<p>I am trying to retrieve a collection from firebase that are called ""availableExercises"". I am using rxjs 6 and when I am mapping over and assigning the values in an object, I am getting a few errors. </p>

<p>Somehow the app still runs, but I am very confused about this error.</p>

<p>My exercise model is as follows:</p>

<pre><code>export interface Exercise {
  id: string;
  name: string;
  duration: number;
  calories: number;
  date?: Date;
  state?: 'completed' | 'cancelled' | null;
}
</code></pre>

<p>Here is my function I am calling:</p>

<pre><code> fetchAvailableExercises() {
    this.db
      .collection('availableExercises')
      .snapshotChanges()
      .pipe(
        map(docArray =&gt; {
          return docArray.map(doc =&gt; {
            return {
              id: doc.payload.doc.id,
              name: doc.payload.doc.data().name,
              duration: doc.payload.doc.data().duration,
              calories: doc.payload.doc.data().calories
            };
          });
        })
      )
      .subscribe((exercises: Exercise[]) =&gt; {
        this.availableExercises = exercises;
        this.exercisesChanged.next([...this.availableExercises]);
      });
  }
</code></pre>

<p>There errors when I run ng serve are:</p>

<pre><code>ERROR in src/app/training/training.service.ts(26,44): error TS2339: Property 'name' does not exist on type '{}'.
src/app/training/training.service.ts(27,48): error TS2339: Property 'duration' does not exist on type '{}'.
src/app/training/training.service.ts(28,48): error TS2339: Property 'calories' does not exist on type '{}'.
</code></pre>

<p>Here are my dependencies:</p>

<pre><code>""dependencies"": {
    ""@angular/animations"": ""^6.1.0"",
    ""@angular/cdk"": ""^6.4.1"",
    ""@angular/common"": ""^6.1.0"",
    ""@angular/compiler"": ""^6.1.0"",
    ""@angular/core"": ""^6.1.0"",
    ""@angular/flex-layout"": ""^6.0.0-beta.17"",
    ""@angular/forms"": ""^6.1.0"",
    ""@angular/http"": ""^6.1.0"",
    ""@angular/material"": ""^6.4.1"",
    ""@angular/platform-browser"": ""^6.1.0"",
    ""@angular/platform-browser-dynamic"": ""^6.1.0"",
    ""@angular/pwa"": ""^0.6.8"",
    ""@angular/router"": ""^6.1.0"",
    ""@angular/service-worker"": ""^6.1.0"",
    ""angularfire2"": ""^5.0.0-rc.11"",
    ""core-js"": ""^2.5.7"",
    ""firebase"": ""^5.3.0"",
    ""hammerjs"": ""^2.0.8"",
    ""rxjs"": ""^6.2.2"",
    ""zone.js"": ""^0.8.26""
  },
  ""devDependencies"": {
    ""@angular-devkit/build-angular"": ""~0.7.0"",
    ""@angular/cli"": ""^6.0.8"",
    ""@angular/compiler-cli"": ""^6.1.0"",
    ""@angular/language-service"": ""^6.1.0"",
    ""@types/jasmine"": ""^2.8.8"",
    ""@types/jasminewd2"": ""~2.0.2"",
    ""@types/node"": ""^10.5.4"",
    ""codelyzer"": ""^4.4.2"",
    ""jasmine-core"": ""~3.1.0"",
    ""jasmine-spec-reporter"": ""~4.2.1"",
    ""karma"": ""^2.0.5"",
    ""karma-chrome-launcher"": ""~2.2.0"",
    ""karma-cli"": ""~1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""^2.0.1"",
    ""karma-jasmine"": ""^1.1.2"",
    ""karma-jasmine-html-reporter"": ""^1.2.0"",
    ""protractor"": ""~5.4.0"",
    ""ts-node"": ""~7.0.0"",
    ""tslint"": ""~5.11.0"",
    ""typescript"": ""^2.7.2""
  }
</code></pre>

<p>if I <code>console.log(doc.payload.doc.data());</code>
I get the expected data as an object like so:
<code>{calories: 8, duration: 60, name: ""Burpees""}</code></p>
","3760413","","3760413","","2018-08-02 17:20:35","2018-08-02 17:25:28","Fetching data from firestore in angular app type error","<angular><typescript><firebase><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51674593","1","51820214","","2018-08-03 14:14:54","","1","127","<p>I have an app where I've implemented error handling according to the official Angular 6 tutorial in rest.service.ts</p>

<pre><code>... 
       return this.http.get(url).pipe(catchError(this.handleError));
  }

  private handleError(error: HttpErrorResponse) {
    if (error.error instanceof ErrorEvent) {
      // A client-side or network error occurred. Handle it accordingly.
      console.error(""An error occurred:"", error.error.message);
    } else {
      // The backend returned an unsuccessful response code.
      // The response body may contain clues as to what went wrong,
      console.error(
        `Backend returned code ${error.status}, ` + `body was: ${error.error}`
      );
    }
    // return an observable with a user-facing error message
    return throwError(error.error);
  }
</code></pre>

<p>My problem is that I also need to use forkJoin, and with this error handling, forkJoin hangs. Error handling in forkJoin tutorials looks like this:</p>

<pre><code>throwError('This will error').pipe(catchError(error =&gt; of(error))
</code></pre>

<p>How could I create a generic error handler that also works with forkJoin?</p>
","3896003","","","","","2018-08-13 10:28:07","How to implement generic error handling that works with forkJoin in Angular 6?","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51678587","1","51679439","","2018-08-03 18:55:23","","0","417","<p>I have following statement which was working well with rxjs5.5 and redux observable 0.x. Now, I'm using redux-observable v1, and rxjs v6. I coulnd't figure out how to trasform race for following code (since it's usage deprecated).</p>

<pre><code>(action$, state$) =&gt;
    action$.pipe(
      ofType(REQUEST),
      switchMap(action =&gt; {
        return race(
          action$.pipe(
            ofType(REQUEST_CANCEL),
            take(1),
            mapTo(
              observableOf(
                failure({
                  description: ""Cancelled by user.""
                })
              )
            ),
            ajax(`url`).pipe(
              map(response =&gt; response.response),
              map(data =&gt; success(data)),
              catchError(error =&gt;
                handleError(FAILURE, error)
              )
            )
          )
        );
      })
    ),
</code></pre>

<p>There migh be some other problem, It doesn't make the request. It think race is the problem.</p>
","2746389","","","","","2018-08-03 20:04:55","How to use race with rxjs 6","<rxjs><redux-observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51687403","1","","","2018-08-04 16:11:42","","7","6741","<p>I have this code snippet: </p>

<pre><code>SubmitTransaction(transNumber: string, transactionRequest: ITransactionRequestObj): Observable&lt;TransactionResponse&gt; {
    this.body =  JSON.stringify(transactionRequest);
    this.headers = new HttpHeaders().set('Content-Type', 'application/json');
    this.headers.append('Accept', 'application/json');
    this.options = new RequestOptions({headers: this.headers});
    return this.http.post&lt;TransactionResponse&gt;(this.baseUrl + '/transactions/' + transNumber + '/new',  this.body, this.options)
   .pipe(catchError((e) =&gt; this.errorHandler(e)));
  }
</code></pre>

<p>where all I did was upgrade my project from Angular 5 to Angular 6 and change <code>.catch((e) =&gt; this.errorHandler(e));</code> to  <code>.pipe(catchError((e) =&gt; this.errorHandler(e)));</code> . However, I am getting the following TypeScript error for this particular method. </p>

<p>Error: </p>

<pre><code>[ts]
Type 'Observable&lt;HttpEvent&lt;TransactionResponse&gt;&gt;' is not assignable to type 'Observable&lt;TransactionResponse&gt;'.
  Type 'HttpEvent&lt;TransactionResponse&gt;' is not assignable to type 'TransactionResponse'.
    Type 'HttpSentEvent' is not assignable to type 'TransactionResponse'.
      Property '_transactionNumber' is missing in type 'HttpSentEvent'.
</code></pre>

<p>I'm not sure what I should do in this scenario. The code snippet above was working in Angular 5. What do I need to do to fix it for Angular 6? </p>

<p>EDIT: </p>

<pre><code>errorHandler(error: HttpErrorResponse) {
      return throwError(error.message || 'Server Error');
  }
</code></pre>

<p>I have noticed if I don't use the HttpHeaders, it works: </p>

<pre><code>SubmitTransaction(transNumber: string, transactionRequest: ITransactionRequestObj): Observable&lt;TransactionResponse&gt; {
    this.body =  JSON.stringify(transactionRequest);
    this.headers = new HttpHeaders().set('Content-Type', 'application/json');
    this.headers.append('Accept', 'application/json');
    this.options = new RequestOptions({headers: this.headers});
    return this.http.post&lt;TransactionResponse&gt;(this.baseUrl + '/transactions/' + transNumber + '/new',  transactionRequest)
    .pipe(catchError((e) =&gt; this.errorHandler(e)));
  }
</code></pre>

<p>However, I might need to use the HttpHeaders... what is the workaround in this scenario? </p>
","2039574","","2039574","","2018-08-04 16:52:03","2018-08-08 14:21:12","Type 'Observable<HttpEvent<>>' is not assignable to type 'Observable<>'","<angular><typescript><angular6><rxjs6>","2","4","","","","CC BY-SA 4.0"
"51689582","1","51689765","","2018-08-04 21:11:29","","1","7198","<p>Can someone please illustrate the syntax for take(1) in Angular 6 / rxjs 6?</p>

<p>In the code below, I retrieve a document from Firestore and then make it available as an observable.  </p>

<p>I then subscribe to that observable, read the timestamp of the document, and format the age in human-readable format.  That works great, however it does not need to execute every time there are changes in the document stream.  It only needs to execute one time, since the document timestamp is never, ever going to change.</p>

<p>How can I modify this code to incorporate <code>take(1)</code>, so that the age string is only generated once and the subscription to <code>items</code> is not kept open?  I cannot find any clear example of the syntax for <code>take(1)</code> under Angular / rxjs version 6.  All of the examples I can find are for previous versions.</p>

<pre><code>import { Component, Input, OnChanges } from '@angular/core';
import { AngularFirestore, AngularFirestoreDocument } from 'angularfire2/firestore';
import { Item } from '../../interfaces/item';

@Component({
  selector: 'app-item',
  templateUrl: './item.component.html',
  styleUrls: ['./item.component.scss']
})
export class ItemComponent implements OnChanges {

  @Input() itemId: string;
  private itemDoc: AngularFirestoreDocument&lt;Item&gt;;
  public item: Observable&lt;Item&gt;;
  public age: string;

  constructor(private afs: AngularFirestore) {}

  ngOnChanges() {

    if ( this.itemId ) {

      this.itemDoc = this.afs.doc&lt;Item&gt;('items/' + this.itemId);
      this.item = this.itemDoc.valueChanges();

      this.item.subscribe(thisitem =&gt; {
        this.age = Utils.getFormattedAgeString(thisitem.timestamp);
      });

    }

  }

}
</code></pre>
","649131","","","","","2018-08-04 21:45:31","How to use take(1) in Angular 6?","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","1","1","","","","CC BY-SA 4.0"
"51695009","1","","","2018-08-05 14:01:54","","0","39","<p>I am doing a request on my service.ts and subscribing to it in a component.</p>

<p>All is working as I would expect, but it results in many request to the network. How can I write this better to prevent this?</p>

<pre><code> getDeal(id: string){
    const item: AngularFirestoreCollection&lt;Deal&gt; = this._afs.collection(`deals`,
    (ref) =&gt; ref.where(`id`, '==', id));
    return item.valueChanges().pipe(
     // take(1),
      map(arr =&gt; {
        return arr;
    }),
      switchMap(arr =&gt; {
        const userObservables = arr.map(deal =&gt; this._afs.doc(`users/${deal.customerId}`).valueChanges()
          );
         return combineLatest(...userObservables)
            .pipe(
              map((...eusers) =&gt; {
                arr.forEach((deal, index) =&gt; {
                  deal['customer_username'] =  eusers[0][index].displayName.username;
                  deal['customer_avatar'] = eusers[0][index].photoURL;

              });
              return arr;
            })
            );
      }),
      switchMap(arr =&gt; {
        const userObservables = arr.map(deal =&gt; this._afs.doc(`users/${deal.dealerId}`).valueChanges()
          );
         return combineLatest(...userObservables)
            .pipe(
              map((...eusers) =&gt; {
                arr.forEach((deal, index) =&gt; {
                  deal['dealer_username'] =  eusers[0][index].displayName.username;
                  deal['dealer_avatar'] = eusers[0][index].photoURL;
              });

              return arr;
            })
            );
      }),
      share()
  );

  }
</code></pre>

<p>In the component I do a subscribe ..</p>

<pre><code>this.subDeal = this._service.getDeal(id).subscribe((deal) =&gt; {
console.log(deal) // This should log just once, but it logs multiple times
}):
</code></pre>

<p>How to prevent the multiple network request?</p>
","6180766","","4929531","","2018-08-05 14:46:38","2018-08-05 14:46:38","How to prevent multiple network requests with reactive switchmap","<angular><angularfire2><rxjs6>","0","4","","","","CC BY-SA 4.0"
"51695075","1","","","2018-08-05 14:10:00","","0","1026","<p>The following Angular 6 service can be used to send/receive messages to/from other services/components (note that <code>getMsg</code> returns an Observable):</p>

<pre><code>@Injectable({ 
    providedIn: 'root' 
})
export class MessageService {

    private subject = new Subject&lt;any&gt;();

    sendMsg(message: any) {
        this.subject.next(message);
    }

    getMsg(): Observable&lt;any&gt; {
        return this.subject.asObservable();
    }
}
</code></pre>

<p>Now, what I need is to allow the sender/receiver to use channels, similar to AngularJS event names in $emit/broadcast. <code>sendMsg</code> signature would be as follows:</p>

<pre><code>sendMsg(channel: string, message: any)
</code></pre>

<p>and to receive a message, the receiver will have to subscribe the Observable using a channel name. Is this possible?</p>

<p>Note: I don't want to use <code>filter</code> in the subscription as it would affect performance if the number of messages is large. I prefer to use an Rxjs native option.</p>
","1362485","","","","","2018-08-06 02:20:07","Angular 6 - Using channels in Rxjs Observable","<angular><rxjs><rxjs6>","2","2","","","","CC BY-SA 4.0"
"51733749","1","","","2018-08-07 19:03:35","","3","4012","<p>I am trying to write some unit tests for my effects, but it seems like the test does not reach the part where I have my <code>expect</code>.  I don't want to use <code>jasmine-marbles</code>, I just want to use plain <code>jasmine</code> out of the box.</p>

<p><strong>Effects</strong></p>

<pre><code>@Effect
loadData$: Observable&lt;Action&gt; = this.actions$.pipe(
    ofType(actions.LOAD_DATA),
    switchMap(actions =&gt;
        this.dataService.getData().pipe(
            map(data =&gt; new actions.LoadDataSuccess(data)),
            catchError(err =&gt; of(new actions.LoadDataFailed(err)))
        )
    )
);
</code></pre>

<p><strong>spec file</strong></p>

<pre><code>let effects: fromData.DataEffects;
let actions: Observable&lt;any&gt;;
let mockState: fromData.DataState;
let mockDataService: jasmine.SpyObj&lt;DataService&gt;;

beforeEach((async(() =&gt; {
    mockState = { name: 'Test', age: 40 };
    mockDataService = jasmine.createSpyObj({'dataService', getData: of&lt;Data&gt;(mockState)});
    TestBed.configureTestingModule({
        imports: [],
        providers: [
            fromData.DataEffects,
            provideMockActions(() =&gt; actions),
            { provide: DataService, useValue: mockDataService }
        ]
    });
    effects = TestBed.get(fromData.DataEffects);
})));

it('should return new success action after load', fakeAsync(() =&gt; {
    let data: any;
    const actions = new ReplaySubject(1);
    actions.next(new fromData.LoadAction());
    effects.loadData$.subscribe(result =&gt; {
        data = result;
    });
    tick(100);
    expect(data).toEqual(fromData.LoadDataSuccess);
}));
</code></pre>

<p>The test is failing because <code>Expected undefined to equal Function</code>.  </p>

<p>Note I am using <strong>Angular 6</strong> with the latest <code>ngrx</code> and <strong>RxJS 6</strong>.</p>

<p>Thanks!</p>
","2063134","","","","","2019-01-30 06:20:14","How do you unit test ngrx effects with Angular 6 and without jasmine-marbles?","<angular><jasmine><angular6><ngrx-effects><rxjs6>","3","1","","","","CC BY-SA 4.0"
"51747372","1","52252469","","2018-08-08 12:57:15","","0","452","<p>I build a loading system for my game in typescript. I have some layer : Game > Scenes > Elements > Sprites > html image with load event. All waiting via observable.</p>

<p>First i have a sprite with multiple html image so i have a load function</p>

<pre><code>  public load(): Observable&lt;boolean&gt; {
    this.loadingObs = new Observable((observer) =&gt; {
      const layerNames = Object.keys(this.conf.layers);
      let nLayer: number = 0;
      layerNames.forEach((k) =&gt; {
        this.loadImage(k).subscribe((loadResult) =&gt; {
          if (loadResult) {
            nLayer++;
          }

          if (nLayer === layerNames.length) {
            this.loaded = true;
            observer.next(true);
            observer.complete();
          }
        });
      });
    });

    return this.loadingObs;
  }
</code></pre>

<p>And a method to retreive the observable</p>

<pre><code>  public getLoadingObs(): Observable&lt;boolean&gt; {
    return this.loadingObs;
  }
</code></pre>

<p>The idea is : if a have N Element that want to load the same Sprite, i create an observable for my image load event, store the observable and give the observable for the next Element Wanting it. So when image loading is done, all Element receive the 'notification' via the observable subscribe. It work.</p>

<p>About Game > Scenes > Elements > Sprites, all is about the mechanic like</p>

<pre><code>  public load(): Observable&lt;boolean&gt; {
    return new Observable((observer) =&gt; {
      let nRefs = 0;
      const spriteRefs = this.getSpritesRefs();

      // Load all needed sprites
      spriteRefs.forEach((ref) =&gt; {
        this.resources.loadSprite(ref).subscribe((loadFinished) =&gt; {
          if (loadFinished) {
            nRefs++;
          }

          if (nRefs === spriteRefs.length) {
            this.afterLoadInit();

            observer.next(true);
            observer.complete();
          }
        });
      });
    });
  }
</code></pre>

<p>My loadSprite service function get the new observable from sprite or retreive it like explain before. But i'm notified only when created and subscribed and never when retreive and subscribed. (It works just berfore)</p>

<p>So image loading is ok, some observable through all layer comunicate well, but not all. So if i wait 26 loading status, i receive 5 (5 real load), so why sudently observable not spread the next() function to all subscriber like before ?</p>

<p>I'm lost and i don't know tools or technics to debug observable more easily. I tried tap/do method without success. And console.log are mixed cause of async.</p>

<p>Thanks in advance for any help or advice</p>
","6427809","","","","","2018-09-10 06:51:27","Angular 6 rxjs observable not alert when next()","<typescript><observable><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51767204","1","51791430","","2018-08-09 12:35:18","","2","2503","<p>I have some code which polls until a task is complete</p>

<p>See below</p>

<pre><code>this.simulationStatus =
  interval(2000).pipe(
    switchMap(
      () =&gt; from(this.simulationService.getSimulationStatus(this.route.snapshot.paramMap.get('jobId')))),
    takeUntil(this.stopPoll),
    tap(simulation =&gt; {
      if (simulation &amp;&amp; simulation.complete) {
        if (this.stopCount == 1) {
          // Get once after complete
          this.stopPoll.next(true);
        }
        this.stopCount++;
      }
    })
  );
</code></pre>

<p>I have tried using takeUntil and takeWhile the problem is that that the last value is never published once the task is complete.</p>

<p>To get around this I have to include the tap method to with the stopPoll subject and incrementing the stopCount to get the last value. </p>

<p>So the above works but just feels a bit messy, I'm sure there must be a better way of achieving this?</p>

<p>I would have expected takeUntil to publish the last value or have an override to tell it to e.g takeUntil(observable, {publishLast: true})</p>

<p>BTW Update, the observable is subscribed to by an Angular 6 template 
Thanks in advance</p>
","2248174","","2248174","","2018-08-09 12:57:05","2021-06-23 14:17:33","RxJs Interval with takeUntil to publish last value","<angular6><rxjs6><rxjs-pipeable-operators>","3","0","1","","","CC BY-SA 4.0"
"51770795","1","51912649","","2018-08-09 15:24:57","","0","475","<p>I have response data from an Api that I send as json.send({message: 'success', itineraries: 'flight'})</p>

<p>I then perform my get request in Angular to retrieve the response. 
The response looks like </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>[  
    {  
       ""AirItinerary"":{  
          ""OriginDestinationOptions"":{  
             ""OriginDestinationOption"":[  
                {  
                   ""FlightSegment"":[  
                      {  
                         ""DepartureAirport"":{  
                            ""LocationCode"":""JFK""
                         },
                         ""ArrivalAirport"":{  
                            ""LocationCode"":""LAX""
                         },
                         ""MarketingAirline"":{  
                            ""Code"":""AS""
                         },
                         ""ArrivalTimeZone"":{  
                            ""GMTOffset"":-7
                         },
                         ""TPA_Extensions"":{  
                            ""eTicket"":{  
                               ""Ind"":true
                            }
                         },
                         ""StopQuantity"":0,
                         ""ElapsedTime"":375,
                         ""ResBookDesigCode"":""R"",
                         ""MarriageGrp"":""O"",
                         ""Equipment"":{  
                            ""AirEquipType"":""32S""
                         },
                         ""DepartureDateTime"":""2018-10-07T16:55:00"",
                         ""ArrivalDateTime"":""2018-10-07T20:10:00"",
                         ""FlightNumber"":1413,
                         ""OnTimePerformance"":{  
                            ""Percentage"":""NNN""
                         },
                         ""OperatingAirline"":{  
                            ""FlightNumber"":1413,
                            ""Code"":""AS""
                         },
                         ""DepartureTimeZone"":{  
                            ""GMTOffset"":-4
                         }
                      }
                   ],
                   ""ElapsedTime"":375
                },
                {  
                   ""FlightSegment"":[  
                      {  
                         ""DepartureAirport"":{  
                            ""LocationCode"":""LAX""
                         },
                         ""ArrivalAirport"":{  
                            ""LocationCode"":""JFK""
                         },
                         ""MarketingAirline"":{  
                            ""Code"":""AS""
                         },
                         ""ArrivalTimeZone"":{  
                            ""GMTOffset"":-4
                         },
                         ""TPA_Extensions"":{  
                            ""eTicket"":{  
                               ""Ind"":true
                            }
                         },
                         ""StopQuantity"":0,
                         ""ElapsedTime"":315,
                         ""ResBookDesigCode"":""R"",
                         ""MarriageGrp"":""O"",
                         ""Equipment"":{  
                            ""AirEquipType"":""32S""
                         },
                         ""DepartureDateTime"":""2018-10-20T07:35:00"",
                         ""ArrivalDateTime"":""2018-10-20T15:50:00"",
                         ""FlightNumber"":1404,
                         ""OnTimePerformance"":{  
                            ""Percentage"":""NNN""
                         },
                         ""OperatingAirline"":{  
                            ""FlightNumber"":1404,
                            ""Code"":""AS""
                         },
                         ""DepartureTimeZone"":{  
                            ""GMTOffset"":-7
                         }
                      }
                   ],
                   ""ElapsedTime"":315
                }
             ]
          },
          ""DirectionInd"":""Return""
       },
       ""TPA_Extensions"":{  
          ""ValidatingCarrier"":{  
             ""Code"":""AS""
          }
       },
       ""SequenceNumber"":1,
       ""AirItineraryPricingInfo"":{  
          ""PTC_FareBreakdowns"":{  
             ""PTC_FareBreakdown"":{  
                ""FareBasisCodes"":{  
                   ""FareBasisCode"":[  
                      {  
                         ""BookingCode"":""R"",
                         ""DepartureAirportCode"":""JFK"",
                         ""AvailabilityBreak"":true,
                         ""ArrivalAirportCode"":""LAX"",
                         ""content"":""R21N6""
                      },
                      {  
                         ""BookingCode"":""R"",
                         ""DepartureAirportCode"":""LAX"",
                         ""AvailabilityBreak"":true,
                         ""ArrivalAirportCode"":""JFK"",
                         ""content"":""R21XN6""
                      }
                   ]
                },</code></pre>
</div>
</div>
</p>

<p>I receive my object through a subscription and then transform it and send it to my component as an observable. 
How can I map the response when it is an object?
I can get the sequence number because it is of type number in my interface. I tried using a second interface, but I get a type error. </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { Itinerary, AirItineraryList } from ""./../models/Itinerary"";
import { Subject } from ""rxjs"";
import { Injectable } from ""@angular/core"";
import { HttpClient } from ""@angular/common/http"";

import { map } from ""rxjs/operators"";

@Injectable({
  providedIn: ""root""
})
export class InstantSearchService {
  Itineraries: Itinerary[] = [];
  private updatedItineraries = new Subject&lt;Itinerary[]&gt;();

  constructor(private http: HttpClient) {}

  getItineraries() {
    console.log('getting')
    this.http
      .get&lt;{ message: string; Itineraries: Itinerary[] }&gt;(
        ""http://localhost:3000/cities/instant""
      )
      .pipe(
        map(ItineraryData =&gt; {
          return ItineraryData.Itineraries.map(flight =&gt; {
            return {
              AirItinerary: flight.AirItinerary,
              SequenceNumber: flight.SequenceNumber
            };
          });
        })
      )
      .subscribe(transIten =&gt; {
        this.Itineraries = transIten;
        this.updatedItineraries.next([...this.Itineraries]);
      });
  }

  getItineraryUpdateListener() {
    return this.updatedItineraries.asObservable();
  }
}</code></pre>
</div>
</div>
</p>

<p>interface </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export interface Itinerary {
  AirItinerary:AirItineraryList[];
  SequenceNumber: Number;

}
export interface AirItineraryList {
  OriginDestinationOptions: Object;
  DirectionInd: string;
}</code></pre>
</div>
</div>
</p>
","7953755","","","","","2018-08-18 21:23:28","Use interface to map nested Array response from http request","<node.js><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51770861","1","51772830","","2018-08-09 15:28:02","","1","815","<p>Using rxjs@5, we implemented a convenient DisposeBag class to gather Subscriptions and make it easier to unsubscribe when destroying an Angular component.</p>

<pre><code>import { Subscription } from ""rxjs/Subscription"";

export class DisposeBag {
    private _subscription: Subscription[] = [];

    insert(subscription: Subscription): void {
        this._subscription.push(subscription);
    }

    dispose() {
        this._subscription.forEach(subscription =&gt; {
            subscription.unsubscribe();
        });
        this._subscription = [];
    }
}

export function disposedBy(this: Subscription, bag: DisposeBag): void {
    bag.insert(this);
}

Subscription.prototype.disposedBy = disposedBy;

declare module ""rxjs/Subscription"" {
    interface Subscription {
        disposedBy: typeof disposedBy;
    }
}
</code></pre>

<p>Upgrading to rxjs@6 + rxjs-compat@6, we get the following compile errors:</p>

<p><code>(12) Property 'unsubscribe' does not exist on type 'Subscription'.
(22) 'Subscription' only refers to a type, but is being used as a value here.</code></p>

<p>Switching the 1st import to </p>

<p><code>import { Subscription } from ""rxjs"";</code></p>

<p>solves both errors but introduces a <code>(22) Property 'disposedBy' does not exist on type 'Subscription'.</code> error.</p>

<p>How can we fix this?</p>
","288052","","","","","2019-03-08 10:47:48","Adding method to RxJs 6 Subscription prototype","<angular><rxjs><rxjs6>","1","4","","","","CC BY-SA 4.0"
"51777885","1","","","2018-08-10 01:58:37","","0","58","<p>I know there are examples on effect error handling all over the net but in my case I am not calling an http service which returns an observable like 99% of the examples I have found, so I am at a loss for structuring these operators to get the desired effect.</p>

<p>I need to move my catchError() into my switchMap()</p>

<pre><code>switchMap( ( [ routerState, state ] ) =&gt; {

    const tenantKey = routerState.params[ 'tenantKey' ];
    if ( state ) {
      if ( state.tenant &amp;&amp; state.tenant.id === tenantKey ) {
        return of( { type: '[TenantContext] Tenant Context Check Valid', payload: state.tenant } );
      } else {
        return of( new LoadContextAction( tenantKey ) );
      }

    } else {
      return of( new LoadContextAction( tenantKey ) );
    }

  } ),
  catchError( ( err ) =&gt; {
    return of( { type: '[TenantContext] Error', payload: err } );
  } )
</code></pre>
","202820","","","","","2018-08-12 13:56:56","error handling inside ngrx effects","<ngrx-effects><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51778328","1","52123431","","2018-08-10 03:02:43","","0","62","<p>I'm trying to map angularfire2's promises into typed observables. This is my class:</p>

<pre><code>export class RestService&lt;T extends Entity&gt; {

    constructor(
        protected afAuth: AngularFireAuth,
        protected store: AngularFirestore,
        protected readonly collectionName: string) {

        this.collection = store.collection&lt;T&gt;(collectionName);

    }

    protected collection: AngularFirestoreCollection&lt;any&gt;;

    all(): Observable&lt;Array&lt;T&gt;&gt; {
        return from(this.collection
            .snapshotChanges()
            .pipe(
                map(action =&gt; mapActionArray(action)),
                catchError((error: any) =&gt; {
                    throw new ApiError(error);
                })
            )
        );
    }


}

/**
 * Override Firestore errors with common app errors.
 * @param error - Firestore error
 */
function mapError(error: any): Observable&lt;ApiError&gt; {
    return throwError(new ApiError(error));
}

function mapDocument&lt;T extends Entity&gt;(doc: DocumentSnapshot&lt;any&gt;): T {
    return {
        id: doc.id,
        ...doc.data()
    };
}
</code></pre>

<p>Notice the all() method, I want to map any error in the catchError, but the thing is I get this type error:</p>

<blockquote>
  <p>TS2322: Type 'Observable&lt;{}[]>' is not assignable to type 'Observable'.   Type '{}[]' is not assignable to type 'T[]'.     Type '{}' is not assignable to type 'T'.</p>
</blockquote>

<p>I fixed it by changing the return type to Observable&lt;{} | Array>, but that would require using the same types whenever I use this service, I don't find it good.
How do I work around this? I want to be able to type my services and in beforehand map the errors into a proper CustomError object (this includes mapping codes to messages).</p>

<p>Btw, I also tried using the throwError from RXJS.</p>

<p>Thanks in advance.</p>
","2929113","","","","","2018-08-31 22:55:52","AngularFire2 promises into Observable type Issues","<rxjs><angularfire2><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51782888","1","51783490","","2018-08-10 09:08:06","","3","243","<p>We have a function that gets a stream from the backend as observable. However we would like to be able to push to that observable as well to see the changes before those are done in the back-end. To do so I tried giving back a subject instead but the connection is still on going after the unsubscribe.</p>

<p>In other words, in the code below, we would like the <code>console.log(i)</code> not to start before we subscribe to the subject, and finish when we unsubscribe from it :</p>

<pre><code>import { ReplaySubject, Observable, interval } from 'rxjs';
import { tap } from 'rxjs/operators'

function test() {
    const obs = interval(1000).pipe(tap(i =&gt; console.log(i)));
    const subj = new ReplaySubject(1);
    obs.subscribe(subj);
    return subj;
}

const subject = test();
subject.next('TEST');

const subscription = subject.pipe(
    tap(i =&gt; console.log('from outside ' + i))
).subscribe()
setTimeout(_ =&gt; subscription.unsubscribe(), 5000);
</code></pre>

<p><a href=""https://rxjs-playground.github.io/#/?html=&amp;js=%2F%2F%20A%20simple%20illustration%20to%20count%20to%203.%0Afunction%20fn%28%29%20%7B%0A%20%20const%20obs%20%3D%20Rx.Observable.interval%281000%29.do%28i%20%3D%3E%20console.log%28i%29%29%3B%0A%20%20const%20subj%20%3D%20new%20Rx.Subject%28%29%3B%0A%20%20obs.subscribe%28subj%29%3B%0A%20%20return%20subj%3B%0A%7D%0Aconst%20subj%20%3D%20fn%28%29%3B%0Asubj.next%28%27TEST%27%29%3B%0A%0Aconst%20subscription%20%3D%20subj.do%28i%20%3D%3E%20console.log%28%27from%20outside%20%27%20%2B%20i%29%29.subscribe%28%29%0AsetTimeout%28_%20%3D%3E%20subscription.unsubscribe%28%29%2C%205000%29%3B%0A%20%20%20%20"" rel=""nofollow noreferrer"">example</a></p>
","4299560","","","","","2018-08-10 09:44:04","Turn observable into subject","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51809492","1","","","2018-08-12 13:57:18","","1","691","<p>Our angular project tslint </p>

<pre><code>""import-blacklist"": [
        true,
        ""rxjs""
]
</code></pre>

<p>So if i import as rxjs6, it will show this is blacklisted. When i searched for the reason of including rxjs will import all the Rx functionality and increase the application bundle side. </p>

<p>So currently for Observable, Observer it import as </p>

<pre><code>import { Observable } from 'rxjs/Observable';
import { Observer } from 'rxjs/Observer';
</code></pre>

<p>I want to use the <code>Observable.empty();</code> but it will cause error </p>

<blockquote>
  <p>rxjs_Observable__WEBPACK_IMPORTED_MODULE_8__.Observable.empty is
  not a function</p>
</blockquote>

<pre><code>import { empty } from 'rxjs/Observable/empty';
</code></pre>

<p>I can directly call <code>empty()</code>. But the <code>import { empty }</code> in the editor shows that it is deprecated. </p>

<p>After searching in rxjs 6, it should <code>import { empty } from 'rxjs'</code>.</p>

<p>So i would like to ask about how to fix this import { empty } deprecation without increasing the application bundle size. Does import { Observable, Observer } from 'rxjs' really increases the size?<br>
If it import from 'rxjs', then i can use Observable.empty(). It has no problem. </p>

<p>Thanks a lot. </p>
","3733534","","","","","2019-03-07 16:25:57","Does the way of rxjs6 import dramatically increase the size of the application bundle","<angular><rxjs6>","2","2","","","","CC BY-SA 4.0"
"51816901","1","51825847","","2018-08-13 07:10:46","","1","49","<p>I am using TypeScript and Rxjs. I am sending data to the server using Rxjs. I  have also implemented a custom interceptor. The interceptor returns a <code>type:0</code> event and also the response from the server as two separate events. I suppose <code>type:0</code> means that the request has been sent.</p>

<p>I don't want to do anything when <code>type:0</code> event is received so I have put checks in the code to ignore it but my code still executes a piece of logic even if the event is <code>type:0</code>. Have I made a mistake?</p>

<p>The code where I send the request is</p>

<pre><code>let response:ServerResponseAPI = this.dataManagementService.addData(this.newData);
      console.log(""add practice question - response is "",response); //I see this print
      if (response != null) { //for type:0, this should be null but isn't

        let isResponseStructureOK: boolean = this.helper.validateServerResponseStructure(response);
        if (isResponseStructureOK) {
          console.log(""received response from server: "" + response.result);
          let dialogComponentRef: ComponentRef&lt;DialogBoxComponent&gt; = this.maxFilesDialogContainerRef.createComponent(this.dialogFactory);
          dialogComponentRef.instance.dialogMessage = response.result + "": "" + response['additional-info'];
          dialogComponentRef.instance.dialogID = ""maxFilesDialog"";
          dialogComponentRef.instance.dialogShow();
          return;
        } else {  //response structure not ok
          console.log(""received incorrect response structure from server: "", response);
          let dialogComponentRef: ComponentRef&lt;DialogBoxComponent&gt; = this.maxFilesDialogContainerRef.createComponent(this.dialogFactory);
          dialogComponentRef.instance.dialogMessage = ""Server error"";
          dialogComponentRef.instance.dialogID = ""maxFilesDialog"";
          dialogComponentRef.instance.dialogShow();
          return;
        }
      } //end of not null response
</code></pre>

<p>addData is</p>

<pre><code>addData(data:Data):ServerResponseAPI{
    console.log(""In DataManagementService: addData: "",data);

    return this.bs.createData(data).subscribe((resBody/*:any*/)=&gt;{
      if(resBody != null) { //null means that the response wasn't an HttpResponse but probably some internal Rxjs event (eg type 0)
        console.log('response from server:', resBody);
        &lt;ServerResponseAPI&gt;resBody; //returning response body which is of type ServerResponseAPI;
      }
      else null; //this means type0 event
    });
  }
</code></pre>

<p>and bs.createData is</p>

<pre><code>public createData(data:Data):any{
    console.log('contacting server at '+this.API_URL +this.NEW_DATA_URL +"" with data ""+data+ "" with httpOptions ""+httpOptions.withCredentials + "",""+httpOptions.headers );

    let newData = new DataAPI(data)

    let body = JSON.stringify(newData); 

    return this.http.post(this.NEW_DATA_URL,body,httpOptions)
      .map(response =&gt; { //I suppose this could be any event from custom interceptor 
        if(response instanceof HttpResponse)
        {
          console.log('response from backend service:', response);

          let result = &lt;HttpResponse&lt;any&gt;&gt;response;

          return result.body; //return body of response which ideally should be of type ServerResponseAPI
        }
        else {
          console.log(""not an http response"")

          return null; //returning null for non-HttpResponse type
        }
      })
      .catch(this.handleError); //error handler if Observable fails

  }
</code></pre>

<p>The interceptor is</p>

<pre><code>intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {


    console.log(""outgoing request"",request);
    const idToken = localStorage.getItem(""id_token""); //JWT authentication stuff
    console.log(""id token is ""+idToken);

    if (idToken) {
      const cloned = request.clone({
        headers: request.headers.set(""X-Auth-Token"",
          idToken)
      });
      console.log(""new outgoing request"", request);
      return next.handle(cloned) 
      .do((ev: any) =&gt; { 
        console.log(""got an event"",ev)
      })
      .catch(errorResponse =&gt; {
          console.log(""caught error from server"",errorResponse)
          return observableThrowError(errorResponse);
      });
    }
    else {
      return next
      .handle(request) 
      .do((ev: any) =&gt; { 
          console.log(""got an event"",ev)
            })
      .catch(errorResponse =&gt; {
          console.log(""caught error from server"",errorResponse)
          return observableThrowError(errorResponse);
      });
    }

      }
</code></pre>

<p>When I run the code, I see this message which I shouldn't</p>

<p><code>got an event {type: 0}</code>
<code>new-data.component.ts:255 add data- response is  Subscriber {closed: false, _parent: null, _parents: null, _subscriptions: Array(1), syncErrorValue: null, …}</code>
<code>new-practice-question.component.ts:270 received incorrect response structure from server:  Subscriber {closed: false, _parent: null, _parents: null, _subscriptions: Array(1), syncErrorValue: null, …}</code></p>

<p>I suppose I get <code>HttpEvent</code> from <code>Rxjs</code> which is a union of HttpResponse.</p>

<pre><code>type HttpEvent&lt;T&gt; = HttpSentEvent | HttpHeaderResponse | HttpResponse&lt;T&gt; | HttpProgressEvent | HttpUserEvent&lt;T&gt;;
</code></pre>

<p>How could I check that <code>HttpEvent</code> is of type <code>HttpResponse</code>?</p>
","6703783","","472495","","2019-10-08 20:44:01","2019-10-08 20:45:13","TypeScript code getting executed but it shouldn't","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"51828801","1","","","2018-08-13 18:51:15","","0","256","<p>I am migrating from angular 5 to 6 and I can't quite figure out the new pipeable operator syntax.</p>

<p>Consider my angular 5 http interceptor</p>

<pre><code>intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
this.request = req;

//do stuff
return next.handle(this.request)
  .do(event =&gt; {

   //do logging stuff
  },
  err =&gt; {
    //do error stuff
  });
}
</code></pre>

<p>Here is my attempt in converting this to the <code>pipe</code> way</p>

<pre><code>intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
this.request = req;

//do stuff
return next.handle(this.request).pipe(
  tap(event =&gt; {

   //do logging stuff
  },
  err =&gt; {
    //do error stuff
  }));
}
</code></pre>

<p>This doesn't compile however - the whole thing withing the <code>pipe</code> function is underlined with the following error.</p>

<pre><code>Severity    Code    Description Project File    Line    Suppression State
Error   TS2345  (TS) Argument of type 'MonoTypeOperatorFunction&lt;{}&gt;' is not 
assignable to parameter of type 'UnaryFunction&lt;Observable&lt;HttpEvent&lt;any&gt;&gt;, 
Observable&lt;any&gt;&gt;'.
Types of parameters 'source' and 'source' are incompatible.
Type 'Observable&lt;HttpEvent&lt;any&gt;&gt;' is not assignable to type 
'Observable&lt;{}&gt;'.
  Property 'source' is protected in type 'Observable&lt;HttpEvent&lt;any&gt;&gt;' but public in type 'Observable&lt;{}&gt;'.  C:\Users\stas.levich\Documents\Projects\EEA.Projects\DEP\MassAir\Web (tsconfig or jsconfig project) C:\Users\stas.levich\Documents\Projects\EEA.Projects\DEP\MassAir\Web\src\app\services\httpinterceptor.service.ts    44  Active
</code></pre>
","2501497","","1930348","","2018-10-07 11:58:24","2018-10-07 11:58:24","patched operators to pipable operators, angular 5 to 6","<angular><rxjs><angular-http-interceptors><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"51834611","1","51834629","","2018-08-14 06:01:27","","0","619","<p>How can I return true/false inside <code>subscribe</code>?</p>

<pre><code>import {Injectable} from '@angular/core';
import {Router, CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot} from '@angular/router';
import {AppState} from '../../app.state';
import {select, Store} from '@ngrx/store';
import {merge, combineLatest} from 'rxjs';
import {map, take, tap} from 'rxjs/operators';
import {HttpClient} from '@angular/common/http';


@Injectable()
export class PermissionsGuard implements CanActivate {

user;

constructor(
  private router: Router,
  private store: Store&lt;AppState&gt;
) {
}

canActivate(route: ActivatedRouteSnapshot): any {

  const academy$ = this.store.pipe(select(state =&gt; state.academy));
  const user$ = this.store.pipe(select(state =&gt; state.user));

  return combineLatest(
     academy$,
     user$
  ).pipe(
     map((data) =&gt; {
        console.log(data[0]);
        console.log(data[1]);
        return data;
     })
  ).subscribe((data) =&gt; {
     console.log(data);
     // return true or false to guard
  })
}

}
</code></pre>
","913951","","","","","2018-08-14 06:03:49","Angular 6+ Guards - Return true/false to combineLatest subscription","<angular><rxjs><rxjs6><angular-guards>","1","0","","","","CC BY-SA 4.0"
"51839305","1","","","2018-08-14 10:28:37","","0","521","<p>I have the code like this:</p>

<p>Form:</p>

<pre><code>&lt;form [formGroup]=""logoForm"" (ngSubmit)=""saveLogoInfo(logoForm)""&gt;

    &lt;mat-card&gt;

        &lt;mat-card-title&gt;Add information about your creative logo&lt;/mat-card-title&gt;

        &lt;mat-form-field&gt;
            &lt;input matInput placeholder=""Title"" #logoTitle formControlName=""logoTitle"" required&gt;
        &lt;/mat-form-field&gt;

        &lt;mat-form-field&gt;
            &lt;input matInput placeholder=""Caption"" formControlName=""logoCaption"" #logoCaption&gt;
        &lt;/mat-form-field&gt;    

    &lt;/mat-card&gt;

&lt;/form&gt;
</code></pre>

<p>ts code:</p>

<pre><code>import { Component, OnInit, ViewChild, ElementRef } from '@angular/core';
import { LogoDesignService } from './logo-design.service';
import { NgForm, FormGroup, FormControl, FormBuilder, Validators } from '@angular/forms';
import { Observable } from 'rxjs/Rx';
import { auditTime } from ""rxjs/operators"";


@Component({
  selector: 'app-logo-design',
  templateUrl: './logo-design.component.html',
  styleUrls: ['./logo-design.component.css']
})
export class LogoDesignComponent implements OnInit {

  logoForm: FormGroup;

  @ViewChild('logoTitle') logoTitle: ElementRef;
  @ViewChild('logoCaption') logoCaption: ElementRef;
  private alive: boolean;

  constructor(private _logoDesignService: LogoDesignService, private fb: FormBuilder) { }

  ngOnInit() {

    this.logoForm = this.fb.group({
      logoTitle: ['', Validators.required],
      logoCaption: '',
    });

    this.logoForm.valueChanges.auditTime(3000).subscribe(value =&gt; {
      console.log('value', value);
    })
  }

  progressiveSave(logoTitle) {
    console.log('debouncing 1: ', logoTitle);
  }

  saveLogoInfo(form: NgForm) {
  }

}
</code></pre>

<p>Package json:</p>

<pre><code>""rxjs"": ""6.0.0"",
""rxjs-compat"": ""^6.2.2"",
</code></pre>

<p>I get error on page: <code>ERROR TypeError: this.logoForm.valueChanges.auditTime is not a function</code></p>
","1800583","","","","","2018-08-14 10:28:37","rxjs audit time not working with angular 6","<angular><rxjs6>","0","3","","","","CC BY-SA 4.0"
"51845336","1","","","2018-08-14 15:50:25","","1","139","<p>As part of migrating my project from angular 5 to 6 I had to update the way RXJS6 does things.</p>

<p>So this </p>

<pre><code>this.filteredList = this.autoComplete.valueChanges
.startWith(null)
.map(val =&gt; val ? this.filter(val) : this.list.slice());
</code></pre>

<p>changed to this</p>

<pre><code>this.filteredList = this.autoComplete.valueChanges.pipe(
startWith(null),
map(val =&gt; val ? this.filter(val) : this.list.slice()));
</code></pre>

<p>It seems the compiler can't infer type anymore as I get </p>

<pre><code>Severity    Code    Description Project File    Line    Suppression State
Error   TS2345  (TS) Argument of type '{}' is not assignable to parameter of 
type 'string'.  
</code></pre>

<p>I get the same thing on all the <code>pipeable</code> operators - none of them can tell the type of the data they are receiving. How do I help it out?</p>

<p>Interestingly enough this seems to be only an intellisense error is the code compiles and works fine.</p>
","2501497","","2501497","","2018-08-14 18:49:01","2018-08-14 18:49:01","Can't infer type in the map function","<angular><rxjs><angular6><rxjs6>","0","5","","","","CC BY-SA 4.0"
"51845378","1","","","2018-08-14 15:52:34","","0","57","<p>Having following setup,</p>

<blockquote>
  <p>Angular-4.2.4, 
  RXJS - 5.4.2 </p>
</blockquote>

<p>I wanted to upgrade RXJS so I did it and now it is</p>

<blockquote>
  <p>rxjs-6.2.2</p>
</blockquote>

<p>I faced problems like <code>map, subscribe, Observable</code> not exist.</p>

<p>So installed <code>rxjs-compat</code> for backward compatibility.</p>

<blockquote>
  <p>rxjs-compat-6.2.2</p>
</blockquote>

<p>But still I get the same errors.</p>

<p>Any solution? Am I doing something wrong? </p>

<p>Any guidance will be pretty helpful.</p>

<p><strong><em>Plesae note that I don't want to upgrade Angular</em></strong></p>
","3751711","","","","","2018-08-14 16:46:23","Property map, subscribe, observable not exist","<angular><rxjs5><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51847650","1","51847853","","2018-08-14 18:24:27","","0","598","<p>Consider the following code Angular 5 + older rxjs</p>

<pre><code>this.measurementUnitsService.GetAll().subscribe(
        res =&gt; {
            this.measurementUnits = res.map(x =&gt; new MeasurementUnit(x));
        }
    )
</code></pre>

<p>I am getting a list of objects and for each one of them creating a new strongly typed class.</p>

<p>How would I go about doing the same in angular 6 + rxjs 6
My attempt.</p>

<pre><code>this.measurementUnitsService.GetAll().pipe&lt;MeasurementUnit[]&gt;(mergeMap(x =&gt; new MeasurementUnit(x))).subscribe(
  res =&gt; {
    this.measurementUnits = res;
  }
)
</code></pre>

<p>It generates an error unfortunately <code>Type 'MeasurementUnit[]' has no properties in common with type 'Partial&lt;MeasurementUnit&gt;'.</code></p>

<p><code>MeasurementUnit</code> just in case</p>

<pre><code>export class MeasurementUnit {
Id: number;
CreatedDate: Date;
ModifiedDate: Date;
Disabled: boolean;
DisabledDate: Date;
Name: string;
Description: string;

ParentId: number;

public constructor(item: Partial&lt;MeasurementUnit&gt;) {
    //item.EstablishedDate = new DatePipe('en-US').transform(item.EstablishedDate, ""yyyy-MM-dd"");

    Object.assign(this, item);
}
}
</code></pre>
","2501497","","4694994","","2018-08-14 18:40:12","2018-08-14 18:40:12","Converting rxjs 5 map to rxjs 6 map","<javascript><angular><rxjs><angular6><rxjs6>","1","8","","","","CC BY-SA 4.0"
"51848778","1","","","2018-08-14 19:46:11","","0","97","<p>From my backend service, I am sending a <code>post</code> message</p>

<pre><code>return this.http.post(/*this.API_URL +*/this.NEW_QUESTION_URL,body,httpOptions)
      .map(response =&gt; { 
          return result; //map isn't required
        }

      })
      .catch(this.handleError); //error handler if Observable fails
</code></pre>

<p>In <code>handleError</code>, I am throwing an error</p>

<pre><code>private handleError (error: HttpErrorResponse) {
console.error('WebToBackendInterfaceService::handleError', error);//I SEE THIS PRINT
        let result:ServerResponseAPI = {result:""error"", ""additional-info"":error.message};
    return throwError(result);     
  }
</code></pre>

<p>My question - I suppose <code>throwError</code> returns an <code>Observable</code>. How and where do I subscribe to this Observable so that I can handle the error?</p>

<p>I suppose the <code>Observable</code> returned by <code>post</code> is different from the one from <code>throwError</code>. I have subscribed to the <code>Observable</code> of <code>post</code> already.</p>

<p>I also have a custom interceptor.</p>

<pre><code>return next.handle(cloned)
 .pipe(tap((ev: HttpEvent&lt;any&gt;) =&gt; { 
        console.log(""got an event"",ev);
        if (ev.type === HttpEventType.Response) {
          console.log('event of type Http response');
        }  else if (ev.type === HttpEventType.Sent) {
          console.log("" event of type httpsent"");
        } else if(ev.type === HttpEventType.DownloadProgress){
          console.log(""event of type download progress"");
        } else if (ev.type === HttpEventType.UploadProgress) {
          console.log(""event of type upload progress"");
        } else if (ev.type === HttpEventType.User) {
          console.log(""event of type user progress"");
        }else if (ev.type === HttpEventType.ResponseHeader) {
          console.log(""event of type response header"")
        } else {
          console.log(""don't know type"",ev.type);
        }
      })
      ,catchError(errorResponse =&gt; {
          console.log(""caught error from server"",errorResponse) //I SEE THIS PRINT
          return observableThrowError(errorResponse);
      }));
    }
</code></pre>
","6703783","","6703783","","2018-08-15 05:22:16","2018-08-15 06:36:55","how to handle error thrown by rxjs post","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"51849873","1","","","2018-08-14 21:16:27","","1","1110","<p>I have 2 observables like this:</p>

<pre><code>return this.loaded$.pipe(
            switchMap((isLoaded: boolean) =&gt; {
                if (!isLoaded) {
                 return this.userId$;
                }
            }),
            tap((userId: string) =&gt; {
                this.store.dispatch(new MyPostsList(userId))
            }),
            filter((value: any) =&gt; value),
            take(1)
        )
</code></pre>

<p>I want to have access to <code>isLoaded</code> var from $loaded stream inside tap part how can I do it?
Is it some better way to do this?</p>
","6342729","","","","","2018-08-15 07:12:00","How to memorize previous value from stream RxJS","<rxjs><rxjs6><rxjs-lettable-operators>","1","1","","","","CC BY-SA 4.0"
"51854143","1","51870327","","2018-08-15 06:49:43","","0","853","<p>I have the following piece of code which works correctly.</p>

<pre><code>  public createData(data:Data):Observable&lt;any&gt;{
    console.log('contacting server at '+this.API_URL +this.NEW_DATA_URL +"" with data ""+data+ "" with httpOptions ""+httpOptions.withCredentials + "",""+httpOptions.headers );

let newData = new Data(data)    
    let body = JSON.stringify(newQuestion); 
//I WANT TO MOVE THE CODE BELOW INTO A FUNCTION BUT AM GETTING COMPILATION ERROR
    this.loaderService.show();
    return this.http.post(this.NEW_QUESTION_URL,body,httpOptions)
      .pipe(tap(response =&gt; { 
        let httpEvent = &lt;HttpEvent&lt;any&gt;&gt;response;
        if(httpEvent.type === HttpEventType.Response)
        {
          console.log('response from backend service:', response);

          return result;
        }
        else {
          console.log(""not an http response"")
          return response;
        }
      })
      ,catchError(this.handleError)
        ,finalize(()=&gt; this.loaderService.hide())); //error handler if Observable fails

  }
</code></pre>

<p>As I can reuse some part of the code, I thought to create a function but now I am getting compilation errors. I am unable to find out what is the mistake.</p>

<p>The new function is</p>

<pre><code>private sendMessage(url:string, body:any,httpOptions:any){
    this.loaderService.show();
    return this.http.post(url,body,httpOptions)
      .pipe(tap(response =&gt; { 

          let httpEvent = &lt;HttpEvent&lt;any&gt;&gt;response; //ERROR HERE - 'ArrayBuffer' cannot be converted to type 'HttpEvent&lt;any&gt;'.
          if(httpEvent.type === HttpEventType.Response)
          {
            console.log('response from backend service:', response);

            let result = &lt;HttpResponse&lt;any&gt;&gt;response;

            return result;
          }
          else {
            console.log(""not an http response"")
            return response;
          }
        })
        ,catchError(this.handleError)
        ,finalize(()=&gt; this.loaderService.hide())); //error handler if Observable fails
    }
</code></pre>

<p>ERROR is 
<code>ERROR in src/app/web-to-backend-interface.service.ts(264,27): error TS2352:</code> <code>Type 'ArrayBuffer' cannot be converted to type 'HttpEvent&lt;any&gt;'.</code>
<code>Type 'ArrayBuffer' is not comparable to type 'HttpUserEvent&lt;any&gt;'.</code>
<code>Property 'type' is missing in type 'ArrayBuffer'.</code></p>

<p><code>http.post</code> has several overloaded methods and one of them return Observable - angular.io/api/common/http/HttpClient#post. How do I make Angular use the overloaded version which returns <code>Observable&lt;T&gt;</code>? I changed the code and added <code>responseType:'json'</code> but that didnt work either</p>

<pre><code>const httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
  withCredentials: true, 
observe: 'response' as 'response', 
  responseType: 'json' 
};


let observable:Observable&lt;HttpEvent&lt;any&gt;&gt; = this.http.post(url,body,httpOptions)
    return observable.pipe(tap((httpEvent:HttpEvent&lt;any&gt;) =&gt; {....}
</code></pre>

<p>The errors I am seeing are</p>

<pre><code>ERROR in src/app/web-to-backend-interface.service.ts(80,71): error TS2345: Argument of type '{ headers: HttpHeaders; withCredentials: boolean; observe: ""response""; responseType: string; }' is not assignable to parameter of type '{ headers?: HttpHeaders | { [header: string]: string | string[]; }; observe?: ""body""; params?: Ht...'.
  Types of property 'observe' are incompatible.
    Type '""response""' is not assignable to type '""body""'.
src/app/web-to-backend-interface.service.ts(111,52): error TS2345: Argument of type '{ headers: HttpHeaders; withCredentials: boolean; observe: ""response""; responseType: string; }' is not assignable to parameter of type '{ headers?: HttpHeaders | { [header: string]: string | string[]; }; observe?: ""body""; params?: Ht...'.
  Types of property 'observe' are incompatible.
    Type '""response""' is not assignable to type '""body""'.
src/app/web-to-backend-interface.service.ts(195,73): error TS2345: Argument of type '{ headers: HttpHeaders; withCredentials: boolean; observe: ""response""; responseType: string; }' is not assignable to parameter of type '{ headers?: HttpHeaders | { [header: string]: string | string[]; }; observe?: ""body""; params?: Ht...'.
src/app/web-to-backend-interface.service.ts(215,72): error TS2345: Argument of type '{ headers: HttpHeaders; withCredentials: boolean; observe: ""response""; responseType: string; }' is not assignable to parameter of type '{ headers?: HttpHeaders | { [header: string]: string | string[]; }; observe?: ""body""; params?: Ht...'.
src/app/web-to-backend-interface.service.ts(250,54): error TS2345: Argument of type '{ headers: HttpHeaders; withCredentials: boolean; observe: ""response""; responseType: string; }' is not assignable to parameter of type '{ headers?: HttpHeaders | { [header: string]: string | string[]; }; observe?: ""body""; params?: Ht...'.
src/app/web-to-backend-interface.service.ts(290,9): error TS2322: Type 'Observable&lt;ArrayBuffer&gt;' is not assignable to type 'Observable&lt;HttpEvent&lt;any&gt;&gt;'.
  Type 'ArrayBuffer' is not assignable to type 'HttpEvent&lt;any&gt;'.
    Type 'ArrayBuffer' is not assignable to type 'HttpUserEvent&lt;any&gt;'.
      Property 'type' is missing in type 'ArrayBuffer'.
src/app/web-to-backend-interface.service.ts(296,59): error TS2552: Cannot find name 'response'. Did you mean 'Response'?
</code></pre>

<p>Why does making a separate function of a working code makes it non-compilable? What is my mistake?</p>
","6703783","","6703783","","2018-08-16 05:03:39","2018-08-16 05:45:54","unable to compile a code when converted into a function","<typescript><angular6><rxjs6>","2","3","0","","","CC BY-SA 4.0"
"51862609","1","","","2018-08-15 16:23:51","","0","68","<p>Using NG6 Rxjs to return some data via http.  I then split the returned data into two Observables.  Works great but I need to sort the data first, by a value(s) in a nested array.  I am able to sort the array after an event fires in the view, but not working when the page loads.</p>

<p>This code sorts by a value in the outer array:</p>

<pre><code>return this.http
  .get(this.apiUrl + 'PatchGroups/ForApp/' + appId)
  .pipe(
    map((data: Array&lt;any&gt;) =&gt; {
    return {
      ungrouped: data.filter(d =&gt; d.id &lt; 0),
      grouped: data.filter(d =&gt; d.id &gt; 0).sort((a, b) =&gt; a.name &lt; b.name ? -1 : 1)
    };
    }),
   catchError(this.handleError)
  );
</code></pre>

<p>Tried this to sort by the nested value but no good:</p>

<pre><code>return this.http
  .get(this.apiUrl + 'PatchGroups/ForApp/' + appId)
  .pipe(
    map((data: Array&lt;any&gt;) =&gt; {
    return {
      ungrouped: data.sort((a, b) =&gt; a.server.name &lt; b.server.name ? -1 : 1).filter(d =&gt; d.id &lt; 0),
      grouped: data.filter(d =&gt; d.id &gt; 0).sort((a, b) =&gt; a.name &lt; b.name ? -1 : 1)
    };
    }),
   catchError(this.handleError)
  );
</code></pre>

<p>It seems dirty to sort each Observable. Can't I sort the data before passing to each Observable?</p>

<p>From my component:</p>

<pre><code>this.appsApiService.getPatchGroups(appReconId)
  .subscribe(pg =&gt; {
    this.ungrouped_patchGroups = pg.ungrouped;
    this.grouped_patchGroups = pg.grouped;
  }
);
</code></pre>
","9333900","","9333900","","2018-08-15 17:11:05","2018-08-15 17:11:05","Sort by value in nested array before Map","<angular><typescript><angular6><rxjs6>","0","5","","","","CC BY-SA 4.0"
"51863041","1","51918027","","2018-08-15 16:51:05","","1","232","<p>I have an observable get data from stream each time at size 512 each next I have to break it up to 200 char at other observable and keep [12] char in other buffer to concatenate with next block, I solve it by using new subject and for loop, I believe there maybe a better, more pretty solution.</p>

<p>received Observable ----------------------------------------     </p>

<ul>
<li>1st next   [512] -------> <strong>[112]</strong>  [200] [200] -------> [200] [200]</li>
<li>2nd next [512][<strong>112</strong>] --> [24][200][200] [88+<strong>112</strong>]  --> [200] [200]</li>
<li>3rd next [512][24] --> [136] [200] [76+124] .....</li>
<li><p>nth iteration  [512][194] --> [106][200][200][106+94] --> [200][200][200]</p></li>
<li><p>n+1th [512][6].......</p></li>
</ul>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>maxValueSize = 200
this._sreamRecord$.subscribe(
    {
        next: (val) =&gt; {
            const bufferToSend: Buffer = Buffer.concat([completationBuffer, val])
            for (let i = 0; i &lt; bufferToSend.length; i += maxValueSize) {
                if (bufferToSend.length - i &gt; maxValueSize) {
                    bufferStreamer.next(bufferToSend.slice(i, i + maxValueSize))
                } else {
                    completationBuffer = bufferToSend.slice(i, i + maxValueSize)
                }
            }
        },
        complete() {
            if (completationBuffer.length) {
                bufferStreamer.next(completationBuffer)
            }
            bufferStreamer.complete()
        }
    })</code></pre>
</div>
</div>
</p>
","9198878","","9198878","","2018-08-15 17:20:22","2018-08-28 13:09:29","break up buffer into size rxjs","<javascript><rxjs><observable><rxjs6>","1","3","","","","CC BY-SA 4.0"
"51864945","1","","","2018-08-15 19:09:01","","3","1501","<pre><code>private pollSubscriptions: Subscription;
private defaultPollTime: number = 2000;
constructor(
    private http: HttpClient,
) {
    this.pollSubscriptions = new Subscription();
}

pollRequest&lt;T&gt;(
    url: string,
    updateStatus: any,
    pollWhileCondition: Function,
    onPollingSuccessCallback?: Function,
    timer = this.defaultPollTime
) {
    this.pollSubscriptions.add(timer(0, 2000).pipe(
        switchMap(() =&gt; this.http.get&lt;T&gt;(url).pipe(
            catchError((error: any) =&gt; empty()))),
        tap(updateStatus),
        takeWhile(data =&gt; pollWhileCondition(data)))
        .subscribe());
}

ngOnDestroy(): void {
    this.pollSubscriptions.unsubscribe();
}
</code></pre>

<p>I am able to poll for multiple urls simultaneously. But how can I enhance current functionality so that I can meet the following requirements:</p>

<ol>
<li>If a url which is polled gets failed then how can we retry that poll url with a delay of 3(n) secs for 3 times?</li>
<li>How can we add distinct operator on the urls being polled?</li>
</ol>

<p><strong><em>STILL NO SOLUTION</em></strong></p>

<p>Thanks in advance</p>
","5706900","","5706900","","2018-08-22 17:44:38","2018-09-06 18:57:34","Retrying a polling service with n seconds delay","<javascript><angular><rxjs><reactive-programming><rxjs6>","3","1","1","","","CC BY-SA 4.0"
"51866699","1","51880854","","2018-08-15 21:28:13","","1","617","<p>I'm trying to figure out how the queueScheduler works in rxjs (version 6.2.2).
I'm running an express server and what I want to do is accept multiple requests, but the function <code>processMetricRequest2</code> should only process one item at at time, but the code below...when I access <code>/test1</code> twice in a row, it will call <code>processMetricRequest2</code> even though it hasn't finished (the <code>webMetrics</code> function takes a few seconds).
Any ideas on what I'm doing wrong? thanks!</p>

<pre><code>router.get('/test1', function(req, res, next) {
  let fn = partial(processMetricRequest2, req.query.input);
  queueScheduler.schedule(fn);
  res.render('index', { id: 1, current: {url: req.query.input}});
});
async function processMetricRequest2(url, arg) {
  console.log('--processing:', url);
  let result = await webMetrics(url);
  console.log('--FINISHED: ', url);
  return result;
}
</code></pre>
","4709703","","3024975","","2018-08-16 22:15:30","2018-08-16 22:15:30","How to create a queue using RxJS","<rxjs><queue><observable><rxjs6>","1","3","","","","CC BY-SA 4.0"
"51868852","1","51869113","","2018-08-16 02:33:59","","0","350","<p>How do we convert:</p>

<pre><code>Rx.Observable.timer(3000).mapTo({ id: 1 }) 
</code></pre>

<p>to RxJS 6?</p>

<p>For example if we:</p>

<pre><code> import { Observable, timer } from 'rxjs';
</code></pre>

<p>We still get:</p>

<blockquote>
  <p>[ts] Property 'timer' does not exist on type 'typeof Observable'.</p>
</blockquote>

<p>All in all I'm trying to get this example <a href=""https://netbasal.com/rxjs-six-operators-that-you-must-know-5ed3b6e238a0"" rel=""nofollow noreferrer"">(From this tutorial)</a> to work:</p>

<pre><code>    // Simulate HTTP requests 
    const getPostOne$ = Rx.Observable.timer(3000).mapTo({id: 1});
    const getPostTwo$ = Rx.Observable.timer(1000).mapTo({id: 2});

    Rx.Observable.concat(getPostOne$, getPostTwo$).subscribe(res =&gt; console.log(res));
</code></pre>
","1684269","","1684269","","2018-08-16 03:07:19","2018-08-16 03:14:44","Converting RxJS 5 Rx.Observable.timer(3000).mapTo({ id: 1 }) to RxJS 6?","<javascript><typescript><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51871190","1","51872653","","2018-08-16 06:53:22","","1","1672","<p>I am really new to both Angular and RxJS. I am trying to create an Angular component which allows different objects to share a tree-structured data set.</p>

<p>Here's my scenario in an imaginary and simplified way - an Angular component to post an entire company structure to the server. This structure is a composite of multiple ""StuffDto"" object, which references each other as their manager. And all stuffs share a same company department structure map.</p>

<p>The multi-level structure map is like:</p>

<ul>
<li>Marketing Dept

<ul>
<li>Sales Dept

<ul>
<li>In-store Sales Team</li>
<li>On-site Sales Team</li>
</ul></li>
<li>Advertisement Dept

<ul>
<li>Planner Team</li>
<li>Designer Team</li>
</ul></li>
</ul></li>
<li>Manufacturing Dept

<ul>
<li>R&amp;D Dept

<ul>
<li>Engineer Team</li>
<li>Researcher Team</li>
</ul></li>
<li>QA Dept

<ul>
<li>Inspector Team</li>
<li>Assurance Team</li>
</ul></li>
</ul></li>
</ul>

<p>Here's my <code>StaffDto</code> class which will be posted to the server directly upon submission.</p>

<pre><code>export class StaffDto {
    id: string;
    name: string;
    assignedDept?: string;
    managerId?: string;
}
</code></pre>

<p>Here's my <code>Stuff</code> object which will be passed around my Angular applications.</p>

<pre><code>export class Stuff {
    data: StuffDto;
    _manager: Stuff;

    get manager(): Stuff {
        return this._manager;
    }

    set manager(manager: Stuff) {
        this._manager = manager;
        this.data.managerId = manager.data.id;
    }
}
</code></pre>

<p>This will work in some straightforward scenarios, But not all of them. </p>

<p>If I create Peter and Tom, then set Peter to be Tom's manager. Here's what the 2 <code>StuffDto</code> objects look like.</p>

<pre><code>{ id: abc01,
  name: 'Peter',
  assignedDept: 'Marketing Dept',
  managerId: null }
{ id: abc02,
  name: 'Tom',
  assignedDept: 'Sales Dept',
  managerId: 'abc01' }
</code></pre>

<p>If I change Peter's <code>id</code> from ""abc01"" to ""abc01a"", I would expect tom's <code>ManagerId</code> to be changed as well. Also if I change Peter's <code>assignedDept</code> form ""Marketing Dept"" to ""R&amp;D Dept"", since there will not be ""Sales Dept"" underneath Peter's department for Tom to be assigned, Tom's <code>assignedDept</code> should be cleared to null.</p>

<p>I am not quite sure this could be done by subscription of RxJS. I've tried to make <code>_manager</code> a <code>Subject</code> and then subscribe to it. But the function will only be called whenever a new manager is assigned, not with the manager's property change. </p>

<p>I am wondering whether there's a way to do it without changing too much of the code. As the <code>StuffDto</code> will be passed to the server I won't be able to change that.</p>
","8816835","","","","","2018-08-16 08:22:50","How to subscribe to the property change of an object referenced within another object in rxjs","<angular><typescript><rxjs><angular6><rxjs6>","1","4","","","","CC BY-SA 4.0"
"51876752","1","51876857","","2018-08-16 12:10:08","","3","875","<p>Consider this code, from an Angular 6 component:</p>
<pre><code>class AppComponent  {
  subject = new Subject&lt;any&gt;();
  one = this.subject.pipe(share(), tap(e =&gt; log('one emits')));
  two = this.one.pipe(tap(e =&gt; log('two emits')));
  three = this.one.pipe(delay(500), tap(e =&gt; log('three emits')));

  ngOnInit() {
    this.two.subscribe(e =&gt; log('two received'));
    this.three.subscribe(e =&gt; log('three received'));    
    this.subject.next();
  }  
}
</code></pre>
<p>When <code>ngOnInit</code> executes, this is what gets logged:</p>
<blockquote>
<p>one emits</p>
<p>two emits</p>
<p>two received</p>
<p>one emits</p>
<p>three emits</p>
<p>three received</p>
</blockquote>
<p>I don't understand: why does <code>one</code> emit twice? Shouldn't the <code>share</code> operator in its pipe make <code>two</code> and <code>three</code> subscribe to the same shared source?</p>
<p><a href=""https://stackblitz.com/edit/angular-xoyvw6?file=src%2Fapp%2Fapp.component.ts"" rel=""nofollow noreferrer"">Source on Stackblitz</a></p>
","3977061","","-1","","2020-06-20 09:12:55","2018-08-16 12:15:07","RxJS Observables: why does callback fire twice?","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51876882","1","52157317","","2018-08-16 12:17:06","","8","3391","<p>For rxjs, can I provide an initial value when using <code>distinctUntilChanged</code>? It seems that the equals check is skipped entirely when no previous value was received. I'd like to not emit anything when the first value it receives is the initial value.</p>

<hr>

<p><strong>Use case</strong></p>

<p>In my case I'm working with angular, I'm working with reactive forms and subscribing to its value changes. Since it's an input field I have a typical pipe setup:</p>

<ul>
<li><code>debounceTime(350)</code></li>
<li><code>distinctUntilChanged()</code></li>
</ul>

<p>When the user changes the initial field from empty to something and then empty again within the debounce time, the event is triggered anyway which should not happen.</p>

<hr>

<p><strong>What I've tried</strong></p>

<ul>
<li>Supply a custom equals method in <code>distinctUntilChanged</code>

<ul>
<li>Does not work since the pipe is skipped entirely when encoutered for the first time</li>
</ul></li>
<li>Force a <code>next</code> on the underlying subject with the default value

<ul>
<li>This still emits a value after the debounce time which I'd rather avoid</li>
</ul></li>
</ul>
","2158015","","","","","2018-09-05 16:26:50","distinctUntilChanged set initial value","<observable><distinct-values><rxjs6>","2","2","","","","CC BY-SA 4.0"
"51878886","1","51879655","","2018-08-16 13:59:07","","0","47","<p>If I want to pass returned value from the first stream to second I use <code>switchMap</code> . </p>

<p>What should I use, if I want to use param from the first stream in second, but I don't want to do 2 subscribe?</p>

<pre><code>this.firstStream$.subscribe(first =&gt; {
  this.secondStream$.subscribe(second =&gt; {
  // here I want to use first and second.
}
</code></pre>
","6370870","","","","","2018-08-16 14:38:33","How to use param from one stream in another with RX.js?","<angular><rxjs><rxjs6><switchmap>","1","2","","","","CC BY-SA 4.0"
"51880242","1","","","2018-08-16 15:08:01","","4","1271","<p>I am having one stream which carries the data from the API response and has another stream which emits the values which needs to be filtered from the source stream.</p>

<pre><code>@Injectable({
    providedIn: 'root'
})
export class SmpService {
    private _smp$ = new ReplaySubject(1);
    private _deleteSubject = new BehaviorSubject(null);

    constructor(private http: HttpClient) {
        const allSmp$ = this.loadSmp().pipe(map(list =&gt; list.map(item =&gt; item.id)));
        const delete$ = this._deleteSubject.pipe(map(value =&gt; this.filterSmp(value)));

        allSmp$
            .pipe(
                combineLatest(delete$, (notifications, xf) =&gt; {
                    return xf(notifications);
                }),
                tap(x =&gt; console.log('console ', x))
            )
            .subscribe(this._smp$);
    }

    loadSmp(): Observable&lt;any&gt; {
        const contextPath = 'some_url';
        const url = this.uriPrefix + contextPath;
        return this.http.get(url).pipe(map((response: any) =&gt; response.notifications || []));
    }

    filterSmp(value) {
        return notifications =&gt; notifications.filter(notification =&gt; value !== notification);
    }

    deleteSmp(subscribeItem) {
        this._deleteSubject.next(subscribeItem);
    }

    getSmp(): Observable&lt;any&gt; {
        return this._smp$.asObservable();
    }
}
</code></pre>

<p>Filtering is working fine. But on page load, I am not able to get the initial API response rendered on the page. I only receive that when I trigger the deleteStream via some action.</p>

<p>Is there any way I can get the initial data even though deleteStream is not triggered?  </p>
","3159935","","3159935","","2018-08-24 07:13:26","2018-08-24 07:13:26","RxJS : Filter one observable using another observable","<angular><observable><reactive-programming><angular6><rxjs6>","3","3","1","","","CC BY-SA 4.0"
"51880937","1","","","2018-08-16 15:48:44","","1","63","<p>I intend to write unit test for the following epic</p>

<pre><code>// Actions
const actionCreator = actionCreatorFactory('PARENT_DIRECTORY');
export const fetchPage = actionCreator.async&lt;Page, ParentPage&gt;('FETCH_PAGE');

export const fetchParentDirectoryEpic: Epic = action$ =&gt;
  action$.pipe(
    filter(fetchPage.started.match),
    mergeMap((action) =&gt; {
      return getDirectoryPage(action.payload).pipe(
        map(response =&gt; fetchPage.done({ params: action.payload, result: response.response })),
        catchError(error =&gt; of(fetchPage.failed({ params: action.payload, error: error })))
      );
    })
  );
</code></pre>

<p>I mocked the getDirectoryPage like below -</p>

<pre><code>import { AjaxResponse, AjaxError } from 'rxjs/ajax';
import { Observable, of } from 'rxjs';

export function getDirectoryPage(page: any): Observable&lt;AjaxResponse&gt; {
  switch (page.index) {
    case 0:
      return Observable.create({'data': [], page: 0, pages: 1});
    default:
      return Observable.create(observer =&gt; {
        return new AjaxError('Something bad happened!', null, null);
      });
  }
}
</code></pre>

<p>and following is how my unit test looks like -</p>

<pre><code>describe('fetchParentDirectoryEpic Epic', () =&gt; {
    it('dispatches the correct actions when it is successful', async (done) =&gt; {
        const expectedOutputAction = outputAction;

        fetchParentDirectoryEpic(inputAction, initialState, null)
            .subscribe(actualOutputAction =&gt; {
                expect(actualOutputAction).toBe(expectedOutputAction)
                done()
            }
        );
    });
});
</code></pre>

<p>Issue is that the call to <code>fetchParentDirectoryEpic(inputAction, initialState, null)</code> results in an Observable which doesn't have subscribe method. As I understand, the method is available with <code>ActionObservable</code> but I am unable to create its instance using a payload.</p>
","1323517","","1323517","","2018-08-17 12:34:05","2018-08-17 12:34:05","Unable to test redux-observable epic","<javascript><reactjs><jestjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51904407","1","","","2018-08-18 01:00:38","","3","1097","<p>I am creating an Angular Http Retry Interceptor.  When I have retries of 1, my code looks like this:</p>

<pre><code>  return next.handle(req).pipe(
    retryWhen((error) =&gt; {
      return error.pipe(
        delay(1000),
        take(1),
        concatMap((err) =&gt; {
          return _throw({ ...err, message: `Sorry, there was an error (after 1 retry)` });
        })
      );
    })
  );
</code></pre>

<p>This seems to work.  I can throw with the original error.</p>

<p>Now, when the retries is zero, this doesn't work.  I think that's because we are doing take(0).  However, the concat operator will work:</p>

<pre><code>  return next.handle(req).pipe(
    retryWhen((error) =&gt; {
      return error.pipe(
        delay(1000),
        take(0),
        concat(_throw({ message: `Sorry, there was an error (after 0 retries)` }))
      );
    })
  );
</code></pre>

<p>But the problem is that I can't get the original error.  What other operators can I use in my zero retry scenario to get/throw the original error?</p>
","4611304","","","","","2018-08-18 07:25:40","How to throw the original error when using rxjs retryWhen with zero retries","<angular><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"51905697","1","51905723","","2018-08-18 05:51:16","","2","5520","<p>I'm trying to use <code>map</code> operator from RxJS but it throws an error saying</p>

<blockquote>
  <p>Property 'map' does not exist on type 'Observable'.</p>
</blockquote>

<p>Here is the code</p>

<pre class=""lang-js prettyprint-override""><code>    import { Injectable } from ""@angular/core"";
    import { Http } from ""@angular/http"";
    import ""rxjs/add/operator/map"";
    @Injectable()

    export class DataService {
     constructor(public http: Http) {}

     getData() {
       return this.http
        .get(""https://jsonplaceholder.typicode.com/users"")
        .map(res =&gt; res.json());
      }
    }
</code></pre>
","9360234","","9360234","","2019-11-17 17:06:09","2019-11-17 17:06:09","RsJX 'Map' operator is not working in Angular 6","<angular><typescript><angular6><rxjs6>","3","2","","","","CC BY-SA 4.0"
"51919198","1","51921465","","2018-08-19 15:31:55","","0","389","<p>In my Angular 6 project i had a component with 3 range inputs and 1 checkbox.
With the checkbox I can link the value of 2 of the 3 range inputs so that if one is changed the other one change accordingly.
When the checkbox is unchecked the second one isn't updated.
When one of range inputs are changed, the values of all 3 controls have to be send to an API.</p>

<p>So far I was successfull.
The problem is that when I change the range input there is a burst of post requests to the API.
I want to reduce the burst of requests.</p>

<p>In the template I have the following controls:</p>

<pre><code>&lt;input class=""my-custom-range"" type=""range"" [min]=""-1 * navControl.engine1.power.max"" [max]=""navControl.engine1.power.max"" [(ngModel)]=""controls.throttle1"" (ngModelChange)=""onChangeThrothel1($event)"" [disabled]=""!navControl.engine1.isOnline"" &gt;
&lt;input class=""my-custom-range"" type=""range"" [min]=""-1 * navControl.engine2.power.max"" [max]=""navControl.engine2.power.max"" [(ngModel)]=""controls.throttle2"" (ngModelChange)=""onChangeThrothel2($event)"" [disabled]=""!navControl.engine2.isOnline"" &gt;
&lt;mat-slider min=""-80"" max=""80"" step=""8"" thumbLabel=""true"" vertical=""true"" [(ngModel)]=""controls.mainHelm"" (ngModelChange)=""changeMainHelm($event)"" [disabled]=""!navControl.engine1.isOnline"" style=""margin-top: 4em; height: 100%""&gt;&lt;/mat-slider&gt;
&lt;mat-checkbox [(ngModel)]=""syncEngines""&gt;Motor Sync&lt;/mat-checkbox&gt;
</code></pre>

<p>I have some interfaces like this:</p>

<pre><code>export interface INavigationRequest {
  engine1: IEngineRequest;
  engine2: IEngineRequest;
}
export interface IEngineRequest {
  id: number;
  requestedPower: number;
  isForwardPropultion: boolean;
  requestedAngle: number;
  correctionPower: number;
  correctionAngle: number;
}
</code></pre>

<p>In the server.service.ts I have the following:</p>

<pre><code>updateEngines(params: INavigationRequest): Observable&lt;INavigationResponse&gt; {
  console.log('update engines', params);
  return this.http.post&lt;INavigationResponse&gt;(`${this.baseUrl}/api/navigation/post/`, params);
}
</code></pre>

<p>In the component.ts I have the following:</p>

<pre><code>public onChangeThrothel1(value): void {
  if (value &amp;&amp; this.syncEngines) {
    this.controls.throttle2 = value;
  }
  console.log('1', this.controls.throttle1);
  console.log('2', this.controls.throttle2);
  this.updateNavControl();
}

public onChangeThrothel2(value): void {
  if (value &amp;&amp; this.syncEngines) {
    this.controls.throttle1 = value;
  }
  console.log('1', this.controls.throttle1);
  console.log('2', this.controls.throttle2);
  this.updateNavControl();
}

public changeMainHelm(value): void {
  if (value) {
    this.controls.helm = value;
    this.updateNavControl();
  }
}

public updateNavControl(): void {
  let params: INavigationRequest = {
    engine1: {
      id: this.navControl.engine1.id,
      isForwardPropultion: this.navControl.engine1.isForwardPropultion,
      requestedPower: this.controls.throttle1,
      requestedAngle: this.controls.helm,
      correctionPower: this.navControl.engine1.power.correction,
      correctionAngle: this.navControl.engine1.angle.correction
    },
    engine2: {
      id: this.navControl.engine2.id,
      isForwardPropultion: this.navControl.engine2.isForwardPropultion,
      requestedPower: this.controls.throttle2,
      requestedAngle: this.controls.helm,
      correctionPower: this.navControl.engine2.power.correction,
      correctionAngle: this.navControl.engine2.angle.correction
    }
  };
  console.log(params);
  this.server.updateEngines(params).pipe(debounceTime(500), distinctUntilChanged()).subscribe(result =&gt; {
    console.log('HttpClient [POST] /api/navigation/post', result);
    this.procesEngines(result);
  }, error =&gt; {
    console.log(`There was an issue. ${error._body}.`);
  });
}
</code></pre>

<p>The debounceTime isn't working and every change is submitted.</p>

<p>I think the placement of the debounce time is not in the right place.
Maybe my approach is completely wrong.</p>
","2394251","","3024975","","2018-08-19 23:22:25","2018-08-19 23:22:25","Post values from multiple range inputs on change in Angular 6 with debounceTime","<rxjs><angular6><rxjs6>","1","0","0","","","CC BY-SA 4.0"
"51919555","1","","","2018-08-19 16:12:45","","1","7458","<p>Here is the testbed setup. Mocking and providing everything needed:</p>

<pre><code> let component: PageUploadContainer;
  let store;
  let route;
  let fixture: ComponentFixture&lt;PageUploadContainer&gt;;
  const sanitizer = jasmine.createSpyObj('sanitizer', ['bypassSecurityTrustResourceUrl']);
  sanitizer.bypassSecurityTrustResourceUrl.and.callFake(url =&gt; url);
  const mockTranslate = {
    instant: label =&gt; label,
  };

  beforeEach(() =&gt; {
    store = createMockStore&lt;AppState&gt;(reducers);
    route = new MockActivatedRoute();
  });

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [translationModule],
      declarations: [
        PageUploadContainer,
        MockTranslatePipe,
        MockTranslateCutPipe,
      ],
      schemas: [NO_ERRORS_SCHEMA],
      providers: [
        FormBuilder,
        { provide: DomSanitizer, useValue: sanitizer },
        { provide: Store, useValue: store },
        { provide: ActivatedRoute, useValue: route },
        { provide: TranslateService, useFactory: () =&gt; mockTranslate },
      ],
    }).compileComponents();
  });

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(PageUploadContainer);
    component = fixture.componentInstance;
    component.mappingTriggered$ = Observable.of(false);
  });
</code></pre>

<p>I have the following code, I set up me tests with testBed:</p>

<pre><code>onGoTo(uploadStep: string) {
    if (uploadStep === NAVIGATION.DEFAULT) {
      this.store.dispatch(new ReplaceSelectedCompanies([]));
      this.companyIds$.filter(isEmpty)
        .take(1)
        .subscribe(() =&gt; {
          this.store.dispatch(new Navigate({ direction: uploadStep}));
        });
    } else {
      this.store.dispatch(new Navigate({ direction: uploadStep}));
    }
  }
</code></pre>

<p>And my test. This test fails due to <code>new Navigate({ direction: uploadStep})</code> was not called due to it's asynchronous nature</p>

<pre><code>it('if navigation default and companyIds empty should call navigate', () =&gt; {
       component.companyIds$ = Observable.of(['123', '234']);
      component.onGoTo(NAVIGATION.DEFAULT);
      expect(store.dispatch).toHaveBeenCalledWith(new ReplaceSelectedCompanies([]));
      expect(store.dispatch).toHaveBeenCalledWith(new Navigate({ direction: NAVIGATION.DEFAULT }));
    });
</code></pre>

<p>Can you help me how to test such methods?</p>
","7109755","","7109755","","2018-08-19 22:22:08","2018-08-20 00:45:09","Testing Observable with subscribe in a function","<angular><jasmine><rxjs><angular5><rxjs6>","2","2","1","","","CC BY-SA 4.0"
"51920997","1","51921313","","2018-08-19 19:12:19","","0","527","<p>shareReplay isn't working like I would expect. From the documentation I would expect the following bits of code to be equivalent. </p>

<pre><code>@Injectable( {
    providedIn: 'root'
} )
export class CartService {

    private list: InventoryItem[] = [];
    cart: Observable&lt;ReadonlyArray&lt;Readonly&lt;InventoryItem&gt;&gt;&gt; = of( this.list ).pipe(
        shareReplay( 1 )
    );

    constructor() {}

    addItem( item: InventoryItem ) {
        this.list.push( item );
    }
}
</code></pre>

<p>and </p>

<pre><code>@Injectable( {
    providedIn: 'root'
} )
export class CartService {

    private list: InventoryItem[] = [];
    private subject = new ReplaySubject&lt;ReadonlyArray&lt;Readonly&lt;InventoryItem&gt;&gt;&gt;(1);
    cart: Observable&lt;ReadonlyArray&lt;Readonly&lt;InventoryItem&gt;&gt;&gt; = this.subject.asObservable();

    constructor() {}

    addItem( item: InventoryItem ) {
        this.list.push( item );
        this.subject.next(this.list);
    }
}
</code></pre>

<p>Yet only the second version works where all subscribers receive the events when <code>addItem(...)</code> is called.</p>

<p>The first example only works in one instance in my root component, but not in any other component where I use a similar syntax. </p>

<pre><code>[matBadge]=""(cartService.cart | async)?.length""
</code></pre>

<p>I've verified that only one instance of the service is being created, can anyone give me some insight on what's going on in the first piece of code?</p>
","1750067","","1750067","","2018-08-19 20:05:16","2018-08-19 20:05:16","Observable of pipe shareReplay vs. ReplaySubject.observableOf","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51930761","1","51938136","","2018-08-20 12:26:52","","1","233","<p>I have an Observable and when I subscribe it I want:</p>

<ul>
<li>if it's is executing, return the result of the current execution</li>
<li>if not, re/execute the Observable.</li>
</ul>

<p>For example:</p>

<p>I have a <code>wait</code> function. This function wait 1 seconds and return the current <code>time()</code></p>

<pre><code>function wait(): Observable&lt;number&gt; {
  return new Observable&lt;number&gt;((observer) =&gt; {
    setTimeout(() =&gt; {
      observer.next((new Date).getTime());
      observer.complete();
    }, 1000);
  });
}
</code></pre>

<p>Now, I have a code that call this <code>wait</code> function every 0.4 seconds.</p>

<ul>
<li>The first call to <code>wait</code> (0.4 seconds) will wait 1 second and return the current time</li>
<li>The second call to <code>wait</code> (0.8 seconds), because there is an execution of <code>wait</code>, will return the same observable of the first point and the same result</li>
<li>The third call to <code>wait</code> (1.2 seconds) will wait again 1 second because there is not an execution </li>
<li>Etc</li>
</ul>
","1581433","","3024975","","2018-08-21 07:29:06","2018-08-21 11:31:06","How to share an Observable when it's running and resubscribe when it's not","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51937152","1","51938520","","2018-08-20 19:14:29","","3","1623","<p><strong>Context</strong>: I'm trying to use <code>redux-observable</code> with <code>rxjs v6</code> to trigger multiple actions after fetching a resource.</p>

<p><strong>Problem</strong>: I can trigger a single action after fetching the resource no problem; but my attempt to trigger multiple actions has me stumped. Specifically, my attempt shown below to use rxjs <code>merge</code> to trigger multiple actions seems so standard and close to documented examples (<a href=""https://www.learnrxjs.io/operators/combination/merge.html"" rel=""nofollow noreferrer"">see e.g. here</a>) that I can't understand where I'm going wrong. Here is a breakdown of my code with typescript types indicated in comments; I've simplified things for the sake of problem clarity:</p>

<pre><code>import { from } from ""rxjs""; 
import { merge, mergeMap, map } from ""rxjs/operators"";
import { AnyAction } from ""redux"";

... //Setup related to rxjs-observable epics

function myEpic(
    action$: Observable&lt;AnyAction&gt;,
    state$: any,
    {fetchPromisedStrings}: any
) {
    return action$.pipe(
        ofType('MY_ACTION'),
        mergeMap(
            action =&gt; 
{
    const demoAction1: AnyAction = {type:'FOO1', payload:'BAR1'};
    const demoAction2: AnyAction = {type:'FOO2', payload:'BAR2'};

    const w = from(fetchPromisedStrings())     //const w: Observable&lt;string[]&gt;
    const x = w.pipe( map(() =&gt; demoAction1)); //const x: Observable&lt;AnyAction&gt; 
    const y = w.pipe( map(() =&gt; demoAction2)); //const y: Observable&lt;AnyAction&gt; 

    //My attempt to merge observables:
    const z = merge(x,y); // const z: OperatorFunction&lt;{}, {} | AnyAction&gt;

    // return x; // Works :)
    // return y; // Works :)
    return z;    // Doesn't work :(
}   
        )
    );
}    
</code></pre>

<p>This code gives me the following error when I try to <code>return z</code>:</p>

<pre><code>TypeError: You provided 'function (source) { return source.lift.call(_observable_merge__WEBPACK_IMPORTED_MODULE_0__[""merge""].apply(void 0, [source].concat(observables))); }' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable
</code></pre>

<p>So what's the problem here? I'd expect <code>merge</code> in the above code to take the two <code>Observable&lt;AnyAction&gt;</code> types and return a single <code>Observable&lt;AnyAction&gt;</code> type (or some more general type that's compatible with <code>Observable&lt;AnyAction&gt;</code>, which my epic needs in order to function correctly). Instead, I get some opaque type called <code>OperatorFunction&lt;{}, {} | AnyAction&gt;</code> that, evidently, isn't compatible with <code>Observable&lt;AnyAction&gt;</code>. Could someone please unmuddle my thinking here? Is <code>merge</code> not the operator I am supposed to use here, or is my entire <code>rxjs-v6</code> pattern wrong for the (seemingly) simple goal of triggering multiple actions after fetching a promised resource?</p>
","8620332","","","","","2018-08-20 21:09:07","Understanding merge in rxjs6 (and redux-observable specifically)","<merge><redux-observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"51948677","1","51962178","","2018-08-21 12:27:11","","9","7033","<p>I have a simple interceptor that handles requests and catches any http error using RXJS catchError. The second argument received in catchError is the caught observable. I want to, in some cases, return this error and let it propagate up to the error handler in the subscribe function. The problem is that returning th caught error causes an infinite loop (as seen in the example: <a href=""https://stackblitz.com/edit/angular-u4gakr"" rel=""noreferrer"">https://stackblitz.com/edit/angular-u4gakr</a>)</p>

<p>The intercept function in the interceptor where the catchError is stuck in a loop when reciving an HTTP error, like 404:</p>

<pre><code>return next.handle(request)
  .pipe(
    catchError((error, caught$) =&gt; {
      console.log('Returning caught observable'); 
      return caught$;
    })
  );
</code></pre>

<p>I have probably misunderstood something about the interceptor or RxJS catchError. Any suggestion?</p>
","1452165","","","","","2018-08-22 13:13:43","Returning caught error observable from catchError in HttpInterceptor causes error loop","<angular><rxjs><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"51951200","1","51951493","","2018-08-21 14:41:52","","7","6772","<p>I have a problem when I try to start my angular 6 project. I've got this error : </p>

<p>""TSError: ⨯ Unable to compile TypeScript:
git.version.ts(34,29): error TS2339: Property 'combineLatest' does not exist on type 'typeof Observable'.""</p>

<p>It worked well with Angular 5 but I updated RxJs (from 5 to 6) and now it doesn't work. </p>

<pre class=""lang-js prettyprint-override""><code>import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { Observable, combineLatest } from 'rxjs';


let exec = require('child_process').exec;

let tag = new Observable&lt;string&gt;(s =&gt; {
    exec('git describe --tags $(git rev-list --tags --max-count=1)',
        function (error: Error, stdout: Buffer, stderr: Buffer) {
            if (error !== null) {
                console.log('git error: ' + error + stderr);
            }
            s.next(stdout.toString().trim());
            s.complete();
        });
});



let revision = new Observable&lt;string&gt;(s =&gt; {
    exec('git rev-parse --short HEAD',
        function (error: Error, stdout: Buffer, stderr: Buffer) {
            if (error !== null) {
                console.log('git error: ' + error + stderr);
            }
            s.next(stdout.toString().trim());
            s.complete();
        });
});

Observable.combineLatest(tag, revision).subscribe(([tag, revision]) =&gt; {
        console.log(`version: '${tag}', revision: '${revision}'`);

        const content = '// this file is automatically generated\n' +
            `export const version = {version: '${tag}', revision: '${revision}'};`;

        writeFileSync(
            'src/environments/version.ts',
            content,
            {encoding: 'utf8'}
        );
    });
</code></pre>

<p>The command I launch : ""ts-node git.version.ts"" is to get the commit and the tag version I work with.</p>

<p>Thank you very much !</p>

<p>UPDATE : </p>

<pre><code>combineLatest(tag, revision).subscribe(([tag, revision]) =&gt; {
        console.log(`version: '${tag}', revision: '${revision}'`);

        const content = '// this file is automatically generated\n' +
            `export const version = {version: '${tag}', revision: '${revision}'};`;

        writeFileSync(
            'src/environments/version.ts',
            content,
            {encoding: 'utf8'}
        );
    });
</code></pre>

<p>I haven't any error about CombineLatest but I have an error from ts-node : </p>

<pre><code>function (exports, require, module, __filename, __dirname) { import { writeFileSync } from 'fs';
                                                              ^^^^^^

SyntaxError: Unexpected token import
</code></pre>

<p>Any idea ?</p>

<p>UPDATE 2 : To fix this error : </p>

<pre><code>""config"": ""ts-node -O '{\""module\"": \""commonjs\""}' git.version.ts"",
</code></pre>

<p>In package.json</p>
","7807547","","7807547","","2018-08-21 15:21:38","2018-08-24 12:02:32","error TS2339: Property 'combineLatest' does not exist on type 'typeof Observable'","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"51951642","1","51952147","","2018-08-21 15:05:24","","1","59","<p>I'm new to RxJS.</p>

<p>I have a promised base HTTP client. It has a <em>login()</em> method that fetches a token from the server and stores it internally to be used by other methods.</p>

<p>When token expires, server will respond with <strong>401</strong> HTTP error, in which case, I want to call <em>login()</em> again and retry the request. Also, retry for other types of errors.</p>

<p>I'm not sure how to model that in RxJS, I've got something working but I'm hoping there's a better way to do it.</p>

<p>(<em>this is inside a decorator that's applied to all auth requiring methods</em>, here <strong>wrappedFunc</strong>)</p>

<pre><code>        return interval(100)
            .pipe(
                startWith(0),
                switchMap(() =&gt; {
                    return wrappedFunc.apply(this, args)
                }),
                retryWhen(errors$ =&gt; errors$.pipe(
                    switchMap((error) =&gt; {
                        if (error.response.status === 401) {
                            return this.login()
                        } else {
                            return of(error)
                        }
                    }),
                    scan((attempts, currentError) =&gt; {
                        if (attempts &gt; 5) {
                            throw currentError
                        }
                        return attempts + 1
                    }, 0),
                )),
                first()
            )
</code></pre>

<p>What's the idiomatic way to do this kind of error handling in RxJS?</p>
","384980","","384980","","2018-08-21 15:26:03","2018-08-21 15:33:26","Self healing error handling in RxJS","<javascript><node.js><rxjs><observable><rxjs6>","1","2","","","","CC BY-SA 4.0"
"51975403","1","51975481","","2018-08-22 21:29:40","","0","1522","<p>I am not sure whats the problem here. I'd like to make a HTTP-request that does respond binary data (e.g. a file download) instead of JSON.</p>

<pre><code>import {HttpClient, HttpHeaders, HttpParams} from ""@angular/common/http"";
</code></pre>

<p>These lines are ok - but expect JSON.</p>

<pre><code>let x = this.http.get &lt;any&gt; (""http://myhost"", { responseType : 'json' });
let y = this.http.get &lt;any&gt; (""http://myhost"");
</code></pre>

<p>But I need to define the response to be not JSON.</p>

<pre><code>let z = this.http.get &lt;any&gt; (""http://myhost"", { responseType : 'string' });
</code></pre>

<p>Here I get a problem with it. I tried 'blob' as well.
I always get a typescript-error at compile-time.</p>

<blockquote>
  <p>Argument of type '{ responseType: ""string""; }' is not assignable to parameter of type '{ headers?: HttpHeaders | { [header: string]: string | string[]; }; observe?: ""body""; params?: Ht...'.
    Types of property 'responseType' are incompatible.
      Type '""string""' is not assignable to type '""json""'.</p>
</blockquote>
","307297","","","","","2018-08-22 21:36:11","RxJS HTTP-Client: response type for not JSON","<angular><typescript><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"51977371","1","51977842","","2018-08-23 02:00:01","","0","145","<p>I am trying out Angular and rxjs (6.0) and got stuck in a scenario.</p>

<p>Here it goes,</p>

<p>This is my sample codebase: <a href=""https://stackblitz.com/edit/angular-kxqj8d?file=app%2Finput-overview-example.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-kxqj8d?file=app%2Finput-overview-example.ts</a></p>

<pre><code>var service = {
  isUserSignedIn: null
};
var myObservable$ = new BehaviorSubject(service);

setInterval(function() {
  debugger;
  service.isUserSignedIn = !service.isUserSignedIn;
  service = JSON.parse(JSON.stringify(service));
  console.log(""--------------------------------------------"")
  console.log(""Value update to : "" + service.isUserSignedIn)
  myObservable$.next(service);


}.bind(this), 5000);


myObservable$
  .pipe(
  filter((curr) =&gt; curr.isUserSignedIn != null),
  distinctUntilChanged((prev, curr) =&gt; {
    debugger;
    console.log(""Value during comparison prev: "" + prev.isUserSignedIn + "" curr: "" + curr.isUserSignedIn)
    return prev.isUserSignedIn === curr.isUserSignedIn;
  }))
  .subscribe(value =&gt; {
    console.log(""Got Notified! New Value: "" + value.isUserSignedIn);
  })
</code></pre>

<p>Here's the console logs:</p>

<p><a href=""https://i.stack.imgur.com/XQvdP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XQvdP.png"" alt=""Observer not notified in rxjs angular""></a></p>

<p>Inside the ""distinctUntilChanged"" operator, both the values prev and curr are the same when the flag ""service.isUserSignedIn"" is set to false. But works correctly when the same flag is set to true!</p>

<p>Because of this, observer is not being notified!</p>

<p>I spent last two days trying to figure out, but couldn't find what's wrong.</p>

<p>Can you guys please help me out here. </p>
","737415","","","","","2018-08-23 14:13:53","Observer not notified when value changed to false","<angular><rxjs><observable><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"51979412","1","51979961","","2018-08-23 06:18:52","","2","1394","<p>I got the tslint waring <code>select is deprecated: from 6.1.0. Use the pipeable
'select' operator instead.</code></p>

<p>my selectors looks like below</p>

<p><code>private availableStudents$ = this.store.select(getAvailableStudents);</code></p>

<p>also my package.json</p>

<p><code>""rxjs"": ""^6.0.0""
""tslint"": ""~5.9.1""
""typescript"": ""^2.9.2""
""@angular/cli"": ""~6.1.2</code></p>
","8778646","","","","","2018-08-23 06:56:21","Angular 6 ng lint select is deprecated","<angular6><ngrx><rxjs6>","1","1","1","","","CC BY-SA 4.0"
"51989654","1","51991493","","2018-08-23 15:45:50","","0","578","<p>I am new to RxJs 6.0 (or any RxJs version for that matter) and although I see how powerful it is, some simple concepts escape me.</p>

<p>I have a situation where i would like to emit an extra value into the output stream based upon the source stream but for the life of me I can't figure out how to do it.  I really need a startsWith operator that can take a method instead of a static value and then I could achieve this.  Here is some silly code that sets up the scenario.</p>

<pre><code>import { startWith, scan, tap, mergeMap, map, concat } from 'rxjs/operators';

interface IData {
  data: number;
  emitExtraVal: boolean;
}

class obsData implements IData {
  constructor(data: number) {
    this.data = data;
    this.emitExtraVal = false;
  }
  public data: number;
  public emitExtraVal: boolean;

}

class extraData implements IData {
  constructor(data: number) {
    this.data = data;
    this.emitExtraVal = true;
  }

  public data: number;
  public emitExtraVal: boolean;
}
const sourceOne = of(new obsData(1),new obsData(2),new obsData(3));
/*const finalSource = sourceOne.pipe(
  map((sData) =&gt; &lt;IData&gt;new extraData(sData.data)),
  map((sData) =&gt; sData)
);*/
const finalSource = sourceOne.pipe(
  mergeMap((sData) =&gt; concat(of(&lt;IData&gt;new extraData(sData.data), of(sData))))
);
const subscribe = finalSource.subscribe(val =&gt; console.log('Data:' + val.emitExtraVal));
</code></pre>

<p>What I want to do is output an instance of extraData with the number in obsData followed by the obsData I just took in from the source.  This is not the exact scenario I am attempting but it demonstrates the core of what I'm trying to do which is to create an extra output followed by another output, both of which rely on the a single source input.</p>

<p><strong>This updated example of the problem is based on comments, however this example won't run because the syntax is not correct</strong></p>

<p>This produces the following error:</p>

<p>You provided 'function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); }' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.</p>

<p><strong>---Update---</strong>
Here is the final answer that works thanks to the responses.  The main problem I was having was that you can import concat from rxjs/operators or rxjs.  You MUST import it from rxjs if you are using it in the pipe command.</p>

<pre><code>// RxJS v6+
import { of, fromEvent, combineLatest, concat } from 'rxjs';
import { startWith, scan, tap, mergeMap, map } from 'rxjs/operators';

interface IData {
  data: number;
  emitExtraVal: boolean;
}

class obsData implements IData {
  constructor(data: number) {
    this.data = data;
    this.emitExtraVal = false;
  }
  public data: number;
  public emitExtraVal: boolean;

}

class extraData implements IData {
  constructor(data: number) {
    this.data = data;
    this.emitExtraVal = true;
  }

  public data: number;
  public emitExtraVal: boolean;
}
const sourceOne = of(new obsData(1),new obsData(2),new obsData(3));

const finalSource = sourceOne.pipe(
  mergeMap((sData) =&gt; concat(of(&lt;IData&gt;new extraData(sData.data), &lt;IData&gt;sData)))
);
const subscribe = finalSource.subscribe(val =&gt; console.log('Data:' + val.emitExtraVal));
</code></pre>
","5946519","","5946519","","2018-08-24 16:32:10","2018-08-24 16:32:10","RXJS: Emit extra value based upon observable value coming in","<typescript><rxjs><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"51990944","1","","","2018-08-23 17:05:01","","0","46","<p>So in vanilla JS I the way I understand the map operator is that it iterates through every item in an array and does work on that item. So if I have an array:</p>

<pre><code> [ {...}, {...}, {...} ]
</code></pre>

<p>Then .map would iterate over each object in this array, exposing that object's properties while you're inside of it. </p>

<p>With RxJS I most commonly see this: <code>map(x=&gt;x).map(...)</code> because it seems the RxJS map operator <strong>doesn't actually</strong> iterate over each object in the array. I see that it's most commonly used simple to expose the inside of the observable so that other work can be done on it.</p>

<p>So I have two questions:</p>

<ol>
<li>Is there a more semantic operator for map(x=>x)?</li>
<li>Why does RxJS's map deviate from Javascript's map?</li>
</ol>
","1467034","","","","","2018-08-23 17:16:44","Is the RxJS map operator used only for (x=>x) the wrong operator?","<angular><rxjs><reactive-programming><rxjs6>","1","5","","","","CC BY-SA 4.0"
"51998328","1","","","2018-08-24 06:00:27","","0","278","<p>I have a searchbar field which I use a service to run my search function from like so:</p>

<pre><code>// signup.ts

ngOnInit() {
  this.filteredOptions$ = this.searchService.search(this.searchTerm$);
}
</code></pre>

<p>Where search term is a Subject:</p>

<pre><code>&lt;input type=""text"" placeholder=""Your Business Name"" aria-label=""Number"" matInput (keyup)=""searchTerm$.next($event.target.value)""
        [matAutocomplete]=""auto""&gt;
</code></pre>

<p>I want to show a loading indicator when the search function starts and when it finished but the problem is that is a service (using injectable). Here is my search function:</p>

<pre><code>// searchservice.ts
  public search(terms: Observable&lt;string&gt;): Observable&lt;ABN&gt; {
    return terms.pipe(
      debounceTime(400),
      distinctUntilChanged(),
      switchMap(term =&gt; this.searchEntries(term)),
    );
  }
</code></pre>

<p>I then subscribe to this on my template. How can I keep it in a seperate file as a service but still update a local variable (isLoading) on the component?</p>
","4372290","","","user4676340","2018-08-24 06:38:00","2018-08-24 16:47:14","Need help adding a loading indicator to a searchbar that subscribes to a Rxjs subject","<angular><typescript><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"52016268","1","","","2018-08-25 10:18:56","","0","35","<p>I am trying to map data from two observables to a third one like </p>

<pre><code>  return this.coursesService
  .findCourseByUrl(route.params['id'])
  .pipe(
    switchMap((course: Course) =&gt;
      this.coursesService
        .findLessonsForCourse(course.id)
        .pipe(map((lessons: Lesson[])=&gt; [course, lessons)])
    )
  );
</code></pre>

<p>But I am getting the following exception</p>

<pre><code>Type 'Observable&lt;(Course | Lesson[])[]&gt;' is not assignable to type 'Observable&lt;[Course, Lesson[]]&gt;'.
Type '(Course | Lesson[])[]' is not assignable to type '[Course, Lesson[]]'.
Property '0' is missing in type '(Course | Lesson[])[]'.
</code></pre>

<p>I found out that the resultSelector in switchMap is deprecated in rxJs6, that's why I was trying this approach. But got stuck in here.</p>
","2122297","","2122297","","2018-08-25 10:26:07","2018-08-25 10:54:04","Type 'Observable<(T | R[])[]>' is not assignable to type 'Observable<[T, R[]]>","<rxjs6><switchmap>","1","0","","","","CC BY-SA 4.0"
"52018881","1","52019214","","2018-08-25 15:50:14","","25","17577","<p><strong>Use case:</strong> Call a function every minute (60000 ms) that dispatches store action to fetch <code>lastUpdated</code> status of items, which upon response and filtering, updates the store, and updated store is read as an observable and displayed in the view). This needs to happen for as long as the web app is open (so indefinitely).</p>

<p>Currently, I'm using this:</p>

<pre><code>this.refreshDate = window.setInterval(
  () =&gt; this.store.dispatch(new FetchLastUpdate())
, 60000);
</code></pre>

<p>And when view is destroyed/dismounted, I delete the interval as so:</p>

<pre><code>if (this.refreshDate) {
  clearInterval(this.refreshDate);
}
</code></pre>

<p>Is this efficient/effective, or is it troublesome?</p>

<p>Why would I want to use an RxJS polling strategy like:</p>

<pre><code>interval(60000)
  .pipe(
    startWith(0),
    switchMap(() =&gt; this.store.dispatch(new FetchLastUpdate()))
   );
</code></pre>

<p>Or</p>

<pre><code>timer(0, 60000)
  .pipe(
    switchMap(() =&gt; this.store.dispatch(new FetchLastUpdate()))
  );
</code></pre>

<hr>

<p><strong>TL;DR:</strong> <code>window.setInterval()</code> vs. RxJS <code>timer()</code>/<code>interval()</code></p>

<hr>

<h2><strong>Conclusion/answers (for ease of research):</strong></h2>

<p>There is great benefit to using RxJS functions to set an interval or perform polling, these benefits are explained in the <a href=""https://stackoverflow.com/a/52019030/5872268""><em>selected answer</em></a> but also in comments, but it is concluded (by discussions in the comments) that for the very simple requirement defined in the ""<strong>Use case</strong>"" section at the beginning of this post, it is unnecessary to use RxJS, and in fact if you are not using RxJS in any other part of your program, do not import it just for this, however in my case, I had already imported and used RxJS elsewhere.</p>
","5872268","","5872268","","2018-08-26 10:34:07","2021-01-26 19:32:47","Why would I use RxJS interval() or timer() polling instead of window.setInterval()?","<javascript><typescript><rxjs><rxjs5><rxjs6>","2","4","7","","","CC BY-SA 4.0"
"52026050","1","52026278","","2018-08-26 12:02:39","","0","51","<p>I am trying to subscribe to a service which is trying to access the REST back-end using the following object.</p>

<pre><code>export class Country {

    iso: String;
    iso3: String;
    name: String;
    niceName: String;
    numCode: number;
    phoneCode: number;

    constructor(values: Country = {}) {
        Object.assign(this, values);
    }
}
</code></pre>

<p>This is the service method which retrieves the data from the API, and the data is retrieved successfully into the <code>map()</code> function.</p>

<pre><code>public getCountries(): Observable&lt;Country[]&gt; {
    return this.http.get(COUNTRY_URL).pipe(
            map(response =&gt; {
                const countries = response.json()._embedded.countries;
                return countries.map((country) =&gt; { new Country(country) });
            }),
            catchError(this.handleError)
        );
}
</code></pre>

<p>And this is the consumer subscribing to the service.</p>

<pre><code>countries: Country[] = [];

constructor(private countryService: CountryService) {
    countryService.getCountries()
        .subscribe(countries =&gt; { 
            this.countries = countries;
    });
}
</code></pre>

<p>The <code>country</code> variable ends up being an array of <code>undefined</code> objects.</p>

<blockquote>
  <p><strong>Additional Info</strong></p>
  
  <p>I am using <strong>Angular 6</strong> with <strong>RXJS6</strong> and followed the migration
  guide
  <a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md"" rel=""nofollow noreferrer"">here</a></p>
</blockquote>

<p>This is a sample API response.</p>

<pre><code>{
    ""_embedded"" : {
        ""countries"" : [ ... ]
    },
    ""_links"" : {
        ""first"" : {
            ""href"" : ""http://localhost:8080/api/countries?page=0&amp;size=20""
        },
        ""self"" : {
            ""href"" : ""http://localhost:8080/api/countries{?page,size,sort}"",
            ""templated"" : true
        },
        ""next"" : {
            ""href"" : ""http://localhost:8080/api/countries?page=1&amp;size=20""
        },
        ""last"" : {
            ""href"" : ""http://localhost:8080/api/countries?page=11&amp;size=20""
        },
        ""profile"" : {
            ""href"" : ""http://localhost:8080/api/profile/countries""
        },
        ""search"" : {
            ""href"" : ""http://localhost:8080/api/countries/search""
        }
    },
    ""page"" : {
        ""size"" : 20,
        ""totalElements"" : 239,
        ""totalPages"" : 12,
        ""number"" : 0
    }
}
</code></pre>

<p>Can anyone see any issue with my code? Any help would be appreciated.</p>
","6663366","","6663366","","2018-08-26 12:17:16","2018-08-26 12:31:10","Subscribing to service returns `undefined` values","<angular><typescript><rxjs6>","1","14","1","","","CC BY-SA 4.0"
"52032963","1","","","2018-08-27 05:23:10","","6","888","<p>I'm having a little trouble reading the rxjs documentation. </p>

<p>As far as I can see, this is the official documentation: <a href=""https://rxjs-dev.firebaseapp.com/api"" rel=""noreferrer"">https://rxjs-dev.firebaseapp.com/api</a></p>

<p>In the <a href=""https://rxjs-dev.firebaseapp.com/api/index/class/Observable"" rel=""noreferrer"">Observable documenation page</a> under methods it has listed <code>lift()</code> and <code>subscribe()</code>, though later down the page, under examples, there are <code>forEach()</code>, <code>pipe()</code>, and <code>toPromise()</code>. </p>

<p>None of those have usage notes - just argument specifiers. </p>

<p>Looking at this page: <a href=""https://www.learnrxjs.io/operators/utility/topromise.html"" rel=""noreferrer"">https://www.learnrxjs.io/operators/utility/topromise.html</a></p>

<p>We're told: </p>

<blockquote>
  <p>:warning: toPromise has been deprecated! (RxJS 5.5+)</p>
</blockquote>

<p>How I am I meant to be reading this? <code>toPromise</code> was deprecated in 5.5x and continues to be deprecated? </p>
","1068446","","","","","2018-08-27 19:36:16","Should I be using toPromise in rxjs6? What does it do?","<deprecated><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52047553","1","52166247","","2018-08-27 22:03:56","","1","66","<p>I want to communicate from children to the parent as described in the <a href=""https://angular.io/guide/component-interaction#parent-and-children-communicate-via-a-service"" rel=""nofollow noreferrer"">Angular cookbook</a>. A service creates Subject through which to communicate:</p>

<p><code>progressSubject = new Subject&lt;ProgressMessage&gt;</code></p>

<p>The parent subscribes to the Subject and reacts on messages:</p>

<p><code>this.service.progressSubject.subscribe(msg =&gt; showProgress(msg))</code></p>

<p>Clients can use <code>progressSubject.next()</code> to send messages, which works fine.
However, if I want to subscribe the <code>progressSubject</code> to another Observable, all subscriptions terminate if the source observable completes. The parent will not react to input anymore.</p>

<pre><code>let first = new Subject();
first.subscribe(this.service.progressSubject);
first.next(3); // value is processed by subscribers to progressSubject
first.complete();

let second= new Subject();
second.subscribe(this.service.progressSubject);
second.next(3); // original subcription to progressSubject is ended, 
                // value is not processed anymore.
</code></pre>

<p>How can I ignore the ""complete"" event on a Subject, so that multiple sources can connect to that Subject?</p>
","2080575","","","","","2018-09-05 20:37:39","Create subscription that never ends","<angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52047891","1","52049652","","2018-08-27 22:48:01","","0","642","<p>I've never thought of myself as dumb, but I may have to reevaluate that position. I am missing something really simple here, but I just can't figure it out.</p>

<p>In my <code>login</code> component I have code like:</p>

<pre><code>if (this.authenticationService.login(user,password)) {
    // Navigate somewhere else now the user is logged in
} else {
    // Display an error message and leave the login screen in place
}
</code></pre>

<p>Naturally, this is expecting a boolean response to indicate the success or failure of the login.</p>

<p>In the AuthenticationService there is a login function. It then adds headers and builds the body before calling <code>http.put&lt;any&gt;</code></p>

<p>So my <code>AuthenticationService.login: boolean</code></p>

<p>makes the actual call to <code>http.put</code>. Obviously this doesn't get executed until the <code>subscribe()</code> call.</p>

<p>My question is that, as I see it, I have two options. One is to delay somehow the <code>return success;</code> until after the <code>.subscribe()</code> has processed or to return immediately an <code>Observable&lt;boolean&gt;</code> (changing the function prototype to indicate that) and then sending <code>observer.next(true)</code> when the <code>.subscribe()</code> is complete.</p>

<p>The problem is, in spite of reading documentation from all over the place, much of which is contradictory, I can't figure out how to achieve either of these ends. Please note that I am using Angular 6 and RxJS 6.</p>
","1867688","","","","","2018-08-28 13:21:11","Angular 6, Rxjs 6, process login using HttpClient","<observable><angular6><rxjs6>","2","0","","","","CC BY-SA 4.0"
"52051155","1","","","2018-08-28 06:08:18","","0","730","<p>Using rxjs and angular 6. 95% of the answers I've seen only use older versions of rxjs.</p>

<p>The server I'm connecting to requires a valid jwt token as a cookie during the connection initiation. Once the server responds with a 101 Switching Protocols, it immediately emits <code>{ ""status"": ""OK"" }</code>. </p>

<p>The next part of the handshake is for the client (what I'm writing) to send <code>{ ""sessionId"": ""xxyyzz"" }</code>. The server responds with another <code>{ ""status"": ""OK"" }</code> and then begins emitting events.</p>

<p>Or at least, it should?</p>

<p>I receive the first <code>{ ""status"": ""OK"" }</code> message, send the sessionId and userId, and the second <code>{ ""status"": ""OK"" }</code> comes through. </p>

<p>I am new to rxjs and observables so I'm wondering if my setup is incorrect. If I send a ping, the browser shows the ping frame being sent, but it's not responded to (The implementation server-side works - coworkers connect via android, etc, just fine).</p>

<p>Is <code>subject.next(""ping"")</code> even the right method? I'm just going round in circles and would appreciate any insight.</p>

<pre><code>subject: WebSocketSubject&lt;any&gt;;
connectAttempted: boolean;
connected: boolean;

connect(sessionId, userId) {    
        this.subject = webSocket({
            url: `wss://remote.api.server/stream`
        });

        this.subject.subscribe(
            (msg) =&gt; {
                if(msg.status &amp;&amp; msg.status == ""OK"" &amp;&amp; !this.connectAttempted) {
                    this.subject.next(
                        {
                            sessionId: sessionId,
                            userId: userId,
                            eventClasses: []
                        }
                    );
                    this.connectAttempted = true;
                } else if(msg.status &amp;&amp; msg.status == ""OK"" &amp;&amp; !this.connected) {
                    console.log(""Handshake completed"");
                    this.connected = true;
                    this.subject.next(""ping"");
                } else if(msg.status &amp;&amp; msg.status == ""FAIL"") {
                    this.connected = false;
                    console.log(""FAIL! No longer connected"");
                } else {
                    console.log(""Something other than status"", JSON.stringify(msg))    
                }
            },
            (err) =&gt; {
                console.log('error', err)
            },
            () =&gt; {
                console.log('complete?')
                this.connected = false;
                this.connectAttempted = false;
            }
        );
    }
</code></pre>
","7397261","","","","","2018-11-09 00:49:45","rxjs websocket: ping not being returned","<angular><websocket><rxjs><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52052298","1","52052349","","2018-08-28 07:26:07","","1","1620","<p>I am trying to create a search service for real time searching in input. I have 
<strong><code>search.service.ts</code></strong> :</p>

<pre><code>import { Injectable } from '@angular/core';
import { Http } from '@angular/http';

import { Observable } from 'rxjs';
import { map, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class SearchService {

  baseUrl: string = 'https://api.cdnjs.com/libraries';
  queryUrl: string = '?search=';

  constructor(private http: Http) { }

  search(terms: Observable&lt;string&gt;) {
    return terms.pipe(debounceTime(400)
      .distinctUntilChanged()
      .switchMap(term =&gt; this.searchEntries(term)));
  }

  searchEntries(term) {
    this.http.get(this.baseUrl + this.queryUrl + term).pipe(map(res =&gt; {
      res.json();
    }))
  }
}
</code></pre>

<p>and 
<strong><code>app.component.ts</code></strong>:</p>

<pre><code>import { Component } from '@angular/core';
import { SearchService } from './search.service';
import { Subject } from 'rxjs/Subject';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
  providers: [SearchService]
})
export class AppComponent {
  results: Object;
  searchTerm$ = new Subject&lt;string&gt;();

  constructor(private searchService: SearchService) {
    this.searchService.search(this.searchTerm$)
      .subscribe(results =&gt; {
        this.results = results.results;
      });
  }
}
</code></pre>

<p>I am facing a problem in <code>search.service.ts</code> <strong>Property 'distinctUntilChanged()' does not exist on type MonoTypeOperatorFunction&lt;{}></strong>. How can I fix this? Please give suggestions. </p>

<p><strong>EDITED</strong>
The code below fixed the issue. </p>

<pre><code>search(terms: Observable&lt;string&gt;) {
        return terms.pipe(debounceTime(400),
            distinctUntilChanged(),
            switchMap(() =&gt; interval(50), term =&gt; this.searchEntries(term)));
    }
</code></pre>

<p>You can visit my code for this project <a href=""https://github.com/NodiraIbrogimova/real-time-search-ng6"" rel=""nofollow noreferrer"">on github</a></p>
","5899688","","5899688","","2018-08-29 05:51:06","2018-08-29 05:51:06","Property 'distinctUntilChanged()' does not exist on type MonoTypeOperatorFunction<{}> Rxjs6","<typescript><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52066539","1","52067611","","2018-08-28 21:38:27","","1","49","<p>I have a stream of location data from a real-time data source and I am trying to use the rx <code>scan</code> operator to reduce the stream and compute the distance traveled as new location changes are emitted.</p>

<p>The emitted values are in this format</p>

<pre><code>{
  lat: 3.4646343,
  lng: 6.4343234,
  speed: 1.3353,
  heading: 279
}
</code></pre>

<p>And this is the processor</p>

<pre><code>function distanceBetweenPoints (point, point2, unit: string = 'M') {
    const radlat1 = Math.PI * (point.lat / 180);
    const radlat2 = Math.PI * (point2.lat / 180);
    const theta = point.lng - point2.lng;
    const radtheta = Math.PI * theta / 180;
    let dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
    dist = Math.acos(dist);
    dist = dist * 180 / Math.PI;
    dist = dist * 60 * 1.1515;

    if (unit == 'KM') { dist = dist * 1.609344; }
    if (unit == 'M') { dist = dist * 1.609344 * 1000; }
    return dist;
}

const location$: Subject&lt;LocationUpdate&gt; = new Subject();

location$
    .pipe(
        map(location =&gt; {
            return { lat: location.lat, lng: location.lng };
        }),
        scan((x, y) =&gt; {
            return distanceBetweenPoints(x, y);
        }),
        takeUntil(locationUpdateEnd$)
    )
    .subscribe(distance =&gt; console.info('distance', distance));
</code></pre>

<p>I'm pretty sure that I am using the <code>scan</code> operator wrong because i'm seeing <code>Nan</code> and a numeric value in the output. Any help would be appreciated.</p>
","754865","","754865","","2018-08-28 22:41:38","2018-08-29 04:57:08","Reduce stream into value with Rx scan operator","<javascript><typescript><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"52067495","1","52074034","","2018-08-28 23:32:20","","0","40","<p>The goal is that there is one service, and 2 components rely on the service. The update would be triggered externally, and all the components that rely on the data from the service would be notified that new data is available. To do this I'm using a typed subject, that then is published as a connectable observable.</p>

<p>Peeking in the debugger one thing that bothers me is that the refcounts stay 0, but I'm not sure if I'm misunderstanding what these mean. Any information as to what to expect and how to troubleshoot this would be awesome. </p>

<p>the components each have identical code</p>

<pre><code>  ngOnInit() {
    this.stepService.stepsFeed.subscribe(val =&gt; {
      console.log(`Got Steps in operations`);
      this.availableOperations = val;
    });
    console.log(`subscribed`);
  }
</code></pre>

<p>The service has the following</p>

<pre><code>constructor(
    private http: HttpClient) {

    this.stepsSubject = new Subject&lt;StepDefinition[]&gt;();
    this.stepsFeed = this.stepsSubject.pipe(
      tap(_ =&gt; {
        this.log('new steps published');
      }),
      publish()
    ) as ConnectableObservable&lt;StepDefinition[]&gt;;

    this.getStepDefinitions()
      .subscribe(operations =&gt; {
        this.stepsFeed.connect();
        this.log('connected');
      });
  }

  private stepsUrl = 'api/steps';

  private stepsSubject: Subject&lt;StepDefinition[]&gt;;
  public stepsFeed: ConnectableObservable&lt;StepDefinition[]&gt;;

  private getStepDefinitions(): Observable&lt;StepDefinition[]&gt; {
    return this.http.get&lt;StepDefinition[]&gt;(this.stepsUrl)
      .pipe(
        tap(steps =&gt;
        {
          this.stepsSubject.next(steps);
          this.log('fetched steps');
        }),
        catchError(this.handleError('getStepDefinitions', []))
      );
  }
</code></pre>

<p>The output is as follows:</p>

<pre><code>subscribed
subscribed
fetched steps
connected
</code></pre>
","292666","","","","","2018-08-29 09:28:13","using publish with subject","<angular><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52072763","1","52082910","","2018-08-29 08:21:52","","5","2234","<p>i'm new in angular 6 and ngrx store. I try to dispatch action after get data subscribe from store but it make infinite loop and crash browser? What i was wrong . Some solution i find it using do/tap operator of rxjs but still not working. And when i use {{(feedState | async).loading}} for example , it alway return undefined .</p>

<p>my component: </p>

<pre><code>  ngOnInit() {
    this.store.dispatch(new FeedActions.GetFeedCategories());
    this.feedSubscription = this.store
      .pipe(
        select('feed'),
        map(data =&gt; {
          this.feedState = data;
          return data.categories;
        }),
        tap(data =&gt;
          this.store.dispatch(
            new FeedActions.GetFeedItems({
              cat_id: data[this.selectedIndex],
              page: 0
            })
          )
        )
      )
      .subscribe(data =&gt; {});
  }
</code></pre>
","6333488","","","","","2018-08-29 17:14:25","infinite loop when i dispatch action after getting data w/subscribe","<angular6><ngrx-store><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52080850","1","52086904","","2018-08-29 15:10:37","","3","1974","<p>my question is similar to this one <a href=""https://stackoverflow.com/q/43199642/10290557"">How to throw error from RxJS map operator (angular)</a>, but I'm on angular6 with rxjs6 and I guess all is changed ;) </p>

<p>I want to know, how I could propagate an Error-Object within map of an observable to the subscribe OnError Part. I always end up in the OnNext Part.</p>

<p>Here is what I have so far:</p>

<p>Within a ng-component I have maybe the following method call</p>

<pre><code>[...]
this.dataStreamService.execCall({ method : 'order_list',params : {}})
   .subscribe( r =&gt; {
        // here r provides the result data from http call
        console.log(""execCall result"", r);
    }, err =&gt; {    
        // HERE the ""MAP ERROR OCCURED"" Error should be occured as well,
        // but in doesn't
        console.log(""execCall error"",err);

    });
[...]
</code></pre>

<p>The called service method looks like:</p>

<pre><code>execCall(dataStreamCall: DataStreamCall): Observable&lt;DataStreamResult&gt; {

    let apiURL = '&lt;some API-URL&gt;';
    let params = dataStreamCall.params;

    // do HTTP request (this.http calls an extra service handler which wraps
    // the angular httpClient and the API errors there
    // There is NO Problem with that part :)
    let apiResult = this.http.post(apiURL, params);

    // Build a new Observable from type ""DataStreamResult""
    let dsr : Observable&lt;DataStreamResult&gt; = apiResult
        .pipe(
            map( httpresult =&gt; {

                if (httpresult['status'] == false){
                   // the http call was basically successful,
                   // but state in data is false

                   // *** THIS IS NOT PROPAGATE TO SUBSCRIBE OnERROR *** 
                   throwError({'msg' : 'MAP ERROR OCCURED'});

                   // also tried as alternative
                   return throwError({'msg' : 'MAP ERROR OCCURED'});

                } else {

                    // here the http call was successful
                    let d = new DataStreamResult();
                    d.result = httpresult;
                    return d;
                }
            }),
            catchError( err =&gt; {
              // error is bubble up from http request handler
              return throwError(err);
            })
        );

    return dsr;
}
</code></pre>

<p>Finally the Question:
How could manage, that the ""throwError"" within the piped ""map"" is propagated to subscribe ""err => { ... }"".</p>

<p>The actual behavior for:</p>

<pre><code>throwError({..})
</code></pre>

<p>I ended up in the subscribe OnNext Part with <code>r = undefined</code></p>

<p>If I use:</p>

<pre><code>return throwError({..})
</code></pre>

<p>I also ended up in the subscribe OnNext Part where <code>r</code> is the throwError-Observable</p>

<p>Thx in Advance
Best Regards</p>
","10290557","","","","","2018-08-30 07:43:27","How to throwError within map of observable (rxjs6, ng6)","<error-handling><observable><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52081255","1","52084182","","2018-08-29 15:33:34","","1","2131","<p>I call backend that respond with:</p>

<pre><code>[
  ""https://some-url.com/someData1.json"",
  ""https://some-url.com/someData2.json""
]
</code></pre>

<p>Each JSON can have following schema:</p>

<pre><code>{
  ""isValid"": boolean,
  ""data"": string
}
</code></pre>

<p>I want to get array with all data, that have isValid is set to true</p>

<pre><code>backend.get(url)
    .pipe(
        mergeMap((urls: []) =&gt;
            urls.map((url: string) =&gt;
                backend.get(url)
                    .pipe(
                        filter(response =&gt; response.isValid),
                        map(response =&gt; response.data)
                    )
            )
        ),
        combineAll()
    )
</code></pre>

<p>When both .json have ""isValid"" set to true, I get array with both data.
But when one of them has ""isValid"" set to false observable never completes.</p>

<p>I could use mergeAll instead of combineAll, but then I receive stream of single data not collection of all data.</p>

<p>Is there any better way to filter out observable?</p>
","3868287","","","","","2018-08-30 11:37:53","rxjs - combining inner observables after filtering","<rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"52090509","1","52090617","","2018-08-30 06:29:26","","0","307","<p>I would like to return a child element of an observable as this.</p>

<p>Say I have a HttpClient that gets an observable of people:</p>

<pre><code>export class People{

    public Name: string;
}
</code></pre>

<p>and a service that gets a single one as abservable:</p>

<pre><code>public get(id: number): Observable&lt;People&gt; {
    return this.http.get&lt;People&gt;('http://localhost:8801/' + ""people/"" + id);
  }
</code></pre>

<p>Now I would like to get the name from my observable as observable:</p>

<pre><code>public get(id: number): Observable&lt;string&gt;{
    this.peopleService.get(id) .... ?
}
</code></pre>

<p>How could this be done?</p>
","1959238","","","","","2018-08-30 06:37:18","Angular 6 rxjs 6 return Observable nested element","<angular><observable><rxjs6>","2","0","","","","CC BY-SA 4.0"
"52094977","1","","","2018-08-30 10:39:20","","0","43","<p>I am using 3 API services in different tabs of mat-tab, but when I am switching between tabs, I am getting the data combined from all the 3 APIs.</p>

<p>I have defined three functions in a component in which I am calling different APIs in all the different functions and calling the 3 functions in the ngOninit(). When printing the fetched data into the console, I am getting data appended to one another.</p>

<p>For instance, if function 1, has 20 records, function 2 has 3, and function 3 has also 3.</p>

<p>So, if function 1 is executed first, then 20 records will be logged, after that if function 2 is executed, then 20+3=23 records will be logged(whereas here only 3 shall be logged), and finally when function 3 is executed, it returns, 23+3=26 records(here also it should be only 3).</p>

<p>Tried to unsubscribe the function after the value is fetched in a particular function. Was not able to do it.</p>

<pre><code>constructor(private _server: ServerService) {}
ngOnInit(): void {
  this.f1();
  this.f2()
}

getf1(): void {
  this._server.getf1count()
       .subscribe(exeJened =&gt; {
      this.exeJened = exeJened
      console.log('exe',this.exeJened)
     })
}
getf2(): void 
{
  this._server.getf2count()
       .subscribe(queJened =&gt; {
      this.queJened = queJened
    console.log('que',this.queJened) }

     })
}
</code></pre>

<p>Result of exe: array of 20 records
Result of que: array of 23 records
whereas, exe has 20 and que has 3 records.
Not able to upload screenshot.</p>

<p>Code for serverservice:</p>

<pre><code> constructor(private _http: HttpClient){}
getf1count():Observable&lt;any&gt;
  {
  return this._http.get(this.executed_URL)
  .pipe(
        map(exeresult=&gt;exeresult['serverserials']),
        retry(4),
        catchError(this.handleError)
    )
  }
  getf2count():Observable&lt;any&gt;
  {
  return this._http.get(this.queued_URL)
  .pipe(
        map(queresult=&gt;queresult['serverserials']),
        retry(4),
        catchError(this.handleError)
    )
  }
</code></pre>
","9934433","","9934433","","2018-08-31 09:47:59","2018-08-31 09:47:59","How to use multiple subscriber call in a component without overriding the data of all the subscriber calls","<javascript><angular><typescript><angular6><rxjs6>","0","6","","","","CC BY-SA 4.0"
"52098315","1","52101282","","2018-08-30 13:29:09","","4","14706","<p>I am retrieving a document from PouchDB in an Angular Service.  The document is retrieved in the following format:</p>

<pre><code>{
""_id"":""segments"",
""_rev"":""1-4f0ed65cde23fe724db13bea1ae3bb13"",
""segments"":[
    { ""name"":""Aerospace"" },
    { ""name"":""Auto repair"" },
    { ""name"":""Commercial"" },
    { ""name"":""Education"" },
    { ""name"":""Energy"" },
    { ""name"":""Farm/ranch"" },
    { ""name"":""Furniture"" },
    { ""name"":""Heavy Equipment"" },
    { ""name"":""Hobbyist"" },
    { ""name"":""Infrastructure"" },
    { ""name"":""Luxury/Leisure"" },
    { ""name"":""Military"" },
    { ""name"":""MUP"" },
    { ""name"":""Processing"" },
    { ""name"":""Rail"" },
    { ""name"":""Transportation"" }
]}
</code></pre>

<p>And I want to map that to a new Array that would look like:</p>

<pre><code>[
  { value: ""Aerospace"", viewValue: ""Aerospace"" },
  { value: ""Auto Repair"", viewValue: ""Auto Repair"" },
  { value: ""Commercial"", viewValue: ""Commercial"" }
  ...
 ]
</code></pre>

<p>To accomplish this, I have tried this code in my Service:</p>

<pre><code>getSegments(): Observable&lt;any[]&gt; {
  return from(this.database.get('segments'))
  .pipe(
    map((results) =&gt; results.segments)
  );
}
</code></pre>

<p>And I transform the array in my Component like this:</p>

<pre><code>segments: SegmentsLookup[] = [];
...
this.lookupDbService.getSegments()
  .subscribe(data =&gt; {
    data.forEach(element =&gt; {
      this.segments.push({value: element.name, viewValue: element.name});
  });
});
</code></pre>

<p>This works but I know there is a way to map this properly back in the Service code.  Also, when done this way, the compiler complains about the ""results.<em>segments</em>"" stating ""Property ""segments"" does not exist on type '{}'.</p>

<p>How do I map the data retrieved to the Array that I need in the Service's ""getSegments"" method?  </p>
","271206","","","","","2020-04-20 13:42:53","Rxjs Map Array in Json Document to new Array type","<javascript><mapping><angular6><rxjs6>","3","0","1","","","CC BY-SA 4.0"
"52108244","1","","","2018-08-31 03:57:12","","6","1208","<p>Let's say we have this global const:</p>

<pre class=""lang-js prettyprint-override""><code>const isSignedIn = fromPromise(fetch('/api/is-signed-in'))
    .pipe(throttleTime(1000), shareReply(1));
</code></pre>

<p>After page load, several components will subscribe to this at the same time:</p>

<pre class=""lang-js prettyprint-override""><code>isSignedIn.subscribe(() =&gt; console.log('do 1st'));
isSignedIn.subscribe(() =&gt; console.log('do 2nd'));
isSignedIn.subscribe(() =&gt; console.log('do 3rd'));
</code></pre>

<p>The above will only call the API once, however i need it to call the API again (ie after 1 second) if another component subscribes to it.</p>

<pre class=""lang-js prettyprint-override""><code>isSignedIn.subscribe(() =&gt; console.log('button press'));
</code></pre>

<p>How do i that using RxJS?</p>
","912215","","","","","2019-01-10 02:59:36","RxJS - How to share the output of an expensive observable but rerun that observable if its requested again after N seconds?","<javascript><typescript><rxjs6>","3","2","1","","","CC BY-SA 4.0"
"52110696","1","","","2018-08-31 07:38:56","","3","5066","<p>I have a method that returns an observable as follows</p>

<pre><code>constructor(private _http: HttpClient) {}

getUsers(location){
   return this._http.get(`https://someurl?location=${location}`)
          .pipe(
              map((response: any) =&gt; response),
              distinctUntilChanged()
           )
}
</code></pre>

<p>(Please assume all the required dependencies are imported)</p>

<p>So in order to display the result of users, I call loadUsers method.</p>

<pre><code>loadUsers(location){
   this.getUsers(location).subscribe( users =&gt; {
       this.userList = users;
    });
}

ngOnInit(){
    this.loadUsers('mumbai');
}
</code></pre>

<p>So the above code loads the list of users for me, for all the users who have location Mumbai.</p>

<p>Now I have a list of locations on the UI with the checkbox next to it like</p>

<pre><code>Mumbai,
Delhi,
Kerala
</code></pre>

<p>So clicking on one location will call the loadUsers method with the location name as a parameter.</p>

<p>So when I click on Mumbai again from the checkbox ( before clicking on any other checkbox other than Mumbai) I do not want to loadUsers belonging to Mumbai again as it was already loaded on load.</p>

<p>I have read that distinctUntilChanged()  can be used in such cases. However it doesn't seem to work for me as when I select Mumbai from the checkbox list, it still hits a call to loadUsers from Mumbai</p>

<p>PS - This is not the real use case. The above description is just an attempt to get my problem clear to you all.</p>

<p>I am a newbie into Angular and Rxjs. Please help.</p>
","6072233","","6588498","","2018-08-31 07:41:14","2018-08-31 07:56:34","distinctUntilChanged() not working as expected in angular 6","<javascript><angular><typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52116196","1","52121842","","2018-08-31 13:09:49","","1","42","<p>Why observable created with <code>of(...)</code> does not share source among multiple subscribers? <code>timer(...)</code> and <code>Observable.create(...)</code> work as expected. I couldn't find any mention of it in the documentation.</p>

<p><a href=""https://stackblitz.com/edit/typescript-cygjdt?file=index.ts&amp;devtoolsheight=100"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-cygjdt?file=index.ts&amp;devtoolsheight=100</a></p>
","1453167","","","","","2018-08-31 19:48:08","rxjs6 'share()' does not work with 'of(...)'?","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"52117866","1","","","2018-08-31 14:45:08","","6","3160","<p>When the user selects an item on the screen an action is triggered that requests data from the api and loads that data into the store for the selected item.</p>

<p>A selector is used to grab specific pieces of that returned data to create a graph.</p>

<p>The selector is returning undefined because the store doesn't have that data yet.</p>

<p>I either need the store/action/dispatch to signal to the call to the selector that it's ready OR allow the selector to keep requesting until it has the data it's looking for:</p>

<pre><code>this.setItemDispatch(this.datetime, this.selectedItem, this.direction);

this.store.select(selectFlyoutTimelineBar(this.selectedItem, this.direction, 'Graph Title')).subscribe(x =&gt; {
  console.log('data returned:', x);
});
</code></pre>

<p>The dispatch:</p>

<pre><code>this.store.dispatch(
          new LoadStationArriveTimelineDataAction({
            station: selectedItem,
            start: { startDate: currentDate },
            query: this.codes,
            lineQuery: this.lineCode
          })
        );
</code></pre>
","249316","","","","","2018-09-01 20:12:07","NGRX selector requests data before it's available in the store","<angular><rxjs><ngrx><rxjs6>","5","0","","","","CC BY-SA 4.0"
"52126319","1","","","2018-09-01 08:21:06","","0","33","<p>I am sorry if my question is a little bit newbie. But this is a question that doesn't leave me since the very beginning.
Imagine I have a service like <code>data.ts</code> where I make requests to the backend. </p>

<p>For example I have </p>

<pre><code>getInfo() {
    return this.http.get(`${this.domainName}api/getinfo`)
}
</code></pre>

<p>It is easy and seems good.
But, what if I want to subscribe to the observable of getInfo in let's say 10 components?
It means in each of them I will have the same code</p>

<pre><code>.subscribe(
  (data) =&gt; console.log(data), 
  (error) =&gt; console.log(errors)
)
</code></pre>

<p>I have some questions:</p>

<ul>
<li>Is it possible that from my component I will only address my
service and get data? (without subscribing in component)</li>
<li>Is it possible that I handle errors in separate service?</li>
<li>Does it mean I should subscribe to getInfo just right in the service and return, subject?</li>
<li>If I subscribe to getInfo in 10 places, does it mean that all observables will be different, not instance of one and the same observable and is it bad? </li>
</ul>

<p>Any help would be greatly appreciated.</p>
","9284609","","4661771","","2018-09-01 10:06:26","2018-09-01 10:06:26","Subscriptions to one observable in different places","<angular><rxjs6>","0","2","","","","CC BY-SA 4.0"
"52138102","1","52138266","","2018-09-02 14:49:32","","0","139","<p>This is my code in RxJs6:</p>

<pre><code>const observable$ = interval(1000).pipe(
      take(2),
      map(x =&gt; interval(1500).pipe(
        map(y =&gt; x+':'+y),
        take(2),
        concatAll()
      )),
    );
observable$.subscribe(obs =&gt; {
     obs.subscribe(x =&gt; console.log(x));
});
</code></pre>

<p>I expect my code show the result like this:</p>

<pre><code>0:0 
1:0 
0:1 
1:1 
</code></pre>

<p>But it actually shows:</p>

<p><a href=""https://i.stack.imgur.com/5720k.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5720k.png"" alt=""enter image description here""></a></p>

<p>why my code print data only one character every time ? And I think it should work like what i expected above not the actual result. anything wrong i understand about rxjs ?</p>
","7727387","","7727387","","2018-09-02 14:57:14","2018-09-02 15:09:41","Why rxjs print data one single character every time?","<javascript><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52148327","1","","","2018-09-03 10:55:52","","1","540","<p>Okay suppose I have auth guard.
I want to do just a simple thing: send request to backend, in case it sends me user info that means user is authenticated, I want to return true. Else it will send me the error, so I want to catch that error and redirect user.
How do I do it in with rxjs? It seems overcomplicated...
What I want to do is to check whether user is logged in and whether his token is valid. So I understand that I need to send a request but how to manager error or response in general then? I understand too, that if there is no token in local storage, I should return false and shouldn't even send any request.
Of course this doesn't work but I don't know how to do it at all...</p>

<pre><code>// guard
return this.authService.checkUserAuthenticated();
// service
checkUserAuthenticated() {
    this.http.post(`${this.domainName}api/auth/userinfo`, null)
      .subscribe(
      (data) =&gt; true,
    (err) =&gt; false
      );
  }
</code></pre>
","9284609","","9284609","","2018-09-03 12:25:23","2018-09-03 12:25:23","Auth guard with observable?","<angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52156393","1","","","2018-09-03 21:34:27","","0","225","<p>I need to get weather data for the city by unique ID. The API has it's limitation, so I need to group several requests into one.</p>

<pre><code>getWeatherByCityId(cityId: number): Observable&lt;IWeatherData&gt; {
    const cachedWeatherData = this.weatherCache.filter(
        (weatherData: IWeatherData) =&gt; weatherData.id === cityId
    );
    this.getDebouncedDataTimer = timer(5000);

    if (cachedWeatherData &amp;&amp; cachedWeatherData.length !== 0) {
        return of(cachedWeatherData[0]);
    }

    this.debouncedIds.push(cityId);
    if (this.getDebouncedDataSubscription) {
        this.getDebouncedDataSubscription.unsubscribe();
    }
    this.getDebouncedDataSubscription = this.getDebouncedDataByIds(cityId).pipe(
        delay(5000)
    ).subscribe(data =&gt; data);

    return this.getDebouncedDataSubscription;
}
</code></pre>

<p>The idea is to do only one request after 5000ms to get the weather for the several cities at once, instead of doing several requests after checking the cached data.</p>

<p>So getWeatherByCityId method should be called numerous of times and getDebouncedDataByIds should be called only once, not to overload an API.</p>

<p>The problem is that the return could be only Observable, but not Subscription. And I can't use map inside of pipe, because I can't unsubscribe in this case.</p>

<p>And I also should return the right value for each city in this case:</p>

<pre><code>private getDebouncedDataByIds(cityId: number) {
    return this.getWeatherByCityIds(debouncedIds).pipe(
        map((weatherDataMultiple: HttpResponse&lt;IWeatherDataMultiple&gt;) =&gt; {
            if (weatherDataMultiple.status === 200) {
                this.weatherCache.push(...weatherDataMultiple.body.list);

                return weatherDataMultiple.body.list.filter(
                    (weatherData: IWeatherData) =&gt; weatherData.id === cityId
                )[0];
            }
        })
    );
}
</code></pre>
","2404985","","","","","2018-09-03 21:43:46","RXJS / Angular 6: Debounce/group several request into one with timeout","<typescript><rxjs><observable><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52156707","1","52191772","","2018-09-03 22:19:05","","2","1235","<p>In this example, switchMap gives the http response but when map is used an Observable is returned. I believe this has to do with the 'flattening' switchMap does, but still don't understand what switchMap is doing behind the scenes to produce the http response result. </p>

<pre><code>import{Component, OnInit} from '@angular/core';
import {HttpClient} from '@angular/common/http';
import { of, from, Observable, forkJoin } from 'rxjs';
import { map, mergeMap, switchMap, tap, flatMap} from 'rxjs/operators';
@Component({
  selector: 'star-wars',
  template: ``,
})
export class StarWars {
  private peopleUrl = 'https://swapi.co/api/people/';

  constructor(private http: HttpClient) {}

  ngOnInit() {
    of(1)
    .pipe(
      map(() =&gt; this.http.get('https://swapi.co/api/people/1')),
      // produces Observable {_isScalar: false, source: {…}

      switchMap(() =&gt; this.http.get('https://swapi.co/api/people/1')),
      // produces http response {name: ""Luke Skywalker"", height: ""172"", mass: ""77"", hair_color: ""blond""…}
    )
    .subscribe(res =&gt; {
      console.log(res)
    })
  }
}
</code></pre>

<p>Any clarification on what switchMap is doing here to produce this different result would be appreciated.</p>
","971823","","","","","2018-09-05 18:55:15","Why does switchmap return a http response but map returns an observable","<angular6><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"52160425","1","52161166","","2018-09-04 06:54:13","","1","342","<p>I have a login function in my authentication service and I want it to return with some value if the login completes or return the HttpError. That step was easy however, I also want to include if the initial login works, load account details using a second observable. This step is not working for me because if the login fails the code shouldn't also try and load the account details. I tried using the merge function however when errors occur it still calls the other observable. Also even if the login works I still never get a delay from the second observable.</p>

<p>I am having a really hard time adapting to the pipe setup with version 6 of Rxjs and having this many pipes is very confusing to follow.</p>

<p>Login Method: </p>

<pre><code>    public Login(LoginData: LoginModel): Observable&lt;HttpErrorResponse | LoginResponse&gt;
  {
    var loginRequest = this.web.post&lt;LoginResponse&gt;('http://localhost:20552/api/token', LoginData).pipe(share());

    return loginRequest.pipe(map((success: LoginResponse) =&gt;
    {
      return new LoginResponse(success.token);
    }), merge(this.LoadAccountDetails())).pipe(catchError((val: LoginResponse | HttpErrorResponse) =&gt; of(val))).pipe(map((x: LoginResponse | HttpErrorResponse) =&gt;
    {
      if (x instanceof LoginResponse)
      {
        return new LoginResponse(x.token);
      } else
      { 
        var error = x as HttpErrorResponse;
        return error;
      }
    }));
  }


  public LoadAccountDetails(): Observable&lt;any&gt;
  { 
    return of({}).pipe(delay(5000)); // Simple delay function because I haven't finished this server code yet.
  }
</code></pre>
","7564855","","","","","2018-09-04 07:38:45","Angular 6 / RxJs 6 Observable merging that also skips to error block","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52163131","1","52163268","","2018-09-04 09:30:03","","0","709","<pre><code>showDateCriteria = combineLatest(this.myForm.controls['name'].valueChanges, this.myForm.controls['age'].valueChanges, (name, age) =&gt; ({name, age}))
.subscribe(val =&gt; !(val.name==null ||val.age==null ));
</code></pre>

<p>I have tried this code with <strong>combineLatest</strong> Operator and <strong>showDateCriteria</strong> </p>

<pre><code>&lt;div *ngIf=""{{showDateCriteria | async}}""&gt;Show This&lt;/div&gt;
</code></pre>

<p>I am unable to show the <code>&lt;div&gt;</code> eventhough particular condition is satisfied</p>

<p><a href=""https://stackblitz.com/edit/angular-rs3d7a"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-rs3d7a</a></p>
","6379830","","","","","2018-09-05 03:40:50","How to do combineLatest operator in valueChanges subscriptions","<angular><reactive-programming><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52171868","1","","","2018-09-04 18:10:48","","0","70","<p>I have a service which returns an Observable, after getting the response I map the response and assign result to the array.</p>

<pre><code>  this.dataService.fetchData().subscribe(response =&gt;{
    [...this.DataMappingField ]=  response.map(({ ID: id, Name: name }) =&gt; ({ id, name }));
  });
</code></pre>

<p>With spread operators inside subscribe I am getting the error below.</p>

<p><strong>Error: Property 'map' does not exist on type 'Modelclass'.</strong>   </p>

<p>Response from service</p>

<pre><code>[
  {ID: 6197, Name: 'A', desc: null,catergory:'lap'},
  {ID: 6198, Name: 'B', desc: null,catergory:'lap'}
]
</code></pre>

<p>In service, <code>fetchData</code> method:</p>

<pre><code>fetchData(): Observable&lt;Modelclass&gt; {
  return this.http
    .get&lt;Modelclass&gt;(REQUEST_URL)
    .pipe(
      tap(response =&gt; response)
    );
}
</code></pre>

<p>Model class: </p>

<pre><code>export class Modelclass {
  ID: any;
  Name: string;
}
</code></pre>

<hr>

<p>But the below code is working fine when call with method:</p>

<pre><code>this.dataService.fetchData().subscribe(this.fetchResponse);

private fetchResponse(response): void =&gt; {
  [...this.DataMappingField ]= response.map(({ ID: id, Name: name }) =&gt; ({ id, name }));
}
</code></pre>
","4031891","","3024975","","2018-09-08 00:24:23","2018-09-08 00:24:23","How to use map inside subscribe rxjs6","<rxjs><angular6><rxjs6>","1","3","","","","CC BY-SA 4.0"
"52174542","1","52176578","","2018-09-04 22:02:02","","0","627","<p>I am using Angular CLI 6.1.3, rxjs 6.2.2 .</p>

<p>To my issue: </p>

<p>I implemented a Service <code>RespSearchService</code> which is responsible for getting information from a Sharepoint.</p>

<p>Following code requests a JSON from the Sharepoint:</p>

<pre><code>public search(queryString: string): Observable&lt;any&gt; {
    return from(
        web.siteUsers
            .filter(""substringof(\'"" + queryString + ""\',Email)"")
            .get()
            .then(v =&gt; {
                console.log('search', v);
            })
    );
}
</code></pre>

<p>The above code works as expected and is logging the JSON to the console.</p>

<p>My issue lies within another component where I subscribe to the <code>Observable</code>, as I did in all other cases, where it works. But somehow here it will not work. It seems like the Observable returns an empty object as the log to the console says <code>undefined</code>.</p>

<pre><code>export class ClaimFormInfoComponent implements OnInit {

    public claim: Claim = new Claim();
    public results: any;
    queryField: FormControl = new FormControl();
    constructor(private data: DataService, private respSearch: RespSearchService) { }

    ngOnInit() {
        this.data.currentClaim.subscribe(claim =&gt; this.claim = claim);

        this.respSearch.search(""chri"").subscribe((response: any) =&gt; {
          this.results = response;
          console.log('results', this.results); \\-&gt; results undefined
        });
    }
}
</code></pre>

<p>I am stuck. I have no more ideas nor can I find anything useful on the internet.</p>

<p>Thanks in advance for any hint or idea!</p>
","10317173","","2829204","","2018-09-05 03:19:23","2018-09-05 03:21:35","Angular 6 & rxjs 6 - subscription returns undefined","<sharepoint><rxjs><angular6><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"52182687","1","52182849","","2018-09-05 10:16:50","","9","9252","<p><strong>Issue</strong></p>

<p>I have used ngrx fromEvent operator to create an Observable from 2 input text fields, I have used document as target which is fine, but now I want to target only one input field. I am not sure sure what to use instead of document to target only one input field.</p>

<p><strong>What I have done so far to get the target</strong></p>

<ul>
<li>Used document.getElementByID('someID')</li>
<li>Used ElementRef</li>
<li>Used document.querySelector('someID')</li>
</ul>

<p><strong>Code</strong></p>

<p><a href=""https://stackblitz.com/edit/ngrx-fromevent"" rel=""noreferrer"">StackBlits live editor</a> </p>

<pre><code>import { Component } from '@angular/core';
import { fromEvent } from 'rxjs';

@Component({
  selector: 'my-app',
  template: `&lt;input type=""text""&gt;
             &lt;input type=""text""&gt;`
})
export class AppComponent {
  ngOnInit() {
    fromEvent(document, 'keyup')
      .subscribe(res =&gt; console.log(res.target.value));
  }
}
</code></pre>

<p>Thanks for your help in advance.</p>
","669013","","","","","2020-09-04 06:19:10","How to target an HTML element using rxjs fromEvent in Angular 6","<angular><rxjs><angular6><rxjs6>","2","0","2","","","CC BY-SA 4.0"
"52191839","1","","","2018-09-05 19:01:46","","3","80","<p>I'm creating a search in <code>Angular 6</code>. I'm having a hard time with my stream.</p>

<p>I want my rx stream to:</p>

<ol>
<li>Accepts text input changes</li>
<li>Combine with a <code>subject</code> that tells the stream to get more results (increment limit) when button clicked</li>
<li>Call the service</li>
</ol>

<p>What I have works, except:</p>

<ol>
<li>When the subject emits, it does nothing, I expected the <code>switchmap</code> to kick in and thus get server response..</li>
<li><p>How can I increment the limit each time the <code>subject</code> emits by 10?</p>

<pre><code>searchInput: FormControl = new FormControl();
showMore$: Subject&lt;number&gt; = new Subject();

ngOnInit() {
this.searchInput
    .valueChanges
    .pipe(
        debounceTime(300),
        distinctUntilChanged(),
        withLatestFrom(this.showMore$.pipe(startWith(10), tap(val =&gt; {
            //how to increment the value here?
        }))),
        //switchmap not called when showMore$ emits...
        switchMap(([searchTerm, limit]) =&gt; {
            return this.myservice.search(searchTerm, limit)
        }),
    )
    .subscribe(response =&gt; {
        this.results = response;
    });
}

showMore(): void {
    this.showMore$.next(10);
}
</code></pre></li>
</ol>
","2275792","","","","","2018-09-05 19:18:29","Angular: Text search rxjs issue","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52202009","1","","","2018-09-06 10:28:21","","0","346","<p>I'm trying to store (in NgRx Store) an Object that has an EventEmitter,</p>

<p>after retriving it from the Store and subscribing to it I got this message:</p>

<blockquote>
  <p>ERROR TypeError: Cannot add property 0, object is not extensible</p>
</blockquote>

<p><strong>if I disable Store-Freeze everthing works perfectly</strong>. there is any solution?</p>
","8284340","","","","","2018-09-06 13:44:35","how to Subscribe to EventEmitter retrieved from NgRx Store (with Store-Freez) (ERROR TypeError: Cannot add property 0, object is not extensible)","<angular><ngrx><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52206226","1","52206312","","2018-09-06 14:21:26","","0","863","<p>I have an interceptor and I need to chain/execute a promise/observable when the request comes back from the server.  How can I do this in rxjs 6?</p>

<pre><code>intercept(): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    return next.handle(request)[DO-SOMETHING]
}
</code></pre>
","2174621","","","","","2018-09-06 14:47:08","execute extra observable/promise at the end of the http request","<rxjs><angular-http-interceptors><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52210034","1","","","2018-09-06 18:18:11","","1","48","<p>I am trying to retrieve a list of todos from service class in the component. But it  does not work. Please find the code below:</p>

<p>todos.service.ts</p>

<pre><code>import { Injectable } from '@angular/core';
import { Todos } from '../models/Todos';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, of, BehaviorSubject } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class TodosService {

  todos: Todos[];

  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  }

  private todoSource = new BehaviorSubject&lt;Todos&gt;({ id: null, text: null, completed: null });
  selectedTodo = this.todoSource.asObservable();

  constructor(private http: HttpClient) {
    this.http.get&lt;Todos[]&gt;('http://localhost:8888/api/todos').subscribe((todos) =&gt; {
      this.todos = todos;
    });
  }

  getTodos(): Observable&lt;Todos[]&gt; {
    return of(this.todos);
  }

  addTodo(todo): Observable&lt;Todos&gt; {
    return this.http.post&lt;Todos&gt;('http://localhost:8888/api/todos', todo, this.httpOptions);
  }

  setTodo(todo: Todos) {
    this.todoSource.next(todo);
  }
}
</code></pre>

<p>todoslist.component.ts</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { Todos } from '../../models/Todos';
import { TodosService } from '../../services/todos.service';

@Component({
  selector: 'app-todolist',
  templateUrl: './todolist.component.html',
  styleUrls: ['./todolist.component.css']
})
export class TodolistComponent implements OnInit {

  todos: Todos[];
  constructor(private _todosService: TodosService) {
  }

  ngOnInit() {
    this._todosService.getTodos().subscribe(todos =&gt; {
      console.log('getting todos', todos);
      this.todos = todos;
    });
  }

  onSelect(todo: Todos) {
    this._todosService.setTodo(todo);
  }
}
</code></pre>

<p>The ngOnInit method of the component calls the getTodos() method of the service. But on console logging the todos appear to be undefined. What am I doing wrong here ?</p>

<p>Thanks</p>
","1324023","","","","","2018-09-06 19:52:20","angular6 RxJs observables issue","<angular><angular6><rxjs6>","2","1","","","","CC BY-SA 4.0"
"52210083","1","","","2018-09-06 18:22:01","","1","37","<p>I have the following code which tries to process an array of endpoints in parallel:</p>

<pre><code>callApiEndpoint(endpoint: string): Observable&lt;any&gt; {
  return this.httpClient
    .get&lt;any&gt;(endpoint)
    .pipe(
      tap(
        data =&gt;
          console.log(`calling ${endpoint} returned ${JSON.stringify(data)}`),
        catchError(ApiCallerComponent.handleError)
      )
    );
}

getEndpointsToProcess(): string[] {
  const result = [];

  this.idsToProcess.forEach(element =&gt; {
    result.push(this.getEndpoint(element));
  });

  return result;
}

processRequests() {
  const endpoints = this.getEndpointsToProcess();

  forkJoin(endpoints.map(uri =&gt; &lt;Observable&lt;any&gt;&gt;this.callApiEndpoint(uri)))
    .pipe(concatAll())
    .subscribe(val =&gt; console.log(val));
}
</code></pre>

<p>How would I be able to control the degree of parallel requests made to the API server? In addition, how would I be able to say all the requests have finished irrespective of their outcomes?</p>
","1901646","","3024975","","2018-09-07 20:00:23","2018-09-07 20:00:23","Controlling the degree of parallelism and making sure the operation finished","<angular><typescript><rxjs><angular6><rxjs6>","0","1","1","","","CC BY-SA 4.0"
"52210958","1","","","2018-09-06 19:27:41","","0","53","<p>Long story short: I have an Angular app initializing by calling a service that calls a second, data service. After the middle service receives and processes its data from the data service, it must communicate to the app, via Observable or Subject, that the app can continue to load. I want to short-circuit any subsequent calls to the same method.</p>

<pre><code>export class MiddleService {
    private triedOnce = false;
    private isLoadedSubject = new AsyncSubject();

    public loadConfig (): AsyncSubject&lt;any&gt; {
        if (!this.triedOnce) {
            this.isLoadedSubject.next(false);
            this.dataService.getConfiguration(...).subscribe(
                (data) =&gt; {
                    // do stuff with data
                    this.isLoadedSubject.next(true);
                }
            );

            this.isLoadedSubject.complete();
            this.triedOnce = true;
        }
        return this.isLoadedSubject;
    }
}
</code></pre>

<p>The first question, I guess, is if using a Subject like this is an anti-pattern or non-standard use. (<a href=""https://medium.com/@benlesh/on-the-subject-of-subjects-in-rxjs-2b08b7198b93"" rel=""nofollow noreferrer"">Does this apply?</a>)</p>

<p>Secondly, I feel like I should reuse and be able to reuse the <code>isLoadedSubject</code> instead of needing a separate boolean. I'm not sure how to do that outside of a subscription and its <code>complete</code> callback. The <code>AsyncSubject</code> has an <code>isCompleted</code> property, but it's private.</p>
","356016","","","","","2018-09-06 19:33:48","Rxjs way to let caller know method is complete, and to cache that result","<angular><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52222232","1","52222372","","2018-09-07 12:06:42","","1","90","<p>In a service class a method has to pass the current device serialNumber. Using ngrx the device$ can be subscribed to get actual one, but that doesn't feel good. What is a best practice for this situation?</p>

<pre><code>@Injectable()
export class DeviceService {
  public device$: Observable&lt;Device&gt;;
  public device: Device; // feels 'redundant'

  constructor(private http: HttpClient,
              private store: Store&lt;DeviceState&gt;,) {
    this.device$ = this.store.select(DeviceSelectors.getCurrentDevice);
    this.device$.subscribe((device: Device) =&gt; {
      this.device = device; // feels bad
    });
  }

  regenerate() : Observable&lt;Object&gt; {
    if (environment.production) {
      const url = `${environment.url}/devices/${this.device.serialNumber}/regenerate`;
      return this.http.get(url) as Observable&lt;Object&gt;;
    } else {
      return of({});
    }
  }
}
</code></pre>
","1416696","","","","","2018-09-07 12:31:11","How to get actual value of observable","<angular><typescript><ngrx><rxjs6>","2","5","","","","CC BY-SA 4.0"
"52225366","1","52225976","","2018-09-07 15:11:25","","0","3356","<p>I am using Angular 6.
And in this specific use case want to handle 404, rather pass it along to the component to display a text message in the UI.</p>

<pre><code>// code in service
public getVariatioMarginPlugDates(): Observable&lt;Date[]&gt; {
return this._http
              .get&lt;Date[]&gt;(AppSettings.VariationMarginPlugDatesUrl, { withCredentials: true })
              .pipe(catchError(this._trace.handleError('GET ' + AppSettings.VariationMarginPlugDatesUrl, [])));
}
</code></pre>

<p>The <code>404</code> is also being handled by <code>catchError</code> that uses an error handler utility. However I want to trap the 404 and potentially set some boolean variable which the component could use to display a useful status message on the UI (not looking for <code>404</code> redirect or generic popup)</p>

<p>Thank you so much!</p>

<pre><code>// edited code with solution
public getVariatioMarginEmail(runDate: string): Observable&lt;any&gt; {
const url = AppSettings.VariationMarginEmailUrl.replace(this._regExp, runDate);
return this._http
              .get&lt;any&gt;(url, { withCredentials: true })
              .catch(this._trace.handleError('GET ' + url, []));
}

public handleError&lt;T&gt;(operation = 'operation',  result?: T, skipStatus = [404]) {
    return (error: any): Observable&lt;T&gt; =&gt; {

      if (skipStatus.includes(error.status)) {
        return observableOf(error.status as T);
      }

      const errMsg = (error.message) ? error.message : error.status ? `${error.status} - ${error.statusText}` : 'Server error';
      console.error(errMsg);

      const dialog = this._dialogService.open({
        title: 'Server Error',
        content: `${operation} failed: ${errMsg}`,
        actions: [ { text: 'Ok' } ]
      });

      try { this._loggingService.log(errMsg); } catch (error) {}

      return observableOf(result as T); // return empty result
  };
}
</code></pre>
","4603068","","4603068","","2018-09-07 16:38:41","2018-09-07 16:38:41","How to gracefully handle 404 in Angular component?","<angular><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52226237","1","52226602","","2018-09-07 16:09:38","","0","493","<p>I have an Observable with items that are selected by the user. Every selected items is used as the source for an api call. And the results from the api call should be ""merged"" to an Observable.</p>

<p>The thing that I don't seem to get is how I merge the results back. I tried using the scan operator, but the ""accumulator"" only ""grows"".</p>

<p>I have this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""true"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import {
  Observable,
  Subject,
  of ,
  from
} from 'rxjs';
import {
  map,
  merge,
  flatMap
} from 'rxjs/operators';

function apiUri(albumId: String) {
  return `https://jsonplaceholder.typicode.com/albums/${albumId}`
}


const albums$ = new Subject &lt; String[] &gt; ();

const responseStream = albums$.pipe(
  flatMap(albumIds =&gt; albumIds),
  flatMap(id =&gt; from(fetch(apiUri(id)))),
  flatMap(resp =&gt; resp.json()),
  /* I'm in the dark on how to ""merge"" it back into an Observable&lt;String[]&gt; */
);

responseStream.subscribe(resp =&gt; console.log(resp))
const randomCodes1 = ['5', '1', '3'];
albums$.next(randomCodes1);</code></pre>
</div>
</div>
</p>

<p>Stackblitz link with running example: <a href=""https://stackblitz.com/edit/rxjs-flatmap-galore?&amp;file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-flatmap-galore?&amp;file=index.ts</a></p>
","33110","","33110","","2018-09-07 23:57:27","2018-09-07 23:57:27","Call api for every item in Observable<sourceitem[]> and ""merge"" it back to an Observable<targetitem[]>","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52229439","1","52229564","","2018-09-07 20:46:04","","1","1918","<p>I have a search function that was written like this in Angular prior to version 6:</p>

<pre><code>import { Component, OnInit, OnDestroy } from '@angular/core';
import { Observable, Subject } from 'rxjs/Rx';

import { Product } from '../products/product';
import { ProductService } from '../products/product.service';
import { Subscription } from 'rxjs';
import { SearchService } from '../services/search-service';
import { Router } from '@angular/router';
import { PagedList } from '../shared/paged-list.interface';

@Component({
  selector: 'fb-product-list',
  templateUrl: './product-list.component.html'
})
export class ProductListComponent implements OnInit, OnDestroy {
  total$: Observable&lt;number&gt;;
  items$: Observable&lt;Product[]&gt;;

  product: Product;
  subTimer: Subscription;

  term: string = """";
  currentPage: number = 1;
  private pageStream = new Subject&lt;number&gt;();

  public pluralizeMapProduct: any = {
    '=0': 'No products',
    '=1': '1 product',
    'other': '# products'
  }

  constructor(
    private _searchService: SearchService,
    private _productService: ProductService,
    private _router: Router) {
  }

  ngOnInit() {
    this.setupSearching();
  }

  setupSearching(){
    const searchSource = this._searchService.searchTermStream
      .map(searchTerm =&gt; {
        this.term = searchTerm;
        return {search: searchTerm, page: 1}
      });

    const pageSource = this.pageStream.map(pageNumber =&gt; {
      this.currentPage = pageNumber;
      return {search: this.term, page: pageNumber}
    });

    const source:Observable&lt;PagedList&lt;any&gt;&gt; = pageSource
      .merge(searchSource)
      .startWith({search: this.term, page: this.currentPage})
      .switchMap((params: {search: string, page: number}) =&gt; {
        return this._productService.getProductsPaged(params.search, params.page, null, null)
      })
      .share();

    this.total$ = source.pluck('meta').pluck('total_count') as Observable&lt;number&gt;;
    this.items$ = source.pluck('data') as Observable&lt;Product[]&gt;;
  }

  goToPage(page: number, reload: boolean) {
    this.pageStream.next(page);
  }  

}
</code></pre>

<p>It is now re-written following the guidelines to this:</p>

<pre><code>    import { Component, OnInit, OnDestroy } from '@angular/core';
    import { Subscription, Observable, Subject, merge } from 'rxjs';
    import { map, startWith, switchMap, share, pluck } from 'rxjs/operators';

    import { Product } from '../products/product';
    import { ProductService } from '../products/product.service';
    import { SearchService } from '../services/search-service';
    import { Router } from '@angular/router';
    import { PagedList } from '../shared/paged-list.interface';
    import { SearchSpec } from '../shared/search-spec.interface';

    @Component({
      selector: 'fb-product-list',
      templateUrl: './product-list.component.html'
    })
    export class ProductListComponent implements OnInit, OnDestroy {
      total$: Observable&lt;number&gt;;
      items$: Observable&lt;Product[]&gt;;

      product: Product;
      subTimer: Subscription;

      term: string = """";
      currentPage: number = 1;
      private pageStream = new Subject&lt;number&gt;();

      public pluralizeMapProduct: any = {
        '=0': 'No products',
        '=1': '1 product',
        'other': '# products'
      }

      constructor(
        private _searchService: SearchService,
        private _productService: ProductService,
        private _router: Router) {
      }

      ngOnInit() {
        this.setupSearching();
      }

      setupSearching(){
        const searchSource = this._searchService.searchTermStream
          .pipe(
            map(searchTerm =&gt; {
              this.term = searchTerm;
              return {term: searchTerm, page: 1} as SearchSpec
            })
          );

        const pageSource = this.pageStream
          .pipe(
            map(pageNumber =&gt; {
              this.currentPage = pageNumber;
              return {term: this.term, page: pageNumber} as SearchSpec
            })
          );

        const source:Observable&lt;PagedList&lt;any&gt;&gt; = pageSource
          .pipe(        
            merge(searchSource),
            startWith({term: this.term, page: this.currentPage}),
            switchMap((params: {term: string, page: number}) =&gt; {
              return this._productService.getProductsPaged(params.term, params.page, null, null)
            }),
            share()
          );

        this.total$ = source.pipe(pluck('meta'), pluck('total_count')) as Observable&lt;number&gt;;
        this.items$ = source.pipe(pluck('data')) as Observable&lt;Product[]&gt;;
      }

      goToPage(page: number, reload: boolean) {
        this.pageStream.next(page);
      }  

    }
</code></pre>

<p>VSCode complains about this line in the 3rd const, inside the pipe:</p>

<pre><code>merge(searchSource),
</code></pre>

<p>with the error:</p>

<blockquote>
  <p>Argument of type 'Observable' is not assignable to
  parameter of type 'OperatorFunction'.</p>
  
  <p>Type 'Observable' provides no match for the signature
  '(source: Observable): Observable&lt;{}>'</p>
</blockquote>

<p>which I sort of understand (it is a parameter missmatch because in rxjs6 we must use OperatorFunctions) but I have no idea how to fix it.</p>

<hr>

<p><strong>EDIT</strong></p>

<p>This is the search service (for v6):</p>

<pre><code>import { Injectable } from '@angular/core';

import { Subject } from 'rxjs';

@Injectable()
export class SearchService {

  searchTermStream = new Subject&lt;string&gt;();

  sendSearchTerm(term: string) {
    this.searchTermStream.next(term)
  }

}
</code></pre>

<p>and this is the new interface SearchSpec that I added to enforce typing:</p>

<pre><code>export interface SearchSpec {
  term: string,
  page: number
}
</code></pre>
","1028679","","1028679","","2018-09-07 20:52:16","2019-09-16 10:05:31","Angular 6 & rxjs6 - piped operators - Type 'Observable<>' provides no match for the signature","<angular><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"52232088","1","52233139","","2018-09-08 04:44:01","","0","50","<p>I'm using RxJS v6, but this question applies to v5 as well.</p>

<p>When using <code>mergeMap</code>, my original array disappears and while I can do a number of operations in parallel, I no longer have a way of monitoring when all those observables I sent into <code>mergeMap</code> are complete.</p>

<h1>Example</h1>

<pre class=""lang-js prettyprint-override""><code>of([1, 2, 3, 4])
.pipe(
    mergeMap(values =&gt; values),
)
.subscribe(console.log)

// 1
// 2
// 3
// 4
</code></pre>

<p>I'd like to see:</p>

<pre class=""lang-js prettyprint-override""><code>// [1, 2, 3, 4]
</code></pre>

<p>The only way I've come up with so far requires getting the length of the array, but I'm sure there's gotta be some operator I'm missing:</p>

<pre class=""lang-js prettyprint-override""><code>of([1, 2, 3, 4])
.pipe(
    switchMap(values =&gt; (
        of(values)
        .pipe(
            mergeMap(value =&gt; value),
            bufferCount(values.length),
        )
    ))
)
.subscribe(console.log)
</code></pre>
","1624862","","","","","2018-09-08 07:41:02","Combine a fixed number of mergeMapped observables - RxJS","<rxjs><observable><rxjs5><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52232956","1","52233373","","2018-09-08 07:17:11","","1","46","<blockquote>
  <p>I'm using RxJS v6, but the answer could apply to RxJS v5 as well.</p>
</blockquote>

<p>I'd like to make it so if I have say 8 values, I would only have 4 actively being processed at a time.</p>

<p>The code I have right now sends in 4 items, then waits till all 4 finish, then sends in the next 4. I'd like it to send in the first 4, then as an observable completes, another one comes in to be processed.</p>

<pre class=""lang-js prettyprint-override""><code>from([1, 2, 3, 4, 5, 6, 7, 8])
.pipe(
    bufferCount(4),
    concatMap(values =&gt; (
        from(values)
        .pipe(
            mergeMap(value =&gt; (
                timer(1000) // Async stuff would happen here
                .pipe(
                    mapTo(value),
                )
            )),
        )
    )),
)
.subscribe(console.log)
</code></pre>
","1624862","","","","","2018-09-08 08:13:09","How can I have only X observables active at a time?","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52244374","1","52244418","","2018-09-09 12:05:57","","1","291","<p>I am building an application using Firebase Auth (AngularFire) with Angular 6. I also have a MongoDB service for Role-Base-Access (RBA)</p>

<p>I need to do 3 things in order to resolve whether a user can access a URL path:</p>

<ol>
<li>Listen to the Firebase authState Observable for the current user</li>
<li>Fetch his latest token ID</li>
<li>Check MongoDB if the user is allowed access to the URL</li>
</ol>

<p>When all 3 pass, it should return true</p>

<p>I have studied Observables a bit but still feel confused, specially since I am using rxjs 6 and lots of links still refer to before-5.5</p>

<p>This is my canActivate function right now:</p>

<pre><code>canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) 
{

     return this.authService.user$.pipe(map (user =&gt; {

         //user.getIdToken() returns a Promise so I wrap it in an Observable
         return from(user.getIdToken());

     })).pipe(map( tokenValue =&gt; {

          //tokenValue is an Observable here 
          this.mongoDBService.validate(tokenValue, state.url);
     }));
}
</code></pre>

<p>I was expecting the second ""pipe"" to listen and receive the result of from(user.getIdToken())</p>

<p>Isn't that how it's supposed to work? If not, can someone please guide me how to chain these 2 observables together?</p>

<p>Thanks</p>
","150878","","","","","2018-09-09 12:11:26","Chain Observables and Promises","<angular><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"52254099","1","52254368","","2018-09-10 08:47:21","","0","32","<p>The service returns me an array with 40 objects but all I need in my app are the first 5. I've made some research and I found out that the operator that fit the case is Take, but it doesn't do anything: when I call the service, it returns me all the 40 elements.</p>

<p>What am I doing wrong?</p>

<p>In the service:</p>

<pre><code>getData(valueS): Observable&lt;any&gt; {
    return Observable.from(
        this.http.get&lt;any&gt;(`${this.URL}`)
    );
}
</code></pre>

<p>In my component's ts:  </p>

<pre><code>this.dataService.getData(this.valueSelected)
        .pipe(
            delay(1000),
            take(5)
        )
        .subscribe((res: any) =&gt; {
            this.dataContainer = res.main;
            console.log(res);
            console.log(this.dataContainer);
            this.buildWidget();
        });
</code></pre>
","5691255","","2829204","","2018-09-10 09:10:10","2018-09-10 09:10:10",".take() operator is not working on the Observables","<angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52259232","1","","","2018-09-10 13:47:23","","0","61","<p>The angular interceptor looks like this:</p>

<pre><code>public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

  catchError(err =&gt; {
      if (err instanceof HttpErrorResponse) {
          if (err.status === 401) {

              this.auth.getToken().subscribe((refreshOk: boolean) =&gt; {
                if (!refreshOk) {
                  this.router.navigate([""/login""]);
                }
              });
          }
      }

      return Observable.throw(err);
  })
);
</code></pre>

<p>The issue is that four different api call are made at once. So four getToken calls are made simultaneous. Only one call would be enough. How can i ensure that only one call is made at once?</p>
","5321299","","","","","2018-09-11 14:06:57","How can i ensure that only one call is made simultaneous with angular interceptor?","<angular><rxjs><angular-http-interceptors><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52271612","1","","","2018-09-11 08:17:44","","3","1244","<p>I'm writing chrome extension and decided to wrap everything into streams, mostly for training and take a look into rxjs.</p>

<p>So I’m stuck with such a problem. I have two streams, one stream is <strong><em>static</em></strong> <em>(don’t know how to correctly name it)</em> and one <strong><em>dynamic</em></strong>.</p>

<p>A static stream is that one who emits value only when you subscribe to it (<strong>getPath$</strong>), it return value from a chrome storage. 
A dynamic (<strong>message$</strong>) stream is a stream which listening for events(messages). </p>

<p>So my goal is somehow to merge this two stream and every time when I’m receiving a message from <strong>message$</strong> get value from a <strong>getPath$</strong> and make some calculations based on two values.</p>

<pre><code>type Handler = (
    message: any, 
    sender: any, 
    sendResponse: (response: any) =&gt; void
) =&gt; void; 

type Values  = string | string[];

const getValues = (values: Values) =&gt; (cb) =&gt; chrome.storage.local.get(values, cb) 
const getPathBinded = bindCallback(getValues('path')) 
const getPath$ = getPathBinded() 

const message$ = fromEventPattern( 
   (handler: Handler) =&gt; chrome.runtime.onMessage.addListener(handler), 
   (handler: Handler) =&gt; chrome.runtime.onMessage.removeListener(handler), 
   (message, sender, sendResponse) =&gt; ({ message, sender, sendResponse }) 
).pipe( 
    map(
       ({ message }) =&gt; message
    ) 
) 
</code></pre>

<p>I found how to do this in such a way:</p>

<pre><code>message$.pipe( 
    switchMap( 
        _ =&gt; getPath$, 
        (oV, iV) =&gt; {
            //doing some calculation
        } 
    ) 
 )
</code></pre>

<p>Or </p>

<pre><code>combineLatest(
  message$,
  getPath$,
).pipe(
    map((a, b) =&gt; {
       //doing some calculation
    })
)
</code></pre>

<p>Seems like it's working, but it feels like I am doing wrong. Any suggestions or how to do it following best approaches? Also, please correct me in definitions.</p>

<p><strong>UPD</strong>
Here the full <a href=""https://gist.github.com/dmfilipenko/afb4559d5be3cf02aa0d05888fe66330"" rel=""nofollow noreferrer"">code: https://gist.github.com/</a>
And the latest version which is work</p>

<pre><code>const merged$ = message$.pipe(
   switchMap(sendedPath =&gt; combineLatest(
        path$,
        unit$
    ).pipe(
        map(([path, unit]) =&gt; [sendedPath, path, unit]))
    )
)
</code></pre>
","401047","","401047","","2018-09-18 12:46:41","2018-09-18 12:46:41","How to merge ""static"" observable with ""dynamic"" in rxjs 6?","<typescript><google-chrome-extension><rxjs><rxjs6>","2","3","1","","","CC BY-SA 4.0"
"52271989","1","","","2018-09-11 08:40:58","","3","1250","<p>While migrating application from Angular 5 to Angular 6 getting below error,</p>

<pre><code>Module '/node_modules/rxjs/observable/TimerObservable' has no exported member 'TimerObservable'.
</code></pre>

<p>Code:</p>

<pre><code>import { Injectable } from '@angular/core';
import { TimerObservable } from 'rxjs/observable/TimerObservable';
import { Observable } from 'rxjs';

@Injectable()
export class TimerTestScv {

    static fetchTimer(interval: number, initialDelay: number): Observable&lt;number&gt;         
    {
       return TimerObservable.create(initialDelay, interval);
    }
}
</code></pre>

<p>rxjs package used:</p>

<pre><code>""rxjs"": ""^6.2.2"",
</code></pre>
","7208895","","","","","2020-08-29 12:17:05","Module '/node_modules/rxjs/observable/TimerObservable' has no exported member 'TimerObservable' in Angular 6","<angular6><rxjs6>","2","0","0","","","CC BY-SA 4.0"
"52280012","1","52552595","","2018-09-11 16:03:16","","3","1959","<p>Let's imagine i have a function <code>fetchUser</code> which takes as parameter <code>userId</code> and return an <strong>observable of user</strong>. </p>

<p>As i am calling this method often, i want to <strong>batch</strong> the ids to perform one request with multiple ids instead !</p>

<p><em>Here my troubles began...</em> </p>

<p>I can't find a solution to do that without sharing an observable between the different calls of <code>fetchUser</code>.</p>

<pre><code>import { Subject, from } from ""rxjs""
import { bufferTime, mergeMap, map, toArray, filter, take, share } from ""rxjs/operators""

const functionThatSimulateAFetch = (userIds: string[]) =&gt; from(userIds).pipe(
    map((userId) =&gt; ({ id: userId, name: ""George"" })),
    toArray(),
)

const userToFetch$ = new Subject&lt;string&gt;()

const fetchedUser$ = userToFetch$.pipe(
    bufferTime(1000),
    mergeMap((userIds) =&gt; functionThatSimulateAFetch(userIds)),
    share(),
)

const fetchUser = (userId: string) =&gt; {
    const observable = fetchedUser$.pipe(
        map((users) =&gt; users.find((user) =&gt; user.id === userId)),
        filter((user) =&gt; !!user),
        take(1),
    )
    userToFetch$.next(userId)
    return observable
}
</code></pre>

<p>But that's ugly and it has multiple troubles:</p>

<ul>
<li>If i unsubscribe from the observable returned by <code>fetchUser</code> before the timer of <code>bufferTime</code> is finished, it doesn't prevent the fetch of the user. </li>
<li>If i unsubscribe from all the observables returned by <code>fetchUser</code> before the fetch of the batch is finished, it doesn't cancel the request.</li>
<li>Error handling is more complex</li>
<li>etc</li>
</ul>

<p>More generally: i don't know how to solve the problems requiring <strong>sharing resources</strong> using RxJS. It's difficult to find advanced example of RxJS. </p>
","3292234","","5801495","","2018-09-11 16:59:52","2019-09-21 07:24:09","RxJS: Batch requests and share response","<javascript><typescript><rxjs><rxjs6>","4","2","4","","","CC BY-SA 4.0"
"52281650","1","","","2018-09-11 17:56:45","","0","275","<p>This seems like it should be a fairly common pattern, so I'm hoping someone can help.</p>

<p>I'm trying to expose an Observable of ""Things"" via an Angular service.  My service will need to first fetch the list of Things, then listen for new Things added.  So I have two different service requests to make, but I'm trying to wrap them both up in a single Things observable so that the consuming component doesn't have to worry about the internals.</p>

<p>So, it looks something like this:</p>

<pre><code>export class MyService {

  constructor(private commService: CommService){}

  get things(): Observable&lt;Things[]&gt; {

    // how can I get the initial list of things, then listen for updates?

    //THIS DOESN'T WORK
    return merge(commService.getAllInitialThings(), commService.listenToThingAdded());
  }

}

export class CommService{

  getAllInitialThings(): Observable&lt;Things[]&gt; { //etc }

  listenToThingAdded(): Observable&lt;Thing&gt; { //etc  }
 }
</code></pre>

<p>I've made some attempts at using concat and merge, but I dont know how to </p>

<ol>
<li>Ensure that getThings() completes first </li>
<li>Update the things property, since it's an observable</li>
</ol>

<p>Note that the listenToThingAdded may never occur, but I would still need to return the initial list of Things.</p>
","3632838","","3632838","","2018-09-11 18:43:07","2018-09-11 19:02:46","RxJS: Update An Observable From Multiple Streams","<angular><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52285923","1","52286050","","2018-09-12 00:41:57","","0","192","<p>I have two calls to the backend and I need handle result only when both responses will be ready:</p>

<pre><code>this.historyService.fetchBalance().subscribe((balance: Balance[]) =&gt; {
    this.servicesBalance = balance;
});

this.historyService.fetchOuts().subscribe((outs: History[]) =&gt; {
    this.outHistories = outs;
});
</code></pre>

<p>I know <code>forkJoin</code> method but it returns Array and I lost types, something like this:</p>

<pre><code>...subscribe([v1, v2] =&gt; ...)
</code></pre>

<p>I want to save types of returning values something like this:</p>

<pre><code>...subscribe(balance: Balance[], outs: History[] =&gt; ...)
</code></pre>

<p>How to union Observables in my case?</p>

<pre><code>myQuestionUnionMethod(
    this.historyService.fetchBalance(),
    this.historyService.fetchOuts()
)
    .subscribe(balance: Balance[], outs: History[] =&gt; ...)
</code></pre>
","7548062","","","","","2018-09-12 01:08:18","How to union two Observable. Rx 6.2.2","<typescript><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52288338","1","","","2018-09-12 05:56:35","","1","761","<p>I was upgrading my angular app to version 4 to 6. this is my package.</p>

<p><strong>json file:</strong></p>

<pre><code>{
  ""version"": ""0.10.50"",
  ""license"": ""MIT"",
  ""angular-cli"": {},
  ""scripts"": {
    ""ng"": ""ng"",
    ""start"": ""node ./public-token/index.js &amp;&amp; npm run delete &amp;&amp; ng serve"",
    ""test"": ""ng test"",
    ""lint"": ""ng lint"",
    ""e2e"": ""ng e2e"",
    ""build"": ""rm -rf dist/ &amp;&amp; webpack"",
    ""unit"": ""node ./public-token/index.js &amp;&amp; ng test""
  },
  ""dependencies"": {
    ""@angular/animations"": ""6.1.7"",
    ""@angular/cdk"": ""^6.4.7"",
    ""@angular/common"": ""6.1.7"",
    ""@angular/compiler"": ""6.1.7"",
    ""@angular/compiler-cli"": ""6.1.7"",
    ""@angular/core"": ""6.1.7"",
    ""@angular/flex-layout"": ""^6.0.0-beta.18"",
    ""@angular/forms"": ""6.1.7"",
    ""@angular/http"": ""6.1.7"",
    ""@angular/material"": ""^6.4.7"",
    ""@angular/platform-browser"": ""6.1.7"",
    ""@angular/platform-browser-dynamic"": ""6.1.7"",
    ""@angular/platform-server"": ""6.1.7"",
    ""@angular/router"": ""6.1.7"",
    ""@swimlane/ngx-datatable"": ""13.1.0"",
    ""acorn"": ""^4.0.7"",
    ""amazon-cognito-identity-js"": ""1.31.0"",
    ""angular-in-memory-web-api"": ""0.4.6"",
    ""angular2"": ""2.0.0-beta.21"",
    ""angular2-jwt"": ""0.2.3"",
    ""angular2-toaster"": ""^6.1.0"",
    ""angular2-virtual-scroll"": ""0.3.2"",
    ""aws-sdk"": ""2.188.0"",
    ""bin"": ""file:public-token"",
    ""core-js"": ""2.4.1"",
    ""file-saver"": ""1.3.3"",
    ""fuse.js"": ""3.2.1"",
    ""hammerjs"": ""^2.0.8"",
    ""jquery"": ""^3.3.1"",
    ""ng2-cookies"": ""1.0.12"",
    ""ng2-material-dropdown"": ""^0.10.1"",
    ""ng2-mock-server"": ""0.0.4"",
    ""ng2-modal"": ""0.0.25"",
    ""ng2-select"": ""2.0.0"",
    ""ng2-toastr"": ""4.1.2"",
    ""ngx-chips"": ""^1.9.7"",
    ""ngx-tooltip"": ""0.0.9"",
    ""ngx-tooltip-selectable"": ""0.1.22"",
    ""rxjs"": ""6.3.2"",
    ""rxjs-compat"": ""6.3.2"",
    ""ts-helpers"": ""1.1.1"",
    ""typescript"": ""2.9.1"",
    ""underscore"": ""^1.9.1"",
    ""zone.js"": ""0.8.26""
  },
  ""devDependencies"": {
    ""@angular-devkit/build-angular"": ""0.8.1"",
    ""@angular/cli"": ""^6.2.1"",
    ""@types/jasmine"": ""2.5.38"",
    ""@types/node"": ""6.0.42"",
    ""codelyzer"": ""2.1.1"",
    ""gulp"": ""3.9.1"",
    ""gulp-flatten"": ""0.3.1"",
    ""gulp-inject"": ""4.2.0"",
    ""gulp-order"": ""1.1.1"",
    ""jasmine-core"": ""2.5.2"",
    ""jasmine-spec-reporter"": ""2.5.0"",
    ""karma"": ""1.2.0"",
    ""karma-chrome-launcher"": ""2.0.0"",
    ""karma-cli"": ""1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""0.2.0"",
    ""karma-jasmine"": ""1.0.2"",
    ""node-sass"": ""4.5.3"",
    ""protractor"": ""~5.1.0"",
    ""raw-loader"": ""0.5.1"",
    ""sass-loader"": ""6.0.5"",
    ""ts-node"": ""1.2.1"",
    ""tslint"": ""4.5.1""
  }
}
</code></pre>

<p>And When I am using <strong>npm run start</strong>. I am getting this error in the javascript console.
{</p>

<p>core.js:1673 ERROR Error: Uncaught (in promise): TypeError: Observable_1.Observable.defer is not a function</p>

<pre><code>TypeError: Observable_1.Observable.defer is not a function
    at AuthHttp.push../node_modules/angular2-jwt/angular2-jwt.js.AuthHttp.request (angular2-jwt.js:140)
    at AuthHttp.push../node_modules/angular2-jwt/angular2-jwt.js.AuthHttp.requestHelper (angular2-jwt.js:104)
    at AuthHttp.push../node_modules/angular2-jwt/angular2-jwt.js.AuthHttp.post (angular2-jwt.js:154)
    at new BackendService (backend.service.ts:35)
    at _createClass (core.js:8431)
    at _createProviderInstance (core.js:8393)
    at resolveNgModuleDep (core.js:8356)
    at NgModuleRef_.push../node_modules/@angular/core/fesm5/core.js.NgModuleRef_.get (core.js:9064)
    at resolveDep (core.js:9429)
    at createClass (core.js:9309)
    at AuthHttp.push../node_modules/angular2-jwt/angular2-jwt.js.AuthHttp.request (angular2-jwt.js:140)
    at AuthHttp.push../node_modules/angular2-jwt/angular2-jwt.js.AuthHttp.requestHelper (angular2-jwt.js:104)
    at AuthHttp.push../node_modules/angular2-jwt/angular2-jwt.js.AuthHttp.post (angular2-jwt.js:154)
    at new BackendService (backend.service.ts:35)
    at _createClass (core.js:8431)
    at _createProviderInstance (core.js:8393)
    at resolveNgModuleDep (core.js:8356)
    at NgModuleRef_.push../node_modules/@angular/core/fesm5/core.js.NgModuleRef_.get (core.js:9064)
    at resolveDep (core.js:9429)
    at createClass (core.js:9309)
    at resolvePromise (zone.js:814)
    at resolvePromise (zone.js:771)
    at zone.js:873
    at ZoneDelegate.push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invokeTask (zone.js:421)
    at Object.onInvokeTask (core.js:3815)
    at ZoneDelegate.push../node_modules/zone.js/dist/zone.js.ZoneDelegate.invokeTask (zone.js:420)
    at Zone.push../node_modules/zone.js/dist/zone.js.Zone.runTask (zone.js:188)
    at drainMicroTaskQueue (zone.js:595)}
</code></pre>

<p>I think this is happening because of some package version is not getting updated from my part? And please let me know how can I improve my question formatting? This is my first question on stackOverflow. Thanks.</p>
","6603988","","6603988","","2018-09-12 06:50:12","2018-09-12 06:53:51","ERROR:Observable_1.Observable.defer is not a function Angular2","<javascript><angular><rxjs><angular6><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52291095","1","52318736","","2018-09-12 08:47:44","","0","79","<p>I am currently working on a file uploading method which requires me to limit the number of concurrent requests coming through.</p>

<p>I've begun by writing a prototype to how it should be handled</p>

<pre><code>const items = Array.from({ length: 50 }).map((_, n) =&gt; n);
from(items)
  .pipe(
    mergeMap(n =&gt; {
      return of(n).pipe(delay(2000));
    }, 5)
  )
  .subscribe(n =&gt; {
    console.log(n);
  });
</code></pre>

<p>And it did work, however as soon as I swapped out the <code>of</code> with the actual call. It only processes one chunk, so let's say 5 out of 20 files</p>

<pre><code>from(files)
  .pipe(mergeMap(handleFile, 5))
  .subscribe(console.log);
</code></pre>

<p>The <code>handleFile</code> function returns a call to my custom ajax implementation </p>

<pre><code>import { Observable, Subscriber } from 'rxjs';
import axios from 'axios';

const { CancelToken } = axios;

class AjaxSubscriber extends Subscriber {
  constructor(destination, settings) {
    super(destination);
    this.send(settings);
  }

  send(settings) {
    const cancelToken = new CancelToken(cancel =&gt; {
      // An executor function receives a cancel function as a parameter
      this.cancel = cancel;
    });
    axios(Object.assign({ cancelToken }, settings))
      .then(resp =&gt; this.next([null, resp.data]))
      .catch(e =&gt; this.next([e, null]));
  }

  next(config) {
    this.done = true;
    const { destination } = this;
    destination.next(config);
  }

  unsubscribe() {
    if (this.cancel) {
      this.cancel();
    }
    super.unsubscribe();
  }
}

export class AjaxObservable extends Observable {
  static create(settings) {
    return new AjaxObservable(settings);
  }

  constructor(settings) {
    super();
    this.settings = settings;
  }

  _subscribe(subscriber) {
    return new AjaxSubscriber(subscriber, this.settings);
  }
}
</code></pre>

<p>So it looks something like this like</p>

<pre><code>function handleFile() {
  return AjaxObservable.create({
    url: ""https://jsonplaceholder.typicode.com/todos/1""
  });
}
</code></pre>

<p><a href=""https://codesandbox.io/s/2wpr3n12vn"" rel=""nofollow noreferrer"">CodeSandbox</a></p>

<p>If I remove the concurrency parameter from the merge map function everything works fine, but it uploads all files all at once. Is there any way to fix this?</p>
","5716739","","6558042","","2018-09-12 19:21:13","2018-09-13 17:17:43","Inconsitant mergeMap behaviour","<javascript><ajax><rxjs><rxjs6>","1","5","","","","CC BY-SA 4.0"
"52292377","1","52292757","","2018-09-12 09:55:32","","2","932","<p>I have the following two functions in Angular 6:</p>

<pre><code>http1() {
    return this.http.post&lt;any&gt;('/url1').subscribe(() =&gt; console.log(1));
}

http2() {
    return this.http.post&lt;any&gt;('/url2').subscribe(() =&gt; console.log(2));
}
</code></pre>

<p>Now, I want to subscribe to both Observables with zip, and perform an action on completion of both:</p>

<pre><code>Observable.zip([http1(), http2()]).subscribe(() =&gt; console.log(3));
</code></pre>

<p>In this example, <code>3</code> is not printed in the console, only <code>1</code>, and <code>2</code>. I need the three of them to be printed, how to achieve that?</p>
","1362485","","","","","2018-09-12 10:29:14","Perform an action on Observable zip subscription","<angular><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"52302074","1","","","2018-09-12 19:24:17","","0","124","<p>I have a Observable of service data which return true or false value ,when call the servive which returns</p>

<pre><code> let m =this.myService.checkCapabilityOf(constantvalue);
console.log(m);
</code></pre>

<p><a href=""https://i.stack.imgur.com/ePWmN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ePWmN.png"" alt=""enter image description here""></a></p>

<p>below format<a href=""https://i.stack.imgur.com/oHR6e.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oHR6e.png"" alt=""enter image description here""></a>
<a href=""https://i.stack.imgur.com/wn0UF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wn0UF.png"" alt=""enter image description here""></a></p>

<p>Here in the observable value it return false,
I need to get the value 
so i have subscribe the observable.</p>

<pre><code>let m =this.myService.checkCapabilityOf(constantvalue).subscribe(value =&gt; value);
console.log(m);
</code></pre>

<p>But it returns below format , howto get a value from observable<a href=""https://i.stack.imgur.com/aAzZO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aAzZO.png"" alt=""enter image description here""></a></p>
","4031891","","","","","2018-09-12 20:42:53","How to get a value from Observable","<angular><rxjs><angular6><rxjs6>","1","3","","2018-09-13 07:23:56","","CC BY-SA 4.0"
"52310878","1","52311015","","2018-09-13 09:37:45","","2","211","<p><strong>Scenario :</strong></p>

<ul>
<li>New to Angular<br>Trying to <strong>migrate Angular 2 code into Angular 6</strong>. </li>
<li>Any idea how I
can rewrite the following code in angular 6</li>
</ul>

<p><br>
<strong>Code To write in Angular 6 :</strong> </p>

<pre><code>return this._http.post(this.apiBaseUrl + ""/api/login"", body, options)
   .timeoutWith(Constant.timeout, Observable.throw(new Error(Constant.timeoutMsg)))
      .map(response =&gt; {
            const result = response.json() as LoginResultModel;

            if (result.AccessToken != null) {
                this.setLoginToken(result);
                return result;
            } else {
                return response;
            }
        });
</code></pre>
","3287334","","721644","","2018-09-13 12:22:04","2018-09-13 12:22:04","Convert Rxjs code to Angular 6 and latest rxjs","<angular><rxjs><angular6><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52322208","1","","","2018-09-13 21:44:42","","0","225","<p>I tried to make RxJS epic which will basically do loop over an API end point and concatenate results into one big array, due to fact that API allows maximum of 100 elements as response I want to collect all elements and ideally sort them before I put it as payload to redux </p>

<pre><code>const fetchData = action$ =&gt;
action$.pipe(
    ofType(FETCH_DATA),
    mergeMap(action =&gt;
        ajax(`localhost:8001/data?page=${action.payload.pages}&amp;per_page=${MAX_PER_PAGE}`).pipe(
            map(datas =&gt; fetchDataSuccess(datas)),
            retry(2),
            catchError(error =&gt; of(fetchDataFailed()))
        )
    )
);
</code></pre>

<p>this snippet works and I made a work around in my component where I basically do iteration over page numbers and call this fetch data for each page number, I do not like this but didn't found what would be better approach to do this in epic itself.</p>

<p>Tried also to dispatch additional action and do sort in reducer once when all pages are loaded, but I'm pretty sure that RxJS is more powerful and there is a way to do it directly in epic.</p>

<p>I'm pretty much idealess at this stage, anyone see some better way to do multi Ajax cals and combine all results into one big array?</p>
","16039","","","","","2018-09-13 21:44:42","The best way to do multiple ajax calls with RxJS6","<reactjs><redux><rxjs><redux-observable><rxjs6>","0","4","","","","CC BY-SA 4.0"
"52326419","1","","","2018-09-14 06:53:30","","1","69","<p>My component fetches data from a service in the following way:</p>

<pre><code>ngOnInit() {
    interval(5000)
    .pipe(
        startWith(0),
        switchMap(() =&gt; this.rawMaterialDataService.returnData())
    )
    .subscribe(data =&gt; {
        this.rawMaterialProductData = data;
    });
}
</code></pre>

<p>It then renders it into another component like so:</p>

<pre><code>&lt;section *ngFor='let stock of rawMaterialProductData trackBy:stock?.key'&gt;
    &lt;app-raw-material-view [stockGroupData]='stock'&gt;&lt;/app-raw-material-view&gt;
&lt;/section&gt;
</code></pre>

<p>The problem is that every time the data is re-fetched, the child component gets re-rendered, but not the parent component. I have put a console.log in the Init method of the child component, and every 5 seconds the log message gets triggered, meaning that the Init got run. </p>

<p>So the problem with this is that my child component has drop-down templates, that the user looks at, but every time the component re-renders the templates close back up to their initial state. </p>

<p>As you can see I tried <code>trackBy</code> to solve this issue, but it did not help.</p>

<p>-- Edit --</p>

<p>Here is the component that the data gets used in</p>

<pre><code>&lt;table (click)=collaps()&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th id='th1'&gt;{{stockGroupData.key}}&lt;/th&gt;
            &lt;div class=""topnav-right""&gt;
                &lt;th *ngIf=""!expandedIndex"" class='headingIcon'&gt; &lt;i class=""material-icons""&gt;expand_more&lt;/i&gt;&lt;/th&gt;
                &lt;th *ngIf=""expandedIndex"" class='headingIcon'&gt; &lt;i class=""material-icons""&gt;expand_less&lt;/i&gt;&lt;/th&gt;
            &lt;/div&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tr *ngIf=""!expandedIndex""&gt;
        Test
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre>
","5996109","","5996109","","2018-09-14 07:08:24","2018-09-14 07:08:24","Angular rxjs-interval operator (polling) redraws component view every time data is fetched","<angular><rxjs6>","0","8","","","","CC BY-SA 4.0"
"52332253","1","52338564","","2018-09-14 12:40:47","","1","54","<p>I have a <code>Subject</code> that is <code>next</code>'ed with a value before it has any subscribers - how do I make subscribers not miss values that got sent before the subscription?</p>

<p>Some code:</p>

<pre><code>subject = new Subject&lt;string&gt;;
subject.next('value');

// at a later time
subject.subsribe(val =&gt; {...});
</code></pre>
","5018962","","","","","2018-09-14 20:02:30","rxjs - Subject subscriber misses a value","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52334989","1","52341404","","2018-09-14 15:24:51","","1","121","<p>I've got following epic (btw. <a href=""http://thebestpageintheuniverse.net/c.cgi?u=epic"" rel=""nofollow noreferrer"">why epic</a>?)</p>

<pre><code>const fetchOrders = action$ =&gt; {
  console.log('fetchOrders', action$);
  return action$.pipe(
    ofType(FETCH_ORDERS),
    mergeMap(action =&gt; interval(2000).pipe(
      map(_ =&gt; ordersReceived(mockOrders()))
    ))
  );
};
</code></pre>

<p>where <code>ordersReceived</code> is an action creator meant to be run with paylod, <code>mockOrders</code> returns some mocked payload.</p>

<p>When I call <code>FETCH_ORDERS</code> action this epic starts then every 2seconds <code>ordersReceived</code> is dispatched and that's fine. But when I've fired this action again I've noticed that the ordersReceived being called more frequent, obviuosly I have created multiple instances that now fire separate actions. Now, is there a way that I could cancel previous epic call?</p>

<p><em>Edit</em>
I've found in the <a href=""https://redux-observable.js.org/docs/recipes/Cancellation.html"" rel=""nofollow noreferrer"">docs about cancellation</a> that I have to use another action that the epic will react e.g.</p>

<pre><code>const fetchOrders = (action$, state) =&gt; {
  console.log('fetchOrders', state);
  return action$.pipe(
    ofType(FETCH_ORDERS),
    mergeMap(action =&gt; interval(2001).pipe(
      map(_ =&gt; ordersReceived(cloneOrders())),


      takeUntil(action$.pipe(
        filter(action =&gt; action.type === FETCH_ORDERS_CANCELLED)
      ))


    ))
  );
};
</code></pre>

<p>then somewhere call <code>dispatch({type:FETCH_ORDERS_CANCELLED})</code>. </p>

<p>It is fine but I was thinking something more autononymous:) so the call to <code>fetchOrders</code> will stop anything previously called.</p>
","923340","","923340","","2018-09-14 16:05:28","2018-09-15 03:55:00","How to cancel epic to avoid multiple instances","<rxjs><redux-observable><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52345024","1","52345129","","2018-09-15 13:11:04","","0","1494","<p>I've created an app with user authentication system. Firstly I check if user with given registration e-mail exists and if does not - I call registration service.</p>

<p>register.component.ts</p>

<pre><code>registerUser(email: String, password: String) {
  let found = false;
  this.authService.findUser(email).pipe(
    tap(res =&gt; { console.log(res.status);
      if (res.status === 202) { found = true; } else if (res.status === 200) { found = false; } else {found = null; }}),
    concatMap(res =&gt; {
      console.log(found);
      if (found) {
        this.snackBar.open('E-mail already taken.', 'Ok', { duration: 3000 });
      } else if (!found) {
        this.authService.registerUser(email, password).subscribe(res2 =&gt; {
          /* CODE DOES NOT EXECUTE - START */
          console.log(res2.status);
          if (res2.status === 201) {
            this.router.navigate(['/list']);
          } else {
            this.snackBar.open('Unable to add new user.', 'Try later', { duration: 3000 });
          }
          /* CODE DOES NOT EXECUTE - END*/
        });
      } else {
        this.snackBar.open('Checking e-mail address failed.', 'Try later', { duration: 3000 });
      }
      return of(res);
    })
  ).subscribe();
}
</code></pre>

<p>The user is registered properly, but the marked code is not executed. <strong>In AuthService - {observe: 'response'} is added to both get (findUser) and post (registerUser) requests.</strong></p>
","6257570","","6257570","","2018-09-15 13:16:54","2018-09-15 13:27:42","Angular 6 - problem executing nested .subscribe() ""next"" function","<angular><observable><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52347048","1","52353296","","2018-09-15 17:14:35","","0","1533","<p><strong>Background:</strong></p>

<p>I am trying to write a message service with Rxjs and angular 6. I use a ReplaySubject to keep the sent messages, then subscriber even after message emited can get them. So the message can be cross different angular components.</p>

<p>I successfully implemented these, however, I meet a problem that for every new subscriber will get the all of messages in the ReplaySubject, I want to delete some particular messages in ReplaySubject. or even clear all the ReplaySubject.</p>

<p><strong>Question:</strong></p>

<ul>
<li><p>How can I delete some item inside a ReplaySubject? </p></li>
<li><p>If impossible, is there any work around?</p></li>
<li><p>If impossible nether, is there any way to create a new ReplaySubject, then copy the subscriber to the new ReplaySubject? so all subscriber can still receive messages.</p></li>
</ul>

<p>Many thanks.</p>
","8186927","","","","","2018-09-16 10:44:46","How Can I remove some element in a ReplaySubject in Rxjs?","<angular><rxjs6>","2","1","","","","CC BY-SA 4.0"
"52368064","1","","","2018-09-17 12:43:34","","5","316","<p>I want to asynchronously dispose of a resource in the <code>unsubscribe</code> function of an observable. For example:</p>

<pre><code>// rxjs 6
let observable = Observable.create(sub =&gt; {
    let resource = new Resource();
    return {
        async unsubscribe() {
            await resource.dispose();
        }
    }

};
</code></pre>

<p>The problem is that because the <code>unsubscribe</code> function isn't supposed to return a <code>Promise</code>, nothing will await it so the <code>unsubscribe</code> function will be ""over early"", before the resource is fully disposed of. This can cause behavior that shouldn't happen while the resource is being disposed of.</p>

<p>How do I deal with this?</p>
","1333004","","","","","2018-09-17 16:05:48","Dispose of a resource asynchronously in the unsubscribe function","<javascript><rxjs><rxjs6>","1","4","","","","CC BY-SA 4.0"
"52370506","1","52370968","","2018-09-17 14:54:43","","16","8265","<p>Can anyone help with the scenario where <code>this._getReactions$.next()</code> not working whenever <code>this.http.get(...)</code> gets an error. I want to keep observable alive to take the next input.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>private _getReactions$: Subject&lt;any&gt; = new Subject();

 constructor() {
  this._getReactions$
  .pipe(
    switchMap(() =&gt; {
        return this.http.get(...)
        // http request 
    }),
    catchError(error =&gt; {
      console.log(error);
      return empty();
    })
  )
  .subscribe(data =&gt; {
      console.log(data)
      //results handling
  });
 }</code></pre>
</div>
</div>
</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>onClick() {
  this._getReactions$.next();
}</code></pre>
</div>
</div>
</p>
","7110325","","","","","2021-04-27 11:46:35","How to keep observable alive after error in RxJS 6 and Angular 6","<angular><rxjs><angular6><rxjs6>","2","3","5","","","CC BY-SA 4.0"
"52379922","1","52380029","","2018-09-18 06:07:25","","0","83","<p>I want to start polling when the value of atrribute becomes true, is there any method to start  to poll when the flag becomes true, right now my implementation is :</p>

<pre><code> ngOnInit(){
        //want to start when startedPoll becomes true otherwise dont
        let url = 'getStatus'
        this.pollingSubscribe = interval(5000).pipe(
          switchMap(() =&gt; this.http.getCall(url))
        ).subscribe(data =&gt; {
          if(data['success']) {
            this.pollingData =data['result']

            this.processData(this.pollingData)
          }

        }, error =&gt;{
          this.error = true;
          this.errorData = this.createPollingFiles;
        })
      }

startPoll(){
  this.startedPoll = true;
}
</code></pre>

<p>when <strong><em>startedPoll</em></strong> becomes <strong>true</strong> start to poll data, please don't suggest the <strong>if and else</strong> implementation</p>
","4281964","","","","","2018-09-18 10:32:57","Start polling when flag becomes true","<angular><observable><rxjs6>","1","1","1","","","CC BY-SA 4.0"
"52383286","1","","","2018-09-18 09:25:57","","0","375","<p>I have to upgrade Angular5 code to Angular6, but I have an issue with the static combineLatest.</p>

<pre><code>export function test&lt;T&gt;(id: string | Observable&lt;string&gt;): OperatorFunction&lt;T[], T&gt; {

const id$ = asObservableIfNot(id);
return pipe(
  combineLatest(id$, (collection: T[], resolvedId) =&gt; {
    return collection.find(element =&gt; {
      return element.id === resolvedId;
    });
  }),
  distinctUntilChanged()
 );
}
</code></pre>

<p>In this case the combineLatest is import from rxjs/operators and return an OperatorFunction, but the static one return an Observable.</p>

<p>How can I convert this code in angular6 ?</p>
","10379442","","","","","2018-09-18 13:11:41","Angular6 no pipeable combineLatest","<angular6><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"52392834","1","","","2018-09-18 18:45:54","","0","1141","<p>I have an Observable which return as observable of data and that is binding with async using HTML.</p>

<p>here I have called the service.</p>

<pre><code>this.ProductOptions = this.ProductService.fetchProduct();
</code></pre>

<p>In HTML we have binding as </p>

<pre><code>Productoptions | async.
</code></pre>

<p>It's working fine.</p>

<p>In another function call, I have filtered based on product name, but it's not working.</p>

<pre><code>getCategory() {
  const productListOptions = this.productOptions.pipe(
    switchMap((itemList: BindingModel[]) =&gt; itemList.filter(product =&gt; product.name !== ""Active"")));

  console.log(this.productListOptions);
}
</code></pre>

<p><code>this.productOptions</code> shows below in console.</p>

<p><a href=""https://i.stack.imgur.com/ZSnG0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ZSnG0.png"" alt=""enter image description here""></a></p>

<hr>

<p>But when I subscribe to the observable.</p>

<pre><code>this.productService.fetchproducts().subscribe(response =&gt; console.log(response));
</code></pre>

<p>I am getting below format</p>

<pre><code>[{id:1,name:""Active""},{id:1,name:""InActive""}]; i need to filter based on Active
</code></pre>
","4031891","","2622292","","2018-09-18 18:53:05","2018-09-18 19:10:33","How to filter Observable of array with rxjs 6 with async","<angular><angular6><angular2-services><rxjs5><rxjs6>","1","3","","","","CC BY-SA 4.0"
"52408401","1","","","2018-09-19 14:37:28","","0","42","<p>I'm looking for a more readable solution than the one I have.</p>

<p>I need:
1) Retrieve products from an API. They are an array of objs.
2) Filter those products based on category etc...
3) Paginate the products and return a paginated version of those products.</p>

<pre><code>ngOnInit() {

//This gets the products from the API 
    this.drinkSubscription = this.drinkService.getAllDrinks().subscribe(drinks =&gt; {

//Save products without pagination for other purposes
      this.allDrinks = drinks;

//Get the parameter to filter products
      this.paramSubscription =  this.route.params.subscribe((params: Params) =&gt; {

//Filter the products and return a filtered array
        const filteredDrinks = this.filterService.filter(drinks, params['filter'], params['name']);

//Sort products based on the selection
        this.sorterSubscription = this.sorter.initialize(filteredDrinks).subscribe(sortedDrinks =&gt; {

//Create a pager that holds the paginated drinks in a property
          this.pagerSubscription = this.pagerService.initializePaginatedItems(sortedDrinks, 10, 5)
                                  .subscribe(pager =&gt; {
                                    this.pager = pager;
                                    this.paginatedDrinks = pager.paginatedItems;
                                  });
        });
      });
    });
  }
</code></pre>

<p>The sorter and the pagination are BehaviorSubjects so that I can inject next() but I'm not positive about them...
You can see the level of indentation is quite high, and I was wondering if there's a way with RxJS to obtain the same results in a more readable way.</p>
","9803391","","","","","2018-09-20 05:56:18","RxJS: untangle nested observables","<javascript><stream><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"52410998","1","","","2018-09-19 17:07:51","","0","124","<p>I have this code</p>

<pre><code>this.store
  .select(s =&gt; s.pins)
  .pipe(filter(s =&gt; !s.loading))
  .subscribe(pinsState =&gt; {
    this.listItems = pinsState.pins;
  });
</code></pre>

<p><code>pins</code> is an array of objects.</p>

<p>I want to recalculate a value in each object in the array as I get the data. For instance:</p>

<pre><code>pins.calculatedval = calcnewval()
</code></pre>

<p>How do I use the <code>map</code> operator to do this? Or is there another operator I should use?</p>
","1247395","","20057","","2018-09-19 17:11:27","2018-09-19 17:17:46","Observable - add data with map?","<angular><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52413693","1","52413877","","2018-09-19 20:23:57","","1","9766","<p>I'm new to rxjs and pipes - and pulling my hair out trying to understand why I'm getting this typescript error: ""Argument of type Observable not assignable to parameter OperatorFunction"". Could someone please explain this to me?</p>

<p>The intent is to ask for ""Hello"", but have the data replaced by ""Bye"" as the data gets piped.</p>

<pre><code>  ngOnInit() {
    this.getHello()
      .pipe(this.getBye())
      .subscribe(data =&gt; console.log(data))
  }
  getHello() {
    return of(""Hello"")
  }
  getBye() {
    return of (""Bye"")
  }
}
</code></pre>
","4512657","","","","","2018-09-19 20:55:56","rxjs pipes: Argument of type Observable not assignable to parameter","<angular><rxjs6>","3","3","1","","","CC BY-SA 4.0"
"52421588","1","52428318","","2018-09-20 09:16:22","","5","320","<p>I am using the latest version of redux-observable and Rxjs i.e</p>

<pre><code>// My version
""redux-observable"": ""^1.0.0"",
""rxjs"": ""^6.3.2""
</code></pre>

<p>The store - middleware, setup looks like this: </p>

<pre><code>// Setting up middlewares
import { pingEpic } from './epics';
import pingReducer from './reducers/pingReducer';

import { combineReducers, createStore, applyMiddleware } from 'redux';
import { combineEpics, createEpicMiddleware } from 'redux-observable';

const rootReducer = combineReducers(pingReducer);
const rootEpic = combineEpics(pingEpic);

const epicMiddleware = createEpicMiddleware();

const store = createStore(rootReducer,
    applyMiddleware(epicMiddleware)
);

epicMiddleware.run(rootEpic);
export default store;
</code></pre>

<p>And my epic looks like this</p>

<pre><code>// pingEpic.js
import { mapTo } from 'rxjs/operator/mapTo';
import { ofType } from 'redux-observable';
export const pingEpic = action$ =&gt; action$.pipe(
    ofType('PING'),
    mapTo({ type: 'PONG' })
);
</code></pre>

<p>So when I executed the program for the first time I got the following error:</p>

<p><a href=""https://i.stack.imgur.com/t7UuS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/t7UuS.png"" alt=""enter image description here""></a></p>

<p>I googled it and <a href=""https://github.com/MurhafSousli/ngx-progressbar/issues/112#issuecomment-388332618"" rel=""nofollow noreferrer"">found a solution here</a> which says to install <code>rxjs-compat@6</code> (however it doesn't makes any sense) I installed that too! And then I ran into the following error:</p>

<p><a href=""https://i.stack.imgur.com/8urBG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8urBG.png"" alt=""enter image description here""></a>.</p>

<p>I don't know what/where am I doing wrong? Any help would be much appreciated!</p>

<p>Thanks</p>
","4475433","","4475433","","2018-09-20 14:41:39","2018-09-20 15:29:53","rxjs v6 / redux-observable v1.0.0: Operators not working in epic","<javascript><reactjs><react-redux><redux-observable><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52423934","1","","","2018-09-20 11:18:45","","1","197","<p>I have the following code in which I want the part inside the call to tap() to only be processed if there is no error, meaning the catchError() part was not invoked:</p>

<pre><code>myObservable$.pipe(
  switchMap(a =&gt; of(this)),
  catchError((err: any) =&gt; {
    // Handle error here
  }),
  tap(result =&gt; {
    // I want to skip this code if error
  })
);
</code></pre>

<p>How can I skip the code inside the tap () part of the stream?  Is this possible, or is tap() just not designed that way?</p>
","1511335","","","","","2018-09-20 11:18:45","In RxJS 6, how can I skip the tap() part of the stream if an error is caught","<rxjs><rxjs6>","0","2","","","","CC BY-SA 4.0"
"52429667","1","","","2018-09-20 16:41:35","","0","33","<p>I have a service call and fetch the service and getting the result.while running the application with type , i am getting below error.</p>

<p>Error is ProductTypes property Does not exist on DataModel.</p>

<p>if i provide any in the below line working fine i have change to this</p>

<pre><code>   return this.http.get&lt;any&gt;(SERVICE_URL).pipe(
</code></pre>

<p>Error is in this line with type:</p>

<pre><code>  return res.ProductTypes.map((item:DataModel) =&gt; {
</code></pre>

<p>Service code:</p>

<pre><code>fetchProduct(): Observable&lt;DataModel[]&gt; {

    return this.http.get&lt;DataModel[]&gt;(SERVICE_URL).pipe(
      map(res =&gt; {
        return res.ProductTypes.map((item:DataModel) =&gt; {
          return this.Mapper(code, details);
        });
      }),
      catchError(error =&gt; this.handleError(error,'error'))
    );
  }
</code></pre>

<p>Model:</p>

<pre><code>  import { ProductType } from './product-type-model';

export class DataModel {
  code?: string;
  ProductTypes?: ProductType;
}
</code></pre>

<p>Json response from server</p>

<pre><code> {
    ProductTypes:[
      {
        ""code"":'',
        ""details"":'name'
      },
      {
        ""code"":'AS',
        ""details"":'Laptop'
      }
    ]
    }
</code></pre>
","4031891","","4031891","","2018-09-20 19:15:42","2018-11-02 14:46:49","Type: Property Does not exist on Model in RXJS 6 map with angular 6","<angular><angular5><angular6><angular2-services><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52430609","1","52430758","","2018-09-20 17:48:51","","7","4911","<p>What is the difference between <code>new Observable()</code> and <code>of()</code> in <code>RxJs</code>?</p>

<p>In my test cases when I try to return <code>new Observable()</code> it gives me a wired error and if I replace it with the <code>of()</code> from Rxjs it works fine.</p>

<p>My impression was <code>Observable.create()</code>, <code>new Observable()</code> and <code>of()</code> does same thing.</p>

<pre><code>someService.getMethod().pipe(
  ...
  catchError((e) =&gt; {
    // some operation
    // return new Observable(false as any);  // ----&gt; creates error
    return of(false as any); // this works perfectly
  })
)
</code></pre>
","537647","","537647","","2019-10-17 21:55:01","2019-10-17 21:55:01","what is the difference between ""new Observable()"" and ""of()"" in RxJs","<angular><rxjs><rxjs6>","1","0","4","","","CC BY-SA 4.0"
"52435199","1","","","2018-09-21 00:56:44","","0","1067","<p>I have an api call which returns data with <code>Observable&lt;User[]&gt;</code>  (where user is </p>

<pre><code>{id:string, status:string}
</code></pre>

<p>what I would like to do is to split the observable into two different observables, based on the status (active/inactive)</p>

<p>I googled and Stackoverflowed, but the only samples I could find only showed single-value arrays <code>[1,2,3,4]</code> etc</p>

<p>I tried to apply the same technique to the array of objects</p>

<pre><code>const foo = this.userApi
        .find()
        .pipe(partition(item =&gt; item.status === 'active'));
</code></pre>

<p>hoping that this would return <code>foo[0]</code> holding the active and <code>foo[1]</code> holding the inactive users</p>

<p>However, the vsCode editor complains about </p>

<pre><code>[ts]
Argument of type 'UnaryFunction&lt;Observable&lt;User[]&gt;, [Observable&lt;User[]&gt;, Observable&lt;User[]&gt;]&gt;' is not assignable to parameter of type 'OperatorFunction&lt;any, any&gt;'.
  Type '[Observable&lt;User[]&gt;, Observable&lt;User[]&gt;]' is not assignable to type 'Observable&lt;any&gt;'.
    Property '_isScalar' is missing in type '[Observable&lt;User[]&gt;, Observable&lt;User[]&gt;]'.
[ts] Property 'status' does not exist on type 'User[]'.
any
</code></pre>

<p>which implies that the <code>item</code> is an array ... </p>

<p>I also tried <code>groupBy</code> and hit the same problem</p>

<pre><code>const foo = this.userApi
        .find&lt;User&gt;()
        .pipe(groupBy(item =&gt; item.status));

[ts] Property 'status' does not exist on type 'User[]'
</code></pre>

<p>as you can probably tell, I'm no rxjs expert and have hit a wall at this point, and would appreciate any pointers</p>
","1542325","","","","","2020-04-28 10:37:52","split observable array into two observable arrays","<rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"52435848","1","","","2018-09-21 02:35:38","","4","136","<ul>
<li><p>in <code>rxjs5</code>(angular6 app), I use</p>

<pre><code>this.router.events
  .filter(event =&gt; event instanceof NavigationEnd)
  .map(() =&gt; this.activatedRoute)
  .map(route =&gt; {
    while (route.firstChild) {
      route = route.firstChild;
    }
    return route;`enter code here`
  })
  .filter(route =&gt; route.outlet === 'primary')
  .mergeMap(route =&gt; route.data)
  .subscribe((event) =&gt; {
    this.titleService.setTitle(event['title'] + '-' + APP_NAME);
    this.appDataLogic.urlChanged();
});
</code></pre></li>
<li><p>But in <code>rxjs6</code>, <code>route</code> is <code>{}</code> so that has error <code>property firstChild does not exist on type {}</code>.</p>

<pre><code>this.router.events.pipe(
  filter(event =&gt; event instanceof NavigationEnd),
  map(() =&gt; { return this.activatedRoute }).pipe(),
  map(route =&gt; {
    while (route.firstChild) {
      route = route.firstChild;
    }
    return route;
 }),
 filter(route =&gt; route.outlet === 'primary'),
 mergeMap(route =&gt; route.data)
 ).subscribe((event) =&gt; {
 this.titleService.setTitle(event['title'] + '-');
})
</code></pre></li>
<li><p>How do I rewrite it with rxjs6? thanks a lot.</p></li>
</ul>
","10394361","","4265225","","2018-09-21 03:16:46","2018-09-21 05:40:46","How do I register routing listening in rxjs6 and change the title?","<angular><router><rxjs6>","1","6","","","","CC BY-SA 4.0"
"52453356","1","","","2018-09-22 03:56:21","","1","192","<p>I have epic that debounce until it successfully call ping api. I tested successfully ping case. I'd like to use <code>import { TestScheduler } from 'rxjs/testing';</code> and test when I cannot ping to 1st call, but success in 2nd with marble diagram. is there any example?</p>

<pre><code>export const resendData = (action$, store$, {service}) =&gt; {
return action$
    .pipe(
    ofType(
        SOMETHING_FALL
    ),
    debounce(() =&gt; service.get('/api/ping').pipe(
        retryWhen(err =&gt;
        err.pipe(
            scan((acc, _) =&gt; acc * 2, 2),
            delayWhen(val =&gt; timer(val * 1000))
        )
        ),
        catchError(_ =&gt; empty())),
    ),
    map(_ =&gt; retryAction()),
    );
}
</code></pre>
","10394879","","10394879","","2018-09-23 02:50:49","2018-09-23 02:50:49","Test debounce with marble diagram","<rxjs><redux-observable><rxjs6>","0","2","0","","","CC BY-SA 4.0"
"52457021","1","","","2018-09-22 13:17:19","","1","22","<p>I have this methods which sends <code>http.post</code> message and returns an <code>Observable</code>. But I am a bit confused about how the program flow works. </p>

<p>Question 1 - Am I correct that in the following code, the <code>Observable</code> which is returned is the one from <code>finalize</code> and not the one from <code>http.post</code>?</p>

<p><code>http.post</code> returns an <code>Observable</code>. The <code>pipe</code> takes that <code>Observable</code> and creates a composition of operators (<code>tap</code>, <code>catchError</code> and <code>finalize</code>, each taking <code>Observable</code> from previous operator and returning a new <code>Observable</code>. The <code>Observable</code> returned in the end is the one from <code>finalize</code>.</p>

<pre><code>sendMessage(url:string, body:any,httpOptions){
        this.loaderService.show();
        let observable:Observable&lt;HttpEvent&lt;any&gt;&gt; = this.http.post(url,body,{
          headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
          withCredentials: true,
          observe: 'events', //what post should observe (look for). Here it means events. This could be body as well
          responseType: 'json' //responseType tells post how to interpret the body
        })
        return observable.pipe(tap((httpEvent:HttpEvent&lt;any&gt;) =&gt; {//tap transparently perform actions or side-effects, such as logging.
            if(httpEvent.type === HttpEventType.Response)
            {
              console.log('response from backend service:', httpEvent);
            }
            else {
              console.log(""not an http response"")
            }
              return httpEvent;

          })
          ,catchError(this.handleError)//error handler if Observable fails
          ,finalize(()=&gt; this.loaderService.hide()));
      }
</code></pre>

<p>Question 2 - If I subscribe to the <code>Observable</code> returned by <code>sendMessage</code> (above) then the error handler will not receive error notification because <code>catchError</code> has handled it. It I want the application to receive error then <code>handleError</code> function should explicitly throw an error</p>

<pre><code>sendMessage(...).subscribe(
next,
err, //this will not error notification unless catchError handler throws error
complete
)

private handleError (error: HttpErrorResponse) {

    let result:ServerResponseAPI = {result:""error"", ""additional-info"":error.message,['http-status']:error.status.toString(),['http-status-text']:error.statusText};
    return throwError(result); //catch by error handler mentioned in the subscribe method

  }
</code></pre>
","6703783","","472495","","2018-09-30 23:40:08","2018-09-30 23:40:08","How to understand this Observable recipe?","<rxjs6>","0","0","","","","CC BY-SA 4.0"
"52464729","1","52465052","","2018-09-23 09:18:28","","1","183","<p>I'm using <code>Angular 6</code> with <code>RxJS 6.2.2</code> and <code>RxJS Compact 6.2.2</code>.</p>

<p>I have a code to call my api service to load some records, which is:</p>

<pre><code>this.route.params
  .flatMap((params: Params) =&gt; {
    if (!params['id']) {
      return Observable.throwError('Id is not specified.');
    }

    this.itemId = params['id'];
    this.isEditMode = true;
    this.loadCategoryGroupCondition = new LoadCategoryGroupViewModel();
    this.loadCategoryGroupCondition.id = [this.itemId];
    this.loadCategoryGroupCondition.pagination = new Pagination();

    return this.categoryGroupService
      .loadCategoryGroup(this.loadCategoryGroupCondition);
  })
  .subscribe(
    (loadCategoryGroupResult: SearchResult&lt;CategoryGroup&gt;) =&gt; {
      console.log(loadCategoryGroupResult);
    },
    () =&gt; {},
    () =&gt; {
      console.log('Completed')
    });
</code></pre>

<p>The code above can print a list of my items returned from my api service. That means onSuccess has been called.</p>

<p>But the complete method is fired.
What is wrong with my code ?</p>

<p>Thank you, </p>
","3301076","","","","","2018-09-23 10:06:21","Subscribe onComplete never completes with flatMap","<javascript><angular><typescript><rxjs><rxjs6>","1","8","","","","CC BY-SA 4.0"
"52473872","1","","","2018-09-24 06:40:58","","0","84","<p>I have a service to manage logged in user. I have a second service that provides datasource for logged-in user's list items. Both services are singletons and (possibly) live longer than one users login.</p>

<p>I have this pattern reoccurring a lot:</p>

<pre><code>this._loggedInUserService.loggedInUserObservable.subscribe(loggedInUser: User =&gt; {

  // Remove old subscription
  if (this._subscription) {
    this._subscription.unsubscribe()
    this._subscription = null
  }

  if (loggedInUser) {
    this._subscription = this._otherService.getUserSpecificObservable(loggedInUser).subscribe(...)
  }

})
</code></pre>

<p>Now that I have read a bit about switchMap, is the following functionally equal with the code above? Is the subscription correctly ended if the user changes?</p>

<pre><code>this._loggedInUserService.loggedInUserObservable.pipe(
  switchMap(user =&gt; {
    if (user) {
      return this._otherService.getUserSpecificObservable(loggedInUser)
    } else {
      // What to return here?
    }
  })
).subscribe(...)
</code></pre>

<p>Also, what should I return in the else? I don't need the subscription to work at all in that case, so is it safe just to return null or undefined? Or should I return empty Observable (import { EMPTY } from 'rxjs')? (The code in subscribe does not need to be run if there is no active user.)</p>
","7740038","","","","","2018-09-24 20:50:15","rxjs can manual subscription handling be replaced with switchmap","<rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52481261","1","52481404","","2018-09-24 14:11:31","","0","635","<p>I want return a <code>Observable&lt;Car&gt;</code></p>

<pre><code>import { zip, Observable } from 'rxjs';

public createMedia(car: Car, dataUrl: string): Observable&lt;Car&gt; {
    const url = this.carDataService.createCar(car);
    const blob = this.dataUrlToBlob(dataUrl);
    const z = zip(url, blob);
    z.subscribe(val =&gt; this.saveData(val));
    return ...???(I want return Observable&lt;Car&gt; from saveData(val))
}

saveData(val): Observable&lt;Car&gt; {
  console.log('saveData =&gt; val 0: ' + val[0].id + ' val 1: ' + val[1]);
  return this.mediaDataService.saveBytes(val[0].id, val[1]);
}

const oMedia: Observable&lt;Car&gt; = this.createMedia(media);
oMedia.pipe(
  tap(media =&gt; console.log('Media created with id: ' + media.id)),
  map(media =&gt; this.setMediaId(step, media))
);
</code></pre>
","3535537","","3535537","","2018-09-24 14:34:56","2018-09-24 14:46:40","Angular 6 return Observable<Car> after a subscribe of RxJs zip","<angular><rxjs6>","1","4","","","","CC BY-SA 4.0"
"52483351","1","","","2018-09-24 16:10:34","","2","466","<p>I try to create an observable with Rx.Subject that will be subscribe by multiple components.</p>

<p>I have my WebsocketService :</p>

<pre><code>export class WebsocketService {
private ws = null;
private subject: Rx.Subject&lt;{}&gt;;

constructor() {
}

public connect(url): Rx.Subject&lt;{}&gt; {
    if (!this.subject) {
        this.subject = this.create(url);
        console.log('Successfully connected: ' + url);
    } else {
        console.log('Already connected: ' + url);
    }
    return this.subject;
}

private create(url): Rx.Subject&lt;MessageEvent&gt; {
    if (this.ws === null) {
        console.log('Connected to WS');
        this.ws = new WebSocket(url);
    } else {
        console.log('Already connected to WS');
    }

    const observable = Rx.Observable.create(
        (obs: Rx.Observer&lt;MessageEvent&gt;) =&gt; {
            this.ws.onmessage = obs.next.bind(obs);
            this.ws.onerror = obs.error.bind(obs);
            this.ws.onclose = obs.complete.bind(obs);
            return this.ws.close.bind(this.ws);
        });

    return Rx.Subject.create({}, observable);
}
}
</code></pre>

<p>And two components that subscribe int the same way :</p>

<pre><code>// ...
constructor(private stationService: StationService, private websocketService: WebsocketService) {

    websocketService.connect('ws://localhost:8080/ws')
        .subscribe(msg =&gt; {
            console.log(msg);
            console.log('[Dashboard] Response from websocket: ' + msg.data);
        });
}
// ...
</code></pre>

<p>And the second :</p>

<pre><code>// ...
constructor(private http: HttpClient, private websocketService: WebsocketService) {

    websocketService.connect('ws://localhost:8080/ws')
        .subscribe(msg =&gt; {
            console.log(msg);
            console.log('[Station] Response from websocket: ' + msg.data);

        });
}
// ...
</code></pre>

<p>We i refresh, the two components call my service :</p>

<p>Connected to WS websocket.service.ts:26:12
   Successfully connected: ws://localhost:8080/ws websocket.service.ts:17:12
   Already connected: ws://localhost:8080/ws</p>

<p>But when i send something one the socket i have only one subscriber that responde :</p>

<p>[Dashboard] Response from websocket: qwerty</p>

<p>Someone call help me to find my mistake ?</p>

<p>Thanks,</p>
","2064192","","","","","2018-09-25 07:22:09","Multiple subscribe to one Rx.Subject","<angular><websocket><rxjs><angular6><rxjs6>","1","3","2","","","CC BY-SA 4.0"
"52486786","1","53381715","","2018-09-24 20:20:29","","75","58754","<p>I'm working on an Angular 6 project.</p>
<p>Running <strong>ng lint</strong> gives the following Warning:</p>
<p>&quot;forkJoin is deprecated: resultSelector is deprecated, pipe to map instead&quot;</p>
<pre><code> forkJoin(...observables).subscribe(
</code></pre>
<p>Any idea? Can't seem to find any information about this deprecation.</p>
<p>I just generated a brand new Angular application &quot;ng new forkApp&quot; with Angular CLI: 6.1.5</p>
<p>source:</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { forkJoin } from 'rxjs';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  title = 'forkApp';

  constructor(private http: HttpClient) {}

  ngOnInit() {
    console.log('ngOnInit...');

    const obs = [];
    for (let i = 1; i &lt; 4; i++) {

      const ob = this.http.get('https://swapi.co/api/people/' + i);
      obs.push(ob);

    }

    forkJoin(...obs)
      .subscribe(
        datas =&gt; {
          console.log('received data', datas);
        }
      );

  }
}
</code></pre>
<p>&quot;dependencies&quot; section from package.json file:</p>
<pre><code>  &quot;dependencies&quot;: {
    &quot;@angular/animations&quot;: &quot;^6.1.0&quot;,
    &quot;@angular/common&quot;: &quot;^6.1.0&quot;,
    &quot;@angular/compiler&quot;: &quot;^6.1.0&quot;,
    &quot;@angular/core&quot;: &quot;^6.1.0&quot;,
    &quot;@angular/forms&quot;: &quot;^6.1.0&quot;,
    &quot;@angular/http&quot;: &quot;^6.1.0&quot;,
    &quot;@angular/platform-browser&quot;: &quot;^6.1.0&quot;,
    &quot;@angular/platform-browser-dynamic&quot;: &quot;^6.1.0&quot;,
    &quot;@angular/router&quot;: &quot;^6.1.0&quot;,
    &quot;core-js&quot;: &quot;^2.5.4&quot;,
    &quot;rxjs&quot;: &quot;^6.0.0&quot;,
    &quot;zone.js&quot;: &quot;~0.8.26&quot;
  },
</code></pre>
<p>Once all three GET requests are done I got all data in &quot;datas&quot; array.
The issue is that once I run: <code>ng lint</code> I got this:</p>
<p>C:\forkApp&gt;<strong>ng lint</strong></p>
<blockquote>
<p>WARNING: C:/forkApp/src/app/app.component.ts[26, 5]: forkJoin is
deprecated: resultSelector is deprecated, pipe to map instead</p>
</blockquote>
","2050306","","2050306","","2020-09-23 15:44:24","2021-02-01 13:01:57","forkJoin is deprecated: resultSelector is deprecated, pipe to map instead","<angular><rxjs6>","7","6","6","","","CC BY-SA 4.0"
"52487291","1","","","2018-09-24 20:58:50","","3","75","<p>I am reading the source code of <code>catchError</code>. I notice that it is defined as follows: It seems it takes as argument a function which takes two arguments and returns an <code>Observable</code> - <code>selector: (err: any, caught: Observable&lt;T&gt;) =&gt; ObservableInput&lt;R&gt;</code></p>

<pre><code>export function catchError&lt;T&gt;(selector: (err: any, caught: Observable&lt;T&gt;) =&gt; never): MonoTypeOperatorFunction&lt;T&gt;;
export function catchError&lt;T, R&gt;(selector: (err: any, caught: Observable&lt;T&gt;) =&gt; ObservableInput&lt;R&gt;): OperatorFunction&lt;T, T | R&gt;;
export function catchError&lt;T, R&gt;(selector: (err: any, caught: Observable&lt;T&gt;) =&gt; ObservableInput&lt;R&gt;): OperatorFunction&lt;T, T | R&gt; {
  return function catchErrorOperatorFunction(source: Observable&lt;T&gt;): Observable&lt;T | R&gt; {
    const operator = new CatchOperator(selector);
    const caught = source.lift(operator);
    return (operator.caught = caught as Observable&lt;T&gt;);
  };
}
</code></pre>

<p>But in the examples of usage of <code>catchError</code>, it seem to take a function with one argument <code>catchError(err =&gt; of[])</code>. How come the examples don't need the second argument <code>caught</code>?</p>
","6703783","","","","","2018-09-24 20:58:50","catchError seems to require two arguments instead of one","<rxjs6>","0","0","0","","","CC BY-SA 4.0"
"52492541","1","52509877","","2018-09-25 07:12:56","","1","1387","<p>After Migration of my application from angular 5 to 6, rxjs have been causing all sorts of issues. I used rxjs-compact during migration process and after removing it, since it cause greater memory utilization. I have been left with errors like this.</p>

<blockquote>
  <p>ERROR in ./node_modules/rxjs-compat/_esm5/add/operator/publishReplay.js
  Module build failed: Error: ENOENT: no such file or directory, open '/home/training/Desktop/vishnu/TemplateAppv6/node_modules/rxjs-compat/_esm5/add/operator/publishReplay.js'</p>
</blockquote>

<p>I have tried importing publishReplay from rxjs and rxjs/operators.</p>

<p>import { filter, map, catchError, publishReplay } from 'rxjs/operators';</p>

<p>But issues still persists, is there any change for publishReplay like catchError.</p>

<p>Any help would be appreciated.</p>

<p>Here is the full code </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';
import { Observable } from 'rxjs';

import { ErrorResponse } from '../core/interfaces/Error';

import { throwError, ReplaySubject } from 'rxjs';
import { filter, map, catchError, publishReplay } from 'rxjs/operators';

import 'rxjs/add/observable/forkJoin';

import { environment } from '../../environments/environment';
import { HomeConstants } from './home-consatant';
import { BaseService } from '../core/base.service';




                // Construct the rail data.
                responses.map((response: RailResponse) =&gt; {
                  railsData[response.railId] = response
                    .entries
                    .map((entry: EntriesEntity) =&gt; {
                      return {
                        imageSrc: this.getImageUrl(entry, response.railId), // Get rail image according to the rail type.
                        contentTypeLabel: entry.pricingType, // Content Type.
                        description: entry.title, // Rail title.
                        url: '/details/' + entry.programType + '/' +
                          this.utility.encodeProgramName(entry.title) + '/' + entry.id, // Rail url.
                        isPopoverVisible: true,
                        popoverTitle: entry.title,
                        popoverDescription: entry.title
                      };
                    });
                });
                return railsData;
              })
              .publishReplay(1, this.cacheInterval)
              .refCount()
              .take(1)
              .catchError((res: HttpErrorResponse) =&gt; throwError(res));
            this.rails.set(railParams[0].railId, this.railResponse);
          }
          return this.rails.get(railParams[0].railId);
        }
      } else {
        return null;
      }
    } else {
      return null;
    }
  }</code></pre>
</div>
</div>
</p>
","7755420","","7755420","","2018-09-26 04:41:14","2018-09-26 04:41:14","RXJS 6.0 : ERROR in ./node_modules/rxjs-compat/_esm5/add/operator/publishReplay.js","<angular><rxjs><migration><angular6><rxjs6>","2","4","1","","","CC BY-SA 4.0"
"52494691","1","52501006","","2018-09-25 09:21:14","","0","4097","<p>The transpiller complains of:</p>

<p>The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.</p>

<p>about this code:</p>

<pre><code>import { map } from  'rxjs/operators';

const multiply = num =&gt; map(value =&gt; value * num);
</code></pre>

<p>How can I fix it ?</p>
","3887366","","","","","2018-09-25 14:46:37","Typescript observable The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type","<typescript><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52496282","1","52515307","","2018-09-25 10:43:41","","2","3199","<pre><code>private save(payload) {

  const newMedias: Observable&lt;Media&gt;[] = [];
  const newMediaInStepIndex: number[] = [];

  (payload.formData.steps).forEach((step: Step, stepIndex: number) =&gt; {
    const media: Observable&lt;Media&gt; = this.createOneMedia(step);
    if (media !== undefined) {
      newMedias.push(media);
      newMediaInStepIndex.push(stepIndex);
    }
  });

  forkJoin(newMedias).subscribe(medias =&gt; {
    medias.forEach((media, i) =&gt; {
      console.log('Media created with id: ' + media.id + ' in step ' + newMediaInStepIndex[i]);
      payload.formData.steps[newMediaInStepIndex[i]].media[0].id  = media.id;
    });
  });

  return this.createRecipe(payload);
}
</code></pre>

<p>My problem is that the following line is executed asynchronously and therefore not before the return of the end:</p>

<pre><code>payload.formData.steps[newMediaInStepIndex[i]].media[0].id  = media.id;
</code></pre>

<p>so I need to do the return of the end once the end of the subscribe. I think we have to cut this function in half.</p>

<p><strong>IMPORTANT: return in save(payload)</strong></p>
","3535537","","3535537","","2018-09-26 10:14:01","2018-09-26 10:14:01","How to return value from subscribe of forkJoin with angular 6 and RxJs 6?","<angular><rxjs6>","3","2","","","","CC BY-SA 4.0"
"52498098","1","52502180","","2018-09-25 12:20:01","","0","70","<p>So I'm trying to build an ""autocomplete"" directive for a project that will query the API and display a list of results to select from. I have a component that displays a modal with a simple input box. I need to be able to type into the box to search Members, click on a member and add that to an array in the <strong>component</strong>.</p>

<p><strong>Edit:</strong>
The issue I'm having is that when I call <code>this.wlAutocomplete.next(value);</code>, it goes back into my component and makes the API call with the correct value from the input field, it doesn't return the data back to the directive to handle the response from the API there.</p>

<p><strong>StackBlitz Example:</strong> <a href=""https://stackblitz.com/edit/angular-11erew"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-11erew</a></p>

<p>The Component will track the array of selected members. I need to be able to:</p>

<ul>
<li>Call my API in the Component to get the data and return to the directive</li>
<li>The directive will need to read the data and display a list below the input box (I can do the HTML here)</li>
<li>Clicking a list item in the dropdown will send that selection <strong>back</strong> to the component to handle as it needs, eg. add it to an array.</li>
</ul>

<p>My component has a method:</p>

<pre class=""lang-js prettyprint-override""><code>queryMembers(value: string): Subscription {
  return this.memberService.query({ term: value, groupKey: this.group.groupKey })
    .subscribe((members) =&gt; {
      console.log(members);
      return this.searchMemberList = members;
    });
}
</code></pre>

<p>Which I'm using in the template like this:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;input (wlAutocomplete)=""queryMembers($event)"" class=""uk-search-input"" type=""search"" placeholder=""Search...""&gt;
</code></pre>

<p>Here is the code for the Directive:</p>

<pre class=""lang-js prettyprint-override""><code>@Directive({
  selector: 'input[wlAutocomplete]'
})
export class AutocompleteDirective {
  modelChanged: Subject&lt;string&gt; = new Subject&lt;string&gt;();
  subscription: Subscription;
  debounce: number = 500;

  constructor() {
    this.subscription =
      this.modelChanged
        .pipe(debounceTime(this.debounce))
        .subscribe(value =&gt; {
          this.wlAutocomplete.next(value); // I need to get the data from component method passed into `wlAutocomplete`
        });
  }

  @Output() wlAutocomplete: EventEmitter&lt;any&gt; = new EventEmitter();

  @HostListener('input', ['$event'])
  onChange($event) {
    this.modelChanged.next($event.target.value);
  }
}
</code></pre>
","3636177","","3636177","","2018-09-25 15:20:25","2018-09-25 15:49:07","Angular Access data from Component in Directive","<angular><typescript><rxjs><rxjs6>","1","6","","","","CC BY-SA 4.0"
"52499187","1","52499188","","2018-09-25 13:18:01","","7","4808","<p>I'm migrating from angular 5 to angular 6. When I make npm run build, I'm it is throw to the console the following error:</p>

<blockquote>
  <p>error TS2305: Module
  '""C:/PrjNET/Elevation3/FW/4.00/Mainline/Framework/Development/Client/ElevationJS/ngcore/.tmp/node_modules/rxjs/operator/map""'
  has no exported member 'map'.</p>
</blockquote>

<p>I'm importing <code>map</code> as follows:</p>

<pre><code>import { map} from 'rxjs/operator/map';
</code></pre>

<p>Any one knows how to solve this?</p>
","5148197","","","","","2019-12-05 14:35:21","Error: rxjs/operator/map has no exported member 'map'","<angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52501453","1","52501524","","2018-09-25 15:10:55","","1","101","<p>I am using RXJS 6 together with Angular 6 HttpClient and I am trying to execute two http calls sequentially.</p>

<ul>
<li>I need to <strong>return the result of the first call only</strong>. </li>
<li>The <strong>first call must be issued before the second</strong>.</li>
</ul>

<p>I thought of using the tap method as follows:</p>

<pre><code>someMethod(items: Item[]): Observable&lt;Item[]&gt; {
   const one = this.http.put&lt;{ items: Item[] }&gt;('urlOne', items);
   const two = this.http.put&lt;void&gt;('urlTwo', items);

   return one.pipe(
     mergeMap((res)=&gt; res.items),
     tap(two)
   );
}
</code></pre>

<p>Is there a better way? If so how?</p>
","536299","","310726","","2018-09-25 15:34:29","2018-09-25 15:34:29","Using RXJS to issue two sequential http calls and returning the result of the first one only","<angular><rxjs><angular-httpclient><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52502888","1","52503172","","2018-09-25 16:32:05","","1","500","<p>I have following epic:</p>

<pre><code>import {
  map,
  catchError,
  switchMap,
  takeUntil,
} from 'rxjs/operators';
import {
  FETCH_JOKES,
  jokesReceived,
  FETCH_JOKES_CANCELLED,
  jokesFetchFailed,
} from '../actions/jokes-action';
import { ofType } from 'redux-observable';
import { of, concat } from 'rxjs';
import { ajax } from 'rxjs/ajax';

const getJokes = () =&gt;
  ajax.getJSON('http://api.icndb.com/jokes/random?escape=javascript');

const fetchJokesEpic = action$ =&gt; {
  return action$.pipe(
    ofType(FETCH_JOKES),
    switchMap(() =&gt;
      getJokes().pipe(
        map(response =&gt; jokesReceived(response)),
        catchError((err, act) =&gt; of(jokesFetchFailed(err))),
        takeUntil(action$.pipe(ofType(FETCH_JOKES_CANCELLED)))
      )
    ),
  );
};

export default fetchJokesEpic;
</code></pre>

<p>whenever the <code>FETCH_JOKES</code> is dispatched this epic starts <code>ajax</code> call and on success dispatches <code>jokesReceived</code> action or on failure <code>jokesFetchFailed</code>.</p>

<p>I want to loop it so unless cancelled the endpoint will be called again after previous call will finish (success or failure).</p>

<p>I thought I could use another epic taht will react to <code>JOKES_RECEIVED</code> and <code>FETCH_JOKES_ERROR</code> actions and then dispatch <code>FETCH_JOKES</code> action that should start cricle again.</p>

<pre><code>import { ofType } from 'redux-observable';
import {
  delay,
  map,
} from 'rxjs/operators';
import {
  JOKES_RECEIVED,
  FETCH_JOKES_CANCELLED,
  FETCH_JOKES_ERROR,
  fetchJokes,
} from '../actions/jokes-action';

const pollJokes = (action$, state$) =&gt; {
  return action$.pipe(
    ofType(JOKES_RECEIVED, FETCH_JOKES_ERROR, FETCH_JOKES_CANCELLED),
    delay(2000),
    map(action =&gt; {
      console.log('pollJokes.map', action);
      if(action.type === FETCH_JOKES_CANCELLED)
      { 
        console.log(""Cancelled"")
        return { type: 'POLL_STOPPED' };
      }
      else {
        // loop
        return fetchJokes();
      }
    })
  );
};
export default pollJokes;
</code></pre>

<p>However this doesnt work when I dispatch <code>FETCH_JOKES_CANCELLED</code> action. The action stack looks like this:</p>

<pre><code>@INIT
FETCH_JOKES
JOKES_RECEIVED
FETCH_JOKES
JOKES_RECEIVED
...
FETCH_JOKES_CANCELLED
FETCH_JOKES
JOKES_RECEIVED
POLL_STOPPED
FETCH_JOKES
JOKES_RECEIVED
...
</code></pre>

<p>I've tried to add <code>takeUntil</code> to the <code>pollJokes</code> epic but with the same poor results</p>

<pre><code>const pollJokes = (action$, state$) =&gt; {
  return action$.pipe(
    ofType(JOKES_RECEIVED, FETCH_JOKES_ERROR, FETCH_JOKES_CANCELLED),
    delay(2000),
    map(action =&gt; {
      console.log('pollJokes.map', action);
      if(action.type === FETCH_JOKES_CANCELLED)
      { 
        console.log(""Cancelled"")
        return { type: 'POLL_STOPPED' };
      }
      else {
        // loop
        return fetchJokes();
      }
    }),


    takeUntil(action$.pipe(ofType(FETCH_JOKES_CANCELLED)))


  );
};
</code></pre>

<p>With this apporach the <code>pollJokes</code> epic stops working as soon as the <code>FETCH_JOKES_CANCELLED</code> is dispatched for the first time. Now I know that the epic completed on <code>takeUntil</code>.</p>

<p>What can I do to have this ""looping"" work? I could I guess implement a middleware that will actually invoke <code>fetchJokes</code> when <code>JOKES_RECEIVED</code> dispatched, but I was searching for a all-rxjs-solution,</p>
","923340","","","","","2018-09-25 16:48:53","How to loop epic call","<reactjs><react-redux><polling><redux-observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52504988","1","52532558","","2018-09-25 18:52:17","","2","373","<p>I'm using Redux Observable and need to solve a timing issue when firing off actions from epics.</p>

<p>I have an array of items that I want to loop over for making AJAX calls on each one. Immediately after receiving the AJAX response, I want to fire off some actions. After all of the AJAX responses come back for each item in the original array, I want to fire off more actions.</p>

<p>How can I get these actions to fire immediately after the <code>timer</code> expires even though the original array hasn't finished looping?</p>

<pre class=""lang-js prettyprint-override""><code>const someEpic = action$ =&gt; (
    action$
    .pipe(
        ofType(SOME_ACTION),
        switchMap(({ payload }) =&gt; (
            from(payload) // This is an array of items
            .pipe(
                mergeMap(() =&gt; (
                    timer(5000) // This is my AJAX call
                    .pipe(
                        map(loadedAction),
                    )
                )),
                toArray(),
                map(anotherAction),
            )
        ))
    )
)
</code></pre>
","7113321","","1624862","","2018-09-30 17:45:11","2018-09-30 17:45:11","Emit actions before `toArray` - Redux Observable","<rxjs><rxjs5><redux-observable><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"52508962","1","","","2018-09-26 02:09:30","","1","1560","<p>environment:</p>

<ul>
<li>rxjs6</li>
<li>es6</li>
</ul>

<p>I write a function called ""getStatus$"" to mock an async promise, and turned it to an observable.</p>

<p>When I subscribe it,it works fine.</p>

<p>But I put it into a pipe, it doesn't work.</p>

<p>What's the problem? </p>

<p>How to fix it?</p>

<p>Thanks~</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { from, interval } = rxjs
const { switchMap } = rxjs.operators

const getStatus$ = () =&gt; from(new Promise(res =&gt; {
	setTimeout(() =&gt; {
  	res('zdl')
  }, 1000);
}));
// 1s
// 'first zdl'
// It works
getStatus$().subscribe(str =&gt; console.log('first', str));

// It doesn't work
// nothing output
interval(1000).pipe(
  switchMap(getStatus$)
).subscribe(str =&gt; console.log('second', str));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.bootcss.com/rxjs/6.2.0/rxjs.umd.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Thanks to <a href=""https://stackoverflow.com/users/8618350/fan-cheung"">Fan Cheung</a>, two ways:</p>

<pre><code>interval(1000).pipe(
  mergeMap(getStatus$)
).subscribe(str =&gt; console.log('second', str));
// or
const getStatus$ = () =&gt; from(new Promise(res =&gt; {
    setTimeout(() =&gt; {
    res('zdl')
  }, 500);
}));
</code></pre>
","5465023","","5465023","","2018-09-26 03:17:55","2018-09-27 07:45:38","switchMap a Promise Observable doesn't work","<javascript><rxjs><rxjs6>","1","6","","","","CC BY-SA 4.0"
"52512360","1","","","2018-09-26 07:35:24","","2","686","<p>I have several observables request. 
Each observable request is recursive call and when there is no more data, it will call EMPTY.</p>

<p>for example:</p>

<pre><code>request1 = recursive observable call
request2 = recursive observable call
request3 = recursive observable call
</code></pre>

<p>Then i use forJoin</p>

<pre><code>forJoin(request, request2, request3).subscribe();
</code></pre>

<p>The forkJoin will callback with complete when anyone of them finish. It actually not wait for all observables complete.
I check the rxjs document, it mention</p>

<blockquote>
  <p>When all observables complete, emit the last emitted value from each.</p>
</blockquote>

<p>As I don't care these observables return value, so it would not emit value to the forkJoin observer. Then i found that in this case if only one complete, forkJoin observer is notified with complete. </p>

<p>Is this the observable limitation that i do need to emit value to able to wait for all observables complete?</p>

<p>Thanks a lot.</p>
","3733534","","3733534","","2018-09-26 08:17:13","2020-03-31 14:59:31","forkjoin not wait for all observables complete when no value emit from each observable","<rxjs><observable><rxjs6>","1","3","","","","CC BY-SA 4.0"
"52512408","1","","","2018-09-26 07:38:18","","2","275","<p>I am trying to have on-demand wensocket connection in my React-Redux application. RxJS gives webscoketSubject for managing webscokets. On reception of action, I want to start a connection using webscoketSubject, for subsequent start webscokets request, I would reuse the socket, if already a connection is established. But when I am doing it, a new subscription is getting created in webscoketSubject reference I am holding in memory and cause of that whenever I receive message from Server, I am getting duplicate actions.</p>

<p>Here is the snippet of the code.</p>

<pre><code>import { ofType } from 'redux-observable';
import { delay, mapTo, switchMap, mergeMap, map, skipUntil, skipWhile, takeUntil, catchError, take } from 'rxjs/operators';
import { Observable, DataEvent, WebSocket, of } from 'rxjs';
import { WebSocketSubject } from 'rxjs/webSocket';

let socket;

const getWebSocket = () =&gt; {
    console.log(""socket"", socket);
    if(socket) {
        console.log(socket.closed);
    }
    if(!socket) {
        console.log(""creating new socket"");
        socket = new WebSocketSubject(""ws://localhost:9091/web-socket"");
    }
    return socket;
}

//maps a websocket recieved message to redux store types
const websocketMsgMapper = payload =&gt; {
    return {
        type : 'WORKFLOWS_RECEIVED',
        workflows : payload.workflows
    }
};


export const openSocketEpic = action$ =&gt; action$.pipe(
    ofType('START_WEBSOCKET'),
    mergeMap( action =&gt; {
        const socket$ = getWebSocket();
        console.log(socket$);
        return socket$.pipe(            
            map(websocketMsgMapper),
            takeUntil(action$.pipe(ofType('STOP_WEBSOCKET'))),
            catchError(error =&gt; of({ 
                    type : 'WORKFLOWS_RECEIVED_ERROR'
                }))
        );
    })
    );
</code></pre>
","701199","","701199","","2018-09-27 05:52:32","2018-09-27 05:52:32","RXJS6 Websocket Subject Subscription issue with Redux Observables","<websocket><rxjs><redux-observable><rxjs6>","0","0","1","","","CC BY-SA 4.0"
"52520900","1","","","2018-09-26 15:06:10","","0","1015","<h2>Scenario</h2>

<p>In my angular6 app, i have three cateories, catA, catB, catC.
<strong>Each category needs data from 3 APIs</strong>. On clicking any category it loads the CategoryDetailsComponent, i dispatch action (LoadCategoryDetails). </p>

<p>I have implemented <code>forjoin</code> to perform parallel api calls(in service) and also <code>resolver</code> to ensure all the calls are done, only then the component should loaded.</p>

<h2>Problem</h2>

<ul>
<li>On clicking catA (or page reload), <code>categoryNames</code> array is empty</li>
<li>On clicked catB (second routing), <code>CategoryNames</code> array shows list of previous category (catA)</li>
</ul>

<p>Maybe one of the api call is taking time. and my resolver is not configured properly. </p>

<h2>Question</h2>

<p><strong>How to configure effects and resolver??</strong></p>

<p><strong>How to use forkjoin to make multiple calls and send data to component?</strong></p>

<h2>Code</h2>

<ol>
<li><p>dipatch action and subscribe to selector
<div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>ngOnInit() {
    const id = parseInt(this.route.snapshot.paramMap.get('categoryId'), 10);
    this.store.dispatch(new fromCategory.LoadCategoryDetails(id));

    this.store.select(getCategoryDetails)
              .subscribe((data) =&gt; {
                this.categoryDetails = data[0];
                this.journeys = data[1];
                this.categories = data[2];
              });

    // filter only category name
    // problem
    this.categories.forEach( category =&gt; {
      this.categoryNames.push(category.name);
    });
}</code></pre>
</div>
</div>
</p></li>
<li><p>effects (look for action and call service)
<div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>@Effect()
loadCategoryDetails$ = this.actions$.pipe(
    ofType&lt;fromCategory.LoadCategoryDetails&gt;(CategoryActionTypes.LoadCategoryDetails),
    switchMap((action) =&gt; {
    return this.categoryService.getCategoryDetails(action.payload).pipe(
        map(data =&gt; new fromCategory.LoadCategoryDetailsSuccess(data))
    );
    })
);</code></pre>
</div>
</div>
</p></li>
<li><p>service func making multiple calls and using forkjoin
<div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { forkJoin } from 'rxjs';

getCategoryDetails(categoryId) {
    const categoryDetails = this.http.get(url);
    const journeys = this.http.get(url);
    const courses = this.http.get(url);

    return forkJoin([categoryDetails, journeys, courses]);
}</code></pre>
</div>
</div>
</p></li>
<li><p>resolver
<div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>export class CategoryDetailsResolver implements Resolve&lt;any&gt; {

    constructor(
        private categoryService: CategoryService,
        private router: Router) {}

    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
        const categoryId = route.paramMap.get('categoryId');
        return this.categoryService.getCategoryDetails(categoryId);
    }
}</code></pre>
</div>
</div>
</p></li>
</ol>

<p>Thanks in advance.</p>
","6166406","","","","","2018-09-27 01:27:55","How to make multiple HTTP calls in Angular6, using forkJoin and ngrx?","<angular><rxjs><angular6><rxjs6><ngrx-effects>","2","2","","","","CC BY-SA 4.0"
"52526166","1","52526275","","2018-09-26 21:19:30","","4","461","<p>I want to be able to cache an http call, but also force the cache to refresh. My service looks like this:</p>

<pre><code>@Injectable()
export class UserService {
  private currentUser$: Observable&lt;User&gt;;

  constructor(private http: HttpClient) { }

  getCurrentUser(force = false): Observable&lt;User&gt; {
    if (!this.currentUser$ || force) {
      this.currentUser$ = this.http.get&lt;User&gt;(`${environment.API_URL}/profiles/me`)
        .pipe(
          shareReplay(CACHE_SIZE)
        );
    }
    return this.currentUser$;
  }
}
</code></pre>

<p>If I call <code>getCurrentUser(true)</code>, the <code>currentUser$</code> variable gets overwritten. I'm afraid this will wipe out any existing subscribers. Is this true? How can I preserve them?</p>
","64279","","","","","2018-09-26 22:49:51","Will overwriting my observable variable kill current subscribers?","<angular><rxjs><observable><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"52537218","1","","","2018-09-27 12:36:55","","3","914","<p>Is there a way in an epic to receive previous state of the store? I feel you can't as the epic stands at the end of the <code>Action -&gt; Reducer -&gt; Epic</code> queue. </p>

<blockquote>
  <p>REMEMBER: When an Epic receives an action, it has already been run through your reducers and the state updated.</p>
</blockquote>

<p>But maybe someone will suggest some solution to my problem:</p>

<p>I have an epic that handles downloading json which then is stored in the store. I though that another epic that will check what has changed would be good to dispatch a ""new item"" notification, but for that I need an access to the state prior to the store change:) maybe I should do it within the same epic?</p>
","923340","","","","","2019-12-17 09:43:40","How to get previous state in the epic","<reactjs><redux-observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52539367","1","52539610","","2018-09-27 14:28:17","","2","5613","<p>I recently update my application to angular 6 as well as the RxJs to <code>6.3.3</code> <code>version</code>. </p>

<p>As described in <a href=""https://auth0.com/blog/whats-new-in-rxjs-6/"" rel=""nofollow noreferrer"">here</a>, I used the package <code>rxjs-compat</code> to have temporarily the code written in RxJS5 and RxJS6 compatibility mode, at the same time.</p>

<p>As suggested by the RxJS team, after I update all my code to be compatible with RxJS6, I uninstalled the <code>rxjs-compat</code> because it is not longer necessary.</p>

<p>After that, I'm trying to run my code but the compiler is retrieving the following error:</p>

<blockquote>
  <p>ERROR in node_modules/rxjs/Rx.d.ts(1,15): error TS2307: Cannot find
  module 'rxjs-compat'</p>
</blockquote>

<p>Any one know what can be the problem in here? This seems that the RxJS pacadge depends on <code>rxjs-compat</code>, but if what I'm saying is true, why the RxJS team recommends to uninstall <code>rxjs-compat</code>?</p>
","5148197","","","","","2020-11-26 12:10:12","RxJS6 (angular 6) - ERROR in node_modules/rxjs/Rx.d.ts(1,15): error TS2307: Cannot find module 'rxjs-compat'","<angular><rxjs><rxjs5><rxjs6>","5","3","","","","CC BY-SA 4.0"
"52546645","1","","","2018-09-28 00:13:09","","2","87","<p>Posted nice example on stackBlitz :-)</p>

<p><a href=""https://stackblitz.com/edit/angular-f351cx"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-f351cx</a></p>

<p>I am having some troubles combining two database lookups in firebase into a single observable that renders nicely into my mat-table. </p>

<p>I made it pretty far. I can get ONE database lookup to display in a table by just returning the observable, but once I try to connect the second, nothing shows in the table. </p>

<p>I find this very strange, cause when I async/JSON pipe the result of my second Observable the result seems to have the right format. </p>

<p>What am I doing wrong? My example uses http.get() and restcountries.eu, but I am actually trying to make it work with Firebase. The error/behaviour is the same though, both at my own application and in this example. </p>
","9291737","","9291737","","2018-09-28 08:07:34","2018-09-28 19:26:06","mat-table does not render my Observable<any[]> when using mergeMap","<angular><angular-material><observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52549016","1","52549286","","2018-09-28 05:43:13","","0","52","<p>Here is an example. The source is considered half cold half hot:</p>

<pre><code>const subject = new Subject()

const source = of(1, 2, 3).pipe(concat(subject))

const hot = source.pipe(
    share()
)

setTimeout(() =&gt; {
    hot.subscribe(val =&gt; console.log(`a: ${val}`))

    subject.next(6)
}, 1000)

subject.next(4)
subject.next(5)
</code></pre>

<p>But the output:</p>

<pre><code>a: 1
a: 2
a: 3
a: 6
</code></pre>

<p>Is this considered an expected result or a bug?</p>
","6246431","","","","","2018-09-28 09:33:47","Does share operator works correctly?","<rxjs6>","2","2","","","","CC BY-SA 4.0"
"52553617","1","52556325","","2018-09-28 10:42:49","","0","859","<p>I have a hard time understanding something related to using a <a href=""https://rxjs-dev.firebaseapp.com/api/index/function/concat"" rel=""nofollow noreferrer""><code>concat</code></a> function inside a <a href=""https://rxjs-dev.firebaseapp.com/api/operators/mergeMap"" rel=""nofollow noreferrer""><code>mergeMap</code></a> operator.</p>

<p>The documentation for <code>concat</code> says that </p>

<blockquote>
  <p>You can pass either an array of Observables, or put them directly as arguments.</p>
</blockquote>

<p>When I put the Observables directly as arguments, like in the following example, I correctly get 20 and 24 in the console.</p>

<pre><code>of(4)
  .pipe(
    mergeMap(number =&gt; concat(of(5 * number), of(6 * number)))
  )
  .subscribe(value =&gt; console.log(value));
</code></pre>

<p>But when I put them as an array, then in the console I get the Observables and not their values:</p>

<pre><code>of(4)
  .pipe(
    mergeMap(number =&gt; concat([of(5 * number), of(6 * number)]))
  )
  .subscribe(value =&gt; console.log(value));
</code></pre>

<p>Here's a <a href=""https://stackblitz.com/edit/angular-hce1cn"" rel=""nofollow noreferrer"">live version</a> in Stackblitz.</p>

<p>Any idea why is that? Shouldn't both examples work identically?</p>
","5080934","","","","","2018-09-28 13:28:23","Using concat inside mergeMap","<rxjs><rxjs6>","1","6","","","","CC BY-SA 4.0"
"52558226","1","","","2018-09-28 15:12:53","","2","1527","<p>I have a container component where I'm fetching the data via <code>ajax</code> operator from <code>rxjs</code></p>

<pre><code>const data = ajax(someUrl).pipe(map(r =&gt; r.response));
</code></pre>

<p>And in my componentDidMount I have </p>

<pre><code>data.subscribe((data) =&gt; {
    this.setState({ data });
});
</code></pre>

<p>// test.js</p>

<pre><code>import React from 'react';
import { mount } from 'enzyme';
import { ajax } from 'rxjs/ajax'
import App from '../src/App';

describe('&lt;App /&gt;', () =&gt; {
  const wrap = mount(&lt;App /&gt;);
  const data = [{ 1: 'a' }];
  const mock = ajax('http://url.com').pipe(map(() =&gt; data));
  it('renders', () =&gt; {
    console.log(mock.subscribe(x =&gt; x));
    expect(wrap.find(App).exists()).toBe(true);
  });
});
</code></pre>

<p>How do I go about mocking the response so that when I run the test it I can pass that data on to other components and check if they render?</p>

<p>All the testing examples I've found have been redux-Observable ones which I'm not using.</p>

<p>Thanks a lot!</p>
","1356046","","1356046","","2018-09-28 15:30:03","2018-11-06 06:53:06","How to test rxjs ajax call with jest?","<javascript><rxjs><jestjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52562029","1","52572966","","2018-09-28 20:05:56","","5","933","<p>I am trying to use the RxJS <code>groupBy</code> operator followed by <code>concatMap</code> to collect records into individual groups based on some keys.</p>

<p>I have noticed that when <code>concatMap</code> follows a <code>groupBy</code> operator, it seems to lose the data for all the keys that occur after the first one.</p>

<p>For Example:</p>

<p>Consider the following code block:</p>

<pre><code>// DOES NOT WORK
const records = ['a:1', 'b:2', 'c:3', 'd:1', 'e:2', 'f:3', 'g:1'];
const clicks = new Subject();

const result = clicks.pipe(
  groupBy(x =&gt; x.substr(2,1)),
  concatMap(ev$ =&gt; ev$.pipe(map(x =&gt; ({key: ev$.key, value: x})))),
);
const subscription = result.subscribe(x =&gt; console.log(x));

records.forEach(x =&gt; clicks.next(x));

// Expected Output:
// { key: '1', value: 'a:1' }
// { key: '1', value: 'd:1' }
// { key: '1', value: 'g:1' }
// { key: '2', value: 'b:2' }
// { key: '2', value: 'e:2' }
// { key: '3', value: 'c:3' }
// { key: '3', value: 'f:3' }
// 
// Actual Output:
// { key: '1', value: 'a:1' }
// { key: '1', value: 'd:1' }
// { key: '1', value: 'g:1' }
// ...Nothing more -- no results for key 2 and 3
</code></pre>

<p>However, when I use the <code>concatMap</code> operator on its own, it behaves as expected.</p>

<pre><code>// WORKS
const records = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
const clicks = new Subject();

const result = clicks.pipe(
  concatMap(ev =&gt; ev.subject$.pipe(take(4), map(x =&gt; ev.key + x))),
);
const subscription = result.subscribe(x =&gt; console.log(x));

records.forEach(x =&gt; clicks.next({key: x, subject$: interval(1000)}));

// Expected &amp; Actual Output:
// a0
// a1
// a2
// a3
// b0
// b1
// b2
// b3
// c0
// c1
// c2
// c3
// d0
// d1
// d2
// d3
// e0
// e1
// e2
// e3
// f0
// f1
// f2
// f3
// g0
// g1
// g2
// g3
</code></pre>

<p>Reading through the documentation for RxJS <a href=""https://rxjs-dev.firebaseapp.com/api/operators/groupBy"" rel=""noreferrer""><code>groupBy</code></a> and <a href=""https://rxjs-dev.firebaseapp.com/api/operators/concatMap"" rel=""noreferrer""><code>concatMap</code></a> does not provide me with any clues as to what could be going on here. Whereas the section on RxJS <code>concatMap</code> at <a href=""http://reactivex.io/documentation/operators/flatmap.html"" rel=""noreferrer"">reactivex.io</a> leads me to believe that this should work.</p>

<p>Can anyone help me understand what's going on with the first scenario here? How can I get the first scenario to work?</p>
","8400917","","","","","2019-07-24 15:10:13","RxJS: Observable stream piped to groupBy() followed by concatMap(); data for subsequent keys lost","<rxjs6>","2","2","1","","","CC BY-SA 4.0"
"52569957","1","52570703","","2018-09-29 15:42:11","","5","272","<p>I have a form that looks something like this:</p>

<p><a href=""https://i.stack.imgur.com/jvU55.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jvU55.png"" alt=""Form UI""></a></p>

<p>The <code>Program Name</code> and <code>Description</code> are a part of a Reactive Form. And the <code>Feature Image</code> and <code>Video(s)</code> are file inputs.</p>

<p>I have two buttons that submit the form, Save as Draft and Publish. Publish will get enabled if all the fields are filled including both the file inputs. Save as Draft is always enabled and will submit the form.</p>

<p><strong>On Form Submit:</strong>
I check if there is a Feature Image. If there is one, I upload it to a Firebase Storage Bucket. I apply the same check for Videos. If there is/are any video(s), I upload them one by one to the Firebase Storage Bucket. Here's the code for the same:</p>

<pre><code>let featureImageUrl$: Observable&lt;string&gt;;
const videoUrls$: Observable&lt;string&gt;[] = [];
// Check if featureImageToUpload was uploaded
if (this.featureImageToUpload) {
  featureImageUrl$ = this.fileService.upload(`content/programs/images/${this.utils.generateRandomString()}`, this.featureImageToUpload);
}

// Check if video(s) was/were uploaded
if (this.videosToUpload) {
  this.utils.range(this.videosToUpload.length).forEach(fileIndex =&gt; {
    // tslint:disable-next-line:max-line-length
    const videoUrl$ = this.fileService.upload(`content/programs/videos/${this.utils.generateRandomString()}`, this.videosToUpload[fileIndex]);
    videoUrls$.push(videoUrl$);
  });
}
</code></pre>

<p><code>this.fileService.upload</code> is just a method that returns an <code>Observable&lt;string&gt;</code> essentially wrapping the Download URL of the file that was uploaded.</p>

<p><code>this.utils.range</code> is just a method that returns an Array of numbers based on the length. so if the length is 4, then it will return <code>[0, 1, 2, 3]</code></p>

<h2>The issue:</h2>

<p>I want to create an <code>Observable</code> which I can subscribe to, to get an Object with a structure like this:</p>

<pre><code>{
  featureImageUrl: 'DOWNLOAD URL FOR THE FEATURE IMAGE' || null // null in case the file wasn't uploaded;
  videos: [
    'DOWNLOAD URL FOR VIDEO 1',
    'DOWNLOAD URL FOR VIDEO 2',
    'DOWNLOAD URL FOR VIDEO 3',
    'DOWNLOAD URL FOR VIDEO 4',
    ...
  ] || null // null in case the video(s) were not uploaded;
}
</code></pre>

<h2>Things I've tried so far:</h2>

<p>I could use <code>forkJoin</code> like this:</p>

<pre><code>forkJoin(...videoUrls$, featureImageUrl$)
  .subscribe(downloadUrls =&gt; {
    console.log(downloadUrls);
  });
</code></pre>

<p>And then extract the video download urls based on the length of <code>videoUrls$</code> and then create my Object accordingly. But I'm looking for a cleaner way of doing this. </p>

<p>I also tried using <code>Observable.create</code> but couldn't wrap my head around it for this specific use case.</p>

<p>With suggestions from <a href=""https://stackoverflow.com/users/5801495/buggy"">Buggy</a>, I also tried this:</p>

<pre><code>forkJoin(forkJoin(videoUrls$), featureImageUrl$)
  .pipe(
    map(([videoUrls, featureImageUrl]) =&gt; ({videoUrls, featureImageUrl}))
  );
</code></pre>

<p>It works perfectly fine in case both the Feature Image and Videos are selected. But if I just select Feature Image not don't select any videos, the subscription never reaches.</p>

<p>Here's a <a href=""https://stackblitz.com/edit/angular-firebase-eg?file=src%2Fapp%2Fapp.component.ts"" rel=""nofollow noreferrer""><strong>Sample StackBlitz</strong></a> for your reference.</p>
","2622292","","2622292","","2018-09-29 16:30:39","2018-09-29 20:45:56","Combine an Observable<string> and an Array<Observable<string>> into a single Observable<{string, string[]}>","<angular><rxjs><observable><rxjs6>","1","4","","","","CC BY-SA 4.0"
"52583242","1","52598641","","2018-10-01 00:21:43","","0","170","<p>I am attempting to get the rxjs operator share working like in <a href=""https://www.learnrxjs.io/operators/multicasting/share.html"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/operators/multicasting/share.html</a>, but I am not getting the expected results. I was expecting the 'Running map function' to only log once. Am I missing something?</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { of } = rxjs;
const { map, share } = rxjs.operators;

const obs$ = of('data');

const mapped$ = obs$.pipe(map(d =&gt; {
  console.log('Running map function');
  return `mapped ${d}`;
}));

const shared$ = mapped$.pipe(share());

shared$.subscribe(d =&gt; { console.log(d); });

shared$.subscribe(d =&gt; { console.log(d); });</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.3.3/rxjs.umd.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1679126","","10000141","","2018-10-01 00:40:41","2018-10-01 20:44:14","Rxjs share operator is not giving the expected results","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52589148","1","","","2018-10-01 10:27:10","","0","499","<p>I have updated my project today(Angular5 to Angular6).And a running code started to give errors......................................................................................................</p>

<p><a href=""https://i.stack.imgur.com/AWA9G.png"" rel=""nofollow noreferrer"">error mesage</a></p>

<pre><code>/**
 * Resolve
 * @param {ActivatedRouteSnapshot} route
 * @param {RouterStateSnapshot} state
 * @returns {Observable&lt;any&gt; | Promise&lt;any&gt; | any}
 */
resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;any&gt; | Promise&lt;any&gt; | any {
    this.routeParams = route.params;
    return new Promise((resolve, reject) =&gt; {
        Promise.all([
            this.getCompany()
        ]).then(
            () =&gt; {
                if (this.routeParams.postKey) {
                    this.setCurrentMail(this.routeParams.postKey);
                }
                else {
                    this.setCurrentMail(null);
                }
                this.onSearchTextChanged.subscribe(searchText =&gt; {
                    if(searchText !== ''){
                        this.searchText = searchText;
                        this.getMailsByLabel();
                    }
                    else{
                    this.searchText = searchText;
                    this.getMailsByLabel();
                }
                });

                resolve();
            },
            reject
            );
    });
}

getCompany() {
    var companyIndex = this.routeParams.company;
    return new Promise((resolve, reject) =&gt; {
        this.db.list('corporateUsers/' + localStorage.getItem('currentUserId') + ""/companies"")
            .valueChanges().subscribe((company: any) =&gt; {
                if (company) {
                    resolve(company[companyIndex || 0])
                }
            },reject);
    }).then((company: any) =&gt; {
        this.company = company.uniqueName;
        return this.getMailsByLabel()
    });
}
</code></pre>

<p>my package.json............................................................................</p>

<pre><code>""dependencies"": {
""@agm/core"": ""1.0.0-beta.2"",
""@angular/animations"": ""6.1.9"",
""@angular/cdk"": ""6.4.7"",
""@angular/common"": ""6.1.9"",
""@angular/compiler"": ""6.1.9"",
""@angular/core"": ""6.1.9"",
""@angular/flex-layout"": ""6.0.0-beta.18"",
""@angular/forms"": ""6.1.9"",
""@angular/http"": ""6.1.9"",
""@angular/material"": ""6.4.7"",
""@angular/platform-browser"": ""6.1.9"",
""@angular/platform-browser-dynamic"": ""6.1.9"",
""@angular/router"": ""6.1.9"",
""@ngu/carousel"": ""1.4.8"",
""@ngx-translate/core"": ""10.0.2"",
""@swimlane/ngx-charts"": ""7.4.0"",
""@swimlane/ngx-datatable"": ""11.0.3"",
""@withinpixels/ngx-dnd"": ""3.1.0"",
""@xmlking/ngx-knob"": ""0.0.6"",
""angular-calendar"": ""0.21.3"",
""angular2-knob"": ""1.1.15"",
""angularfire2"": ""5.0.0-rc.7"",
""chart.js"": ""2.7.2"",
""classlist.js"": ""1.1.20150312"",
""core-js"": ""2.5.1"",
""d3"": ""4.11.0"",
""firebase"": ""5.0.1"",
""hammerjs"": ""2.0.8"",
""highlight.js"": ""9.12.0"",
""intl"": ""1.2.5"",
""moment"": ""2.19.2"",
""ng2-imageupload"": ""1.4.2"",
""ng2-img-cropper"": ""0.9.0"",
""ngx-color-picker"": ""4.4.0"",
""ngx-cookie-service"": ""1.0.9"",
""ngx-moment"": ""2.0.0"",
""perfect-scrollbar"": ""1.0.3"",
""rxjs"": ""6.3.3"",
""rxjs-compat"": ""6.3.3"",
""web-animations-js"": ""2.3.1"",
""zone.js"": ""^0.8.26""


""devDependencies"": {
    ""@angular-devkit/build-angular"": ""~0.8.0"",
    ""@angular/cli"": ""6.2.3"",
    ""@angular/compiler-cli"": ""6.1.9"",
    ""@angular/language-service"": ""6.1.9"",
    ""@angularclass/hmr"": ""2.1.3"",
    ""@types/jasmine"": ""2.5.54"",
    ""@types/jasminewd2"": ""2.0.3"",
    ""@types/node"": ""6.0.90"",
    ""codelyzer"": ""3.2.2"",
    ""jasmine-core"": ""2.6.4"",
    ""jasmine-spec-reporter"": ""4.1.1"",
    ""karma"": ""1.7.1"",
    ""karma-chrome-launcher"": ""2.1.1"",
    ""karma-cli"": ""1.0.1"",
    ""karma-coverage-istanbul-reporter"": ""1.3.0"",
    ""karma-jasmine"": ""1.1.0"",
    ""karma-jasmine-html-reporter"": ""0.2.2"",
    ""protractor"": ""5.1.2"",
    ""ts-node"": ""3.2.2"",
    ""tslint"": ""5.7.0"",
    ""typescript"": ""2.9.2""
  }
</code></pre>

<p>I map function used in more than one place.I adding one</p>

<pre><code> if (!this.routeParams[""isAnswered""]) {
            this.mails = [];
             let path = this.routeParams[""hashtag""] ? ""hashtags/"" + this.routeParams[""hashtag""] + ""/timeline"" : ""timeline"";
            this.subscription = this.db.list(""brand/"" + this.company + ""/"" + path, ref =&gt; ref.orderByChild(""order""))
                .snapshotChanges()
                .pipe(
                map(changes =&gt; {
                    return changes.filter(mail =&gt; mail.payload.val()['rating']['uniqueName'] === this.company &amp;&amp; mail.payload.val()['repostedByUser'] === undefined).map(c =&gt; ({ $key: c.payload.key, ...c.payload.val() }));
                })
                )
                .subscribe((mails: any) =&gt; {

                    this.mails = mails.map(mail =&gt; {
                        return new Mail(mail);
                    });
                    this.mails = FuseUtils.filterArrayByString(this.mails, this.searchText);
                    this.onMailsChanged.next(this.mails);

                    resolve(this.mails);
                }, reject);
</code></pre>

<p><strong>EDİT:</strong></p>

<p>I changed rxjs version 6.2.2 and problem has gone.But i did not understand what is changed on 6.2.2 to 6.3.3 ?</p>
","10046467","","10046467","","2018-10-05 08:35:41","2018-10-05 08:35:41","Angular6 Error: Uncaught (in promise): TypeError: (intermediate value).map is not a function","<typescript><promise><rxjs><angular6><rxjs6>","0","5","1","","","CC BY-SA 4.0"
"52594026","1","52623292","","2018-10-01 15:09:18","","6","7688","<p>I have the following code:</p>

<pre><code>export class EventsChainComponent { 
    eventSubscriber:Subscription;

    constructor (protected eventService: EventService) {}


    public registerComponentsEvent(event:any) {
        // getOnEvent signature
        // (method) EventService.getOnEvent(): Observable&lt;FormEvent&gt;
        this.eventSubscriber = this.eventService.getOnEvent()
            .pipe(filter((formEvent: FormEvent) =&gt; {return formEvent.key == event.event}))
            .subscribe((formEvent: FormEvent) =&gt; {
                  ..........
            });
    }
</code></pre>

<p>When I compile, the compiler returns the following error:</p>

<blockquote>
  <p>Argument of type 'MonoTypeOperatorFunction' is not assignable to parameter of type 'OperatorFunction'.</p>
</blockquote>

<p>So, I search a little bit and I found the <code>RxJs6</code> operator filter API:</p>

<pre><code>export declare function filter&lt;T, S extends T&gt;(predicate: (value: T, index: number) =&gt; value is S, thisArg?: any): OperatorFunction&lt;T, S&gt;;
export declare function filter&lt;T&gt;(predicate: (value: T, index: number) =&gt; boolean, thisArg?: any): MonoTypeOperatorFunction&lt;T&gt;;
</code></pre>

<p>As you can see, the filter as 2 overloads methods, one returning <code>OperatorFunction</code> and another <code>MonoTypeOperatorFunction</code>.</p>

<p>Any one can tell me the difference between this 2 types? And any one knows how can I solve this error?</p>

<p>Note: The <code>FormEvent</code> class was created by me, and both <code>EventService</code> and <code>EventsChainComponent</code> has the same import that reference to the same class.</p>
","5148197","","5148197","","2018-10-02 10:55:42","2021-02-01 09:41:19","RxJs6: OperatorFunction vs MonoTypeOperatorFunction","<angular><typescript><rxjs6>","3","11","","","","CC BY-SA 4.0"
"52596486","1","52597029","","2018-10-01 18:03:08","","1","2037","<p>For example:</p>

<pre><code>this.saveSubscription$ = this.ds.onSave$.subscribe(x =&gt; 
  this.sb.updateMachineTool(this.viewEditModel.viewEditModel).subscribe(x = {
    console.log('alert results', x)
  })
)
</code></pre>

<p><code>this.ds.onSave$</code> is a subject that triggers when a save button on a different component is clicked.</p>

<p><code>this.sb.updateMachineTool</code> is an httpClient post that updates a specific tool</p>

<p>should I be using some type of map so i'm not subscribing to both areas?</p>

<p>How can I refactor this code?</p>
","9457997","","5377805","","2018-10-01 18:11:24","2018-10-01 18:46:37","How to refactor a subscribe inside a subscribe in rxjs","<angular><rxjs><angular6><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52596493","1","52596875","","2018-10-01 18:03:36","","1","72","<p>Using Angular CLI 6 for a Single Page Application</p>

<p>What I need to do is the following
make an HTTP post request. I will get an OK back. The results or the side effect will take sometime before is ready for processing.
I will have to poll for results readiness, lets say once a second.</p>

<p>To poll for the results, I need to make an HTTP get call and check the results. If results are complete, I am done.
Otherwise I will have to continue to poll..</p>

<p>What I have done, I have two obserables, one for the HTTP post and one for HTTP get call. 
I use a setTimeout for the polling. This organization for the code, when I hit the setTimeout, I go to never never land I have to kill the application...</p>

<p>Any hints on this problem?</p>

<p>What I have so far is</p>

<pre><code>private initiateAnalysis(){
    this.initiateRequest$()
    .subscribe(response =&gt;{
            const error = getErrorMessage(response);
            if (error !== null) {
                console.error(error);
            } else {
                this.processResults();
            }
        },
        (err: HttpErrorResponse) =&gt;{
            console.error('feature error:', err);
        });
}

private initiateRequest$(): Observable&lt;any&gt;{
    let params: any = {
    };
    return this.problemsService.postRequest('postURL', {}, params)
}

private checkForResponse$(): Observable&lt;any&gt;{
    let params: any = {
    };

    return this.problemsService.getResults('someURL', params);
}

private processResults(){
    this.doneWithNecRiskAnalysis = false;
    while (!this.doneWithNecRiskAnalysis) {
        setTimeout(() =&gt;{
            this.checkForResults();   // I never to this line in the code...
        }, 1000);
    }
}

private checkForResults() {
    this.checkForResponse$()
    .subscribe(response =&gt;{
            const error = getErrorMessage(response);
            if (error !== null) {
                console.error(error);
            } else {
                if (1 === 1) { // just for now
                    this.showResults(response.payload);
                }
            }
        },
        (err: HttpErrorResponse) =&gt;{
            console.error('feature error:', err);
        });
}

private showResults(results) {
    console.log('results', results);
}
</code></pre>
","496136","","496136","","2018-10-01 18:10:22","2018-10-01 19:10:04","How to chain a list of RxJS observable","<angular><rxjs6>","1","3","","","","CC BY-SA 4.0"
"52597959","1","","","2018-10-01 19:51:59","","4","3602","<p>I'm building a simple stopwatch with angular/rxjs6, I can start the timer but I can't pause/resume it.</p>

<pre><code>  source: Observable&lt;number&gt;;
  subscribe: Subscription;

  start() {
    this.source = timer(0, 1000);
    this.subscribe = this.source
      .subscribe(number =&gt; {
        this.toSeconds = number % 60;
        this.toMinutes = Math.floor(number / 60);
        this.toHours = Math.floor(number / (60 * 60));

        this.seconds = (this.toSeconds &lt; 10 ? '0' : '') + this.toSeconds;
        this.minutes = (this.toMinutes &lt; 10 ? '0' : '') + this.toMinutes;
        this.hours = (this.toHours &lt; 10 ? '0' : '') + this.toHours;
    });
  }

  pause() {
    this.subscribe.unsubscribe(); // not working
  }
</code></pre>

<p>after doing lot of searching, I found that I should use <code>switchMap</code> operator to accomplish that, but I'm new to rxjs and don't know how to do it the right way.</p>

<p>Any help would be much appreciated.</p>
","7054862","","10154951","","2018-10-02 01:31:38","2020-09-01 20:31:41","pause/resume a timer Observable","<angular><angular6><rxjs6>","3","0","","","","CC BY-SA 4.0"
"52599371","1","52600034","","2018-10-01 21:52:15","","1","548","<p>I'm fairly new to RxJS and I want to do the following:</p>

<p>Imagine I'm writing a method to track temperatures over time. This method would observe a Subject that will emit values like the following: <code>[12, 49, -2, 26, 5, ...]</code></p>

<p>How can I turn this into another Observable which adds the mean over time for every value as they come?</p>

<pre><code>[
  {
    temperature: 12,
    mean: 12
  },
  {
    temperature: 49,
    mean: 30.5
  },
  {
    temperature: -2,
    mean: 19.67
  },
  {
    temperature: 26,
    mean: 21.25
  },
  {
    temperature: 5,
    mean: 18
  },
  ...
]
</code></pre>

<p>The difficulty I'm struggling with is that mean calculation should be done using ALL previous values.</p>

<p>Is there a way to do this? I actually need to add more data and calculate other values as well, but this is the gist of what I need to do.</p>
","4185753","","","","","2018-10-02 04:38:48","RxJS - How can I map/switch a Subject Observable and add a mean calculation to every emitted value?","<javascript><rxjs><reactivex><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52605354","1","52606279","","2018-10-02 09:12:01","","3","814","<p>I'm trying to understand the <code>pipe</code> operator of observable API:</p>

<pre><code> export declare class Observable&lt;T&gt; implements Subscribable&lt;T&gt; {
.......
    pipe&lt;A&gt;(op1: OperatorFunction&lt;T, A&gt;): Observable&lt;A&gt;;
    pipe&lt;A, B&gt;(op1: OperatorFunction&lt;T, A&gt;, op2: OperatorFunction&lt;A, B&gt;): Observable&lt;B&gt;;
    pipe&lt;A, B, C&gt;(op1: OperatorFunction&lt;T, A&gt;, op2: OperatorFunction&lt;A, B&gt;, op3: OperatorFunction&lt;B, C&gt;): Observable&lt;C&gt;;
    pipe&lt;A, B, C, D&gt;(op1: OperatorFunction&lt;T, A&gt;, op2: OperatorFunction&lt;A, B&gt;, op3: OperatorFunction&lt;B, C&gt;, op4: OperatorFunction&lt;C, D&gt;): Observable&lt;D&gt;;
    pipe&lt;A, B, C, D, E&gt;(op1: OperatorFunction&lt;T, A&gt;, op2: OperatorFunction&lt;A, B&gt;, op3: OperatorFunction&lt;B, C&gt;, op4: OperatorFunction&lt;C, D&gt;, op5: OperatorFunction&lt;D, E&gt;): Observable&lt;E&gt;;
    pipe&lt;A, B, C, D, E, F&gt;(op1: OperatorFunction&lt;T, A&gt;, op2: OperatorFunction&lt;A, B&gt;, op3: OperatorFunction&lt;B, C&gt;, op4: OperatorFunction&lt;C, D&gt;, op5: OperatorFunction&lt;D, E&gt;, op6: OperatorFunction&lt;E, F&gt;): Observable&lt;F&gt;;
    pipe&lt;A, B, C, D, E, F, G&gt;(op1: OperatorFunction&lt;T, A&gt;, op2: OperatorFunction&lt;A, B&gt;, op3: OperatorFunction&lt;B, C&gt;, op4: OperatorFunction&lt;C, D&gt;, op5: OperatorFunction&lt;D, E&gt;, op6: OperatorFunction&lt;E, F&gt;, op7: OperatorFunction&lt;F, G&gt;): Observable&lt;G&gt;;
    pipe&lt;A, B, C, D, E, F, G, H&gt;(op1: OperatorFunction&lt;T, A&gt;, op2: OperatorFunction&lt;A, B&gt;, op3: OperatorFunction&lt;B, C&gt;, op4: OperatorFunction&lt;C, D&gt;, op5: OperatorFunction&lt;D, E&gt;, op6: OperatorFunction&lt;E, F&gt;, op7: OperatorFunction&lt;F, G&gt;, op8: OperatorFunction&lt;G, H&gt;): Observable&lt;H&gt;;
    pipe&lt;A, B, C, D, E, F, G, H, I&gt;(op1: OperatorFunction&lt;T, A&gt;, op2: OperatorFunction&lt;A, B&gt;, op3: OperatorFunction&lt;B, C&gt;, op4: OperatorFunction&lt;C, D&gt;, op5: OperatorFunction&lt;D, E&gt;, op6: OperatorFunction&lt;E, F&gt;, op7: OperatorFunction&lt;F, G&gt;, op8: OperatorFunction&lt;G, H&gt;, op9: OperatorFunction&lt;H, I&gt;): Observable&lt;I&gt;;
.......
}
</code></pre>

<p>As you could see, all of pipe overload methods receive and <code>OperationFunction</code> type.</p>

<p>Lets check the filter operator API:</p>

<pre><code>export declare function filter&lt;T, S extends T&gt;(predicate: (value: T, index: number) =&gt; value is S, thisArg?: any): OperatorFunction&lt;T, S&gt;;
export declare function filter&lt;T&gt;(predicate: (value: T, index: number) =&gt; boolean, thisArg?: any): MonoTypeOperatorFunction&lt;T&gt;;
</code></pre>

<p>As you can see, you have an overload method that returns an <code>OperationFunction</code> and another that returns <code>MonoTypeOperatorFunction</code>.</p>

<p>I have the following questions:</p>

<ul>
<li>RxJS6 operators like <code>filter</code>, could only be used on <code>pipe</code> method?</li>
<li>Why in filter we have a overload method that return different types but the <code>pipe</code> only receives one?</li>
</ul>
","5148197","","5394220","","2018-10-02 12:40:30","2018-10-02 12:40:30","RxJS6: Why observable Pipe operator only receives OperatorFunction and not MonoTypeOperatorFunction","<typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52605935","1","52606102","","2018-10-02 09:50:50","","1","9189","<p>I am trying to map a response from an API call to a let's say a Product object. I can't seem to find a way to do this properly.</p>

<p>The response is in the following structure:</p>

<pre><code>{
  ""data"": [
    {
      ""id"": 1,
      ""name"": ""keyboard"",
      ""details"": {
        ""parent"": 1,
        ""price"": 50,
        ""other"": ""info""
      }
    },
    {
      ""id"": 2,
      ""name"": ""mouse"",
      ""details"": {
        ""parent"": 2,
        ""other"": ""info"",
        ""price"": 20
      }
    }
  ],
  ""total-records"": 2,
  ""more"": ""something""
}
</code></pre>

<p>The response details order cannot be guaranteed. (Note price in detail).I am trying to map the object above to a single new object which contains only following properties:</p>

<pre><code>{
    ""id"": 1,
    ""name"": ""keyboard"",
    ""price"": 50
},
{
    ""id"": 2,
    ""name"": ""mouse"",
    ""price"": 20
}
</code></pre>

<p>I am using angular and Observables to get the data. Now I am getting the value, mapping it, and can either just get the details or the 1st level object properties such as <code>data.id</code> or <code>data.name</code>. However getting details such as price is a bit confusing to me.</p>

<p>I have researched a lot about mergemap, flatmap, even lodash and countless hours trying to figure it out but I can't seem to find a correct way to do it. </p>

<p>Can I use perhaps filter in the combination of a map to achieve this?
Any information is highly appreciated.</p>

<p>Here is my code so far:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>ngOnInit() {
    //Get by criteria
    this.productService
      .get(url, httpOptions)
      .pipe(
        map((items: Response&lt;Product&gt;) =&gt; {
          this.details = items[""details""].filter(
            // Filter possible null values
            details=&gt; details!==null;
          );
          this.header = items
        }),
        tap(() =&gt; console.log(this.header))
      )
      .subscribe();
  }
  
  // Header is level 1 info like name and id
  // Detail is level 2 info like price.
  // I have to have a filter on the details because sometimes </code></pre>
</div>
</div>
</p>
","10445161","","833070","","2018-10-02 11:14:45","2018-10-02 12:19:20","Map an observable nested object to another object","<angular><typescript><mapping><observable><rxjs6>","2","2","","","","CC BY-SA 4.0"
"52610411","1","52610557","","2018-10-02 14:24:11","","2","1849","<p>The Following code is from my service component. It requires a user observable and the data to submit in a BehaviorSubject. I call <code>form.service.formToSubmit$.next(form);</code> to update it. because combineLatest also fires when the user observable emits I do a check if the formToSubmit is not null and it is set to null after it is submitted. But its not firing when I update formToSubmit. I have tried just bout everything. </p>

<pre><code>     this.formToSubmit$ = new BehaviorSubject&lt;Forms&gt;(null);  
    constructor(){
    this.updateForm();

}
    updateForm(){
            combineLatest(this.authService.user$, this.formToSubmit$).pipe(
                switchMap(([user, form]) =&gt;{
                    if(form == null) return;
                    return this.afs.collection('networks').doc(user.activeNetworkProfile.id).collection('companyProfiles').doc(user.activeCompanyProfile.id).collection('inspectionForms').doc(form.id).set(JSON.parse(JSON.stringify(form))).then(success=&gt;{
                        this.formToSubmit$.next(null);
                    }).catch(err=&gt;{
                        this.formToSubmit$.next(null);  
                    });
                })
            );
        }
</code></pre>

<p>This is the previous code that worked just fine.</p>

<pre><code>updateFormdd(form: Forms){
        return Observable.create(observer=&gt;{
            this.authService.user$.subscribe(user=&gt;{
                this.afs.collection('networks').doc(user.activeNetworkProfile.id).collection('companyProfiles').doc(user.activeCompanyProfile.id).collection('inspectionForms').doc(form.id).set(JSON.parse(JSON.stringify(form))).then(success=&gt;{
                    observer.next(success);
                    observer.complete();
                }).catch(err=&gt;{
                    observer.err(err);
                });
            })
        })
    }
</code></pre>

<p>But ultimately the goal is to figure out how to do the above function but allow me to combine up to 3 observable like in the following function.</p>

<pre><code>  updateInspection(){

            combineLatest(this.authService.user$, this.equipmentId$, this.inspectionToSubmit$).pipe(
                switchMap(([user, equipmentId, form]) =&gt;{
                    if(form == null) return;
                    return this.afs.collection('networks').doc(user.activeNetworkProfile.id).collection('companyProfiles').doc(user.activeCompanyProfile.id).collection('equipment').doc(equipmentId).set(JSON.parse(JSON.stringify(form))).then(success=&gt;{
                        this.formToSubmit$.next(null);
                    }).catch(err=&gt;{
                        this.formToSubmit$.next(null);
                    });
                })
            );

    }
</code></pre>

<p>I just want to ensure Im using observable's properly. Thank you</p>
","9581414","","","","","2018-10-02 14:43:42","Does combineLatest not fire becuase of the behaviorSubject?","<angular><typescript><observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52614958","1","","","2018-10-02 19:13:43","","2","182","<p>I have the following service:</p>

<pre><code>public loadMatchAnalysis(clientId: string): void {
    this.logger.info(`Calling matchAnalysisService to get everything for the 'Match Analysis' page`);

    this.matchAnalysisService.getMatchAnalysis(clientId).subscribe(
      (matches: MatchAnalysis[]) =&gt; {
        matches.forEach(match =&gt; {
          forkJoin(
            this.matchAnalysisService.getMappings(clientId, match.id),
            this.matchAnalysisService.getCalculationMethods(clientId, match.id)
          ).subscribe(([mappings, calculations]) =&gt; {
            match.mappings = mappings.filter(m =&gt; m.id === match.id);
            match.children = calculations.filter(c =&gt; c.id === match.id);

            console.log('mappings', mappings);
            console.log('calculations', calculations);
            console.log('matches', matches);
          });
        });

        //THIS ONLY NEEDS TO BE CALLED ONCE
        new GetMatchAnalysisLoadedAction({ data: matches }).dispatch();
      },
      (error: HttpErrorResponse) =&gt; {
        new GetMatchAnalysisLoadedAction({ error: error }).dispatch();
      }
    );
  }
</code></pre>

<p>What I'm trying to accomplish:</p>

<p>I need to make an API call that will return a list of <code>matches</code>. Each <code>match</code> has an <code>id</code> that I need in order to make two new API calls. As you can see, I'm using <code>forkJoin</code> to perform the calls and when I get the data back, I'm modifying the <code>matches</code> with the data I need. Once all of that is complete, I need to make a call to <code>GetMatchAnalysisLoadedAction()</code> with all the data (<code>matches</code>).</p>

<p>The above code works for the most part except for only calling <code>GetMatchAnalysisLoadedAction()</code> once--and I understand why that occurs.</p>

<p>Is there some RXJS magic to do all of this nicely?</p>
","2094116","","2094116","","2018-10-02 20:27:24","2018-10-02 22:12:49","Subscription has an inner subscribe for each item","<angular><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"52619758","1","","","2018-10-03 04:36:16","","0","138","<p>Say I have this:</p>

<pre><code>const register = function(cb){

   process.on('message', m =&gt; {

         cb(m, (err, v) =&gt; {

            process.send({error: err, value: v});

         });
   });

};
</code></pre>

<p>we use the above like:</p>

<pre><code>register((m, cb) =&gt; {

   // do something with m

   setTimeout(() =&gt; {
      cb('some error', m);
   }, 100);

});
</code></pre>

<p>my question is - is there a way to use <code>Rx.Observable</code> with this - most examples of <code>Rx.Observable.fromCallback</code> will wrap an <em>error-first</em> callback. But in this case, the callback is not error first. As an exercise, how to make it work for non-error first callbacks? Here is a start:</p>

<pre><code>const {Observable, bindNodeCallback} = require('rxjs');

const obs = bindNodeCallback(register);

const subscription = obs().subscribe(v =&gt; {

}, e =&gt; {
       // this gets hit since the first arg is not an error
 });
</code></pre>

<p>anyone dealt with this one before?</p>

<p><strong>Update</strong>, I got a little closer, the following example uses setInterval instead of process.on('message') so it is easier to work with for testing:</p>

<p><a href=""https://gist.github.com/ORESoftware/ea5d754d6ca6c92ca7e3bddc7eb318c2"" rel=""nofollow noreferrer"">https://gist.github.com/ORESoftware/ea5d754d6ca6c92ca7e3bddc7eb318c2</a></p>
","1223975","","1223975","","2018-10-03 04:59:13","2018-10-03 08:41:27","Observable from callback, where callback is not error-first","<rxjs><observable><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52621774","1","52623728","","2018-10-03 07:21:25","","1","328","<p>I migrated an Angular project from v5 to v6.</p>

<p>In order to update all the imports I already ran <code>rxjs-5-to-6-migrate</code>:</p>

<pre><code>npm install -g rxjs-tslint
rxjs-5-to-6-migrate -p src/tsconfig.app.json
</code></pre>

<p>But now I have ERRORs like the following:</p>

<pre><code>src/app/products/product.service.ts(54,4): error TS2322: Type 'Observable&lt;{}&gt;' is not assignable to type 'Observable&lt;{ count: number; next: string; previous: string; results: any[]; }&gt;'.
  Type '{}' is not assignable to type '{ count: number; next: string; previous: string; results: any[]; }'.
    Property 'count' is missing in type '{}'.
</code></pre>

<p><strong>product.service.ts</strong>:</p>

<pre><code>import { Injectable } from '@angular/core';
//import { Http, Response, Headers, RequestOptions } from '@angular/http';
import { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { ErrorObservable } from 'rxjs/observable/ErrorObservable';

import { catchError, map, tap, finalize } from 'rxjs/operators';

import { Product } from './product';

import { SpinnerService } from './../utilities/spinner/spinner.service';

import { environment } from '../../environments/environment';

const endpoint = environment.apiHost+'/api/products/' //'http://127.0.0.1:8000/api/products/'

@Injectable()
export class ProductService {

  /* Caching few data that does not change so often */
  private productTypes: any[];
  private departments: any[];
  private authors: any[];
  private colors: any[];
  private sizeRuns: any[];

  constructor(private http: HttpClient, private _spinnerService: SpinnerService) { }

  list(params?): Observable&lt;{count:number, next:string, previous:string, results: any[]}&gt; {
    return this.http.get&lt;{count:number, next:string, previous:string, results: any[]}&gt;(endpoint, {params: params})
      .pipe(
        catchError(this.handleError&lt;any&gt;('Retrieving products'))
      );
  }

  /**
   * Handle Http operation that failed.
   * Let the app continue.
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  private handleError&lt;T&gt;(operation='Operation', result?: T) {
    return (error: any): ErrorObservable | Observable&lt;T&gt; =&gt; {

      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      // TODO: better job of transforming error for user consumption
      console.log(`${operation} failed: ${error.message}`);

      // Let the app keep running by returning an Observable with empty result.
      //return of(result as T); 
      return new ErrorObservable(error);
    };
  }

}
</code></pre>

<p>I saw other questions like this on StackOverflow, but still I don't understand how to solve.
I can probably change the interface <code>{count:number, next:string, previous:string, results: any[]}</code> to simply <code>any</code>, but I don't really want to do it.
Any solution?</p>

<p><strong>UPDATE1</strong>: Using an Interface</p>

<pre><code>interface PaginatedList {
  count: number;
  next: string;
  previous: string;
  results: any[];
}

@Injectable()
export class ProductService {

  /* Caching few data that does not change so often */
  private productTypes: any[];
  private departments: any[];
  private authors: any[];
  private colors: any[];
  private sizeRuns: any[];

  constructor(private http: HttpClient, private _spinnerService: SpinnerService) { }

  list(params?): Observable&lt;PaginatedList&gt; {
    this._spinnerService.show('productListSpinner');
    return this.http.get&lt;PaginatedList&gt;(endpoint, {params: params})
      .pipe(
        catchError(this.handleError&lt;any&gt;('Retrieving products')),
        finalize(() =&gt; this._spinnerService.hide('productListSpinner'))
      );
  }

  /**
   * Handle Http operation that failed.
   * Let the app continue.
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  private handleError&lt;T&gt;(operation='Operation', result?: T) {
    return (error: any): ErrorObservable | Observable&lt;T&gt; =&gt; {

      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      // TODO: better job of transforming error for user consumption
      console.log(`${operation} failed: ${error.message}`);

      // Let the app keep running by returning an Observable with empty result.
      //return of(result as T); 
      return new ErrorObservable(error);
    };
  }

}
</code></pre>

<p><strong>ERRORS</strong>:</p>

<pre><code>src/app/products/product.service.ts(61,4): error TS2322: Type 'Observable&lt;{}&gt;' is not assignable to type 'Observable&lt;PaginatedList&gt;'.
  Type '{}' is not assignable to type 'PaginatedList'.
    Property 'count' is missing in type '{}'.
</code></pre>

<p><strong>UPDATE2</strong>:</p>

<p>Checking my errors, I think that <code>ErrorObservable</code> is causing the other errors:</p>

<pre><code>src/app/products/product.service.ts(325,26): error TS2314: Generic type 'ErrorObservable&lt;T&gt;' requires 1 type argument(s).
</code></pre>
","4960618","","4960618","","2018-10-03 07:50:14","2018-10-10 06:57:19","Errors after migrated Angular and RxJS 5 to 6 - Type 'Observable<{}>' is not assignable to type 'Observable<....>'","<angular><rxjs><angular6><rxjs6>","2","1","","","","CC BY-SA 4.0"
"52643710","1","","","2018-10-04 09:47:44","","0","2149","<p>i am building an e-shop with some products. The user can add to cart and he can see the products he has added. I have three categories. One category is all products where i display all products and one fruits and bread category where i display specific products..Everything is working fine but when i change category  without clicking the add to cart button angular performs the addToCart method..I think its a problem with multiple subscriptions and memory leak..How can i do this with better coding?Here is my ts and html angular files.</p>

<p>My products.ts</p>

<pre><code>import {Component, OnDestroy, OnInit} from '@angular/core';
import {CategoryService} from '../category.service';
import {ActivatedRoute} from '@angular/router';
import {Subject} from 'rxjs/index';
import 'rxjs/add/operator/takeUntil';
import {ShoppingCartService} from '../services/shopping-cart.service';
import {Product} from '../models/product';




@Component({
  selector: 'app-products',
  templateUrl: './products.component.html',
  styleUrls: ['./products.component.css'],

})
export class ProductsComponent implements OnInit, OnDestroy {

  products: any;
  filteredproducts: any;
  category: any;
  res: any;
  categoryid: any;
  cartId: any;
  private ngUnsubscribe: Subject&lt;any&gt; = new Subject();





  constructor(private service: CategoryService,
              private route: ActivatedRoute,
              private cartService: ShoppingCartService) {


  }


ngOnInit() {

  this.route.queryParamMap.takeUntil(this.ngUnsubscribe).subscribe(params =&gt; {
    this.category = params.get('category');
    this.cartId = localStorage.getItem('cartId');
    if (this.category) {
        setTimeout(() =&gt; {
            this.service.allProductNames(this.category, this.cartId).takeUntil(this.ngUnsubscribe).subscribe(data =&gt; {
                this.filteredproducts = this.products = data;
            });
        }, 500);

    } else {
        if (this.cartId === null) {this.cartId = -1; }
        setTimeout(() =&gt; {
            this.service.getProducts(this.cartId).takeUntil(this.ngUnsubscribe).subscribe(data =&gt; {
                this.filteredproducts = data;
            });
        }, 500);


    }

  });


}


    addToCart(products: Product) {

        const cartId = this.cartService.getOrCreateCartId();

        if (!cartId) {
         const imero = new Date().getTime();
         this.cartService.create(imero).takeUntil(this.ngUnsubscribe).subscribe(res =&gt; {
           this.res = res;
           localStorage.setItem('cartId', this.res.id);
           this.route.queryParamMap.takeUntil(this.ngUnsubscribe).subscribe(params =&gt; {
           this.categoryid = params.get('category');
           if (this.categoryid) {
            this.cartService.createItem(products.id, this.res.id).
            takeUntil(this.ngUnsubscribe).subscribe(res1 =&gt; {
                setTimeout(() =&gt; {
                    this.service.allProductNames(this.category, this.res.id).takeUntil(this.ngUnsubscribe).subscribe(data =&gt; {
                        this.filteredproducts = this.products = data;});
                }, 500);

            });

           } else {
           this.cartService.createItem(products.id, this.res.id).takeUntil(this.ngUnsubscribe).subscribe(res2 =&gt; {
               setTimeout(() =&gt; {
                   this.service.getProducts(this.res.id).takeUntil(this.ngUnsubscribe).subscribe(data =&gt; {
                       this.filteredproducts = data;
                   });
               }, 500);

           } );
              }

                });
            });

        }


        else {
            this.route.queryParamMap.takeUntil(this.ngUnsubscribe).subscribe(params =&gt; {
                this.categoryid = params.get('category');
                this.cartId = localStorage.getItem('cartId');
                if (this.category) {
                    this.cartService.createItem(products.id, this.cartId).takeUntil(this.ngUnsubscribe).subscribe(res1 =&gt; {});
                    setTimeout(() =&gt; {
                        this.service.allProductNames(this.category, this.cartId).takeUntil(this.ngUnsubscribe).subscribe(data =&gt; {
                            this.filteredproducts = data;
                            });

                    }, 500);

                } else {
                    this.cartService.createItem(products.id, this.cartId).takeUntil(this.ngUnsubscribe).subscribe(res1 =&gt; {});
                    setTimeout(() =&gt; {
                        this.service.getProducts(this.cartId).takeUntil(this.ngUnsubscribe).subscribe(data =&gt; {
                            this.filteredproducts = data;
                            console.log(this.products);});

                    }, 500);
                }





            });

        }
    }



ngOnDestroy() {
  this.ngUnsubscribe.next();
  this.ngUnsubscribe.complete();
}

}
</code></pre>

<p>My products.html</p>

<pre><code>&lt;div class=""row""&gt;
  &lt;div class=""col-sm-3""&gt;
&lt;app-product-filter&gt;&lt;/app-product-filter&gt;
  &lt;/div&gt;
  &lt;div class=""col-sm-9""&gt;
    &lt;div class=""row""&gt;
      &lt;ng-container  *ngFor=""let p of filteredproducts; let i = index""&gt;
        &lt;div class=""col""&gt;
            &lt;div class=""card""&gt;
                &lt;img  class=""card-img-top"" src=""{{p?.imageUrl}}"" style=""max-height: 200px; width: 100%;""&gt;
                &lt;div class=""card-body""&gt;
                    &lt;h5 class=""card-title""&gt;{{p?.title}}&lt;/h5&gt;
                    &lt;p class=""card-text""&gt;{{p?.price | currency: 'EUR': symbol }}&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class=""card-footer""&gt;
                    &lt;button (click)=""addToCart(p)"" class=""btn btn-primary btn-block""&gt;Add to Cart&lt;/button&gt;
                    &lt;div *ngIf=""p?.quantity!=0""&gt;{{p?.quantity}}&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

        &lt;/div&gt;
        &lt;div *ngIf=""(i+1) % 2 === 0"" class=""w-100""&gt;&lt;/div&gt;
      &lt;/ng-container&gt;

    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
","9441948","","2185093","","2018-10-04 13:03:32","2018-10-04 13:03:32","Multiple subscribe angular 6","<angular><rxjs><observable><angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52645334","1","","","2018-10-04 11:14:51","","1","2954","<p><strong>What i have now:</strong> I have a custom autocomplete implementation, looks like this in html:</p>

<pre><code>&lt;input [formControl]=""parentFormControl""
       (mouseup)=""autocomplete()""
       (input)=""autocomplete()""&gt;

&lt;ul *ngIf=""showAutocompleteList""&gt;
  &lt;li *ngFor=""let listItem of autocompleteList; let index = index;""&gt;
    &lt;a role=""option"" href=""#"" type=""button"" (mousedown)=""select(listItem)"" [innerHtml]=""highlight(listItem)""&gt;&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>parentFormControl is the value behind the input (the modal so to speak), and is a FormControl. So this encapsulates the text which is displayed in input, and submitted with the submit button.</p>

<p>Now everytime i type or click in input, the function autocomplete is called, and makes a normal async call with subscribe:</p>

<pre><code>  autocomplete(): void {
    if (this.autocompleteSubscription) {
      this.autocompleteSubscription.unsubscribe();
    }
    this.autocompleteSubscription = this.http.get('url').subscribe(
      (autocompleteList:  Array&lt;OptionItem&gt;) =&gt; {
        this.autocompleteList = autocompleteList;
      }
    );
  }
</code></pre>

<p>I actually do not have any delay for the aysnc call, so everytime user types, I call the backend immediately. But imagine that user types 'Software', I of course do not want to display any irrelevant results. For example we typed 'Soft', and the XHR call is fired. We continue typing and typed 'Softw', another XHR call is fired, before the first call finished its job. So i actually immediately cancel the first execution, since it is not relevant anymore. That's why everytime the autocomplete function is called, i call the unsubscribe of the previous subscription. </p>

<p><strong>Question:</strong> Is this the way i should implement my autocomplete behaviour? I have seen tooday an artical about the exact same thing, but they implement this behaviour with a detailed (or pure?) rxjs, with Pipes. this is the link:
<a href=""https://blog.strongbrew.io/building-a-safe-autocomplete-operator-with-rxjs/"" rel=""nofollow noreferrer"">https://blog.strongbrew.io/building-a-safe-autocomplete-operator-with-rxjs/</a></p>

<p>I have also seen other examples which are pipes, but they also have in their html for me a bit foreign syntax like '{{ text$ | async }}'.</p>

<p>So i wanted to be sure, whether what i have now (subscribe &amp; unsubcribe) is a good way of achieving what I want? Or should i really change the implementation and implement sth like what they have? Which side has which pros and cons?</p>

<p>And if i should switch my implementation, can you provide an example code with my formControl as model?</p>

<p>Thanks in advance</p>

<p>Edit:</p>

<p>I now have sth like this:</p>

<pre><code>  ngOnInit(): void {
    this.parentFormControl.valueChanges
      .pipe(
        debounceTime(1000),
        distinctUntilChanged(),
        filter(value =&gt; this.myGetRequestCondition() ? true : false),
        switchMap((value: string) =&gt;  {
            return this.http.get('url' + value)
              .pipe(catchError(err =&gt; {
                 this.myErrorFunction(err);
                 return EMPTY;
              }));
        }))
      .subscribe(autocompleteList =&gt; {
        this.autocompleteList = autocompleteList;
      });
  }
</code></pre>
","2224454","","2224454","","2018-10-08 08:21:03","2018-10-08 08:21:03","How to make an async autocomplete in Angular 6 (rxjs 6), which does not show any irrelevant data by fast typing","<angular><rxjs><angular6><rxjs6>","2","5","","","","CC BY-SA 4.0"
"52690067","1","52690458","","2018-10-07 15:32:32","","3","2456","<p>I have been trying to use Rxjs in a node app. <code>fileList$</code> is the return from <code>fs.readdirsync</code> (an array of strings).</p>

<p>The first <code>map()</code> has a parameter called filename. </p>

<p><code>flatMap() readFileAsObservable()</code> uses <code>bindNodeCallback(fs.readFile)</code> to read the file.</p>

<p>My class <code>Testian</code> takes 2 args; The object created by <code>yaml-js</code> from reading the file and the <code>filename</code> from the first map. How can I access <code>filename</code> in the pipe where I have indicated?</p>

<pre><code>fileList$
    .pipe(
        map((filename: string) =&gt; `${resolvedDirPath}/${filename}`),
        flatMap(
            (filePath: string) =&gt; readFileAsObservable(filePath, 'utf8') as Observable&lt;string&gt;
        ),
        map((fileData: string) =&gt; yaml.safeLoad(fileData) as ITestYaml),
        map((testYaml: ITestYaml) =&gt; new Testian(testYaml, [I want to use filename here])),
        flatMap((testYaml: Testian) =&gt; {
            const prom: Promise&lt;{}&gt; = activeTests.set(testYaml);
            outgoing.sendTest(testYaml);
            return from(prom);
        })
    )
</code></pre>
","1329477","","3000206","","2018-10-07 15:34:28","2020-10-23 19:05:21","Keep access to variables between pipe operators","<node.js><rxjs6>","1","0","3","","","CC BY-SA 4.0"
"52705979","1","","","2018-10-08 15:53:36","","1","957","<p>I have a pipe like this:</p>

<pre><code>this.parentFormControl.valueChanges
  .pipe(
    debounceTime(500),
    distinctUntilChanged(),
    tap(() =&gt; {
      this.focusIndex = -1;
    }),
    filter(() =&gt; this.myCondition()),
    switchMap((value: string) =&gt; {
      return this.http.get(value).pipe(catchError(err =&gt; {
        this.myErrorFunction(err);
        return EMPTY;
      }));
    })
  )
</code></pre>

<p>And i would like to perform some other 'side' actions like in the tap operator, for the items which are filtered -removed- (which returned 'false' from 'myCondition()' so to speak) How do i do it?</p>
","2224454","","2224454","","2018-10-08 15:59:38","2018-10-08 16:10:05","Angular - RxJS - How to perform actions for the filtered items in chain?","<angular><rxjs><angular6><rxjs6>","2","5","","","","CC BY-SA 4.0"
"52708479","1","","","2018-10-08 18:55:45","","-1","33","<p>I have an angular service something like this:</p>

<pre><code>saveNewUser(user: User): Observable&lt;boolean&gt; {
  if (!user || !user.password) {
    return of(false);
  }

  return this.http.put(this.saveUrl, user).pipe(map((res: Response) =&gt; res.ok));
}
</code></pre>

<p>I am attempting a way to <code>return of(false);</code> to return only when the consumer of <code>saveNewUser(...)</code> subscribe to it. In other words, always return cold observable.</p>
","5104963","","5104963","","2018-10-08 19:37:28","2018-10-08 19:41:40","EDIT: disregard this question (How to return cold observable before making http call)","<angular><angular-httpclient><rxjs6>","1","4","","","","CC BY-SA 4.0"
"52727719","1","52728244","","2018-10-09 19:00:43","","5","1891","<p>Sometimes I need a value from previous observable and run another function that depend on that value and so on. It make nested subcribe() calls and then code is very ugly and unmanageable. I have an example here:</p>

<pre><code>getObservableData().subcribe(next=&gt;
    let dialogRef=this.dialog.open(EvalListComponent, {data: next})
    dialogRef.afterClosed().subscribe(next=&gt;{
        let k=dialogRef.componentInstance.getAnotherObservableData()
            .subcribe( next=&gt; doSomthing(next))
}))
</code></pre>

<p>What kind of solution can have situation like that. I need some flatten structure. I know there is a pipe function and can be use it with rxjs operators. But how can be it accomplished?</p>
","8708710","","10395768","","2018-10-10 04:20:52","2018-10-10 04:20:52","Avoiding nested subcribe() calls in RxJs 6","<angular><typescript><observable><rxjs6>","3","0","","","","CC BY-SA 4.0"
"52730265","1","52730691","","2018-10-09 22:39:44","","3","436","<p>I've been playing around with RxJS to explore the edges and came across something unexpected.  </p>

<p>Consider the following code:</p>

<pre><code>of(1)
.pipe(expand(x =&gt; of(x + 1)))
.subscribe(
    x =&gt; console.log(x), 
    err =&gt; console.log(err), 
    () =&gt; console.log('complete'));
</code></pre>

<p>When run in node, I expected this to produce an infinite list of numbers, each increasing by 1 that would eventually error out when it exceeded the max number in JavaScript, or I would kill it with Ctrl-C (on Windows).  What I didn't expect was that it would stop without an error after less than 1000 numbers had been logged.</p>

<p>What I got was the numbers 1 - 783 written to the console.  </p>

<p>Then it stopped.</p>

<p>Every time.</p>

<p>I run it.  It stops at 783 (which is not a special number - 256, 1024, etc).  It doesn't log an error or 'complete'.  It just stops.</p>

<p>I would have expected it to run 'forever', throw an error, or at least log out 'complete'.  But it just stops and returns me to a command line.</p>

<p>I did  some digging and thought that perhaps it had something to do with the optional concurrency parameter, which defaults to <code>Number.POSITIVE_INFINITY</code> according to the <a href=""https://rxjs-dev.firebaseapp.com/api/operators/expand"" rel=""nofollow noreferrer"">docs for expand</a>.</p>

<p>However, if I explicitly specify values for this parameter, I get equally weird results - i.e. a concurrency of 1 results in more values (consistently ~860) than a concurrency value of 1,000,000 (back to 783), more than 100 (~850), and more than 200 (~840).  It seems like the most values are emitted with a concurrency of 1, and then it slowly meanders down to a low of 783 values as you increase the concurrency.  That said, I have no idea if it is actually the concurrency that is affecting this, though it does seem related.</p>

<p>I took a quick peek at the source code for expand and didn't see anything that would explain this.  </p>

<p>This is not code that I would run in production, but it has piqued my curiosity.  Does anyone have any ideas for what could explain this?  </p>

<ul>
<li><p>RxJS 6.3.2 </p></li>
<li><p>Node 8.9.4</p></li>
</ul>

<p>Thanks,</p>

<p>TTE</p>
","1816009","","","","","2018-10-09 23:42:40","RxJS 6 expand not infinite?","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52743757","1","52744132","","2018-10-10 15:28:34","","0","829","<p>I'm trying to create an app with Angular 6 and using NGX-Erros module. I already updated rxjs imports to this: </p>

<pre><code>import { Observable, Subject, pipe,of  } from 'rxjs';
import { map, takeUntil, tap, catchError } from 'rxjs/operators';
</code></pre>

<p>And I still get this error : 
ERROR in ./node_modules/@ultimate/ngxerrors/src/ngxerror.directive.js   Can't resolve 'rxjs/Observable'</p>
","9468345","","5394220","","2018-10-10 15:57:31","2018-10-10 15:57:31","ngx-errors and angular6: Can´t resolve rxjs/Observable","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52748684","1","","","2018-10-10 20:58:19","","1","585","<p>I'm trying to use the async pipe as much as possible because I hear that's best practice since it manages observable subscriptions for you.</p>

<p>A very simplified version of my app looks something like this:</p>

<pre><code>export class OrderDetailComponent implements OnInit {
  order$: Observable&lt;Order&gt;;
  lineItems$: Observable&lt;LineItem&gt;;

  constructor(
    private orderService: OrderService,
    private lineItemService: LineItemService
  ) {}

  ngOnInit() {
    this.order$ = this.getOrders();
    this.lineItems$ = this.getLineItems();
  }

  private getOrders(): Observable&lt;Order&gt; {}
  private getLineItems: Observable&lt;LineItem[]&gt;;
}
</code></pre>

<p>And then the template looks something like this:</p>

<pre><code>&lt;div *ngIf=""order$ | async; let order""&gt;
  Order#: {{order.ID}}

  Line Items
  &lt;div *ngIf=""lineItems$ | async; let lineItems""&gt;
    &lt;div *ngFor=""let li of lineItems""&gt;
        &lt;app-lineitem-card [lineItem]=""li""&gt;&lt;/app-lineitem-card&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  Order Summary:
  Total: {{order.Total}}
&lt;/div&gt;
</code></pre>

<p>Obviously this is simplified but the point is that order is needed pretty much everywhere on the page so I'm using the async pipe on the outermost div. This works great on first page load but the situation i'm running into is I update part of the order which only actually affects a very small portion of the page, let's say order.Total. I know I can do the following to update the order:</p>

<pre><code>this.order$ = this.getOrder()
</code></pre>

<p>but that causes all of my components to be re-initialized (because of the ngIf).What's the correct way to handle this scenario?</p>
","6147893","","","","","2018-10-11 11:09:51","How can I update part of the value of an observable without re-rendering my whole page?","<angular><rxjs><rxjs6>","2","3","0","","","CC BY-SA 4.0"
"52749355","1","","","2018-10-10 21:59:52","","0","143","<p>I keep getting an error <code>You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.</code> in my angular project.
Basically, I am trying to access store state value in my effect like below:</p>

<pre><code>@Effect()
getHoles$ = this.actions$.pipe(
  ofType&lt;GetTreeHoles&gt;(HolesActions.GetTreeHoles),
  withLatestFrom(this.store.pipe(select(getLastDocumentSnapshot))),
  ...
</code></pre>

<p>However, when the code tries to resolve the observable below, it throws an error.</p>

<pre><code>this.store.pipe(select(getLastDocumentSnapshot))
</code></pre>

<p>I tried to step the code, and realize the code is failing in file rxjs' subscribeTo.js: </p>

<pre><code>if (result instanceof Observable_1.Observable) {
</code></pre>

<p>This if statement return <code>false</code>. This if statement should return true because the store extends Observable. So the code goes to the else statement below and throws an error:</p>

<pre><code>else {
    var value = isObject_1.isObject(result) ? 'an invalid object' : ""'"" + result + ""'"";
    var msg = ""You provided "" + value + "" where a stream was expected.""
        + ' You can provide an Observable, Promise, Array, or Iterable.';
    throw new TypeError(msg);
}
</code></pre>

<p>I changed the code to be something simple like:</p>

<pre><code>@Effect()
getHoles$ = this.actions$.pipe(
  ofType&lt;GetTreeHoles&gt;(HolesActions.GetTreeHoles),
  withLatestFrom(of(123)),
  ...
</code></pre>

<p>However, it stills returns the same error and fails because of <code>of(123)</code>, which does not make sense to me.</p>

<p>I remove the line with <code>withLatestFrom</code> and the effect works fine.</p>

<p>I double checked, I imported withLatestFrom correctly.</p>

<pre><code>import { catchError, switchMap, withLatestFrom } from 'rxjs/internal/operators';
</code></pre>

<p>My version:</p>

<pre><code>""@angular/animations"": ""^6.1.10"",
""@angular/cdk"": ""^6.4.7"",
""@angular/common"": ""^6.1.10"",
""@angular/compiler"": ""^6.1.10"",
""@angular/core"": ""^6.1.10"",
""@angular/forms"": ""^6.1.10"",
""@angular/http"": ""^6.1.10"",
""@angular/material"": ""^6.4.7"",
""@angular/platform-browser"": ""^6.1.10"",
""@angular/platform-browser-dynamic"": ""^6.1.10"",
""@angular/router"": ""^6.1.10"",
""@ngrx/effects"": ""^6.1.0"",
""@ngrx/router-store"": ""^6.1.0"",
""@ngrx/store"": ""^6.1.0"",
""@ngx-translate/core"": ""^10.0.2"",
""@ngx-translate/http-loader"": ""^3.0.1"",
""core-js"": ""^2.5.4"",
""firebase"": ""^5.5.3"",
""rxjs"": ""~6.2.0"",
</code></pre>

<p>This bug is driving me crazy. Please help me to resolve it. Thanks.</p>
","2675714","","","","","2018-10-10 21:59:52","Getting Error ngrx Store is not an instance of rxjs Observable","<angular><rxjs><ngrx><ngrx-store><rxjs6>","0","2","","","","CC BY-SA 4.0"
"52758954","1","52759075","","2018-10-11 11:28:21","","2","4953","<p>Trying to upgrade to Angular 6 from 5 and got this error:</p>

<blockquote>
  <p>ERROR in src/app/app.component.ts(26,23): error TS2339: Property
  'distinctUntilChanged' does not exist on type 'Observable'.</p>
</blockquote>

<p>I've imported distinctUntilChanged in app.module.ts:</p>

<pre><code>import ""rxjs/add/operator/distinctUntilChanged"";
</code></pre>

<p>And my code in app.component.ts:</p>

<pre><code>import { Component } from ""@angular/core""; import { Router, NavigationEnd } from ""@angular/router"";
import { TranslateService } from ""@ngx-translate/core"";
import { GeoService } from ""app/services/geo.service"";
import { ArbeteService } from ""app/services/arbete.service"";
import { GoogleAnalyticsEventsService } from ""app/services/google-analytics-events.service"";

import * as _ from ""lodash"";

@Component({
    selector: ""app-root"",
    templateUrl: ""./app.component.html"",
    styleUrls: [""./app.component.scss""]
})
export class AppComponent {

        //Send pageview to Google Analytics
        router.events.distinctUntilChanged((previous: any, current: any) =&gt; {
        if (current instanceof NavigationEnd) {
            return previous.url === current.url;
        }
        return true;
    }).subscribe((x: any) =&gt; {
        googleAnalytics.emitVirtualPageView(""Rekryteringsguiden"", ""Rekryteringsguiden"");
    });
</code></pre>

<p>What am I missing here?</p>
","7208045","","","","","2019-05-31 18:23:38","Property 'distinctUntilChanged' does not exist on type 'Observable<Event>'","<angular><angular5><angular6><rxjs5><rxjs6>","3","0","1","","","CC BY-SA 4.0"
"52760890","1","52761241","","2018-10-11 13:09:40","","3","6059","<p>I am trying to upgrade to Angular 6 from 5 and got this error:</p>

<blockquote>
  <p>ERROR in src/app/services/http.service.ts(17,14): error TS2339:
  Property 'timeout' does not exist on type 'Observable'.</p>
</blockquote>

<p>My code in http.service.ts:</p>

<pre><code>import { throwError as observableThrowError,  Observable } from 'rxjs';
import { Injectable } from '@angular/core';
import { environment } from ""environments/environment"";
import { AppService } from 'app/app.service';
import { HttpClient } from '@angular/common/http';

@Injectable()
export class HttpService {

    private baseUrl = environment.apiUrl;

    constructor(private http: HttpClient, private appService: AppService) { }

    public get(endpoint: string): Observable&lt;any&gt;{
        return this.http.get(this.baseUrl + endpoint)
            .timeout(this.appService.timeoutInterval)
            .retryWhen(error =&gt; error.delay(this.appService.waitInterval)
                .take(this.appService.numberOfRetries)
                .concat(observableThrowError(new Error())))
            .share();
    }
}
</code></pre>

<p>What am I missing here?</p>
","7208045","","1205871","","2018-10-11 13:28:51","2020-06-04 06:56:38","Property 'timeout' does not exist on type 'Observable<Object>'","<angular><angular5><angular6><rxjs5><rxjs6>","4","1","","","","CC BY-SA 4.0"
"52764600","1","52764849","","2018-10-11 16:12:31","","2","1028","<p>I'm trying to wrap an event-based API with RXJS Observables, but I can't figure out how to clean up after myself after an unsubscription happens.</p>

<p>This is pretty much how I would sync up the subscription with the Observable and the event-based API:</p>

<pre><code>interface SomeEventService{
    registerListener(messageName: string, messageContent: Something): Listener;
    unregisterListener(listener: Listener);
}

class MyWrapper {
    private eventService: SomeEventService;

    streamOfSomething$(): Observable&lt;Something&gt; {
        return Observable.create((observer: Observer&lt;Something&gt;) =&gt; {
            // Create a listener, and relay events to the Observable
            const listener = this.eventService.registerListener(""something"", something =&gt; {
                observer.next(something);
            })
            // Now what?
        })
    }
}
</code></pre>

<p>The problem here is that at some time in the future I want to call <code>eventService.unregisterListener</code>, e.g when the consumer of <code>streamOfSomething$</code> unsubscribes from the stream.</p>

<p><strong>The question:</strong> How do I do this? As far as I can tell there is no event or callback I can use on my <code>observer</code> to run code after an unsubscribe happens.</p>
","2279621","","","","","2018-10-11 16:25:45","React to rxjs unsubscribe","<angular><typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52769658","1","52771231","","2018-10-11 22:17:36","","0","35","<p>I have to make multiple serialise call on server side in <strong>NodeJs</strong> using  <a href=""https://www.npmjs.com/package/request"" rel=""nofollow noreferrer"">request module</a> , and <strong>RxJs Observable</strong></p>

<p>I have array of Url Address like ['www.google.com','facebook.com']
When I make request to call then server get busy in event loop . I want to know when my last url call gets response so that I can send response to front end
here is my code so far</p>

<pre><code> const foo = Observable.create(function (observer) {
         res.writeHeader(200, { ""Content-Type"": ""text/html"" });
         var str = '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt; Following are the responses: &lt;/h1&gt;&lt;ul&gt;'
         res.write(str);
         let count = 0;
         addressesArray.forEach(function (element, i) {

         observer.next(element);
         if (some Condition) {
            console.log('here i want to call complete when I get last response')     
       // observer.complete();   
         }


         })
     }) 
</code></pre>

<p>and this is my subscribe function </p>

<pre><code>     const subscription = foo.subscribe({
         next : addres =&gt;
         {
             request(addres , function (error, response, body) {
                if (!error &amp;&amp; response.statusCode == 200) {

                     console.log(response)


                 }
                if (typeof response === ""undefined"" || typeof body === ""undefined"") {
                     console.log('No resp')
                 }
            })

     },
     complete:()=&gt;{console.log('done')}


 })
</code></pre>
","5669114","","","","","2018-10-12 15:04:36","multiple serialise call in rxjx on server side using Request module","<node.js><asynchronous><rxjs><observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52774281","1","52774516","","2018-10-12 07:17:15","","8","9575","<p>Any suggestions, how this can be rewritten in more promise-chaining style?:</p>

<pre><code>this.apiService.sendPutRequest('/api/users/activate', usrObj).pipe(
        map(() =&gt; {
            return this.apiService.sendGetRequest('/api/users/' + this.currentUserId).pipe(
                map(data =&gt; {
                    return this.setActiveUser(data).pipe(
                        map(() =&gt; {
                            return this.apiService.sendGetRequest('api/tasks/user/' + this.currentUserId).pipe(
                                map(tasks =&gt; {
                                    return this.taskService.setCurrentUserTasks(tasks);
                                })
                            );
                        })
                    );
                })
            );
        })
    );
</code></pre>
","1227950","","","","","2018-10-12 08:39:06","How to properly chain rxjs 6 observables?","<angular><rxjs><observable><rxjs6>","3","0","1","","","CC BY-SA 4.0"
"52774929","1","52775124","","2018-10-12 08:00:40","","2","370","<p>In my <code>AppComponent.ts</code> file, I made a HTTP GET call using <code>HttpClient</code>. </p>

<pre><code>import { Component } from '@angular/core';
import { Observable, Subscriber, Unsubscribable } from 'rxjs';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'app';
  ob: Observable&lt;any&gt; = null;

  constructor(private httpClient: HttpClient) {

    httpClient.get("""").subscribe((response) =&gt; {
      console.log(response);
    });
  }
}
</code></pre>

<p>Then I also have an interceptor which intercepts the Http call and returns some static data (lets say cache for an example).</p>

<pre><code>import { Injectable } from ""@angular/core"";
import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';
import { Observable, of } from ""rxjs"";

@Injectable()
export class CustomHttpInterceptor implements HttpInterceptor {
    intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;any&gt; {
        return of({});
    }
}
</code></pre>

<p>However the subscription in <code>AppComponent.ts</code> file, doesn't receive any response. In fact the subscribe success or error function doesn't even gets hit.
There are no console errors either. Anyone have any idea what is going on here?</p>

<p><strong>NOTE</strong>
I have changed the return type from <code>Observable&lt;HttpEvent&lt;any&gt;&gt;</code> to <code>Observable&lt;any&gt;</code> as TypeScript wasn't able to cast <code>Observable&lt;{}&gt;</code> to <code>Observable&lt;HttpEvent&lt;any&gt;&gt;</code>.</p>
","815600","","815600","","2018-10-12 08:05:51","2018-10-12 11:19:00","Unable to subscribe data from Interceptor","<rxjs><angular6><interceptor><angular-httpclient><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52775507","1","52775517","","2018-10-12 08:36:46","","1","1026","<p>How to update the old syntax of <strong>Observable.merge()</strong> in <strong>rxjs 6+</strong> ?
The old syntax looks like this: 
<code>Observable.merge(...array).map(() =&gt; {});</code>
What should be the correct syntax using <strong>rxjs 6</strong> ? </p>
","6432698","","","","","2018-10-12 09:12:19","update Rxjs static merge Observable to version 6 syntax","<angular><rxjs><observable><reactive-programming><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"52796730","1","52796872","","2018-10-13 19:48:58","","2","3300","<p>I'm using Angular 6 and Rxjs 6.</p>

<p>The following code will throw undefined at the <code>ListFormsComponent</code> over and over and over until the <code>Observable</code> is assigned by <code>getForms()</code> at which it will then display the data. The <code>getForms()</code> is called by the navigation service when attempting to navigate to <code>ListFormsComponent</code> page. </p>

<p>FormService.ts</p>

<pre><code>export class FormService {

  public forms$: Observable &lt;Array&lt;Form&gt;&gt; ;
  public assignedForms$: Observable &lt;Array&lt;Form&gt;&gt; ;
  public form$: Observable &lt;Form&gt;;
  constructor(
    private afs: AngularFirestore,
    private authService: AuthService,
  ) {}

  getForms() {
    let zippedData = zip(this.authService.user$);
    zippedData.subscribe(data =&gt; {
      this.forms$ = this.afs.collection('networks')
        .doc(data[0].activeNetworkProfile.id)
        .collection('companyProfiles')
        .doc(data[0].activeCompanyProfile.id)
        .collection&lt;Forms&gt;('inspectionForms')
        .valueChanges();
    })
  }

}
</code></pre>

<p>ListFormsComponent.ts</p>

<pre><code>export class ListFormsComponent implements OnInit {
  public forms: Forms[];
  constructor(private formService: FormService, private navigateService: NavigationService) {

    this.formService.forms$.subscribe(forms =&gt; { //&lt;---Error here this.formService.forms$ is undefined
      this.forms = forms;
      console.log(""Forms inside component"");
      console.log(this.forms);
    })
  }
}
</code></pre>

<p>ListFormsComponent.html</p>

<pre><code>&lt;mbsc-listview [options]=""listSettings"" style=""display:none""&gt;
  &lt;mbsc-listview-item (click)=""viewDetails(form.id)"" *ngFor=""let form of forms""&gt;
    &lt;h3 class=""mbsc-lv-txt""&gt;{{form.name}}&lt;/h3&gt;
    &lt;p class=""mbsc-lv-txt""&gt;{{form.lastEdited | date: 'medium'}} &lt;/p&gt;
  &lt;/mbsc-listview-item&gt;
&lt;/mbsc-listview&gt;
</code></pre>

<p>NavigationService.ts</p>

<pre><code>navigateForms() {
  this.formService.getForms();
  this.navigateService.navigate('forms');
}
</code></pre>

<p>So I then decided to initialize the observable by doing the following code(see below) in the constructor of FormService.ts and it stops the errors but It does not trigger the subscription in the <code>ListFormsComponent.ts</code>. I'm assuming when <code>valueChanges()</code> returns the <code>Observable</code> to <code>forms$</code> it breaks rest of the <code>subscriptions</code>. </p>

<pre><code>this.forms$ = new Observable&lt;Array&lt;Forms&gt;&gt;();
</code></pre>
","1869811","","1869811","","2018-10-13 20:26:12","2018-10-13 20:42:42","How do I properly initialize and assign a observable using angulafire2?","<angular><typescript><angularfire2><rxjs6>","1","3","","","","CC BY-SA 4.0"
"52800850","1","52801181","","2018-10-14 08:28:18","","0","131","<p>I have an angularFirestore observable array inside users.service.ts:</p>

<pre><code>$users: Observable&lt;Array&lt;any&gt;&gt;;
constructor()
{
    this.$users = this.angularFirestore.collection('users').valueChanges();
}
</code></pre>

<p>This is the object class:</p>

<pre><code>class User
{
    name: string;
    status: boolean;
    index: number;
}
</code></pre>

<p>I need to filter based on multiple fields but somehow using the following code in users.component.ts does not subscribes any results:</p>

<pre><code>users: Users[];
ngOnInit()
{
    this.usersService.$users.pipe
    (filter((user: User) =&gt; user.name == 'some value'))
    .subscribe((users: User[]) =&gt;
    {
        this.users = users;
    });
}
</code></pre>

<p>My end goal is to be able to filter to include <em>user.name search string</em> and user.status == true and exclude the rest of the invalid results.</p>

<p>I would like to do this without pipes. would appreciate any help on correcting and improving upon the existing code to achieve the above. Thanks in advance!</p>
","776914","","776914","","2018-10-14 08:41:57","2018-10-14 09:14:19","rxjs6 filter Observable<Array<any>>","<angular><angularfire2><rxjs6>","2","3","","","","CC BY-SA 4.0"
"52803121","1","52803137","","2018-10-14 13:24:15","","5","3620","<p>I updated my material angular project to include an expandable detail row in my table. I needed to upgrade to rsjx 6 for this. Now I get the following error. I'm totally new with angular, so unfortunately I don't have a clue how to resolve this.</p>

<pre><code>Property 'merge' does not exist on type 'typeof Observable'.
</code></pre>

<p>Can anyone help to resolve this error?</p>

<p><strong>app.component.ts</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>  /** Connect function called by the table to retrieve one stream containing the data to render. */
  connect(): Observable&lt;Track[]&gt; {
    // Listen for any changes in the base data, sorting, filtering, or pagination
    const displayDataChanges = [
    this._exampleDatabase.dataChange,
    this._sort.sortChange,
    this._filterChange,
    this._paginator.page
    ];

    this._exampleDatabase.getAllTracks();

    return Observable.merge(...displayDataChanges).map(() =&gt; {
      // Filter data
      this.filteredData = this._exampleDatabase.data.slice().filter((track: Track) =&gt; {
        const searchStr = (track.id + track.title + track.artist + track.year + track.comment + track.path).toLowerCase();
        return searchStr.indexOf(this.filter.toLowerCase()) !== -1;
      });

      // Sort filtered data
      const sortedData = this.sortData(this.filteredData.slice());

      // Grab the page's slice of the filtered sorted data.
      const startIndex = this._paginator.pageIndex * this._paginator.pageSize;
      this.renderedData = sortedData.splice(startIndex, this._paginator.pageSize);
      return this.renderedData;
    });
  }</code></pre>
</div>
</div>
</p>
","10502779","","6782707","","2020-02-23 05:01:57","2020-02-23 05:01:57","RxJS updated, Property 'merge' does not exist on type 'typeof Observable'","<angular><rxjs><rxjs6>","2","2","1","","","CC BY-SA 4.0"
"52804070","1","","","2018-10-14 15:11:31","","1","496","<p>I have  a below method to have a service call when using map inside map first time which goes to catchError and then automatically goes to response.</p>

<pre><code>fetchProduct(): Observable&lt;Model[]&gt; {
    return this.http.get&lt;DataModel[]&gt;(Product_URL).pipe(
      map(res =&gt; {       
        return res.map((item: DataModel) =&gt; {
          return this.Mapper(item.code, item.name);
         });
      }),
       catchError(error =&gt; this.handleError(error)
    );
  }
</code></pre>

<p>when i using without map , which call once .</p>

<pre><code>fetchProduct(): Observable&lt;Model[]&gt; {
    return this.http.get&lt;DataModel[]&gt;(Product_URL).pipe(
      map(res =&gt; {       
       console.log(res);
      }),
       catchError(error =&gt; this.handleError(error)
    );
  }
</code></pre>

<p>whats wrong with the first implementation why which calls twice</p>
","4031891","","","","","2018-10-14 15:11:31","Rxjs pipe call two times when have a service call with map inside map","<angular><angular5><angular6><angular-services><rxjs6>","0","8","","","","CC BY-SA 4.0"
"52812813","1","","","2018-10-15 08:44:37","","0","334","<p>Is there an observable in RxJS that emits in a date range?</p>

<p>For instance, <code>interval(1000)</code> would emit every second. I could use this to check the current date, but I didn't know if RxJS (or JavaScript really) has a method I could hook into that emits when subscribed based on if I'm in a certain date range or at a specific time like October 1st, 2019 at midnight.</p>
","1624862","","","","","2018-10-15 14:53:32","RxJS Observable that emits in a date range?","<rxjs><scheduled-tasks><scheduler><rxjs5><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52817473","1","52820479","","2018-10-15 13:04:17","","3","919","<p>So I have a timer where I call an api every 60 seconds (it's a digital signage app so there won't be any interaction yet I want it to auto update)</p>

<p>I have various components that load different api calls but the problem is, when I'm trying to unsubscribe to these timer subscriptions ondestroy it simply does not work.</p>

<p>I go in, test by routing to 2 components back and forth 5-6 times. This should normally kil subscription everytime I go to the next one.</p>

<p>After 60 seconds passes, there's as many api calls being made as many times I've switched between those two. so I've created a timer subscription everytime I went on one of the components but did not destroy them.</p>

<p>EDIT, added my full OnInit and OnDestroy code below:</p>

<pre><code>ngOnInit() {

    let mainTimer = timer(0, 60000);

    this.dataSourceSubscription = mainTimer.subscribe(t =&gt; {
      this.service.getSection3();
      this.dataSourceSubscription = this.section3.subscribe(data =&gt; {
        let countAccepted = data =&gt; {
          for (let i = 0; i &lt; data.length; i++) {
            if (
              data[i].DeliveryStatus == ""Accepted"" &amp;&amp;
              data[i].BookingId == ""0""
            ) {
              this.multidropAccepted++;
            }
          }
        };

        let countDepartedSite = data =&gt; {
          for (let i = 0; i &lt; data.length; i++) {
            if (
              data[i].DeliveryStatus == ""Departed Site"" &amp;&amp;
              data[i].BookingId == ""0""
            ) {
              this.multidropDepartedSite++;
            }
          }
        };


        let countPending = data =&gt; {
          for (let i = 0; i &lt; data.length; i++) {
            if (
              data[i].DeliveryStatus == ""Pending"" &amp;&amp;
              data[i].BookingId == ""0""
            ) {
              this.multidropPending++;
            }
          }
        };

        let countOnSite = data =&gt; {
          for (let i = 0; i &lt; data.length; i++) {
            if (
              data[i].DeliveryStatus == ""On Site"" &amp;&amp;
              data[i].BookingId == ""0""
            ) {
              this.multidropOnSite++;
            }
          }
        };

        let countTurnedAway = data =&gt; {
          for (let i = 0; i &lt; data.length; i++) {
            if (
              data[i].DeliveryStatus == ""Turned Away"" &amp;&amp;
              data[i].BookingId == ""0""
            ) {
              this.multidropTurnedAway++;
            }
          }
        };


        (this.dataSource = new MatTableDataSource(
          data.filter(
            (value, index, array) =&gt;
              !array.filter(
                (v, i) =&gt; JSON.stringify(value) == JSON.stringify(v) &amp;&amp; i &lt; index
              ).length
          )
        )),
          (this.dataSource.sort = this.sort),
          (this.dataSource.paginator = this.paginator),
          this.multidropAccepted = 0;
          this.multidropDepartedSite = 0;
          this.multidropPending = 0;
          this.multidropOnSite = 0;
          this.multidropTurnedAway = 0;
          countAccepted(data),
          countDepartedSite(data),
          countPending(data),
          countOnSite(data),
          countTurnedAway(data),
          this.totalDeliveries = data.length;
      });

      this.lastUpdated.subscribe(data =&gt; {
        console.log(data);
      })
    })


    let pageTimer = timer(10000, 10000);

    this.pageSubscription = pageTimer.subscribe(t =&gt; {
      if (
        this.dataSource.paginator._pageIndex ==
        this.dataSource.paginator.getNumberOfPages()
      ) {
        this.dataSource.paginator.firstPage();
      } else {
        this.dataSource.paginator.nextPage();
      }
    });
  }

  ngOnDestroy() {
    this.dataSourceSubscription.unsubscribe();
    this.pageSubscription.unsubscribe();
  }

  applyFilter(filterValue: string) {
    this.dataSource.filter = filterValue.trim().toLowerCase();

    if (this.dataSource.paginator) {
      this.dataSource.paginator.firstPage();
    }
  }
</code></pre>
","10064334","","10064334","","2018-10-15 16:43:55","2018-10-15 16:48:08","Angular6 rxjs unsubscribing to timer subscription OnDestroy does not work?","<angular><rxjs><angular6><angular2-observables><rxjs6>","1","5","","","","CC BY-SA 4.0"
"52817690","1","","","2018-10-15 13:18:23","","0","327","<p>I'm using rxjs in angular 6 application and I'm building a component which has a <code>downloadUrl: Observable&lt;string&gt;</code> which is populated when I fetch the url from firebase storage.</p>

<p>I need to assign an initial value which is passed to the component using the <code>@Input attribute (@Input imagesrc:string)</code> and I've tried emitting a value to the downloadurl as (in <code>ngOnInit</code>) :</p>

<pre><code>let emitter;
this.downloadURL = Observable.create(e =&gt; emitter = e)
emitter.next(this.imagesrc);
</code></pre>

<p>However, this is incorrect since I'm receiving console error messages that <code>emitter</code> is undefined. How would I be able to manually emit the value of <code>imagesrc</code> into downloadURL?</p>
","3836415","","2622292","","2018-10-15 16:44:15","2018-10-15 16:44:15","Manually emitting a value to an observable","<angular><rxjs6>","1","1","","","","CC BY-SA 4.0"
"52833823","1","52922986","","2018-10-16 10:53:52","","-2","749","<p>I have multiple requests with dynamic parameter array parameter in observable interval. So how can I return a subject based on the array parameter. Because of the <code>BehaviorSubject</code> contain all data in it</p>

<p><strong>initialize subject</strong></p>

<pre><code>getSchedularData: BehaviorSubject &lt; any &gt; = new BehaviorSubject &lt; any &gt; (null);
constructor(private httpClient: HttpClient, ) {
  SchedulerStore.select('jobSchedulerState')
    .subscribe(response =&gt; {
      this.schedularDataCollector = response;
    });
}
</code></pre>

<p><strong>component</strong></p>

<pre><code>this.schedulerService.startScheduler(this.channelList1)
  .subscribe((value) =&gt; {
    // console.log(value);
    // tslint:disable-next-line:forin
    for (const keys in value) {
      this.schedularData[keys] = value[keys];
    }
  });
</code></pre>

<p><strong>service</strong></p>

<pre><code>Observable.interval((!this.backChannelEnvironment.schedularInterval) ? 10000 : this.backChannelEnvironment.schedularInterval)
  .pipe(
    map(() =&gt; {
      /**
       * dispatch request for schedular for requesting http request for channel
       */
      this.SchedulerStore.dispatch(new SchedulerAction.GetScheduler(Channels));
    })
  )
  .subscribe(() =&gt; {
    /**
     * get data from schedular store and return it at schedular interval
     */
    if (this.schedularDataCollector != null) {
      if (JSON.stringify(this.schedularDataCollector['jobScheduler']) !==
        JSON.stringify(this.getSchedularData.value)) {

        this.getSchedularData.next(this.schedularDataCollector['jobScheduler']);
      }
    }
  });
return this.getSchedularData.asObservable();
</code></pre>
","5181115","","2622292","","2018-10-26 13:53:20","2018-10-26 13:53:20","RXJS subject and behaviour subject","<angular><rxjs5><rxjs6>","2","3","","","","CC BY-SA 4.0"
"52836516","1","","","2018-10-16 13:24:32","","1","194","<p>How should I implement my <strong>Observables</strong> to get the following behavior in <strong>RxJS 6</strong>?</p>

<p><a href=""https://i.stack.imgur.com/l981g.png"" rel=""nofollow noreferrer"">RxMarble diagram</a></p>

<p><strong>Description:</strong>
I'm trying to create a buffer[1] of incoming Observable[0] values, that buffers out after a debounce[2] time of the same Observable[0].</p>

<p>This is what I've got for now:</p>

<pre><code>const Observable = rxjs.Observable;
const buffer = rxjs.operators.buffer;
const debounceTime = rxjs.operators.debounceTime;

const DEBOUNCE_TIME_SPAN = 2000;
let $observableObserver = null;

// Custom cold observable.
const $observable = Observable.create((observer) =&gt; {
  // Exposed observer
  $observableObserver = observer;
  // Manual entries
  observer.next(0);
});

// Debounce time observable (OK)
const $debouncedObservable = $observable
  .pipe(debounceTime(DEBOUNCE_TIME_SPAN));

// Buffered observable (THIS DOES NOT WORK)
const $bufferObservable = $debouncedObservable
  .pipe(buffer($observable));

// So this doesn't print something correct.
$bufferObservable.subscribe({
  next: v =&gt; console.log(v),
});
</code></pre>
","6743608","","6743608","","2018-10-18 07:40:33","2018-10-18 07:40:33","RxJS 6 buffer with debounce as closingNotifier","<javascript><buffer><rxjs6><debounce>","0","0","","","","CC BY-SA 4.0"
"52840416","1","","","2018-10-16 16:51:43","","0","1643","<p>I am trying to use <code>ngbTypeahead</code> on a basic Angular 6 application.  There aren't a whole lot of other dependencies in the application.  I keep getting the following method signature not found error...</p>

<pre><code>ERROR TypeError: Object(...)(...) is not a function
at Observable.push../node_modules/rxjs/_esm5/internal/Observable.js.Observable.pipe (Observable.js:91)
</code></pre>

<p>If I follow this line it ends up at this code which is the method it is looking for.</p>

<pre><code>return pipeFromArray(operations)(this);
</code></pre>

<p>Here are the imports</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import {Observable} from 'rxjs';
import {debounceTime, map} from 'rxjs/operators';
</code></pre>

<p>Here is my package.json</p>

<pre><code>{
  ""name"": ""myapp"",
  ""version"": ""1.0.0"",
  ""scripts"": {
    ""ng"": ""ng"",
    ""start"": ""ng serve --proxy-config proxy.conf.json"",
    ""build"": ""ng build"",
    ""test"": ""ng test"",
    ""lint"": ""ng lint"",
    ""e2e"": ""ng e2e""
  },
  ""private"": true,
  ""dependencies"": {
    ""@angular/animations"": ""^6.1.0"",
    ""@angular/common"": ""^6.1.0"",
    ""@angular/compiler"": ""^6.1.0"",
    ""@angular/core"": ""^6.1.0"",
    ""@angular/forms"": ""^6.1.0"",
    ""@angular/http"": ""^6.1.0"",
    ""@angular/platform-browser"": ""^6.1.0"",
    ""@angular/platform-browser-dynamic"": ""^6.1.0"",
    ""@angular/router"": ""^6.1.0"",
    ""@ng-bootstrap/ng-bootstrap"": ""^3.0"",
    ""core-js"": ""^2.5.4"",
    ""rxjs"": ""^6.1.0"",
    ""rxjs-compat"": ""^6.1.0"",
    ""zone.js"": ""~0.8.26""
  },
  ""devDependencies"": {
    ""@angular-devkit/build-angular"": ""~0.7.0"",
    ""@angular/cli"": ""~6.1.2"",
    ""@angular/compiler-cli"": ""^6.1.0"",
    ""@angular/language-service"": ""^6.1.0"",
    ""@types/jasmine"": ""~2.8.6"",
    ""@types/jasminewd2"": ""~2.0.3"",
    ""@types/node"": ""~8.9.4"",
    ""codelyzer"": ""~4.2.1"",
    ""jasmine-core"": ""~2.99.1"",
    ""jasmine-spec-reporter"": ""~4.2.1"",
    ""karma"": ""~1.7.1"",
    ""karma-chrome-launcher"": ""~2.2.0"",
    ""karma-coverage-istanbul-reporter"": ""~2.0.0"",
    ""karma-jasmine"": ""~1.1.1"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""protractor"": ""~5.3.0"",
    ""ts-node"": ""~5.0.1"",
    ""tslint"": ""~5.9.1"",
    ""typescript"": ""~2.7.2""
  }
}
</code></pre>
","3735715","","","","","2021-04-26 13:45:03","ngbTypeahead not working with Angular 6 and ng-bootstrap","<angular><ng-bootstrap><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52852283","1","52858791","","2018-10-17 10:07:00","","1","625","<p>I am using rxjs 6 with redux-observable 1 and write test for epic</p>

<pre><code>const signInEpic = action$ =&gt;
  action$
    .ofType(authActions.signIn)
    .pipe(
      switchMap(mapSignInAction$)
    )
</code></pre>

<p>I am using TestScheduler for testing by marble diagrams and when run test it return error <code>action$.ofType is not a function</code></p>

<p>test:</p>

<pre><code>import { TestScheduler } from 'rxjs/testing'

const scheduler = new TestScheduler((actual, expected) =&gt; {
  expect(actual).toEqual(expected)
})

scheduler.run(({ cold, hot, expectObservable }) =&gt; {
    const action$ = hot('-a', { a: { type: 'HFJKDHF' } })
    const state$ = null
    const output$ = signInEpic(action$, state$)

    expectObservable(output$).toBe('--b', {
      b: actions.signInSuccess(response)
    })
  })
</code></pre>
","10207166","","","","","2018-10-17 15:43:54","ofType is not a function in testing with rxjs marble diagrams","<redux><rxjs><rxjs6><redux-observable>","2","0","1","","","CC BY-SA 4.0"
"52854782","1","","","2018-10-17 12:21:51","","1","263","<p>When I send a request and the response is a 401 status, I want to display modal box (with user and password) to relog the user and after, resend the original request.</p>

<p>I found really interesting post with the previous version of RxJs and I cannot update it to the new version <a href=""https://stackoverflow.com/questions/36654920/how-to-catch-an-error-on-a-request-then-open-a-modal-then-retry-when-modal-clo"">How to catch an error on a Request, then open a modal, then retry when modal closes with RxJS</a></p>

<p>When I have a 401, my code display the modal, but in the same time, it resend my request and it doesn't wait the closing action.</p>

<p>Can you help me ?</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>return this.http.get&lt;Object&gt;('http://localhost/test', httpOptions).
        pipe(
            tap(),
            retryWhen(errors =&gt;
                errors.pipe(
                    tap(val =&gt; {
                        if (val.status === 401) {
                            let closedSubject = new Subject();
                            let modalRef = this.modalService.open(ModalLoginComponent);
                            modalRef.result.then((data) =&gt; {
                                console.log('closed me');
                                closedSubject.next(val);

                            }, (reason) =&gt; {
                            });
                            return &lt;any&gt;closedSubject;
                        }
                        else {
                            return Observable.throw(val.json());
                        }
                    })
                )
            )
        );</code></pre>
</div>
</div>
</p>
","8759738","","","","","2018-11-14 08:03:33","Angular 6 and RxJs 6 display modal if 401","<angular><rxjs6>","1","2","","","","CC BY-SA 4.0"
"52891267","1","","","2018-10-19 11:12:50","","2","170","<p>So i just recently began updating the version of rxjs on my react project, following the instructions given here: <a href=""https://rxjs-dev.firebaseapp.com/guide/v6/migration"" rel=""nofollow noreferrer"">https://rxjs-dev.firebaseapp.com/guide/v6/migration</a></p>

<p>according to the instructions everything should work as normal with the compatibility layer installed as well. The 'breaking changes not covered by rxjs-compat' are not relevant to my project.</p>

<p>all I have done is run the command <code>npm install rxjs@6 rxjs-compat@6 --save</code> and now i get the following error when trying to run my site: </p>

<pre><code>Uncaught TypeError: Cannot set property 'bindCallback' of undefined
at Object.defineProperty.value (bindCallback.js:4)
at __webpack_require__ (bootstrap aec2a29d759a238a1d9d:54)
at Object.__webpack_exports__.a (Rx.js:17)
at __webpack_require__ (bootstrap aec2a29d759a238a1d9d:54)
at Object.defineProperty.value (Rx.js:6)
at __webpack_require__ (bootstrap aec2a29d759a238a1d9d:54)
at Object.defineProperty.value (Subject.js:3)
at __webpack_require__ (bootstrap aec2a29d759a238a1d9d:54)
at Object.module.exports (Subject.js:6)
at __webpack_require__ (bootstrap aec2a29d759a238a1d9d:54)
</code></pre>

<p>Can anybody help me with this? I have done a lot of research but most sources seem to cover angular rather than react, also everywhere seems to declare that all old syntax and imports should run fine</p>

<p>extra note: if I update the syntax and imports to those associated with rxjs 6 alone, everthing works fine, but as rxjs themselves say, it should work fine with old syntax (so long as rxjs-compat is installed), and i want to keep the old syntax for now so that things can be introduced and tested step by step.</p>
","10528669","","10528669","","2018-10-19 11:18:37","2019-02-08 08:31:28","upgrading from rxjs v5.5.6 to rxjs v6.3.3 with rxjs-compat v6.3.3","<reactjs><react-redux><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52912709","1","53455956","","2018-10-21 06:31:59","","0","206","<p>First, the start button is stopped, then click restore01 button and restore02 button the start button restored,</p>

<p>then the bug is when click stop button01 or stop button02 then the stop button should be stopped, but not</p>

<p>notice console.log, the start button is stopped when start, then you click restore01 and restore02, then the start button works, and now the bug is coming like winter, when I click stop01 button or stop02 button, in console.log it show stop stream Array [ ""r"", """" ] but the start button still works, not be stopped, can you image my feeling about see this circumstances? oh my god</p>

<p><a href=""https://codepen.io/dxcqcv/pen/QZBEqJ?editors=1010"" rel=""nofollow noreferrer"">online demo</a></p>

<p>the code is blow</p>

<pre><code>const startDom = document.querySelector(""#start"")
const numberDom = document.querySelector(""#number"")
const restoreDom01 = document.querySelector(""#restore01"")
const stopDom01 = document.querySelector(""#stop01"")
const restoreDom02 = document.querySelector(""#restore02"")
const stopDom02 = document.querySelector(""#stop02"")

let init01 = false
let init02 = false

const origin01$ = new rxjs.Subject()
const origin02$ = new rxjs.Subject()

const restore01$ = rxjs.fromEvent(restoreDom01, ""click"")
restore01$.subscribe(() =&gt; origin01$.next(""r""))
const stop01$ = rxjs.fromEvent(stopDom01, ""click"")
stop01$.subscribe(() =&gt; origin01$.next(""""))

const restore02$ = rxjs.fromEvent(restoreDom02, ""click"")
restore02$.subscribe(() =&gt; origin02$.next(""r""))
const stop02$ = rxjs.fromEvent(stopDom02, ""click"")
stop02$.subscribe(() =&gt; origin02$.next(""""))

const [stopReg$, right$] = rxjs
.combineLatest(origin01$, origin02$)
.pipe(rxjs.operators.partition(arr =&gt; arr.some(isEmpty)));
const restoreReg$ = right$.pipe(
  rxjs.operators.take(1),
  rxjs.operators.repeatWhen(() =&gt; stopReg$)
);


const start$ = rxjs.fromEvent(startDom, ""click"");
start$
  .pipe(
  rxjs.operators.mapTo(1),
  rxjs.operators.scan((acc, cur) =&gt; acc + cur, 0),
  rxjs.operators.takeUntil(stopReg$),
  rxjs.operators.repeatWhen(() =&gt; restoreReg$)
)
  .subscribe(x =&gt; (numberDom.innerHTML = x));


stopReg$.subscribe(x =&gt; console.log(""stop stream"", x));
restoreReg$.subscribe(x =&gt; console.log(""restore stream"", x));

origin01$.next("""")
origin02$.next("""")

function isEmpty(n) {
  return n === """";
}
</code></pre>

<p>may be it's not very clear, so I tell you the steps</p>

<ol>
<li><p>click 2 restore button, one by one</p></li>
<li><p>click start button, you'll see the number be added one after clicked</p></li>
<li><p>click stop button, OK, this is a problem, for now start button should be stopped, but not, you still can add one to click start button, but in console you can see the stop stream is subscribed, so weird</p></li>
</ol>

<p><a href=""https://codepen.io/dxcqcv/pen/BqVGJP?editors=0010"" rel=""nofollow noreferrer"">I also have other demo with the same problem using react and rxjs</a></p>
","1793574","","1793574","","2018-10-27 00:13:42","2018-11-24 07:02:32","weird takeUntil behave in rxjs 6","<reactjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"52923192","1","","","2018-10-22 06:02:26","","1","608","<p>I am facing some weird issues while working with Angular 6 and Rxjs 6.
When I import as below</p>

<pre><code>Import { forkJoin } from 'rxjs/internal/observable/forkJoin';
</code></pre>

<p>I am getting issue as</p>

<p><a href=""https://i.stack.imgur.com/wtvHD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wtvHD.png"" alt=""enter image description here""></a>
but when I use import as </p>

<pre><code>import { forkJoin } from 'rxjs/';
</code></pre>

<p>it works perfectly.</p>

<p>I used the same method to merge operator but when i used import as </p>

<pre><code>import { merge } from 'rxjs/';
</code></pre>

<p>but it thrown error as above and it works fine if i use</p>

<pre><code>import { merge } from 'rxjs/internal/observable/merge';
</code></pre>

<p>Could someone point out where is the problem? Why is this working differently?</p>

<p>PS: It's working on reloading page but alternately. </p>
","7415356","","1402846","","2018-10-22 06:20:41","2018-10-22 06:26:36","Rxjs import issues in Angular 6","<angular><rxjs6>","2","3","","","","CC BY-SA 4.0"
"52929467","1","52988398","","2018-10-22 12:31:30","","0","608","<p>Please someone can help, </p>

<p>in rxjs 6.3.3 pipe get TS2557: Expected at least 0 arguments, but got 1 or more. </p>

<pre><code>   let currentPath;
const pipeArguments = path
  .map((subPath: string, index: number) =&gt; [
    flatMap((href: string) =&gt; {
      console.log('href', href);
      return this.getEndpointMapAt(href);
    }),
    map((endpointMap: EndpointMap) =&gt; {
      console.log('map', endpointMap);
      if (hasValue(endpointMap) &amp;&amp; hasValue(endpointMap[subPath])) {
        currentPath = endpointMap[subPath];
        return endpointMap[subPath];
      } else {
        currentPath += '/' + subPath;
        return currentPath;
      }
    })
  ])
  .reduce((combined, thisElement) =&gt; [...combined, ...thisElement], []);
return of(this.getRootHref()).pipe(
  ...pipeArguments,
  distinctUntilChanged()
);
</code></pre>
","9929504","","","","","2019-01-29 19:37:06","after update to 6.3.3 I get in pipe() error TS2557: Expected at least 0 arguments, but got 1 or more.","<javascript><angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"52936191","1","52936647","","2018-10-22 19:06:34","","4","894","<p>I have a router guard called <code>PermissionGuard</code> which is initiated here</p>

<pre><code>const routes: Routes = [
  {
    path: ':company',
    component: CompanyComponent,
    canActivate: [PermissionGuard],
    canActivateChild: [PermissionGuard],
    children: [
      {
        path: '',
        component: IndexComponent
      },
      {
        path: 'projects',
        loadChildren: '../projects/projects.module#ProjectsModule'
      },
    ]
  }
];
</code></pre>

<p>Inside my <code>PermissionGuard</code> I subscribe to a <code>PermissionService</code> like this:</p>

<pre><code>export class PermissionGuard implements CanActivate, CanActivateChild {

  private permissions: Permission[];

  constructor(private permissionService: PermissionService, private router: Router) {
    this.permissionService.permissions$.subscribe(
      (permissions: Permission[]) =&gt; {
        this.permissions = permissions;
      }
    );
  }

  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean&gt; {
    this.permissionService.getPermissions(next.paramMap.get('company'));
    return this.permissionService.permissionsFetchDone$
    .pipe(filter(x =&gt; x))
    .pipe(
      map(response =&gt; {
        if (this.permissions) {
          return true;
        } else {
          this.router.navigate(['/forbidden']);
        }
      })
    );
  }
}
</code></pre>

<p>and perform necessary <code>canActivate</code> or <code>canActivateChild</code> checks based on this data. From adding <code>console.log()</code> and emitting new data from <code>permissions$</code> inside the children routes I can see that the observable is still active, even though the guard has been ""used"" and the route is activated. I was then expecting it to disappear when I go to a route outside of <code>path: ':company'</code>, however the guard isn't destroyed.</p>

<p><strong>This brings me to my question:</strong>
Am I doing this correctly? I wish to use a guard to check if the user has any permissions, but at the same time I want to perform the HTTP request for permissions only once (when navigating to <code>path: ':company'</code> or any of its children). I'm afraid that if I use guards like this it will in time slow down the entire application due to massive amounts of observers.</p>
","4011315","","","","","2018-10-22 19:39:39","Subscribing to observables in route guards and its implications","<angular><rxjs6><angular-observable><angular-guards>","1","0","","","","CC BY-SA 4.0"
"52947944","1","","","2018-10-23 11:28:13","","1","155","<p>I have an Angular 6 application which uses OAM authentication cookie to communicate with back-end web services. OAM sessions are set to expire after X minutes or when the same user has logged in from another device. I want to handle this and display a popup window to the users so that they can click and navigate them to the Login page. I have created an HttpInterceptor and call a service to display the popup window. </p>

<p>When I deploy the application (build it using <code>ng build</code> and production mode configurations) it works fine whenever the session expires and the next user action is to navigate to a path which <strong>does not have a route resolver</strong> defined in the routing module, i.e. services are called within the component after initialization. Whenever I try to navigate to a path which needs a resolver to be called first nothing happens. I tried adding console logs and redeployed several times to see what could be wrong but the resolver as well as the interceptor are not even called. I just get the following errors in the Console tab and no navigation takes place:</p>

<p><code>Uncaught SyntaxError: Unexpected token &lt;       at https://login...?bmctx=920634F2F55...e9b2.js</code></p>

<p><code>Error: Loading chunk 21 failed...</code></p>

<p>From what I understand, the 1st error is because it's trying to parse the response of the request (which is from OAM's automatic redirection to the login page) and the <code>&lt;</code> character is the beginning of <code>&lt;!DOCTYPE html&gt;</code>. By the way, this is the same response which returns error code 200 and which I check in my interceptor in order to display the pop-up window.</p>

<p><strong>The weird thing is that this does not happen when I run the application in debug mode (using <code>ng serve</code> command). The interceptor is invoked correctly and in all cases! Could it be something related to my build configurations or am I missing something related to OAM timeout handling?</strong></p>

<p>See below some sections of my code:</p>

<pre><code>@Injectable()
export class ResponseInterceptor implements HttpInterceptor {
  constructor(private alertMessageService: AlertMessagesService) { }

  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

    return next.handle(req).pipe(catchError((error: any, caught: Observable&lt;HttpEvent&lt;any&gt;&gt;) =&gt; {

      if ((error.status === 200 || error.status === 0) &amp;&amp; error.url.indexOf('login.') !== -1) {
        this.alertMessageService.displayLogoutConfirmation();
        return of(error);
      }

      throw error;
    }));
  }
}
</code></pre>

<p>Deployment build configurations in angular.json:</p>

<pre><code>""configurations"": {
    ""dev1"": {
      ""optimization"": true,
      ""outputHashing"": ""all"",
      ""sourceMap"": false,
      ""extractCss"": true,
      ""namedChunks"": false,
      ""aot"": true,
      ""extractLicenses"": true,
      ""vendorChunk"": false,
      ""buildOptimizer"": true,
      ""fileReplacements"": [
        {
          ""replace"": ""src/./environments/environment.ts"",
          ""with"": ""src/./environments/environment.prodpro.ts""
        }
      ]
    },
</code></pre>
","1188435","","","","","2018-10-23 11:28:13","Handle OAM Timeouts in Angular 6 with Route-Resolvers","<typescript><angular6><rxjs6><angular-http-interceptors><oracle-access-manager>","0","0","1","","","CC BY-SA 4.0"
"52965491","1","","","2018-10-24 09:27:06","","4","8281","<p>Initially, I had a function that simply checked for the presence of a token and, if it was not present, sent the user to the login header. Now I need to implement the logic of refreshing a token when it expires with the help of a refreshing token. But I get an error 401. The refresh function does not have time to work and the work in the interceptor goes further to the error. How can I fix the code so that I can wait for the refresh to finish, get a new token and not redirect to the login page?</p>

<p><strong>TokenInterceptor</strong></p>

<pre><code>import {HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest} from ""@angular/common/http"";
import {Injectable, Injector} from ""@angular/core"";
import {AuthService} from ""../services/auth.service"";
import {Observable, throwError} from ""rxjs"";
import {catchError, tap} from ""rxjs/operators"";
import {Router} from ""@angular/router"";
import {JwtHelperService} from ""@auth0/angular-jwt"";

@Injectable({
  providedIn: 'root'
})
export class TokenInterceptor implements HttpInterceptor{

  private auth: AuthService;

  constructor(private injector: Injector, private router: Router) {}

  jwtHelper: JwtHelperService = new JwtHelperService();

  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

    this.auth = this.injector.get(AuthService);

    const accToken = this.auth.getToken();
    const refToken = this.auth.getRefreshToken();

    if ( accToken &amp;&amp; refToken ) {

      if ( this.jwtHelper.isTokenExpired(accToken) ) {
        this.auth.refreshTokens().pipe(
          tap(
            () =&gt; {
              req = req.clone({
                setHeaders: {
                  Authorization: `Bearer ${accToken}`
                }
              });
            }
          )
        )
      } else {
        req = req.clone({
          setHeaders: {
            Authorization: `Bearer ${accToken}`
          }
        });
      }

    }
    return next.handle(req).pipe(
      catchError(
        (error: HttpErrorResponse) =&gt; this.handleAuthError(error)
      )
    );
  }

  private handleAuthError(error: HttpErrorResponse): Observable&lt;any&gt;{
    if (error.status === 401) {
      this.router.navigate(['/login'], {
        queryParams: {
          sessionFailed: true
        }
      });
    }
    return throwError(error);
  }

}
</code></pre>

<p><strong>AuthService</strong></p>

<pre><code>import {Injectable} from ""@angular/core"";
import {HttpClient, HttpHeaders} from ""@angular/common/http"";
import {Observable, of} from ""rxjs"";
import {RefreshTokens, Tokens, User} from ""../interfaces"";
import {map, tap} from ""rxjs/operators"";

@Injectable({
  providedIn: 'root'
})
export class AuthService{

  private authToken = null;
  private refreshToken = null;

  constructor(private http: HttpClient) {}

  setToken(authToken: string) {
    this.authToken = authToken;
  }

  setRefreshToken(refreshToken: string) {
    this.refreshToken = refreshToken;
  }

  getToken(): string {
    this.authToken = localStorage.getItem('auth-token');
    return this.authToken;
  };

  getRefreshToken(): string {
    this.refreshToken = localStorage.getItem('refresh-token');
    return this.refreshToken;
  };

  isAuthenticated(): boolean {
    return !!this.authToken;
  }

  isRefreshToken(): boolean {
    return !!this.refreshToken;
  }

  refreshTokens(): Observable&lt;any&gt; {

    const httpOptions = {
      headers: new HttpHeaders({
        'Authorization': 'Bearer ' + this.getRefreshToken()
      })
    };

    return this.http.post&lt;RefreshTokens&gt;('/api2/auth/refresh', {}, httpOptions)
      .pipe(
        tap((tokens: RefreshTokens) =&gt; {
          localStorage.setItem('auth-token', tokens.access_token);
          localStorage.setItem('refresh-token', tokens.refresh_token);
          this.setToken(tokens.access_token);
          this.setRefreshToken(tokens.refresh_token);
          console.log('Refresh token ok');
        })
      );
  }

}
</code></pre>
","8247592","","8247592","","2018-10-29 13:38:24","2021-06-14 07:05:50","Refresh token (JWT) in interceptor Angular 6","<javascript><angular><typescript><angular6><rxjs6>","3","3","2","","","CC BY-SA 4.0"
"52978032","1","52978617","","2018-10-24 21:17:22","","3","415","<p>I am using rxjs 6 and I am executing two async operations where the order is important. </p>

<p>I do have this chunk of code which works perfectly: </p>

<pre><code>dbmsProxy.createDatastores().subscribe(() =&gt; {
    UsersDAO.insert(users).subscribe(() =&gt; {
        console.log('FINISHED ALL THE CHAIN');
    });
});
</code></pre>

<p>But when I try to use <code>concat</code> of <code>rxjs</code> I do have an issue because the second one is executed before the first one finishes: </p>

<pre><code>concat([dbmsProxy.createDatastores(), UsersDAO.insert(users)]).subscribe();
</code></pre>

<p>Below the DBMSProxy methods</p>

<pre><code>public createDatastores(): Observable&lt;string&gt; {
    const _this: DBMSProxy = this;
    const subject = new Subject&lt;string&gt;();
    const subscription: Subscription = UsersDAO.createDatastore().subscribe(
        onSuccess,
        onError,
        onFinally
    );
    return subject;

    function onSuccess(datastore: Nedb): void {
        console.log(`USERS Datastore Created Successfully`);
        _this.db.users = datastore;
        subject.next('success');
    }

    function onError(err: string) {
        subject.error('error');
        console.error(err);
    }

    function onFinally() {
        subject.complete();
        subscription.unsubscribe();
    }
}

public insertDocuments(documents: any, datastore: Nedb): Subject&lt;any&gt; {
    const subject = new Subject&lt;any&gt;();
    datastore.insert(documents, onInsert);
    return subject;

    function onInsert(err: Error, newDocuments: any) {
        if (err) {
            subject.error(err);
        } else {
            // add to the documents to insert the id just created from nedb when inserting the document
            documents.forEach((document: any, ind: number) =&gt; {
                document.id = newDocuments[ind]._id;
            });
            subject.next(documents);
        }
        subject.complete();
    }
}
</code></pre>

<p>And below the UsersDAO methods: </p>

<pre><code>public static createDatastore(): Subject&lt;Nedb | string&gt; {
        const subject = new Subject&lt;Nedb | string&gt;();
        const datastore = new Nedb({
            filename: USERS_DATASTORE_FULL_NAME,
            autoload: true,
            onload
        });
        return subject;

        function onload(err: Error) {
            if (err) {
                subject.error(
                    `Error creating USERS datastore: ${err.name} - ${err.message}`
                );
            } else {
                subject.next(datastore);
            }
            subject.complete();
        }
    }

    public static insert(users: User[]): Observable&lt;any&gt; {
        return DBMSProxy.getInstance()
            .insertDocuments(users, DBMSProxy.getInstance().db.users)
            .pipe(catchError((val: any) =&gt; of('Error inserting the users')));
    }
</code></pre>

<p>Any idea of what's going on please? </p>
","2652759","","","","","2018-10-24 22:47:30","Rxjs issue with the concat operator when executing operations sequentially","<javascript><typescript><rxjs><rxjs5><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"52988528","1","","","2018-10-25 11:46:26","","0","401","<p>Hello how to pass <strong>payload</strong> parameter from mergeMap to switchMap ? 
I use it in clientservice.checkValideName but would like pass it into sendMessage(data, <strong>payload[1]</strong>) .</p>

<p>I tried many things but nothing works. (another mergemap or map the result of checkValideName to inject the payload)</p>

<pre><code>@Effect()  CheckValidatedName$ = this.actions$.pipe(
ofType(CheckValidatedActionTypes.VALIDATED_NAME),
map((action: ValidatedNameAction) =&gt; action.payload),
withLatestFrom(this.store.select(fromRoot.selectors.getCurrentClient)),
mergeMap(([payload, client]) =&gt;
  this.clientService.checkValideName(client.uuid, payload[0])
),
map((result: any) =&gt; result.data),
switchMap((data: boolean) =&gt; {
  return of(this.sendMessage(data))
}),
catchError((res: any) =&gt; this.catchResponseError(res))
</code></pre>

<p>);</p>
","4231054","","","","","2018-10-25 11:57:20","Angular 6 Pass parameter throught effect rxjs","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53012513","1","","","2018-10-26 16:04:32","","1","411","<p>maybe somebody already had this problem. Trying to run this in angular 6 project:</p>

<pre><code>ng build --prod --aot=true
</code></pre>

<p>and it gives me this error: <strong>ERROR in Cannot read property 'map' of undefined</strong></p>

<p>I don't have idea what might be the problem, i've tried also to delete node_module + package-lock.json and do once again npm install, but it didn't help. Also tried to run ng build without --aot=true which in the end gave me the same error.</p>

<p>Angular CLI version is: 6.2.6</p>

<p>Node version: 8.11.3</p>

<p>Any ideas guys of how can i figure out with this? Thanks a lot!</p>
","5720356","","","","","2018-10-26 16:08:02","Cannot read property 'map' - production build for Angular 6","<angular><typescript><rxjs6>","0","7","","","","CC BY-SA 4.0"
"53015159","1","","","2018-10-26 19:26:18","","2","255","<p>Hey I couldn't find how can i do nested query in firestore ?</p>

<pre><code>this.match1 = this.MatchCollection1.snapshotChanges().pipe(map(actions =&gt; {
    return actions.map(a =&gt; {
        const data = a.payload.doc.data() as Matches;
        const uid = data.pairer;
        const id = a.payload.doc.id;
        const photourl = afs.collection(`users/${uid}/photos`,
            ref =&gt; ref.where('index', '==', 0).where('deleted', '==', false)).snapshotChanges().pipe(map(action =&gt; {
            return action.map(p =&gt; {
                const pdata = p.payload.doc.data() as Photos;
                return pdata.url;
            });
        }));
        return {id, uid, url: photourl, ...data};
    });
}));
</code></pre>

<p>My problem photourl return observable how can i do return object like others</p>
","9373793","","9373793","","2018-10-27 16:43:47","2018-11-04 06:42:37","Expert wanted AngularFire2 firestore nested collection get data?","<firebase><nested><angular6><angularfire2><rxjs6>","2","3","0","","","CC BY-SA 4.0"
"53023024","1","53023412","","2018-10-27 14:45:20","","0","1934","<p>I'm starting with Rxjs for Angular 6 and I have some doubts about how accomplish this:</p>

<p>I have a card list component which will show list with items fetched from a service which returns an observable. Data type items are different. And service observable may be updated with new items so card list should display this new items.</p>

<pre class=""lang-js prettyprint-override""><code>export class HomeComponent implements OnInit, OnDestroy {

  papers$:Observable&lt;Paper[]&gt;;

  papersPublished$:Observable&lt;DataCard[]&gt;;
  papersOnReview$:Observable&lt;DataCard[]&gt;;
  papersSubmitted$:Observable&lt;DataCard[]&gt;;

  constructor(private publicationService: PublicationService) { }

  ngOnInit() {
    this.papers$ = merge(
      this.publicationService.getAllPapersOnState(""Submitted""),
      this.publicationService.getAllPapersOnState(""OnReview""),
      this.publicationService.getAllPapersOnState(""Published"")
    );

        this.papersSubmitted$ = this.papers$.pipe(map(paper =&gt; [HomeComponent.paperToCard(paper,'Read', 'Review')]));
        this.papersOnReview$ = this.papers$.pipe(map(paper =&gt; [HomeComponent.paperToCard(paper,'Read', 'Accept')]));
        this.papersPublished$ = this.papers$.pipe(map(paper =&gt; [HomeComponent.paperToCard(paper,'Read', '')]));
      }

  private static paperToCard(paper, action_1_name, action_2_name): DataCard {
        // ... other code ...
  }
}

&lt;app-cardlist
  [title]=""'Published'""
  [description]=""'Last science papers published. Yay!'""
  [items$]=""papersPublished$""&gt;&lt;/app-cardlist&gt;
&lt;app-cardlist
  [title]=""'On Review'""
  [description]=""'Last papers on review. On publish way!'""
  [items$]=""papersOnReview$""&gt;&lt;/app-cardlist&gt;
&lt;app-cardlist
  [title]=""'Submitted'""
  [description]=""'Last papers submitted for reviewing. Be the first one to check them!'""
  [items$]=""papersSubmitted$""&gt;&lt;/app-cardlist&gt;



export class PublicationService {
 // ... more code ...
 getAllPapersOnState(state: string): Observable&lt;Paper[]&gt; {
    return Observable.create(observer =&gt; {
      this.WF_SC.deployed().then(instance =&gt; {

        // State changed watcher to update on-live the observable
        const event = instance.AssetStateChanged({});
        event.on('data', (data) =&gt; {
          console.log('StateChanged catched!');
          this.getPaper((data['args']['assetAddress'])).then((paper) =&gt; observer.next(paper));
        });

        return instance.findAssetsByState.call(state);
      }).then(addresses =&gt; {
        addresses.forEach((address) =&gt; this.getPaper(address).then((paper) =&gt; observer.next(paper)));
      });
    });
  }
}


export class CardlistComponent implements OnInit {

  @Input() items$: Observable&lt;DataCard[]&gt;;

}

&lt;div *ngIf=""(items$ | async)"" class=""card-deck""&gt;
  &lt;div *ngFor=""let item of items$ | async"" class=""card"" style=""width: 18rem;""&gt;
    &lt;!-- Other code --&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>The issue is that only last item is displayed on the list. How can I transform <code>papers$:Observable&lt;Paper[]&gt;</code> into <code>$papersSubmitted$:Observable&lt;DataCard[]&gt;</code> to be able pass it to <code>CardlistComponent</code> ?</p>
","1456004","","1456004","","2018-10-27 15:46:29","2018-10-27 16:39:32","How transform observable into another observable","<angular6><rxjs6>","1","2","","","","CC BY-SA 4.0"
"53050830","1","","","2018-10-29 17:28:00","","0","536","<p>I have been racking my brain for a couple of weeks now with this problem. I have typed observable array being returned via an http request. This the array output to the console. I am trying to grab each item and check the properties._hg_layer. <a href=""https://i.stack.imgur.com/6BIQZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6BIQZ.png"" alt=""enter image description here""></a></p>

<p>An ngrx state selector is then assigned to Observable and then passed to a BehaviorSubject. This emits the array but won't let me get out the values inside of the array. I have tried every conceivable operator combination. I can't tell if my issue has to do with how the response is typed coming out of the service or how I am using the operators. It will not let me have access to the typed members of the array. IT's as if it doesn't know the properties of the array objects.<br>
<a href=""https://i.stack.imgur.com/xYTMC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xYTMC.png"" alt=""enter image description here""></a></p>

<p>I have tried assigning the type of object on the subscription and I can't get that to work either. </p>

<p><a href=""https://i.stack.imgur.com/ixzay.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ixzay.png"" alt=""enter image description here""></a></p>

<p>Any insight or help you could provide would be greatly appreciated. Thank you very much.</p>
","9536803","","","","","2018-10-29 22:02:00","Which rxjs operator should I use to get values from an observable array to filter based on an object property","<angular><ngrx><rxjs6>","2","6","","","","CC BY-SA 4.0"
"53054281","1","","","2018-10-29 21:43:40","","0","131","<p>I'm a quite newbie to TypeScript (or even JavaScript) and Angular 6. I have to retrieve an observable value, pass it to <code>HttpClient.post</code> and process the response.</p>

<p>Somehow I'm not able to do it correctly. The following does not compile, since return is here <code>Observable&lt;Observable&lt;string&gt;&gt;</code>. But how do I it correctly? </p>

<pre><code>refreshTokenCall: Observable&lt;string&gt; = null;

refreshToken(): Observable&lt;string&gt; {

  if (!this.refreshTokenCall) {

    // Here is the error: Type 'Observable&lt;Observable&lt;string&gt;&gt;' is not assignable to type 'Observable&lt;string&gt;'.
    // Type 'Observable&lt;string&gt;' is not assignable to type 'string'. [2322]

    this.refreshTokenCall = this.getToken().pipe(
      map(token =&gt; {
        console.log(""try refresh"")
        return this.http.post&lt;Token&gt;(AuthService.REFRESH_TOKEN_URL, JSON.stringify({token: token})).pipe(
          map(data =&gt; data.token),
          shareReplay(),
          tap(token =&gt; { 
            console.log(""save token after refresh"");
            this.saveToken(token);
          }),
          finalize(() =&gt; this.refreshTokenCall = null)
        );
      })
    );

  } // if
  return this.refreshTokenCall;
</code></pre>

<p>I tried to put the second map <code>map(data =&gt; data.token)</code> into the first <code>pipe</code> but then the argument <code>data</code>is of type <code>Observable&lt;Token&gt;</code>. At least what syntactically works is to replace the first <code>map</code>by <code>switchMap</code>. I think then I have my problems with the <a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-switchMap"" rel=""nofollow noreferrer"">documentation about <code>switchMap</code></a></p>

<blockquote>
  <p>switchMap stops emitting items from the earlier-emitted inner Observable and begins emitting items from the new one.</p>
</blockquote>

<p>I hope the <code>if</code> condition catches all subsequent calls. But somehow my Observable pipeline is not processed. The log entries do not appear.</p>

<p>So what I'm doing wrong here?</p>
","3142459","","3142459","","2018-10-29 21:53:09","2018-10-29 21:53:09","Chain Observable with HttpClient post","<typescript><angular6><rxjs6>","0","2","","","","CC BY-SA 4.0"
"53063818","1","53064088","","2018-10-30 11:57:47","","0","1040","<p>I use concatMap to do two API calls consecutively, but the second one should only be run if a checkbox is checked. So this is my code:</p>

<pre><code>this.myService.createArticle(article)
  .pipe(
    filter(() =&gt; this.checkbox),
    concatMap(() =&gt; return this.mailer.createOtherResource(data)),
  }).subscribe(
    (x) =&gt; { console.log('OK', x); },
    error =&gt; console.error('FALLA', error),
    () =&gt; console.log('Finally I have really reached the END')
  );
</code></pre>

<p>The thing is that, if the check box is not checked, even if the first observable does not return an error, the OK function is never run, only the 'finally' one, and I need it to inform the user that the resource was created. What can I do?</p>

<p>I tried with <code>takeWhile</code> instead <code>pipe</code>, and same result.</p>
","651555","","","","","2018-10-30 12:14:53","RxJs 6 - React to concatMap in filter or takeWhile condition","<angular><observable><reactive-programming><rxjs6>","2","0","","","","CC BY-SA 4.0"
"53064231","1","53064627","","2018-10-30 12:22:59","","0","41","<p>I have a call to an HTTP service that return an observable (it's part of a third party library so I cannot change its inner code) and it is throwing an error on the subscribe for a use case that I would like to handle in the happy path.</p>

<p>I have something like this:</p>

<p><strong>My service class:</strong></p>

<pre><code>class MyService {
  getEntities(): Observable&lt;any&gt; {
    return this.http.get('&lt;the url'&gt;)
      .pipe(
        catchError(err =&gt; {
          // Handle the errors and returns a string corresponding to each message.
          // Here I show an example with the status code 403
          if (err.status === 403) {
            return throwError('My error message for 403');
          }

          // This is what I want to do.
          if (err.status === 409) {
            // Somehow, make this to trigger the goodResponse in the consumer class.
          }
        })
      );
  }
}
</code></pre>

<p><strong>My consumer:</strong></p>

<pre><code>class MyComponent {
  private myService: MyService;

  constructor() {
    this.myService = new MyService();
  }

  callTheAPI() {
    this.myService.getEntities()
      .subscribe(goodResponse =&gt; {
        // Handle good response
      }, error =&gt; {
        // Handle error
      });
  }
}
</code></pre>

<p>So, for the current code example, what I want to do is, for the case where the status code is 409, make the subscription to succeed.</p>
","4848267","","","","","2018-10-30 12:46:06","Convert failing Observable into a good one","<typescript><rxjs><rxjs6><rxjs-pipeable-operators><rxjs-lettable-operators>","1","0","","","","CC BY-SA 4.0"
"53080656","1","53169839","","2018-10-31 09:56:56","","0","7656","<p>Im currently trying to convert an <code>Observable</code> to a Promise. But when I call that method nothing happens. Im using Angular 6.</p>

<h2>Service</h2>

<pre><code>  public create(form: StoryForm): Promise&lt;void | string&gt; {
    const key: string = this.afStore.createId();

    return this.auth.authState.pipe(map(res =&gt;
      &lt;Story&gt;{
        title: form.title, content: form.content, createdAt: new Date(), sid: key,
        uid: res.uid, username: res.displayName
      }
    )).toPromise().then((story: Story) =&gt;
      this.afStore.doc(`stories/${key}`).set(story).catch(err =&gt; err.message));
  }
</code></pre>

<h2>Component</h2>

<pre><code>  public save() {
    this.triedToSave = true;
    if (this.storyForm.valid) {
      this.storyService.create(this.storyForm.value)
        .then(() =&gt; this.router.navigate(['/stories']))
        .catch((err: string) =&gt; this.notify.danger(err));
    }
  }
</code></pre>

<p>What save should do is to navigate or at least displaying the error.</p>

<h2>Auth</h2>

<p>How authstate is implemented: It returns an observable of some user information. It is implemented in a different service and looks like this:</p>

<pre><code>  public get authState(): Observable&lt;firebase.User&gt; {
    return this.afAuth.authState;
  }
</code></pre>

<h2>Edit</h2>

<p>What confuses me is that, if I use a mock Object than it suddenly works:</p>

<pre><code>  public create(form: StoryForm) {
    const key: string = this.afStore.createId();

    return of({uid: 'blubb', displayName: 'kdsjf', photoUrl: 'kjdfkjfd'}).pipe(map(user =&gt; {
      return {
        title: form.title, content: form.content, createdAt: new Date(), sid: key,
        uid: user.uid, username: user.displayName, photoUrl: user.photoURL
      } as Story;
    })).toPromise();
  }
</code></pre>

<p>But I wonder why toPromise does not work on the example above...</p>
","9032085","","9032085","","2018-11-06 07:06:53","2018-11-06 10:29:58","RXJS 6 - toPromise","<rxjs><angular6><es6-promise><angularfire2><rxjs6>","1","2","","","","CC BY-SA 4.0"
"53082378","1","","","2018-10-31 11:33:08","","0","374","<p>I am trying to solve a use case of an app I am developing with <strong>Angular 6.x</strong> and <strong>Rxjs 6.x</strong></p>

<p>It may be quite simple but I am not able to solve....
Just to summarize I have some Components which I subscribe in the AfterViewInit Cycle and then I would need to execute only the last emit every time the observable is dispatched or emitted</p>

<pre><code> @ViewChildren(XComponent)
  xChilds: QueryList&lt;XComponent&gt;;

a ==&gt; ngAfterViewInit() {
        this.xChilds.changes.pipe(
                ................ //I SHOULD PUT SOMETHING TO GET THE LAST VALUE
        ).subscribe(xChilds =&gt; {
          debugger;
          ------------------
</code></pre>

<p><em>The diagram would be like this</em></p>

<pre><code>a)      &gt;--A--A--A--A|
RESULT) &gt;-----------A|
</code></pre>

<p>So my approach at the very first time was using operators like <strong>TAKE(1)</strong>, <strong>FIRST()</strong> or <strong>LAST()</strong> and it is working</p>

<p>The point is that latter when I receive more events they don't fire or trigger again......</p>

<p><em>And the diagram would be like this</em></p>

<pre><code>a)      &gt;--A--A--A--A .......NOTHING HAPPENS.......... --A--A--A--A|
RESULT) &gt;-----------A............................ ------------- NOTHING
</code></pre>

<p>Is like operators first etc unsubscribe after the first sequence</p>

<p>I am sure there should be an operator to achieve <strong>what I want</strong>.</p>

<pre><code>a)      &gt;--A--A--A--A....NOTHING HAPPENS....--A--A--A--A|
RESULT) &gt;-----------A.......................-----------A|
</code></pre>

<p>I appreciate any help. Thanks in advance!!!!</p>
","3029263","","3029263","","2018-10-31 13:06:14","2018-10-31 13:06:14","Angular 6 - Rxjs Subscribe to the last events in QueryList changes?","<javascript><angular><rxjs><angular6><rxjs6>","0","9","","","","CC BY-SA 4.0"
"53086641","1","","","2018-10-31 15:12:49","","0","474","<p>Usind delay with HTTPClient object gives me error as below:</p>

<blockquote>
  <p>Cannot invoke an expression whose type lacks a call signature. Type 'Number' has no compatible call signatures.</p>
</blockquote>

<p>TS:</p>

<pre><code>import { delay } from 'rxjs/operators';

this.http.get(url,{params:search})
          .pipe(
              delay(1000),
              map(res =&gt; res)
          , catchError((error: any) =&gt; {
              return Observable.throw(error)
        }));
</code></pre>
","4868839","","","","","2018-10-31 15:15:32","How to use delay with HTTPClient Rxjs 6.3.0","<angular><typescript><angular-httpclient><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53088099","1","","","2018-10-31 16:30:09","","0","178","<p>I have an array of unique ID's and want to perform a bulk action (HTTP patch, delete etc) on them. That needs to be done individually and I need to display individual results. </p>

<p>As the requests are individual and it's responses should not affect each other. Results are displayed as they are received. </p>

<p>Every call is a separate Observable and what I'm looking for is a way to know when <strong>all Observables have completed</strong>.
The <code>onCompleted</code> method works only when there are no errors.</p>

<p>The goal is to prevent the button from being clicked while there are still call's being processed.</p>

<pre><code>this.inProgress = {};
this.myIdArray = [1, 2, 3, 4];

actionHandler(type) {

    this.inProgress[type] = true;

    const myAction = {
        patch       : id =&gt; this.patch(id, this.body),
        delete      : id =&gt; this.delete(id)
    };

    from(myIdArray)
        .pipe (
            tap(myAction[type])
        )
        .subscribe(
            res =&gt; {}, 
            err =&gt; {}, 
            () =&gt; this.inProgress[type] = false ); // onCompleted
}


delete(id) {
    this.myService.delete(id).subscribe(
        res =&gt; {} // confirm
        err =&gt; {} // show error
    );
}
</code></pre>
","1021147","","","","","2018-10-31 16:58:03","RxJS All Individual Observables completed","<angular><rxjs><observable><reactive-programming><rxjs6>","1","1","","","","CC BY-SA 4.0"
"53096042","1","53096513","","2018-11-01 06:12:08","","0","381","<p>i need help on managing delay on an array iteration.</p>

<p>Regarding my <a href=""https://jsfiddle.net/mlefree/vrL813j2/93/"" rel=""nofollow noreferrer"">https://jsfiddle.net/mlefree/vrL813j2/93/</a>, two questions :</p>

<ol>
<li>How to add delay on each iteration action ?</li>
<li>How to reduce all iteration computed values ?</li>
</ol>

<p>```</p>

<pre><code>...

const arrayAsObservable = of(null).pipe(
        delay(500),
        switchMap(_ =&gt; getObjectWithArrayInPromise()),
        map(val =&gt; {
            log('array', val);
            return (val.myArray);
        }),
        switchMap(val =&gt; from(val))
    );

const eachElementAsObservable = arrayAsObservable.pipe(
                delay(500), // Not working : we want to wait 500ms more for each value
        map(val =&gt; {
            log('value', val);
            return val ;
        }),
        switchMap(val =&gt; getNewValueInPromise(val)),
        map(val =&gt; {
        // Not working : why not all new values ?
            log('value after computing (KO)', val);
            return (val);
        })
     );

const summarizeAsObservable = eachElementAsObservable.pipe(
// Not working : we want to sum all new values
        map(val =&gt; { 
            log('value before reduce (KO)', val);
            return val ;
        }),
        reduce((a,b) =&gt; a + b)
);

summarizeAsObservable.subscribe(msg =&gt; {
    log('We did a total of (KO)', msg);
});
</code></pre>

<p>```</p>
","4130896","","4130896","","2018-11-01 19:05:55","2018-11-02 03:33:00","RxJs 6 : Manage array iteration and delay","<rxjs><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"53103604","1","","","2018-11-01 14:44:38","","0","1421","<p>In our angular 6 application, I noticed some Http GET calls are executed at least two times. Sometimes the OPTIONS and/or the first GET is cancelled and only the second call succeeds. In other cases the same GET call is executed two or more times.</p>

<p><a href=""https://i.stack.imgur.com/qkZlH.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qkZlH.png"" alt=""enter image description here""></a></p>

<p>A footer component calls a service to get the current application version and display it its template. A simple Observable with subscription, without any special operator.</p>

<p><strong>UPDATE</strong><br>
After further investigation, the issue seems to be with the <code>combineLatest</code> in the HttpInterceptor. As the two observables are emitted as observables by a BehaviourSubject (each), I guess the different speed/time when those Subjects emit, make it so that the combineLates is triggered twice or more.</p>

<p><strong>Impersonator service</strong> (emits observables from a BehaviourSubject)<br></p>

<pre><code>export class ImpersonatorService {
public get changeHandler(): Observable&lt;string&gt; {
    return this.changeHandlerInternal.asObservable();
}

private changeHandlerInternal = new BehaviorSubject&lt;string&gt;(this.get());
private key = ""impersonate"";
constructor(private cookieService: CookieService) {}

public set(impersonate: string) {
    this.cookieService.put(this.key, impersonate);
    this.changeHandlerInternal.next(impersonate);
}

private get(): string {
    let impersonate = this.cookieService.get(this.key);
    if (impersonate === undefined || impersonate === null || impersonate === """") {
        impersonate = """";
    }

    return impersonate;
}
}
</code></pre>

<p><strong>Footer component</strong>:</p>

<pre><code>export class FooterComponent implements OnInit {
public applicationInfo: Observable&lt;ApplicationInfo&gt;;

constructor(private applicationService: ApplicationInfoService) {}

ngOnInit() {
    this.applicationInfo = applicationService.getApplicationInfo();
  }
}
</code></pre>

<p><strong>Footer Template</strong></p>

<pre><code>&lt;div&gt;
    {{ (applicationInfo | async)?.version }}
&lt;/div&gt;
</code></pre>

<p><strong>Application Service</strong></p>

<pre><code>export class ApplicationInfoService {
constructor(private http: HttpClient, @Inject(APP_CONFIG) private config: IAppConfig) {}

public getApplicationInfo(): Observable&lt;ApplicationInfo&gt; {
    return this.http.get&lt;ApplicationInfo&gt;(this.config.apiEndpoint + ""/api/applicationinfo"");
   }
}
</code></pre>

<p>The application service is called only from the footer component.</p>

<p>We also use an HttpInterceptor to inject headers:</p>

<pre><code>export class HttpInterceptor implements HttpInterceptor {
constructor(private impersonator: ImpersonatorService, private profileService: ProfileService, private languageService: TranslateService) {}

public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    return this.impersonator.changeHandler
        .combineLatest(this.profileService.changeHandler, (user, profile) =&gt; {
            let customHeaders = req.headers.set(""X-Impersonate"", user).set(""X-Profile"", profile);

            if (customHeaders.has(""Content-Type"")) {
                if (customHeaders.get(""Content-Type"") === ""multipart/form-data"") {
                    customHeaders = customHeaders.delete(""Content-Type"");
                }
            } else {
                customHeaders = customHeaders.set(""Content-Type"", ""application/json"");
            }

            const clonedReq = req.clone({ headers: customHeaders, withCredentials: true });
            return next.handle(clonedReq);
        })
        .switch();
    }
}
</code></pre>

<p>Reading from other SO responses, it seems related to a race issue. However the other cases found were using switchMap or other operators causing issues in those scenarios.<br></p>

<p>By debugging, I can see that inside the HttpInterceptor two requests for ApplicationInfo endpoint arrive. But how can I ensure that no duplicates requests are shipped?</p>
","706293","","706293","","2018-11-02 11:27:17","2018-11-02 11:27:17","Http Request sent multiple times in Angular 6 app","<angular><httprequest><rxjs6><angular-http-interceptors>","0","4","","","","CC BY-SA 4.0"
"53104426","1","","","2018-11-01 15:31:59","","0","33","<p>I need to limit how many times a HTTP request can be made in a certain time period. So, for example, the first call made will send a request but <strong>if another request is made within the set time period (3 seconds) then I want to share the response rather than making another HTTP request</strong>. Whereas, if the second request is made after the set time period then just send a new request.</p>

<p>My current understanding (feel free to correct me as I'm probably wrong) is that:</p>

<ul>
<li>debounceTime wont help as it delays the first request by a certain
time period. Whereas I don't want to delay the first request, I want it to be sent straight away and any future requests made in the set time period to share the response.</li>
<li>throttleTime wont help as it just delays the second request</li>
<li>shareReplay wont help as all future requests are shared even if they
are made 10 minutes later</li>
</ul>

<p>What I'm looking for is a mix between throttleTime and shareReplay where I can configure a time period and the first request is sent straight away but any future requests made within the time period just share the response of the first one. After the time period has finished (3 seconds) the next request will send a new HTTP request.</p>
","6518823","","","","","2018-11-01 15:31:59","How do I limit extra HTTP requests and share responses for requests that are made within a set period?","<angular><angular6><rxjs6>","0","3","1","","","CC BY-SA 4.0"
"53115864","1","53117746","","2018-11-02 09:28:37","","3","2113","<p>I am working on Angular 6+ web-app using rxjs 6+ . </p>

<p>There is a set of services(all are different and make different http calls) .
Basically these services are used to initialize the app.  </p>

<p>My requirement is to call these services in parallel and wait untill all of them are finished . Once finished , I need to process the responses received . 
I have studied a lot on this and found that forkJoin and combineLatest can be my friend. 
And i have implemented the same in the following way  : </p>

<pre><code> getInitialData() {

 this._authService.openCorsConnection().subscribe(res =&gt; { 
  forkJoin(
    this._authService.x(),
    this._tService.getSystemDate(),
    this._tService.getTemp(),
    this._tService.getSettings()
  ).pipe(
    catchError( err =&gt; {
      console.log('gor error',err);
      if (err.status == 401) {
          // this._router.navigateByUrl('/unauthorize');
          return EMPTY;
      } else {
          return throwError(err);
      }
 }),
    map(([x,y,z,p])=&gt;{
           console.log('sucesss',{x,y,z,p});          
            return {x,y,z,p}
    }),
  finalize(()=&gt;{
        console.log('Executing Finally');
        processData();

  })
  );
});
 }
</code></pre>

<p>But These are not executing . Here are the services : </p>

<pre><code>x(): Observable&lt;any&gt; {          
const xUrl  = EnvironmentConfiguration.endPointConfig.xServiceEndpoint;
          let serviceMethod: String = 'x';
          let requestObj: any = this._utilHelperSvc.getRequestObject(xUrl  , { ""y"": """" }, serviceMethod);
          return this._http.post&lt;any&gt;(requestObj.url,{ ""pid"": """" } , requestObj)
          .pipe(
            catchError(this.handleError('x', {}))
          );
      }
</code></pre>

<p>Do i need to modify services ? 
I am not able to figure out how to solve this.</p>

<p>Can anybody please Suggest some better solution or different approach for this ? </p>

<p>Thanks.   </p>
","8175467","","8175467","","2018-11-24 23:04:33","2018-11-24 23:04:33","Angular 6: How to make a set of service calls in parallel and process Data once all of them are completed","<angular><rxjs><observable><angular6><rxjs6>","2","4","1","","","CC BY-SA 4.0"
"53120330","1","","","2018-11-02 14:21:06","","2","253","<p>I have the function <code>getCurrentStatus()</code> that returns a boolean value, when I subscribe to this method it always return null then true, when I try to get the last value (true) using the function last() of rxjs, it doesn't work, it always executes treatment 2, which returns null from the beginning.</p>

<pre><code>import { last } from 'rxjs/operators';

this.getCurrentStatus().pipe(last()).subscribe(status =&gt; {
  console.log(status);
  if (status) {
    // treatment 1 
  } else {
   // treatment 2
  }
});

  private status$: Subscription;

  getCurrentStatus(): Observable&lt;Boolean&gt; {
    if (!this.status) {
      this.status$ = this.store.pipe(select(fromUserSelector.getAuthStatus)).subscribe((status: Boolean) =&gt; {
        this.status = status;
      });
    }
    return of(this.status);
  }
</code></pre>
","4739210","","4739210","","2018-11-04 08:45:02","2018-11-04 08:45:02","Get the last value from subscribe","<angular><angular6><ngrx><rxjs6>","0","3","","","","CC BY-SA 4.0"
"53129929","1","53130264","","2018-11-03 09:13:19","","1","797","<p>I have in my Angular application a list of a specific model. Each item of this list has a propery <code>xyzList</code>. This <code>xyzList</code> property should be filled from a request which depends on the id of the first request. Here an example:</p>

<p><strong>Model</strong>:</p>

<pre><code>{
  id: number;
  name: string;
  xyzList: any[]
}
</code></pre>

<p>Now I have two requests:</p>

<p><strong>Request 1</strong>: Fills the model, but not the <code>xyzList</code></p>

<p><code>this.myVar$ = this.myService.getElements&lt;Model[]&gt;();</code></p>

<p><strong>Request 2</strong>: Should fill <code>xyzList</code></p>

<p><code>this.myService.getXyzElements&lt;XyzModel[]&gt;(idOfTheModelOfTheFirstRequest);</code></p>

<p>At first I thought something like that:</p>

<pre><code>this.myService.getElements&lt;Model[]&gt;()
.pipe(
  mergeMap(items =&gt; items)
  mergeMap(item =&gt; {
    return this.myService.getXyzElements&lt;XyzModel[]&gt;(item.id)
           .pipe(
             map(xyzList =&gt; {
               item.xyzList = xyzList

               return item;
             })
           )
  })
)
</code></pre>

<p>This does not work as I have flattened my list and I need an <code>Observable&lt;Array[]&gt;</code>, but I think is more or less clear what I want to achieve. I assume I can achieve this with <code>forkJoin</code> for instance, but I don't know how.Or is there a way to convert the flattened list back to list?</p>
","3095538","","6299088","","2018-11-03 16:10:54","2018-11-03 16:10:54","Angular RxJs - fill array in the second stream (nested stream)","<javascript><angular><typescript><rxjs><rxjs6>","2","1","1","","","CC BY-SA 4.0"
"53163108","1","","","2018-11-05 22:21:49","","0","837","<p>I have a service <code>HomeService</code> and has this method in the service</p>

<pre><code>getAlerts(): Observable&lt;any&gt; {
    return this.apiService.post(`${this.DASHBOARD_URL}/alerts`);
}
</code></pre>

<p>so I have a scenario where I have to poll this method every 10 sec to get the new data and polling should happen only on success response and when browser tab is active. When browser tab is inactive, the polling should pause and resume when tab is active. </p>

<p>From the component I am doing this:</p>

<pre><code>import {Subscription, timer as observableTimer} from 'rxjs';
import {delay, retryWhen, takeWhile} from 'rxjs/operators';

    private pollAlerts(): void {
             this.pollAlertsRequest = this.homeService.getAlerts().pipe(retryWhen(errors =&gt; errors.pipe(delay(10 * 1000))))
              .subscribe(res =&gt; {
                this.populateAlerts(res.alerts);
                this.alertsTimer = observableTimer(10 * 1000).pipe(
                  takeWhile(() =&gt; this.isComponentAlive))
                  .subscribe(() =&gt; {
                    this.pollAlerts();
                  });
              });
    }
</code></pre>

<p>I am able to get the timer done, but not sure how to pause and resume.  </p>
","4093172","","4093172","","2018-11-06 01:06:14","2018-11-06 02:12:05","Rxjs timer with pause and resume the poll","<javascript><angular><typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53182499","1","53182649","","2018-11-07 01:26:53","","0","507","<p>Attempting to verify that an observable emits a certain number of events before it completes.  This is pseudo code:</p>

<pre><code>o.pipe(count).subscribe(count=&gt;
  expect(count).toEqual(4));
</code></pre>

<p>Thoughts?</p>
","1684269","","1684269","","2018-11-07 01:53:13","2018-11-07 01:53:41","Counting the number of values emitted before the Observable completes?","<node.js><typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53196493","1","53196578","","2018-11-07 19:30:26","","1","3823","<p>Getting this error when I upgraded to Angular 6. I see the documentation to use .pipe(), but I am not getting how to use pipe when there is multiple .map() as below. Need your help...</p>

<pre><code>   import {Injectable} from '@angular/core';
    import {Http, Headers} from '@angular/http';
    import 'rxjs/add/operator/map';
    import {TOKEN_AUTH_PASSWORD, TOKEN_AUTH_USERNAME} from '../services/auth.constant';

    @Injectable()

    export class AuthenticationService {

      static AUTH_TOKEN = '/oauth/token';
      constructor(private http: Http) {
      }
      login(username: string, password: string) {

        const body = `username=${encodeURIComponent(username)}&amp;password=${encodeURIComponent(password)}&amp;grant_type=password`;

        const headers = new Headers();
        headers.append('Content-Type', 'application/x-www-form-urlencoded');
        headers.append('Authorization', 'Basic ' + btoa(TOKEN_AUTH_USERNAME + ':' + TOKEN_AUTH_PASSWORD));
        return this.http.post(AuthenticationService.AUTH_TOKEN, body, {headers})
          //.map(res =&gt; res.json())
          .pipe(map((res: any) =&gt; {
            if (res.access_token) {
              return res.access_token;
            }
            return null;
          }));
      }
    }
</code></pre>

<p>I understand to use .pipe when there is one .map is used like below, but I am not getting how to use pipe() when multiple .map are used.</p>

<pre><code>.pipe(map(data =&gt; {})).subscribe(result =&gt; {
      console.log(result);
    });
</code></pre>
","1338585","","1338585","","2018-11-07 19:45:09","2018-11-07 19:53:57","Angular 6 - rxjs property 'map' does not exist on type 'observable'","<angular><typescript><rxjs><rxjs6>","1","2","","2018-11-07 19:37:05","","CC BY-SA 4.0"
"53201857","1","53204497","","2018-11-08 05:08:40","","0","115","<p>I have this method in Angular (latest, package.json shows 7.0.0) and <code>Rxjs 6.3.3</code>. I am calling a <strong>SpringBoot</strong> Rest API that returns a list of Flights. I want to convert into <code>Observable&lt;Flight[]&gt;</code>.</p>

<pre><code>search(searchquery): Observable&lt;Flight[]&gt;
  {
    return this.http.post('/searchservice/search/get', searchquery)
      .pipe(map(response =&gt; 
      {
        return (response.map((flight: Flight) =&gt;
        {
          return new Flight().deserialize(flight);
        }));
      }));

  }
</code></pre>

<p>But when building, I get this error </p>

<blockquote>
  <p>""error TS2339: Property 'map' does not exist on type 'Object'""</p>
</blockquote>

<p>. The error is shown in the <code>response.map((flight: Flight) =&gt;</code> code. May I know what I am doing wrong?
Based on the query below, this is the json response printed.</p>

<pre><code>0: {id: 4, flightNumber: ""BF101"", origin: ""NYC"", destination: ""SFO"", flightDate: ""22-JAN-16"", …}
1: {id: 7, flightNumber: ""BF105"", origin: ""NYC"", destination: ""SFO"", flightDate: ""22-JAN-16"", …}
2: {id: 10, flightNumber: ""BF106"", origin: ""NYC"", destination: ""SFO"", flightDate: ""22-JAN-16"", ..}
</code></pre>

<p>And one more thing. The code worked perfectly yesterday, but today morning, it started showing errors. Weird!!!
What I am trying to do is similar to this code below which is written in the book, The complete book on Angular.</p>

<pre><code>return this.http.get(queryUrl)
  .map((response: Response) =&gt; {
   return (&lt;any&gt;response.json()).items.map(item =&gt; {
   SearchResult({
      id: item.id.videoId,
      title: item.snippet.title,
      description: item.snippet.description,
      thumbnailUrl: item.snippet.thumbnails.high.url
    });
  });
});
</code></pre>
","4308371","","4308371","","2018-11-08 07:54:27","2018-11-15 08:55:00","Correct way of using RxJS","<angular><rxjs6>","1","9","","","","CC BY-SA 4.0"
"53207445","1","","","2018-11-08 12:08:05","","0","591","<p>I have a taxi booking app that uses Ionic Geolocation and Firebase Firestore. My code was not working with the firestore package so i had to update rxjs to version 6. It brought up the error </p>

<pre><code>'Property 'filter' does not exist on type 'Observable&lt;Geoposition&gt;'. '
</code></pre>

<p>Here is my code</p>

<pre><code>import { filter } from 'rxjs/operators';



    const subscription = this.geo.watchPosition()
                          .filter((p) =&gt; p.coords !== undefined) //Filter Out Errors
                          .subscribe(position =&gt; {
                          let latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
                          this.map.setCenter(latLng);
                          this.lat = position.coords.latitude;
                          this.long = position.coords.longitude;
                          console.log(this.long + ' ' + this.lat);
});
</code></pre>

<p>my package.json file</p>

<pre><code>""@ionic-native/core"": ""~4.15.0"",
""@ionic-native/geolocation"": ""^4.17.0"",
""@ionic-native/splash-screen"": ""~4.15.0"",
""@ionic-native/status-bar"": ""~4.15.0"",
""@ionic/storage"": ""2.2.0"",
""angularfire2"": ""^5.1.0"",
""cordova-plugin-geolocation"": ""^4.0.1"",
""firebase"": ""^5.5.7"",
""ionic-angular"": ""3.9.2"",
""ionic-native"": ""^2.9.0"",
""ionicons"": ""3.0.0"",
""rxjs"": ""^6.3.3"",
""rxjs-compat"": ""^6.3.3"",
</code></pre>

<p>What is wrong with my code?</p>
","8390502","","","","","2018-11-08 12:29:46","Property 'filter' does not exist on type 'Observable<Geoposition>'. Google Maps","<rxjs><ionic3><ionic-native><rxjs6>","1","5","0","","","CC BY-SA 4.0"
"53210309","1","","","2018-11-08 14:56:58","","1","45","<p>I am new to the RxJS library. </p>

<p>What I am trying to achieve is to get infinite scroll working properly on a page (smart component). Observable that contains data that is supposed to be displayed is initially an array of ten objects. As soon as user scrolls to the bottom of the page, is where I am trying to append or concatenate the observable with the next ten objects. Template that shows data is looping through with *ngFor and async pipe. I can paste that code too if needed.</p>

<p>I have figured out when the scroll method is triggered and how to keep track of how many elements I have, so I can do a http request for next ten objects.</p>

<p>Looking at the documents from me it makes sense that concat operator is perfect for me, but could not make it work. After a lot of digging I finally found this thread: <a href=""https://stackoverflow.com/questions/42859848/combining-2-arrays-in-correct-sequence-using-rx-js"">Combining 2 arrays in correct sequence using Rx.js</a></p>

<p>My last method is from the thread I linked. It does actually make observable accumulate by ten elements, but the problem is that it scrolls at top everytime that happen, which is not desirable. Are there more convenient ways to achieve this ? And how do I prevent the page to scroll at top?</p>

<p>Here is the HTTP method in service class:</p>

<pre><code>//Returns all articles corresponding to given categorytitle as input parameter

public getCategoryArticles(httpParams: HttpParameters): Observable&lt;Article[]&gt;{

  const headers = new Headers().set('Content-Type', 'application/json');

  const params = this.createHttpParams(httpParams);

  return this.HTTP_GET({headers: headers, params: params}).pipe(
    map((data: any) =&gt; {
      return data.stream.current.map((categoryData: any) =&gt; {
        return {
          id: categoryData.siObj.id,
          headline1: categoryData.siObj.headline1,
          headline2: categoryData.siObj.headline2,
          headline3: categoryData.siObj.headline3,
          lead: categoryData.siObj.lead,
          byline: categoryData.siObj.byline,
          body: categoryData.siObj.body,
          media: categoryData.siObj.media
        };
      });
    }),
    catchError((error) =&gt; {
      return throwError(`A problem has occured. More info: ${error}`);
    })
  );
}
</code></pre>

<p>Here are some of the methods in page class (smart component). Initial statements:</p>

<pre><code>ngOnInit(){
    this.from = 0;
    this.categoryKey = this.route.snapshot.paramMap.get('key');
    this.categoryCount = Number(this.route.snapshot.paramMap.get('count'));
    this.category$ = this.getCategoryArticles(this.categoryKey, this.from);
}
</code></pre>

<p>HTTP request from page class.</p>

<pre><code>getCategoryArticles(categoryAsString: string, from: number): Observable&lt;Article[]&gt; {
    const httParams: HttpParameters = {
      aType: ""stream"", 
      action: ""getStream"",
      categoriesAsString: categoryAsString, 
      from: String(from),
      size: ""10""
    };
    this.from = this.from + 10;
    return this.networkService.getCategoryArticles(httParams); 
}
</code></pre>

<p>Infinite scroll method.</p>

<pre><code> //Triggered when scrolling at bottom of page
  loadData(){ 
    this.category$ = this.category$.pipe(
      combineLatest(this.getCategoryArticles(this.categoryKey, this.from))
      ,map(([current, latest]) =&gt; {
        return [...current, ...latest];
      })
    );
  }
</code></pre>
","6115017","","472495","","2018-11-10 11:27:02","2018-11-10 11:27:02","Concatenate two Observables into one. The Observables types are Array of objects","<angular6><rxjs6><ionic4>","0","0","","","","CC BY-SA 4.0"
"53211877","1","","","2018-11-08 16:19:19","","1","69","<p>I'm using RxJs 6 with angular 7.</p>

<p>I want to draw a line from one start element to another point into a canvas. The start element is already drawn into the canvas.</p>

<p>I have two streams:</p>

<ul>
<li>One that emits the click on start element, <code>click$</code>;</li>
<li>One that emits the clicks from the canvas, <code>canvasClick$</code>; </li>
</ul>

<p><a href=""https://i.stack.imgur.com/UsOTy.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UsOTy.jpg"" alt=""two stream""></a></p>

<p>How can I define the subscriptions where to call <code>startDraw()</code> and <code>endDraw()</code>? How to manage the middle drawing state with streams?</p>

<p><strong>EDIT: a no reactive solution</strong></p>

<pre><code>drawState = false;

fromEvent(elem, 'click').subscribe((e) =&gt; {
    console.log('hang', e);
    drawState = true;
    e.stopPropagation();
  });

fromEvent(canvas, 'click').subscribe((e) =&gt; {
    if (lineBuilding) {
      console.log('stage', e);
      lineBuilding = false;
    }
  });
</code></pre>

<p>I think that there is a better way using reactive, I think that the variable <code>lineBuilding</code> is necessary and the use of stopPropagation()?</p>
","10529476","","7109869","","2018-11-09 12:01:04","2018-11-09 12:01:04","RxJs - Change behavior of a stream from another stream","<angular><reactive-programming><rxjs6><angular7>","0","0","","","","CC BY-SA 4.0"
"53217669","1","53223534","","2018-11-08 23:25:07","","0","546","<p>I have to following problem:</p>

<p>Many API calls go through an API interface (Google API) and have to be limited in request per seconds/concurrency because of the Google API limitation.</p>

<p>I use a subject (<em>sink</em>/call pool), which manages all API requests with mergeMap and returns a result to another, piped subject.</p>

<p>Because API requests can unsubscribe before they finish, they shouldn't block my sink. So I have to stop the API request (<em>task</em>) after unsubscription.</p>

<p>The issue:
I don't know how to capture this unsubscribed state correctly. What I currently do is overwriting <em>subscribe</em> and <em>unsubscribe</em> to catch this state. It works but it does not look to ""rxjs""ish for me.</p>

<p>What could I improve it?</p>

<pre><code>import {Observable, Subject, Subscription, Subscribable, EMPTY} from 'rxjs';
import {mergeMap, tap} from 'rxjs/operators';

function doHeavyRequest() {
    return new Observable(subscribe =&gt; {
        // Simulate delay.
        setTimeout(() =&gt; {
            subscribe.next(1);
            subscribe.complete();
        }, 1000);
    });
}

const sink = new Subject&lt;[Subject&lt;any&gt;, number]&gt;();

sink.pipe(
    mergeMap(([subject, id]) =&gt; {
        // Stop request here if already unsubscribed.
        if (subject.closed) {
            console.log('Request cancelled:', id);
            return EMPTY;
        }
        return doHeavyRequest()
            .pipe(
                tap(res =&gt; {
                    if (!subject.closed) {
                        subject.next(res);
                        subject.complete();
                    } else {
                        console.log('Request aborted:', id);
                    }
                })
            );
    }, 2)
).subscribe();

// Insert request into sink.
// Overwrite subscribe and unsubscribe.
// Track unsubscribe over the flag alive.
function getSomething(id: number) {
    const task = new Subject();

    const ob = task.asObservable();

    ob.subscribe = (...args: any[]) =&gt; {
        const sub = Observable.prototype.subscribe.call(ob, ...args);
        sub.unsubscribe = () =&gt; {
            if (!task.isStopped)
                task.unsubscribe();
            Subscription.prototype.unsubscribe.call(sub);
    };
        return sub;
    };

    sink.next([task, id]);

    return ob;
}

// Make 3 requests and unsubscribe.
export function test() {
    const ob0 = getSomething(0);
    const ob1 = getSomething(1);
    const ob2 = getSomething(2);

    const sub0 = ob0.subscribe(e =&gt; {
        console.log('0:', e);
    });
    setTimeout(() =&gt; sub0.unsubscribe(), 1500);

    const sub1 = ob1.subscribe(e =&gt; {
        console.log('1:', e);
    });
    setTimeout(() =&gt; sub1.unsubscribe(), 900);

    const sub2 = ob2.subscribe(e =&gt; {
        console.log('2:', e);
    });
    setTimeout(() =&gt; sub2.unsubscribe(), 100);
}
</code></pre>

<p>See the <em>test.ts</em> at plunker and the console output:</p>

<p><a href=""https://next.plnkr.co/edit/KREjMprTrjHu2zMI?preview"" rel=""nofollow noreferrer"">https://next.plnkr.co/edit/KREjMprTrjHu2zMI?preview</a></p>
","1611317","","1611317","","2018-11-09 07:26:26","2018-11-09 09:59:28","Cancel concurrency HTTP requests after unsubscription","<angular><typescript><rxjs><google-api-client><rxjs6>","2","4","","","","CC BY-SA 4.0"
"53217726","1","","","2018-11-08 23:32:47","","0","47","<p>I was trying to get the fetched data based on the changed events. The result I was expected should be an object instead I see observable as the fetch produces promise.</p>

<p>The <code>flatMap</code> was used to convert <code>promise</code> to an object, but it seems I was doing wrong. Please let me know how I can fix it. </p>

<pre><code>/** Receives UpdateEvent */
const changes$ = new Subject&lt;FileChangesEvent&gt;();

/** mock for 'this' */
const context = {
    notify: (...args) =&gt; console.log('[CONTEXT.NOTIFY]: ', ...args),
    processAdds: (input) =&gt; of(input).pipe(delay(input.debounce || 1), map(i =&gt; Object.assign(i, ...fetch(i.url)))),
    processUpdates: (input) =&gt; of(input).pipe(delay(input.debounce || 1), map(i =&gt; Object.assign(i, ...fetch(i.url)))),
    processDeletes: (input) =&gt; of(input).pipe(delay(input.debounce || 1), map(i =&gt; Object.assign(i, { modified: 'fetchUpdates' }))),
};

/** Process FilesChange event */
const stream$ = changes$
    .pipe(
        /** Side effect for log current step */
        tap(event =&gt; console.log('onFileChanges trigged, event data: ', event.changes)),
        /** Fetching array of changes */
        map(event =&gt; event.changes),
        /** Use it for wait all 'forked' observables */
        flatMap(
            /** Process each record in parallel */
            changes =&gt; forkJoin(
                changes.map(change =&gt;
                    /** Update processing */
                    of(change)
                        .pipe(
                            tap(input =&gt; console.log('Validating the file Type: ', input)),
                            /** fetching data based on update type */
                            flatMap(input =&gt;
                                input.type === FileChangeType.ADDED
                                    ? context.processAdds(input)
                                    : context.processUpdates(input),
                            ),
                            /** remove large files from update */
                            map(input =&gt; (
                                input.type === FileChangeType.UPDATED &amp;&amp; input.size &lt; CONTENT_SIZE_LIMIT
                                    ? Object.assign(input, { value: '' })
                                    : input
                            )),
                            /** side effect for pubsub notifications */
                            tap(updates =&gt; context.notify(updates)),
                        ),
                ),
            ),
        ),
    );

/** When updates stream was finished */
stream$.subscribe(
    (...args) =&gt; console.log('[TICK]: ', ...args), // When all event updates was processed
    (...args) =&gt; console.log('[ERROR]: ', ...args),
    (...args) =&gt; console.log('[DONE]: ', ...args),
);

export const updateEventsStream = (event) =&gt; changes$.next(event);
</code></pre>
","1595858","","","","","2018-11-12 04:04:33","return data based on the fetch urls","<observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53234647","1","53234710","","2018-11-09 23:40:40","","1","217","<p>I'm trying to implement the login as mentioned here.</p>

<p><a href=""https://ngxs.gitbook.io/ngxs/recipes/authentication"" rel=""nofollow noreferrer"">https://ngxs.gitbook.io/ngxs/recipes/authentication</a></p>

<pre><code>  @Action(Login)
  login({ patchState }: StateContext&lt;AuthStateModel&gt;, { payload: { username } }: Login) {
    return this.authService.login(payload).pipe(tap((result: { token: string }) =&gt; {
      patchState({ token, username });
    }))
  }
</code></pre>

<p>But I'm unable to get the reference of 'payload' as shown in the sample, instead I get the following error. Any help appreciated ! I also wanted to know what '{ payload: { username } }' would mean in the input parameters of the function.</p>

<p><a href=""https://i.stack.imgur.com/AD6x9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AD6x9.png"" alt=""enter image description here""></a></p>
","1376533","","","","","2018-11-14 16:34:40","Angular/NGXS sample code - cannot get reference of the parameter input","<angular><angular6><rxjs6><ngxs>","1","3","","","","CC BY-SA 4.0"
"53235191","1","53235221","","2018-11-10 01:14:14","","1","12064","<p>When I make a GET call via HttpClient I want to pass back an array of the actual typed objects, vs. just a generic 'object', and so I tried to do this:</p>

<pre class=""lang-js prettyprint-override""><code>getExistingArsByLab(labId: number): Observable&lt;EhsAssessmentAr[]&gt; {
    return this.http
        .get&lt;EhsAssessmentAr[]&gt;(`${this.baseUrl}/ar?labId=${labId}`)
        .pipe(
            map(x =&gt; {
                const ret = EhsAssessmentAr.fromJson(x);
                ret.ar = this.sanitizer.sanitize(SecurityContext.HTML, ret.ar.replace(/\n/g, '&lt;br/&gt;'));
                return ret;
            })
        )
}
</code></pre>

<p>That <code>fromJson</code> method is declared to return the proper class, and I thought since I was sending this through <code>map</code> that I'd get back an array.  I'm REALLY new to RxJs so I'm sure I'm just doing something completely stupid there.</p>

<p>I'm getting theerror:</p>

<blockquote>
  <p>TS2322: Type 'Observable&lt;EhsAssessmentAr>' is not assignable to type 'Observable&lt;EhsAssessmentAr[]>`</p>
</blockquote>
","1455351","","7109869","","2018-12-03 21:52:02","2019-05-10 08:17:09","How do I pipe/map to return an array in Angular 7","<angular><rxjs><pipe><angular7><rxjs6>","2","5","1","","","CC BY-SA 4.0"
"53240090","1","53240209","","2018-11-10 14:48:35","","8","1878","<p>The documentation isn't helpful enough for me to understand the difference between these.</p>

<blockquote>
  <p>It's like concatMap, but maps each value always to the same inner
  Observable.
  <a href=""http://reactivex.io/rxjs/file/es6/operators/concatMapTo.js.html"" rel=""noreferrer"">http://reactivex.io/rxjs/file/es6/operators/concatMapTo.js.html</a></p>
</blockquote>

<p>I tried checking out learnrxjs.io's examples on stackblitz, but even with those, I wasn't able to immediately identify what the distinguishing feature was separating these.</p>

<p>FYI i saw this other similar question
<a href=""https://stackoverflow.com/questions/39290306/what-is-the-difference-between-mergemap-and-mergemapto"">What is the difference between mergeMap and mergeMapTo?</a>
but the answer in there wasn't satisfactory, because in the learnrxjs.io examples, they clearly map to observables, not hard-coded values.
<a href=""https://www.learnrxjs.io/operators/transformation/concatmapto.html"" rel=""noreferrer"">https://www.learnrxjs.io/operators/transformation/concatmapto.html</a></p>

<p>If someone could provide some examples (and maybe a brief explanation) to help distinguish the *** vs the ***To higher-order observable operators, I'd appreciate that, thanks.</p>
","3147666","","","","","2018-11-10 16:18:22","RxJs: ConcatMap VS ConcatMapTo, MergeMap VS MergeMapTo","<rxjs><rxjs6>","1","1","1","","","CC BY-SA 4.0"
"53240192","1","53241246","","2018-11-10 15:00:25","","0","35","<p>I have a similar case to one described in <a href=""https://stackoverflow.com/questions/49627239/casting-a-type-interface-via-map-to-observable"">this post</a>.</p>

<p>I have a user login service, which (among other things) verifies if user's token is still valid. The server's response is defined in an interface:</p>

<pre class=""lang-js prettyprint-override""><code>export interface UserVerifyResponse {
    success: boolean
}
</code></pre>

<p>My aim was to create an observable that will return a boolean value depending on whether user is verified. This code was working with RxJS v6.2:</p>

<pre><code>authenticate(): Observable&lt;boolean&gt; {
    return this.http.get&lt;boolean&gt;(
        this.apiUrl+'/verify_user'
    ).pipe(
        map&lt;UserVerifyResponse, boolean&gt;((receivedData: UserVerifyResponse) =&gt; {
            return receivedData.success;
        }),
        tap((data: boolean) =&gt; {console.log(""User authenticated"", data)}),
        catchError(this.handleError)
    )
}
</code></pre>

<p>However, now that I have updated RxJS to v6.3 I get this error:</p>

<pre><code>ERROR in src/app/login/user.service.ts(50,13): error TS2345: Argument of type 'OperatorFunction&lt;UserVerifyResponse, boolean&gt;' is not assignable to parameter of type 'OperatorFunction&lt;boolean, boolean&gt;'.
  Type 'UserVerifyResponse' is not assignable to type 'boolean'.
</code></pre>

<p>It bothers me, because I use this approach of mapping API response to an internal class or a primitive (in other place I have a service which uses <code>http.get&lt;T&gt;</code>) and now I wonder if I should force RxJS 6.2 or there is an easy way to migrate to 6.3. I can rewrite all of them as it is described in the answer to the above mentioned post, but I I want to return a boolean value and my approach looks clearer in my opinion. </p>

<p>Any suggestions?</p>
","5854688","","","","","2018-11-10 16:56:50","Why map doesn't work after upgrading RxJS to v6.3","<typescript><type-conversion><rxjs><rxjs6><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"53240230","1","","","2018-11-10 15:04:12","","0","77","<p>In search for a timer - triggered every minute, on the minute - that doesn't drift, I found <a href=""https://stackoverflow.com/questions/13838113/observable-timer-how-to-avoid-timer-drift"">this</a> solution. However I'm having difficulties understanding how to use / construct the last parameter <code>scheduler?: SchedulerLike</code>.</p>

<pre><code>const noDrift = generate(
  0,
  _ =&gt; true, // start condition
  i =&gt; ++i,  // iterate
  i =&gt; i,    // result selector
  i =&gt;  ...  // scheduler?: SchedulerLike; every minute on the minute, but how?
);

noDrift.subscribe(() =&gt; {
  // action
});
</code></pre>

<p>original solution that drifts:</p>

<pre><code>const date = new Date();

// calculate how many ms are left till the full minute is reached
const tillNextFullMinute = (60 - date.getSeconds()) * 1000 - date.getMilliseconds();

// start on the next full minute, then just every minute
this.currentTime = timer(tillNextFullMinute, 60 * 1000);
this.currentTime.subscribe(value =&gt; {
  // action
});
</code></pre>
","1378051","","","","","2018-11-10 15:04:12","Using RxJS's `generate` to create a non-drifiting timer, how to use the `scheduler`?","<timer><rxjs><scheduler><rxjs6>","0","3","","","","CC BY-SA 4.0"
"53244389","1","53244415","","2018-11-10 23:22:07","","2","348","<p>Assume that you have a json object as response. e.g </p>

<pre><code>var items = [{
    title: 'sample 1',
    image: 'http://www.lorempixel.com/700/600/',
    description: 'lorem ipsum'
}, {
    title: 'sample 2',
    image: 'http://www.lorempixel.com/900/1200/',
    description: 'lorem ipsum'
}]
</code></pre>

<p>How to map the object in order to have only a result object like this: </p>

<pre><code>[{
    image: 'http://www.lorempixel.com/700/600/',

}, {
    image: 'http://www.lorempixel.com/900/1200/',
}]
</code></pre>

<p>is there a clean way using rxjs operators? or simply js native? </p>

<p>I tried it using :</p>

<pre><code>const source = from(items);
const result = source.pipe(
                    pluck('image')
                );
result.subscribe(val =&gt; console.log('new values ', val));
</code></pre>

<p>But it's not working. Is there a cleaner way?</p>
","6432698","","","","","2018-11-11 19:54:24","Extract specific keys from json using rxjs or native javascript","<javascript><json><angular><rxjs6>","2","1","0","","","CC BY-SA 4.0"
"53245197","1","","","2018-11-11 01:58:13","","0","73","<p>I'm building a trading bot which sometimes requires to make multiple calls to the Exchange's API (e.g. refresh N charts after reconnect). I'd like to have these calls time-spaced so I don't end up flooding the API (I still don't want to discard any call I need to make, so debounce/throttle is not what I'm looking for). Like this:</p>

<p>Source: [update chart 1, update chart 2, ..., update chart N]</p>

<p>Observable: [update chart 1 -> wait 1 second -> update chart 2 -> wait 1 second -> ... -> update chart N]</p>

<p>I'd expect this observable to complete in N - 1 seconds.</p>

<p>How can I build such Observable?
(I'm using rxjs ^6.3.3)</p>

<p>Note: I was exploring the idea of having a callAPI Subject wrapping all calls to the API and delay them somehow, but I can't figure this either.</p>

<p>Thanks.-</p>

<p><strong>Update</strong>: Ok, I ended up using <a href=""https://github.com/SGrondin/bottleneck"" rel=""nofollow noreferrer"">Bottleneck</a>, like this:</p>

<pre><code>const limiter = new Bottleneck({
  minTime: 1000
})
</code></pre>

<p>Then: <code>chartsToReset.map(async (chart) =&gt; await limiter.schedule(() =&gt; exchangeAPI.updateChart(chart)))</code></p>
","4185753","","4185753","","2018-11-12 15:12:43","2018-11-12 15:12:43","Spacing calls to API in order to avoid flooding it","<javascript><rxjs6>","2","0","","","","CC BY-SA 4.0"
"53248105","1","","","2018-11-11 11:08:13","","0","44","<p>I have upgraded my current project from angular 4 to version 6. I followed the steps mentioned in this URL: <a href=""https://update.angular.io/"" rel=""nofollow noreferrer"">https://update.angular.io/</a></p>

<p>I corrected the import definitions for RxJs classes and operators according to version 6+, used pipe operators to combine multiple operators and resolved the name of operators that were changed in RxJs version 6. </p>

<p>I am not facing any issue when compiling the build for development but observing issue while running the application with optimized build <code>**ng --prod**</code>.</p>

<p>Here is my current package.json file.</p>

<pre><code>    ""dependencies"": {
      ...
      ""primeng"": ""4.0.3"",
      ""rxjs"": ""^6.3.2"",
      ""rxjs-compat"": ""^6.3.2"",
      ""tixif-ngx-busy"": ""0.0.8"",
      ""zone.js"": ""^0.8.26""
    }
</code></pre>

<p>and here is the error in console.</p>

<p><a href=""https://i.stack.imgur.com/RY565.png"" rel=""nofollow noreferrer"">https://i.stack.imgur.com/RY565.png</a></p>
","10483719","","10483719","","2018-11-11 11:24:25","2018-11-11 20:22:12","Angular 6 upgrade run time issue for optimized build","<migration><angular6><rxjs6>","1","1","","","","CC BY-SA 4.0"
"53248669","1","","","2018-11-11 12:16:52","","0","1742","<p>I'm playing with RxJS for the first time, and I'm trying to create a simple observable that will take both a maximum number of entries <em>and</em> wait for a time interval to pass before passing the data on to subscribers.</p>

<p>This is what I have:</p>

<pre class=""lang-js prettyprint-override""><code>import EventEmitter from ""events"";

import { fromEvent } from ""rxjs"";
import { bufferTime, filter, take } from ""rxjs/operators"";

const ev = new EventEmitter();
const observer = fromEvent(ev, ""log"").pipe(
  take(10),
  bufferTime(1000),
  filter(logs =&gt; !!logs.length)
);

observer.subscribe(data =&gt; {
  console.log(`received: ${data.length}`);
});

for (let i = 0; i &lt; 100; i++) {
  ev.emit(""log"", { hello: ""world"" });
}
</code></pre>

<p><strong>What I expected to happen:</strong></p>

<p><code>received: 10</code> to be printed 10x, at 1 second intervals.</p>

<p><strong>What actually happened:</strong></p>

<p><code>received: 10</code> was printed once, and then the script exits.</p>

<p><strong>Why I <em>think</em> it's happening</strong></p>

<p>I'm new to RxJS, but from what I can gather the <code>take()</code> operator emits a 'completed' status after it has taken 10 entries, which prevents any further subscriptions from firing.</p>

<p>How do I make this observable 'recurring' so that it'll a) take a maximum of 10, b) ensure it runs, at most, once every 1000ms, and c) repeat forever?</p>
","216012","","","","","2018-11-12 17:52:32","RxJS - receiving data in batches of time + max","<rxjs><rxjs6>","2","4","1","","","CC BY-SA 4.0"
"53258982","1","","","2018-11-12 09:13:34","","3","1803","<p>I want to listen scroll event and handler them by two function for two scroll.</p>
<p>One need a <code>throttleTime()</code> to save resource and the other cannot use <code>throttleTime()</code> because it need trigger immediately and it doesn't cast too much.</p>
<p>Now I add two <code>fromEvent</code> to handle them but question is they will both be fired if scroll event is triggered.</p>
<pre><code>fromEvent(this.vscroll.nativeElement, 'scroll').pipe(throttleTime(200)).subscribe((e) =&gt; {
  if (this.timer) {
    clearTimeout(this.timer);
    this.timer = null;
    this.timer = setTimeout(() =&gt; {
      this.updateShow();
    }, 201);
  } else {
    this.timer = setTimeout(() =&gt; {
      this.updateShow();
    }, 201);
  }
});
fromEvent(this.vscroll.nativeElement, 'scroll').subscribe((e) =&gt; {
  (document.body.querySelector('#headerScroll') as HTMLElement).style.marginLeft = -this.vscroll.nativeElement.scrollLeft + 'px';
});
</code></pre>
<p>In my component those two function won't happen at the same time, so what should I do to make it only trigger one function and prevent from the other being executed?</p>
","8530145","","4370109","","2020-12-13 22:17:50","2020-12-13 22:17:50","How to listen scroll event for x scroll and y scroll Individually","<javascript><typescript><dom-events><rxjs6>","1","1","","","","CC BY-SA 4.0"
"53260723","1","","","2018-11-12 10:59:58","","0","31","<p>I am struggling with using observables and pipes where I want to add one item from one observable to another observable containing a list of items of the same type. </p>

<p>I have type X. And of the type X I have an observable array:</p>

<pre><code>readonly arrayOfx$: Observable&lt;X[]&gt;;
</code></pre>

<p>I also have an observable of only the the type X:</p>

<pre><code>private readonly _x$: Observable&lt;UpdateOfX&gt;;

interface UpdateOfX {
    x: X,
    updateState: ""Add"" | ""Modified"" | ""Removed""
}
</code></pre>

<p>All this code is in a Service Class where the service should only expose the array of X. The data in the array I want to show in my html with async piping and this part of the functionality works. The host and the client are connected with the signalR technique and onConnected, an array of items of type X is retrieved. But as the application runs, in the backend new items of type X can be created, existing items can be changed or can be removed and when this occures, only this item will be send via the signalR connection and the modification state. </p>

<p>In the front end, this item must be added to the already retrieved array of items of type X. In the service, the pipe technique is used and my question is, how do I add the single item I get in a later moment to the list of items I retrieved earlier?</p>

<pre><code>constructor() {
    this.arrayOfx$ = this._someSignalRHelperService.retrieveMultipleItems$.pipe(
        tap((xArray: X[]) =&gt; console.log(xArray)), 
        //can I somehow get the a later created x from the server here...
    );

    this._x$ = this._someSignalRHelperService.retrieveOneItem$.pipe(
        tap((updateOfX: UpdateOfX) =&gt; console.log(updateOfX)),
        map((updateOfX: UpdateOfX) =&gt; {
            //process the updateState
            //... or must I do something here to get x into x[]?
        })
    );
}
</code></pre>

<p>Since SignalR is used, the backend is in control when the client receives a new item of type X when there is one created. </p>
","1856913","","1856913","","2018-11-12 11:28:16","2018-11-13 09:10:30","How to add one item from observable to an array of items in a different observable?","<typescript2.0><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53282811","1","","","2018-11-13 14:06:11","","2","829","<p>I've been wondering if it's safe to assume that after the using the tap operator, the side effect inside it has completed.</p>

<p>My use case is with ngrx. </p>

<pre class=""lang-js prettyprint-override""><code> ...
tap(() =&gt; {
    this.store.dispatch(new SetValue(""Hello World""));
  }
}),
switchMap(() =&gt; this.store),
select(state =&gt; state.value),
tap(state =&gt; {
  if (state === undefined) {
    throw new Error(""Couldn't find value"");
  }
})
</code></pre>

<p>SetValue is an class that implements ngrx </p>

<pre class=""lang-js prettyprint-override""><code>export class SetValue implements Action {
  readonly type = SET_VALUE;
  constructor(public payload: string) {}
}
</code></pre>



<p>What I'm trying to implement is to set a value on the store and then check if it's effectively been set.</p>

<p>Can I assume the dispatch has completed after tap operator?</p>

<p><strong>Answer</strong></p>

<p>I used this on <em>Angular Router guards</em> to set initial state by the parameters on the url, so I ended up filtering to only continue when the store has new value</p>

<pre class=""lang-js prettyprint-override""><code> ...
tap(() =&gt; this.store.dispatch(new SetValue(""Hello World""))),
switchMap(() =&gt; this.store),
select(state =&gt; state.value),
filter(value =&gt; value === ""Hello World""),
take(1)
</code></pre>
","7037861","","7037861","","2019-03-12 17:10:27","2019-03-12 17:10:27","RxJS 6 / When does tap operator emit a value","<rxjs><ngrx><rxjs5><rxjs6><ngrx-store>","1","1","","","","CC BY-SA 4.0"
"53286573","1","53291742","","2018-11-13 17:31:22","","2","1010","<p>I'm seeing the http request happen - in the Chrome Network tab, and also by using <code>then()</code> within the fetch promise - with the below code, despite never subscribing to the inner observable (<code>saveCourses$</code>).</p>

<p>I modified to use <code>from()</code> rather than <code>fromPromise()</code> as per the updated rxjs documentation, but the same occurs.</p>

<p>My understanding is that the inner Observable should not run?</p>

<pre><code>ngOnInit() {
  this.form.valueChanges.pipe(
    filter(() =&gt; this.form.valid)
  )
    .subscribe(changes =&gt; {
      const saveCourses$ = fromPromise(fetch(`/api/courses/${this.course.id}`, {
        method: 'PUT',
        body: JSON.stringify(changes),
        headers: {
          'content-type': 'application/json'
        }
      }));
    });
}
</code></pre>
","2765936","","","","","2018-11-14 01:06:30","http request within Observable happens even without subscription","<javascript><angular><ecmascript-6><rxjs6>","2","3","","","","CC BY-SA 4.0"
"53313511","1","","","2018-11-15 06:18:52","","0","34","<blockquote>
  <p>Forgive the awkward question title, I'm not sure how to phrase it...</p>
</blockquote>

<p>I have an observable that returns a <code>Form</code> object.</p>

<pre><code>export class QuestionConfiguration {
    //...
}

export class Question {
    configure(qc: QuestionConfiguration) {
        // set variables...
    };
}

export class Form {
    constructor(public question: Question[]) {}
}

// lets assume this does a http call and returns an instanstiated list of forms.
let doFormsRequest$ = (): Observable&lt;Forms[]&gt; =&gt;  {
}
</code></pre>

<p>And I have another method which returns configuration for each inner <code>question</code> of the <code>Form.questions</code>:</p>

<pre><code>let getQuestionConfiguration$ = (question: Question): Observable&lt;QuestionConfiguration&gt; {
    // ...
}
</code></pre>

<p>I wish to create a <code>ReplaySubject(1)</code> that will be the observer of an observable that configures each of the questions with the questionConfiguration observable and only returns when all the sub questions have been configured.</p>

<p>Is there a way to pipe/map/whatever the first observable to return the fully configured form to achieve this?</p>

<p>something like:</p>

<pre><code>// using this as an observer so the configuration logic only happens once.
let mySubject: Subject&lt;Form[]&gt; = new ReplaySubject(1);

doFormsRequest$().pipe(
    someOperator((forms: Forms[]) =&gt; {
        // returns the configured form after calling and modifying each question according to the output of the getQuestionConfiguration observable
        // i.e. question.configure(qc: QuestionConfiguration);
    })
).subscribe(mySubject);
</code></pre>
","735284","","","","","2018-11-15 06:18:52","configure list of objects inside observable output","<typescript><rxjs><rxjs6>","0","2","","","","CC BY-SA 4.0"
"53332872","1","","","2018-11-16 06:56:52","","0","274","<p>When updating angular 6 to angular 7 I got error. I first used this command <strong>npm i -g rxjs-tslint</strong>. And then I used this command r<strong>xjs-5-to-6-migrate -p src/tsconfig.app.json</strong>.I got this error.</p>

<pre><code>        module.js:550
            throw err;
            ^

        Error: Cannot find module 'typescript'
            at Function.Module._resolveFilename (module.js:548:15)
            at Function.Module._load (module.js:475:25)
            at Module.require (module.js:597:17)
            at require (internal/module.js:11:18)
            at Object.&lt;anonymous&gt; (/usr/lib/node_modules/rxjs-tslint/node_modules/tslint/lib/linter.js:22:10)
            at Module._compile (module.js:653:30)
            at Object.Module._extensions..js (module.js:664:10)
            at Module.load (module.js:566:32)
            at tryModuleLoad (module.js:506:12)
            at Function.Module._load (module.js:498:3)
        child_process.js:645
            throw err;
            ^

        Error: Command failed: ""/usr/lib/node_modules/rxjs-tslint/node_modules/.bin/tslint"" -c ""/usr/lib/node_modules/rxjs-tslint/rxjs-5-to-6-migrate.json"" -p ""src/tsconfig.app.json"" --fix
        module.js:550
            throw err;
            ^

        Error: Cannot find module 'typescript'
            at Function.Module._resolveFilename (module.js:548:15)
            at Function.Module._load (module.js:475:25)
            at Module.require (module.js:597:17)
            at require (internal/module.js:11:18)
            at Object.&lt;anonymous&gt; (/usr/lib/node_modules/rxjs-tslint/node_modules/tslint/lib/linter.js:22:10)
            at Module._compile (module.js:653:30)
            at Object.Module._extensions..js (module.js:664:10)
            at Module.load (module.js:566:32)
            at tryModuleLoad (module.js:506:12)
            at Function.Module._load (module.js:498:3)

            at checkExecSyncError (child_process.js:602:13)
            at Object.execSync (child_process.js:642:13)
            at migrate (/usr/lib/node_modules/rxjs-tslint/rxjs-5-to-6-migrate.js:18:34)
            at Object.&lt;anonymous&gt; (/usr/lib/node_modules/rxjs-tslint/rxjs-5-to-6-migrate.js:25:14)
            at Module._compile (module.js:653:30)
            at Object.Module._extensions..js (module.js:664:10)
            at Module.load (module.js:566:32)
            at tryModuleLoad (module.js:506:12)
            at Function.Module._load (module.js:498:3)
            at Module.require (module.js:597:17)
</code></pre>
","9106682","","","","","2018-11-16 07:53:40","Updating Angular 6 to angular 7 got error","<javascript><angular><typescript><migration><rxjs6>","1","2","","","","CC BY-SA 4.0"
"53359370","1","53359396","","2018-11-18 09:15:48","","3","2158","<p>I followed this tutorial (really straightforward):
<a href=""https://www.techiediaries.com/rxjs-tutorial/"" rel=""nofollow noreferrer"">https://www.techiediaries.com/rxjs-tutorial/</a></p>

<p>My index.ts looks like this:</p>

<pre><code>import { Observable, Observer } from ""rxjs"";
import { map } from ""rxjs/operators""

console.log(Observable);

var observable = Observable.create((observer:Observer&lt;string&gt;) =&gt; {
    observer.next('Hello');
    observer.next('Hello Again');
    observer.complete();
});

observable.map((s:string) =&gt; s).subscribe((x:any) =&gt; {
    console.log(x);
});
</code></pre>

<p>webpack-dev-server starts without problem. It seems that ""Observable.create"" also works.</p>

<p>My problem: not a single operator will work. I get the errror when I open the page:</p>

<blockquote>
  <p>Uncaught TypeError: observable.map is not a function</p>
</blockquote>

<p>I am searching for 2 hours now - every article explains that this should be the correct way to use RxJs 6 with TypeScript.</p>

<p>My tsconfig.json:</p>

<pre><code>{
  ""compilerOptions"": {
    ""outDir"": ""./dist/"",
    ""sourceMap"": true,
    ""noImplicitAny"": true,
    ""module"": ""es6"",
    ""moduleResolution"": ""node"",
    ""target"": ""es6"",
    ""allowJs"": true,
    ""typeRoots"": [
      ""node_modules/@types""
    ],
    ""lib"": [
      ""es2017"",
      ""dom""
    ]
  }
}
</code></pre>

<p>My webpack.config.js:</p>

<pre><code>const path = require('path');
module.exports = {
    entry: './src/index.ts',
    devtool: 'inline-source-map',
    module: {
      rules: [
        {
          test: /\.tsx?$/,
          use: 'ts-loader',
          exclude: /node_modules/
        }
      ]
    },
    resolve: {
      extensions: [ '.tsx', '.ts', '.js' ]
    },
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist')
    }
};
</code></pre>
","1853429","","","","","2018-11-18 09:19:40","How to use RxJs 6 with TypeScript and WebPack","<typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53390328","1","53495354","","2018-11-20 09:53:06","","3","402","<p>I know this question has been asked before <a href=""https://stackoverflow.com/questions/51210629/angular-6-pipe-rxjs-operator-to-chain-3-dependant-observables/51210930"">here</a>. But the solution accepted is not working for me or I am not able to understand it well.</p>

<p>I am using ng-7
I have simple use case:</p>

<p>I have 2 APIs, 2nd is dependent on 1st's response.
I subscribe to result of 1st API and then using pipe subscribe to 2nd API result.</p>

<p>My code looks like below;</p>

<pre><code>this._SomeService
        .addUserToDb(payload)
        .pipe(
          map(res =&gt; res),
          mergeMap(db1Response =&gt;
            this._SomeService.addUserToDb2(db1Response
            )
          ),
          catchError(errodb1 =&gt; {

            return Observable.throw(new 
            Error(errorSso));
          })
        )
        .subscribe(
          resDb2 =&gt; {
              // Here I get response of addUserToDb2
          },
          errDb2 =&gt; {


          }
        )
</code></pre>

<p>Now before subscribing to second API response I want to subscribe to another observable say:</p>

<p>this._tokenService.getToken.pipe(</p>

<p>)</p>

<p>And Want to use it's response in service 2.
Such that:</p>

<p>API1 => token => API2</p>

<p>Please suggest how to implement.</p>

<p><strong>UPDATE:</strong></p>

<p>I tried to implement, below is my implementation:</p>

<pre><code>  this._service.addUserToDB1(payload).pipe(
          map(resp =&gt; this.resDB1 = resp) // Adding to global variable because I need this response while subscribing to DB2 service.
          ,mergeMap(resdb1=&gt;this._tokenService.getToken.pipe(
            mergeMap(token =&gt; this._service.addUserToDb2(
              this.resDB1,
              this.organizationId,
              this.practitionerId,
              token
            ),
            catchError(errorToken =&gt; {

              return Observable.throw(new Error(errorToken));
            })),
            )
          ),
          catchError(errordb1 =&gt; {

            return Observable.throw(new Error(errordb1));
          })

      ).subscribe (
        resdb2Response =&gt;
        {

        },
        errdb2 =&gt; {

        }
      )
</code></pre>

<p>Can someone validate if above implementation is fine or suggest right way?</p>
","3032338","","3032338","","2018-11-26 11:58:21","2018-11-27 08:18:21","Chain 3 or more dependent observables","<observable><rxjs6><angular7><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"53392647","1","53392780","","2018-11-20 12:05:09","","0","169","<p>I'm using <strong>ng-select v2</strong> and <strong>angular 7</strong>.</p>

<p>I'm getting an error at the return statement below</p>

<pre><code>getHospital(term: string = null): Observable&lt;Hospitals[]&gt; {
    let items = this.getHospitals1();
    if (term) {
      items = items.pipe(
        filter((x,i) =&gt; x[i].name.toLocaleLowerCase().indexOf(term.toLocaleLowerCase()) &gt; -1)
      )
    }
    return of(items).pipe(delay(500));
  }
</code></pre>

<p>3 errors which says:</p>

<blockquote>
  <ul>
  <li>Type 'Observable>' is not    assignable to type 'Observable'. </li>
  <li>Type 'Hospitals[] | Observable' is not assignable to type 'Hospitals[]'.</li>
  <li>Type 'Observable' is not assignable to type 'Hospitals[]'.</li>
  </ul>
</blockquote>

<p>here's my <strong>getHospitals1</strong> function</p>

<pre><code>getHospitals1() : Observable&lt;Hospitals[]&gt;{
    return this.http.get&lt;Hospitals[]&gt;('https://my-json-server.typicode.com/monsterbrain/FakeJsonServer/hospitals')
   }

export interface Hospitals {
  id: string;
  name: string;
  address: string;
}
</code></pre>

<p>What should be changed to fix this ?</p>
","8519297","","7109869","","2018-12-01 12:27:35","2018-12-01 12:27:35","Type 'Observable<any[] | Observable<any[]>>' is not assignable to type 'Observable<any[]>'","<angular><rxjs><rxjs6><angular7><angular-ngselect>","1","1","1","","","CC BY-SA 4.0"
"53400784","1","53495048","","2018-11-20 20:09:49","","0","86","<p><strong>Lets consider following streams:</strong></p>

<pre><code>Stream1: 1  2  3  4  5  6  7  8  9                
Stream2: abc  d       fg   h
</code></pre>

<p><strong>Output I would like to get with combining these streams:</strong></p>

<pre><code>[1, a]
[2, b]
[3, c]
[4, d]
[5, d]
[6, f]
[7, g]
[8, h]
[9, h]
</code></pre>

<p><strong>Sample Code Idea:</strong> <a href=""https://stackblitz.com/edit/rxjs-zip-with-latest-form"" rel=""nofollow noreferrer"">StackBlitz Editor Link</a></p>

<pre><code>const input$ = fromEvent(document, 'keydown')
  .pipe(
    map((event: KeyboardEvent) =&gt; event.keyCode)
  );
const source$ = interval(500).pipe(s$ =&gt; zip(s$, input$))
source$.subscribe(x =&gt; console.log(x));
</code></pre>

<p>So this is something like operators <code>zip()</code> and/or <code>withLatestForm()</code>, but I can't come up with solution</p>

<ul>
<li><em>Main idea is that I have interval of 500ms and on every tick I want to zip it with Keyboard Input Observable, which works how I would like, but as long I am not emitting Keyboard Input Observable everything stops. <strong>I want to keep emitting interval ticks, but if keyboard events stop then take the latest value</em></strong></li>
</ul>
","8578281","","8578281","","2018-11-21 05:52:18","2018-11-27 07:54:49","ZipWithLatestForm *Wanted Operator* or Workaround","<javascript><typescript><rxjs><reactive-programming><rxjs6>","3","5","","","","CC BY-SA 4.0"
"53408251","1","","","2018-11-21 08:49:50","","1","4160","<pre><code>enter code here


    getHospital(term: string = null): Observable&lt;Hospitals[]&gt; {
    let items = this.getHospitals1();
    if (term) {
      items = items.filter(x =&gt; x.name.toLocaleLowerCase().indexOf(term.toLocaleLowerCase()) &gt; -1);

    }
    return items.pipe(delay(500));;
  }



getHospitals1() : Observable&lt;Hospitals[]&gt;{

     return this.http.get&lt;Hospitals[]&gt;('https://my-json-server.typicode.com/monsterbrain/FakeJsonServer/hospitals')

   }
</code></pre>

<p><strong>Here an error occured when i add filter</strong> 
It is code for  dropdownlist using ng-select .it is based on text based seraching
here iam using angular7 and rxjs 6</p>
","8519297","","310726","","2018-11-22 09:50:57","2018-11-22 09:50:57","Property 'filter' does not exist on type 'Observable<>","<angular><rxjs><angular6><rxjs6><angular-ngselect>","1","0","","","","CC BY-SA 4.0"
"53412899","1","","","2018-11-21 13:16:09","","1","165","<p>The problem:<br>
external breadcrumb implementation forces to use such construct for routes:
</p>

<pre class=""lang-js prettyprint-override""><code>export const routes = {
    path: 'xx',
    component: xxComponent,
    data: {
      title: 'someTitle' //&lt;-- breadcrumb requirement
    },
}
</code></pre>

<p>current project has something like:</p>

<pre class=""lang-js prettyprint-override""><code>export const routes = {
    path: 'xx',
    component: xxComponent,
    data: {
      options: {title: 'some.title'} //&lt;-- current project, will be translated.
    },
}
</code></pre>

<p>the data from <code>options</code>will be translated then.</p>

<p>since the breadcrumb cannot translate, and needs another <code>data</code> structure, it would be nice, to set the <code>data.title = translate(data.options.title)</code> dynamically on <strong>every</strong> route call (full routes tree, since breadcrumb traverse it)  </p>

<p>the endresult, should be then:</p>

<pre class=""lang-js prettyprint-override""><code>export const routes = {
    path: 'xx',
    component: xxComponent,
    data: {
      title: 'translatedSomeTitle' //&lt;--should be dynamically added
      options: {title: 'some.title'}
    },
}
</code></pre>

<p>How to write such interceptor?<br>
Is there a better way to solve the problem?  </p>

<p>One solution could be a resolver <code>... data: {title: TitleResolver, ...</code> , but i dont want to write resolver on every route definition, and probably later remove, if breadcrumb will be improved.</p>
","2519073","","","","","2018-11-21 13:16:09","Angular router: how to manupulate every route data in runtime / dynamically?","<angular><angular-router><angular2-observables><rxjs6><angular-observable>","0","2","","","","CC BY-SA 4.0"
"53415802","1","53416105","","2018-11-21 15:51:41","","0","304","<p>I have a list of objects created dynamically by the user. Each object has a <code>click$</code> observable, I want to merge all this <code>click$</code> streams in one stream.</p>

<p>I've tried the <code>merge</code> static operator from <code>rxjs</code> import. With the direct references to the stream:</p>

<pre><code>sub = merge(list[0].click$, list[1].click$)
    .subscribe(e =&gt; { 
       console.log('My click event', e); 
    })
</code></pre>

<p>all goes as expected.</p>

<p>But when I use an array of <code>click$</code> in the subscribe next call I received an <code>Observable</code> object and not my click event.</p>

<pre><code>const streams= [];
list.forEach(o =&gt; { streams.push(o.click$); });

sub = merge(streams).subscribe(e =&gt; {
  console.log(e); // e is an observable ???
});
</code></pre>

<p>Why? What am I doing wrong?</p>

<p>Here a similar implementation with the same error: <a href=""https://stackblitz.com/edit/typescript-ohq6rx?file=index.ts&amp;devtoolsheight=100"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-ohq6rx?file=index.ts&amp;devtoolsheight=100</a></p>
","10529476","","","","","2018-11-21 16:13:52","RxJs6 - Static merge an array of observables","<javascript><reactive-programming><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53447267","1","53447610","","2018-11-23 13:05:47","","1","249","<p>From the following code:</p>

<pre><code>const parent$ = interval(2000).pipe(
  map(x =&gt; 'parent' + x),
  tap(_ =&gt; console.log('click$'))
);

const child$ = parent$.pipe(map(x =&gt; x + ' from child 1'));
const child2$ = parent$.pipe(map(x =&gt; x + ' from child 2'));

child$.subscribe((v) =&gt; console.log(v));
child2$.subscribe((v) =&gt; console.log(v));
</code></pre>

<p>I expected this output:</p>

<pre><code>click$
parent0 from child 1
parent0 from child 2
...
</code></pre>

<p>Instead the correct output is:</p>

<pre><code>click$
parent0 from child 1
click$
parent0 from child 2
...
</code></pre>

<p>Why click$ tap emits twice?</p>

<p>Implementation: <a href=""https://stackblitz.com/edit/rxjs-gpxoud?devtoolsheight=60"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-gpxoud?devtoolsheight=60</a></p>
","10529476","","4095444","","2018-11-23 13:45:53","2018-11-23 13:45:53","Tap operator - Why an Observable expanded by other 2 observables trigger tap 2 times instead of 1?","<javascript><reactive-programming><rxjs6>","2","0","","","","CC BY-SA 4.0"
"53459307","1","53459421","","2018-11-24 14:45:44","","1","40","<p>Here is a product Service response.</p>

<pre><code>productServiceResponse = [
  {productOrderId:108898,productStatus:""C"",productId:'4'},
  {productOrderId:108899,productStatus:""P"",productId:'2'},
];
</code></pre>

<p>by using const value  currentProductStatus = ""C"";</p>

<p>In product Service response ,i need to find the current product and taken the product by using above constant value and taken the product id.</p>

<p>So here i did that .Here i have did the index of the current product instead of that need it in dynamicllay find out from the collection .</p>

<pre><code>this.productServiceResponse[0].productStatus
</code></pre>

<p>// check the current product</p>

<pre><code>  const ProductCode =
            this.productServiceResponse[0].productStatus ===
            this.currentProductStatus
              ? this.productServiceResponse[0].productId.toString()
              : null;
</code></pre>

<p>once get the current productId.</p>

<p>i have check it in another collection.</p>

<pre><code>      productTypes =[
    {id: ""1"", name: ""Laptop""},
    {id: ""2"", name: ""Mobile""},
    {id: ""3"", name: ""headphone""},
    {id: ""4"", name: ""Cameras""}
      ];
</code></pre>

<p>from the product types collection , i have match the product id from the above result.</p>

<pre><code>   this.currentProduct = this.productTypes.find(product=&gt;product.id ===ProductCode).name;
</code></pre>

<p>final o/p becomes cameras.</p>

<p>I have got the o/p :but i need this query in single line filteration instead of two variables.</p>

<p>can any one refactor this.</p>

<p>Demo:<a href=""https://stackblitz.com/edit/angular-qjekuz"" rel=""nofollow noreferrer"">filter</a></p>
","4031891","","4031891","","2018-11-24 14:53:51","2018-11-24 15:20:36","How to do a two different array results manipulation in angular6","<angular><typescript><rxjs><angular6><rxjs6>","1","3","","","","CC BY-SA 4.0"
"53478229","1","53479305","","2018-11-26 09:36:57","","1","1525","<p>I'm a newbie to <strong>Angular-7</strong>, <strong>RxJS-6</strong> and <strong>Visual Studio Code</strong> and I'm having difficulty debugging an Observable that is being returned to a subscriber with the result that I have a runtime ""TypeError"" being raised by the subscriber. From research, it would appear that I'm not alone with tricky problems like this. Can you either suggest how I can determine what the subscriber is ""observing"" or can you spot the error in my code below?</p>

<p><strong>In Detail</strong></p>

<p>I'm writing a very simple proof of concept using Visual Studio Code and the Angular-7 CLI to retrieve the current system date/time from a server using angular's <code>httpclient</code> and display it.</p>

<p>Refer to the method <em>instrument.service.ts::getSystemTimeDate()</em> below. The HTTP layer is fine in that the JSON response is obtained ...</p>

<pre><code>{
  ""SystemDateTime"": ""2018-11-26T08:54:06.894Z""
}
</code></pre>

<p>Within the <code>map</code> operator, this response is first converted to an object of type <code>SystemDateTimeResponse</code> and then to a <code>Date</code> and the method should return an <code>Observable&lt;Date&gt;</code> to any subscribers. What I am having trouble with is the component's subscription to <code>Observable&lt;Date&gt;</code>. At runtime, this subscriber in the method <code>onTimeDateBtnClick()</code> throws an error: </p>

<pre><code>ERROR
TypeError: You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
message: ""You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.""
stack: ""TypeError: You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
    at subscribeTo (http://localhost:4200/vendor.js:75870:15)
    at subscribeToResult (http://localhost:4200/vendor.js:76027:76)
    at MergeMapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/mergeMap.js.MergeMapSubscriber._innerSub (http://localhost:4200/vendor.js:70784:90)
    at MergeMapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/mergeMap.js.MergeMapSubscriber._tryNext (http://localhost:4200/vendor.js:70778:14)
    at MergeMapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/mergeMap.js.MergeMapSubscriber._next (http://localhost:4200/vendor.js:70761:18)
    at MergeMapSubscriber.push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next (http://localhost:4200/vendor.js:65218:18)
    at TapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/tap.js.TapSubscriber._next (http://localhost:4200/vendor.js:73228:26)
    at TapSubscriber.push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next (http://localhost:4200/vendor.js:65218:18)
    at TakeSubscriber.push../node_modules/rxjs/_esm5/internal/operators/take.js.TakeSubscriber._next (http://localhost:4200/vendor.js:72950:30)
    at TakeSubscriber.push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next (http://localhost:4200/vendor.js:65218:18)""
__proto__: Error {constructor: , name: ""TypeError"", message: """", …}
constructor: function TypeError() { … }
message: """"
name: ""TypeError""
toString: function toString() { … }
__proto__: Object {constructor: , name: ""Error"", message: """", …}
</code></pre>

<p>I believe that I am not properly returning an <em>Observable</em> and may be screwing up my use of the map operator. What am I missing?</p>

<hr>

<p><strong>The Code</strong></p>

<p>The software references of this snippet include:</p>

<p><strong>timedate.component.html</strong>: contains the simple template of</p>

<pre><code>&lt;p&gt;
  Last time I checked, it was : {{today | date:'medium'}}
&lt;/p&gt;
&lt;button mat-button (click)=""onTimedateBtnClick()""&gt;Update&lt;/button&gt;
</code></pre>

<p><strong>timedate.component.ts</strong>: contains the display property definition of <code>today</code> and the event handler <code>onTimedateBtnClick()</code> which uses a data service to manage the HTTP request/response, retrieving the current date/time from a server.</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { InstrumentService } from '../instrument.service';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-timedate',
  templateUrl: './timedate.component.html',
  styleUrls: ['./timedate.component.css']
})
export class TimedateComponent implements OnInit {

  /** Display property */
  today: Date;

  /**
   * Constructor
   * @param - data service
   */
  constructor(private dataService: InstrumentService) {
  }

  ngOnInit() {
    this.today = new Date();  /// initialise with client's date/time
  }

  /**
   *  User event handler requesting system time/date from the server
   */
  onTimedateBtnClick() {
    const http$: Observable&lt;Date&gt; = this.dataService.getSystemTimeDate();

    http$.subscribe(
      res =&gt; this.today = res,
    );
  }
}
</code></pre>

<p><strong>instrument.service.ts</strong>: contains the <code>getSystemTimeDate()</code> method which returns an <code>Observable&lt;Date&gt;</code>. Again, I've simplified the code (although it still fails) and exaggerated the <em>map</em> in order to better see what I'm doing.</p>

<pre><code>import { Injectable } from '@angular/core';
import { Observable, of } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';

// App imports
import { SystemDateTimeResponse, SystemDateTimeUrl } from './instrument.service.httpdtos';


@Injectable({
  providedIn: 'root'
 })
export class InstrumentService {

  constructor(private http: HttpClient) { }

  /**
   * Return the server date and time
   */
  public getSystemTimeDate(): Observable&lt;Date&gt; {
    // Convert the server response object into an observable date
    const responseObject: Observable&lt;Date&gt; =
    this.http.get&lt;SystemDateTimeResponse&gt;(SystemDateTimeUrl.Url).
      pipe(
        map(jsonResponse =&gt; {
          const newDto = new SystemDateTimeResponse(jsonResponse.SystemDateTime);
          const d = new Date(newDto.SystemDateTime);
          return d;
        }),
      );

    return responseObject;
  }
}
</code></pre>

<p><strong>instrument.service.httpdtos.ts</strong> : Contains data transfer object definitions.</p>

<pre><code>/** URL - Instrument system date/time */
export class SystemDateTimeUrl {
  public static readonly HttpVerb = 'GET';
  public static readonly Url = 'api/instrument/systemdatetime';
  public static readonly Summary = 'Query the instrument current date/time';
}

/** Response DTO */
export class SystemDateTimeResponse {
  constructor(
    public SystemDateTime: string     // In UTC format
  ) { }
}
</code></pre>
","8329690","","7109869","","2018-12-06 18:50:11","2018-12-06 18:50:11","How can I debug the object type returned to the subscriber of an Angular observable?","<angular><typescript><angular7><angular-httpclient><rxjs6>","1","8","","","","CC BY-SA 4.0"
"53507699","1","53507869","","2018-11-27 20:34:22","","6","2618","<p>I want to send request using this code (i've tried forkJoin too) with a delay between calls:</p>

<pre><code>duplicateElement(id: string): Observable&lt;any&gt; {
    return this.http.get({ routeName: 'route_name', params: { id } });
}

duplicateElements(ids: string[]): Observable&lt;any&gt; {
    return from(ids)
    .pipe(
        mergeMap(id =&gt; this.duplicateElement(id).pipe(delay(1000))
    ));
}
</code></pre>

<p>but .pipe(delay(1000) is not working how I expect: send each http request after 1000 mls.</p>
","4195071","","4195071","","2018-11-27 20:42:58","2018-12-01 16:57:06","Rxjs angular 6/7 mergeMap delay http request","<javascript><angular><rxjs6>","2","2","1","","","CC BY-SA 4.0"
"53508217","1","53508311","","2018-11-27 21:13:22","","1","5650","<p>I am trying to use timeout in one of my http post. I get error as </p>

<pre><code>ERROR TypeError: this._http.post(...).timeout is not a function
</code></pre>

<p>This is how the code looks like: </p>

<pre><code>return this._http.post(this.meetingProcessURL, body )
  .timeout(5000)
  .catch( err =&gt; { 
    return Observable.throw(""Timeout has occurred"");
  })

    .pipe(catchError(this.handleError));
  }
</code></pre>

<p>I am using angular 6 and rxjs 6.0.0</p>

<pre><code>""@angular/core"": ""^6.1.0"",
""rxjs"": ""^6.0.0"",
""rxjs-compat"": ""^6.0.0"",
</code></pre>

<p>What am I doing wrong?</p>

<p>ref: <a href=""https://stackoverflow.com/questions/38990350/angular-2-rxjs-timeout-callback"">Angular 2 rxjs timeout callback</a></p>

<p><a href=""https://i.stack.imgur.com/QX4sl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QX4sl.png"" alt=""enter image description here""></a></p>
","7369926","","","","","2020-06-01 18:06:51","Angular 6 rxjs timeout - timeout is not a function","<angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53520636","1","53521265","","2018-11-28 13:32:22","","0","108","<p>I have a scenario where I have to get results of 2 http calls, and pass an array of their combined results to a class I am instantiating. Here is the code:</p>

<pre><code>export class VideoListComponent implements OnInit {
  @ViewChild(MatPaginator) paginator: MatPaginator;
  @ViewChild(MatSort) sort: MatSort;
  dataSource: VideoListDataSource;
  constructor( private http: HttpProxyService, private videoService: VideoService ) { }
  /** Columns displayed in the table. Columns IDs can be added, removed, or reordered. */
  displayedColumns = ['Video Name', 'Author', 'Category Name', 'Highest Quality Format', 'Release Date', 'Options'];

  ngOnInit() {
    let observables = [this.videoService.getInitialData('movie-authors'), this.videoService.getInitialData('movie-categories')];
    forkJoin(observables).subscribe(res =&gt; {
      this.dataSource = new VideoListDataSource(this.paginator, this.sort, res);
      console.log(this.dataSource);
    })
  }

}
</code></pre>

<p>Now on the console.log I can see the value within <code>this.dataSource</code> as required, but when using it on the html template, it says that this.dataSource is undefined.</p>

<p>Any help? Am I missing something here?</p>

<p><strong>Edit with HTML markup</strong></p>

<pre><code>&lt;div class=""mat-elevation-z8""&gt;
  &lt;table mat-table class=""full-width-table"" [dataSource]=""dataSource"" matSort aria-label=""Elements""&gt;
    &lt;!-- Id Column --&gt;
    &lt;ng-container matColumnDef=""id""&gt;
      &lt;th mat-header-cell *matHeaderCellDef mat-sort-header&gt;Id&lt;/th&gt;
      &lt;td mat-cell *matCellDef=""let row""&gt;{{row.id}}&lt;/td&gt;
    &lt;/ng-container&gt;

    &lt;!-- Name Column --&gt;
    &lt;ng-container matColumnDef=""name""&gt;
      &lt;th mat-header-cell *matHeaderCellDef mat-sort-header&gt;Name&lt;/th&gt;
      &lt;td mat-cell *matCellDef=""let row""&gt;{{row.name}}&lt;/td&gt;
    &lt;/ng-container&gt;

    &lt;tr mat-header-row *matHeaderRowDef=""displayedColumns""&gt;&lt;/tr&gt;
    &lt;tr mat-row *matRowDef=""let row; columns: displayedColumns;""&gt;&lt;/tr&gt;
  &lt;/table&gt;

  &lt;mat-paginator #paginator
      [length]=""dataSource.data.length""
      [pageIndex]=""0""
      [pageSize]=""50""
      [pageSizeOptions]=""[25, 50, 100, 250]""&gt;
  &lt;/mat-paginator&gt;
&lt;/div&gt;
</code></pre>
","1504265","","1504265","","2018-11-28 13:37:29","2018-11-28 14:05:04","How to persist value from forkJoin","<javascript><angular><typescript><rxjs6>","1","6","","","","CC BY-SA 4.0"
"53524737","1","","","2018-11-28 17:10:54","","0","38","<p>I have 2 components and a service which provides an observable. Both components are lazy loaded with there modules.</p>

<p>service: </p>

<pre><code>this.filteredBookings$ = this._filteredBookings
  .asObservable()
  .pipe(
    tap(s =&gt; {
      console.log(s, 'activity');
      return s;
    })
  );
</code></pre>

<p>I have added tap here to see any subscription activity.</p>

<p>component 1:</p>

<pre><code>this.bookings$ = this._bookingService.filteredBookings$;

this.sum$ = this.bookings$.pipe(
  map(bookings =&gt; bookings
    .map(booking =&gt; booking.value)
    .reduce((total, value) =&gt; total + value, 0)
  )
);
</code></pre>

<p>component 1 template:</p>

<pre><code>&lt;ion-list *ngIf=""bookings$ | async; let bookings; else loading""&gt;
    ...
    &lt;ion-label slot=""end"" text-right&gt;
        &lt;ion-text color=""medium""&gt;&lt;b&gt;{{ sum$ | async }}&lt;/b&gt;&lt;/ion-text&gt;
    &lt;/ion-label&gt;
&lt;/ion-list&gt;
...
</code></pre>

<p>component 2:</p>

<pre><code>this.bookings$ = this._bookingService.filteredBookings$;
</code></pre>

<p>I want to prevent unecessary subscriptions. When I understand it correctly the two observables in component 1 subscribe into observable provided by service. And also the async pipes in component 1 template subscribe into this observable. So there are 4 subscriptions / 3 unecessary ones?</p>

<p>To prevent the unecessary ones I found share(). </p>

<pre><code>this.filteredBookings$ = this._filteredBookings
  .asObservable()
  .pipe(
    share()
  );
</code></pre>

<p>I think don't need sharereplay because _filteredBookings is an BehaviorSubject which always caches the last value.</p>

<p>The docs say: </p>

<p>""As long as there is at least one Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will unsubscribe from the source Observable.""</p>

<p>So when I switch route and load component 2 I fear that observable in service is canceled? Because component 1 observables unsubscribe (async pipe handles unsubscribe?) before component 2 can subscribe?</p>

<p>How can I handle that?</p>
","5657968","","","","","2018-11-28 18:41:17","What's the correct way and place to share observable data","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53544592","1","","","2018-11-29 17:31:42","","0","28","<p>In analogous to <a href=""https://stackoverflow.com/questions/52223727/angular-should-i-subscribe-to-http-get-each-time-i-need-to-update/52223937#comment93954550_52224013"">this thread</a>, i am also implementing in similar fashion.
My idea here is to have a centralized DB json data cached, so that many components can refer to it.</p>

<p>However, In my case, i have a http data service; which actually picks JSON data from local json-server DB as shown below:</p>

<pre><code>export class ProductDataService implements OnInit {

  constructor(private httpClientService: HttpClient) {
    this.productDataURL = environment.production ? ""http://Server"" : ""http://localhost:3000/products"";
    this.productList = this.httpClientService.get&lt;IProduct[]&gt;(this.productDataURL);
  }
}
</code></pre>

<p>This data service is being used in many components as well as for async pipes in view. Below are few among many consumers:</p>

<p>Component 1:</p>

<pre><code>    export class DetailsProductsComponent implements OnInit {
         constructor(private activatedRoute: ActivatedRoute, private productService: ProductDataService) {     
            this.productService.productList.subscribe(item =&gt; 
              {
                this.selectedProduct = item.find(value =&gt; value.productCode == this.productId);
              });    
          }
}
</code></pre>

<p>Component 2:</p>

<pre><code>export class ProductListComponent implements OnInit {

  _filterString: string = """";

  constructor(private productDataService: ProductDataService) {
    this._filterString = """";    
    this.productDataService.productList.subscribe(item =&gt; this.filteredProducts = this.masterProductList = item);
  }
}
</code></pre>

<p>As you can see above, i have just listed 2 components which are using the data service for its own tasks. There are several more components as such. </p>

<p>Kindly please guide me for below:</p>

<ol>
<li>Is this the right way to do the data access? if not, please guide?</li>
<li>I noticed that, upon navigation to any of the components through UI clicks, a call is done to the subscribe or async pipes; which hits a call to Json-server DB. I can see the log in terminal window by json-server. So is it not poor performance? How to make it efficient?</li>
<li>Also this way, i am also trying to do an automatic update of the observable when the DB is updated. But it is not working. What i should do?</li>
</ol>

<p>Thanks </p>

<p><em>Libraries used: 
""rxjs"": ""~6.2.0"", 
""@angular/animations"": ""^6.1.10"",
""@angular/common"": ""^6.1.10"",
""@angular/compiler"": ""^6.1.10"",
""@angular/core"": ""^6.1.10"",
""@angular/forms"": ""^6.1.10"",
""@angular/http"": ""^6.1.10"",
""@angular/platform-browser"": ""^6.1.10"",
""@angular/platform-browser-dynamic"": ""^6.1.10"",
""@angular/router"": ""^6.1.10""</em></p>
","785375","","","","","2018-11-29 17:31:42","Multiple Observable subscription hits HTTP DB","<angular><observable><rxjs6>","0","4","","","","CC BY-SA 4.0"
"53545379","1","","","2018-11-29 18:26:03","","0","2742","<p>I have the following code which works wonderfully.  Unfortunately, each Observable is a heavy database query and they can't be executed in a parallel fashion.  </p>

<pre><code>import { Observable } from 'rxjs';

...

public search(criteria: SearchCriteria): void {
  this.searchAllTables(criteria).subscribe((responses: Array&lt;JsonResponse&gt;) =&gt; {
    this.progressDialogService.notifyComplete();
  });
}

private searchAllTables(criteria: SearchCriteria): Observable&lt;Array&lt;JsonResponse&gt;&gt; {
  return Observable.forkJoin(
    this.heavyDatabaseQuery1(criteria),
    this.heavyDatabaseQuery2(criteria),
    this.heavyDatabaseQuery3(criteria)
  );
}

private heavyDatabaseQuery1(criteria: SearchCriteria): Observable&lt;JsonResponse&gt; {
  return Observable.create(observer =&gt; {
    this.dbService.query1(criteria).subscribe((response: JsonResponse) =&gt; {
      observer.next(response);
      observer.complete();
    }, error =&gt; {
      observer.error(error);
    });
  });
}

... 
</code></pre>

<p>I'm having a very difficult time figuring out how to execute the heavy database queries sequentially.  I've tried so many things (combinations of pipe, concat, flatMap, etc.) but none of them compile and I'm not sure it's worth detailing them all.  Is this enough information for anyone to assist me in sequential execution of these methods?  I would really appreciate it.  </p>

<p>All I'm looking for is a means of replacing forkJoin with a function that executes sequentially rather than parallel.  I need to notify another component when these queries are complete, and I'll need to do a bit of processing against the resulting array of json responses.</p>
","2514739","","","","","2018-11-29 18:26:03","Angular 6 forkJoin vs concat","<angular><concat><rxjs6><fork-join>","0","3","","","","CC BY-SA 4.0"
"53546601","1","","","2018-11-29 19:55:27","","2","338","<p>I was (wrongly) under the impression that the scan operator would always return a new object on each pass. I've discovered recently that is not the case.</p>

<p>I've forked the example from <a href=""https://www.learnrxjs.io/operators/transformation/scan.html"" rel=""nofollow noreferrer"">learnrxjs.io</a> to demonstrate what I mean <a href=""https://stackblitz.com/edit/typescript-vwlv96?file=index.ts"" rel=""nofollow noreferrer"">here</a>. </p>

<p>Taking a look at the code:</p>

<pre><code>const subject = new Rx.Subject();

const example = subject.scan((acc, curr) =&gt; {
    console.log('Accumulator', acc);
    return Object.assign({}, acc, curr)
}, {});

//log accumulated values
const subscribe = example.subscribe(val =&gt; {
    val.mutating = 'test'
    console.log('Accumulated object:', val)
});

//next values into subject, adding properties to object
subject.next({name: 'Joe'}); 
// {name: 'Joe'}

subject.next({age: 30}); 
// {name: 'Joe', age: 30}

subject.next({favoriteLanguage: 'JavaScript'}); 
// {name: 'Joe', age: 30, favoriteLanguage: 'JavaScript'}
</code></pre>

<p>I am mutating the <code>val</code> passed down the stream in the <code>subscription</code> and logging out the value of the <code>accumulator</code> in the <code>scan</code> accumulator function.</p>

<p>Looking at the console, it shows that the accumulator contains <code>mutating:""test""</code> after the first and subsequent passes:</p>

<p><a href=""https://i.stack.imgur.com/DK04k.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DK04k.png"" alt=""enter image description here""></a></p>

<p>Unless I am mistaken this demonstrates that I can mutate stream objects anywhere down the line up to and in the subscription. Which, I suppose does not surprise me as it is an object reference. But, I thought that the <code>scan</code> operator would always return a new object preventing its internal accumulator to be mutated...</p>

<p>First thought I have is mapping a new object like this:</p>

<pre><code>scan((acc, curr) =&gt; Object.assign({}, acc, curr), {}),
map(data=&gt;Object.assign({}, data))
</code></pre>

<p>But that seems odd to me. </p>

<p>Is the behaviour I am demonstrating expected or am I not understanding how this all works? How can I prevent the accumulator from being mutated? </p>

<p>Thank-you</p>
","2275792","","","","","2018-11-29 21:57:29","rxjs: scan accumulator mutation","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"53560111","1","","","2018-11-30 15:11:18","","0","40","<p>Let's say I have two REST services : </p>

<pre><code>todo.service.ts
user.service.ts
</code></pre>

<p>Here is the definition of each objects :</p>

<pre><code>todo: userId, title, id, completed
user: id, name, email, etc
</code></pre>

<p>Both my services are returning me Observable with collections of the definition.</p>

<pre><code>users: Observable&lt;User[]&gt;
todos: Observable&lt;Todo[]&gt;
</code></pre>

<p>The final result is to display something like this : </p>

<pre><code>todo.title by user.name
</code></pre>

<p>What is the best way to do it ? Is it to map them to one single object like :</p>

<pre><code>todo: id, title, completed, user { id, name, email, etc }
</code></pre>

<p>Or is there a better way to archieve that ?</p>

<p>Thanks !</p>
","10218623","","10218623","","2018-11-30 15:28:28","2018-11-30 15:35:11","Observable json join on id","<javascript><observable><rxjs6>","1","2","","","","CC BY-SA 4.0"
"53560652","1","53560996","","2018-11-30 15:43:57","","11","22926","<p>I've been looking for a solution all over the web, but couldn't find anything that fits my user case. I'm using the MEAN stack (Angular 6) and I have a registration form. I'm looking for a way to execute multiple HTTP calls to the API and each one is dependent on the returned result from the previous one. I need something that looks like this:  </p>

<pre><code>firstPOSTCallToAPI('url', data).pipe(
    result1 =&gt; secondPOSTCallToAPI('url', result1)
    result2 =&gt; thirdPOSTCallToAPI('url', result2)
    result3 =&gt; fourthPOSTCallToAPI('url', result3)
    ....
).subscribe(
    success =&gt; { /* display success msg */ },
    errorData =&gt; { /* display error msg */ }
);
</code></pre>

<p>What combination of RxJS operators do I need to use to achieve this? One possible solution would be to nest multiple subscriptions, but I want to avoid that and do it better with RxJS. Also need to think about error handling.</p>
","3947018","","1033581","","2019-12-07 16:21:14","2021-03-04 09:49:29","How to make a sequence of http requests in Angular 6 using RxJS","<angular><typescript><rxjs><angular-httpclient><rxjs6>","6","3","7","","","CC BY-SA 4.0"
"53562113","1","","","2018-11-30 17:19:30","","0","75","<p>I am trying to migrate some code from Angular 5 to Angular 7. I tried the official update guide, but not everything was migrated. So I tried it manually, but I can not get it to work.</p>

<p>This is  Angular 5 Code </p>

<pre class=""lang-js prettyprint-override""><code>getNodes(): Observable &lt; Node[] &gt; {
   return Observable.create(obs =&gt; {
     ros.getNodes(data =&gt; {
      obs.next(data);
      obs.complete();
     });
   }).flatMap(data =&gt; {
     return Observable.forkJoin(data.map(name =&gt; Observable.create(obs =&gt; {
       const detailClient = new ROSLIB.Service({
         ros: ros,
         name: '/rosapi/node_details',
         serviceType: 'rosapi/NodeDetails'
       });
       const request = new ROSLIB.ServiceRequest({ node: name });
       detailClient.callService(request, data2 =&gt; {
         obs.next({ name, subscribing: data2.subscribing });
         obs.complete();
       });
     })));
   });
 }
 loadData(): void {
   Observable.forkJoin(this.getNodes()).subscribe(([nodes]) =&gt; {
     //this.data.nodes = nodes;
     console.log(nodes);
   });
 }
</code></pre>

<p>And the output of console.log is the following and the new Angular 7 code should look like the same </p>

<pre class=""lang-js prettyprint-override""><code>[
  {
    ""name"": ""/mission_controller""
  },
  {
    ""name"": ""/mavros""
  },
  {
    ""name"": ""/pose_analyser""
  }
]
</code></pre>

<p>This is what I tried, but it gives me the error ""Property 'pipe' does not exist on type '{}'""</p>

<pre class=""lang-js prettyprint-override""><code>getNodes(): Observable&lt;Node[]&gt; {
  return Observable.create(obs =&gt; {
    ros.getNodes(data =&gt; {
      obs.next(data);
      obs.complete();
    });
  }).pipe(mergeMap( data =&gt; {
    return forkJoin(data.pipe(map(name =&gt; Observable.create(obs =&gt; {
      const detailClient = new ROSLIB.Service({
        ros: ros,
        name: '/rosapi/node_details',
        serviceType: 'rosapi/NodeDetails'
      });
      const request = new ROSLIB.ServiceRequest({ node: name });
      detailClient.callService(request, data2 =&gt; {
        obs.next({ name });
        obs.complete();
      });
    }))));
  }));
}
loadNodes(): void {
  forkJoin(this.getNodes()).subscribe(([nodes]) =&gt; {
    console.log(nodes);      
  });
}
</code></pre>

<p>I hope somebody can help me</p>

<p>Best regards </p>

<p>newsub7</p>
","10728632","","7109869","","2018-12-08 19:07:35","2018-12-08 19:07:35","Problem migrating code from Angular 5 to Angular 7","<angular><rxjs5><angular7><rxjs6>","0","8","","","","CC BY-SA 4.0"
"53564351","1","","","2018-11-30 20:19:42","","1","388","<p>In the <code>saveExpense()</code> method, when passing error handling <code>catchError (this.handleError&lt;any&gt;('Add Expense', []))</code>, this method is highlighted and the error is displayed: <strong><code>Argument type (error:any)=&gt;Observable&lt;any&gt; is not assignable to parameter type (err:any, caught:Observable&lt;T&gt;)=&gt;never</code>. How to solve?</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    saveExpense(userid, oExpense) {
        const httpOptions = {
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                'Authorization': `${this.jwtToken}`
            })
        };
    return this.http.post(`http://localhost:5555/api/expense/${userid}`, JSON.stringify(oExpense), httpOptions).pipe(
        tap(
            (response: ServerMessage) =&gt; console.log(response)
        ),
        catchError(this.handleError('Add Expense', []))
    );
}

    private handleError&lt;T&gt;(operation = 'operation', result?: T) {
        return (error: any): Observable&lt;T&gt; =&gt; {
            console.error(error);
            console.log(`${operation} failed: ${error.message}`);
            return of(result as T);
        };
    }</code></pre>
</div>
</div>
</p>
","10717010","","10717010","","2018-11-30 21:41:46","2018-11-30 22:57:48","How to fix (error:any)=>Observable<any> is not assignable?","<javascript><angular><typescript><error-handling><rxjs6>","2","3","","","","CC BY-SA 4.0"
"53586234","1","","","2018-12-03 01:11:26","","0","109","<p><code>getComments</code> is async function. When it returns an error, I want to handle it through <code>catchError</code>. But I always execute <code>map()</code> and never execute <code>catchError</code>.</p>

<p>Why and How to fix this?</p>

<pre><code>from(getComments(action.payload.url)).pipe(
  map((comments: IComments[]) =&gt; commentsActions.fetch.done({ params: action.payload.url, result: { comments } })),
  // TODO: 以下ではError handlingができない
  catchError(error =&gt; of(commentsActions.fetch.failed({ params: action.payload.url, error: { hasError: true } }))),
),
</code></pre>

<p>and</p>

<pre><code>export const getComments = async (url: string) =&gt; {
  return await fetch(url)
    .then(response =&gt; response.json())
    .then(comments =&gt; comments)
    .catch((e: string) =&gt; throwError(e));
}
</code></pre>

<p>Thanks in advance.</p>
","10217778","","","","","2018-12-03 02:44:56","Rxjs6: Can't handle error in async function","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"53589654","1","","","2018-12-03 08:00:33","","1","579","<p>Trying to call a list of apis obtained from first api call</p>

<pre><code>loadData() {
  this.http.get(this.firstApi).pipe(
    .map(response =&gt; response.ip)
        )
      .subscribe(ip =&gt; {
        console.log(ip);

        Observable.forkJoin(
          ip.map(
             g =&gt;
             this.http.get('http://'+ip+':port/api/status')
             .map(response =&gt; response.json())
           )
         ).subscribe(res =&gt; {
             //THIS WILL LOG GAME RESULTS SUCH AS HITS/PITCHES/STOLENBASES/RUNS...
             let i;
             res.forEach((item, index) =&gt; {
               i = index;
               console.log(res[i]);
             })
          })
   });
}
</code></pre>

<p>The issue is that <code>ip</code> is undefined. Any way to solve the issue.</p>

<p>Generally what I need is </p>

<p>Call an api -> returns list of object with ip key and other stuff (ip is relevant).
Call status api (returns a json object) in each of the ip obtained and push the result to an array.</p>
","2837567","","","","","2018-12-03 12:45:03","Angular dynamic api call","<angular><angular6><rxjs6>","2","3","","","","CC BY-SA 4.0"
"53628707","1","","","2018-12-05 09:10:39","","0","541","<p>Good morning, great jedi of the angular universe :) </p>

<p>I am trying to implement the following idea with Angular 7 and RxJS 6.
I have a REST API endpoint that streams data in chunks. As I receive one chunk of data, I would like to be able to put the request on hold (so that angular HttpClient won't be receiving the data at that time). When I finish proceeding the data, I would like to get another portion.
This endpoint might stream large data chunks and I don't want to fill the memory with those. Instead, I want to proceed chunks in pieces.</p>

<p>In my imagination, the dummy code would be something like that:</p>

<pre><code>const req = new HttpRequest(
    'POST',
    'localhost:9000',
    {},
    {
        reportProgress: true,
        responseType: 'json'
     });

const source = http.request(req)

const pause = new BehaviourSubject(false);

source
    .pipe(pauseStream(pause))
    .getSearchProductsStream.subscribe(dataChunk =&gt; { 
        pause.next(true);
        doOperations(dataChunk)
        pause.next(false);
})
</code></pre>

<p>Is there anything like that in Angular (some specific HttpClient settings) or RxJS (secret operators), that could potentially solve this problem?</p>

<p>With regards,
Angular padawan.</p>
","6761182","","7109869","","2018-12-11 17:37:24","2018-12-11 17:37:24","Angular 7: pause ongoing streaming request and continue when data chunk is proceeded","<angular><stream><rxjs><angular7><rxjs6>","0","3","1","","","CC BY-SA 4.0"
"53639445","1","","","2018-12-05 19:29:05","","1","1123","<p>I am trying to return a custom error from a data service in the event of and error. </p>

<pre><code>public getRoles(): Observable&lt;Array&lt;Role&gt; | CustomError&gt; {

    return this.http.get(this.urlService.getRoles)
        .pipe(
            map((res: any) =&gt; {
                    let roles = new Array&lt;Role&gt;();
                    res.Result.forEach(item =&gt; {
                        roles.push(new Role().fromItem(item));
                    });

                    return roles;
                }
            ),
            catchError(err =&gt; {
                let customError = new CustomError();
                customError.errorNumber = err.status;
                customError.message = err.message;
                return throwError(customError);
            })
        );
}
</code></pre>

<p>The code above acutally runs as i expect it should, but the text editor indicates the following error:</p>

<p>(TS) Type 'Observable&lt;{} | Role[]>' is not assignable to type 'ObservableRole[] | CustomError>'.</p>

<p>Type '{} | Role[]' is not assignable to type 'Role[] | CustomError'.</p>

<p>Type '{}' is not assignable to type 'Role[] | CustomError'.</p>

<p>Type '{}' is not assignable to type 'CustomError'.</p>

<p>Property 'errorNumber' is missing in type '{}'</p>

<p>Can anyone tell me what I need to do to resolve the problem?</p>

<p>It turns out that this is not the only place in the code where I am having an issue with catchError. I have a simple interceptor that will log http errors to the console. (I was experimenting on how to use interceptors).</p>

<pre><code>public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    console.log(`ErrorInterceptor - ${req.url}`);

    return next.handle(req)
        .pipe(catchError(err =&gt; {
            console.log(err);
            return throwError(err);
        }));
}
</code></pre>

<p>With this block of code I am getting a very similar set of messages. Am I using catchError and throwError correctly?</p>
","10751253","","7109869","","2018-12-06 06:36:16","2019-04-26 04:08:57","TypeScript 3.1.6 Angular 7 Rxjs6 Using catchError shows error in editor but the code runs correctly","<angular><angular7><rxjs6><typescript3.0>","1","6","","","","CC BY-SA 4.0"
"53640684","1","53640748","","2018-12-05 21:02:16","","0","41","<p>I have a service making http call and getting data back as Observable and i am assigning it to a variable in the component like follows</p>

<pre><code>this.usersResponse$ = this.dataSvc.getUsers(pageNumber);
</code></pre>

<p>On html i am doing the follows</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;div *ngIf=""usersResponse$ | async as userResponse; else loading""&gt;
    &lt;ng-container&gt;
        &lt;ul&gt;
            &lt;li *ngFor=""let user of userResponse.data"" (click)=""detail(user.id)""&gt;
                &lt;img [src]=""user.avatar"" alt=""""&gt;
                &lt;p&gt;{{ user.first_name }} {{ user.last_name }}&lt;/p&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/ng-container&gt;    
&lt;/div&gt;
&lt;ng-template #loading&gt;
    &lt;app-loading&gt;&lt;/app-loading&gt;
&lt;/ng-template&gt;</code></pre>
</div>
</div>
</p>

<p>What i want to achieve is how to get a granular control to show loader before http call then make http call get the data back and turn off the loader, so that the UI is jumpy.</p>

<p>I appreciate the help.</p>
","7226486","","","","","2018-12-05 21:07:27","Angular 4+ Granular control over http call to show / hide loader","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53674718","1","53701420","","2018-12-07 17:59:43","","1","1215","<p>I am using Angular 7 and latest RxJS and ngrx/store. I faced a problem with <code>debounceTime(0)</code>.  debounceTime is an @Input() property of <code>ui-input</code> component. Its default value is <code>0</code>. I want a possibility to use <code>debounceTime</code> for some inputs - for others - no. The input value I am getting from the store. Also, I have a validation service that should validate input values. I pass the input value to validation service through the selector. The problem is that in validation service I am getting previous values. Here is a simplified <strong>(updated)</strong> <a href=""https://stackblitz.com/edit/angular-q7m9fc?file=src%2Fapp%2Fvalidation.service.ts"" rel=""nofollow noreferrer"">example</a>. I have validation rule: input.length > 2. I want to get an error when the length is more than 2. But with debounceTime(0) I am getting a validation error in the console only when the length of the input is 4.</p>

<p>If I remove debounceTime - everything work as expected. I am getting a synchronous call: </p>

<p>How I can fix the problem? I didn't find any variants for applying debounceTime conditionally. Also, I think that something like this is not a good solution:</p>

<pre><code>ngOnInit() {
    if (this.debounceTime &gt; 0) {
      this._valueChanged
        .pipe(
          debounceTime(this.debounceTime),
        )
        .subscribe(value =&gt; this.inputted.emit(value));
    } else {
      this._valueChanged
        .subscribe(value =&gt; this.inputted.emit(value));
    }
  }
</code></pre>
","4219282","","4219282","","2018-12-07 19:37:35","2018-12-10 07:47:58","RxJS debounceTime(0) still postpones execution","<javascript><angular><rxjs6>","2","2","","","","CC BY-SA 4.0"
"53712345","1","53731708","","2018-12-10 19:27:41","","2","934","<p>I've got a service call that loads ten items onto the screen. When users click a ""View More"" button, I send another call to the service with different paging arguments. What's the best way to gracefully append the new array of items from the second call into the existing array emitted by the first call?</p>

<p>My example below technically works, but it resets the original observable, refreshing all items on the screen, rather than just adding the new ones. Thoughts? Could Subjects help with this?</p>

<pre><code>private onViewMoreClicked(): void {
    this.pageOffset += this.pageLimit;

    const moreItems$ = this.itemService.get(
        this.pageLimit,
        this.pageOffset
    );

    this.items$ = forkJoin(this.items$, moreItems$).pipe(
        map(([a, b]) =&gt; [...a, ...b])
    );
</code></pre>
","6757270","","","","","2018-12-11 20:16:47","How to append an Observable array to existing one consumed via Angular async pipes?","<angular><rxjs><rxjs5><rxjs6>","2","1","","","","CC BY-SA 4.0"
"53713589","1","","","2018-12-10 21:01:44","","0","58","<p>This problem just happened and began to happen like this, out of nowhere, apparently for no reason at all. It simply does not complete the request from the POST method call to webservice.</p>

<p>I honestly can not see any problems in the code, even though it was working normally just now.</p>

<p>The worst thing is that in the Chrome console does not show any error, only points that failed:</p>

<pre><code>polyfills.js:3 
XHR failed loading: OPTIONS ""http://MY-SERVER:5000/profiles/set-logged-profile"".

s @ polyfills.js:3
t.scheduleTask @ polyfills.js:3
onScheduleTask @ polyfills.js:3
t.scheduleTask @ polyfills.js:3
r.scheduleTask @ polyfills.js:3
r.scheduleMacroTask @ polyfills.js:3
(anonymous) @ polyfills.js:3
o.(anonymous function) @ polyfills.js:2
(anonymous) @ http.js:1630
Observable._trySubscribe @ Observable.js:43
Observable.subscribe @ Observable.js:29
(anonymous) @ subscribeTo.js:21
subscribeToResult @ subscribeToResult.js:11
MergeMapSubscriber._innerSub @ mergeMap.js:74
MergeMapSubscriber._tryNext @ mergeMap.js:68
MergeMapSubscriber._next @ mergeMap.js:51
Subscriber.next @ Subscriber.js:54
(anonymous) @ scalar.js:5
Observable._trySubscribe @ Observable.js:43
Observable.subscribe @ Observable.js:29
MergeMapOperator.call @ mergeMap.js:29
Observable.subscribe @ Observable.js:24
FilterOperator.call @ filter.js:15
Observable.subscribe @ Observable.js:24
MapOperator.call @ map.js:18
Observable.subscribe @ Observable.js:24
TakeUntilOperator.call @ takeUntil.js:17
Observable.subscribe @ Observable.js:24
webpackJsonp.620.HomePage.ionViewWillEnter @ home.ts:134
ViewController._lifecycle @ view-controller.js:486
ViewController._willEnter @ view-controller.js:384
NavControllerBase._willEnter @ nav-controller-base.js:780
(anonymous) @ nav-controller-base.js:673
t.invoke @ polyfills.js:3
onInvoke @ core.js:14191
t.invoke @ polyfills.js:3
r.run @ polyfills.js:3
NgZone.run @ core.js:14105
NavControllerBase._viewsWillLifecycles @ nav-controller-base.js:667
Animation._fireBeforeReadFunc @ animation.js:723
Animation._beforeAnimation @ animation.js:652
Animation._playDomInspect @ animation.js:346
requestAnimationFrame (async)
Platform.raf @ platform.js:538
(anonymous) @ animation.js:292
requestAnimationFrame (async)
Platform.raf @ platform.js:538
Animation.play @ animation.js:291
NavControllerBase._transitionStart @ nav-controller-base.js:605
(anonymous) @ nav-controller-base.js:533
t.invoke @ polyfills.js:3
onInvoke @ core.js:14191
t.invoke @ polyfills.js:3
r.run @ polyfills.js:3
(anonymous) @ polyfills.js:3
t.invokeTask @ polyfills.js:3
onInvokeTask @ core.js:14182
t.invokeTask @ polyfills.js:3
r.runTask @ polyfills.js:3
o @ polyfills.js:3
Promise.then (async)
r @ polyfills.js:3
t.scheduleTask @ polyfills.js:3
onScheduleTask @ polyfills.js:3
t.scheduleTask @ polyfills.js:3
r.scheduleTask @ polyfills.js:3
r.scheduleMicroTask @ polyfills.js:3
f @ polyfills.js:3
c @ polyfills.js:3
(anonymous) @ polyfills.js:3
Animation._didFinish @ animation.js:994
Animation._didFinishAll @ animation.js:981
onTransitionEnd @ animation.js:428
onTransitionEnd @ platform.js:610
</code></pre>

<p>I'm using RxJs 6+ with Angular 7+, below the code of my ""service"" that makes the POST request:</p>

<pre><code>  public sendPost(url: string, payload: any, showLoading: boolean = true) {
    if (this.isConnected) {
      this.loadingStatus(showLoading);
      let endPoint: string = this.setEndPoint(url);
      let headers: any = this.requestHeaders();
      console.log('ENDPOINT: ' + endPoint);
      let observable$: Observable &lt; any &gt; = this.http.post(endPoint, payload, headers);
      observable$.pipe(
        retryWhen(genericRetryStrategy()),
        tap(() =&gt; {
          console.log(""HTTP POST request executed and finished"");
          this.loadingStatus(false);
        }),
        catchError(err =&gt; {
          this.loadingStatus(false);
          return throwError(err);
        }));
      return observable$;
    } else {
      return this.error$;
    }
  }
</code></pre>

<p>Did anybody face a situation like this before?</p>
","2011091","","","","","2018-12-11 11:08:20","Failed when posting with Ionic/Angular using POST method","<angular><ionic3><rxjs6>","1","1","","","","CC BY-SA 4.0"
"53719715","1","","","2018-12-11 08:00:50","","0","466","<p>I've a prop of <code>addHandler</code> passed to <code>AddTodo</code> component from <code>App.js</code>. Then inside <code>AddTodo</code> handler I'm not sure how do I combine pluck and map so that I've value from pluck as well as <code>combineLatest</code> merged inside <code>map</code></p>

<p>Here's my code </p>

<p><strong>App.js</strong> </p>

<pre><code>import React from 'react';
import { componentFromStream , createEventHandler } from ""recompose"";
import { combineLatest } from ""rxjs"";
import { map, tap } from ""rxjs/operators"";
import AddTodo from './AddTodo/AddTodo';

import Todos from './Todos/todos';
// import User from './User/User';

const App = componentFromStream(prop$ =&gt; {
    const { handler: onAddHandler, stream: clickStream } = createEventHandler();
    const value$ = clickStream.pipe( tap(input =&gt;
        console.warn(input)
        ));

    return combineLatest(prop$, value$).pipe(map(([props, value]) =&gt; &lt;div&gt;
          &lt;AddTodo onAddHandler={onAddHandler}  /&gt;
          {/* &lt;input placeholder=""Add TODO"" onChange={handler} /&gt; */}
          &lt;Todos todo={value} /&gt;
        &lt;/div&gt;));
});


export default App;
</code></pre>

<p><strong>AddTodo.js</strong></p>

<pre><code>import React from ""react"";
import { combineLatest } from ""rxjs"";
import { componentFromStream, createEventHandler } from ""recompose"";
import { pluck, map, startWith, tap } from ""rxjs/operators"";

const AddTodo = componentFromStream(prop$ =&gt; {
  const {
    handler: onChangeHandler,
    stream: inputStream
  } = createEventHandler();
  const value$ = inputStream.pipe(
    map(e =&gt; e.target.value),
    startWith("""")
  );

  return combineLatest(prop$, value$).pipe(
    map(([props, value]) =&gt; (
      &lt;div&gt;
        &lt;input
          type=""text""
          placeholder=""Add Todo...""
          onChange={onChangeHandler}
        /&gt;
        &lt;button onClick={() =&gt; {}}&gt;Add todo&lt;/button&gt;
        {/* &lt;button onClick={() =&gt; onAddHandler(value)}&gt;Add todo&lt;/button&gt; */}
      &lt;/div&gt;
    ))
  );
});

export default AddTodo;
</code></pre>

<p>Inside <code>AddTodo.js</code> inside map I probably I'm looking for something like </p>

<pre><code>  return combineLatest(prop$, value$).pipe(
    pluck('onAddHandler'),
    // and use this value plus the belo values inside map
    map(([props, value]) =&gt; (
</code></pre>
","1096194","","","","","2018-12-13 05:21:38","merge values from pluck and combineLatest inside map rxjs","<rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"53750358","1","","","2018-12-12 19:48:15","","0","79","<p>I try to merge 3 stream status of my app to 1. The cycle is disconnect &lt;-> connect &lt;-> authed. So whenever the app only connected to the server, it will try to send auth every 3 second. Unless it is disconnected or already authenticated.</p>

<p>I am using rxjs timer to send auth on to-be-merged stream and takeUntil to stop sending the auth if the it has been authenticated. But the problem is instead of completing the sendAuth stream, merged auth$ stops emitting new response even though to-be-merged auth$ still emitting response. Here's the code:</p>

<pre><code>this._response$ = fromEvent&lt;string&gt;(this._socket, ""response"")
  .pipe(map(data =&gt; JSON.parse(data)));

const disconnect$ = fromEvent(this._socket, ""disconnect"");
const connect$ = fromEvent(this._socket, ""connect"");
const auth$ = this._response$.pipe(
  // this stream still emitting even if takeUntil is declared on connect$.
  filter(res =&gt; res.action === ""authentication"" &amp;&amp; res.type === ""success""),
);

status$ = merge(
  disconnect$.pipe(
    map(() =&gt; {
      this._status = statusEnum.OFF;
      return this._status;
    })
  ),
  connect$.pipe(
    // will send auth each 3s after connected
    // until it is authenticated or disconnected
    switchMap(() =&gt; timer(0, 3000).pipe(
      tap(() =&gt; console.log('Sending auth right after connect')),
      map(() =&gt; this._sendAuth()),
      // completing the status$ stream instead of switchMap
      takeUntil(auth$),
    )),
    map(() =&gt; {
      this._status = statusEnum.ON;
      return this._status;
    }),
  ),
  auth$.pipe(
    // this stream stop emitting if takeUntil is declared on connect$.
    map(() =&gt; {
      this._status = statusEnum.AUTHENTICATED;
      return this._status;
    })
  ),
);
</code></pre>

<p><strong>EDIT</strong>:
Merged auth$ start emitting value again after adding share operator to to-be-merged auth pipeline.</p>

<pre><code>const auth$ = this._response$.pipe(
  // this stream still emitting even if takeUntil is declared on connect$.
  filter(res =&gt; res.action === ""authentication"" &amp;&amp; res.type === ""success""),
  share(),
);
</code></pre>
","5410352","","5410352","","2018-12-14 05:38:39","2018-12-14 05:38:39","Timer with merge stop emitting value even though the parent source stream still emit new ones","<javascript><rxjs><rxjs6><reactivex>","1","2","","","","CC BY-SA 4.0"
"53754602","1","","","2018-12-13 03:26:37","","0","42","<p>It used to be I could so something like this:</p>

<pre><code>const rs = new ReplaySubject();
rs.take(1).subscribe(v =&gt; {});
</code></pre>

<p>but it looks like the API changed to:</p>

<pre><code>const rs = new ReplaySubject();
rs.pipe(take(1)).subscribe(v =&gt; {});
</code></pre>

<p><a href=""https://www.academind.com/learn/javascript/rxjs-6-what-changed/"" rel=""nofollow noreferrer"">https://www.academind.com/learn/javascript/rxjs-6-what-changed/</a></p>

<p>is this right? Seems like a big change and I don't understand that rationale.</p>
","","user5047085","","","","2018-12-13 03:26:37","RxJS version 6 operators change?","<rxjs><rxjs6>","0","3","","","","CC BY-SA 4.0"
"53754631","1","","","2018-12-13 03:30:21","","0","333","<p>Say I have a ReplaySubject:</p>

<pre><code>const rs = new ReplaySubject();

rs.next(1);
rs.next(2);
rs.next(3);
</code></pre>

<p>if I do:</p>

<pre><code>rs.pipe(take(1)).subscribe(v =&gt; {});
</code></pre>

<p>I will get the first value, but how do I get the most recent value, 3?</p>

<p>I tried</p>

<pre><code>rs.pipe(takeLast(1))
rs.pipe(last())
</code></pre>

<p>but those didn't work.</p>
","","user5047085","","user5047085","2018-12-13 03:40:52","2018-12-27 21:47:25","Get only most recent value from ReplaySubject","<rxjs6>","2","1","","","","CC BY-SA 4.0"
"53760300","1","53763237","","2018-12-13 10:57:17","","0","106","<p>I'm trying to chain a few requests in a series, something like <code>forkJoin</code> but the requests NOT being requested in parallel. Here's what I have so far:</p>

<pre><code>let nodeDetails = this.http.get('node/1/')
let nodeParents = this.http.get('nodeParents/1/')
let nodeTree = this.http.get('nodeTree/1/')
let nodeUsers = this.http.get('nodeUsers/1/')
let nodeDocuments = this.http.get('nodeDocuments/1/')
var requests = [nodeDetails, nodeParents, nodeTree, nodeUsers, nodeDocuments]
forkJoin(requests)
  .subscribe(responses =&gt; {
    // List of all responses from all of the requests
    console.log(responses)
  })
</code></pre>

<p>I read somewhere that <code>concat</code> can be used in combination with <code>toArray</code>, but that was apparently taken out in recent rxjs updates. Is there any way to do this currently?</p>

<p><strong>EDIT</strong> - The final goal is something similar to <a href=""https://stackoverflow.com/a/45229853/7970018"">this answer</a>. The code in that answer is no longer working in Angular 7 and Rxjs 6.2.2. </p>
","7970018","","7970018","","2018-12-13 12:15:12","2018-12-13 13:43:13","Combine requests in series - Angular 7","<angular><rxjs><angular7><rxjs6>","2","3","","","","CC BY-SA 4.0"
"53760583","1","53887321","","2018-12-13 11:13:00","","0","389","<p>I am trying with the basic use case of a Rxjs observer. This is what I am doing:</p>

<pre><code>const { Observable } = require('rxjs');

Observable.create(o =&gt; { 
  setTimeout(() =&gt; o.next('hi'), 1000); 
  setTimeout(() =&gt; { throw new Error('A mistake') }, 1500); 
  setTimeout(() =&gt; o.next('this should not print'), 2000) }
).subscribe({
  next: x =&gt; console.log(x),
  error: y =&gt; console.log('error', y),
  complete: () =&gt; console.log('done')
});
</code></pre>

<p>The out put of this is the following: </p>

<pre><code>&gt; hi
Error: A mistake
    at Timeout.setTimeout [as _onTimeout] (repl:1:89)
    at ontimeout (timers.js:498:11)
    at tryOnTimeout (timers.js:323:5)
    at Timer.listOnTimeout (timers.js:290:5)
&gt; this should not print
</code></pre>

<p>What I need to do is stop the execution of the next, and even If I <code>unsubscribe</code> my subscription it is not stopping the next execution.</p>

<p>I tried like this too:</p>

<p>let subscription;</p>

<pre><code>let source = Observable.create(o =&gt; { 
  try {
    setTimeout(() =&gt; o.next('hi'), 1000); 
    setTimeout(() =&gt; { throw new Error('A mistake') }, 1500); 
    setTimeout(() =&gt; o.next('this should not print'), 2000) 
  } catch (e) {
    subscription.unsubscribe();
    return 'error';
  }
});
subscription = source.subscribe({
  next: x =&gt; console.log(x),
  error: y =&gt; console.log('error', y),
  complete: () =&gt; console.log('done')
});
</code></pre>

<p>but no chance... it did not stop.</p>

<p>What I have as code is not just set timeout I have async and await code like this:</p>

<pre><code>let subscription;

let source = Observable.create(async o =&gt; { 
  try {
    o.next(await anEvent()); 
    o.next(await anEventThatThrowsAnException()); 
    o.next(await anEventThatIWantToAvoidDueToTheException()); 
  } catch (e) {
    subscription.unsubscribe();
    return 'error';
  }
});
subscription = source.subscribe({
  next: x =&gt; console.log(x),
  error: y =&gt; console.log('error', y),
  complete: () =&gt; console.log('done')
});
</code></pre>

<p>How can I achieve this code to stop the ""this should not print"" ?</p>
","5504356","","5504356","","2018-12-13 11:27:42","2018-12-21 15:31:03","Stop next execution of Rxjs observer?","<javascript><node.js><rxjs><rxjs6>","2","6","","","","CC BY-SA 4.0"
"53798142","1","","","2018-12-15 23:31:05","","6","533","<p>My usecase is this: I connect to a service with a websocket and get periodic (but unpredictable) health data from the service.  The app may have multiple users of this data stream, so I want to share it.  New subscribers should see the most recently emitted health data.  I also want to close the websocket when there are no more subscribers.</p>
<p>My app used <code>shareReplay(1)</code> for quite some time, until it was discovered that it leaks the underlying connection (<a href=""https://blog.strongbrew.io/share-replay-issue/"" rel=""nofollow noreferrer"">https://blog.strongbrew.io/share-replay-issue/</a>).  At which point we changed to <code>pipe(publishReplay(1), refCount)</code>.  It turns out that this also has a subtly that I did not expect:</p>
<ol>
<li>Subscriber A connects &amp; the websocket connection is established.</li>
<li>Subscriber B connects and shares correctly, as well as getting the most recent data.</li>
<li>Both A and B disconnect.  The websocket is torn down</li>
<li>Subscriber C connects, but only needs one value <code>take(1)</code>.  The value that is cached by the <code>publishReplay(1)</code> is returned.</li>
</ol>
<p>In step 4 I really wanted the websocket to be re-created.  The cached value is of no use.  The timewindow parameter of <code>publishReplay</code> is tempting, but also not quite what I want.</p>
<p>I've managed to find a solution, by using <code>pipe(multicast(() =&gt; new ReplaySubject(1)), refCount())</code>, but I don't know Rx well enough to understand the full implications of this.</p>
<p>My question is - what's the best way to achieve the behaviour I want?</p>
<p>Thanks!</p>
<p>Code sample can be seen at <a href=""https://repl.it/@bradb/MinorColdRouter"" rel=""nofollow noreferrer"">https://repl.it/@bradb/MinorColdRouter</a>
Inline code</p>
<pre class=""lang-js prettyprint-override""><code>    const { Observable, ReplaySubject } = require('rxjs');
    const { tap, multicast, take, publishReplay, refCount } = require('rxjs/operators');
    
    const log = console.log;
    
    function eq(a, b) {
      let result = JSON.stringify(a) == JSON.stringify(b);
      if (!result) {
        log('eq failed', a, b);
      }
      return result;
    }
    
    function assert(cond, msg) {
      if (!cond) {
        log('****************************************');
        log('Assert failed: ', msg);
        log('****************************************');
      }
    }
    
    function delay(t) {
      return new Promise(resolve =&gt; {
        setTimeout(resolve, t);
      });
    }
    
    let liveCount = 0;
    
    // emitValue 1 happens at 100ms, 2 at 200ms etc
    function testSource() {
      return Observable.create(function(observer) {
        let emitValue = 1;
        liveCount++;
        log('create');
        let interv = setInterval(() =&gt; {
          log('next --------&gt; ', emitValue);
          observer.next(emitValue);
          emitValue++;
        }, 100);
    
        return () =&gt; {
          liveCount--;
          log('destroy');
          clearInterval(interv);
        };
      });
    }
    
    async function doTest(name, o) {
      log('\nDOTEST: ', name);
      assert(liveCount === 0, 'Start off not live');
      let a_vals = [];
      o.pipe(take(4)).subscribe(x =&gt; {
        a_vals.push(x);
      });
      await delay(250);
      assert(liveCount === 1, 'Must be alive');
    
      let b_vals = [];
      o.pipe(take(2)).subscribe(x =&gt; {
        b_vals.push(x);
      });
      assert(liveCount === 1, 'Two subscribers, one source');
      await delay(500);
      assert(liveCount === 0, 'source is destroyed');
      assert(eq(a_vals, [1, 2, 3, 4]), 'a vals match');
      assert(eq(b_vals, [2, 3]), 'b vals match');
    
      let c_vals = [];
      o.pipe(take(2)).subscribe(x =&gt; {
        c_vals.push(x);
      });
      assert(liveCount === 1, 'Must be alive');
    
      await delay(300);
      assert(liveCount === 0, 'Destroyed');
      assert(eq(c_vals, [1, 2]), 'c_vals match');
    }
    
    async function main() {
      await doTest(
        'bad: cached value is stale',
        testSource().pipe(
          publishReplay(1),
          refCount()
        )
      );
      await doTest(
        'good: But why is this different to publish replay?',
        testSource().pipe(
          multicast(() =&gt; new ReplaySubject(1)),
          refCount()
        )
      );
      await doTest(
        'bad: But why is this different to the above?',
        testSource().pipe(
          multicast(new ReplaySubject(1)),
          refCount()
        )
      );
    }
    main();
</code></pre>
","1502846","","15159603","","2021-09-13 12:36:53","2021-09-13 12:36:53","Rxjs - unexpected publishReplay + refCount behaviour after refCount goes to 0","<rxjs><rxjs5><rxjs6>","1","3","1","","","CC BY-SA 4.0"
"53807158","1","","","2018-12-16 22:50:22","","2","1448","<p>I am using RxJS 6 which now uses the pipe operator. I have this:</p>

<pre><code>import {Observable, ReplaySubject} from 'rxjs';

const rs1 = new ReplaySubject(1); 
const rs2 = new ReplaySubject(1);
const rs3 = new ReplaySubject(1);

rs1.next(1);
rs2.next(2);
rs3.next(3);

Observable.merge(rs1,rs2,rs3).subscribe(v =&gt; {

});
</code></pre>

<p>but this doesn't compile - Observable.merge is not defined. I might be looking for concat instead of merge, but either way, concat is not defined as a static method on the Observable constructor either - how can we use merge and concat with RxJS7?</p>
","1223975","","","","","2018-12-16 23:00:12","Observable merge with pipe operator in RxJS version 6","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"53807265","1","53811958","","2018-12-16 23:06:39","","0","40","<p>I have this right now:</p>

<pre><code>import {concat, Observable, ReplaySubject, pipe, merge} from 'rxjs';
import {takeUntil, takeWhile, toArray} from 'rxjs/operators';


const rs1 = new ReplaySubject(1);  
const rs2 = new ReplaySubject(1);
const rs3 = new ReplaySubject(1);

rs1.next(1);
rs2.next(2);
rs3.next(2);

merge(rs1,rs2,rs3).pipe(toArray()).subscribe(v =&gt; {
  console.log({v});
});
</code></pre>

<p>right now it's logging nothing, but I am looking to get this logged:</p>

<pre><code>{v: [1,2,3]}
</code></pre>

<p>how do I concat/merge them to an array?</p>
","1223975","","","","","2018-12-17 09:09:30","Merge/concat to array","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"53809767","1","","","2018-12-17 06:10:18","","1","331","<p>As the below code, which is work in the desktop browser. However, it is doesn't work in the mobile browser. I find it is because of the subject.next() did not send successfully.</p>

<p><a href=""https://stackblitz.com/edit/angular-nmpadm"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-nmpadm</a> (my codes)</p>

<p><strong>ToastService.ts</strong></p>

<pre><code> public subject = new Subject&lt;ToastModel&gt;();

 constructor() {}

 getToast = (toastId?: string): Observable&lt;any&gt; =&gt; {
   return this.subject.asObservable();
 };

 success(message: string, keepAfterRouteChange = false) {
  this.toast(ToastType.Success, message, keepAfterRouteChange);
 }

 toast(type: ToastType, message: string, keepAfterRouteChange = false) 
 {
   this.keepAfterRouterChange = keepAfterRouteChange;
   // I think is this code doesn't work
   this.subject.next(&lt;ToastModel&gt;{ type: type, message: message });
 }
</code></pre>

<p><strong>toast.component.ts</strong></p>

<pre><code>constructor(private toastService: ToastService) {
}

ngOnInit() {
  this.toastService.getToast().subscribe((toast: ToastModel) =&gt; {
    // because in here can not catch the data from subject.next()
    console.log('toast')
    if(!toast) {
      this.toasts = [];
      return;
    }
    this.toasts.push(toast);
  })

  this.toastService.subject.subscribe((toast: ToastModel) =&gt; {
    console.log(toast);
  })
}
</code></pre>

<p><strong>Above those codes is work in the desktop browser, However, it is not work in the mobile browser</strong> </p>

<p>It is strange, anyone can help me?</p>
","5950855","","5950855","","2018-12-17 07:33:51","2018-12-17 07:33:51","angular Rxjs subject.next() doesn't work in mobile browser","<angular><rxjs><rxjs6>","0","13","","","","CC BY-SA 4.0"
"53812762","1","","","2018-12-17 09:57:05","","3","9514","<p>This is my <code>package.json</code> file:</p>

<pre><code>""dependencies"": {
    ""@angular/animations"": ""~7.1.0"",
    ""@angular/common"": ""~7.1.0"",
    ""@angular/compiler"": ""~7.1.0"",
    ""@angular/core"": ""~7.1.0"",
    ""@angular/forms"": ""~7.1.0"",
    ""@angular/material"": ""^7.1.1"",
    ""@angular/platform-browser"": ""~7.1.0"",
    ""@angular/platform-browser-dynamic"": ""~7.1.0"",
    ""@angular/router"": ""~7.1.0"",
    ""core-js"": ""^2.5.4"",
    ""ng2-opd-popup"": ""^1.1.21"",
    ""rxjs"": ""~6.3.3"",
    ""tslib"": ""^1.9.0"",
    ""zone.js"": ""~0.8.26""
</code></pre>

<p><code>service.ts</code> file code as below:</p>

<pre><code>import { Injectable } from '@angular/core';
import { Http, Headers} from '@angular/http';
import 'rxjs/add/operator/map';
//import { Observable } from 'rxjs/Observable';
//import   'rxjs/add/observable';
import { Observable} from 'rxjs';
@Injectable({
  providedIn: 'root'
})
export class EmpService {
  employees=[];
  constructor(private _http: Http) { }
  addEmployee(info){
    return this._http.post(""http://localhost/data/insert.php"",info)
      .map(()=&gt;"""");
  }
}
</code></pre>

<p>I got the following error:</p>

<blockquote>
  <p>rxjs has no exported member 'Observable'</p>
</blockquote>

<p>Is there any kind of issues in versions?</p>
","8496216","","8718377","","2018-12-17 10:51:55","2019-03-05 09:09:59","Angular 7 - getting error: 'rxjs has no exported member 'Observable'","<angular><typescript><rxjs><angular7><rxjs6>","3","3","","","","CC BY-SA 4.0"
"53826430","1","","","2018-12-18 04:32:52","","8","2987","

<p>I've been trying to get Jest working with RxJS and am having trouble with Jest not propagating errors from inside the subscribe callback.</p>

<p>Here is a sample test I've tried that is not working:</p>

<pre class=""lang-js prettyprint-override""><code>import {of} from 'rxjs';

test('should fail', () =&gt; {
  of(false).subscribe(val =&gt; {
    expect(val).toBe(true);
  });
});
</code></pre>

<p>The above test should fail, but it passes. I've googled around and found the following solution:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/50930249/failing-expect-inside-subscribe-does-not-mark-test-as-invalid"">Failing expect() inside subscribe() does not mark test as invalid</a></li>
</ul>

<p>This suggests using the ""done"" syntax in jest to solve the issue. While using the ""done"" callback does get the above test to fail, there are a number of issues with this approach:</p>

<h3>Undescriptive errors</h3>

<p>The test fails because the 'expect' call in subcribe() throws an error, resulting in 'done()' never getting called. The test then times out, waiting for done. So instead of propagating the 'expect' error, it is causing a timeout error, which means every test that fails in the expect clause will show a timeout error instead of the actual error message of the failed 'expect' call.</p>

<h3>Tests take longer to fail</h3>

<p>Because all tests are failing due to a timeout error, that means it takes 5 seconds for each test to fail (async tests timeout after 5 seconds). This can dramatically increase the amount of time for tests to run</p>

<h3>Poor use of done</h3>

<p>The <code>done</code> callback is meant to support asynchronous use cases for testing. But rxjs is not necessarily asynchronous. The code I inlined above actually runs synchronously. For example, the following test will pass:</p>

<pre class=""lang-js prettyprint-override""><code>import {of} from 'rxjs';

test('should pass', () =&gt; {
  let didRunSynchronously = false;
  of(true).subscribe(() =&gt; {
    didRunSynchronously = true;
  });
  expect(didRunSynchronously).toBe(true);
});
</code></pre>

<p>It seems strange to have to use asynchronous semantics to solve a problem for a synchronous test.</p>

<p>Wondering if anyone has come up with a good solution for testing in rxjs that will result in the <code>expect</code> calls to properly get handled by the testing library.</p>

<p>Thanks in advance!</p>

<h3>Relevant dependencies in package.json:</h3>

<pre class=""lang-js prettyprint-override""><code> ""dependencies"": {
    ""@babel/polyfill"": ""^7.0.0"",
    ""classnames"": ""^2.2.6"",
    ""history"": ""^4.7.2"",
    ""json-stringify-pretty-compact"": ""^1.2.0"",
    ""minimist"": ""^1.2.0"",
    ""normalize.css"": ""^8.0.0"",
    ""nullthrows"": ""^1.1.0"",
    ""react"": ""^16.5.2"",
    ""react-dom"": ""^16.5.2"",
    ""react-router-dom"": ""^4.3.1"",
    ""rxjs"": ""^6.3.3"",
  },
  ""devDependencies"": {
    ""@babel/core"": ""^7.2.2"",
    ""@babel/plugin-proposal-class-properties"": ""^7.1.0"",
    ""@babel/plugin-proposal-object-rest-spread"": ""^7.0.0"",
    ""@babel/preset-env"": ""^7.1.0"",
    ""@babel/preset-flow"": ""^7.0.0"",
    ""@babel/preset-react"": ""^7.0.0"",
    ""babel-core"": ""^7.0.0-bridge.0"",
    ""babel-env"": ""^2.4.1"",
    ""babel-eslint"": ""^10.0.1"",
    ""babel-jest"": ""^23.6.0"",
    ""babel-loader"": ""^8.0.4"",
    ""copy-webpack-plugin"": ""^4.5.3"",
    ""css-loader"": ""^1.0.0"",
    ""eslint"": ""^5.9.0"",
    ""eslint-plugin-flowtype"": ""^3.2.0"",
    ""eslint-plugin-import"": ""^2.14.0"",
    ""eslint-plugin-react"": ""^7.11.1"",
    ""eslint-watch"": ""^4.0.2"",
    ""flow-bin"": ""^0.83.0"",
    ""html-webpack-plugin"": ""^3.2.0"",
    ""jest"": ""^23.6.0"",
    ""prettier"": ""^1.15.3"",
    ""style-loader"": ""^0.23.1"",
    ""webpack"": ""^4.20.2"",
    ""webpack-cli"": ""^3.1.2"",
    ""webpack-dev-server"": ""^3.1.9""
  }
</code></pre>

<h3>.babelrc file</h3>

<pre class=""lang-js prettyprint-override""><code>{
  ""plugins"": [
    ""module:@babel/plugin-proposal-class-properties"",
    ""module:@babel/plugin-proposal-object-rest-spread""
  ],
  ""presets"": [
    [""module:@babel/preset-env"", { ""targets"": { ""node"": ""6.10"" } }],
    ""module:@babel/preset-flow""
  ]
}
</code></pre>
","3147688","","542251","","2019-12-16 17:29:21","2021-03-18 09:48:50","Jest not handling errors from expect() in subscribe() of RxJS observable","<rxjs><jestjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"53828056","1","","","2018-12-18 07:17:46","","0","103","<p>I have a method that returns an array of objects</p>

<p>I need to filter it by a certain criterion, and then create a new array of objects, where the data will be converted to another model</p>

<p>and then return the resulting array, then subscribe to it</p>

<pre><code>public getTestWithPare(): Observable&lt;Array&lt;TestModel&gt;&gt; {

    return this.http.getTests().pipe(
        flatMap(rate =&gt; rate), // splitting array
        filter(test =&gt; !test.isDone),
        map(test =&gt; {

            const testPare = new TestModel();
            testPare.key = `${test.id}/${test.name}`;
            if (test.type === 'new') {
                testPare.finish = test.value;
                testPare.show = true;
            } else {
                testPare.start = test.value;
                testPare.hide = true;
            }

            return testPare;
        }),
        concatAll(),
        toArray()
    );
}
</code></pre>

<p>after calling the method, I get an error: </p>

<blockquote>
  <p>You provided an invalid object where a stream was expected. You can
  provide an Observable, Promise, Array, or Iterable.</p>
</blockquote>

<p>I can not understand what is wrong</p>

<p>I want to get an array of objects at the output</p>

<p>approximately in this format:<code>['key': {key: '1 / t', finish: 7, show: true}, ...]</code></p>
","7883217","","7883217","","2018-12-18 08:02:17","2018-12-18 08:15:21","Concat Observable","<typescript><rxjs><rxjs6>","1","9","","","","CC BY-SA 4.0"
"53843267","1","","","2018-12-19 01:08:48","","0","103","<p>I have an Angular app using RXJS 6 for my authentication. I have rxjs-compat installed so the following code still works. But I would like to learn how to refactor the code. </p>

<pre><code> auth$ = this.af.authState
  .do(next =&gt; {
     if (!next) {
      this.store.set('user', null);
      return;
    }
    const user: User = {
      email: next.email,
      uid: next.uid,
      authenticated: true
    };
    this.store.set('user', user);
});
</code></pre>

<p>I was able to update my app using the docs, wrapping each operator in a pipe(), which was kind of neat, but I noticed that I wasn't getting the Authstate updated in my store. So after a bit of research i found a reference <a href=""https://stackoverflow.com/a/52188958/10648022"">here from ggradnig</a>. </p>

<p>I tried playing around with tacking on a subscribe after the pipe and I was able to console log out, but I couldn't figure out how to get the authenticated: true to trigger. Here's the tap() version I forgot to post that is not returning the authentication.</p>

<pre><code> auth$ = this.af.authState
.pipe(
tap(next =&gt; {
    if (!next) {
      this.store.set('user', null);
      return;
    }
    const user: User = {
      email: next.email,
      uid: next.uid,
      authenticated: true
    };
    this.store.set('user', user);

})
</code></pre>

<p>)</p>
","10648022","","10648022","","2018-12-19 01:24:02","2018-12-19 01:24:02","Migrating RXJS do() to tap()","<angular><rxjs6>","0","4","0","","","CC BY-SA 4.0"
"53850727","1","53850860","","2018-12-19 11:55:59","","0","46","<p>I have a list of tasks in array and I need to run them making a call to a web service.</p>

<p>But the thing is, they are in an array and I need to run <strong>one at a time</strong>, meaning: <strong>only run the next one when this one is finished</strong>, no matter if an error occurred or not.</p>

<p>I have this code here where I use <strong>combineLatest</strong>, but this way I only get the result when ALL them are finished.</p>

<pre><code>let arrayOfTasks: ServerTask[] = cacheInfo.cacheData;
let observables = [];
arrayOfTasks.forEach((task: ServerTask) =&gt; {
  if (task.method === 'post') {
    let observable$: any = this.restService.sendPost(task.action, task.payload, false, task.cacheName);
    observables.push(observable$);
  }
});

const combined = combineLatest(observables);
combined.subscribe((value: any[]) =&gt; {
  console.log('ARRAY DATA RETURNED');
  console.log(value);
}, error =&gt; {
  console.error(`Error running stored tasks: ${error}`);
}, () =&gt; {
  console.log('All cache tasks executed...');
});
</code></pre>

<h2>Any thoughts?</h2>

<p><strong>Edit 1:</strong></p>

<p>As suggested by @trichetriche here is the final solution:</p>

<pre><code>concat(...observables).subscribe((result: any) =&gt; {
  console.log('RESULT: ', result);
}, error =&gt; {
  console.error(`Error running queue of tasks: ${error}`)
}, () =&gt; {
  console.log('All subscriptions executed');
});
</code></pre>
","2011091","","2011091","","2018-12-19 13:57:18","2018-12-19 13:57:18","How to subscribe several Observables in an array but one at a time?","<angular><typescript><ionic3><rxjs6>","1","0","","","","CC BY-SA 4.0"
"53878650","1","53906123","","2018-12-21 02:59:57","","1","4502","<p>When using rxjs 6.3.3 and recompose <code>componentFromStreamWithConfig</code>, I hit the error: <code>You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.</code></p>

<p>I've tried providing a custom <code>rxjsConfig</code> object to <code>componentFromStreamWithConfig</code> as suggested in other questions relating to recompose and rxjs 6.</p>

<pre><code>import ""symbol-observable"";
import {
  componentFromStreamWithConfig,
  createEventHandlerWithConfig
} from ""recompose"";
import { from } from ""rxjs"";

const rxjsConfig = {
  fromESObservable: from,
  toESObservable: stream =&gt; stream
};

export const createEventHandler = createEventHandlerWithConfig(rxjsConfig);
export const componentFromStream = componentFromStreamWithConfig(rxjsConfig);
</code></pre>

<p>The exported <code>componentFromStream</code> is used in a typical way in various components.</p>

<p>I would expect this to work given the rxjs 6 configuration - however the <code>fromESObservable</code> seems to be a problem (stacktrace points to <code>Object.from [as fromESObservable]</code>)</p>
","4975676","","","","","2018-12-23 18:28:46","""You provided an invalid object where a stream was expected"" when using rxjs6 and recompose's componentFromStreamWithConfig","<reactjs><rxjs><rxjs6><recompose>","1","0","","","","CC BY-SA 4.0"
"53894004","1","53933047","","2018-12-22 08:03:04","","0","854","<p>I did some searching, but was unable to find a simple answer to my use-case. I apologize in advance if there already exists a sufficiently similar question on SO.</p>

<p>I have an observable, <code>myObservable</code>, that continuously streams a value from a store (i.e. it represents the state of the store). I want to test, with Jest, that my observable is able to correctly update when changes happen to the store.</p>

<pre class=""lang-js prettyprint-override""><code>// i.e. every time the value changes, an event is emitted by myObservable
myObservable.subscribe(x =&gt; console.log(x))
</code></pre>

<p>So what I really want to do is something like the following:</p>

<pre class=""lang-js prettyprint-override""><code>await myStore.set(0)
// insert here: check that `myObservable` stream is a 0
await myStore.set(5)
// insert here: check that `myObservable` stream is a 5
</code></pre>

<p>Basically I need a way to ""tap"" in to <code>myObservable</code> at any point in time to see what value was last emitted. Sorry if this is a bit of a n00b question.</p>
","839793","","839793","","2018-12-22 08:27:25","2018-12-26 13:55:22","Testing RxJS observable that tracks the last emitted value (no complete signal)?","<javascript><testing><rxjs><jestjs><rxjs6>","2","3","","","","CC BY-SA 4.0"
"53899228","1","","","2018-12-22 20:54:07","","1","639","<p>I am trying to create an Observable that continuously queries an outside service for updates, and if there is a new one, emits the update:</p>

<pre><code>this._loop = new Rx.Observable&lt;TDL.Result&gt;(subscriber =&gt;
{
    let shouldLoop = true;

    while (shouldLoop)
    {
        if (!this._client)
            throw new Error(""This client is not initialised."");

        const update = this._lib.receiveSync(this._client, 5);

        if (!update)
            continue;

        if (update._ === ""error"")
            this.emit(""error"", update);
        else
            this.emit(""update"", update);

        subscriber.next(update);
    }

    // never gets here b/c of while loop, so subscribing to this Observable
    // causes everything to block

    // cancellation logic
    return () =&gt;
    {
        shouldLoop = false;
        this._loop = null;
    };
}).pipe(RxOp.publish()) as Rx.ConnectableObservable&lt;TDL.Result&gt;;

this._loopSubscription = this._loop.connect();
</code></pre>

<p>However, the subscribe function is blocking, which means that my code halts when I call <code>connect()</code>. How do I rewrite this to make the subscription function non-blocking?</p>
","3508956","","","","","2018-12-22 22:38:04","How to create an observable based on a while loop?","<typescript><rxjs><observable><rxjs6>","1","1","","","","CC BY-SA 4.0"
"53920820","1","","","2018-12-25 08:56:51","","1","431","<p>I have created a new RxJs(6) operator switchIfEmpty(other), it switches to <code>other</code> when the source is empty.</p>

<p>i'am new in marble tests, i've created some tests for validating my operator, all tests pass except one. i dont know if the bugs comes from the operator or the test !</p>

<pre><code>import { Observable } from 'rxjs';

export const switchIfEmpty = &lt;T, R&gt;(emptySource: Observable&lt;R&gt;) =&gt;
  (source: Observable&lt;T&gt;) =&gt; {
    return new Observable&lt;T | R&gt;(subscriber =&gt; {
      let empty = true;
      const subscription = source.subscribe(
        e =&gt; {
          empty = false;
          subscriber.next(e);
        },
        error =&gt; subscriber.error(error),
        () =&gt; {
          if (empty) {
            const innerSub = emptySource.subscribe(
              innerE =&gt; subscriber.next(innerE),
              error =&gt; subscriber.error(error),
              () =&gt; subscriber.complete()
            );
            subscription.add(innerSub);
          } else {
            subscriber.complete();
          }
        }
      );
      return subscription;
    });
  };
</code></pre>

<p>the test spec:</p>

<pre><code>import { TestScheduler } from 'rxjs/testing';
import { of, throwError } from 'rxjs';
import { switchIfEmpty } from './switch-empty';
import { delay } from 'rxjs/operators';

describe('SWITCH IF EMPTY OPERATOR', () =&gt; {

  let scheduler: TestScheduler;

  beforeEach(() =&gt; {
    scheduler = new TestScheduler((actual, expected) =&gt; {
      expect(actual).toEqual(expected);
    });
  });

  it('switchIfEmpty : source not empty', () =&gt; {
    const source = '-x-y-z|';
    const expected = '-x-y-z|';
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      helper.expectObservable(source$.pipe(switchIfEmpty(of(1)))).toBe(expected);
    });
  });

  it('switchIfEmpty : source empty', () =&gt; {
    const source = '|';
    const expected = '(1 a|)';
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      helper.expectObservable(source$.pipe(switchIfEmpty(of('1', 'a')))).toBe(expected);
    });
  });

  it('switchIfEmpty : source error', () =&gt; {
    const source = '-x#';
    const expected = '-x#';
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      helper.expectObservable(source$.pipe(switchIfEmpty(of(1)))).toBe(expected);
    });
  });

  it('switchIfEmpty : empty source switched to error', () =&gt; {
    const source = '|';
    const expected = '#';
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      helper.expectObservable(source$.pipe(switchIfEmpty(throwError('error')))).toBe(expected);
    });
  });

  it('switchIfEmpty : empty source switched to delay', () =&gt; {
    const source = '|';
    const expected = '--x|'; // tried '--(x|)' not work
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      const switchedSource = of(1).pipe(delay(20));
      helper.expectObservable(source$.pipe(switchIfEmpty(switchedSource))).toBe(expected, {x: 1});
    });
  });
});
</code></pre>

<p>only the last one is not working:</p>

<pre><code>it('switchIfEmpty : empty source switched to delay', () =&gt; {
    const source = '|';
    const expected = '--x|'; // tried '--(x|)' not work
    scheduler.run(helper =&gt; {
      const source$ = scheduler.createColdObservable(source);
      const switchedSource = of(1).pipe(delay(20));
      helper.expectObservable(source$.pipe(switchIfEmpty(switchedSource))).toBe(expected, {x: 1});
    });
  });
</code></pre>

<p>the error message</p>

<pre><code>SWITCH IF EMPTY OPERATOR switchIfEmpty : empty source switched to delay FAILED
        Expected $.length = 0 to equal 2.
        Expected $[0] = undefined to equal Object({ frame: 2, notification: Notification({ kind: 'N', value: 1, error: undefined, hasValue: true }) }).
        Expected $[1] = undefined to equal Object({ frame: 3, notification: Notification({ kind: 'C', value: undefined, error: undefined, hasValue: false }) }).
            at TestScheduler.assertDeepEqual (http://localhost:9876/src/switch-empty.spec.ts?:12:22)
            at http://localhost:9876/node_modules/rxjs/_esm5/internal/testing/TestScheduler.js?:122:1
            at Array.filter (&lt;anonymous&gt;)
            at TestScheduler.push../node_modules/rxjs/_esm5/internal/testing/TestScheduler.js.TestScheduler.flush (http://localhost:9876/node_modules/rxjs/_esm5/internal/testing/TestScheduler.js?:120:1)
</code></pre>
","8325761","","8325761","","2018-12-25 22:47:13","2018-12-25 22:47:13","RxJs SwitchIfEmpty Custom pipable operator","<typescript><rxjs><reactive-programming><rxjs6><rxjs-pipeable-operators>","0","6","","","","CC BY-SA 4.0"
"53921613","1","53922819","","2018-12-25 10:46:16","","3","249","<p>I have <code>lessons$</code> observable which is combined from <code>initialLessons$</code> and <code>searchLessons$</code> observables.</p>

<p><code>initialLessons$</code> emits on the load of the page to get a list of lessons and when the user types in the search input <code>searchLessons$</code> emit to get the filtered results.</p>

<p>When I used <code>concat</code> to combine these observables, only the <code>initialLessons$</code> observable emits and it seems that it doesn't subscribe to <code>searchLessons$</code> at all. I replaced it with <code>merge</code> and it worked fine</p>

<p>I just need to know what's the explanation for this case!</p>

<pre><code>export class CourseComponent implements OnInit, AfterViewInit {
  @ViewChild('searchInput') input: ElementRef;

  courseId: string = this.route.snapshot.params['id'];

  course$: Observable&lt;Course&gt;;

  lessons$: Observable&lt;Lesson[]&gt;;

  constructor(private route: ActivatedRoute) {}

  ngOnInit() {
    this.course$ = createHttpObservable(`/api/courses/${this.courseId}`);
  }

  ngAfterViewInit() {
    const initialLessons$: Observable&lt;Lesson[]&gt; = this.loadLessons();

    const searchLessons$: Observable&lt;Lesson[]&gt; = fromEvent&lt;any&gt;(
      this.input.nativeElement,
      'keyup'
    ).pipe(
      debounceTime(400),
      map(event =&gt; event.target.value),
      distinctUntilChanged(),
      switchMap(search =&gt; this.loadLessons(search))
    );

    this.lessons$ = merge(initialLessons$, searchLessons$);
  }

  loadLessons(search = ''): Observable&lt;Lesson[]&gt; {
    return createHttpObservable(`/api/lessons?courseId=${this.courseId}&amp;pageSize=100&amp;filter=${search}`
).pipe(map(res =&gt; res['payload']));
</code></pre>

<p>}
}</p>

<p><strong>Edit:</strong> </p>

<p>This is createHttpObservable code:</p>

<pre><code>import { Observable } from 'rxjs';

export const createHttpObservable = (url: string) =&gt; {
  return Observable.create(observer =&gt; {
    const controller = new AbortController();
    const signal = controller.signal;

    fetch(url, { signal })
      .then(res =&gt; res.json())
      .then(data =&gt; observer.next(data))
      .catch(err =&gt; console.error(err));

    return () =&gt; controller.abort();
  });
};
</code></pre>
","7345306","","7345306","","2018-12-25 12:54:23","2018-12-25 13:41:25","Difference between concat and merge in rxjs6","<angular><rxjs><rxjs6>","1","5","1","","","CC BY-SA 4.0"
"53924674","1","53925063","","2018-12-25 18:23:15","","2","40","<p>I have a ""normal"" subscription to get data from a http source, like this</p>

<pre><code>sscmData.getRegistrations().subscribe(response =&gt; {
    this.registeredSkaters = response.map( item =&gt; item.skater )
})
</code></pre>

<p>The data are finally presented in a html table. Because the amount of data can be pretty huge it takes time until the table is shown.</p>

<p>Now I could show a ""loading circle"" or something else while creating the table, but I'm looking for a smarter solution.</p>

<p>Is it possible to show ""incomplete loaded"" tables or lists while data are still ""loaded by subscribe()""? Is there any concept for doing this?</p>

<p>Thx for your help!</p>
","9939844","","","","","2018-12-25 19:23:46","How to draw incomplete components while subscribe is running?","<angular><components><rxjs6>","2","3","","","","CC BY-SA 4.0"
"53942845","1","53944079","","2018-12-27 09:39:03","","1","252","<p>I have alternative solution but it's more like use more non-rxjs function while removing duplicate, filtering  and transforming array of objects.</p>

<p>and this is impacting performance when there 150 to 500 records there.</p>

<p>Here is glimps of codes</p>

<p><strong>Typescript model</strong></p>

<pre><code>export class columns {
    public displayName: string;
    public fieldName: string;
    public tabName: string;
    public tabOrder: string;
}
</code></pre>

<p>then behavior subject for transferring or listing array of columns from various part of application.</p>

<pre><code>public columnsNotify: BehaviorSubject&lt;columns[]&gt; = new BehaviorSubject([]);
</code></pre>

<p>Some sample data </p>

<pre><code>let listOfCols= [
    {displayName:""student name"",fieldName:""stdName"",tabName:""List"",tabOrder:1},
    {displayName:""student id"",fieldName:""stdid"",tabName:""List"",tabOrder:1},
    .....
    {displayName:""student name"",fieldName:""stdName"",tabName:""Details"",tabOrder:2}
    {displayName:""student id"",fieldName:""stdid"",tabName:""Details"",tabOrder:2}


];

this.columnsNotify.next(listOfCols);
</code></pre>

<p>Now the current solution, which I implemented for <strong><em>getting list of tabs with distinct and sorted by order</em></strong>.</p>

<pre><code>this.columnsNotify.pipe(
            map((column: columns[]) =&gt;
                Array.from(
                    new Set(
                        column.map(mp =&gt; {
                            const obj = JSON.stringify({
                                tabName: mp.tabName,
                                tabOrder: mp.tabOrder
                            } as TabsInfo);

                            return obj;
                        })
                    )
                )
                    .map(data =&gt; JSON.parse(data))
                    .sort((a: TabsInfo, b: TabsInfo) =&gt; {
                        return a.tabOrder &gt; b.tabOrder ? 1 : 0;
                    })
            )
        );
</code></pre>

<p>I tried to improve above code by flatting array but stuck at toArray operator as it wait for completion observable.</p>

<pre><code> this.columnsNotify.pipe(
        flatMap(searchCol =&gt; searchCol),
        map(
            (column: columns) =&gt;
                new TabsInfo(column.tabName, column.tabOrder)
        ),
        distinct((tab: TabsInfo) =&gt; tab.tabName),
        take(3), //&lt;-- Don't want this as, i don't know how many item there.
        toArray()  
    );
</code></pre>

<p>So, Is there anyway without using take operator with toArray, 
or it would be good whole different new approach.</p>

<p>I need similar solution at another place, where processed observable will be used in *ngFor, there also no luck so far n currently using different alternative.</p>
","3606872","","3606872","","2018-12-28 17:24:46","2018-12-28 17:24:46","Processing like filtering ,distinct, transforming array of objects into sequence of objects and back to collection array of objects using RXJS only","<angular><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"53953015","1","53953062","","2018-12-28 02:24:20","","17","5718","<p>I'm reading through some code with the snippet:</p>

<pre><code>search(query: string) {
  of(query).
  pipe(
    filter(Boolean), 
    debounceTime(300), 
</code></pre>

<p>Is <code>filter(Boolean)</code> essentially the same thing as <code>filter(v=&gt;!!v)</code>?</p>
","1684269","","","","","2020-09-28 20:36:53","Using RxJS with filter(Boolean) for queries?","<javascript><angular><typescript><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"53978845","1","","","2018-12-30 15:24:15","","5","4874","<p>i'm trying to create a reusable Modal component.
in a ModalService i have a Subject, and a method that that calls next() on the subject.
The ModalComponent subscribes to that subject, but whenever the method in the service is being called, the next function of the observer gets triggers twice.
Anyone know what causes this?</p>

<pre><code>export class ModalService { 
  openModal = new Subject(); 

  constructor() { } 

  open(cmp) { 
     this.openModal.next(cmp); 
   } 
}
</code></pre>

<p>Modal Component:</p>

<pre><code>export class ModalComponent implements OnInit {
  component: ComponentRef&lt;any&gt;;

  @ViewChild('entry', { read: ViewContainerRef }) entry: ViewContainerRef;

  constructor(
    private resolver: ComponentFactoryResolver,
    private modalService: ModalService
  ) {}

  ngOnInit() {
    this.modalService.openModal.subscribe(cmp =&gt; {

      // CALLD TWICE EVRY TIME THE SERVICE CALLS .next()
      console.log(cmp);
    });
  }
</code></pre>
","10771267","","","","","2021-01-19 05:43:29","Subject Subscription is triggered twice when I call .next() once in Angular app","<javascript><angular><rxjs><rxjs6><subject>","2","0","1","","","CC BY-SA 4.0"
"53984125","1","53986436","","2018-12-31 06:04:29","","0","59","<p>I have this working. On receipt of a socket message, a value is emitted immediately and every second thereafter (incrementing the age), until socket received again.</p>

<p>However, I want it to emit every second regardless of whether socket has been received. So it would start off emitting every seconds, but when socket received the properties would change to the new ones and they would be emitted every second.</p>

<p>Can't quite figure out what to do.</p>

<pre><code>updated: Observable&lt;TargetDevice&gt;;

this.updated = socketService.onMessage.pipe(
  filter(
    message =&gt;
      message.messageType === SocketIoMessageType.Device &amp;&amp;
      message.data.id === this.id
  ),
  map((message: SocketIoMessage) =&gt; &lt;Device&gt;message.data),
  tap(d =&gt; this.setProps(d)),
  switchMap(d =&gt;
    timer(0, 1000).pipe(
      tap(tick =&gt; (this.age = d.age + tick)),
      map(() =&gt; this)
    )
  )
);
</code></pre>
","10804414","","10804414","","2018-12-31 07:00:42","2018-12-31 10:36:33","Emit once and then every second thereafter until value changes","<rxjs><rxjs6>","3","1","","","","CC BY-SA 4.0"
"53988463","1","","","2018-12-31 14:19:06","","3","738","<p>I want to bind socket event with RxJs. I am fairly new in RxJs. I am using typescript with NodeJs. I tried implementing Socket.io with RxJs following some blogs but having issue with types, showing error socket.Server is not assignable to FromEventTarget&lt;{}>.</p>

<p>.Rxjs 6.3.3, Node 10.14.2, Socket-io 2.2.0, Typescript 2.9.2, Express 4.16.4</p>

<pre><code> import * as socketio from ""socket.io"";
 import { of, fromEvent } from 'rxjs';
 import { switchMap, map, mergeMap, takeUntil, tap } from 'rxjs/operators';

  class SocketServer {
    createSocketServer(http) {
    const io$ = of(socketio(http));
            const connection$ = io$.pipe(
        switchMap((io) =&gt; {
            return fromEvent(io, 'connection').pipe( 
    // ====&gt; this line io giving error Argument of type 'Server' is not assignable to parameter of type 'FromEventTarget&lt;{}&gt;'.
    // ==&gt; Property 'off' is missing in type 'Server' but required in type 'JQueryStyleEventEmitter'.ts(2345)
                tap(res =&gt; console.log('socket conected success fully', res)),
                map(client =&gt; ({ io, client }))
            )
        })
    );
    // Stream of disconnections
    const disconnect$ = connection$.pipe(
        mergeMap(({ client }) =&gt; {
            return fromEvent(client, 'disconnect').pipe(  
    // &lt;===== in this line showing error type client: {} not assignable to FromEventTarget&lt;{}&gt;
                map(() =&gt; client)
            )
        })
    );
    // On connection, listen for event
    const listen = (event) =&gt; {
        return connection$.pipe(
            mergeMap(({ io, client }) =&gt; {
                return fromEvent(client, event).pipe(
                    takeUntil(disconnect$),
                    map(data =&gt; ({ io, client, data }))
                )
            })
        )
    }
     }

 }
</code></pre>

<p>Looking best solution for this pattern to implement socket with RxJs with Typescript and node.</p>
","8445053","","8445053","","2019-01-01 13:01:39","2019-01-01 13:01:39","Socket.io with fromEvent observable and Typescript in NodeJS","<node.js><typescript><express><socket.io><rxjs6>","0","0","","","","CC BY-SA 4.0"
"53991889","1","53993863","","2018-12-31 22:33:10","","1","276","<p>I have the following, and it does work, it keeps increasing the delay and eventually timing out which is what I wanted.</p>

<p>But because I am using Concatmap i lose the original value from the interval.</p>

<pre><code>   let x = 1
    let source2$ = interval(500)
      .pipe(

        concatMap(() =&gt; {
          x++
          let newtime = x * 500
          console.log(""newtime "", newtime)
          return of(5).pipe(delay(newtime))
        }),
        timeout(3000),
        map((data) =&gt; {
          return 'Source 2: ' + data
        })
      )
</code></pre>

<p>so it prints Source 2: 5.. where as i want it to print the value of the interval.</p>

<p>I got working what i wanted using the concatmap but i think its the wrong operator as I lose the original value.</p>

<p>Can somebody help?</p>

<p><strong><em>More info</em></strong></p>

<p>TO summarize, all i would like to do is emit values using the interval and after each emit increase the delay time - eventually it hits the timeout of 3000 ms and errors out.</p>
","10853115","","10853115","","2018-12-31 23:25:56","2019-01-02 14:20:55","Increasing delay over a stream?","<rxjs><observable><rxjs6>","2","4","","","","CC BY-SA 4.0"
"53994224","1","","","2019-01-01 09:04:04","","1","71","<p>I have a messaging system in my application that uses socket-io to allow users to send instant messages to eachother.</p>

<p>I have a service which detects when they are typing.</p>

<pre><code>const userTyping = this.instantMessageService
  .messageTyping;

userTyping.subscribe(message =&gt; console.log(message.username))
</code></pre>

<p>I want the other users to be able to see a list of who is typing them a message which times out.</p>

<p>So if one person starts typing they will see ""John Doe is typing a message"" - this will timeout a couple of seconds later.</p>

<p>In the meantime, if another users starts typing they will see ""John Doe and Bill Bloggs are typing a message"" and so on.</p>

<p>I've tried messing around with merge, window, buffer etc in rxjs but can't seem to tie it all together.</p>

<p>Anyone got any tips?</p>
","10804414","","5490782","","2019-01-02 20:08:25","2019-03-01 07:56:20","rxjs get list of people typing","<angular><socket.io><rxjs><angular7><rxjs6>","2","0","","","","CC BY-SA 4.0"
"54000729","1","","","2019-01-02 02:55:28","","1","80","<p>These epics are triggered by the user typing into a field.
The SET_TODO triggers a message saying that the user is typing.
Then if the typing stops for one second the message is that the user is not typing and then two seconds later the message is an empty string.</p>

<p>A couple of questions,</p>

<p>One: Is there a way to do this with one self contained epic?</p>

<p>Two: I used dummy actions (ones that are not in the Redux reducer), is this a bad hack?</p>

<p>cheers</p>

<pre><code>import { concatMap, debounce, delay, mapTo } from 'rxjs/operators'
import { combineEpics, ofType } from 'redux-observable'
import { of, timer } from 'rxjs'

const enteringTextEpic = action$ =&gt;
  action$.pipe(
    ofType('SET_TODO'),
    delay(200),
    concatMap(action =&gt;
      of(
        { type: 'SET_MESSAGE', text: 'You are entering text' },
        { type: 'NOT' }
      )
    )
  )

const notEnteringTextEpic = action$ =&gt;
  action$.pipe(
    ofType('NOT'),
    debounce(() =&gt; timer(1000)),
    concatMap(action =&gt;
      of(
        { type: 'SET_MESSAGE', text: 'Now you are not entering text' },
        { type: 'FINISHED' }
      )
    )
  )
/**The actions NOT and FINISHED are dummy actions and are not in the reducer */
const finishedEnteringTextEpic = action$ =&gt;
  action$.pipe(
    ofType('FINISHED'),
    debounce(() =&gt; timer(2000)),
    mapTo({ type: 'SET_MESSAGE', text: '' })
  )

const epica = combineEpics(
  enteringTextEpic,
  finishedEnteringTextEpic,
  notEnteringTextEpic
)

export default epica
</code></pre>
","4890686","","","","","2019-01-02 02:55:28","Rx sequence of actions with Redux Observable","<rxjs6><redux-observable>","0","0","1","","","CC BY-SA 4.0"
"54012253","1","","","2019-01-02 19:44:22","","2","220","<p>Hy, im new in Rxjs.. </p>

<p>React have its <a href=""http://reactjs.org/docs/context.html"" rel=""nofollow noreferrer"">React context</a>. Similar is possible with Rxjs? My goal is create property, which is accessible from rxjs operators with <code>this</code>...</p>

<pre><code>const myObserver = Observable.create(function(observer) {
  Object.defineProperty(observer, ""context"", {
    value: {test: 'test'},
    writable: false
  });
  observer.next(data);
  observer.complete();
});

myObserver.pipe(map(function(data){
// this.context === {test: 'test'} //true
 return data
}))
</code></pre>
","10054091","","5437671","","2019-01-02 21:13:35","2019-01-02 21:13:35","Its possible for RXJS Observers create Context, as in React?","<angular><rxjs><rxjs5><rxjs6>","0","1","","","","CC BY-SA 4.0"
"54030722","1","54030977","","2019-01-03 22:33:00","","7","510","<p>Take for example:</p>

<pre><code> this.http.get('/getdata').pipe(delay(2000))
</code></pre>

<p>I would like this request to take a <strong>minimum</strong> of 2s to complete, but not any longer than it takes for the request to complete.</p>

<p>In other words:</p>

<ol>
<li><p>if the request takes <strong>1s</strong> to complete, I want the observable to complete in <strong>2s</strong>.</p></li>
<li><p>if the request takes <strong>3s</strong> to complete, I want the observable to complete in <strong>3s</strong> NOT <strong>5s</strong>.</p></li>
</ol>

<p>Is there some other pipe other than <code>delay()</code> that can achieve this that I don't know about or is there a way to build a custom pipe for this if necessary?</p>

<p>The use case is to show a loader, however if the request completes too fast it doesnt look good when the loader just ""flashes"" for a split second</p>
","1267778","","3001761","","2019-01-03 22:39:40","2020-06-22 08:08:34","How can I delay an observable only if it returns faster than the delay","<rxjs><rxjs6><rxjs-pipeable-operators>","2","5","","","","CC BY-SA 4.0"
"54035031","1","","","2019-01-04 07:55:50","","0","90","<p>I am newbie with RXJS Observables and I am trying to improve the next code, this code function well so I've written this code thinking on linear programming but I think is not correct, the buttton call this function : </p>

<pre><code>  submitLocations() {
    var locationsToAdd = this.locationsChecked.filter(item =&gt; !this.myLocations.some(other =&gt; item.id === other.id));
    var locationsToDelete = this.myLocations.filter(item =&gt; !this.locationsChecked.some(other =&gt; item.id === other.id));

    if (locationsToAdd.length &gt; 0) {
      this.addLocations(this.createLocationsToEdit(locationsToAdd));
    }
    if (locationsToDelete.length &gt; 0) {
      this.deleteLocations(this.createLocationsToEdit(locationsToDelete));
    }
    const startIndex = this.navCtrl.getActive().index - 1;
    this.navCtrl.remove(startIndex, 2).then(() =&gt; {
      this.events.publish('dniNameUpdated', true);
      this.navCtrl.pop().then(() =&gt; this.presentToast(`Se han actualizado tus localizaciones favoritas`))
    })
  }

private createLocationsToEdit(locations) {
    let locationsToEdit = {} as LocationLegacyEdit;
    locationsToEdit.locations = [];
    locations.forEach((res: LocationModel) =&gt; {
      locationsToEdit.locations.push(res.id);
    });
    return locationsToEdit;
  }
</code></pre>

<p>As you see, in my code, I have 2 lists to add and delete locations, if it lenght is more than 0 I have to call my services with : addLocations and deleteLocations. </p>

<pre><code>    private addLocations(locations: LocationLegacyEdit) {
    this._sp.addFavoriteLocationList(locations).subscribe(() =&gt; {
    }, error =&gt; console.log(error))
  }

  private deleteLocations(locations: LocationLegacyEdit) {
    this._sp.deleteLocationOteroUserList(locations).subscribe(() =&gt; {
    }, error =&gt; console.log(error))
  }
</code></pre>

<p>And my services that return observable are these:  </p>

<pre><code>    deleteLocationOteroUserList(locations: LocationLegacyEdit): Observable&lt;any&gt; {
    let url = URL_SERCAE + '/instances/favorites-locations';
    return this.http.request('DELETE', url, {
      body: locations
    })
  }

  addFavoriteLocationList(locations: LocationLegacyEdit): Observable&lt;any&gt; {
    let url = URL_SERCAE + '/instances/favorites-locations';
    return this.http
      .post(url, locations)
      .map(res =&gt; {
        return res['result'];
      })
  }
</code></pre>

<p>COuld someone help me, how can I improve this flow ?, I am not sure if Should I write 1 service to combine ADD with DELETE or Should I write this in my component  with conditional to continue if length is 0.</p>

<p>Thank you in advance </p>
","10030734","","3410196","","2019-01-09 08:32:08","2019-01-09 08:32:08","How can I improve my flow code with conditionals and loops with observables RXJS in Angular?","<angular><typescript><ionic-framework><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"54045981","1","54071980","","2019-01-04 20:59:45","","2","1216","<p>I have an external hot source pushing values before observers can subscribe. Upon subscription, the late observers should receive the latest value and every value from that point on. For this, I used the following code (the relevant line is marked with '&lt;&lt;&lt;', the <code>s</code> <code>Subject</code> is here just to be able to create the simplest sample possible, in reality the hot source works differently):</p>

<pre><code>// irrelevant, just to send values
const s = new Subject();

// make the observable cache the last value
const o = s.pipe(shareReplay(1)); // &lt;&lt;&lt;

// now, before subscription, values start coming in
s.next(1);
s.next(2);
s.next(3);

o.subscribe(n =&gt; console.warn('!!!', n));
</code></pre>

<p>This doesn't work (I expected it to print <code>!!! 3</code> but nothing happens), but I found a way to make it work:</p>

<pre><code>// irrelevant, just to send values
const s = new Subject();

const r = new ReplaySubject(1);
s.subscribe(r);
const o = r.asObservable();

s.next(1);
s.next(2);
s.next(3);

o.subscribe(n =&gt; console.warn('!!!', n));
</code></pre>

<p>i.e instead of using <code>shareReplay(1)</code>, I create a <code>ReplaySubject(1)</code> and use it as a bridge. With this code, I do get the coveted <code>!!! 3</code>. </p>

<p>While I'm happy it works, I would like to understand why the first snippet doesn't. I always thought <code>shareReplay</code> is pretty much equivalent to the second way and actually kind of implemented this way. What am I missing?</p>
","1385578","","310726","","2019-01-07 09:52:25","2019-01-07 09:52:25","shareReplay vs ReplaySubject - only ReplaySubject caches latest value before subscription","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54053763","1","","","2019-01-05 16:09:26","","2","1080","<p>Does anybody know why this filter after mapping, is not working?</p>

<p>When I do this:</p>

<pre><code>this.cacheService.getMainCache().pipe( map(val =&gt; val.list)).subscribe((val) =&gt; {
  console.log(val);
}, (error) =&gt; {
  console.log('Error: ', error);
});
</code></pre>

<p>I get this array of objects:
<a href=""https://i.stack.imgur.com/lNkjt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lNkjt.png"" alt=""enter image description here""></a></p>

<p>I need to filter this array and return only one, the one with the name property equal to some string, when I add the filter operator to the pipe nothing happens, I suppose nothing is filtered:</p>

<pre><code>this.cacheService.getMainCache().pipe(map(val =&gt; val.list), filter((item: any) =&gt; item.name == 'profile')).subscribe((val) =&gt; {
  console.log(val);
}, (error) =&gt; {
  console.log('Error: ', error);
});
</code></pre>

<p>What am I doing wrong here?</p>
","2011091","","","","","2019-01-05 21:56:41","Using map and filter in RxJs 6 (Ionic/Angular) is not working properly in object array, filter ignored","<angular><ionic3><rxjs6>","4","0","","","","CC BY-SA 4.0"
"54074184","1","","","2019-01-07 12:10:07","","1","251","<p>The task is to check that the login is free for use or is already in use by another user. For this I use the HEAD request, when the response comes with <strong>404 status code</strong> means the login is free, if the response comes with <strong>200 status code</strong> means the login is already in use by another user. Every time when I enter a single letter in the input field it makes a request to server and it works, <strong>but I tried to use debounceTime and distinctUntilChanged to wait a second before make request, in order not to send a request after each key press</strong> . And I imported it from RxJS.
 <strong>import { debounceTime, distinctUntilChanged } from 'rxjs/operators'</strong>. But it doesn't work for me. The request still comes after each key press. Here it is my html input field. It calls <strong>checkLogin()</strong> on every keyup</p>

<pre><code>&lt;input
            pInputText
            placeholder=""Login""
            id=""float-input-login""
            [(ngModel)]=""teacher.login""
            name=""login""
            [class.is-invalid]=""login.invalid &amp;&amp; login.touched""
            #login=""ngModel""
            minlength=""5""
            maxlength=""20""
            (keyup)=""checkLogin()""
          /&gt;
</code></pre>

<p>Here it is my component <strong>checkLogin()</strong> method code:</p>

<pre><code>checkLogin() {
    this.loginStatus = '';
    if (this.teacher.login.length &gt;= 5) {
      this._teacherServices
        .checkLoginTeacher(this.teacher)
        .pipe(debounceTime(1000),
        distinctUntilChanged())
        .subscribe(checkResponse =&gt; {
          if (
            checkResponse == null &amp;&amp;
            this.selectedTeacher.login !== this.teacher.login
          ) {
            this.loginStatus = 'The login is already in use';
          }
        });
    }
  }
</code></pre>

<p>End here it is my Service head method:</p>

<pre><code>public checkLoginTeacher(teacher: Iteachers): Observable&lt;Iteachers&gt; {
    return this.http
      .head&lt;Iteachers&gt;(`/users/login/${teacher.login}/`)
      .map((response: any) =&gt; {
        return response;
      });
  }
</code></pre>

<p>And Interface:</p>

<pre><code>export interface Iteachers {
  firstname: string;
  lastname: string;
  patronymic: string;
  dateOfBirth: string;
  id: number;
  email: string;
  avatar: string;
  login: string;
  phone: string;
  newPass: string;
  oldPass: string;
}
</code></pre>

<p>Again I want to say that I imported everything what it needs , waiting for your proposals. Thank you!</p>
","10150744","","10150744","","2019-01-07 13:21:50","2019-01-07 13:21:50","Can't make debounceTime work using http head method in Angular 7","<rxjs><angular7><rxjs6><debouncing><debounce>","0","2","","","","CC BY-SA 4.0"
"54078694","1","","","2019-01-07 17:02:40","","1","306","<p>I am trying to implement autosave functionality in which i have used switchMap operator within switchMap operator i.e. multiple nested inner observable </p>

<pre><code>merge(...eventObservables)
    .pipe(switchMap(({ syncWithServer }) =&gt; {
        const source = of(cloneDeep(this.getData()))
            .pipe(tap((data) =&gt; this.storageService.storeItem(data.id, {
                data: data,
                synced: false
            })));
        if (syncWithServer) {
            return source.pipe(delay(5 * 1000),
                switchMap((data) =&gt;
                    this.apiService.saveData(data)
                        .pipe(tap(() =&gt; this.storageService.storeItem(data.RespondentId, {
                            data: data,
                            synced: true
                        })), tap((response) =&gt; response &amp;&amp; this.setData(response['Data'], false)))));
        }
        return source;
    }))
</code></pre>

<p>The problem with above code is API request is completing instead of cancelling when there is new value from eventObservables. Can someone point out what is issue here. As per my understanding when source observable is unsubscribed (As i have used switchMap which will unsubscribe previous observable) switchMap will also unsubscribe inner observable. If i have understood it wrong could someone point out mistake in above code?</p>
","7415356","","1118978","","2019-01-07 17:09:41","2019-01-07 17:09:41","How to unsubscribe inner observable when source observable completes","<angular><rxjs><reactive-programming><rxjs5><rxjs6>","0","4","","","","CC BY-SA 4.0"
"54086789","1","54306670","","2019-01-08 07:07:58","","-1","479","<p>Currently i am working on migration from angular 5 to 6. While updating to redux 4 i am getting error as store.getState() is not a funtion</p>

<pre><code>export interface IAppState {
    source1: IEmployee[],
    source2: IEmployee[],
}    
export type FSAction = FluxStandardAction&lt;any, MetaData | null | number&gt;;
</code></pre>

<p>this is the code for epic middleware.
Here i am facing issue as <strong>store.getState()</strong> is not a function while updating to redux 4</p>

<pre><code>employeeValues_Epic: Epic&lt;FSAction, IAppState&gt; = (action$, store) =&gt; action$
.ofType(APP_Actions.ActionTypes.APP_EMPLOYEE_VALUES).pipe(
  switchMap(data =&gt; {  
       let state1: IEmployee[] = [];
       try {
            console.log(""in All domain  iteration"");
            state1 = store.getState().source1.state;        
       } catch (error) {
           console.error(error);
    }
    return observableFrom(state1);
  }));`
</code></pre>

<p>Currently i am working on migration from angular 5 to 6. While updating to redux 4 i am getting error as store.getState() is not a funtion</p>
","8237266","","","","","2019-01-22 10:52:51","state.getState() is not a function while updating to redux 4","<jquery><redux><angular6><rxjs6><redux-observable>","2","2","","","","CC BY-SA 4.0"
"54110377","1","54110606","","2019-01-09 12:37:43","","3","3006","<p>I implemented an method which returns an Observable. Inside this method I am using http.post to send a request to the backend. After receiving the response, which is a JSON object, I want to store this in an Observable variable and return that variable. But somehow I didn't manage to solve that problem. In .subscribe the res variable is not stored in the postResponse variable, but I can see in the ""local"" console.log that the res variable has the correct value. The global console.log is empty. Furthermore I get the error: </p>

<blockquote>
  <p>""TS2322:
  Type 'ArqResponse' is not assignable to type 'Observable'""
  error  for the return.</p>
</blockquote>

<p>My code looks like this:</p>

<pre><code>postARQRequest(request): Observable&lt;ArqResponse&gt;{
    let postResponse = new ArqResponse;
    const result = this.http.post&lt;ArqResponse&gt;(this.arqUrl, request)
                       .subscribe((res: ArqResponse) =&gt; { postResponse = res; console.log('shadow: ' + res)});
    console.log('global: ' + JSON.stringify(postResponse));
    return postResponse;
}
</code></pre>

<p>My questions are:</p>

<ol>
<li>How can I store the response body in a variable, which then can
be returned?</li>
<li>How can I ""cast"" an ArqResponse variable to an
Observable variable?</li>
<li><code>.subscribe</code> seems to be wrong since I get:</li>
</ol>

<blockquote>
  <p>this.arqService.postARQRequest(...).subscribe is not a function
      error</p>
</blockquote>
","10867959","","8718377","","2019-01-09 13:24:34","2019-01-09 13:24:34","Angular - receive and return Observable<T> response in Http.post","<angular><typescript><rxjs><observable><rxjs6>","3","0","2","","","CC BY-SA 4.0"
"54117710","1","54118467","","2019-01-09 20:20:10","","0","53","<p>I have an issue with an http interceptor that depends on an observable. The whole thing ends up in an endless loop calling the same URL over and over again. 
However, I've searched for other solutions similar to mine (see e.g. <a href=""https://medium.com/@danielcrisp/async-http-interceptors-with-angular-4-3-9e6e795da562"" rel=""nofollow noreferrer"">Async HTTP Interceptors with Angular 4.3</a>) and I can't see any big difference except for a different rxjs version. The interceptor looks as follows:</p>

<pre><code>@Injectable()
export class MyHttpInterceptor implements HttpInterceptor {

  constructor(private loginSvc: LoginService) {}

  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {    
    return this.loginSvc.currentUser$.pipe(
      mergeMap(x =&gt; {
        if (x) {
          console.log(""User is authenticated, usually I would add a bearer token to the request here..."");
        }
        return next.handle(req);
      })
    );
  }
}
</code></pre>

<p>Can someone point out my mistake I've made in this Angular http interceptor? You can see the whole working example here:</p>

<p><a href=""https://stackblitz.com/edit/angular-cazgsa?file=src%2Fapp%2Fservices%2Fmy-http-interceptor.service.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-cazgsa?file=src%2Fapp%2Fservices%2Fmy-http-interceptor.service.ts</a> </p>

<p>The setup is as follows:</p>

<ol>
<li>login.service.ts: this service encapsulates the authenticated user. It does this via a BehaviorSubject and an corresponding Observable. Initially, the subject is initialized with null which indicates a not logged in user.</li>
<li>login.component.ts line line 17: as soon as the route /login is opened we're simulating a request which should authenticate a user. The request simply returns a user from jsonplaceholder which simulates a successful login.</li>
<li>We're populating the user via LoginService so that all interested parties / observers get informed about the newly signed in user. One of these interested parties is the http interceptor.</li>
</ol>

<p>In order to reproduce the issue open the http interceptor on StackBlitz and uncomment the lines as described there. In the developer console you'll see repetitive log messages which appear in an endless loop. <strong>Watch out: if you wait too long it leads to a crashing browser tab / window! So if you uncomment quickly comment out the lines again after you were able to re-produce the issue!</strong> On StackBlitz you can simply use the shortcut STRG + / to toggle comments on multiple lines!</p>

<p>Thanks a lot in advance!</p>
","4587483","","4587483","","2019-01-09 21:03:25","2019-01-09 21:15:19","Request is being fired infinitely when using observable in http interceptor","<angular><angular7><rxjs6><angular-http-interceptors>","1","0","","","","CC BY-SA 4.0"
"54121703","1","54125359","","2019-01-10 03:47:41","","0","75","<p>I have two Observables that are zipped. One generating a stream of events from an external source, and one generating a stream of predefined strings.</p>

<p><strong>Example code:</strong></p>

<pre><code>import { interval, of, zip } from ""rxjs"";
import { pipe, mapTo } from ""rxjs/operators"";

let ticks$ = interval(1000).pipe(mapTo(""Tick""));
let words$ = of(""foo"", ""bar""); 

let ticker$ = zip(ticks$, words$);

ticker$.subscribe((e) =&gt; console.log(e));
</code></pre>

<p>This code works as expected, and outputs until <code>words$</code> runs out of elements, at which point it completes, and <code>ticker$</code> stops:</p>

<pre><code>#=&gt; [""Tick"", ""foo""]
#=&gt; [""Tick"", ""bar""]
</code></pre>

<p>So far, so good. It works in accordance with the documentation for <code>#of</code>:</p>

<blockquote>
  <p>An Observable that emits the arguments described above and then completes.</p>
</blockquote>

<hr>

<p>Now, I would like <code>words$</code> to be cycled. That is, when the last element has been emitted, it starts back at the beginning. So <code>ticker$</code>  will not stop:</p>

<pre><code>#=&gt; [""Tick"", ""foo""]
#=&gt; [""Tick"", ""bar""]
#=&gt; [""Tick"", ""foo""]
#=&gt; ...
</code></pre>

<p>Looking at the documentation, there is no <code>#cycle</code> creator function.</p>

<p>How can I create an observable that cycles through a list of fixed values?</p>
","1520557","","1520557","","2019-01-11 01:56:49","2019-01-11 01:56:49","Observable that cycles trough values","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54129795","1","54130234","","2019-01-10 13:30:04","","0","56","<p>I have some Subject. And one Observer subscribed to it. How to omit all Observer invocations if it is already processing one?</p>

<pre><code>var subject = new Subject();
var observer = {
        next: x =&gt; {
            //... some long processing is here
            console.log('Observer got a next value: ' + x)
        }
    };
subject.subscribe(observer);
subject.next(0);
subject.next(1);// &lt;-- if 0 value is not processed in the observer then skip it
subject.next(2);// &lt;-- if 0 value is not processed in the observer then skip it
</code></pre>

<p>I of cause can introduce some <code>flag</code>, set it in Observer before execution and clear it after. And apply filter operator, like this:</p>

<pre><code>var subject = new Subject();
var flag = true;
var observer = {
    next: x =&gt; {
        flag = false;
        //... some long processing is here
        console.log('Observer got a next value: ' + x)
        flag = true;
        }
    };
subject.filter(() =&gt; flag).subscribe(observer);
subject.next(0);
subject.next(1);// &lt;-- if previous value is not processed in the observer then skip it 
subject.next(2);// &lt;-- if 0 value is not processed in the observer then skip it
</code></pre>

<p>But I believe that exists more elegant and efficient way to achieve that.</p>
","8713472","","","","","2019-01-10 13:54:46","How to ignore new values in Observer during execution","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54149462","1","57547581","","2019-01-11 15:28:24","","2","836","<p>I have this Rxjs testing code. It fail deliberately, because i want to show you the failing log. Which i found hard to understand, or at least i cannot read it fluently.</p>

<p>Someone can explain me what means : <code>$[i].frame = i' to equals i''</code> ?</p>

<pre><code>import { delay } from 'rxjs/operators';
import { TestScheduler } from 'rxjs/testing';

describe('Rxjs Testing', () =&gt; {

  let s: TestScheduler;

  beforeEach(() =&gt; {
    s = new TestScheduler((actual, expected) =&gt; {
      expect(actual).toEqual(expected);
    });
  });

  it('should not work', () =&gt; {
    s.run(m =&gt; {
      const source = s.createColdObservable('-x-y-z|');
      const expected = '-x-y-z|'; // correct expected value is '---x-y-z|'

      const destination = source.pipe(delay(2));
      m.expectObservable(destination).toBe(expected);
    });
  });
});
</code></pre>

<p><a href=""https://i.stack.imgur.com/5yTaz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5yTaz.png"" alt=""enter image description here""></a></p>
","8325761","","","","","2019-08-18 19:07:40","RxJs marble testing : Assertion fail log hard to understand","<testing><rxjs><rxjs6><rxjs-marbles>","1","2","2","","","CC BY-SA 4.0"
"54149656","1","","","2019-01-11 15:39:38","","2","1075","<p>Since <code>switchMap</code> may cut off (unsubscribe) an inner Observable if a new item comes in, we expect the following:</p>

<pre class=""lang-js prettyprint-override""><code>  const items = from([1, 2])
  const seen = []
  const derived = items.pipe(
    switchMap(item =&gt;
      concat(
        of(`now: ${item}`),
        of(`end: ${item}`).pipe(delay(10))
      )
    )
  )

  derived.subscribe(next =&gt; seen.push(next))
</code></pre>

<p>to result in <code>seen</code> having:</p>

<pre><code>['now: 1', 'now: 2', 'end: 2']
           ^ unsubscribed to 1 here, as planned!
</code></pre>

<p>The question is, is there a way to get notified that item 1 was canceled? The reason being, if cancellations are happening too frequently I'd like to know.</p>

<p>I've tried ways of modifying the inner Observables, but basically anything I try to do 'at the end' of them simply doesn't happen when unsubscribed. The Observer spec has <code>next</code>, <code>completed</code>, and <code>error</code>, but nothing for ""ended early"", so I'm not sure what to try.</p>

<p>I'd like to be able to pass an additional function to switchMap, which will be invoked by the operator when an inner observable is canceled, and provided the argument.</p>

<pre><code>  const derived = items.pipe(
    switchMap(item =&gt; concat(
      of(`now: ${item}`),
      of(`end: ${item}`).pipe(delay(10))
    ),
    (item) =&gt; console.error(`${item} was cut off.`))
  )
</code></pre>
","326532","","","","","2019-02-07 17:01:10","How to know if switchMap unsubscribed an inner Observable?","<rxjs><observable><rxjs6><reactivex><switchmap>","1","1","","","","CC BY-SA 4.0"
"54150960","1","","","2019-01-11 16:59:29","","1","17","<p>This is probably more a webpack question than an RXJS question - but something in my code base is including RXJS in different ways. Any tips on how I can tell what has included RXJS?</p>

<p><a href=""https://i.stack.imgur.com/yD3ic.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yD3ic.png"" alt=""enter image description here""></a></p>
","954940","","","","","2019-01-11 16:59:29","why is rxjs code doubled in bundle analyzer","<rxjs6><webpack-bundle-analyzer>","0","1","1","","","CC BY-SA 4.0"
"54155003","1","54162061","","2019-01-11 22:42:48","","4","2309","<p>Using <code>angular 7</code> and <code>rxjs 6</code>:</p>

<pre><code>&lt;input (input)=""onChange($event.target.value)""&gt;
</code></pre>

<p><strong>Why the following does not debounce?</strong></p>

<pre><code>onChange(val: string) {
  of(val)
    .pipe(        
      debounceTime(300)        
  ).subscribe(valx =&gt; {
    console.log(valx);
  });
}
</code></pre>

<p><strong>But this does:</strong></p>

<pre><code>  searchTerm$: Subject&lt;string&gt; = new Subject();

  this.searchTerm$.pipe(      
    debounceTime(300),    
  ).subscribe(val =&gt; {
   console.log(val);
  });


onChange(val: string) {   
  this.searchTerm$.next(val);
}
</code></pre>
","688202","","310726","","2019-01-12 17:22:46","2021-07-04 02:54:58","Why rxjs debounceTime does not work on observables created using 'of' operator?","<angular><rxjs><rxjs6><debouncing>","2","2","1","","","CC BY-SA 4.0"
"54181320","1","54203132","","2019-01-14 12:10:40","","1","533","<p>Newbie question:</p>

<p>I am trying to export my data from a rest API to firebase.</p>

<p>I am using <strong>Angular6</strong> with <strong>RxJS 6</strong>. </p>

<pre><code>getByTag(tag:string) {
  return this.http.get(this.URL + '/get/listings/', { headers })
    .pipe(
      map((res: Listings) =&gt; res.items),
      // How do I add an additional property to each of these items? eg res.items.inserted = new Date();
      // How do chain each of these res.items to another function called exportToFirebase(res.item))
    );
}
</code></pre>

<p>My Data looks something like this:
<a href=""https://pasteboard.co/HWp1hUb.jpg"" rel=""nofollow noreferrer"">https://pasteboard.co/HWp1hUb.jpg</a></p>

<p>I tried the map function but my incoming data stream from the API is an array of arrays so 
I attempted mergeMap without any success
(<a href=""https://www.learnrxjs.io/operators/transformation/mergemap.html"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/operators/transformation/mergemap.html</a>)</p>

<p>I attempted a <code>do()</code> statement to trigger the <code>exportToFirebase(res.item)</code>, but It looks like I am completely off track here :-P</p>

<p><strong>Expected result:</strong> Create a loop to send  item parameter of type Listing to my service function called <code>exportToFirebase(res.item)</code></p>

<p><strong>Questions?</strong></p>

<ol>
<li><p>How do I add an additional property to each of these items? eg <code>res.items.inserted = new Date();</code> ?</p></li>
<li><p>How do chain each of these <code>res.items</code> to another function called <code>exportToFirebase(res.item))</code> ?</p></li>
</ol>
","10911542","","310726","","2019-01-15 16:30:24","2019-01-15 16:49:14","Angular Map and mergeMap rxjs6 operators","<angular><angular6><rxjs6>","2","1","","","","CC BY-SA 4.0"
"54195018","1","54216739","","2019-01-15 08:21:24","","0","112","<p>I have a service periodical api call that changes the url if this is the first time it's called.</p>

<p>It has a interval subscription for generating api call, I can't use a global variable because it's a service that can be invoqued without remove the injector.</p>

<pre><code>getData(init: boolean): Observable&lt;any&gt; {

   const refreshInterval = 5000;
   const interval = observableInterval(refreshInterval).pipe(startWith(0)) 

  return interval.pipe(
    flatMap(() =&gt; this.http.get&lt;any&gt;(this.getUrl(init))), 
    map((data) =&gt; this.doWhateverWithData(data)),
  );

}

getUrl(init: boolean): string {

    return init ? url1 : url2;
}
</code></pre>

<p>My problem is init is not changing and so the url is either.</p>

<p>How can I solve it?</p>

<p>As I said, I can't use this.init because of my code.</p>
","5212118","","5212118","","2019-01-16 11:46:58","2019-01-16 12:06:24","update value in subscription","<rxjs><angular7><rxjs6>","3","0","","","","CC BY-SA 4.0"
"54217306","1","54221519","","2019-01-16 12:41:29","","0","544","<p>hope someone can help I have an observable that returns base64 string inside a map of a http request below</p>

<pre><code>transform(url: string, asBase64: boolean): Observable&lt;any&gt; {
        return this.http
            .get(url, {responseType: 'blob'})
            .pipe(map(val =&gt; {
                if (!asBase64) {
                    return this.sanitizer.bypassSecurityTrustUrl(URL.createObjectURL(val))
                }
                let base64Data = null;
                let reader = new FileReader();
                reader.readAsDataURL(val);
                reader.onloadend = () =&gt; {
                    base64Data = reader.result; // need to return this! 
                    console.log(base64Data);

                };
            }));
    }
</code></pre>

<p>The problem is I need to conditionally return the result  <code>reader.onloadend = () =&gt; {</code></p>

<p>I guess I need to convert this to a promise and use mergeMap? Not sure how.</p>

<p><strong>Update</strong> </p>

<p>So had another stab at this.. From the mergeMap docs looks like this should work, debugging I can see the blob being passed to <code>reader.readAsDataURL(data);</code> but <code>return reader.result;</code> never fires, looks like I'm losing the reference to <code>reader</code></p>

<pre><code>transform(url: string, asBase64: boolean): Observable&lt;any&gt; {
        return this.http
            .get(url, {responseType: 'blob'})
            .pipe(map(val =&gt;
                &lt;any&gt;(asBase64 ? val : this.sanitizer.bypassSecurityTrustUrl(URL.createObjectURL(val)))
            )).pipe(mergeMap(data =&gt; {
                if (!asBase64) {
                    return of(data)
                } else {
                    let reader = new FileReader();
                    let eventObservable = fromEvent(reader, 'onloadend').pipe(map(() =&gt; {
                        return reader.result;
                    }));
                    reader.readAsDataURL(data);
                    return eventObservable;
                }
            }));
    }
</code></pre>
","2248174","","2248174","","2019-01-16 14:13:18","2019-01-16 16:37:51","rxjs return result of event inside map","<typescript><rxjs><rxjs6>","2","5","","","","CC BY-SA 4.0"
"54231990","1","","","2019-01-17 08:44:55","","0","142","<p>Able to catch error inside individual ajax requests using pipe operator, but how can i catch outside concat. getting error source.lift not a function. please point out where i am going wrong and what would be better option for serial requests.</p>

<pre><code>export const deleteSettingsEpic = action$ =&gt; action$.pipe(
    ofType('DELETE_SETTINGSDATA'),
    flatMap(action$ =&gt; concat(
        ajax.ajaxDelete(`${action$.payload.api}/${action$.payload.id}`)
            .pipe(
                map(r =&gt; ({ type: 'DELETE_SUCCESS' })),
                // catchError( e =&gt; of({type: 'DELETE_ERROR'}))
            ),
        ajax.get(`${action$.payload.api}`)
            .pipe(
                map(r =&gt; ({
                    type: action$.payload.getPaginationAction,
                    payload: {
                        leadSourceList: r.response.docs,
                        page: r.response.page,
                        totalPages: r.response.totalPages,
                        limit: r.response.limit,
                        totalDocs: r.response.totalDocs
                    }
                })),
                // catchError(e =&gt; of({type: 'FETCH_ERROR'}))
            ),        
            of({type: 'SET_DIMMER_FALSE'})
    ),
    catchError(e =&gt; of({type: 'FETCH_ERROR'}))
    ),
);
</code></pre>
","3376071","","","","","2019-01-17 08:44:55","catching error of multiple http requests using concat","<rxjs><rxjs6><redux-observable>","0","2","","","","CC BY-SA 4.0"
"54240118","1","54240180","","2019-01-17 16:19:44","","14","9431","<p>I am trying to develop a application using <code>ngrx/store</code> getting error. unable to figureout the issue. any one help me?</p>

<p>here is my errors:</p>

<pre><code>ERROR in src/app/store/effects/authentication.effects.ts(25,7): error TS2339: Property 'ofType' does not exist on type 'Actions&lt;Action&gt;'.
src/app/store/effects/authentication.effects.ts(29,59): error TS2339: Property 'email' does not exist on type '{}'.
src/app/store/effects/authentication.effects.ts(29,74): error TS2339: Property 'password' does not exist on type '{}'.
src/app/store/effects/authentication.effects.ts(33,73): error TS2339: Property 'email' does not exist on type '{}'.
</code></pre>

<p>typescript file :</p>

<pre><code>import { Injectable } from '@angular/core';
import { Action } from '@ngrx/store';
import { Router } from '@angular/router';
import { Actions, Effect, ofType } from '@ngrx/effects';
import { Observable,  of } from 'rxjs';
import { map, switchMap, catchError, tap } from 'rxjs/operators';

import { AuthenticationService } from './../../service/authentication.service';
import { AuthenticationActionTypes, 
         Login, LoginSuccess, 
         LoginFailure, Logout } from './../actions/authentication.actions';

@Injectable({
    providedIn: 'root'
})
export class AuthenticationEffects {

    constructor(
        private actions:Actions, 
        private authenticationService:AuthenticationService,
        private router:Router) {}

    @Effect()
        Login: Observable&lt;any&gt; = this.actions
        .ofType(AuthenticationActionTypes.LOGIN)
        .pipe(
            map((action: Login) =&gt; action.payload),
            switchMap(payload =&gt; {
                return this.authenticationService.login(payload.email, payload.password)
            .pipe(
                map((user) =&gt; {
                console.log(user);
                return new LoginSuccess({token: user.token, email: payload.email});
            }),
            catchError((error) =&gt; {
                return of(new LoginFailure({ error: error }));
            }));
    }));

    @Effect({ dispatch: false })
        LoginSuccess: Observable&lt;any&gt; = this.actions.pipe(
        ofType(AuthenticationActionTypes.LOGIN_SUCCESS),
            tap((user) =&gt; {
              localStorage.setItem('token', user.payload.token);
              localStorage.setItem('email', user.payload.email);
              this.router.navigateByUrl('/');
            })
        );

    @Effect({ dispatch: false })
        LoginFailure: Observable&lt;any&gt; = this.actions.pipe(
            ofType(AuthenticationActionTypes.LOGIN_FAILURE)
        );

    @Effect({ dispatch: false })
        public Logout: Observable&lt;any&gt; = this.actions.pipe(
            ofType(AuthenticationActionTypes.LOGOUT),
                tap((user) =&gt; {
            localStorage.removeItem('token');
            localStorage.removeItem('email');
            this.router.navigateByUrl('/login');
        })
    );

}
</code></pre>

<p>JSON File :</p>

<pre><code>{
  ""name"": ""authentication"",
  ""version"": ""0.0.0"",
  ""scripts"": {
    ""ng"": ""ng"",
    ""start"": ""ng serve"",
    ""build"": ""ng build"",
    ""test"": ""ng test"",
    ""lint"": ""ng lint"",
    ""e2e"": ""ng e2e""
  },
  ""private"": true,
  ""dependencies"": {
    ""@angular/animations"": ""~7.2.0"",
    ""@angular/common"": ""~7.2.0"",
    ""@angular/compiler"": ""~7.2.0"",
    ""@angular/core"": ""~7.2.0"",
    ""@angular/forms"": ""~7.2.0"",
    ""@angular/platform-browser"": ""~7.2.0"",
    ""@angular/platform-browser-dynamic"": ""~7.2.0"",
    ""@angular/router"": ""~7.2.0"",
    ""@ngrx/core"": ""^1.2.0"",
    ""@ngrx/effects"": ""^7.0.0"",
    ""@ngrx/store"": ""^7.0.0"",
    ""core-js"": ""^2.5.4"",
    ""rxjs"": ""~6.3.3"",
    ""tslib"": ""^1.9.0"",
    ""zone.js"": ""~0.8.26""
  },
  ""devDependencies"": {
    ""@angular-devkit/build-angular"": ""~0.12.0"",
    ""@angular/cli"": ""~7.2.2"",
    ""@angular/compiler-cli"": ""~7.2.0"",
    ""@angular/language-service"": ""~7.2.0"",
    ""@types/node"": ""~8.9.4"",
    ""@types/jasmine"": ""~2.8.8"",
    ""@types/jasminewd2"": ""~2.0.3"",
    ""codelyzer"": ""~4.5.0"",
    ""jasmine-core"": ""~2.99.1"",
    ""jasmine-spec-reporter"": ""~4.2.1"",
    ""karma"": ""~3.1.1"",
    ""karma-chrome-launcher"": ""~2.2.0"",
    ""karma-coverage-istanbul-reporter"": ""~2.0.1"",
    ""karma-jasmine"": ""~1.1.2"",
    ""karma-jasmine-html-reporter"": ""^0.2.2"",
    ""protractor"": ""~5.4.0"",
    ""ts-node"": ""~7.0.0"",
    ""tslint"": ""~5.11.0"",
    ""typescript"": ""~3.2.2""
  }
}
</code></pre>

<p>any one help me here.... thanks in advance.</p>
","218349","","","","","2019-01-17 16:23:37","Ngrx store getting error as Property 'ofType' does not exist on type","<ngrx><angular7><rxjs6><ngrx-store><ngrx-effects>","1","0","2","","","CC BY-SA 4.0"
"54248533","1","","","2019-01-18 06:06:36","","0","50","<p><strong>The error</strong>: <code>e1:You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.</code></p>

<p><strong>The code</strong>:</p>

<pre><code>// interceptor
@Injectable()
export class TokenInterceptor implements HttpInterceptor {
  constructor(private auth: AuthService) { }
@delayForToken()
  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    //code to augment token to request
    return next.handle(req);
  }
}
//..



// decorator
export function delayForToken(observableName: string) {
  let auth: AuthService;
  return (target, key, descriptor) =&gt; {
    if (descriptor === undefined) {
      descriptor = Object.getOwnPropertyDescriptor(target, key);
    }
    const om = descriptor.value;
    descriptor.value = function (...args) {
      auth = (!auth) ? injector.get(AuthService) : auth;
      const ags = args;
      const ths = this;
      return auth.onToken().pipe(take(1)).subscribe(() =&gt; {
        return om.apply(ths, ags);
      });
    };
    return descriptor;
  };
}
//..


//following is slightly irrelevant, adding them for completeness
//AuthService
private tokenSub = new ReplaySubject&lt;string&gt;(1);
constructor(private afAuth: AngularFireAuth){
  this.afAuth.idToken.subscribe((tok: string) =&gt; {
    this.tokenSub.next(tok);
  }
}
public onToken(): Observable&lt;string&gt; {
  return this.tokenSub.asObservable();
}
//..


//app.module
providers: [
  { provide: HTTP_INTERCEPTORS, useClass: TokenInterceptor, multi: true }]
//..


//component
this.rest.hitserver('param1').subscribe((response: RspType[]) =&gt; {
  this.rsps = response;
}, (error) =&gt; { console.log('e1:' + error); }, () =&gt; { });
//..


//app.module
providers: [
  { provide: HTTP_INTERCEPTORS, useClass: TokenInterceptor, multi: true }]
</code></pre>

<p><strong>Intention</strong>: I'm trying to delay the http request until I get my idToken setup, so that I can augment it to the request.</p>

<p><strong>Update</strong>: Ended up using the annotation only in the components, repeated the logic in the interceptor with a <code>switchMap</code> (thanks <em>Fan Cheung</em>):</p>

<pre><code>// @delayForToken() - Removed this annotation
intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
  if (this.auth.tok) {
    return next.handle(this.addTokenToReq(req, this.auth.tok));
  }
  return this.auth.onToken().pipe(take(1), switchMap((token: string) =&gt; {
    return next.handle(this.addTokenToReq(req, this.auth.tok));
  }));
  }
}
</code></pre>

<p>Will leave the question open to answers, if there is a way to get this working with the decorator.</p>
","234110","","234110","","2019-01-18 20:24:42","2019-01-18 20:24:42","rxjs Stream broken while using a decorator in angular 7","<angular><rxjs><decorator><rxjs6><typescript-decorator>","0","3","","","","CC BY-SA 4.0"
"54254148","1","","","2019-01-18 12:34:31","","0","514","<p>I have the nex flow with observable : </p>

<pre><code>verifyFacebookUser2(): Observable&lt;User&gt; {       
    let userFacebook = {""type"": ""facebook"", ""id_facebook"": this.userId};
    return this._us.verifyRegisterFacebookObs(userFacebook )
      .flatMap(token =&gt; {
        if (!token) {
          return Observable.of([])
        }
        else {
          return Observable.fromPromise(this.storage.set('token', token));
        }
      }, error =&gt; {
        error =&gt; console.log(""FIRST ERROR"" + JSON.stringify(error));
      })
      .catch(err =&gt; {
        if (err.status === 404) {
          throw new Error(""404"");
        } else {
          throw new Error("""");
        }
        //return Observable.of([])
      })
      .flatMap(res =&gt; {
        return Observable.fromPromise(this.storage.get('token'));
      })
      .flatMap(tokenStorage =&gt; {
        let decodedToken = this.jwtHelper.decodeToken(JSON.stringify(tokenStorage));
        let idUser = parseInt(decodedToken.id);
        return this._ups.getUserProfileObs(idUser);
      })
  }
</code></pre>

<p>As you can see, my observable return User if all flow is ok, my service verifyRegisterFacebookObs return an user : </p>

<pre><code>verifyRegisterFacebookObs(user): Observable&lt;any&gt; {
    let url = URL_SERVICIOS + '/users/verify';
    return this.http2.post(url, user)
      .map(res =&gt; res['result'])
      /*.catch(error =&gt; {
         if (error.status === 404)
           return Observable.of("""");
      })*/
  }
</code></pre>

<p>So, this flow function well when all is ok , but How can I execute another flow or observable if my service return 404 error. </p>

<p>If my service return 404 error, it does mean that user doesnt exist and i need to 
 register this user calling a new http request </p>

<p>TO use that I do the next : </p>

<pre><code>this.verifyFacebookUser2()
              .subscribe((user: User) =&gt; {
                alert(""OK"");               
              }, error =&gt; {
                alert(error);               
    // Can I call another function that call observable to do another flow ? 
                    this.registerIdFacebook(this.userId);    
                  })
</code></pre>

<p>If all is ok print ok , if I get error I need to call registerIdFacebook, so I only call to registerIdFacebook when error is emited by this._us.verifyRegisterFacebookObs(userFacebook ) and its 404.</p>

<pre><code> registerIdFacebook(id) {    
   this._us.facebookRegisterObs({""id_facebook"": id}).
    subscribe(resultado =&gt; {
      alert(JSON.stringify(resultado));
    }, error =&gt; {
      //TODO PRESENT TOAST
      alert(JSON.stringify(error));
    })
  }
</code></pre>

<p>Could someone help me to achieve that ? </p>
","10030734","","","","","2019-01-21 13:06:57","How can I break my flow on my observable to call another observable with RXJS?","<javascript><angular><rxjs><rxjs5><rxjs6>","2","0","","","","CC BY-SA 4.0"
"54258333","1","54261611","","2019-01-18 16:54:48","","1","1022","<p>New to RxJS, but I'm trying to map a single element stream to another that produces an array <em>after</em> all internal/subsequent streams are finished/loaded.  However, my inner observables don't seem to be executing.  They just get returned cold.</p>

<p>High level, I need to execute http post to upload a list of files (in two different arrays to two different endpoints).  Since they are large I emulate with a delay of 5 seconds.  The requests need to be executed in parallel, but limited to concurrently executing X at a time (here 2).  This all needs to be inside a pipe and the pipe should only allow the stream to continue <em>after</em> all posts are complete.</p>

<p><a href=""https://stackblitz.com/edit/rxjs-pnwa1b"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-pnwa1b</a></p>

<pre><code>import { map, mapTo, mergeMap, mergeAll, delay, tap, catchError, toArray } from 'rxjs/operators';
import { interval, merge, forkJoin, of, from, range, Observable } from 'rxjs';

const single = ""name"";

const first = [""abc"", ""def""];

const second = of(""ghi"", ""jkl"", ""mno"");

of(single)
.pipe(tap(val =&gt; console.log(`emit:${val}`)))
.pipe(
  map(claim =&gt; 
    merge(
      from(first).pipe(map(photo =&gt; of(photo).pipe(delay(5000)))),
      from(second).pipe(map(video =&gt; of(video).pipe(delay(5000))))
    )
    .pipe(
      mergeAll(2)
    )
    .pipe(tap(val =&gt; console.log(`emit:${val}`)))
    .pipe(toArray())
    .pipe(tap(val =&gt; console.log(`emit:${val}`)))
  )
)
.pipe(
catchError(error =&gt; {
  console.log(""error"");
  return Observable.throw(error);
})
)
.subscribe(val =&gt; console.log(`final:${val}`));
</code></pre>

<p>An inner subscribe would not wait until they are complete.  Using forkJoin would not allow me to limit the concurrent uploads.  How can I accomplish this?</p>

<p><strong>Update:</strong></p>

<p>Answer by @dmcgrandle was very helpful and led me to make the changes below that seem to be working:</p>

<pre><code>import { map, mapTo, mergeMap, mergeAll, delay, tap, catchError, toArray } from 'rxjs/operators';
import { interval, merge, forkJoin, of, from, range, Observable, throwError } from 'rxjs';

const single = ""name"";

const first = [""abc"", ""def""];

const second = of(""ghi"", ""jkl"", ""mno"");

of(single)
.pipe(tap(val =&gt; console.log(`emit:${val}`)))
.pipe(
  mergeMap(claim =&gt;
    merge(
      from(first).pipe(map(photo =&gt; of(photo).pipe(delay(5000)).pipe(tap(val =&gt; console.log(`emit:${val}`))))),
      from(second).pipe(map(video =&gt; of(video).pipe(delay(5000)).pipe(tap(val =&gt; console.log(`emit:${val}`)))))
    )
  ),
  mergeAll(2),
  toArray()
)
.pipe(
catchError(error =&gt; {
  console.log(""error"");
  return throwError(error);
})
)
.subscribe(val =&gt; console.log(`final:${val}`));
</code></pre>
","9056238","","9056238","","2019-01-18 22:11:26","2019-01-18 22:11:26","In RxJS, map not executing inner mapped observable","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54258968","1","54444535","","2019-01-18 17:40:51","","5","3838","<p>I'm upgrading to angular7 with rxjs6: in <code>mouseWheelEvent</code> type I am getting <code>""Property 'wheelDelta' does not exist on type 'WheelEvent'""</code>.</p>

<p>Do we have any alternative for <code>wheelDelta</code>?</p>

<pre><code>mouseWheelFunc(event: MouseWheelEvent): void {

    //  var event = window.event || event; // old IE support

    let delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.detail)));

    if ( delta &gt; 0) {
      this.mouseWheelUp.emit(event);
    } else if ( delta &lt; 0) {
      this.mouseWheelDown.emit(event);
    }

    // for IE
    event.returnValue = false;
    // for Chrome and Firefox
    if ( event.preventDefault) {
      event.preventDefault();
    }
  }
</code></pre>

<blockquote>
  <p>ERROR in
  src/modules/components/numeric-stepper/mousewheel.directive.ts(23,49):
  error TS2339: Property 'wheelDelta' does not exist on type
  'WheelEvent'.</p>
</blockquote>
","10934686","","5052566","","2019-01-18 19:26:27","2019-01-30 15:54:54","How to fix "" Property 'wheelDelta' does not exist on type 'WheelEvent' "" while upgrading to angular 7,rxjs6?","<angular7><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"54260539","1","","","2019-01-18 19:47:27","","1","77","<p>Imagine a service that has three endpoints.</p>

<ol>
<li>Submit a job and get back a job ID</li>
<li>Submit a status request and get back a status</li>
<li>Submit a results request and get back results</li>
</ol>

<p>I need a solution to submit the job and poll for results until the status of the job is done. Because the status and results endpoints are independent, I need to make sure I make one last results request after it is determined that the status is DONE.</p>

<p>I have tried using many rxjs operators to no avail. I can get the polling easy but the hard part is stoping the polling at the exact right time. When I use takeWhile or takeUntil, my polling stops before I can get the results.</p>

<pre><code>return submitJob(request).pipe(
  delay(500), // Delay start of poll
  switchMap(job =&gt; getResults(job).pipe(
    repeatWhen(c =&gt; c.pipe(delay(1000))), // Keep getting results every second
    takeUntil(getStatus(job).pipe(
      filter(status =&gt; status.done)
    ))
  )
);
</code></pre>

<p>The problem is, the status of the Job is done immediately and the results call is canceled. My code never actually submits a results request. I need to make at least one call to get results AFTER the status comes back as done.</p>
","6728709","","6296561","","2019-01-19 09:11:59","2019-01-19 09:11:59","How can I poll for results from a job and terminate when status is done using rxjs6?","<rxjs><polling><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54270278","1","54270744","","2019-01-19 18:46:12","","1","42","<p>we create </p>

<blockquote>
  <p>ob.pipe(map(),map(),map())</p>
</blockquote>

<p>all the time, well it should be possible to have </p>

<blockquote>
  <p>let myMaps = [map(),map(),map()]</p>
</blockquote>

<p>then later call </p>

<blockquote>
  <p>ob.pipe(myMaps)</p>
</blockquote>

<p>somehow.</p>

<p>This is simplified version of my use case in typescript</p>

<pre><code>declare type InterceptorFunc = (m: Message) =&gt; Observable &lt; Message &gt;

  export function interceptorMap(interceptorFunc: InterceptorFunc):
  (source: Observable &lt; Message &gt; ) =&gt; Observable &lt; Message &gt; {
    console.log(""interceptorMap"") //[1]never see this in the console
    return (source: Observable &lt; Message &gt; ) =&gt; source.pipe(flatMap(e =&gt; {
      console.log(""interceptorMap: msg: "", e) //[2]nor this
      return interceptorFunc(e);
    }));
  }

addInterceptor(interceptor: Function /*InterceptorFunc*/ ) {
  this.interceptorFuncArray.push( &lt; InterceptorFunc &gt; interceptor)
}

/**
 * Apply interceptors
 */
//message intercept

( &lt; any &gt; this.preReplayEventsSubject.asObservable()).pipe(
    ...(this.interceptorFuncArray.map(f =&gt; interceptorMap(f))),
    map((m: Message) =&gt; {
      console.log(""Message after apply interceptors: "", m) //[3]see this in the console and the message appears like it has never flowed through any interceptor Funcs in the array
      return m;
    }))
  .subscribe((m: Message) =&gt; {//[4]
    this.replayEventsSubject.next(m);
  });
</code></pre>

<p>So in comment [1] and [2] the console.log statements inside the custom operator, are never executed. In comment [3] the Message objects which are changed in the operators, are unchanged, but the fact that this console.log statement executes, would suggest the event has to pass through the spread array, to get there.</p>

<p>I tried defining a InterceptorFunc which returns null and then pipped that into a filter(e => !!) the comment [3] and [4] code still runs where the filter with null event should stop the flow for that Message object completely.</p>

<p>Can anyone explain why this is happening?</p>
","536187","","536187","","2019-01-19 18:52:43","2019-01-21 10:27:53","Spreading arrays into arguments, doesn't seem to work for Observable.pipe(...myOperatorsArray)","<typescript><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54278407","1","","","2019-01-20 16:17:23","","0","179","<p>I use <code>Angular 6.1.10</code> and <code>rxjs 6.3.3</code>. I have some service and this method, which get data, when user go to main page (""/""):</p>

<pre><code>getCampaigns(): Observable&lt;CampaignDto[]&gt; {
        return this.http.get&lt;CampaignDto[]&gt;(this.campaignsUrl)
            .pipe(
                tap(campaigns =&gt; console.log(`fetched ${campaigns.length} campaigns`)),
                catchError(this.errorReporter.handleError('getCampaigns', []))
            );
    }
</code></pre>

<p>It's work, but when I run the app and try to refresh the page by pressing F5 quickly for example two times, I get an error in browser console:
dev mode:
<a href=""https://i.stack.imgur.com/pm4H5.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pm4H5.jpg"" alt=""enter image description here""></a></p>

<p>prod mode:
<a href=""https://i.stack.imgur.com/DILP9.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DILP9.jpg"" alt=""enter image description here""></a></p>

<p>If I press F5 slowly when the previous page refresh worked, there is no error! I broke my brain, why is this mistake happening? The error occurs only in the Firefox browser 60.4.0 esr is possible and below, on the latest versions of Firefox and Chrome no errors. Any help.</p>

<p>What's wrong? Maybe this is a bug in <code>rxjs</code>? It's not <code>CORS</code> problem! My frontend and backand use one url <code>localhost:8080</code>. Problem exist in dev and prod modes.</p>

<p><strong>UPDATE</strong>:</p>

<p>I have <code>TokenInterceptor</code>:</p>

<pre><code>@Injectable()
export class TokenInterceptor implements HttpInterceptor {

    constructor(private inj: Injector) {
    }

    intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
        const auth = this.inj.get(AuthService);
        const xAuthToken = auth.xAuthToken;
        if (xAuthToken) {
            console.log(`TokenInterceptor. Getting token: ${xAuthToken}`);
            request = request.clone({
                setHeaders: {
                    'x-auth-token': `${auth.xAuthToken}`
                }
            });
        }
        return next.handle(request);
    }
}
</code></pre>
","8973019","","8973019","","2019-01-21 10:42:54","2019-01-21 10:42:54","Http failure response for (unknown url): 0 Unknown Error in Firefox when page reloading","<angular><firefox><rxjs><rxjs6>","0","5","","","","CC BY-SA 4.0"
"54289549","1","54296808","","2019-01-21 12:00:30","","22","13334","<p>I do not understand from <a href=""https://rxjs-dev.firebaseapp.com/api/operators/tap"" rel=""noreferrer"">the docs</a>. Could anyone explain it to me?</p>
","10842900","","10842900","","2019-01-21 12:34:30","2020-01-17 06:33:37","When should we use the RxJS tap operator?","<rxjs><rxjs6>","3","4","2","","","CC BY-SA 4.0"
"54303447","1","54303798","","2019-01-22 07:46:51","","2","587","<p>Has anyone used <code>toPromise</code> and <code>Promise.all</code> from rxjs in http? Please give me an example.<br>
How can I check both of the request is success in component with <code>promise.all</code> return some message like API is success?</p>

<pre class=""lang-js prettyprint-override""><code>getPostAsync() {
    return this.http.get('https://jsonplaceholder.typicode.com/posts')
                    .pipe(map((res:Response) =&gt; { return res.json();}))
                    .pipe(catchError((error) =&gt; { return throwError(error);}))
}
</code></pre>

<pre class=""lang-js prettyprint-override""><code>getPostAsync1() {
    return this.http.get('https://jsonplaceholder.typicode.com/posts/1')
                    .pipe(map((res:Response) =&gt; { return res.json();}))
                    .pipe(catchError((error) =&gt; { return throwError(error);}))
}
</code></pre>
","10842900","","7404943","","2019-01-22 08:13:33","2019-01-22 21:05:12","does anyone have used toPromise and Promise.all from rxjs in http","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"54310606","1","54326416","","2019-01-22 14:37:50","","0","387","<p>I'm working on an angular project and would like to know the best approach to implement the following.</p>

<blockquote>
  <p>Requirement is: To get image from cache if available otherwise get the
  image from web socket server.</p>
</blockquote>

<p>I'm able to get this done using the below code snippet.</p>

<pre><code>import { Observable,Observer, Subject } from 'rxjs/Rx';
import { webSocket } from 'rxjs/webSocket'

.....

if(key in localStorage)
{
  result = localStorage.getItem(key);
}
else{
    this.websocketClient = 
&lt;Subject&lt;Message&gt;&gt;this.imgWebSocketService.connect();
    this.websocketClient.subscribe(
      (msg) =&gt; this.onMessageReceived(msg),
      (err) =&gt; this.onError(err),
      () =&gt; console.log('complete')
    );
    this.websocketClient.next(message);
}
</code></pre>

<p>Now I'm trying to write this inside a separate service named <code>ImageCacheService</code> and add a method to retrieve the image either from cache or from server. So for that, I'm stuck up and would like to get advice on the best approach in Angular 6.</p>

<p>What I need is to have a function like <code>getImage(request:Message)</code> which will do these operation and return the image data.</p>

<pre><code> getImage(request:Message,useCache:boolean):any{
    var result = null;
    if(key in localStorage){
       result = localStorage.getItem(key);
    }
    else{
       this.websocketClient.subscribe(
           (msg) =&gt;  result = msg,
           (err) =&gt; this.onError(err),
           () =&gt; console.log('complete')
       );
       this.websocketClient.next(message);
    }
    return result;
 }
</code></pre>

<p>But since the message received in async way, I understand that the above code won't work as expected. I know writing a callback can solve the problem, but I'm looking for any other better way to achieve this.</p>

<p>So can anyone please let me know how to do this in the best possible angular/typescript way.</p>
","1672927","","","","","2019-01-23 11:38:23","Send a websocket message from a sync method and return the data in same method","<typescript><websocket><async-await><angular6><rxjs6>","1","4","2","","","CC BY-SA 4.0"
"54321216","1","","","2019-01-23 06:30:05","","1","1847","<p>In my Angular 7 app I have a login service which tracks whether or not the person is logged in and an admin.  Only the initial <code>true</code> value from the <code>login</code> method is being seen for some reason.  In the service I have this:</p>

<pre class=""lang-js prettyprint-override""><code>private admin = new BehaviorSubject(false);
admin$ = this.admin.asObservable();

login(user: string, pwd: string): Observable&lt;ILoginData&gt; {
    sessionStorage.removeItem('admin');

    const coded = btoa(`${user}:${pwd}`);
    const headers = new HttpHeaders({
        'Authorization': `Basic ${coded}`,
    });

    return this.http
        .post&lt;ILoginData&gt;(`${this.baseUrl}/login`, null, {headers: headers})
        .pipe(
            tap(x =&gt; {
                sessionStorage.setItem('admin', JSON.stringify(x.admin));

                this.admin.next(x.admin);
            })
        )
}

logout(): void {
    sessionStorage.removeItem('admin');
    this.admin.next(false);
}
</code></pre>

<p>And then the <code>app.component.ts</code> subscribes to that:</p>

<pre class=""lang-js prettyprint-override""><code>private subscription: Subscription;

ngOnInit(): void {
    this.subscription = this.producerService.admin$.subscribe(x =&gt; {
        console.info(`Admin being set to ${x}`);
        this.showAdminSection = x;
    });
}

ngOnDestroy(): void {
    if (this.subscription) {
        this.subscription.unsubscribe();
    }
}
</code></pre>

<p>What I'm seeing is when I log in the subscription gets called with a value, but when I call the <code>logout()</code> method, even though I'm sending a <code>false</code> update, the message is never printed to the console saying that it's being set to <code>false</code>.  It's like only the first value is emitted and then the subscription shuts down for some reason.</p>

<p>I'm not sure why the <code>false</code> doesn't appear to be getting sent/received.</p>
","1455351","","","","","2019-01-23 07:06:28","BehaviorSubject not emitting values","<angular><angular7><rxjs6><behaviorsubject>","1","6","","","","CC BY-SA 4.0"
"54322194","1","54322669","","2019-01-23 07:41:08","","0","176","<p><a href=""https://codecraft.tv/courses/angular/es6-typescript/promises/#_creating_a_promise"" rel=""nofollow noreferrer"">Here</a></p>

<blockquote>
  <p>Inside this inner function we perform our asynchronous processing and
  then when we are ready we call resolve(), like so:</p>
</blockquote>

<pre><code>var promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    console.log(""Async Work Complete"");
    resolve();
  }, 1000);
});
</code></pre>

<p>For concrete code: <a href=""https://github.com/AngularTemplates/firebase-authentication-with-angular-5/blob/master/src/app/core/user.service.ts"" rel=""nofollow noreferrer"">here</a> firebase authentication github project,</p>

<pre><code> getCurrentUser(){
    return new Promise&lt;any&gt;((resolve, reject) =&gt; {
      var user = firebase.auth().onAuthStateChanged(function(user){
        if (user) {
          resolve(user);
        } else {
          reject('No user logged in');
        }
      })
    })
  }
</code></pre>

<p>and <a href=""https://stackoverflow.com/a/45785513/492258"">here</a> stated </p>

<blockquote>
  <p>For rxjs 6.0.0 use:</p>
</blockquote>

<pre><code>import { from } from 'rxjs';

var observableFromPromise =  from(promiseSrc);
</code></pre>

<p>I could imagine solution would be </p>

<pre><code>  getCurrentUser() {
    return from(firebase.auth().onAuthStateChanged(function (user) {
      user.getIdToken().then(x =&gt; {
        return x;
      })
    })
    )
  }
</code></pre>

<p>or </p>

<pre><code>getCurrentUser() {
    firebase.auth().onAuthStateChanged(function (user) {
      return from(user.getIdToken());
    })

  }
</code></pre>

<p>My question is what is the equivalent second code snippet to <code>from</code> expression in callback?</p>
","492258","","492258","","2019-01-23 08:03:44","2019-01-23 08:18:01","transform to promise in callback to ""from"" rxjs6","<angular><angular-promise><rxjs6>","2","3","","","","CC BY-SA 4.0"
"54322583","1","","","2019-01-23 08:08:37","","1","164","<p>I have a forEach loop which sends http post requests for each item in the loop but for an unknown reason it skips the first item. What could I be doing wrong?
Here is the code:</p>

<pre><code>this.shoppingCartProducts.forEach(cartProduct =&gt; {
  this.productOrderSrv.addProductToOrder(cartProduct)
            .subscribe((result) =&gt; {
              console.log(cartProduct);
            }, error =&gt; {
              // error has occured
            });
}
</code></pre>

<p>The productOrderSrv.addProductToOrder calls the http post request which is a service injected in this component.</p>

<p>I have also tried to implement the forkJoin rxjs method but it also skips the first item (in this case the cartProduct).</p>

<p>Please give me some info on something that I could be doing wrong or missing.</p>
","10176181","","","","","2019-01-23 08:08:37","HTTP POST requests in a foreach loop in angular 6 skipping first item","<angular6><observable><rxjs6>","0","11","1","","","CC BY-SA 4.0"
"54336743","1","54336774","","2019-01-23 22:34:25","","1","268","<p>I'm struggling to figure the correct way to filter an array of objects using RxJS 6.</p>

<p>Here's the scenario. I have <code>users: User[]</code>, <code>filter: FormControl</code>, and another array of <code>filteredUsers: User[]</code>. What I would like to do is filter the list the users based on the value contained in the <code>filter</code>.  The only way I was able to figure this out was to use <code>tap</code>, and while this works, it just doesn't seem like the right way to do it...plus the whole list is ""filtered out"" until the filter control has its first valueChange.</p>

<pre><code>this.filter.valueChanges.pipe(
  tap((term) =&gt; {
    this.filteredUsers = this.users.filter(u =&gt; u.name.indexOf(term) != -1)
  })).subscribe()
</code></pre>

<p>Any help would be greatly appreciated.</p>
","2476111","","","","","2019-01-23 22:47:18","Filter an array of objects using an Observable filter","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"54344923","1","54348394","","2019-01-24 10:52:03","","3","702","<p>I am working on an effect, that will be polling server.</p>

<p>What I want to achieve is as follows:</p>

<p>1) Send GET request to server</p>

<p>2) After response is received, wait 3 seconds</p>

<p>3) Send same GET request</p>

<p>4) After response is received, wait 3 seconds</p>

<p>5) Send same GET request</p>

<p>... and so on.</p>

<p>The code that I have now, doesn't quite work, as it polls server every 3 seconds, no matter if response was received or not:</p>

<pre><code>@Effect()
pollEntries$ = this.actions$.pipe(
  ofType(SubnetBrowserPageActions.SubnetBrowserPageActionTypes.StartPollingSubnetEntries),
  switchMap(() =&gt; {
    return timer(0, 3000);
  }),
  takeUntil(this.actions$.pipe(ofType(SubnetBrowserPageActions.SubnetBrowserPageActionTypes.StopPollingSubnetEntries))),
  switchMap(() =&gt; {
    return this.subnetBrowserService.getSubnetEntries();
  }),
  map((entries) =&gt; {
    return new SubnetBrowserApiActions.LoadEntriesSucces({ entries });
  }),
  catchError((error) =&gt; {
    return of(new SubnetBrowserApiActions.LoadEntriesFailure({ error }));
  }),
);
</code></pre>

<p>Another thing that I am struggling with is how to stop polling. If I emit <code>StopPollingSubnetEntries</code> action before request is sent to server, then it works fine - however if I emit it after request is sent, then I receive one more subsequent response, before polling stops.</p>
","4524996","","","","","2020-10-16 13:21:45","Polling server after each server response + delay","<angular><rxjs><ngrx><rxjs6><ngrx-effects>","3","4","","","","CC BY-SA 4.0"
"54392033","1","54396433","","2019-01-27 19:26:49","","0","121","<p>This is what my Todo class looks like. I guess it has something to do with an update and what I declared in the constructor. Thankful for any clue.</p>

<pre><code>  export class Todo {
  id: number;
  title = '';
  complete = false;

  constructor(values: Object = {}) {
    Object.assign(this, values);
  }
}
</code></pre>
","10969617","","","","","2019-01-28 06:13:33","Uncaught Error: Can't resolve all parameters for Todo: (?)","<angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54395824","1","","","2019-01-28 05:06:22","","5","808","<p>In RxJS, filters such as <code>auditTime</code> and <code>throttleTime</code> emit an Observable (in different ways) after a certain duration has passed. I need to emit an Observable and <em>then</em> wait for a period of time before emitting the next value.</p>

<p>In my case I am working in Angular. For example, this code:</p>

<pre><code>this.fooService$.pipe(throttleTime(10000)).subscribe(() =&gt; this.doSomething());
</code></pre>

<p>will not accomplish what I need because the emission happens at the end of the duration. I need the opposite: the emission happens and then a delay. How can I accomplish this?</p>
","3357958","","3357958","","2019-01-28 05:32:55","2019-01-28 07:36:33","How to emit an Observable and then throttle the subscription","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","4","2","","","CC BY-SA 4.0"
"54409717","1","","","2019-01-28 20:22:20","","1","34","<p>I got 5 behaviour subjects in a service, where I collect information from other components to finally combine them in one last object in a <strong>final component</strong>. <strong>My Problem is</strong> I can't get the final object to have every element that is collected. </p>

<p>The detail is that in the first component the user chooses one of two roads to take, so at the <strong>final component</strong> -before I suscribe to everything- I need to see what did the user chose and just consume that observable (<code>forthObsOne or forthObsTwo</code>) and not his non-chosen brother.</p>

<p>my-service.service.ts</p>

<pre><code>private firstObs = new BehaviorSubject(new Class1());
private secondObs = new BehaviorSubject(new Class2());
private thirdObs = new BehaviorSubject(new Class5());

//this are the two brother component to be chosen from
private forthObsOne = new BehaviorSubject(new Class3());
private forthObsTwo = new BehaviorSubject(new Class3);

// This is the obs for the option component where i choose if
// i take the forthObsOne or the forthObsTwo road
private optionObs = new BehaviorSubject(new Class6());

// Now i project those subjects as an observable like the docs recommendation
firstObs$ = this.firstObs.asObservable();
secondObs$ = this.secondObs.asObservable();
thirdObs$ = this.thirdObs.asObservable();
forthObsOne$ = this.forthObsOne.asObservable();
forthObsTwo$ = this.forthObsTwo.asObservable();
optionObs$ = this.optionObs.asObservable();

// Methods for every subject to pass the data from where they are called
firstObsNext(data: Class1) {
  this.firstObs.next(data)
} 

secondObsNext(data: Class1) {
  this.secondObs.next(data)
}

thirdObsNext(data: Class1) {
  this.thirdObs.next(data)
}

forthObsOneNext(data: Class1) {
  this.forthObsOne.next(data)
}

forthObsTwoNext(data: Class1) {
  this.forthObsTwo.next(data)
}

optionObsNext(data: Class1) {
  this.optionObs.next(data)
}

// The latest thing i tried is with combielatest where i combine 
// every observable and try to assign the data to a new big object.
</code></pre>

<p>I've tried first subscribing to <code>optionObs</code> and making and if/else statement to take the <code>forthObsOne</code> or <code>forthObsTwo</code> road. But at the end I got some elements undefined.
I tried delaying everything with a timeout but i think that's more like a hack and not very professional</p>

<p>At last I tried with <code>combinelatest</code> but failed miserably as I think i'm not understanding it that well (I've watched videos and docs but still can't apply that to this specific problem).</p>

<p>I expect to get a final object with everything I have collected through the components.</p>

<p>I hope it clear enough. Thanks.</p>

<p><strong>UPDATE</strong>
I'm trying this with the <code>forkJoin</code> approach I've been recommended</p>

<pre><code>let observables1 = [
  this.datosAdminAcumul$,
  this.escalaAcumul$,
  this.seccionesAcumul$,
  this.rubricaUnoAcumul$
];
let observables2 = [
  this.datosAdminAcumul$,
  this.escalaAcumul$,
  this.seccionesAcumul$,
  this.rubricaDosAcumul$
];

this.optionObs$.subscribe(option =&gt; {
  if (option == ""one"") {
    forkJoin(...observables1).subscribe(x =&gt; {
      (data1 = x[0]),
        (data2 = x[1]),
        (data3 = x[2]),
        (data4 = x[3]);
        // i've tried `console.log()` here but it returns me four undefined values
    });
       // i've tried `console.log()` here, same result.
  } else {
    forkJoin(...observables2).subscribe(x =&gt; {
      let pautaFinal = {
        admin: x[0],
        escala: x[1],
        rubrica: x[2],
        secciones: x[3]
      };
    });
</code></pre>
","8579973","","8579973","","2019-01-28 20:52:38","2019-01-28 20:52:38","chain 1 observable result with a stream of observables for a final const","<angular><typescript><angular6><rxjs6>","1","3","","","","CC BY-SA 4.0"
"54416988","1","","","2019-01-29 08:46:30","","1","520","<p>I have a component which is subscribed to an event that is fired multiple times at the same time. This subscription starts a request to the server to fetch data. What I want to achieve is firing only one single request.</p>

<p>Instead I receive lots of canceled requests until the final request is finished:</p>

<p><a href=""https://i.stack.imgur.com/6qXk2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6qXk2.png"" alt=""enter image description here""></a></p>

<p><strong>Updated:</strong></p>

<pre><code>this.someObject.onEvent()
  .pipe(switchMap((filterCriterias) =&gt; this.loadData(filterCriterias)))
  .subscribe((res) =&gt; {
    this.data = res;
});
</code></pre>

<p>Is there a way to sort of create a catch basin and only fire last request as in the picture (to not get canceled requests in the first place)?   </p>

<p>I'm using RxJs 6.3</p>

<p>Thanks in advance!</p>
","7145135","","7145135","","2019-01-29 10:24:10","2019-01-29 10:24:10","RxJS prevent switchMap to send request in first place","<angular><typescript><rxjs><rxjs6>","2","8","","","","CC BY-SA 4.0"
"54433415","1","54524199","","2019-01-30 04:34:35","","0","1409","<p>So I have a product search effect. Basically I first dispatch a search_start action, which has a payload of parameters for that search, The effect takes that then goes to a service and I get that response back, which gives me a list of products. I want to be able to then do two things:</p>

<ol>
<li>Dispatch a successful action with the collection of products</li>
<li>Save the parameters for that search to be used later for 'search history' which is currently in the 'action.payload'</li>
</ol>

<p>I'm having a problem the 2nd piece mainly because doing switchMap and having a returnType of 'SearchResultResponseType' means that I can't now do a SearchSave(action.payload) mainly because the payload has the type of 'SearchParameterType'. So I can only execute my SearchSuccess action.</p>

<p>Is there anyway this can be accomplished? I tried changing the response type to a super type that takes both SearchParameterType and SearchResultResponseType as two properties on that type and having my productSearchService return that instead but that seemed to yield errors as well. Isn't there a simper way?</p>

<pre><code>       export class ProductSearchEffects {
          @Effect() startSearch$: Observable&lt;
            ActionWithPayload&lt;SearchResultResponseType&gt; | Observable&lt;Action&gt;
          &gt; = this.actions$.pipe(
            ofType&lt;SearchStart&gt;(ProductSearchActions.SEARCH_START),
            mergeMap(action =&gt;
              this.productSearchService.fetchSearchResults(action.payload)
                .pipe(
// if successful then save search and dispatch search success
                switchMap((data: SearchResultResponseType) =&gt; [
                    new SearchSave(action.payload),
                    new SearchSuccess(data),
                  ]),

                  catchError(() =&gt; of(new SearchFail())),
                ),
            ),
          );
</code></pre>
","1535129","","","","","2019-02-04 20:56:28","How to perform two different types of action after successful service call NGRX","<angular><rxjs><ngrx><rxjs6><ngrx-effects>","2","0","2","","","CC BY-SA 4.0"
"54437751","1","","","2019-01-30 09:56:32","","0","1816","<p>I was working on a new Angular App. I created that using Angular CLI with <code>ng new.</code> </p>

<p>When I tried to lauch that app using npm start , I got following error : </p>

<pre><code>ERROR in node_modules/rxjs/internal/types.d.ts(81,44): error TS1005: ';' expected.
node_modules/rxjs/internal/types.d.ts(81,74): error TS1005: ';' expected.
node_modules/rxjs/internal/types.d.ts(81,77): error TS1109: Expression expected.
</code></pre>

<p>I inspected the dependencies using <code>ng -version</code> inside that project and found below output. </p>

<pre><code>Angular CLI: 6.0.8
Node: 8.11.3
OS: win32 x64
Angular: 6.1.10
... animations, common, compiler, compiler-cli, core, forms
... http, language-service, platform-browser
... platform-browser-dynamic, router

Package                           Version
-----------------------------------------------------------
@angular-devkit/architect         0.6.8
@angular-devkit/build-angular     0.6.8
@angular-devkit/build-optimizer   0.6.8
@angular-devkit/core              0.6.8
@angular-devkit/schematics        0.6.8
@angular/cdk                      7.2.1
@angular/cli                      6.0.8
@angular/material                 7.2.1
@ngtools/webpack                  6.0.8
@schematics/angular               0.6.8
@schematics/update                0.6.8
rxjs                              6.3.3
typescript                        2.7.2
webpack                           4.8.3
</code></pre>

<p>I had another Angular app installed on my machine . </p>

<p>I ran <code>ng -version</code> again in this app giving below result. </p>

<pre><code>Angular CLI: 6.0.8
Node: 8.11.3
OS: win32 x64
Angular: 6.1.10
... animations, common, compiler, compiler-cli, core, forms
... http, language-service, platform-browser
... platform-browser-dynamic, router

Package                           Version
-----------------------------------------------------------
@angular-devkit/architect         0.6.8
@angular-devkit/build-angular     0.6.8
@angular-devkit/build-optimizer   0.6.8
@angular-devkit/core              0.6.8
@angular-devkit/schematics        0.6.8
@angular/cli                      6.0.8
@ngtools/webpack                  6.0.8
@schematics/angular               0.6.8
@schematics/update                0.6.8
rxjs                              6.4.0
typescript                        2.7.2
webpack                           4.8.3
</code></pre>

<p>Comapring the results , I got below difference  </p>

<p><strong>App Giving error has</strong> </p>

<pre><code>rxjs                              6.4.0
</code></pre>

<p><strong>And App running fine has</strong> </p>

<pre><code>rxjs                              6.3.3
</code></pre>

<p>I changed the rxjs version in not running app to below in <code>package.json</code> like below : </p>

<pre><code>""rxjs"": ""6.3.3"" 
</code></pre>

<p>and the problem got resolved </p>

<p>So I have below questions , can anybody please answer these ? </p>

<p>1)I am not able to analyse why downgrading <code>rxjs version</code> resolved the issue ? Since all other component versions are the same in both the apps . First app (not running one uses angular material as addition)</p>

<p>2)I had two apps to compare the versions . Had it not been the case , is there any way to find out this error is due to rxjs downgrading of version ? </p>
","1281182","","","","","2019-01-30 10:04:07","rxjs version error while running npm install","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54441514","1","54443302","","2019-01-30 13:16:22","","1","2859","<p>I updated my app to Angular 7 and RxJS 6.3.3 and I've got a problems during making changes into my code. I really need help with that, because I can't to find solution into google or stack overflow.</p>

<p>My imports:</p>

<pre><code>import { Observable, of } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { Headers, ResponseContentType, Response } from '@angular/http';
import { HttpClient } from '@angular/common/http';
</code></pre>

<p>Here is code of my <code>test</code> function:</p>

<pre><code>protected test(response: Response): Observable&lt;MyResponseClass | null&gt; {
    const status = response.status;

    if (status === 200) {
       let result200: any = null;
       ... some code ...
       return of&lt;MyResponseClass | null&gt;(result200);
    }
    return of&lt;MyResponseClass | null&gt;(&lt;any&gt;null);
}
</code></pre>

<p>Here is <code>MyResponseClass</code> pseudocode:</p>

<pre><code>class MyResponseClass implements IMyResponseClass {
    property1?: string | undefined;
    property2?: string | undefined;
    property3: boolean;

    ...
}
</code></pre>

<p><code>IMyResponseClass</code> pseudocode:</p>

<pre><code>interface IMyResponseClass {
    property1?: string | undefined;
    property2?: string | undefined;
    property3: boolean;
}
</code></pre>

<p>Here is my code of my <code>get()</code> function:</p>

<pre><code>get(): Observable&lt;MyResponseClass | null&gt; {
    let url_ = some_url;

    let options_: any = {
        method: ""get"",
        headers: new Headers({
            ""Content-Type"": ""application/json"",
            ""Accept"": ""application/json""
        })
    };

    return this.http.request(url_, options_).pipe(
        map((response_: any) =&gt; { return this.test(response_); })),
        catchError((err: any, caught: Observable&lt;MyResponseClass | null&gt;) =&gt; {
            if (caught instanceof Response) {
                try {
                    return this.test(&lt;any&gt;caught);
                } catch (e) {
                    return &lt;MyResponseClass | null&gt;&lt;any&gt;Observable.throw(e);
                }
            } else
            return &lt;MyResponseClass | null&gt;&lt;any&gt;Observable.throw(caught);
        })
    );
}
</code></pre>

<p>I'm still getting this error:</p>

<p><a href=""https://i.stack.imgur.com/oL3Fj.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oL3Fj.jpg"" alt=""enter image description here""></a></p>

<p>Here is a text version of this error:</p>

<pre><code>Argument of type '(err: any, caught: Observable&lt;MyResponseClass&gt;) =&gt; MyResponseClass | Observable&lt;MyResponseClass&gt;' is not assignable to parameter of type '(err: any, caught: Observable&lt;MyResponseClass&gt;) =&gt; ObservableInput&lt;MyResponseClass&gt;'.
  Type 'MyResponseClass | Observable&lt;MyResponseClass&gt;' is not assignable to type 'ObservableInput&lt;MyResponseClass&gt;'.
    Type 'MyResponseClass' is not assignable to type 'ObservableInput&lt;MyResponseClass&gt;'.
      Type 'MyResponseClass' is not assignable to type 'Iterable&lt;MyResponseClass&gt;'.
        Property '[Symbol.iterator]' is missing in type 'MyResponseClass'.
</code></pre>

<p>What I'm doing wrong? Will you help me?</p>

<hr>

<p><a href=""https://stackoverflow.com/questions/54438854/how-to-change-httpclient-code-after-update-app-to-angular-7"">Here</a> is the previous step which I did before that error. Maybe did I something wrong on previous step?</p>

<hr>

<p>I made a changes after read all of comments so now the get() function looks like that:</p>

<pre><code>return this.http.request(url_, options_).pipe(
            map((response_: any) =&gt; { return this.test(response_); }),
            catchError((err: any, caught: Observable&lt;MyResponseClass | null&gt;) =&gt; {
                if (caught instanceof Response) {
                    try {
                        return this.test(&lt;any&gt;caught);
                    } catch (e) {
                        return throwError(e);
                    }
                } else
                    return throwError(caught);
            })
        );
</code></pre>

<p>and I'm still getting error:</p>

<p><a href=""https://i.stack.imgur.com/LgPoa.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LgPoa.jpg"" alt=""enter image description here""></a></p>
","8479567","","8479567","","2019-01-31 08:14:56","2019-01-31 08:14:56","Problem with Observable after update app to Angular 7 and RxJS 6.3.3","<angular><rxjs><angular7><angular-httpclient><rxjs6>","2","8","","","","CC BY-SA 4.0"
"54451257","1","","","2019-01-30 23:41:12","","1","3275","<p><a href=""https://i.stack.imgur.com/t7uce.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/t7uce.png"" alt=""enter image description here""></a>I am trying to migrate from rx5 to rx6 by following the guide <a href=""https://github.com/reactivex/rxjs/blob/HEAD/docs_app/content/guide/v6/migration.md"" rel=""nofollow noreferrer"">here</a>. Initially, I installed along with the rxjs-compat package and everything works fine. However, when I try to remove the rxjs-compat package, I am getting an exception <code>Cannot find module 'rxjs-compat/Subscription'</code>. I used the rxjs-5-to-6-migrate to perform the migration</p>

<p>I am using this statement for Subscription : import { Subscription } from ""rxjs""; </p>

<p>For reference this is my branch- <a href=""https://github.com/akshita31/omnisharp-vscode/tree/rxjs_update"" rel=""nofollow noreferrer"">https://github.com/akshita31/omnisharp-vscode/tree/rxjs_update</a> and this is the corresponding pull request that lists all the changes - <a href=""https://github.com/OmniSharp/omnisharp-vscode/pull/2830"" rel=""nofollow noreferrer"">https://github.com/OmniSharp/omnisharp-vscode/pull/2830</a></p>
","4950937","","4950937","","2019-01-31 02:38:40","2019-02-01 00:40:46","Cannot find module 'rxjs-compat/Subscription'","<rxjs><rxjs5><rxjs6>","2","8","","","","CC BY-SA 4.0"
"54456869","1","54458296","","2019-01-31 09:03:51","","0","723","<p>With plain <code>Rxjs</code>, I managed to implement a ""countdown"" behavior by invoking a method each second like this, until there's no more time left: </p>

<pre><code>const time = 5 
var timer$ = Rx.Observable.interval(1000) 
timer$
  .take(time)
  .map((v)=&gt; {
           const remaining = time - 1 - v
           return remaining; 
      })
  .subscribe((v)=&gt;console.log('Countdown', v))
</code></pre>

<p>Now, with <code>redux-observable</code>, I want to implement a countdown behavior, where I get the initial time (e.g 5000 seconds) and I dispatch an action each second until the initial time is down to 0. So far I have this:</p>

<pre><code>action$.pipe(
        ofType(START_COUNTDOWN),
        switchMap(() =&gt;
            interval(1000)
                .map((time) =&gt; updateTime(time))),
);
</code></pre>

<p>But I'm getting an error: <code>Property map does not exist on type Observable&lt;Number&gt;</code>. What am I don't wrong here, because I feel that it shouldn't be very hard to accomplish this with <code>redux-observable</code>.</p>
","6662393","","","","","2019-01-31 10:19:10","Dispatching an action every second with redux-observable","<react-native><rxjs><rxjs6><redux-observable>","1","3","","","","CC BY-SA 4.0"
"54477302","1","54480299","","2019-02-01 10:14:23","","1","4919","<p>I've got a application on Angular 7 and RxJS@6.3.3.
I'm trying to get value from my Observable object and I don't know why it doesn't return.</p>

<p>There is my example code: <a href=""https://stackblitz.com/edit/angular-w9ftkw"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-w9ftkw</a></p>

<p>On my example html file I've got:</p>

<pre><code>&lt;hello name=""{{ result.property1 }} {{ result.property2 }} {{ result.property3 }} {{ resultIsUndefined }}""&gt;&lt;/hello&gt;
&lt;p&gt;
  {{err}}
&lt;/p&gt;
</code></pre>

<p>but the properties (<code>{{ result.property1 }} {{ result.property2 }} {{ result.property3 }}</code>) of my result are not displayed.</p>

<p>What is wrong with that?</p>

<p>The <code>res</code> object which I'm trying to return is still type of <code>Observable</code>. I was trying to cast it on <code>MyResponseClasss</code> but doesn't effect.</p>

<p>And this is my real problem. Why returned object is still type of <code>Observable</code>.</p>

<p>On this part of code:</p>

<pre><code>if (result) {
  result.subscribe((result: MyResponseClass) =&gt; {
    this.resultIsUndefined = false;
    res = result;
    console.log(res);
  })
  return res;
}
</code></pre>

<p>I want have a <code>res</code> with data type of <code>MyResponseClass</code>.</p>
","8479567","","8479567","","2019-02-01 12:49:06","2019-02-04 06:34:10","How to return object from Observable in Angular 7","<angular><observable><angular7><rxjs6>","5","2","","","","CC BY-SA 4.0"
"54496459","1","54524095","","2019-02-02 18:57:48","","0","135","<p>Following is my model.</p>

<pre><code>export interface AuditTrail {
    logAction:string,
    targetEmpId:string,
    createdDate:Date
}
</code></pre>

<p>Code below retrieves data from a GET call and transforms it.</p>

<pre><code>  public getAuditTrails() {
   return this.http.get&lt;AuditTrail[]&gt;(this.auditTrailUrl)
    .pipe(
      map((data :Object[]) =&gt;  {
        return data.map(value =&gt; {
          const auditTrail:AuditTrail = {
            logAction:value[""logAction""],
            targetEmpId:value[""targetEmpId""][""empCode""],
            createdDate:value[""loggedDateTime""]
          }
          return auditTrail;
        });
    })
    )
  }
</code></pre>

<p>This code works alright. However my question is how can I avoid the array
iteration <code>data.map(value =&gt; {</code>and use <code>rxjs</code> operators for the same. </p>

<p>The question is intended to improve my understanding of <code>rxjs</code> operators hence the solution should use rxjs operators.</p>
","1491283","","","","","2019-02-04 20:49:01","HttpClient GET transform response array of Objects","<angular6><angular-httpclient><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54502088","1","54548825","","2019-02-03 10:51:07","","0","633","<p>I am trying to get a list of objects from a firebase db using snapshotChanges.</p>
<p>Angular Version: 7.2.0,
Firebase Version: 5.8.1,
RxJS Version: 6.3.3,
AngularFire2: 5.1.1</p>
<p>My code is the following:</p>
<pre><code>this.fbSubs.push(this.db
      .collection('availableExercises')
      .snapshotChanges()
      .pipe(
        map(docArray =&gt; {
          return docArray.map(doc =&gt; {
            return {
              idExercise: doc.payload.doc.id,
              name: doc.payload.doc.data().name,
              duration: doc.payload.doc.data().duration,
              calories: doc.payload.doc.data().calories
            };
          });
        })
      )
      .subscribe((exercises: Exercise[]) =&gt; {
        // code...
      }, error =&gt; {
        // code...
      }));
</code></pre>
<p>When I try to compile this code, I get the following errors:</p>
<pre><code>ERROR in src/app/training/training.service.ts(41,44): error TS2339: Property 'name' does not exist on type '{}'.
    src/app/training/training.service.ts(42,48): error TS2339: Property 'duration' does not exist on type '{}'.
    src/app/training/training.service.ts(43,48): error TS2339: Property 'calories' does not exist on type '{}'.
</code></pre>
<p>I believe the syntax may be outdated from a previous version of RxJS but I can't seem to work out what I need to change.</p>
","7525841","","10547108","","2020-07-23 02:59:51","2020-07-24 02:11:15","Property doesn't exist on type {}","<angularfire2><angular7><rxjs6>","2","0","","","","CC BY-SA 4.0"
"54517090","1","","","2019-02-04 13:23:24","","0","68","<p>I'm creating an algorithm for displaying an alert/modal that prompts users to take action or be logged out of the application when he/she has been unactive for x amount of seconds, where x is lower than the timeout y on the refresh token.</p>

<p>How long the duration is calculated to be is irrelevant, but I'm solving the issue with RxJs.</p>

<p>I've reached the following pipe that seems to do the work:</p>

<pre><code>this.countDown$
 .pipe(
   distinctUntilChanged(),
   switchMap(exp =&gt;
     of(null).pipe(
       delay(AuthService.CalculateDelayTime(exp))
     )
   )
 )
 .subscribe(AuthService.TriggerModal);

</code></pre>

<p><code>countDown$</code> is a <code>Subject&lt;number&gt;</code> that is continuously fed expiry time of the refresh token whenever route authentication is performed.</p>

<p><code>CalculateDelayTime</code> and <code>TriggerModal</code> are both static methods (for now, as the modal itself has not been implemented; calculate returns an amount of seconds until the modal should appear).</p>

<p>Overall it seems to be what I want, but I'm a bit concerned of the <code>of(null)</code>. Is there a more correct/RxJs-style/elegant way to solve this specific problem? I do need the exp time for the delay-function, and I also want to reset the delay with each unique expirytime that comes in (which is why I use <code>switchMap</code>). 
However doing <code>of(exp)</code> suggests I am actually manipulating <code>exp</code> as a part of the inner pipe, which I am not.</p>

<p>I tried <code>Observable.empty()</code> but it seemed like the inner observable would not trigger.</p>

<p>Any suggestions how this should be done?</p>
","8779395","","3454786","","2019-02-04 15:19:40","2019-02-04 15:19:40","Proper way of creating an observable with a meaningful pipe but meaningless content","<javascript><angular><rxjs><observable><rxjs6>","0","2","","","","CC BY-SA 4.0"
"54518039","1","","","2019-02-04 14:13:49","","0","41","<p><strong>This question has been moved to Code-Review:</strong></p>

<p><a href=""https://codereview.stackexchange.com/questions/212854/rxjs-caching-different-http-requests"">https://codereview.stackexchange.com/questions/212854/rxjs-caching-different-http-requests</a></p>

<hr>

<p>There have been multiple discussions on caching http-requests with rxjs, in this question/proposal I want to propose a custom rxjs-operator (non-pure) to provide caching:</p>

<pre><code>const cacheHttp = (cacheKey: string, cacheStorage: any) =&gt; (source: Observable&lt;any&gt;) =&gt; {
  if (!cacheStorage[cacheKey]) {
    cacheStorage[cacheKey] = source.pipe(
      shareReplay(1)
    );
  }
  return cacheStorage[cacheKey];
};
</code></pre>

<p>This operator is not pure, as it modifies one of its arguments (cacheStorage).</p>

<p>This operator could be used like this:</p>

<pre><code>public cachedItems = {};

public getDataForItem$(itemId: string) {
    return this.http.get('/item/' + itemId).pipe(
        cacheHttp(itemId, this.cachedItems),
        shareReplay(1)
    );
}
</code></pre>

<p>The client could then call this multiple times without causing superfluous http-requests:</p>

<pre><code>// the following two subscriptions cause http-requests
this.itemService.getDataForItem('firstItem').subscribe((val) =&gt; console.log(val));
this.itemService.getDataForItem('secondItem').subscribe((val) =&gt; console.log(val));

// all further subscriptions would not cause any additional http-requests
this.itemService.getDataForItem('firstItem').subscribe((val) =&gt; console.log(val));
this.itemService.getDataForItem('secondItem').subscribe((val) =&gt; console.log(val));
this.itemService.getDataForItem('firstItem').subscribe((val) =&gt; console.log(val));
this.itemService.getDataForItem('secondItem').subscribe((val) =&gt; console.log(val));

// this subscription would again cause an http-request:
this.itemService.getDataForItem('thirdItem').subscribe((val) =&gt; console.log(val));
</code></pre>

<p><strong>Now my questions:</strong>
Is this an acceptable approach to solving the ""cache-for-different-requests-problem""? Is there possibly a memory-leak or are there any leaked subscriptions? Is it ok to have side-effects on a provided argument?</p>

<p>Any comments or hints on problems with this custom-operator are very welcome!</p>
","2767626","","2767626","","2019-02-04 15:52:29","2019-02-04 15:52:29","rxjs: caching different http-requests","<rxjs><rxjs6><rxjs-pipeable-operators>","0","2","","","","CC BY-SA 4.0"
"54523937","1","54523954","","2019-02-04 20:34:53","","-3","376","<p>I tried:</p>

<pre><code>import { Observable } from ""rxjs/Observable"";
import 'rxjs/add/observable/forkJoin';
</code></pre>

<p>It says: module Observable has no imported, also does not work <code>map</code> for <code>fork</code>:</p>

<pre><code>return Observable.forkJoin([
      this.loadCompanies(),
      this.loadUsers(),
      this.loadEvents()
    ]).map((data: any[]) =&gt; {});
</code></pre>
","","user3573738","","","","2019-02-04 20:37:07","How to import Observer with ForkJoin in RXJS 6.3.3?","<angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"54537025","1","","","2019-02-05 14:49:50","","0","35","<p>This is example code from the docs. I am new to RXJS, so this might be real easy. </p>

<p>Can anyone explain how map operator is returning a single digit integer after operating on an array?</p>

<p>I checked that the return value of scan operator is an array which increases from [0], [0,1], [0,1,2], [0,1,2,3] .... and so on.</p>

<pre><code>// RxJS v6+
import { interval } from 'rxjs';
import { scan, map, distinctUntilChanged } from 'rxjs/operators';

// Accumulate values in an array, emit random values from this array.
const scanObs = interval(1000)
  .pipe(
    scan((a, c) =&gt; [...a, c], []),
    map(r =&gt; r[Math.floor(Math.random() * r.length)]),
    distinctUntilChanged()
  )
  .subscribe(console.log);
</code></pre>
","7425747","","4095444","","2019-02-05 16:16:04","2019-02-07 04:48:04","Map operator returning integer as output with array as input","<javascript><rxjs><rxjs6><rxjs-pipeable-operators>","1","3","","","","CC BY-SA 4.0"
"54542231","1","54737964","","2019-02-05 20:06:58","","-1","2862","<p>Say I have a behavior subject, piped through an operation or two:</p>

<pre class=""lang-js prettyprint-override""><code>const inputNumber = new BehaviorSubject(2);

// The current number can be retrieved with `inputNumber.getValue()`

const numberAfterOperations = inputNumber.pipe(
  filter(a =&gt; (a+1) % 2), // filter out odd numbers
  map(a =&gt; a * a), // square it
);
</code></pre>

<p><strong>How can I access the value of numberAfterOperations?</strong></p>

<pre class=""lang-js prettyprint-override""><code>// Does not work because `getValue` is not defined!
numberAfterOperations.getValue(); // I expect this to be 4

inputNumber.next(4);

// Does not work!
numberAfterOperations.getValue(); // I expect this to be 16
</code></pre>

<blockquote>
  <p>Note: the observable subscription here works fine. I'm asking about synchronous access to the <code>.value</code> (or <code>.getValue()</code>)</p>
</blockquote>

<p>I noticed a similar issue here, but did not see a resolution:
<a href=""https://github.com/ReactiveX/rxjs/issues/2378"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/2378</a></p>
","2204104","","","","","2019-02-17 21:42:32","RxJS- How to access the value of a BehaviorSubject after operations","<javascript><rxjs><rxjs6>","4","1","","","","CC BY-SA 4.0"
"54545222","1","54545289","","2019-02-06 00:49:45","","0","137","<p>How can I set the value of randomIntervals for each iteration of interval?</p>

<pre><code>import {random} from 'lodash'
import {interval, timer} from 'rxjs';
import {takeUntil} from 'rxjs/operators';

const timer$ = timer(5000);
const randomInterval = random(100, 1000);
const source = interval(randomInterval)
  .pipe(
    takeUntil(timer$)
  );
source.subscribe(console.log)
</code></pre>
","1191635","","","","","2019-02-06 01:53:46","Generate a stream of values over random intervals in rxjs6?","<javascript><rxjs><reactive-programming><rxjs6>","2","0","","","","CC BY-SA 4.0"
"54552060","1","","","2019-02-06 11:02:31","","0","123","<p>I can't seem to get the RxJS switchMap to return the correct type.
Typescript says <code>Type 'T' is not assignable to type 'number'.</code>
How can I change the type so that it will be correct?</p>

<p>My stop/start counter works just fine when I type it to 'any', but I want to do it right :)</p>

<p>Here's a link to a <a href=""https://stackblitz.com/edit/typescript-3b7yyf"" rel=""nofollow noreferrer"">live example</a> on stackblitz.</p>

<p>But the actual issue is within the <code>tap((count: number)</code></p>

<pre><code>private counter$: Observable&lt;number&gt; = this.isCounting$.pipe(
    switchMap(isCounting =&gt; isCounting ? this.updateCount() : of(this.count)),
    tap((count: number) =&gt;  {
      this.displayCount(count)
    })
)
</code></pre>

<p>Would love Typescript to say the type is , but when hovering <code>tap((count: number)</code> it says:</p>

<p>[ts] Argument of type 'MonoTypeOperatorFunction' is not assignable to parameter of type 'OperatorFunction'.</p>

<p>Types of parameters 'source' and 'source' are incompatible.
    Type 'Observable' is not assignable to type 'Observable'.
      Type 'T' is not assignable to type 'number'. [2345]</p>

<p>Update:
There's no error in TS 2.9.2 
There IS an error in TS 3.2.2</p>
","9200463","","310726","","2019-02-07 09:38:02","2019-02-07 09:38:02","RxJS switchMap returns T instead of Observable<number>","<typescript><rxjs6>","0","3","","","","CC BY-SA 4.0"
"54571544","1","54573995","","2019-02-07 10:45:05","","2","586","<p>I am trying to create a method to return a setting that could be stored in one of three places. I have created three observables, each to attempt to retrieve the setting value from a source. I would like to be able to ""join"" these in such a way to create an IF/ELSE IF/ELSE construct so that only one of the Observables emits the setting value in the end. The condition to move away from one observable to the next is that the previous ""failed"", i.e., emitted a value that did not pass a condition. The order in which each option is tried is important. </p>

<p>So my method looks something like this so far:</p>

<pre><code>getSetting(settingName: string): Observable&lt;any&gt; {

    const optionOne$ = this.getItemAtFirst(settingName).pipe(
        take(1),
        filter(setting =&gt; setting &amp;&amp; this.isSettingValid(settingName, setting)));

    const optionTwo$ = this.getItemAtSecond().pipe(
        take(1),
        filter(setting =&gt; setting &amp;&amp; this.isSettingValid(settingName, setting)));

    const optionThree$ = of(this.defaultSettingValue);

    return merge(optionOne$, optionTwo$, optionThree$);
}
</code></pre>

<p>This obviously does not work because <code>merge</code> does not provide the selection effect that I need.</p>

<p>Any suggestions? Thanks in advance!</p>
","3544686","","","","","2020-03-05 11:23:34","IF/ELSE IF/ELSE with Observable as conditional","<angular><typescript><rxjs><observable><rxjs6>","2","5","1","","","CC BY-SA 4.0"
"54590880","1","","","2019-02-08 10:53:59","","0","76","<p>I have just upgraded my Angular 5 project to 6 following the usual guide. I have updated my packages and have also installed the rxjs-compat package and run the following to migrate from rxjs 5 to rxjs 6 </p>

<pre><code>npm install -g rxjs-tslint

npm install rxjs-compat --save

rxjs-5-to-6-migrate -p tsconfig.json
</code></pre>

<p>My package.json looks as follows</p>

<pre><code>{
  ""name"": ""srm-portal"",
  ""version"": ""1.0.0"",
  ""description"": """",
  ""main"": ""wwwroot/index.html"",
  ""author"": """",
  ""license"": ""ISC"",
  ""scripts"": {
    ""ngc"": ""ngc -p ./tsconfig-aot.json"",
    ""start"": ""concurrently \""webpack-dev-server --hot --inline --port 8080\"" \""dotnet run\"" "",
    ""webpack-dev"": ""set NODE_ENV=development &amp;&amp; webpack"",
    ""webpack-production"": ""set NODE_ENV=production &amp;&amp; webpack"",
    ""build-dev"": ""npm run webpack-dev"",
    ""build-production"": ""npm run ngc &amp;&amp; npm run webpack-production"",
    ""watch-webpack-dev"": ""set NODE_ENV=development &amp;&amp; webpack --watch --color"",
    ""watch-webpack-production"": ""npm run build-production --watch --color"",
    ""publish-for-iis"": ""npm run build-production &amp;&amp; dotnet publish -c Release""
  },
  ""dependencies"": {
    ""@angular/animations"": ""^6.0.0"",
    ""@angular/common"": ""^6.0.0"",
    ""@angular/compiler"": ""^6.0.0"",
    ""@angular/compiler-cli"": ""^6.0.0"",
    ""@angular/core"": ""^6.0.0"",
    ""@angular/forms"": ""^6.0.0"",
    ""@angular/http"": ""^6.0.0"",
    ""@angular/platform-browser"": ""^6.0.0"",
    ""@angular/platform-browser-dynamic"": ""^6.0.0"",
    ""@angular/platform-server"": ""^6.0.0"",
    ""@angular/router"": ""^6.0.0"",
    ""@angular/upgrade"": ""~4.3.0"",
    ""angular-in-memory-web-api"": ""0.3.2"",
    ""angular2-chartjs"": ""^0.2.0"",
    ""angular2-notifications"": ""^0.7.4"",
    ""angular2-redux"": ""^4.0.0"",
    ""core-js"": ""2.5.6"",
    ""date-input-polyfill"": ""^2.14.0"",
    ""font-awesome"": ""4.7.0"",
    ""ie-shim"": ""~0.1.0"",
    ""linkifyjs"": ""^2.1.4"",
    ""ng2-appinsights"": ""^1.0.0-beta.1"",
    ""ng2-currency-mask"": ""^4.3.1"",
    ""ng2-dnd"": ""^4.2.0"",
    ""ng2-toasty"": ""^4.0.3"",
    ""ng2-validation"": ""^4.2.0"",
    ""ngx-chips"": ""1.5.3"",
    ""ngx-easy-table"": ""2.2.0"",
    ""ngx-pagination"": ""3.0.3"",
    ""powerbi-client"": ""^2.4.7"",
    ""primeicons"": ""^1.0.0-beta.10"",
    ""primeng"": ""^6.1.2"",
    ""redux"": ""^3.6.0"",
    ""redux-thunk"": ""^2.2.0"",
    ""reflect-metadata"": ""0.1.10"",
    ""rxjs"": ""^6.1.0"",
    ""rxjs-compat"": ""^6.4.0"",
    ""zone.js"": ""0.8.26""
  },
  ""devDependencies"": {
    ""@types/node"": ""10.0.6"",
    ""angular-router-loader"": ""^0.6.0"",
    ""angular2-template-loader"": ""0.6.2"",
    ""awesome-typescript-loader"": ""3.1.2"",
    ""clean-webpack-plugin"": ""^0.1.16"",
    ""copy-webpack-plugin"": ""^4.0.1"",
    ""css-loader"": ""^0.28.0"",
    ""file-loader"": ""^0.11.1"",
    ""html-webpack-plugin"": ""^2.28.0"",
    ""json-loader"": ""^0.5.4"",
    ""node-sass"": ""^4.5.3"",
    ""raw-loader"": ""^0.5.1"",
    ""sass-loader"": ""^6.0.3"",
    ""source-map-loader"": ""^0.2.1"",
    ""style-loader"": ""^0.16.1"",
    ""ts-helpers"": ""^1.1.2"",
    ""tslint"": ""^5.1.0"",
    ""tslint-loader"": ""^3.5.2"",
    ""typescript"": ""2.7.2"",
    ""url-loader"": ""^0.5.8"",
    ""webpack"": ""^2.4.1"",
    ""webpack-dev-server"": ""2.4.2""
  },
  ""-vs-binding"": {
    ""ProjectOpened"": [
      ""watch-webpack-dev""
    ]
  }
}
</code></pre>

<p>I am using Visual Studio 2017 and have a number of errors shown in the error list</p>

<p>Can anyone help and advise further?</p>

<p>Please see attached images</p>

<p><a href=""https://i.stack.imgur.com/RFuRl.png"" rel=""nofollow noreferrer"">Types.d.ts error</a>
<a href=""https://i.stack.imgur.com/KQn0N.png"" rel=""nofollow noreferrer"">http service api error</a></p>

<p>My project properties look as follows </p>

<p><a href=""https://i.stack.imgur.com/jkAA6.jpg"" rel=""nofollow noreferrer"">Project Properties</a></p>
","11033089","","11033089","","2019-02-08 16:38:19","2019-02-08 16:38:19","Problems after upgrading my Angular project from 5x to 6x","<angular><rxjs><migration><rxjs6><rxjs-compat>","1","0","","","","CC BY-SA 4.0"
"54591004","1","54615163","","2019-02-08 11:00:34","","1","102","<p>I have legacy code I need to migrate to RxJS 6.  There is one line that I have no clue how to migrate that one:</p>

<pre><code>return empty(this.scheduler);
</code></pre>

<p><code>this.scheduler</code> is some scheduler passed into the class constructor.</p>

<p>I found instructions on how to migrate <code>empty()</code>, just use the contant <code>EMPTY</code>, but how can I create an empty observable using a scheduler?</p>
","558239","","310726","","2019-02-10 10:39:35","2019-03-02 23:51:09","How to migrate empy(scheduler) to RxJS?","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54596543","1","","","2019-02-08 16:27:03","","2","72","<p>I am trying to do a lookahead with RxJS using Angular 7.3.1 and RxJS 6.4.  When I type, every keystroke is being sent instead of it waiting for a bit of time to capture all keystrokes.</p>

<p>my.service.ts</p>

<pre><code>return fromEvent(document.getElementById('input-size-default'), 'input')
            .pipe(
                debounceTime(500),
                map((e: any) =&gt; e.target.value),
                filter(earlyText =&gt; earlyText.length &gt; 3),
                distinctUntilChanged(),
                switchMap((myText) =&gt; ajax.post(this.base_href + ':3000/searchUsers', {user: myText}))
            );
</code></pre>

<p>component.ts</p>

<pre><code> this.ad.searchCiscoUser()
        .subscribe(response =&gt; this.showResults({'results': response}), error =&gt; this.showResults({'error': error}));
</code></pre>

<p>For my search, I typed part of my name and you can see below, 9 calls which should have only happened once.</p>

<p>Results:  <a href=""https://i.stack.imgur.com/HMsQn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HMsQn.png"" alt=""enter image description here""></a></p>
","11034636","","11034636","","2019-02-08 19:05:55","2019-10-11 06:04:56","Any ideas why my RxJS api call captures every keystroke instead of waiting?","<angular><rxjs><angular7><rxjs6>","1","3","","","","CC BY-SA 4.0"
"54621370","1","54631116","","2019-02-10 21:42:41","","2","1876","<p>I have an action that I want to use to initialise my app, I want to create an epic for this action and then fire multiple other actions off the back of this, wait for them to all complete and there fire another action. I had a look at other questions and it's pretty similar to this <a href=""https://stackoverflow.com/questions/50951633/redux-observable-how-to-wait-for-multiple-async-requests-then-perform-action-in/50956494"">one</a></p>

<p>I've tried this approach and for me, it doesn't work, it fires the <code>APP_INIT</code> action then but then fails to fire any of the other actions in the sequence. Is anyone able to help?</p>

<pre><code>import { of } from 'rxjs';
import { mergeMap, zip, concat, mapTo } from 'rxjs/operators';
import { ofType } from 'redux-observable';
import { firstAction, secondAction } from 'actions';

export default function appInit (action$) {
  return (
    action$.pipe(
      ofType('APP_INIT'),
      mergeMap(() =&gt;
        concat(
          of(firstAction()),
          of(secondAction()),
          zip(
            action$.ofType('ACTION_ONE_COMPLETE'),
            action$.ofType('ACTION_TWO_COMPLETE')
          ).mapTo(() =&gt; console.log('complete'))
        )
      )
    )
  );
}
</code></pre>
","728150","","728150","","2019-02-11 01:28:40","2019-02-11 12:55:18","Fire multiple actions and wait for them to resolve RxJS / Redux Observables","<javascript><redux><rxjs><rxjs6><redux-observable>","2","2","1","","","CC BY-SA 4.0"
"54641065","1","54645663","","2019-02-12 00:20:28","","0","275","<p>I feel like I'm missing something really simple here. I'm trying to create a simple retry for fetch but only the code in the <code>retryWhen</code> is getting executed. I'm using React so i dont have the <code>this.http.get</code> convenience. Perhaps it's an issue with <code>from(/*promise*/)</code>? I was trying to base the retry logic off of  <a href=""https://mobiarch.wordpress.com/2018/06/21/retry-failed-http-calls-in-angular-6/"" rel=""nofollow noreferrer"">this post</a>.</p>

<p>This is what I would expect to see:</p>

<pre><code>Getting data from fetch...
In the retryWhen
In the interval
/* repeat the previous 3 lines 3x times including the Fetch */
Giving up
</code></pre>

<p>Instead I get:</p>

<pre><code>Getting data from fetch...
In the retryWhen
In the interval...
In the interval...
In the interval...
In the interval...
Giving up
</code></pre>

<p>So it is just repeating the code in he retryWhen interval but not repeating the original fetchData call. I'm probably missing something fundamental to my RXJS knowledge.</p>

<p>Here's the test code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const fetchData = new Promise((res, rej) =&gt; {
  console.log(""Getting data from fetch..."");
  rej(); // just fail immediately to test the retry
});

const source = from(fetchData)
  .pipe(
    retryWhen(_ =&gt; {
      console.log(""In the retryWhen"");
      return interval(1000).pipe(
        tap(_ =&gt; console.log(""In the interval..."")),
        flatMap(count =&gt; count == 3 ? throwError(""Giving up"") : of(count))
      )
    }));

source.subscribe(
  result =&gt; console.log(result),
  err =&gt; console.log(err)
);</code></pre>
</div>
</div>
</p>
","2435006","","2435006","","2019-02-12 04:23:19","2019-02-13 08:03:56","rxjs 5.5+ retryWhen not calling source observable?","<rxjs><observable><rxjs6><rxjs-pipeable-operators><retrywhen>","1","0","","","","CC BY-SA 4.0"
"54646622","1","","","2019-02-12 09:22:59","","0","2353","<p>I need to fetch data from a service. Then I need to loop through the data and fetch data with the id's I got from the first call.</p>

<p>My goal is to optimise Angular bindings performance by calling markForCheck() on ChangeDetectorRef when all data are loaded.</p>

<p>This is my current code. It's get the job done. But the call to markForCheck() is done before all data is loaded.</p>

<pre><code> this.subs.push(
  this.supplierService
    .supplier(this.supplierId)
    .pipe(
      tap(supplier =&gt; {
        this.subs.push(
          of(supplier.employees.map(emp =&gt; emp.authId))
            .pipe(
              mergeMap(ids =&gt; ids.map(id =&gt; this.authRegisterService.lookupId(id))),
              mergeMap(res =&gt; res)
            )
            .subscribe(
              result =&gt; {
                this.authRegs.push(result);
              },
              error =&gt; {
                this.toastr.error(error);
                return EMPTY;
              }
            )
        );
      }),
      tap(supplier =&gt; {
        this.subs.push(this.cvrService.getCompany(supplier.cvr).subscribe(cvr =&gt; (this.cvr = cvr)));
      }),
      tap(supplier =&gt; {
        this.subs.push(
          of(supplier.locations.map(loc =&gt; loc.sorId))
            .pipe(
              mergeMap(ids =&gt; ids.map(id =&gt; this.sorService.getLocation(id))),
              mergeMap(res =&gt; res)
            )
            .subscribe(sor =&gt; {
              this.sors.push(sor);
            })
        );
      })
    )
    .subscribe(supplier =&gt; {
      this.supplier = supplier;
      this.supplierStatusLabel = SupplierStatusNames.get(supplier.status);
      this.cd.markForCheck();
    })
);
</code></pre>

<p>I read the documentation for <a href=""https://www.learnrxjs.io/operators/combination/forkjoin.html"" rel=""nofollow noreferrer"">forkJoin</a> but I don't know how to combine it with the first call. All input are much appreciate.</p>
","1147577","","1147577","","2019-02-12 21:45:42","2019-02-13 00:32:22","RxJS Wait for all observables to finish with data from the first call","<angular><rxjs6>","1","1","1","","","CC BY-SA 4.0"
"54658614","1","55622819","","2019-02-12 21:00:32","","27","6728","<p>Is there any tool or technique to detect ""left behind"" or ""currently alive"" observables, subscriptions.</p>

<p>Just recently discovered a pretty nasty memory leak where components were kept alive due to missing ""unsubscribe"" calls. I read about ""takeUntil"" approach which seems pretty good.
<a href=""https://stackoverflow.com/a/41177163/2050306"">https://stackoverflow.com/a/41177163/2050306</a></p>

<p>However I'm still wondering is there any tool (browser extension etc.) for that. Augury does not cover this area as far as I know.</p>

<p>All input is greatly appreciated.</p>
","2050306","","2050306","","2019-02-15 23:50:05","2020-12-15 04:25:55","How to detect rxjs related memory leaks in Angular apps","<javascript><angular><typescript><rxjs><rxjs6>","1","8","9","","","CC BY-SA 4.0"
"54668110","1","54673160","","2019-02-13 10:37:06","","1","1399","<p>I started to optimize my code and i want to unsubscribe from my subscriptions in ngOndestroy. I have multiple subscription.
The problem is when i want to invoke the add() method to add additional child subscriptions it says Cannot read property 'add' of undefined.
I simplified my code here so you can see the important things only.</p>

<pre><code>import {Subscription} from 'rxjs';

export class DashboardComponent implements OnInit, OnDestroy {
     private subscription: Subscription;
}

ngOnInit() {
   this.getData();
   this.getFeed();
}

ngOndestroy {
if (this.subscription) {
   this.subscription.unsubscribe();
   console.log(this.subscription);
   }
}

getData() {
   const subscription = this._authService.currentCompanyId.subscribe((newCompanyId) =&gt; {
            this.driverSubs(newCompanyId);
            this.vehicleSubs(newCompanyId);
        });
        this.subscription.add(subscription);
    }

   driverSubs(newCompanyId) {
        const subscription = this._driversService.getAllDrivers(newCompanyId).subscribe((data) =&gt; {
            this.getDataForDrivers(data);
        });
        this.subscription.add(subscription);
    }

    vehicleSubs(newCompanyId) {
        const subscription = this._vehiclesService.getAllVehicles(newCompanyId).subscribe((data) =&gt; {
            this.getDataForVehicles(data);
        });
        this.subscription.add(subscription);
    }
}

getFeed() {
    this.feedSubs();
    this.feedTachoSubs();
}

feedSubs() {
    const subscription = this._feedService.getFeed().subscribe(response =&gt; {
        this.feed = response;
    });
    this.subscription.add(subscription);
}

feedTachoSubs() {
    const subscription = this._feedTachoService.getFeedForVehicles().subscribe(response =&gt; {
        this.feedTacho = response;
    });
    this.subscription.add(subscription);
}
</code></pre>
","8695454","","8695454","","2019-02-13 10:53:52","2019-02-13 14:59:02","Cannot read property 'add'. Rxjs Subscription","<angular><angular7><subscription><rxjs6><unsubscribe>","3","0","2","","","CC BY-SA 4.0"
"54680966","1","54681394","","2019-02-13 23:21:57","","0","537","<p>My code compiles and everything is working fine, but my IDE (Visual Studio Code) shows the following error message and I'm unable to deploy my app (with ng build --prod):</p>

<blockquote>
  <p>ERROR in src/app/training/training.service.ts(61,46): error TS2339:
  Property 'name' does not exist on type '{}'.
  src/app/training/training.service.ts(62,50): error TS2339: Property
  'duration' does not exist on type '{}'.
  src/app/training/training.service.ts(63,50): error TS2339: Property
  'calories' does not exist on type '{}'.</p>
</blockquote>

<p>I import the map operator like this:</p>

<pre><code>import { map, take } from 'rxjs/operators';
</code></pre>

<p>and use it like this:</p>

<pre><code>...
    .snapshotChanges()
    .pipe(
      map(docArray =&gt; {
        return docArray.map(doc =&gt; {
          return {
            id: doc.payload.doc.id,
            name: doc.payload.doc.data().name,
            duration: doc.payload.doc.data().duration,
            calories: doc.payload.doc.data().calories
          };
        });
      })
    )
...
</code></pre>

<p>My interface looks like:</p>

<pre><code>export interface Exercise {
id: string;
name: string;
duration: number;
calories: number;
date?: Date;
state?: 'completed' | 'cancelled' | null;
</code></pre>

<p>}</p>

<p>What am I doing wrong?</p>
","6475284","","6475284","","2019-02-13 23:52:05","2019-02-14 00:12:51","How to use the map operator in rxjs within an angular 7 app?","<angular><rxjs><ngrx><angular7><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"54686930","1","54688499","","2019-02-14 09:21:35","","3","2008","<p>I want use second param (error) on my subcriber but dot not work.</p>

<p><strong>Code of my Observable:</strong></p>

<pre><code>return Observable.create(obs =&gt; {
  cognitoidentityserviceprovider.adminCreateUser(params, function(error, data) {
    if (error) {
      console.log(error);
      return throwError(error || 'Server error');
    } else {
      console.log(data);
      return obs.next(data.User);
    }
  });
});
</code></pre>

<p>my <code>console.log(error);</code> is OK but after nothing (no trace).</p>

<p><strong>Code of my subscriber:</strong></p>

<pre><code>this.myService.createUser(user).subscribe(
         result =&gt; this.getUsers(),
         error =&gt;  this.errorUsersProcessor(error));
</code></pre>

<p>second param (error) on my subcriber never call.</p>
","3535537","","","","","2019-02-14 10:42:50","Angular 7 (RxJs 6.x) - How to use throwError","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"54687527","1","54692816","","2019-02-14 09:52:41","","2","70","<p>I have an Observable source <code>source1</code> that emits values, if it does not emit anything for more than 2 seconds, I want to switch to a fallback source <code>source2</code>. And if <code>source1</code> emits again, I want to emit from it. And so on, indefinitely.</p>

<p>So far, I have the following</p>

<pre><code>import { timeout, catchError, takeUntil, concat } from 'rxjs/operators';

declare const source1: Observable;
declare const source2: Observable;

source1.pipe(
    timeout(2000),
    catchError(() =&gt; {
      return source2.pipe(
        takeUntil(source1)
      );
    }),
    concat(source1)
).subscribe(val =&gt; console.log(val));
</code></pre>

<p>This almost works. If <code>source1</code> does not emit after 2 seconds, it emits from <code>source2</code> until <code>source1</code> emits again and then switch to <code>source1</code>. But there are 2 main flaws:</p>

<ol>
<li>when <code>source1</code> emits again, the first emitted value is ""caught"" by <code>takeUntil</code> (<code>source1</code> is a hot observable) and won't be in <code>concat(source1)</code></li>
<li>if <code>source1</code> stops emitting a 2nd time, I would like to have the same behaviour. With my implementation, it only works once.</li>
</ol>

<p>Any idea how I can solve this? </p>
","3791924","","3791924","","2019-02-14 10:00:37","2019-05-29 21:42:00","RxJS emit from source2 if source1 has timed out and when source1 is back emit from source1","<javascript><typescript><rxjs><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"54696550","1","54697091","","2019-02-14 18:04:09","","3","469","<p>I am trying to display to users a list of 'reports' they can add which requires a combination of multiple AJAX requests and observables -- one request to an api to find the 'applications' they can access, and then multiple requests to a defined endpoint for each application. Once this step has been completed, I never need to make the ajax requests again.</p>

<p>I have something working but I do not really understand it and I feel like there should be a much easier way to do this.</p>

<p>I have some working code right now, however, I find it overly complicated and hardly understand how I got it to work.</p>

<pre><code>private _applications: ReplaySubject&lt;Application&gt;;
private _applicationReports: ReplaySubject&lt;ApplicationReports&gt;;

// Ajax request to fetch which applications user has access to
public fetchApplications(): Observable&lt;Application[]&gt; {
    return this._http.get('api/applications').pipe(
        map(http =&gt; {
            const applications = http['applications'] as Application[];
            applications.forEach(app =&gt; this._applications.next(app));
            this._applications.complete();
            return applications;
        })
    );
}

// Returns an observable that contains all the applications
// a user has access to
public getApplications(): Observable&lt;Application&gt; {
    if (!this._applications) {
        this._applications = new ReplaySubject();
        this.fetchApplications().subscribe();
    }
    return this._applications.asObservable();
}

// Returns an observable which shows all the reports a user has
// from all the application they can access
public getApplicationReports(): Observable&lt;ApplicationReports&gt; {
    if (!this._applicationReports) {
        this._applicationReports = new ReplaySubject();
        this.getApplications().pipe(
            mergeMap((app: Application) =&gt; {
                return this._http.get(url.resolve(app.Url, 'api/reports')).pipe(
                    map(http =&gt; {
                        const reports: Report[] = http['data'];

                        // double check reports is an array to avoid future errors
                        if (!reports || !Array.isArray(reports)) {
                            throw new Error(`${app.Name} did not return proper reports url format: ${http}`);
                        }
                        return [app, reports];
                    }),
                    catchError((err) =&gt; new Observable())
                );
            })
        ).subscribe(data =&gt; {
            if (data) {
                const application: Application = data[0];
                const reports: Report[] = data[1];

                // need to normalize all report urls here
                reports.forEach(report =&gt; {
                    report.Url = url.resolve(application.Url, report.Url);
                });

                const applicationReports = new ApplicationReports();
                applicationReports.Application = application;
                applicationReports.Reports = reports;

                this._applicationReports.next(applicationReports);
            }
        }, (error) =&gt; {
            console.log(error);
        }, () =&gt; {
            this._applicationReports.complete();
        });
    }
    return this._applicationReports.asObservable();
}
</code></pre>

<p>Expected functionality:</p>

<p>When a user opens the 'Add a report' component, the application starts a series of ajax calls to fetch all the applications the user has, and all the reports from those applications. Once all the ajax request are completed, the user sees a list of reports they can choose to add. If the user opens the 'Add a report' component a second time, they already have the report list and the application doesn't need to send more ajax requests.</p>
","9333242","","9333242","","2019-02-14 18:28:07","2019-02-15 17:49:53","Angular/RxJS - Only call AJAX requests once, else emit current value of Observable","<ajax><angular><rxjs><observable><rxjs6>","3","0","2","","","CC BY-SA 4.0"
"54700936","1","","","2019-02-15 00:04:42","","0","180","<p>I'm trying to figure out how to translate a common iterative pattern into reactive rxjs. Let's say I'm trying to build an object called SchoolSchedule composed of single days off and Vacations.</p>

<pre><code>class SchoolSchedule {
  schoolName: string;
  districtName: string;
  singleDaysOff: Array&lt;moment.Moment&gt; = new Array&lt;moment.Moment&gt;();
  vacations: Array&lt;Vacation&gt; = new Array&lt;Vacation&gt;();

  constructor(schoolName: string, districtName: string) {
    this.schoolName = schoolName;
    this.districtName = districtName;
  }
}

class Vacation {
  startDate: moment.Moment;
  endDate: moment.Moment;

  constructor(startDate: moment.Moment, endDate: moment.Moment) {
    this.startDate = startDate;
    this.endDate = endDate;
  }
}
</code></pre>

<p>I create instances of this class from a json file</p>

<pre><code>{
  ""daysOff"": [
    {
      ""name"": ""Your Elementary"",
      ""district"": ""Some County"",
      ""single"": [""9/3"", ""11/12"", ""1/21""],
      ""vacations"": [""11/21-11/23"", ""12/20-1/4"", ""2/18-2/22""] 
    }
    ...
  ]
}
</code></pre>

<p>In non-reacive logic, I parse each JSON item. First, I create the SchoolSchedule instance. Then I parse the sub-items 'single' and 'vacations' to populate the SchoolSchedule instance. How do I accomplish this with a combination of observables in a reactive way?</p>

<p>This is what I've come up with so far:</p>

<pre><code>import { Observable, of, from, zip } from 'rxjs';
import { switchMap, map } from 'rxjs';
import moment from 'moment';

import DAYS_OFF from 'days_off.json';

const schoolSchedules = new Array&lt;SchoolSchedule&gt;();
const daysOffBySchool = from(DAYS_OFF['daysOff']).pipe(
  switchMap((schoolDayOffsJSON) =&gt; zip( 
    new Observable((observer) =&gt; {
       const schoolSchedule = new SchoolSchedule(schoolDayOffsJSON.name, schoolDayOffsJSON.district);
       observer.next(schoolSchedule);
       observer.complete();
    }),
    zip(
      from(schoolDayOffsJSON.single).pipe(
        switchMap((dateStr: string) =&gt; {
           return new Observable((observer) =&gt; {
              observer.next(moment(dateStr + '/2019', 'M/D/YYYY'));
              observer.complete();
           })
        })
      )
    ), 
    zip(
      from(schoolDayOffsJSON.single).pipe(
        map((dateRangeStr: string) =&gt; dateRangeStr.split('-')),
        switchMap(dateStr: string) =&gt; zip(
          return new Observable((observer) =&gt; {
              observer.next(moment(dateStr + '/2019', 'M/D/YYYY'));
              observer.complete();
          }),
          return new Observable((observer) =&gt; {
              observer.next(moment(dateStr + '/2019', 'M/D/YYYY'));
              observer.complete();
          })
        )),
        map((dateRanges: Array&lt;moment.Moment&gt;) =&gt; return new Vacation(dateRanges(0), dateRanges(1)))
      )
    )
  )),
  map((results) =&gt; {
    const schoolSchedule: SchoolSchedule = results[0];
    const singleDaysOff: Array&lt;moment.Moment&gt; = results[1];
    const vacations: Array&lt;Vacation&gt; = results[2];
    schoolSchedule.singleDaysOff = singleDaysOff;
    return schoolSchedule;
  }),
);
daysOffBySchool.subscribe((schoolSchedule: SchoolSchedule) =&gt; schoolSchedules.push(schoolSchedule));
</code></pre>

<p>Needless to say, this doesn't work. This is a tough ask, but what am I doing wrong? What should I be doing? I realize that it would much easier if I didn't break this up into a bunch of observables, but I feel that I wouldn't be able to escape this pattern with more complicated logic later on; so it's best to get it right - right now.</p>
","54427","","","","","2019-02-15 00:04:42","Using rxjs to create a 'complex' object using combination operators","<typescript><rxjs><rxjs6>","0","6","","","","CC BY-SA 4.0"
"54712686","1","54716806","","2019-02-15 15:44:48","","0","1360","<p>My console.log is never call (my 2 requests is called and OK).</p>

<pre><code>const obs1 = this.awsService.getUsers();
const obs2 = this.apiService.get('admin/user');

return forkJoin(obs1, obs2).subscribe((res) =&gt; {
  console.log('res2', res);
});
</code></pre>

<p>I try unit call (console.log A and B is ok):</p>

<pre><code>const obs1 = this.awsService.getUsers();
obs1.subscribe((res) =&gt; {
  console.log('A' + res);
});

const obs2 = this.apiService.get('admin/user');
obs2.subscribe((res) =&gt; {
  console.log('B' + res);
});
</code></pre>

<p><strong>EDIT</strong></p>

<p>My code return a observable of User[] but KO un a forkJoin:</p>

<pre><code>getUsers(): Observable&lt;User[]&gt; {
  return Observable.create(obs =&gt; {
    const u = new User;
    u.username = user.Username;
    _users.push(u);
    return obs.next(_users);
  });
}
</code></pre>

<p>This code is OK:</p>

<pre><code>const u1: User = new User;
u1.username = 'foo';
const u2: User = new User;
u2.username = 'foo';
const o2: Observable&lt;User[]&gt; = of([u1, u2]);
const fj = forkJoin(o2);
fj.subscribe(res =&gt; {
  console.log('r');
 });
 // r is ok in console
</code></pre>

<p>What difference between <code>of</code> and <code>Observable.create( ...  return obs.next(_users);)</code> ?</p>
","3535537","","3535537","","2019-02-15 21:15:38","2019-02-15 21:15:38","Angular 7 RXjs 6.x - How to use forkJoin (difference between `of` and `Observable.create`)","<angular><rxjs6>","1","5","","","","CC BY-SA 4.0"
"54714730","1","54714807","","2019-02-15 17:58:28","","4","5993","<p>I have an interceptor in my Angular 7 app that makes a request to get the token before re-issuing the request. If multiple requests come in at once then they will all make a request to get the token. To avoid that I share an observable so that the result for getting the token is shared and that only one request is made to get the token.</p>

<p>I create the shared observable as follows</p>

<pre><code>this.authService.sharedToken =   this.authService.getToken().pipe(share());
</code></pre>

<p>Then I make the request</p>

<pre><code> return auth.sharedToken.flatMap((res) =&gt; {

     auth.saveTokenToLocalStorage(res);
     return this.getRequestWithAuthentication(request, next, auth);

 }).catch(function (err) {// I handle errors here
 }
</code></pre>

<p>The problem is that flatMap is deprecated and replacing it with mergeMap won't work either. It seems mergeMap is a standalone function right now. So how can I get the code above to work.</p>

<p>I am using  rxjs 6.4.0 
and Angular 7.2.4</p>

<p>Thanks.</p>

<p>EDIT: </p>

<p>using the new pipe approach I have the following:</p>

<pre><code>  return auth.sharedToken.pipe(
            mergeMap((res) =&gt; {

                auth.saveTokenToLocalStorage(res);
                return this.getRequestWithAuthentication(request, next, auth);
            }), catchError(function (err) {
                console.log(""failed to get token"")
                return EMPTY;
            }));
</code></pre>

<p>I cannot get the ""failed to get token"" to print when the request fails. I do more error handling there, so I need some code to be triggered when the request fails. </p>
","10056305","","10056305","","2019-02-15 19:08:30","2019-02-15 19:08:30","How to replace flatMap and mergeMap in rxjs 6.4.0 Angular","<angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"54723125","1","","","2019-02-16 12:35:17","","1","66","<p>I have been using rxjs WebSocket service for making WebSocket connection. I am developing one of the functionality which requires a message after making the successful reconnection in angular 6 application. Currently, rxjs retry function doesn't provide any successful
subscribe method or response method from WebSocket.
Following is the code to make a retry connection using rxjs web socket.</p>

<pre><code>this.socket$ = Websocket(""ws://10.12.12.12:4040"")
this.socket$.retry().subscribe((success) =&gt; {
console.log(success);
},(error) =&gt; {
console.log(error);
}, (complete) =&gt; {
console.log(complete);
});
</code></pre>

<p>Above code works when connection appears successfully but we are not able to catch that connection is been established successfully. Even we have also tried with <code>retryWhen()</code> but no success.
Need to identify which method is been used to get a success response in order to display Connection established is successful to the end user.</p>
","8978445","","8978445","","2019-02-19 01:36:55","2019-02-19 01:36:55","Not able to get successful connection message after retry using web socket","<angular><websocket><rxjs><angular6><rxjs6>","0","0","","","","CC BY-SA 4.0"
"54754925","1","54755746","","2019-02-18 20:31:11","","4","1599","<p>I have an Angular component with a BehaviourSubject initialized to the current month:</p>

<pre><code>textLabel: string;

private monthIndex$: BehaviorSubject&lt;number&gt;;

private MONTHS = [
""Gennaio"",
""Febbraio"",
""Marzo"",
""Aprile"",
""Maggio"",
""Giugno"",
""Luglio"",
""Agosto"",
""Settembre"",
""Ottobre"",
""Novembre"",
""Dicembre""
];

constructor(private listService: ShoppingListService) {}

ngOnInit() {
  this.monthIndex$ = new BehaviorSubject&lt;number&gt;(new Date().getMonth());

  // Like this it does not display the label
  this.setMonthLabel(this.monthIndex$.value); 

  this.model$ = this.monthIndex$.pipe(
    switchMap((monthValue: number) =&gt; {
      //    this.setMonthLabel(monthValue);  // This way it works!
      return this.listService.getHistoryChartModel(monthValue);
    }),
    takeUntil(this.destroy$)
  );
}

private setMonthLabel(monthIndex: number) {
  this.textLabel = this.MONTHS[monthIndex];
}

setMonth(direction: number) {
  let monthIndex = this.monthIndex$.getValue();
  monthIndex += direction;
  monthIndex =
  monthIndex &lt; 0 ? 0 : monthIndex &gt; 11 ? 11 : monthIndex;

  this.monthIndex$.next(monthIndex);
  this.setMonthLabel(monthIndex);
}
</code></pre>

<p>And the template:</p>

<pre><code>&lt;div class=""view-sel-container""&gt;
  &lt;button
   color=""primary"" mat-icon-button
   (click)=""setMonth(-1)""
   [disabled]=""monthIndex === 0""&gt;
  &lt;i class=""material-icons""&gt;
    keyboard_arrow_left
  &lt;/i&gt;
 &lt;/button&gt;

 &lt;span class=""label-text"" *ngIf=""textLabel""&gt;{{ textLabel }}&lt;/span&gt;

 &lt;button
  color=""primary"" mat-icon-button
  (click)=""setMonth(1)""
  [disabled]=""monthIndex === 11""&gt;
  &lt;i class=""material-icons""&gt;
    keyboard_arrow_right
  &lt;/i&gt;
 &lt;/button&gt;
</code></pre>

<p></p>

<p>Is it a timing reason why by passing the BehavourSubject value to the method <code>this.setMonthLabel(this.monthIndex$.value)</code>, the label is not displayed in the template?</p>

<p><strong>UPDATE</strong></p>

<p>The solution provided by Deborah Kurata using get/set instead of BehaviourSubject is the best way to go. I leave the original question/code open as I still do not get why the code does now work by passing the behaviourSubject value as parameter.</p>
","706293","","706293","","2019-02-19 15:18:59","2019-02-19 15:18:59","Pass BehaviorSubject value as parameter","<angular><rxjs6><behaviorsubject>","2","6","","","","CC BY-SA 4.0"
"54755950","1","54756320","","2019-02-18 21:55:06","","1","816","<p>I have tried setting up CI for my angular project using Circle CI following this configuration:
<a href=""https://angular.io/guide/testing#configure-project-for-circle-ci"" rel=""nofollow noreferrer"">https://angular.io/guide/testing#configure-project-for-circle-ci</a></p>

<p>However, when <code>ng test</code> runs I get the following error:</p>

<pre><code>ERROR in src/app/account/login-form/login-form.component.ts(4,26): error TS2307: Cannot find module 'rxjs/Operators'.
</code></pre>

<p>Locally, if I delete <code>node_modules/</code> and run <code>npm install</code> followed by <code>npm test</code> I don't have any issue with rxjs.</p>

<p>My <code>package.json</code>:</p>

<pre><code>""dependencies"": {
  ""@angular/animations"": ""7.2.4"",
  ""@angular/common"": ""7.2.4"",
  ""@angular/compiler"": ""7.2.4"",
  ""@angular/core"": ""7.2.4"",
  ""@angular/forms"": ""7.2.4"",
  ""@angular/http"": ""7.2.4"",
  ""@angular/platform-browser"": ""7.2.4"",
  ""@angular/platform-browser-dynamic"": ""7.2.4"",
  ""@angular/platform-server"": ""7.2.4"",
  ""@angular/router"": ""7.2.4"",
  ""@ng-bootstrap/ng-bootstrap"": ""^4.0.2"",
  ""@nguniversal/module-map-ngfactory-loader"": ""7.1.0"",
  ""angularx-social-login"": ""^1.2.6"",
  ""aspnet-prerendering"": ""^3.0.1"",
  ""bootstrap"": ""^4.2.1"",
  ""core-js"": ""^2.5.4"",
  ""rxjs"": ""^6.4.0"",
  ""zone.js"": ""^0.8.29""
},
""devDependencies"": {
  ""@angular-devkit/build-angular"": ""~0.13.0"",
  ""@angular/cli"": ""~7.3.0"",
  ""@angular/compiler-cli"": ""7.2.4"",
  ""@angular/language-service"": ""^7.2.4"",
  ""@types/jasmine"": ""~2.8.6"",
  ""@types/jasminewd2"": ""~2.0.3"",
  ""@types/node"": ""~8.9.4"",
  ""bootstrap-sass"": ""3.4.0"",
  ""codelyzer"": ""~4.5.0"",
  ""jasmine-core"": ""~2.99.1"",
  ""jasmine-spec-reporter"": ""~4.2.1"",
  ""karma"": ""^3.0.0"",
  ""karma-chrome-launcher"": ""~2.2.0"",
  ""karma-coverage-istanbul-reporter"": ""~1.4.2"",
  ""karma-jasmine"": ""~1.1.1"",
  ""karma-jasmine-html-reporter"": ""^0.2.2"",
  ""typescript"": ""~3.2.4""
},
""optionalDependencies"": {
  ""node-sass"": ""4.11.0"",
  ""protractor"": ""~5.4.0"",
  ""ts-node"": ""~5.0.1"",
  ""tslint"": ""~5.9.1""
}
</code></pre>

<p>The offending lines in <code>login-form.component.ts</code>:</p>

<pre><code>import { Subscription } from 'rxjs';
import { finalize } from 'rxjs/Operators';
</code></pre>

<p>I can provide any source on here that is helpful but I don't know what is relevant.</p>
","2190852","","","","","2019-02-18 22:29:59","Angular 7 CI rxjs/Operators cannot find module","<angular><rxjs><node-modules><circleci><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54761277","1","","","2019-02-19 08:00:11","","0","70","<p>Using rxjs6</p>

<pre><code>  // should be dynamic
  const bufferSize = 3

  interval(100)
    .pipe(bufferCount(bufferSize))
    .subscribe(x =&gt; console.log(x))
</code></pre>

<p>I want to change a bufferSize at runtime without recreating a stream. Any ideas how to do so?</p>
","11083018","","","","","2019-02-20 09:33:08","Change bufferCount value at runtime","<javascript><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54789355","1","54866601","","2019-02-20 15:03:07","","1","166","<p>What's the best way to handle asynchronous updates in the middle of an Observable stream.</p>

<p>Let's say there are 3 observables:</p>

<p>Obs1 (gets data from API) -> pipes to Obs2
Obs2 (transforms data) -> pipes to Obs3
Obs3 (sends transformed data)</p>

<p>(The actual application is more complex, and there's reasons it's not done in a single Observable, this is just a simple example).</p>

<p>That all works well and good if it's a linear synchronous path.</p>

<p>But we also have async messages that will change the output of Obs2.</p>

<p>3 scenarios I'm asking about are:
 - we fetch data, and go through Obs1, Obs2 &amp; Obs3
 - we get a message to make a change, go through Obs2 &amp; Obs3
 - we get a different message to make a change which also needs to apply the change from the previous message, through Obs2 &amp; Obs3</p>

<p>The main problem here is that there are different types of asynchronous messages that will change the outcome of Obs2, but they all need to still know what the previous outcome of Obs2 was (so the any other changes from messages that happened before is still applied)</p>

<p>I have tried using switchMap in Obs2 with a scan in Obs1 like this:</p>

<p>obs1</p>

<pre><code>const obs1$ = obs1$.pipe(
  // this returns a function used in the reducer.
  map((data) =&gt; (prevData) =&gt; 'modifiedData',
  scan((data, reducer) =&gt; reducer(betsMap), {})
)
</code></pre>

<p>obs2</p>

<pre><code>const obs2$ = obs1$.pipe(
  switchMap(data =&gt;
    someChange$.pipe(map(reducer =&gt; reducer(data)))
  )
)
</code></pre>

<p>where <code>someChange$</code> is a BehaviorSubject applying a change using another reducer function.</p>

<p>This works fine for async message #1 that makes some change.
But when message #2 comes in and a different change is needed, the first change is lost.</p>

<p>the changes that should be in ""prevData"" in obs1$ is always undefined because it happens before the message is applied.</p>

<p>How can I take the output from obs2$ and apply asynchronous updates to it that remembers what all of the past updates was? (in a way where I can clear all changes if needed)</p>
","4010197","","","","","2019-02-25 12:49:14","rxjs async updates to Observable","<rxjs><reactive-programming><rxjs6>","1","0","","","","CC BY-SA 4.0"
"54802625","1","","","2019-02-21 08:39:45","","2","277","<p>Greetings fellow programmers,</p>

<p>I have a subscription to an observable in an Angular-component where I want to immediately run the subscribe function on the first emission, but debounce all the subsequent, implemented like this:</p>

<pre><code>concat(
  inputStream$.pipe(take(1)),
  inputStream$.pipe(
    skip(1),
    debounceTime(500))
).subscribe(val =&gt; someFunction(val));
</code></pre>

<p>However, as <code>inputStream$</code> comes from an external service, I wish to end the subscription on the destruction of the component. As is usual, I have a local <code>destroy$</code> that emits on <code>ngOnDestroy</code> and was about to do the usual <code>takeUntil(this.destroy$)</code>.</p>

<p>However in this case I'm a bit concerned about where I should end the subscription. Would it be within the concat inside both the individual pipes, or inside a pipe on the concat-stream itself? Or is there even another better way to do this correctly for concatting streams?</p>

<p>In other words, my two suggestions are:</p>

<p><strong>Inside each pipe:</strong></p>

<pre><code>concat(
  inputStream$.pipe(
    take(1),
    takeUntil(this.destroy$)),
  inputStream$.pipe(
    skip(1),
    debounceTime(500),
    takeUntil(this.destroy$))
).subscribe(val =&gt; someFunction(val));
</code></pre>

<p><strong>On the concat-stream itself:</strong></p>

<pre><code>concat(
  inputStream$.pipe(take(1)),
  inputStream$.pipe(
    skip(1),
    debounceTime(500))
).pipe(
  takeUntil(this.destroy$)
).subscribe(val =&gt; someFunction(val));
</code></pre>

<p>Thanks a lot for any help!</p>
","8779395","","8779395","","2019-02-21 09:13:47","2019-02-21 09:13:47","Unsubscribing on destroy for concatenated observables","<angular><rxjs><observable><rxjs6>","0","3","","","","CC BY-SA 4.0"
"54809840","1","","","2019-02-21 14:49:19","","2","3286","<p><code>valueChanges</code> Observable which exists on FormControl object emits value each time <code>setValue(value)</code> function gets called on FormControl object.</p>

<p>Using RxJS operator <code>distinctUntilChanged</code> we can filter out values which aren't new. But this doesn't work if FormControl has initial value.</p>

<pre><code>const formGroup1 = new FormGroup({page: new FormControl(1)});
const formControl1 = formGroup1.get('page');
formControl1.valueChanges.pipe(distinctUntilChanged())
  .subscribe(v =&gt; console.log(`new formControl1 value: ${v}`));
formControl1.setValue(1);
formControl1.setValue(2);
</code></pre>

<p>this is going to log</p>

<pre><code>&gt; new form1Control value: 1
&gt; new form1Control value: 2
</code></pre>

<p>1 is the first value <code>valueChanges</code> Observable emits, because formControl1 value was set before <code>valueChanges</code> Observable was created. </p>

<p><code>distinctUntilChanged</code> never filters out first emitted value</p>

<p>Here is one solution to this problem:</p>

<pre><code>const formGroup2 = new FormGroup({page: new FormControl(1)});
const formControl2 = formGroup2.get('page');
formControl2.valueChanges.pipe(
    startWith(1),
    distinctUntilChanged(),
    skip(1)
).subscribe(v =&gt; console.log(`new formControl2 value: ${v}`));
formControl2.setValue(1);
formControl2.setValue(2);
</code></pre>

<p>Here I'm modifying <code>valueChanges</code> Observable by emitting FormControl initial value, and then skipping it. So the first time <code>distinctUntilChanged</code> gets called, which is line:</p>

<p><code>formControl2.setValue(1)</code></p>

<p>it will already have previousValue (1) to compare new value to, so function inside subscribe won't get executed.</p>

<p>But I don't really like this solution. Is there built-in or recommended way to deal with FormControl value changes in Angular7 and RxJS6?</p>

<p>stackblitz: <a href=""https://stackblitz.com/edit/angular-arevmw?file=app%2Ficon-overview-example.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-arevmw?file=app%2Ficon-overview-example.ts</a></p>
","8687597","","","","","2019-02-21 15:25:36","Best way to subscribe to true value changes of FormControl in Angular2+?","<javascript><angular><rxjs><angular-reactive-forms><rxjs6>","2","0","","","","CC BY-SA 4.0"
"54829140","1","54831886","","2019-02-22 14:21:50","","3","618","<p>I'm trying to implement a togglable auto-save feature using RxJS streams. The goal is to:</p>

<ul>
<li>While auto-save is enabled, send changes to the server as they come.</li>
<li>While auto-save is disabled, buffer the changes and send them to the server when auto-save is re-enabled.</li>
</ul>

<p>Here is what I came across with:</p>

<pre class=""lang-js prettyprint-override""><code>autoSave$ = new BehaviorSubject(true);
change$ = new Subject();

change$.pipe(
  bufferToggle(
    autoSave$.pipe(filter(autoSave =&gt; autoSave === false)),
    () =&gt; autoSave$.pipe(filter(autoSave =&gt; autoSave === true)),
  ),
  concatMap(changes =&gt; changes),
  concatMap(change =&gt; apiService.patch(change)),
).subscribe(
  () =&gt; console.log('Change sent'),
  (error) =&gt; console.error(error),
);
</code></pre>

<p>Thanks to <code>bufferToggle</code>, I'm able to buffer the changes while <code>autoSave</code> is off and send them when it's re-enabled.</p>

<p>Problem is that while <code>autoSave</code> is enabled, nothing passes through. I understand it's because <code>bufferToggle</code> ignores the flow coming while its opening observable doesn't emit.</p>

<p>I feel that I should have a condition there to bypass the <code>bufferToggle</code> while <code>autoSave</code> is enabled, but all my attempts miserably failed.</p>

<p>Any idea to achieve this?</p>
","3864300","","","","","2020-09-30 11:54:34","Pausable buffer with RxJS","<rxjs><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"54862366","1","54867651","","2019-02-25 08:44:30","","0","191","<p>I've got this stream which shows/hides notifications:</p>

<pre><code>this.subscription = this.notificationsApi.notifications$.pipe(
  concatMap((event) =&gt; {

    return of(event).pipe(
      delay(450),
      tap(() =&gt; {
        this.notification = event;
        this.isActive = true;
        this.cd.markForCheck();
      }),
      delay(isDefined(event.showFor) ? event.showFor : this.hideAfter),
      /// Pause here if you hover over the notification ///
      tap(() =&gt; {
        this.isActive = false;
        this.cd.markForCheck();
      }),
      delay(450)
    );
  })
).subscribe(() =&gt; {});
</code></pre>

<p>What I would like to do is pause the stream when you hover over the notification and continue when you're no longer hovering over it:</p>

<pre><code>&lt;div (mouseover)=""pause()"" (mouseout)=""continue()""&gt;&lt;/div&gt;
</code></pre>

<p>This is where I can't seem to find a solution that works in this case. I'm assuming I have to use another 1-2 <code>Subject</code>s and then use <code>switchMap</code> depending on if you pause or continue but like I said I can't figure out how exactly.</p>

<p>I tried looking at <a href=""https://stackblitz.com/edit/typescript-ivdebg?file=index.ts"" rel=""nofollow noreferrer"">this StackBlitz for switchMap pause/resume functionality</a> but when I tried that approach it didn't show any notifications at all.</p>

<p>Any pointers?</p>
","4054974","","107625","","2019-02-25 08:48:15","2019-03-05 16:14:45","Pause notifications stream on mouseover and resume on mouseout","<rxjs><rxjs6>","1","5","2","","","CC BY-SA 4.0"
"54882865","1","54883119","","2019-02-26 10:00:43","","0","336","<p>In my component, I am getting the events from parent. ( wrapper ) But before i send to template, I require to iterate and add the date value in the array. not works for me after i do this with subscribe. </p>

<p>any one show me the correct way to re-assign the value after do the iteration?</p>

<p>here is my try:</p>

<pre><code>import { Component, OnInit, ChangeDetectionStrategy, Input  } from '@angular/core';
import { CalendarService } from ""./../../services/calendar.service"";
import { ModelEvent, EventState } from ""./../../models/model.event"";
import { CalendarEvent } from 'angular-calendar';
import { colors } from ""./../../utilities/colors"";
import { setHours, setMinutes, setDate } from 'date-fns';
import { Observable } from 'rxjs';
import { tap, map } from 'rxjs/operators';
declare var $:any;

@Component({
    selector: 'ibo-calendar',
    templateUrl: './ibo-calendar.component.html',
    styleUrls: ['./ibo-calendar.component.scss']
})
export class IboCalendarComponent implements OnInit {

    // events = [];
    eventId:number | null;

    view: string = 'month';
    // viewDate: Date = new Date('August 19, 2018');
    viewDate: Date = new Date()

    @Input() events:Observable&lt;ModelEvent[]&gt;;
    @Input() currentEvent: ModelEvent;

    clickedDate: Date;
    updatedEvents:Observable&lt;ModelEvent[]&gt;;

    constructor(private calendarService:CalendarService) { }

    ngOnInit() {

        this.updatedEvents = this.events.subscribe(events =&gt; {
            console.log('events', events); //getting consoled.
            return map(event =&gt; { //not works!!
                return {
                    title : event.title,
                    name : event.name,
                    date : new Date()
                }
            })
        })

}
</code></pre>
","218349","","","","","2019-02-26 11:17:27","How to add `map` operator in subscribe","<angular><observable><rxjs6>","4","3","","","","CC BY-SA 4.0"
"54892708","1","","","2019-02-26 19:25:28","","1","385","<p>I faced a problem using stencil with rxjs 6</p>

<p>Just created a stencil component by executing <code>npm init stencil</code> and chose <code>component</code> from the list.</p>

<p>Added <code>rxjs</code> to <code>package.json</code> and updated stencil to latest version:</p>

<pre><code>  ""devDependencies"": {
    ""@stencil/core"": ""^0.18.0"",
    ""rxjs"": ""^6.4.0""
  }
</code></pre>

<p>Created a simple component:</p>

<pre><code>import { Component, Element } from '@stencil/core';
import { fromEvent } from 'rxjs';
import { throttleTime } from 'rxjs/operators';

@Component({
  tag: 'my-component',
  shadow: true
})
export class MyComponent {
  @Element() el: HTMLElement;

  componenDidLoad() {
    const btn = this.el.shadowRoot.getElementById('btn');
    const clicks = fromEvent(btn, 'click');
    const result = clicks.pipe(throttleTime(1000));
    result.subscribe(x =&gt; console.log(x));
  }
  render() {
    return &lt;button id=""btn""&gt;click me&lt;/button&gt;;
  }
}
</code></pre>

<p>and on <code>npm run start</code> got an empty page with following error in the browser console:</p>

<p><code>TypeError: Cannot read property 'h' of undefined</code></p>

<p><a href=""https://i.stack.imgur.com/CMucW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CMucW.png"" alt=""enter image description here""></a></p>
","3276007","","3276007","","2019-02-27 12:49:31","2019-05-18 21:12:09","Stencil with RxJS 6","<rxjs6><stenciljs>","1","6","","","","CC BY-SA 4.0"
"54896682","1","","","2019-02-27 01:31:35","","1","106","<p>So upgrading an angular project from 5 to 7.   I migrated my RxJs chains to use pipe.   I do alot of querying and hence use switchMap to do lookups; but typescript and RxJs 6.2 now want me to cast the switchMap return type as Observable, where it did not before. Maybe this is a problem with implicit typing in RxJs? shouldn't switchMap always return an Observable?  For example:</p>

<p>Before: </p>

<pre class=""lang-js prettyprint-override""><code>function GetFoo() : Observable&lt;IFoo&gt;
// ...
GetFoo.pipe(switchMap&lt;IFoo,IBar&gt;(foo =&gt; GetBarObservable(foo))
   .subscribe(bar =&gt; {
     console.log(bar) 
   });
</code></pre>

<p>Now needs to be:</p>

<pre class=""lang-js prettyprint-override""><code>function GetFoo() : Observable&lt;IFoo&gt;
// ...  note 2nd arg is now Observable&lt;IBar&gt;
GetFoo.pipe(switchMap&lt;IFoo,Observable&lt;IBar&gt;&gt;(foo =&gt; GetBarObservable(foo))
   .subscribe(bar =&gt; {
     console.log(bar) 
   });
</code></pre>

<p>Code works fine once changed and none of the tools complained, but not sure I understand why?</p>
","1367826","","","","","2019-02-27 01:31:35","Why does switchMap use in pipe in typescript now require Observable<> for 2nd arg?","<angular><typescript><rxjs6>","0","1","","","","CC BY-SA 4.0"
"54906423","1","","","2019-02-27 13:17:10","","0","277","<p>I am pulling my hair out a little with attempting to group data recursively in rxjs. There seems to be alot of good examples around with different use cases but I cant seem to refactor the code around to fit my requirements.</p>

<p>The central problem that I can infer is that in my map operator I have a conditional return which is either a non-observable or an observable. Is there a way I can refactor to account for this discrepency?</p>

<p>Ideally this function would group an original ""flat"" array by an arbitrary amount of columns that are passed in as the cols argument.</p>

<p>Each time the criteria is satisfied it would 
append to an array in the format 
{ key: col_name, elements : [...col_elements] } where elements would be another array of elements in the same format, or a straight list of elements.</p>

<p>The below function works when only grouping the columns once ( and thus never requiring the observable within map to emit ).</p>

<pre><code>//group data n times based on passed string[] of column attributes
  group_data(elements: Observable&lt;any&gt;, cols: string[], index=0) : Observable&lt;any&gt; {
    let col = cols[index]

    return elements.pipe(
      //groupby column value
      RxOp.groupBy((el:any) =&gt; this.get_groupingValue(el, col)),

      //place key inside array
      RxOp.mergeMap((group) =&gt; group.pipe(
        RxOp.reduce((acc, cur) =&gt; [...acc, cur], ["""" + group.key]))
      ),
      // map to key:group
      RxOp.map((arr:any) =&gt;

          cols.length &lt;= index + 1?
          // no more grouping req
          { 'key': arr[0], 'elements': arr.slice(1) } :

          //group recursively, returns Observable instead of array:(
          { 'key': arr[0], 'elements':
            this.group_data(from(arr.slice(1)), cols, index + 1)
              .pipe(
                RxOp.tap(t=&gt; console.log(t)), // not logged
                RxOp.reduce((acc, val) =&gt; [...acc, val], [])

              )
          }),
      RxOp.toArray()
    )
  }

//simplified data example:

data = [{id: 'idA', type: 'project', parents: null },
 {id: 'idB', type: 'project', parents: null },
 {id: 'idC', type: 'episode', parents: ['idA'] },
 {id: 'idD', type: 'episode', parents: ['idB'] },
 {id: 'idE', type: 'scene', parents: ['idA', 'idC'] },
 {id: 'idF', type: 'scene', parents: ['idB', 'idD'] }] 

// 1 column passed works correctly as below

group_data(elements: from(data), ['project'])

/* outputted data:
[{key: 'idA', 
  elements: [ {id: 'idC', type: 'episode', parents: ['idA'] },
              {id: 'idE', type: 'scene', parents: ['idA', 'idC'] }]},
{key: 'idB', 
  elements: [ {id: 'idD', type: 'episode', parents: ['idA'] },
              {id: 'idF', type: 'scene', parents: ['idA', 'idC'] }]},

{key: null,
  elements: [ {id: 'idA', type: 'project', parents: [] }
              {id: 'idB', type: 'project', parents: [] }]}
]
*/

// 2 columns not working correctly
group_data(elements: from(data), ['project', 'episode'])
/*[{key: 'idA', 
  elements: Observable},
{key: 'idB', 
  elements: Observable},
{key: null, 
  elements: Observable}
]*/
</code></pre>
","6924363","","6924363","","2019-02-27 23:01:28","2019-02-27 23:56:54","rxjs: recursive Observable emission inside map","<javascript><observable><rxjs6>","1","3","","","","CC BY-SA 4.0"
"54939488","1","","","2019-03-01 06:58:44","","1","1410","<p>In my angular 6 project am getting <strong>property map does not exist on type promise</strong> error even I included</p>

<pre><code>import 'rxjs/add/operator/map';
import 'rxjs/add/operator/catch';
import 'rxjs/add/operator/toPromise';
</code></pre>

<p>Following is my code</p>

<pre><code> submit(): Promise&lt;any&gt; {
        return http.post('api/SubmitEmployee', JSON.stringify(this.formData))
            .map((response: Response) =&gt; &lt;any&gt;response.json())
            .toPromise()
            .catch(this.handlePromiseError)
    }

    handlePromiseError(error: Response) {
        console.log(error)
    }
</code></pre>

<p>After some google I found solution like below but that is also not working</p>

<pre><code>import { map } from 'rxjs/operators';  

pipe(map((response: Response) =&gt; response.json()))
</code></pre>

<p>After including this it shows error <strong>property type does not exist on type promise</strong> 
Following is my custom <code>post</code> method</p>

<pre><code>post(url: string, content: any, resolve: ResolveFunction = null, reject: RejectFunction = null) {
    this.clearCache();
    const retryFunc = _ =&gt; this.post(url, content, resolve, reject);
    return fetch(appSettings.baseApiUri + url, {
      method: 'POST',
      headers: this.getCustomHeader(),
      body: content
    })
      .then(result =&gt; {
        this.handleResponse(url, result, retryFunc, resolve, reject);
      })
      .catch(error =&gt;
        this.debounce(_ =&gt; this.handleError(url, error, retryFunc).catch(_ =&gt; reject(error)), this.debounceTimeout)
      );
  }
</code></pre>
","11049579","","5490782","","2019-03-05 17:00:28","2019-03-05 17:00:28","property map does not exist on type promise<void>","<angular><rxjs><angular6><rxjs6>","1","2","","","","CC BY-SA 4.0"
"54949408","1","","","2019-03-01 17:15:18","","1","76","<p>I have a function that wraps observable with error handling, but to do so I need some code to run once it's inner observable is subscribed.</p>

<p>I also need that cancelling the higher <code>Observable</code> cancels the inner one, as it is doing HTTP call.</p>

<p>Context</p>

<pre><code>slideshow: string[] = [];
currentIndex = 0;
private is = {
    loading: new BehaviorSubject(false),
}

private loadImage(src: string): Observable;

private loadNextImage(index = this.currentIndex, preload = false): Observable&lt;number&gt; {
    const nextIndex = (index + 1) % this.slideshow.length;
        if (this.currentIndex == nextIndex) {
        if (!preload) {
            this.is.loading.next(false);
        }
        throw new Error('No other images are valid');
    }

    return ( possible code below )
}
</code></pre>

<p><code>Defer</code> - This worked nicely until I realised this will create a new instance for every subscriber.</p>

<pre><code>defer(() =&gt; {
    if (!preload) {
        this.is.loading.next(true);
    }
    return this.loadImage(this.slideshow[nextIndex]).pipe(
        finalize(() =&gt; {
            if (!preload) {
                this.is.loading.next(false);
            }
        }),
        map(() =&gt; nextIndex),
        catchError(err =&gt; this.loadNextImage(nextIndex)),
    );
});
</code></pre>

<p><code>Of(void 0).pipe(mergeMap(...))</code> - This does what is should, but it is really ugly</p>

<pre><code>of(void 0).pipe(
    mergeMap(() =&gt; {
        if (!preload) {
            this.is.loading.next(true);
        }

        return this.loadImage(this.slideshow[nextIndex]).pipe(
            finalize(() =&gt; {
                if (!preload) {
                    this.is.loading.next(false);
                }
            }),
            map(() =&gt; nextIndex),
            catchError(err =&gt; this.loadNextImage(nextIndex)),
        );
    }),
)
</code></pre>

<p><code>new Observable</code> - I think there should be a solution that I am missing</p>
","3001856","","","","","2019-03-01 17:15:18","RXJS listen to first subscription","<rxjs><rxjs6>","0","6","","","","CC BY-SA 4.0"
"54952297","1","54958147","","2019-03-01 21:06:43","","1","3755","<p>I'm still learning RxJs, and I'm trying to use concatMap() to NOT use nested subscriptions. I want the first call to run and then delay for a second or two (creating a database record before the second request) before running the second request. I also want to add error handling to each request specifically so I can catch errors for them individually.</p>

<p>So far, I have something that runs request 1, delays, and then runs request 2. </p>

<pre><code>return this.request_1(postData).pipe(
      concatMap(res =&gt; of(res).pipe( delay( 2000 ) )),
      concatMap(res =&gt; this.request_2(parseInt(data.id), parseInt(model['_id'])) )
    );
</code></pre>

<p>What I'm wondering is - </p>

<ol>
<li>can I use something like catchError() on each request?</li>
<li>is this correct if I want request 1 to complete before the second request runs?</li>
</ol>

<p>Thanks!</p>
","3069555","","3069555","","2019-03-01 21:14:24","2019-03-02 11:44:42","Angular 6 + RxJs - Error handling for concatMap","<angular><error-handling><rxjs6><concatmap>","1","0","","","","CC BY-SA 4.0"
"54970502","1","","","2019-03-03 15:36:51","","3","873","<p>I am using <a href=""https://github.com/ng-select/ng-select"" rel=""nofollow noreferrer"">ng-select</a> and specifically using typeahead to fetch the list from the server as user types. Following example as described in <a href=""https://github.com/ng-select/ng-select/blob/master/demo/app/examples/search.component.ts"" rel=""nofollow noreferrer"">typeahead example : <code>people3$</code></a>. My requirement is to add value when user clicks a button (I have <code>id</code> and <code>label</code> and corresponding object) but I am failing to understand :</p>

<ol>
<li>How can I push Item to <code>item : Observable&lt;any[]&gt;</code> I tried doing <code>this.item = concat(of([{label:this.field.display,id:value}]))</code> it pushes the value but it does not reflect the value in ng-select until I click somewhere else outside the element.</li>
<li>I tried <a href=""https://stackoverflow.com/questions/49168270/set-selected-value-in-angular5-ng-select"">this solution by <code>@ViewChild</code></a> and on <code>this.ngSelect.items = [{label:this.field.display,id:value}]</code> still it does not show value in ng-select.</li>
</ol>

<p><a href=""https://i.stack.imgur.com/YsbuI.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YsbuI.png"" alt=""error""></a></p>

<p>After adding value in group, I have added the object but still it does not shows, If i click anywhere soon value will be shown.</p>

<p>I want to know</p>

<ol>
<li>What possibly can be the reason for this behaviour.</li>
<li>preferred way to push items in <code>Observable&lt;any[]&gt;</code></li>
</ol>

<p>Here is my ng-select configuration : </p>

<pre><code>&lt;ng-select class=""form-control ng-select-padding""
                 [items]=""referenceItems | async""
                 [hideSelected]=""true""
                 [loading]=""searchFailed""
                 [typeahead]=""searchReferenceItems""
                 bindLabel=""label""
                 bindValue=""id""
                 (change)=""setField($event)""
                 (blur)=""onUpdated()""
                 [formControlName]=""field.name"" ngDefaultControl&gt;
      &lt;/ng-select&gt;

//@ TS file

searchReferenceItems =  new Subject&lt;object&gt;();
referenceItems: Observable&lt;any[]&gt; ;
</code></pre>

<p>Thanks for your kind help</p>
","5272540","","","","","2019-03-03 18:01:14","How to insert values in Observable type of array in ng-select","<angular><rxjs><angular6><rxjs6><angular-ngselect>","1","3","1","","","CC BY-SA 4.0"
"54990816","1","54990927","","2019-03-04 20:11:44","","0","68","<p>So I'm trying to dispatch different arrays of actions based on the user type that I get from the server when I make a API call to <code>/api/auth/login</code>.</p>

<pre><code>@Effect()
  login = this.actions$.pipe(
    ofType(AuthActions.ActionTypes.TryLogin),
    map((action: AuthActions.TryLogin) =&gt; {
      return action.payload;
    }),
    switchMap(loginData =&gt; {
      return this.httpClient.post&lt;{
        jwtToken: string;
        usertype: string;
        expiresIn: number;
        userId: string;
      }&gt;(`${this.BACKEND_URL}/api/auth/login`, loginData);
    }),
    mergeMap(res =&gt; {
      const actions = [
        {
          type: AuthActions.ActionTypes.Login
        },
        {
          type: AuthActions.ActionTypes.SetToken,
          payload: res.jwtToken
        },
        {
          type: AuthActions.ActionTypes.SetTokenExpiry,
          payload: res.expiresIn
        }
      ];
      if (res.usertype === 'Admin') {
        this.router.navigate(['/admin-panel']);

        return [...actions, {type: AdminActions.ActionTypes.SetId, payload: res.userId}];
      } else {
        this.router.navigate(['/client-panel']);

        return [...actions, {type: UserActions.ActionTypes.SetId, payload: res.userId}];

      }
    })
  );
</code></pre>

<p>But I'm getting this Error:</p>

<pre><code>Argument of type '(res: { jwtToken: string; usertype: string; expiresIn: number; userId: string; }) =&gt; ({ type: Act...' is not assignable to parameter of type '(value: { jwtToken: string; usertype: string; expiresIn: number; userId: string; }, index: number...'.
  Type '({ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string; } | { type: ...' is not assignable to type 'ObservableInput&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: strin...'.
    Type '({ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string; } | { type: ...' is not assignable to type 'ObservableInput&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: strin...'.
      Type '({ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string; } | { type: ...' is not assignable to type 'Iterable&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string; } | ...'.
        Types of property '[Symbol.iterator]' are incompatible.
          Type '() =&gt; IterableIterator&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload...' is not assignable to type '() =&gt; Iterator&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string...'.
            Type 'IterableIterator&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: stri...' is not assignable to type 'Iterator&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string; } | ...'.
              Types of property 'next' are incompatible.
                Type '{ (value?: any): IteratorResult&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes...' is not assignable to type '{ (value?: any): IteratorResult&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes...'. Two different types with this name exist, but they are unrelated.
                  Type 'IteratorResult&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string...' is not assignable to type 'IteratorResult&lt;{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string...'. Two different types with this name exist, but they are unrelated.
                    Type '{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string; } | { type: A...' is not assignable to type '{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string; } | { type: A...'. Two different types with this name exist, but they are unrelated.
                      Type '{ type: ActionTypes; payload: string; }' is not assignable to type '{ type: ActionTypes; payload?: undefined; } | { type: ActionTypes; payload: string; } | { type: A...'.
                        Type '{ type: ActionTypes; payload: string; }' is not assignable to type '{ type: ActionTypes; payload: string; }'. Two different types with this name exist, but they are unrelated.
                          Types of property 'type' are incompatible.
                            Type 'ActionTypes' is not assignable to type 'ActionTypes'. Two different types with this name exist, but they are unrelated.
</code></pre>

<p>It works alright if I separate out Admin Login and User Login. But it would mean much of the code will be identical. Can Anybody help me out here?</p>
","7982622","","5535245","","2019-03-04 21:16:14","2019-03-04 21:16:14","NgRx Effects: What am I doing Wrong?","<angular><ngrx><rxjs6><ngrx-effects>","1","2","","","","CC BY-SA 4.0"
"54992526","1","54992648","","2019-03-04 22:25:07","","0","647","<p>Scenario: When having an observable with lots of elements, 450+ for instance, I want to add these elements to a different observable in batches of 100 elements.</p>

<p>you can find a working example here: <a href=""https://stackblitz.com/edit/rxjs-au9pt7?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-au9pt7?file=index.ts</a> that @martin provided me as part of the answer to this question: <a href=""https://stackoverflow.com/questions/54852013/take-n-values-from-observable-until-its-complete-based-on-an-event-lazy-loading/54852912?noredirect=1#comment96483904_54852912"">Take N values from Observable until its complete based on an event. Lazy loading a multi select list</a></p>

<p>The stackblitz works like a charm, but I'm struggling to implement this in Angular. The observable (the outcome of the zip operator) completes without triggering any single value, but as you can see in the working example it works perfectly fine. I must be missing something, but I'm not sure exactly what.</p>

<p><strong>component.ts</strong></p>

<pre><code>import { Component, AfterViewInit } from '@angular/core';
import { zip, Observable, fromEvent, range } from 'rxjs';
import { map, bufferCount, startWith, scan } from 'rxjs/operators';
import { MultiSelectService, ProductCategory } from './multiselect.service';

@Component({
  selector: 'multiselect',
  templateUrl: './multiselect.component.html',
  styleUrls: ['./multiselect.component.scss']
})
export class MultiselectComponent implements AfterViewInit {

  SLICE_SIZE = 100;
  categories$: Observable&lt;Array&lt;ProductCategory&gt;&gt;;

  constructor(private data: MultiSelectService) {
    this.categories$ = data.categories$;
  }

  ngAfterViewInit() {
    const loadMore$ = fromEvent(document.getElementsByTagName('button')[0], 'click');
    const data$ = range(450);

    zip(
      data$.pipe(bufferCount(this.SLICE_SIZE)),
      loadMore$.pipe(startWith(0)),
    ).pipe(
      map(results =&gt; results[0]),
      scan((acc, chunk) =&gt; [...acc, ...chunk], []),
    ).subscribe({
      next: v =&gt; console.log(v),
      complete: () =&gt; console.log('complete'),
    });
  }

}
</code></pre>

<p><strong>template.html</strong></p>

<pre><code>&lt;button&gt;load more&lt;/button&gt;
</code></pre>

<p>Thanks a lot in advance, any help is greatly appreciated.</p>
","943082","","943082","","2019-03-04 22:36:48","2019-03-04 23:33:08","RxJS zip() operator doesn't work as expected. It always completes without triggering any value","<javascript><angular><rxjs><reactive-programming><rxjs6>","2","0","","","","CC BY-SA 4.0"
"55012020","1","55052773","","2019-03-05 21:38:29","","1","987","<p>Let's say I have this observable:</p>

<pre><code>const obs = new Observable((observer) =&gt; {
    observer.next(0.25);
    observer.next(0.75);
    observer.next(new ArrayBuffer(100));
    observer.complete();
});
</code></pre>

<p>How can I wait for each value with a promise?</p>

<p>The following code will only return the last value (value before complete() is called):</p>

<pre><code>const value = await obs.toPromise();
</code></pre>

<p>But I want to be able to get each value along the way. I can do something like this:</p>

<pre><code>const value1 = await obs.pipe(take(1)).toPromise();
const value2 = await obs.pipe(take(2)).toPromise();
</code></pre>

<p>But that's not ideal, since I'd have to increment the number each time and also <code>take(1000)</code> would still return something in the example, even though there are only 3 values. I'm looking for something like:</p>

<pre><code>const value1 = await obs.pipe(next()).toPromise(); // 0.25
const value2 = await obs.pipe(next()).toPromise(); // 0.75
const value3 = await obs.pipe(next()).toPromise(); // ArrayBuffer(100)
const value4 = await obs.pipe(next()).toPromise(); // null
</code></pre>

<p>That is more akin to a generator.</p>

<p>Is there a way to accomplish something like this?</p>
","5086286","","674326","","2019-03-07 21:05:39","2019-03-07 21:18:12","How to wait for each value of an observable with a promise","<javascript><promise><rxjs><observable><rxjs6>","2","11","","","","CC BY-SA 4.0"
"55013723","1","55013894","","2019-03-06 00:32:33","","0","36","<p>I want to use the result of one subscription to feed another. What is the best way of doing this in Angular 7? Currently, my subscription works intermittently (data is not returned to the user).</p>

<pre><code>this.userService.getNumberOfUsers().subscribe(data =&gt; {
  if (data) {
    this.noOfUsers = data.data['counter'];
    this.tempRanking = this.referralService.getWaitlist().subscribe(waitlistResult =&gt; {
      if (waitlistResult &amp;&amp; this.userData.referralId) {
        return this.referralService.calculateRanking(this.userData.referralId, waitlistResult).then((result: number) =&gt; {
          if (result) {
            if (result &gt; this.noOfUsers) {
              this.ranking = this.noOfUsers;
            } else {
              this.ranking = result;
            }
          }
        });
      }
    });
  }
});
</code></pre>
","436493","","","","","2019-03-06 01:38:46","Chaining observables and feeding result into next","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55039579","1","","","2019-03-07 08:51:39","","0","248","<p>Let's say I have two Observables A and B, and I want to combine them to produce this behaviour: the subscription combination returns only if A fires when a B has already been fired. It differs from the zip because I don't want any return if A has already been fired and then a B fires. In other words: ignores A until B fires then return on the next A, then ignore any other A until B fires ... so on</p>
","5590857","","7436489","","2019-03-07 10:38:50","2019-03-07 10:40:50","Rxjs zip-like operator which returns only when observable fires in specific order","<rxjs><rxjs6><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"55054996","1","","","2019-03-08 00:27:33","","1","1700","<p>I am trying to create a service that will allow me to:</p>

<ol>
<li>Upload files to Azure blob storage</li>
<li>Return progress</li>
<li>When failed retry</li>
<li>When successful call my service to save the file path</li>
</ol>

<p>To achieve this I started by following <a href=""https://medium.com/@stuarttottle/upload-to-azure-blob-storage-with-angular-7977e979496a"" rel=""nofollow noreferrer"">this tutorial on Medium</a>. I have been able to save files in the storage and return the current progress.</p>

<p>My problems come when I want to call my service with the file path saved.</p>

<p>I have looked at the following to try and work out how to achieve this but without any success <a href=""https://coryrylan.com/blog/angular-multiple-http-requests-with-rxjs"" rel=""nofollow noreferrer"">making multiple http requests</a>, <a href=""http://reactivex.io/rxjs/class/es6/MiscJSDoc.js~ObserverDoc.html"" rel=""nofollow noreferrer"">the rxjs docs</a> <a href=""https://blog.angularindepth.com/practical-rxjs-in-the-wild-requests-with-concatmap-vs-mergemap-vs-forkjoin-11e5b2efe293"" rel=""nofollow noreferrer"">making subsequent http requests</a>.</p>

<p>I'm struggling to understand how I change the examples into something I can use.</p>

<p>Please note that I am trying to make the azureBlobStorageService reusable, therefore I am not making the second HTTP call within the azure service, that will be the responsibility of the caller.</p>

<p>Below is my code with comments where I have tried to add the mergeMap or flatMap etc, but without success. I have removed those references as I have tried so many variations I feel comments give a clearer picture of what i'm trying to achieve</p>

<p><strong>Upload component</strong></p>

<pre><code>this.uploadProgress$ = from(inputNode.files as FileList).pipe(
  map(file =&gt; this._uploadService.updateCertificate(file)),
  combineAll()
);
</code></pre>

<p><strong>Upload service</strong></p>

<pre><code>// this is where I would like to call my REST api when the file has uploaded to azure
updateCertificate(file: File): Observable&lt;IUploadProgress&gt; {
      return this._azureBlobStorage
        .uploadCertificateToBlobStorage(file, this.group)
        .pipe(
          map(
            progress =&gt; this.mapProgress(file, progress)
          ),
          //  flatMap(x =&gt; this._httpClient.post('xcv', JSON.Stringify(sasToken.filename))) &lt;--fail 1
        )
        .pipe(flatMap(x =&gt; this._httpClient.post('', JSON.stringify('')))); &lt;-- fail 2
  } // also tried merge map and a couple of others

  private mapProgress(file: File, progress: number): IUploadProgress {
    return {
      filename: file.name,
      progress: progress
    };
  }
</code></pre>

<p><strong>Azure BlobStorage Service</strong></p>

<pre><code>uploadCertificateToBlobStorage(file: File, group: string): Observable&lt;number&gt; 
{
  this.populateSasToken('/cert/' + group + '/' + file.name);
  return this.uploadToBlobStorage(this.sasToken, file);
}

private populateSasToken(filename: string): void {
    //create sasToken stuff
  }

private uploadToBlobStorage(sasToken: ISasToken, file: File): Observable&lt;number&gt; {
  const customBlockSize = this.getBlockSize(file);
  const options = { blockSize: customBlockSize };
  const blobService = this.createBlobService(sasToken.storageAccessToken, sasToken.storageUri);

  blobService.singleBlobPutThresholdInBytes = customBlockSize;

  return this.uploadFile(blobService, sasToken, file, options);
}

  private createBlobService(sasToken: string, blobUri: string): IBlobService {
    return this._blobStorage
      .createBlobServiceWithSas(blobUri, sasToken)
      .withFilter(new this._blobStorage.ExponentialRetryPolicyFilter());
  }

// Need to change this to return a custom object with number and the sasToken.filename
// but when I change this return type and the return of the associated methods I errors, I can't see what i'm missing
private uploadFile(
    blobService: IBlobService,
    sasToken: ISasToken,
    file: File,
    options: { blockSize: number }
  ): Observable&lt;number&gt; {
    return new Observable&lt;number&gt;(observer =&gt; {
      const speedSummary = blobService.createBlockBlobFromBrowserFile(
        sasToken.container,
        sasToken.filename,
        file,
        options,
        error =&gt; this.callback(error, observer)
      );
      speedSummary.on('progress', () =&gt; this.getProgress(speedSummary, observer, sasToken.filename));
    }).pipe(
      startWith(0),
      distinctUntilChanged()
      // retry(4) I think this will allow me to retry failed called to azure. 
    );
  }

  private getProgress(speedSummary: ISpeedSummary, observer: Subscriber&lt;number&gt;, fileName: string): void {
    const progress = parseInt(speedSummary.getCompletePercent(2), 10);
    observer.next(progress === 100 ? 99 : progress);
  }

  private callback(error: any, observer: Subscriber&lt;number&gt;): void {
    if (error) {
      console.log(error);
      observer.error(error);
    } else {
      observer.next(100);
      observer.complete();
    }
  }
</code></pre>

<p>================================</p>

<p>Changes to upload file</p>

<p>the below causes</p>

<blockquote>
  <p>Type Observable  is not assignable to type Observable</p>
</blockquote>

<p>================================</p>

<pre><code>export class Xxx {
  y: number;
  x: string;
}




private uploadFile(
    blobService: IBlobService,
    sasToken: ISasToken,
    file: File,
    options: { blockSize: number }
  ): Observable&lt;Xxx&gt; {
    return new Observable&lt;Xxx&gt;(observer =&gt; {
      const speedSummary = blobService.createBlockBlobFromBrowserFile(
        sasToken.container,
        sasToken.filename,
        file,
        options,
        error =&gt; this.callback(error, observer)
      );
      speedSummary.on('progress', () =&gt; this.getProgress(speedSummary, observer, sasToken.filename));
    }).pipe(
      startWith(0),
      distinctUntilChanged(),
      retry(4)
    );
  }

  private getProgress(speedSummary: ISpeedSummary, observer: Subscriber&lt;Xxx&gt;, fileName: string): void {
    const progress = parseInt(speedSummary.getCompletePercent(2), 10);
    // observer.next(progress === 100 ? 99 : progress);
    observer.next(new Xxx());
  }

  private callback(error: any, observer: Subscriber&lt;Xxx&gt;): void {
    if (error) {
      console.log(error);
      observer.error(error);
    } else {
      // observer.next(100);
      observer.next(new Xxx());
      observer.complete();
    }
  }
</code></pre>
","1363329","","","","","2019-11-06 16:19:33","Angular 7 upload to blob storage with progress indicator","<angular><http><rxjs><rxjs6>","2","5","1","","","CC BY-SA 4.0"
"55073535","1","","","2019-03-09 02:47:38","","0","510","<p>I have written many unit tests to test observables, but for some reason, this test is not working like the other ones I've written, but I dont see what the issue is.  </p>

<p>I would like a mock for ChangePasswordFacade.successful$ to return an Observable that returns true.  Even though I have previously used the mocking strategy below, it's not working. I tried injecting ChangePasswordFacade into the test.  I tried using a mock successful$ function in the useValue of the TestBed provider. And I tried the approach below.  They all yield sucessful$ as false.  How can I mock this out differently to return true?  </p>

<pre><code>import { ComponentFixture, TestBed } from '@angular/core/testing';
import { PasswordChangeModalComponent } from './password-change-modal.component';
import { ReactiveFormsModule } from '@angular/forms';
import { PasswordChangeFormComponent } from '../../..';
import { DefaultPopoverComponent } from '@bis-angular/shared-components/pattern-library';
import { Store, StoreModule } from '@ngrx/store';
import {
  ChangePasswordFacade,
  UserInformationFacade,
  changePasswordInitialState,
  CHANGEPASSWORD_FEATURE_KEY,
  changePasswordReducer
} from '@bis-angular/users';
import { configureTestSuite } from 'ng-bullet';
import { of } from 'rxjs';

describe('PasswordChangeModalComponent', () =&gt; {
  let component: PasswordChangeModalComponent;
  let fixture: ComponentFixture&lt;PasswordChangeModalComponent&gt;;

  const childDefaultPopoverComponent = jasmine.createSpyObj('DefaultPopoverComponent', ['hideModal', 'showModal']);
  const childPasswordChangeFormComponent = jasmine.createSpyObj('PasswordChangeFormComponent', ['setFormControlsToEmpty']);

  const changePasswordFacadeSpy = jasmine.createSpyObj('ChangePasswordFacade', ['resetState']);

  configureTestSuite(() =&gt; {
    TestBed.configureTestingModule({
      imports: [
        ReactiveFormsModule,
        StoreModule.forRoot({}),
        StoreModule.forFeature(CHANGEPASSWORD_FEATURE_KEY, changePasswordReducer, {
          initialState: changePasswordInitialState
        })
      ],
      declarations: [PasswordChangeFormComponent, DefaultPopoverComponent, PasswordChangeModalComponent],
      providers: [Store, UserInformationFacade, ChangePasswordFacade]
    });
  });

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(PasswordChangeModalComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
    component.defaultPopoverComponent = childDefaultPopoverComponent;

    component.watchSuccessful = { unsubscribe: () =&gt; {} };
    spyOn(component.watchSuccessful, 'unsubscribe');
    const service = TestBed.get(ChangePasswordFacade);
    spyOn(service, 'successful$').and.returnValue(of(true));
  });


  describe('showPasswordChangeModal function ', () =&gt; {
    it('should call showModal and then not hide if not successful  ', () =&gt; {
      spyOn(component, 'hidePasswordChangeModal');
      component.successful$.subscribe((successful: boolean) =&gt; {
        expect(component.hidePasswordChangeModal).toHaveBeenCalled();
        expect(changePasswordFacadeSpy.resetState).toHaveBeenCalled();
        expect(component.watchSuccessful.unsubscribe).toHaveBeenCalled();
      });
      component.showPasswordChangeModal();
      expect(childDefaultPopoverComponent.showModal).toHaveBeenCalled();
    });
  });


});
</code></pre>

<pre><code>import { Injectable } from '@angular/core';
import { select, Store } from '@ngrx/store';
import { ChangePasswordPartialState } from './change-password.reducer';
import { changePasswordQuery } from './change-password.selectors';
import { ChangePassword, ChangePasswordResetState } from './change-password.actions';
import { NewPassword } from '@bis-angular/users';

@Injectable()
export class ChangePasswordFacade {
  successful$ = this.store.pipe(select(changePasswordQuery.getSuccessful));

  initiated$ = this.store.pipe(select(changePasswordQuery.getInitiated));

  constructor(private store: Store&lt;ChangePasswordPartialState&gt;) {}

  changePassword(newPassword: NewPassword, userId: string) {
    this.store.dispatch(new ChangePassword(newPassword, userId));
  }

  resetState() {
    this.store.dispatch(new ChangePasswordResetState());
  }
}
</code></pre>
","372225","","372225","","2019-03-09 04:26:02","2019-03-15 17:38:36","how to mock out an Observable? I have tried to mock it out three different ways","<angular><unit-testing><karma-jasmine><rxjs6>","2","1","","","","CC BY-SA 4.0"
"55119622","1","","","2019-03-12 10:47:43","","0","259","<p>How do I migrate from RxJS 5 to RxJS 6 fromPromise while keeping typings in place?</p>

<p>RxJS 5, all ok:</p>

<pre><code>return Observable.fromPromise&lt;SomeInterface&gt;(somePromiseFn())
</code></pre>

<p>RxJS 6:</p>

<pre><code>return from&lt;SomeInterface&gt;(somePromiseFn())
</code></pre>

<p>complains:</p>

<pre><code>Type 'SomeInterface' does not satisfy the constraint 'ObservableInput&lt;any&gt;'.
  Type 'SomeInterface' is not assignable to type 'ArrayLike&lt;any&gt;'.
</code></pre>

<p>So If I understand correctly it expects that from will have a sequence, array. But promises can return any objects?</p>
","911849","","","","","2020-01-16 00:20:23","RxJS 6: migrate fromPromise to from with TypescriptTypings","<typescript><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"55121378","1","","","2019-03-12 12:23:21","","2","643","<p>I get a payload from an action <code>payload: { items: Administration[], id: number}</code>
in an effect.</p>

<p>I use a service inside to post the new value and return it in an succes action.</p>

<p>I would like just pass the id with the result of the httpCall, but il loose the payload after the service.</p>

<p>I tried an <code>mergeMap(([action, items]) =&gt; new SuccessAction({items}))</code> after the  switchMap.</p>

<p>But don't realy understand where or how implement it, something like that,</p>

<pre class=""lang-js prettyprint-override""><code>@Effect() update$: Observable&lt;Action&gt; = this.actions$.pipe(
  ofType&lt;UpdateAction&gt;(ActionTypes.UPDATE),
  switchMap(action =&gt; this.service.update(action.payload.items).pipe(
  map(response =&gt; response.items }), 
    catchError(error =&gt; of(new FailureAction({error}))
  ))),
  mergeMap(([action, items]) =&gt; new UpdateAction({action.payload.id, items}))
);`
</code></pre>

<p>If someone could help me on this.</p>
","4231054","","4231054","","2019-03-12 12:55:46","2019-03-12 13:42:01","Angular 6 effect merge payload and data from service call in a new action","<angular><rxjs6><ngrx-effects>","1","0","2","","","CC BY-SA 4.0"
"55122770","1","","","2019-03-12 13:34:26","","0","212","<p>I have implemented a method to handle errors when anything goes wrong in my service call to the api.
In the code I pass the reference to my error handler to the Rxjs catchError operator as below: </p>

<pre><code>GetUserByUserID(id: number): Observable&lt;UserDetails&gt; {
  const url = `${this.baseUrl}/${this.userByID}/${id}`;

  return this.http.get&lt;UserDetails&gt;(url, this.httpOptions)
    .pipe(
      catchError(this.handleError)
    );
  }
</code></pre>

<p>ErrorHandler: </p>

<pre><code>import { Observable, throwError as observableThrowError } from 'rxjs';

private handleError(error: HttpErrorResponse) {
  console.log(error);
  if (error.status === 400) {
    return observableThrowError(new BadRequestError(error.error));
  }

  if (error.status === 404) {
    return observableThrowError(new NotFoundError());
  }

  if (error.status === 401) {
    return observableThrowError(new UnAuthorizedError(error));
  }

  if (error.status === 403) {
    return observableThrowError(new ForbiddenError(error));
  }

  return observableThrowError(new AppError(error));
}
</code></pre>

<p>In this error handler method I return an Observable that includes an error that is specific to my application domain (Error Domain), I have created different error classes so I just check that the error is an instance of one of my error domain classes when I subscribe to the Observable. </p>

<pre><code>this.router.data
  .subscribe(response =&gt; {
    this.UserDetail = response.userDetail;
    console.log(this.UserDetail);
  }, (error: AppError) =&gt; {
    if (error instanceof BadRequestError) {
      this.notifierService.notify('error', 'lease Register to login');
    } else {
      this.notifierService.notify('error', 'Something went worng... Please try again in few minutes');
    }
  }
});
</code></pre>

<p>Having all these in place to handle the error, i.e return an Observable of error specific to my application and finally check it's an instance of one of my error domain when subscribed to doesn't actually seems to be working, I keep getting this error in the console: </p>

<p><a href=""https://i.stack.imgur.com/BK6rS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BK6rS.png"" alt=""enter image description here""></a></p>
","4724576","","606104","","2019-03-12 16:25:46","2019-03-12 16:25:46","Why is Angular Error handle not throwing error from service","<angular><rxjs6>","0","2","","","","CC BY-SA 4.0"
"55135205","1","","","2019-03-13 05:49:06","","0","463","<p>I have a datasource in my angular app that is populated by and HTTP service/call. I am able to get the data from the remote server, build the table in real time with that data and edit it. I want now to be able to delete a row from the data table just locally, not pushing the change back to the server. But I can't see where I am able to access the array of data. I know it must be stored in an array somewhere, but where? A zillion different console logs have brought me no closer to figuring out where the data actually is so I can manipulate it. My observer works fine to give me the data to display. Here is the code to the datasource:</p>

<pre><code>import { Aircraft } from '../shared/aircraft';
import { AircraftInfoService } from './aircraft-info.service';
import { BehaviorSubject } from 'rxjs';
import { CollectionViewer, DataSource } from '@angular/cdk/collections';
import { Observable } from 'rxjs';
import { of } from 'rxjs';
import { catchError, finalize } from 'rxjs/operators';

export class AircraftInfoDataSource implements DataSource&lt;Aircraft&gt; {

  private className: string;

  private aircraftDBSubject = new BehaviorSubject&lt;any[]&gt;([]);
  private loadingSubject = new BehaviorSubject&lt;boolean&gt;(false);

  public loading$ = this.loadingSubject.asObservable();

  constructor(private aircraftInfoService: AircraftInfoService) {
    this.className = this.constructor.toString().match(/\w+/g)[1];

  }

  connect(collectionViewer: CollectionViewer): Observable&lt;Aircraft[]&gt; {
      return this.aircraftDBSubject.asObservable();
  }

  disconnect(collectionViewer: CollectionViewer): void {
      this.aircraftDBSubject.complete();
      this.loadingSubject.complete();
  }

  getAllAircraftData() {

      this.loadingSubject.next(true);

      this.aircraftInfoService.getAllAircraftRecords().pipe(
        catchError(() =&gt; of([])),
        finalize(() =&gt; this.loadingSubject.next(false))
      )
      .subscribe((data:any[]) =&gt; this.aircraftDBSubject.next(data));
  }

  deleteAircraft( deviceID: string ) {
    console.log(this.className, ' going to delte aircraft: ', deviceID);
    console.log('aircraftDBSubject: ', this.aircraftDBSubject);
    const foundIndex = this.aircraftDBSubject.value.findIndex(x =&gt; x.id === this.deviceID);
    console.log('foundIndex=',foundIndex);

  }
}
</code></pre>

<p>The deleteAircraft function is where I'm having my issue. Here also is the data service that retrieves the data:</p>

<pre><code>import { Aircraft } from '../shared/aircraft';
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';


@Injectable({
  providedIn: 'root'
})
export class AircraftInfoService {
  aircraft: Aircraft[];
  getApi = 'https://&lt;removed&gt;';

  constructor(private httpClient: HttpClient) {

  }

  ngOnInit() {
    console.log('aircraftInfoservice');
  }

  getAllAircraftRecords() {
    return this.httpClient.get(this.getApi)
  }
}
</code></pre>

<p>So everything is working read-only, how can I fix it so I can write (i.e. delete records) as well?</p>

<p>Thanks....</p>
","3508881","","","","","2019-03-13 07:43:57","how to delete item from angular datasource","<angular><rxjs6>","1","2","","","","CC BY-SA 4.0"
"55139290","1","55139393","","2019-03-13 10:13:07","","1","643","<p>I want test throwError part. OK test is OK. I want test if use <code>getById</code> with a wrong id <code>0</code>, <code>getById</code> return an error (<code>throwError</code>) </p>

<p><strong>My service:</strong></p>

<pre><code>getById(fooId): Observable&lt;Foo&gt; {
  return this.getAll().pipe(mergeMap(foos =&gt; {
    const foo: Foo= foos.find(({id}) =&gt; id === fooId);
    if (foo) {
      return of(foo);
    } else {
      throwError('foo not found');
    }
  }
));
</code></pre>

<p>}</p>

<p><strong>My unit tests:</strong></p>

<pre><code>it('...', () =&gt; {

    service.getById(0).subscribe(() =&gt; {
      fail('expected error');
    }, (error) =&gt; {
      expect(error).toBe('foo not found');
    });

    const res= httpMock.expectOne({ url: '/api/admin/foo', method: 'GET' });
    res.flush(
      [
        {
          'id': 1,
          'name': 'foo1'
        },
        {
          'id': 2,
          'name': 'foo2'
        }
      ]);
  });
</code></pre>

<p>I have this error:</p>

<pre><code>TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
</code></pre>
","3535537","","","","","2019-03-13 10:17:15","Angular 7 (RxJs6) - Unit tests - How to check if service return throwError?","<angular><karma-jasmine><rxjs6>","1","2","","","","CC BY-SA 4.0"
"55146798","1","","","2019-03-13 16:28:29","","0","759","<p>I need to preload the images in to the browser cache before displaying them. 
First, I make an http get request to get the json with an array of objects, containing the image details, as well as the image source url. Then I pass the array to the preloadImages method of my images service where i create an observable out of every image, pass the observable to the preloadImage method via mergeMap where I create the new Image() and load it. After that I try to catch the error and return an observable of undefined to keep the stream alive but I fail.
I've tried using switchMap to create a new stream and pipe it with mergeMap and catchError but it still fails
What should I do?</p>

<pre><code>image.service.ts
  preloadImages(images: any[]) {
return from(images).pipe(
  switchMap(x =&gt; {
    const newStream = of(x);
    return newStream.pipe(
      mergeMap(this.preloadImage),
      catchError(e =&gt; of(undefined))
    );
  }),

  toArray(),
  );
}

  preloadImage(img): Observable&lt;HTMLImageElement&gt; {
return Observable.create((observer: Observer&lt;HTMLImageElement&gt;) =&gt; {
  const image = new Image();
  image.src = img.url;
  image.onload = () =&gt; {
    console.log('id: ' + img.id + ' image was loaded');
    observer.next(img);
    observer.complete();
   };
  image.onerror = function (error) {
    observer.error(error);
  };
 });
}
</code></pre>

<p>How can I continue the stream if the image url returns a 404?
In my subscribe it would be ideal to receive an array of loaded images, and to remove the ones that aren't loaded.
Thank you in advance</p>
","9103122","","","","","2019-03-13 16:35:53","Catching an error and returning of(undefined) stops the stream (Angular 7, rxjs6)","<angular><error-handling><rxjs><preload><rxjs6>","1","1","","","","CC BY-SA 4.0"
"55151572","1","55151880","","2019-03-13 21:35:40","","1","115","<p>How would I go about using rxjs in Angular 6 for inserting an item, then after insert I need to upload different types of files to different endpoints with the new item id as a child key without having to nest all these calls. </p>

<pre><code>createItemWithAttachments(data:any)
{    
   this.itemService.insert(data.item).subscribe((newItem:Item)=&gt;{       
        //attachment type 1s 
        if(data.attachmentType1.length &gt; 0){    
         this.attachmentService.upload(data.attachmentType1, 
            ""type1"", newItem.id).subscribe(newAttachment=&gt;{

         });    
    }    

    //attachment type 2s 
    if(data.attachmentType2.length &gt; 0){    
         this.attachmentService.upload(data.attachmentType2, 
             ""type2"", newItem.id).subscribe(newAttachment=&gt;{    

         });    
    }    
    });    
}
</code></pre>
","1188898","","5437671","","2019-03-13 21:43:37","2019-03-18 20:35:33","rxjs operators with multiple inserts","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"55164144","1","","","2019-03-14 13:45:35","","2","394","<p>We have a request service which executes http requests.
All requests implement the IRequest interface, which contains the http-method and an execute function, which in its turn returns another observable.</p>

<p>The RequestService has an overload which accepts a source observable and a requestfactory that returns an IRequest instance based on the source observable's value.</p>

<pre><code>export interface IRequest&lt;TResponse&gt; {
    __method: string;
    execute(): Observable&lt;TResponse&gt;;
}

class RequestService&lt;TSource, TResponse&gt; {
    public execute(source: Observable&lt;TSource&gt;, requestFactory: (input: TSource) =&gt; IRequest&lt;TResponse&gt;): Observable&lt;TResponse&gt; {
        return source.pipe(
            map(x =&gt; requestFactory(x)),
            switchMap(x =&gt; x.execute()),
        );
    }
}
</code></pre>

<p>Ofcourse, a lot more is done in the service (logging, default error handling, ...) but most is irrelevant for the question.</p>

<p>Now, this all works like a charm, but what we would like to do, is to use <code>switchMap</code> for GET-requests and 'mergeMap' for POST, PUT, DELETE requests by default.</p>

<p>We cannot seem to get this working. We need access to the IRequest instance after it has been created by the factory, which is only possible if we have the source observable's value. However, when in an operator, we can't control the choice between switchMap or mergeMap anymore.</p>

<p>Our next choice was to create our own <code>RequestMapOperator</code> which would create an instance of <code>MergeMapOperator</code> or <code>SwitchMapOperator</code> and use the appropriate next, complete and error methods. However, the <code>SwitchMapOperator</code> is not exported by the rxjs library.</p>

<p>So before creating our own Subscriber class which would be just a combination of the <code>MergeMapSubscriber</code> and the <code>SwitchMapSubscriber</code>, we would like to know if we're missing something.</p>

<hr>

<p><strong>TL;DR</strong></p>

<p>We would like an operator which, depending on the source observable's value, flattens to a new observable with mergeMap or switchMap.</p>
","1302710","","","","","2019-03-14 15:35:17","Rxjs: depending on observable value, pipe with mergeMap or switchMap","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"55167317","1","","","2019-03-14 16:14:11","","-2","132","<p>calling one subscribe which is depending one another subscribe method </p>

<p>structure:</p>

<pre><code>    this.example1().subscribe(res =&gt; {
      this.response = res;
    })


  example1(): Observable&lt;any&gt; | any {
    this.example2().pipe(
      catchError(err =&gt; {
        return throwError(err);
      })
    ).subscribe(res =&gt; {
       return of(res);
    });
  }

  example2(): Observable&lt;any&gt; | any {
     this.example3().pipe(
      catchError(err =&gt; {
        return throwError(err);
      })
    ).subscribe(res =&gt; {
      return of(res);
    });

  }

  example3() {
    return of('return from example 3');
  }
</code></pre>

<p>now getting error ""Cannot read property 'pipe' of undefined""</p>

<p>example3() returns value correctly but from example2 value does not get return to example 1 </p>

<p>link: <a href=""https://stackblitz.com/edit/angular-eyz2j7"" rel=""nofollow noreferrer"">stackblitz demo</a></p>
","7430558","","7430558","","2019-03-15 06:56:28","2019-03-15 17:03:42","Calling nested subscribe sequentially","<angular><rxjs><rxjs6>","2","4","","","","CC BY-SA 4.0"
"55174066","1","","","2019-03-15 00:49:03","","0","1008","<p>I have an observable of an array which contains objects of an object. (as shown in the image). I have an <code>observable</code> which receives these values from a <code>get</code> request and then I have another <code>observable</code> for storing filtered values. I have a searchText variable <code>binded</code> to an <code>input</code> and I am calling a function every time the input changes.</p>

<pre><code> &lt;input name=""problem-search"" [(ngModel)]=""searchText"" matInput placeholder=""Search for problems..."" (input)=""filterProblems()""&gt;
</code></pre>

<p>Till now, I have tried this, but it's not producing the desired output. Its is filtering sometimes but that's random and its not even relevant to the <code>searchInput</code>. To be frank, I don't even know how I am getting that output. Rxjs could be confusing sometimes. Kindly let me know what I am doing wrong in here.<a href=""https://i.stack.imgur.com/BxbxN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BxbxN.png"" alt=""enter image description here""></a></p>

<pre><code>    filterProblems() {
    if (this.searchText === '') {
      this._filteredProblems$ = this._everyProblem$;
    }

    this._filteredProblems$ = this._everyProblem$.pipe(
      map(data =&gt; data),
      tap(ele =&gt; ele.filter(data =&gt; {
        Object.keys(data).forEach(key =&gt; {
          if (data[key].name.toLowerCase().includes(this.searchText)) {
            delete data[key];
          }
        });
      }))
    );

    this._filteredProblems$.subscribe(data =&gt; console.log(data))
  }
</code></pre>
","6192673","","","","","2019-03-15 03:06:25","Filter an array of nested object - Observable","<angular><rxjs><observable><rxjs6>","1","2","","","","CC BY-SA 4.0"
"55179570","1","55197807","","2019-03-15 09:39:04","","0","698","<p>I have followed the documentation <a href=""https://github.com/angular/angularfire2/blob/master/docs/firestore/collections.md"" rel=""nofollow noreferrer"">here</a> to get data with document id from firestore.</p>

<pre><code>  import { Injectable } from '@angular/core';
  import { AngularFirestore, AngularFirestoreCollection } from '@angular/fire/firestore';
  import { Observable } from 'rxjs';
  import { map } from 'rxjs/operators';
  import 'rxjs/add/operator/map';

  @Injectable()
  export class UserService {
  userCol : AngularFirestoreCollection&lt;UserInter&gt;;
  users : Observable&lt;UserInter[]&gt;;
  constructor(private afs:AngularFirestore) { } 

  GetUsers(){
    this.userCol = this.afs.collection&lt;UserInter&gt;('users');
    this.users = this.userCol.snapshotChanges().pipe(
                map(changes =&gt;{
 error here-&gt;   return changes.map(a =&gt; {
                const data = a.payload.doc.data() as UserInter;
                data.id = a.payload.doc.id;
                return data;
          })
        }))
return this.users;  
}

export interface UserInter {
email ?: string,
Firstname ?: string,
Lastname ?: string,
Address ?: string,
}

export interface UserInterid extends UserInter {id ?: string }
</code></pre>

<p>When I ng-serve my application I get this error </p>

<blockquote>
  <p>Property 'map' does not exist on type '{}'</p>
</blockquote>
","8304072","","8304072","","2019-03-15 11:38:35","2019-03-16 14:22:23","""Property 'map' does not exist on type '{}'"" while trying to get collection from firebase firestore","<angular><firebase><google-cloud-firestore><angularfire2><rxjs6>","3","2","","","","CC BY-SA 4.0"
"55204188","1","","","2019-03-17 05:41:12","","2","1450","<p>I have this problem when trying to run in git bash.
.switchMap is not geting executed  and showing error as"" error TS2339: Property 'switchMap' does not exist on type 'Observable' ""</p>

<p>The code I am using is:</p>

<pre><code>import { User } from './../classes/user';
import { Injectable } from '@angular/core';
import { Router } from '@angular/router';
import { Observable, of } from 'rxjs';
import { AngularFireAuth } from '@angular/fire/auth';
import { AngularFirestore, AngularFirestoreDocument } from '@angular/fire/firestore';
import { from } from 'rxjs';
@Injectable()
export class AuthService {

  public currentUser: Observable&lt;User | null&gt;;

  constructor(
    private router: Router,
    private alertService: AlertService,
    private afAuth: AngularFireAuth,
    private db: AngularFirestore
  ) {

    this.currentUser = this.afAuth.authState
      .switchMap((user) =&gt; {
        if (user) {
          return this.db.doc&lt;User&gt;(`users/${user.uid}`).valueChanges();
        } else {
          return of(null);
        }
      });
  }
</code></pre>

<p>my rxjs version is rxjs@6.3.3  latest and nodejs version is v8.12.0
please help I am building a chat website.</p>
","11215190","","","","","2019-05-16 21:12:25","Question is : Property 'switchMap' does not exist on type 'Observable<User>","<angular><rxjs><observable><rxjs6><switchmap>","2","0","","","","CC BY-SA 4.0"
"55208306","1","55208493","","2019-03-17 14:45:38","","0","396","<p>How to subscribe on result of flatMap?    </p>

<pre><code>   timer(0, 2000)
      .pipe(
        flatMap(() =&gt; this.scannerService.scan(this.scanType)),
        takeWhile(res =&gt; res.errorDesc !== ""SUCCESS"")
      )
      .subscribe((res: IScanResponse) =&gt; {
});
</code></pre>

<p>I tried do use <code>.subscribe()</code> after <code>pipe</code>. But I get error as:</p>

<blockquote>
  <p>You provided an invalid object where a stream was expected. You can
  provide an Observable, Promise, Array, or Iterable.</p>
</blockquote>

<p>My remote function is:</p>

<pre><code>public scan(scanType: string): Observable&lt;any&gt; {}
</code></pre>

<p>My imports are:</p>

<pre><code>import { timer } from ""rxjs"";
import { takeWhile } from ""rxjs/operators"";
import { ScannerService } from ""src/app/api/ScannerService"";
import { flatMap } from ""rxjs/operators"";
</code></pre>
","8291684","","8291684","","2019-03-17 15:01:09","2019-03-18 04:18:23","How to subscribe on result of flatMap?","<angular><rxjs><rxjs6>","2","2","1","","","CC BY-SA 4.0"
"55210597","1","","","2019-03-17 18:39:53","","0","649","<p>In an Angular7 application, I captured the KeyUp event of a numeric input with this html code:</p>

<pre><code>&lt;input fxFlex
     type=""number"" 
     formControlName=""DM""
     (keyup)=""changeDM()""&gt;
&lt;/div&gt;
</code></pre>

<p>I use debounceTime(500) to delay call to a service that processes the form. I write a 1, 2, 3, 4 ... digit number and I see that the debounceTime(500) works correctly, but it makes a duplicate call to the service. Look the code:</p>

<pre><code>subject: Subject&lt;any&gt; = new Subject();

.....

this.subj.pipe(debounceTime(500)).subscribe(() =&gt; {
    console.log('==CALL TO SERVICE==');
    this.service.setForm( this.form.valid, this.form.value );
});

changeDM(): void { 
    console.log('changeDM==============');
    this.subject.next();
}
</code></pre>

<p>And the image of the browser console with four keyup:</p>

<p><a href=""https://i.stack.imgur.com/JmXQQ.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JmXQQ.jpg"" alt=""enter image description here""></a></p>

<p>Why is the service called two times?
Thank you.</p>

<p>image in which I show the input content after each press. Pulse 8 and wait more than 500 ms., Pulse 4567 ... You can see the result.</p>

<p><a href=""https://i.stack.imgur.com/3ywVL.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/3ywVL.jpg"" alt=""enter image description here""></a></p>
","6065343","","6065343","","2019-03-18 07:31:19","2019-04-26 16:06:41","Angular 7 rxjs/operator/debounceTime on Subject duplicate action","<angular><rxjs6>","2","4","","","","CC BY-SA 4.0"
"55210843","1","","","2019-03-17 19:07:34","","1","230","<p>Why does <code>retryWhen</code> completes with its inner Observable?</p>

<p>Imagine that we need to make maximum <strong>3</strong> attempts to fetch data. And, for example sake, our <strong>3rd attempt will definitely work</strong>. So I try the following:</p>

<pre class=""lang-js prettyprint-override""><code>// ...
retryWhen(errors$ =&gt;
  errors$.pipe(
    take(3)
  )
)
</code></pre>

<p>Which will make 3 attempts, but will immediately <strong>complete after 3rd error</strong>, together with its inner observable. Even if our 3rd attempt was about to give us results.</p>

<p>An illustration:</p>

<p><a href=""https://i.stack.imgur.com/aSgeR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aSgeR.png"" alt=""retryWhen completing with inner Observable""></a></p>

<p><a href=""https://observable-playground.github.io/gist/11d9457e53282dbe9eff1d48d58db24d"" rel=""nofollow noreferrer"">Run this example</a></p>

<p><strong>UPDATED NOTE:</strong> Probably, to properly limit retry attempts — we should <a href=""https://observable-playground.github.io/gist/2bcd4bb2ee9be92de22d65b39c5ec813"" rel=""nofollow noreferrer"">use <code>switchMap</code> to switch based on index to <code>of(error)</code> or to <code>throwError(error)</code></a>.</p>

<p>For me this behavior was unexpected: as I though inner observable will only trigger a retry. And once it notifies about a retry -- it's job is done, and we don't care if it completes.</p>

<p>So this question is rather theoretical then practical:</p>

<p>What was the reasoning behind this particular behavior? And what are its advantages?</p>

<p><strong>NOTE:</strong> Its not an issue, operator behaves as described</p>

<blockquote>
  <p>Returns an Observable that mirrors the source Observable with the
  exception of an error. If the source Observable calls error, this
  method will emit the Throwable that caused the error to the Observable
  returned from notifier. <strong>If that Observable calls complete or error
  then this method will call complete or error on the child
  subscription.</strong> Otherwise this method will resubscribe to the source
  Observable.</p>
</blockquote>
","6921829","","6921829","","2019-04-05 08:29:10","2019-04-05 08:29:10","why does RxJS retryWhen operator completes with its inner Observable?","<rxjs><rxjs6>","0","2","","","","CC BY-SA 4.0"
"55217468","1","55217626","","2019-03-18 08:45:35","","0","346","<p>My problem is that I want to read data from a server as it comes in an angular application without reloading the page.
I have a simple flask server that sends data in python:</p>

<pre><code>from threading import Timer
from flask import Flask
import time
import random
from datetime import datetime
from flask_cors import CORS, cross_origin

app = Flask(__name__)
cors = CORS(app)
app.config['CORS_HEADERS'] = 'Content-Type'

string = ''
humidity = 60
stress = 1
temperature = 20

def update_data(interval):
    Timer(interval, update_data, [interval]).start()

    global string
    global humidity
    global stress
    global temperature

    string = ''
    string += f'{{""ID"":""90A2DA10F2E4"",'
    string += f'""timestamp"":""{datetime.now().isoformat()}"",'
    string += f'""temperature"":{temperature},'
    string += f'""humidity"":{humidity},'
    string += f'""stress"":{stress}}}\n'


    humidity = round( (humidity + (random.random()*2-1)), 2)
    stress = round( (stress + (random.random()*0.2-0.1)), 2)
    temperature = round( (temperature + (random.random()*0.2-0.1)), 2)

# update data every second
update_data(1)

@app.route(""/"")
@cross_origin()
def index():
    return string

if __name__ == ""__main__"":
    app.run(debug=True)
</code></pre>

<p>And a component in angular that creates a subscription to that stream:</p>

<pre><code>@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  title = 'prototype';
  darkTheme =  new FormControl(false);
  list = [];

  constructor(private streamService: TestDataService,
              private http: HttpClient) { }

  ngOnInit() {
    this.privateServer();
  }

  privateServer() {
    console.log(""private server"");
    console.log(this.http.get('http://localhost:5000'));
    this.http.get('http://localhost:5000').subscribe( data =&gt; {
      console.log(data);
      this.list.push(data);
    })
  }

  onClick(){
    console.log(this.list);
  }
}
</code></pre>

<p>It will be part of a service, but for testing purposes I'm trying to get it to work inside the component.
The template consist of just a button that calls onClick().
Any help would be appreciated.</p>
","10790720","","400617","","2019-03-18 12:41:39","2019-03-18 12:41:39","Angular observable doesn't catch new values from flask server","<angular><angular7><rxjs6>","1","2","","","","CC BY-SA 4.0"
"55219620","1","55219807","","2019-03-18 10:50:15","","1","2065","<p>trying to get data from a server, interval to a service every 10 sec.
and if the price is returned, then stop the interval. code below:</p>

<p>but im getting error:</p>

<blockquote>
  <p>ERROR TypeError: You provided 'undefined' where a stream was
  expected. You can provide an Observable, Promise, Array, or Iterable.</p>
</blockquote>

<p>code:</p>

<pre><code>public Respond() {

this.dataService.WaitingForServiceRespond()
  .pipe((
    debounceTime(2000),
    switchMap((r: any) =&gt; {
      if (!r.price) {
        setInterval(() =&gt; {
          return this.Respond();
        }, 10000)
      } else {

        this.dataService.user.payment = r;
        console.log('price returned', r);
        return ''
      }
    })
  ))
  .subscribe(e =&gt; {
    console.log(e)
  })
</code></pre>

<p>}</p>
","10926752","","","","","2019-03-18 11:23:36","rxjs , switchMap ,interval, provided 'undefined' where a stream was expected","<angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"55221339","1","55221381","","2019-03-18 12:24:02","","0","211","<p>I have one observable, <code>numberRange$</code>, that emits an array of numbers, say <code>[65, 66, 67, 68]</code>.</p>

<p>Is there any number to subscribe to <code>numberRange$</code> and getting each number in the array as a separate emission in the new pipe?</p>

<p>Each number will be used as an input to an async http-call, and with <code>mergeMap</code> it is trivial to batch the http-calls as the api only allows 2 parallell computations at once.</p>

<p>For now, I am subscribing to <code>numberRange$</code> and saving the output in a variable <code>numberRange$</code> and using <code>rxjs/operators.from(numberRange).pipe(mergeMap(someFunc, batchCount))</code> to perform the operation, but I would rather directly pipe <code>numberRange$</code> and split the array into separate emissions before hitting <code>mergeMap</code>. </p>

<p>Thanks for good answers!</p>
","8779395","","","","","2019-03-18 12:53:14","Splitting one emission into several","<rxjs><rxjs6>","2","1","","","","CC BY-SA 4.0"
"55229077","1","55229927","","2019-03-18 19:52:47","","2","85","<p>I need to make a series of http calls, where each call depends on the previous responses (bodies or headers). How can I achieve this with Observables?</p>

<p>So far I've made the ugly nested subscriptions:</p>

<pre><code>this.http.get(url1)
.subscribe(response1 =&gt; {
    const params1 = something(response1);
    this.http.post(url2, params1)
    .subscribe(response2 =&gt; {
        const params2 = something(response1,response2);
        this.http.post(url3, params2)
       .subscribe(response3 =&gt; {
           const params3 = something(response1,response2,response3);
           this.http.post(url4, params3)
           .subscribe(response4 =&gt; {
               const params4 = something(response1,response2,response3,response4);
               this.http.post(url5, params4)
               .subscribe(response5 =&gt; console.log(response5));
           });
       });
    });
});
</code></pre>
","3834178","","","","","2019-03-18 22:32:48","RxJS Resolve a sequence of observables where each depends on the previous ones","<rxjs6>","1","0","1","","","CC BY-SA 4.0"
"55380193","1","55380827","","2019-03-27 14:51:44","","5","4119","<p>I am getting a weird error while trying to navigate to different routes from a specific component. If I navigate to different routes from other components I am not seeing this error.
I am attaching the screenshot of the error
<a href=""https://i.stack.imgur.com/hqA6v.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/hqA6v.png"" alt=""enter image description here""></a></p>

<p>I have searched for this issue and seems to be the problem with RxJS or empty routes. But I added <strong>pathMatch:'full'</strong> to empty routes and my RxJS version is <strong>6.3.3</strong>. Any idea or anyone out here resolved the same issue could be of great help.</p>
","2617509","","","","","2021-04-07 19:38:27","ERROR EmptyErrorImpl {message: ""no elements in sequence"", name: ""EmptyError""} in Angular 7","<angular><rxjs><angular-routing><angular7><rxjs6>","2","4","","","","CC BY-SA 4.0"
"55383170","1","55383485","","2019-03-27 17:23:30","","-1","2399","<p>In Angular 6+ httpClient, a request can be configured to get the entire response.</p>

<p>The response observable can be piped into <code>map</code> and <code>catchError</code> operators.</p>

<p>When does the execution go through the <code>map</code> operator and when to <code>catchError</code>?</p>

<p>Does it depend on responce status code? </p>

<p>For example, if <code>response.status === 200</code> then go to <code>map</code>, else go to <code>catchError</code>?</p>

<p>If not only status 200 goes to <code>map</code>, then which else?</p>

<p>And which statuses go to <code>catchError</code>?</p>

<pre class=""lang-js prettyprint-override""><code>getData(): Observable&lt;[]&gt; {
    return this.http.get(this.apiUrl, {observe: 'response'}).pipe(
        map((response: HttpResponse&lt;any&gt;) =&gt; {  
            return response.status === 200;
        }),
        catchError((errorResponse: HttpErrorResponse) =&gt;
            // which value may be logged here?
            console.log(errorResponse.status);
            of(false);
        ));
}

</code></pre>
","623190","","","","","2019-03-27 20:37:20","Which response status code goes to catchError in Angular 6+ httpClient?","<angular><angular-httpclient><rxjs6>","1","2","","","","CC BY-SA 4.0"
"55408421","1","","","2019-03-28 23:36:10","","3","388","<p>Apologies for the long text - just setting the scene.</p>

<p>I am using a AWS Amplify (Cognito) for authentication in my Angular app. AWS Amplify provide an AmplifyService that has an authStateChange$ observable that provides updates on the Authentication state. </p>

<p>After the user logs in it stores the Session in local/cookie storage and therefore when the page is reopened/refreshed etc. the session is returned from storage. e.g. authStateChange$ returns a state of ""signedIn"".</p>

<p>I also have a user session (AppSession) that includes some other domain information for the current users session.</p>

<pre><code>//AppSession.ts
export interface Session {
    package?: PurchasedPackage;
    authState: string;
}
</code></pre>

<p>Because the session is used by multiple components, I am exposing it as a BehaviorSubject from my UserStore.</p>

<pre><code>//UserStore.ts
@Injectable()
export class UserStore {
    private _session$: BehaviorSubject&lt;AppSession&gt;;

    get session(): Observable&lt;Session&gt; {
         return this._session$.asObservable();
    }
    ....
}
</code></pre>

<p>What I want to happen is that I want to set the authState property in the AppSession from the authStateChange observable. Something like</p>

<pre><code>    //UserStore.ts

    constructor(private amplifyService: AmplifyService){
         /**
          * If the user logs in, then update their details.
         */
         this.amplifyService.authStateChanges$.subscribe(
              (event) =&gt; {
                   this._session = new BehaviorSubject({
                       authState: event.state
                   })
              }
         )
    }
</code></pre>

<p>In my app I have a homepage that should only be seen by users who are ""signedIn"". Therefore, I have an ""UnauthenticatedGuard"" that protects it as follows:</p>

<pre><code>canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean&gt; {
return this.userStore.session.pipe(
  map((session) =&gt; {
    if(session &amp;&amp; session.authState == ""signedIn"") {
      this.router.navigate(['/dashboard']);
      return false;
    }
    return true;
  })
)
</code></pre>

<p>}</p>

<p>Now the trouble is that, when I start my app, the UnauthenticatedGuard is executed before the this.amplifyService.authStateChanges$ observable has emitted the signedIn state, therefore, I get:</p>

<pre><code>Cannot read property 'asObservable' of undefined
</code></pre>

<p>If, I set the BehaviorSubject to have an initial value of 'null' for example (or anything really), then the Guard will think that the user is not signed in and therefore allow access.</p>

<p>How can I only expose the BehaviorSubject once it's initial value has been set (i.e. once the authStateChanges$ observable has emitted it's value)?</p>
","2294382","","","","","2019-03-28 23:36:10","Angular RxJs Guard wait for service's BehaviorSubject to have value","<angular><rxjs><rxjs6>","0","0","1","","","CC BY-SA 4.0"
"55415481","1","","","2019-03-29 10:33:24","","2","355","<p>I am trying to unit test some code that uses the <code>webSocket</code> function from rxjs6.  I have tried to spy on the webSocket function by doing the following (as recommended <a href=""https://stackoverflow.com/questions/35240469/how-to-mock-the-imports-of-an-es6-module"">here</a>): -</p>

<p><code>import * as rxJsWebSocket from 'rxjs/webSocket';</code></p>

<pre><code>subject = new Subject();
webSocketSpy = spyOn(rxJsWebSocket, 'webSocket').and.returnValue(&lt;any&gt;subject);
</code></pre>

<p>but I got the error: -</p>

<p><code>Error: &lt;spyOn&gt; : webSocket is not declared writable or has no setter</code></p>

<p>Is there any other way to achieve this or is there a workaround for the error?  </p>

<p>I've also tried <a href=""https://www.npmjs.com/package/ts-mock-imports"" rel=""nofollow noreferrer"">ts-mock-imports</a> with no success.</p>
","318381","","","","","2020-09-10 07:24:28","How can the rxjs 6 webSocket function be mocked for unit tests?","<unit-testing><websocket><jasmine><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55416011","1","55416869","","2019-03-29 11:01:57","","10","9624","<p>I am working on a file encryption and upload class using Angular. Many of these operations are async and therefore the methods I wrote are returning RxJS Observables.</p>

<pre class=""lang-js prettyprint-override""><code>// 1.
private prepareUpload(file): Observable&lt;T&gt;;

// 2.
private encryptData(data, filekey): Observable&lt;T&gt;

// 3.
private uploadEncryptedData(formData, token, range): Observable&lt;T&gt;

// 4.
private completeUpload(updatedFilekey, token): Observable&lt;T&gt;
</code></pre>

<p>I want to encapsulate this logic in a public <code>upload(file)</code> method and I ended up using nested subscriptions and it works but I know that it is wrong and an anti-pattern in RxJS for several reasons. Here is a simplified version of the code:</p>

<pre class=""lang-js prettyprint-override""><code>public upload(file) {
    const gen = this.indexGenerator(); // generator function

    this.prepareUpload(file).subscribe(values =&gt; {
    const [response, filekey, data] = values;

    this.encryptData(data, filekey).subscribe(encryptedDataContainer =&gt; {
      const formData = this.prepareEncDataUpload(encryptedDataContainer.data, file.name)
      const range = this.getRange(file.size, gen.next().value);

      this.uploadEncryptedData(formData, response.token, range).subscribe(() =&gt; {
        if (range.isFinalPart) {
            this.completeUpload(encryptedDataContainer.updatedFilekey, response.token).subscribe(console.log);
        }
      });

    });

  });

}
</code></pre>

<p>I failed to clean this code using combinations of several RxJS operators. My goal is to avoid nested subscriptions and instead return a single Observable from the public <code>upload()</code> method when the workflow is completed.</p>

<p>Thanks!</p>
","11276880","","","","","2019-03-29 11:55:33","How can I avoid multiple nested subscriptions using RxJS operators?","<angular><rxjs6>","4","3","2","","","CC BY-SA 4.0"
"55432959","1","55433033","","2019-03-30 15:29:57","","0","284","<p>I have an epic where I am listening to an action stream, when an action of <code>'AUTH_STATUS_CHECKED'</code> occurs switch over to a new observable <code>authState(app.auth())</code>. This new observable tells me if I am authenticated or not. </p>

<p>If the auth observable returns a user then dispatch <code>'SIGNED_IN'</code> action with the user as the payload.</p>

<p>If a user does not exist then fore off a promise <code>app.auth().signInWithPopup(googleAuthProvider)</code> and when you get the response dispatch <code>'SIGNED_IN'</code>.</p>

<p>If there are any errors, catch them and let me know in the console.</p>

<p>based on the logic above I have implemented the pipeline below</p>

<pre><code>export const fetchAuthStatus = action$ =&gt;
      action$.pipe(
        ofType('AUTH_STATUS_CHECKED'),
        switchMap(() =&gt;
          authState(app.auth()).pipe(
            map(user =&gt;
              user
                ? { type: 'SIGNED_IN', payload: user }
                : app
                    .auth()
                    .signInWithPopup(googleAuthProvider)
                    .then(user =&gt; ({ type: 'SIGNED_IN', payload: user }))
            ),
            catchError(error =&gt; console.log('problems signing in'))
          )
        )
      );
</code></pre>

<p>It's not working as expected. If there is no user the promise gets fired but it does not wait for the response and the dispatch never gets fired.</p>

<p>I'm clearly new to rxjs and I'm having trouble figuring this out. I've gone through the docs and tried using a tap() and mergeMap() but am getting the same error.</p>

<p>Any guidance would be appreciated.</p>
","4387980","","","","","2019-03-30 15:44:47","modelling and if/else pattern inside an rxjs observable pipeline","<javascript><if-statement><rxjs><rxjs6><redux-observable>","2","0","","","","CC BY-SA 4.0"
"55433371","1","55434885","","2019-03-30 16:15:14","","0","431","<p>In the following epic I am listening to an action$ stream and then also listening to an auth stream <code>authState(app.auth())</code></p>

<pre><code>export const fetchAuthStatus = action$ =&gt;
      action$.pipe(
        ofType(AUTH_STATUS_CHECKED),
        switchMap(() =&gt; authState(app.auth())),
        switchMap(user =&gt;
          user
            ? of({ type: 'SIGNED_IN', payload: user })
            : signIn(googleAuthProvider)
        ),
        catchError(error =&gt; console.log('problems signing in'))
      );
</code></pre>

<p>It works as expected, the only problem is that if I change the auth status by logging out then the epic fires the <code>signIn()</code> method since <code>user</code>is no longer available.</p>

<p>How do I stop listening to <code>authState(app.auth())</code> once I have signed in. Where does the unsubscribe logic go in an epic?</p>
","4387980","","","","","2019-03-30 19:16:51","How do I unsubscribe from inner observables in redux observable?","<javascript><rxjs><rxjs6><redux-observable><unsubscribe>","1","6","","","","CC BY-SA 4.0"
"55434482","1","55434633","","2019-03-30 18:28:44","","0","56","<p>Hello guys this is my first time on a while posting here, everyone thanks for your help, but I don't know to do here.</p>

<p>I have a Angular+2 web app (I'm new with Angular) with one component (User) and a service (user.service.ts), I have already done my HTTP request for getUser(Id) and is returning the json correctly, on my component I need to set some variables with my service, but my variables are returning null or empty, which could be the most correct choice to do this?</p>

<p>I think my error could be on the .subscribe method and Observable thing.</p>

<pre><code>//User service
getUser(id:string): Observable&lt;User&gt;{
        return this.http.get&lt;User&gt;(this.userUrl + ""/""+ id);   
    } 
</code></pre>

<pre><code>//Component

ngOnInit() {
    this.route.params
    .subscribe((params:Params)=&gt;{
      this.id = params['id'];
      this.editMode = params['id'] != null;
      this.initForm();
    });
  }
</code></pre>

<pre><code>initForm(){
    let id = '';
    let company ='';
    let userNo = 0;
    let email = '';
    let firstName = '';
    let lastName = '';
    let address1 = '';
    let address2 = '';
    let city = '';
    let country = '';
    let postalCode = '';
    let mobilePhoneNumber = '';
    let homePhoneNumber = '';
    let birthday = '';
    let userType = '';
    let gender = '';

    if(this.editMode){


      this.userService.getUser(this.id).filter(x =&gt; x.id === this.id).subscribe((data:User) =&gt; { return new User(

          id = data.id,
          userNo = data.userNo,
          firstName = data.firstName,
          lastName = data.lastName,
          address1 = data.address1,
          address2 = data.address2,
          city = data.city,
          country = data.country,
          postalCode = data.postalCode,
          homePhoneNumber = data.homePhoneNumber,
          mobilePhoneNumber = data.mobilePhoneNumber,
          email = data.email,
          gender = data.gender,
          userType = data.userType

      )});


    }

    this.userForm = new FormGroup({
      'company': new FormControl(company, Validators.required), &lt;---- company null/empty
      'userNo': new FormControl(userNo, Validators.required), &lt;---- userNo null/empty
      'email': new FormControl(email, Validators.required), &lt;---- email null/empty
      'firstName': new FormControl(firstName, Validators.required), &lt;---- firstName null/empty
      'lastName': new FormControl(lastName, Validators.required), &lt;---- lastName null/empty
      'address1': new FormControl(address1, Validators.required), &lt;---- address1 null/empty
      'address2': new FormControl(address2, Validators.required), &lt;---- address2 null/empty
      'city': new FormControl(city, Validators.required), &lt;---- city null/empty
      'country': new FormControl(country, Validators.required), &lt;---- country null/empty
      'postalCode': new FormControl(postalCode, Validators.required), &lt;---- postalCode null/empty
      'mobilePhoneNumber': new FormControl(mobilePhoneNumber, Validators.required), &lt;---- mobilePhoneNumber null/empty
      'homePhoneNumber': new FormControl(homePhoneNumber, Validators.required), &lt;---- homePhoneNumber null/empty
      //'birthday': new FormControl(birthday, Validators.required), &lt;---- birthday null/empty
      'userType': new FormControl(userType, Validators.required) &lt;---- userType null/empty

    })



  }
</code></pre>
","2574627","","1071020","","2019-03-30 18:30:40","2019-03-30 18:45:13","Pass HTTP GET by Id (Observable) values to variables on component","<typescript><angular6><observable><angular-services><rxjs6>","1","1","0","","","CC BY-SA 4.0"
"55435533","1","55436109","","2019-03-30 20:50:05","","1","359","<p>I'm having trouble understanding why unsubscribing from a rxjs subscription with an added step does not cancel a in-flight http request.</p>

<p>Take a look at: <a href=""https://stackblitz.com/edit/angular5-http-example-nx8fza"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular5-http-example-nx8fza</a></p>

<p>You'll notice in the network tab for chrome, one of the clicks cancels requests and the other does not.</p>

<pre><code> getJoke(): void {
    this.jokeSub = this.api.getData()
      .subscribe(data =&gt; this.joke = data);

    this.jokeSub.unsubscribe();
  }

  // This method does not cancel requests in flight because of the .add step.
  getJoke2(): void {
    this.jokeSub2 = this.api.getData()
      .subscribe(data =&gt; this.joke = data).add(console.log(""Added step""));

    this.jokeSub2.unsubscribe();
  }
</code></pre>

<p><a href=""https://i.stack.imgur.com/VJkUC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VJkUC.png"" alt=""cancel request""></a></p>

<p>Side Note: I came across this when I setting up an http interceptor in Angular 7 with rxjs 6. I couldn't cancel requests when my interceptor had any logic in the pipe. I think if can figure out why its not working here, I can answer my more specific question.</p>
","5078682","","5078682","","2019-03-30 22:02:06","2019-03-30 22:49:38","Angular 7 Rxjs - In-Flight HTTP request not cancelling for subscription","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"55446920","1","55447560","","2019-04-01 01:07:49","","1","1363","<pre><code>buttonClicked$.pipe(
switchMap(value=&gt;makeRequest1),
switchMap(responseOfRequest1=&gt;makeRequest2))
.subscribe()
</code></pre>

<p>I need to make 2 http request sequentially, and abort downstream pending request  if the button clicks. Is the above code the right approach? I understand that a new click will cancel pending <code>request1</code>. if the click happens during <code>request2</code>, does <code>request2</code> get canceled as well?</p>
","2831663","","2831663","","2019-04-01 02:44:26","2019-04-01 12:55:40","how to cancel nested request with rxjs","<angular><rxjs><rxjs6>","3","0","","","","CC BY-SA 4.0"
"55452037","1","55514173","","2019-04-01 09:36:50","","1","2353","<p>I'm having hard time finding neet solution for cashing http request to BehaviorSubject. I wanted to have only single method for cashing and getting value. Example below:</p>

<pre><code>@Injectable({
  providedIn: 'root'
})
export class DataStoreService {

  private readonly initialState: DataState = {
    data: string,
    loaded: false
  };

  private data$: BehaviorSubject&lt;DataState&gt; = new BehaviorSubject&lt;DataState&gt;(this.initialState);

  constructor(private dataService: DataService) { }

  getData$(id: string): Observable&lt;string&gt; {
    return this.data$.asObservable()
      .pipe(
        switchMap((state: DataState) =&gt; {
          if (!state.loaded) {
            this.dataService.getData$(id);
          } else {
            return of(state.data);
          }
        }),
        withLatestFrom(this.data$.asObservable()),
        map(([data, state]) =&gt; {
          if (!state.loaded) {
            this.data$.next({
              loaded: true,
              data
            });
          }
          return data;
        })
      );
  }
}
</code></pre>

<p>I haven't tested it yet (service not working), but looks ok for now. Anybody knows any better solution to have less piping and conditionals (if/else) in rxjs for this kind of usage?</p>
","3202102","","3202102","","2019-04-01 09:55:50","2019-04-08 12:18:44","RxJS BehaviorSubject cashing request from http call","<angular><rxjs><rxjs6>","3","2","","","","CC BY-SA 4.0"
"55463266","1","55463401","","2019-04-01 20:41:46","","0","83","<p>I have a few Angular components, and I use BehaviorSubject to pass event among them. </p>

<p>Service: </p>

<pre><code>@Injectable()
export class SiteManagementEventService {
  private messageSource = new BehaviorSubject&lt;SiteManagementEvent&gt;(defaultEvent);   
  data = this.messageSource.asObservable();

  constructor() {}

  // publish the event using the service
  public publish(event: SiteManagementEvent) {
    if (event !== null) {
      this.messageSource.next(event);
    }
  }
}
</code></pre>

<p>Publishing events:</p>

<pre><code>constructor (
  .......
  private eventService: SiteManagementService,
) {}
........
this.eventService.publish(event);
</code></pre>

<p>Subscribe the events:</p>

<pre><code>constructor (
  .......
  private eventService: SiteManagementService,
) {}

onInit() {
  ......
  this.eventService.data.subscribe(event =&gt; {console.log(""event received""});
}
</code></pre>

<p>By having the above, the issue is that only one receiving component (I have multiple receiving components) receives one event, and do not receive any following events.  </p>

<p>Anything I did wrong? Any online samples for this? </p>

<p>Thanks!</p>
","2777473","","","","","2019-04-01 20:52:27","Observable subscription only recieve the first event","<angular><rxjs6><behaviorsubject>","1","0","1","","","CC BY-SA 4.0"
"55470375","1","55475711","","2019-04-02 08:39:50","","-3","119","<p>I wanted to understand the intellisense displayed in the visual code which got me more confused</p>

<p><a href=""https://i.stack.imgur.com/6hxLB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/6hxLB.png"" alt=""enter image description here""></a></p>

<pre><code>debounce(
durationSelector: (value: {}) =&gt; SubscribableOrPromise&lt;any&gt;
): MonoTypeOperatorFunction&lt;{}&gt;
</code></pre>

<p>from the above example, I think I understood the following:</p>

<ol>
<li><code>debounce</code> is the name of the function</li>
<li><p><code>durationSelector</code> is a function which that a single parameter:</p>

<p>a. <code>value</code> which takes Object as parameter</p>

<p>b. <code>SubscribableOrPromise&lt;any&gt;</code> is the type that the function is going to return</p></li>
<li><code>MonoTypeOperatorFunction&lt;{}&gt;</code>, not able to understand how a function can return <code>MonoTypeOperatorFunction&lt;{}&gt;</code> when it already returns <code>SubscribableOrPromise&lt;any&gt;</code>, this is where I am confused and not able to understand</li>
</ol>
","2711059","","2711059","","2019-04-02 14:10:50","2019-04-02 14:10:50","Not able to understand debounce parameters in rxjs","<rxjs6><debounce>","2","9","","","","CC BY-SA 4.0"
"55485895","1","","","2019-04-03 01:51:28","","0","33","<p>Can you help me with this one? My nested map :</p>

<pre><code>        jobData.map(entity =&gt; {
                entity.entityType.dataProperties.map(property =&gt; {
                  if (/date/i.test(property.name)) {
                    if (entity[property.name] !== null) {
                      const formattedDate = moment(entity[property.name]).format('L');
 // Even this does not work:  const formattedDate = moment('01/01/2009).format('L');
                      return formattedDate;
                    }
                    return property;
                  }
                });
              });
      const newdata = jobData;
</code></pre>

<p>Is not returning the updated values.</p>

<p>I think I am misplacing my return statements. </p>

<p>Can someone help me out with this?</p>
","963048","","","","","2019-04-03 13:55:31","Why isn't my nested map function returning the updated data?","<javascript><rxjs6>","1","3","","","","CC BY-SA 4.0"
"55489507","1","","","2019-04-03 07:35:13","","0","34","<p><code>this.msService.createUpdate</code> is hitting 2 times and throwing error.
I have tried using take(1) but that is also not working.</p>

<pre><code>  this.msService.save(this.ms).subscribe((ms: any) =&gt; {                   this.msService.getDataItemWithCalculations(String(this.DataItemId)).subscribe((calcs:any) =&gt; { //other manipulations                              this.msService.createUpdate(this.ms).subscribe(mswithChild =&gt; {
                       //service is hitting twice
                            this.msService.getDataItemWithCalculations(String(this.ms.DataItemUID)).subscribe(
                                (ms :any)=&gt; {
                                    //other manipulations
                                this.setNotificationMessage();
                                }, error =&gt; this.setNotificationMessage();
                                  }, error =&gt; this.setNotificationMessage();
                                    }, error =&gt; this.setNotificationMessage();
                                      }, error =&gt; this.setNotificationMessage();
</code></pre>
","1285143","","7409220","","2019-04-03 14:53:12","2019-04-03 14:53:12","Multiple subscribe working in Rxjs 5.5.7 not working on RxjS 6.3.3","<angular><rxjs6>","0","10","","","","CC BY-SA 4.0"
"55496498","1","","","2019-04-03 13:34:05","","0","136","<p>Just updated from Angular5 to Angular7 and while converting old RxJS syntax to new I am stuck with this error. Here is the code:</p>

<pre><code>     return this.http.request( reqOptions )
        .pipe( 
            map( (resp: HttpResponse&lt;any&gt;) =&gt; resp.body )
        );
</code></pre>

<p>I get the map(...) line underlined with TS Error which says</p>

<pre><code>The 'this' context of type 'void' is not assignable to method's 'this' of type 'Observable&lt;HttpResponse&lt;any&gt;&gt;'.ts(2684)
</code></pre>

<ul>
<li>Angular CLI V 7.3.7 </li>
<li>Angular Core V 7.2.11 </li>
<li>RxJS V 6.4.0 </li>
<li>RxJsCompat V 6.4.0 </li>
<li>TypeScript V 3.2.4</li>
<li>IDE: VS Code</li>
</ul>

<p>What's the deal?</p>

<p>PS. Just checked a different project running same major versions of those libraries with WebStorm and while having the same syntax AND virtually the same <code>tsconfig</code> files, I don't get any type errors there?...</p>
","542191","","","","","2019-04-03 13:34:05","TS2684 with HttpClient response in Angular","<angular><typescript><rxjs><rxjs6>","0","6","","","","CC BY-SA 4.0"
"55503823","1","55504081","","2019-04-03 20:33:18","","2","819","<p>I have my observable with interval and takeuntil which is working fine in angular 5. Now When I update it to angular 6 and rxjs6, it is failing. 
I changed from Observable.interval to interval but takeuntil is not working.
I need takeuntil because, I need to stop this observable when the component is destroyed.</p>

<pre><code>import { Observable, Subject } from ""rxjs"";

private onDestroy$ = new Subject&lt;void&gt;();

Observable.interval(600000).takeUntil(this.onDestroy$).subscribe(x =&gt; {
    // do something
});

ngOnDestroy() {
    this.onDestroy$.next();
}
</code></pre>
","7582976","","9325419","","2019-04-03 20:54:17","2019-04-03 20:54:17","Object(...)(...).takeUntil is not a function","<angular><rxjs><angular6><rxjs6>","2","2","","","","CC BY-SA 4.0"
"55511596","1","55513552","","2019-04-04 08:46:59","","2","278","<p>this is the code</p>

<pre><code>const timerOne = timer(1000, 4000).pipe(
  map(x=&gt;`1-${x}-${new Date().getSeconds()}`)
)
//timerTwo emits first value at 2s, then once every 4s
const timerTwo = timer(2000, 4000).pipe(
  map(x=&gt;`2-${x}-${new Date().getSeconds()}`)
);
//timerThree emits first value at 3s, then once every 4s
const timerThree = timer(3000, 4000).pipe(
  map(x=&gt;`3-${x}-${new Date().getSeconds()}`)
);

//when one timer emits, emit the latest values from each timer as an array
const combined = combineLatest(timerOne, timerTwo, timerThree);

const subscribe = combined
.pipe(take(5))
.subscribe(
  ([timerValOne, timerValTwo, timerValThree]) =&gt; {   
    console.log(
     ` ${timerValOne},
    ${timerValTwo},
     ${timerValThree}`
    );
  }
);
</code></pre>

<p>this is the definition for combineLatest() in rxjs </p>

<blockquote>
  <p>will not emit an initial value until each observable emits at least
  one value.</p>
</blockquote>

<p>now from the above defintion, the output should be </p>

<pre><code>1-2-56,
2-1-57,
3-0-58
</code></pre>

<p>instead of </p>

<pre><code>1-0-56,
2-0-57,
3-0-58
</code></pre>

<p>because, we will only get the value of the <strong>timerThree</strong> Observable after 3second by that time the latest value for <strong>timerOne</strong> would be 2 and the latest value for <strong>timerTwo</strong> would be 1, am i missing something, please help, thank you</p>
","2711059","","","","","2019-05-04 18:15:02","CombineLatest is not taking the latest value in rxjs","<rxjs6><combinelatest>","1","0","","","","CC BY-SA 4.0"
"55516707","1","55517145","","2019-04-04 13:03:50","","14","14733","<p>Using RxJS v6 is challenging to retrieve data from sub collection for every item in the loop. There is no way to iterate throw array that is retrieved from HTTP call. Merge map does it only for single item where there is a requirement to do it on all array items.</p>
<p>I've been stuck on this for 3 days. I've tried everything. Problem is that new pipe syntax while provides you with neat way to organise code there is no easy way to loop throw collection of data. It is impossible to use map javascript function as it is outside observable and items returned are undefined. On internet I could only find basic examples for a single mergeMap which works great. However I need to use
every item in array with http call and append response to same object.</p>
<p>I start with two endpoints from 3rd party which I have no control off. I have mocked some example API to illustrate.</p>
<p>Endpoint 1 - Returns all items ID's:
http://localhost:3000/contact</p>
<pre class=""lang-json prettyprint-override""><code>{
  &quot;name&quot;: &quot;test&quot;,
  &quot;contact&quot;: [
    {
      &quot;_id&quot;: &quot;5c9dda9aca9c171d6ba4b87e&quot;
    },
    {
      &quot;_id&quot;: &quot;5c9ddb82ca9c171d6ba4b87f&quot;
    },
    {
      &quot;_id&quot;: &quot;5c9ddb8aca9c171d6ba4b880&quot;
    }
  ]
}
</code></pre>
<p>Endpoint 2 - Returns single item information:
http://localhost:3000/contact/5c9dda9aca9c171d6ba4b87e</p>
<pre class=""lang-json prettyprint-override""><code>[
   {
     &quot;_id&quot;: &quot;5c9dda9aca9c171d6ba4b87e&quot;,
     &quot;firstName&quot;: &quot;Luke&quot;,
     &quot;lastName&quot;: &quot;Test&quot;,
     &quot;email&quot;: &quot;vgadgf@adsgasdg.com&quot;,
     &quot;created_date&quot;: &quot;2019-03-29T08:43:06.344Z&quot;
   }
]
</code></pre>
<p>DESIRED RESULT - By using RxJs v6+ return Observable with nested data:</p>
<pre class=""lang-json prettyprint-override""><code>{
  &quot;name&quot;: &quot;test&quot;,
  &quot;contact&quot;: [
    {
      &quot;_id&quot;: &quot;5c9dda9aca9c171d6ba4b87e&quot;.
      &quot;relationship&quot;:  {
                         &quot;_id&quot;: &quot;5c9dda9aca9c171d6ba4b87e&quot;,
                         &quot;firstName&quot;: &quot;Luke&quot;,
                         &quot;lastName&quot;: &quot;Test&quot;,
                         &quot;email&quot;: &quot;vgadgf@adsgasdg.com&quot;,
                         &quot;created_date&quot;: &quot;2019-03-29T08:43:06.344Z&quot;
                       }
    },
    {
      &quot;_id&quot;: &quot;5c9ddb82ca9c171d6ba4b87f&quot;,
      &quot;relationship&quot;: {
                         &quot;_id&quot;: &quot;5c9ddb82ca9c171d6ba4b87f&quot;,
                         &quot;firstName&quot;: &quot;Name2&quot;,
                         &quot;lastName&quot;: &quot;Test2&quot;,
                         &quot;email&quot;: &quot;vgadgf@adsgasdg2.com&quot;,
                         &quot;created_date&quot;: &quot;2019-03-29T08:43:06.344Z&quot;
                       }
    },
    {
      &quot;_id&quot;: &quot;5c9ddb8aca9c171d6ba4b880&quot;,
      &quot;relationship&quot;: {
                         &quot;_id&quot;: &quot;5c9ddb8aca9c171d6ba4b880&quot;,
                         &quot;firstName&quot;: &quot;Name3&quot;,
                         &quot;lastName&quot;: &quot;Test3&quot;,
                         &quot;email&quot;: &quot;vgadgf@adsgasdg3.com&quot;,
                         &quot;created_date&quot;: &quot;2019-03-29T08:43:06.344Z&quot;
                       }
    }
  ]
}
</code></pre>
<p>I just get errors when trying to use Javascript loop and using different operators doesn't give me much either as problem is with looping in RxJs. This is code I have produced. Please provide any useful suggestions or documentation.</p>
<p>testService.service.ts</p>
<pre class=""lang-js prettyprint-override""><code>import { Injectable } from '@angular/core';
import {HttpClient} from '@angular/common/http';
import {Observable} from 'rxjs/Observable';
import {concatMap, map, mergeMap} from 'rxjs/operators';

@Injectable()
export class TestServiceService {

  constructor(
    private http: HttpClient
  ) { }

  public getCombinedData(): Observable&lt;any&gt; {
    return this.getMultipleRelationData()
      .pipe(
        map((result: any) =&gt; {
          result = result.contact;

          return result;
        }),
        mergeMap((fullResults: any) =&gt; {
          return fullResults[0].relationship = this.getSingleData(fullResults[0]._id);
        })
      );
  }

  public getSingleData(id): Observable&lt;any&gt; {
    return this.http.get('http://localhost:3000/contact/' + id);
  }

  public getMultipleRelationData(): Observable&lt;any&gt; {
    return this.http.get('http://localhost:3000/contact');
  }

}
</code></pre>
<p>My current end data looks like just a single item. Its great if I wanted to make just a single call... However its far from desired output described above.</p>
<pre class=""lang-json prettyprint-override""><code>  [
  {
    &quot;_id&quot;: &quot;5c9dda9aca9c171d6ba4b87e&quot;,
    &quot;firstName&quot;: &quot;Luke&quot;,
    &quot;lastName&quot;: &quot;Test&quot;,
    &quot;email&quot;: &quot;vgadgf@adsgasdg.com&quot;,
    &quot;__v&quot;: 0,
    &quot;created_date&quot;: &quot;2019-03-29T08:43:06.344Z&quot;
  }
]
</code></pre>
","2141587","","2237467","","2021-06-18 11:32:26","2021-06-18 11:59:29","Loop array and return data for each id in Observable","<angular><rxjs><observable><angular7><rxjs6>","2","0","12","","","CC BY-SA 4.0"
"55530961","1","55533075","","2019-04-05 08:09:37","","4","955","<p>as per the definition of the switchMap</p>

<blockquote>
  <p>On each emission the previous inner observable (the result of the
  function you supplied) is cancelled and the new observable is
  subscribed. You can remember this by the phrase switch to a new
  observable.</p>
</blockquote>

<p>now, i have a code like this</p>

<pre><code>const source = timer(0, 5000).pipe(map(x=&gt;`${x}`));
const example = source.pipe(switchMap((f) =&gt; interval(1000).pipe(map(y=&gt;`f${f}-s${y}`))),take(20));
const subscribe = example.subscribe(val =&gt; console.log(val+' '+ new Date().getSeconds()));
</code></pre>

<p>and the result is this</p>

<p><a href=""https://i.stack.imgur.com/GVTwA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GVTwA.png"" alt=""enter image description here""></a></p>

<p>my question is, </p>

<ol>
<li><p>25th second - the outer function is called and the inner function is not yet triggered, so the latest value of the outer function is 0 and inner function is also 0 as a default one because it has no value yet <strong>f0-s0 25</strong></p></li>
<li><p>26th second - the inner function is called and the value ideally should be 0 as the function is just called first time but it is 1 ie. <strong>f0-s1 26</strong></p></li>
<li><p>30th second - the outer function is called which resets the inner function value to 0, ie. <strong>f1-s0 30</strong></p></li>
<li><p>why is the inner function got reset on the 35th second, it is still 1 second remaining</p></li>
</ol>

<p><a href=""https://stackblitz.com/edit/rxjs-fwcap5?file=index.ts&amp;devtoolsheight=60"" rel=""nofollow noreferrer"">stackblitz link</a></p>

<p>i find it very difficult to understand the concept, thank you</p>
","2711059","","1000551","","2019-04-05 08:29:47","2019-06-07 21:45:22","Understanding SwitchMap in rxjs","<javascript><rxjs><reactive-programming><rxjs6><switchmap>","2","1","","","","CC BY-SA 4.0"
"55542923","1","","","2019-04-05 20:29:19","","1","7998","<p>I am converting my code to use RxJS6 syntax to use pipe and map but I am getting error. </p>

<pre><code>error TS2345: Argument of type '(error: any) =&gt; void' is not assignable to parameter of type '(err:
any, caught: Observable&lt;void&gt;) =&gt; ObservableInput&lt;{}&gt;'.
  Type 'void' is not assignable to type 'ObservableInput&lt;{}&gt;'.
</code></pre>

<p>The existing code works fine but the issue I have is that before result is returned, other methods get called. So to my understanding using pipe and map 
will resolve this issue.
Here is the code I had initially:</p>

<pre><code>this._reportingService.GetProjectReportsData(data).subscribe(result =&gt; {
    if (result != null) {
        this.reportData = result;
    }

}, error =&gt; {
    this.ErrorMessage('Unable to load workbook ' + error.toString());
    this._reportingService.isLoading = false;
});
</code></pre>

<p>Here is the code I am trying to convert to using pipe and map:</p>

<p>I have imported along with rest of imports</p>

<pre><code>import { Observable, of, throwError } from 'rxjs';
import { map, catchError, retry } from 'rxjs/operators';
</code></pre>

<p>and in the method(modified; removed this.error) Please guide how to add code for errorMessage:</p>

<pre><code>this._reportingService.GetProjectReportsData(data).pipe(
    map(result =&gt; {
        if (result != null) {

  this.reportData = result;


        }
    }))
    .subscribe();
</code></pre>

<p>And my service class:</p>

<pre><code>import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';

import { map, tap, catchError } from 'rxjs/operators';
import 'rxjs/add/operator/catch';
import 'rxjs/add/observable/throw';


@Injectable({
    providedIn: 'root'
})
export class ReportingService extends BehaviorSubject&lt;any[]&gt;{

    constructor(private http: HttpClient) {

    super(null);
    }

    public GetProjectReportsData(data: any): Observable&lt;any&gt; {
        return this.http.post(this.GetProjectReportDataUrl, data)
            .pipe(map(res =&gt; &lt;any[]&gt;res))
            .pipe(catchError(this.handleError));
    }
    private handleError(error: any) {

        let errMsg = (error.message) ? error.message :
            error.status ? `${error.status} - ${error.statusText}` : 'Server error';
        return Observable.throw(errMsg);
    }

}
</code></pre>
","6686925","","6686925","","2019-04-05 21:32:33","2019-04-06 00:03:30","Angular 6 RxJS6 Type 'void' is not assignable to type 'ObservableInput<{}>'","<angular><observable><rxjs6>","3","0","","","","CC BY-SA 4.0"
"55543413","1","55543548","","2019-04-05 21:10:37","","2","426","<p>For RxJS learning purposes, I'm building a small node.js app that puts everything in a stream where possible.</p>

<p>As a first step, I'm working to load an external configuration yaml file. I've seen examples where fs.readFile is wrapped in a bindNodeCallback, which returns an observable when called. However, the readFile variable set below is still a <code>typeof</code> of 'function'. As a result, I'm unable to chain flatMap to it.</p>

<p>How may I reorganize the code below to chain bindNodeCallback() and yaml.safeLoad() (which doesn't offer a callback) before initializing my app?</p>

<pre><code>const yaml = require('js-yaml');
const fs = require('fs');
const { bindNodeCallback, of } = require('rxjs');
const { mergeMap, map } = require('rxjs/operators');

const configPath = './config/config.yml';
const configEncoding = 'utf8';

const readFile = bindNodeCallback(fs.readFile);

readFile(configPath, configEncoding)
.flatMap(yamlString =&gt; of(yaml.safeLoad(yamlString))) // error: .flatMap is not a funciton
.subscribe(
    config =&gt; {
        console.log(config);
        // launch the app when config is loaded
    }, 
    err =&gt; console.error(err)
);
</code></pre>
","1279000","","","","","2019-04-05 21:54:57","RxJS: How may I treat bindNodeCallback() as an Observable that can have operators chained to it?","<node.js><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55586924","1","","","2019-04-09 07:06:23","","0","46","<p>I'm looking at the convert guide available <a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md"" rel=""nofollow noreferrer"">here</a> and I'm trying to convert merge used in pipe following this guide, but it is not working as it was before the change. </p>

<p>Here is my piece of code I'm using to learn new merge: </p>

<pre class=""lang-js prettyprint-override""><code>    this.form.valueChanges.pipe(
      startWith(1),
      merge(this.form.statusChanges),
      merge(this.click$),
      map(() =&gt; this.form.value.query),
      filter(() =&gt; this.form.valid)
    )
    .subscribe(this.search);
</code></pre>

<pre class=""lang-js prettyprint-override""><code>  private search = (query: string) =&gt; {
    this.tvs.search(query).subscribe(shows =&gt; this.shows = shows);
  }
</code></pre>

<p>I've tried to do something like that: </p>

<pre class=""lang-js prettyprint-override""><code>    merge(
    this.form.valueChanges.pipe(
    startWith(1),
      map(() =&gt; this.form.value.query),
      debounceTime(500),
      tap(() =&gt; this.form.controls.query.errors &amp;&amp; console.log(this.form.controls.query.errors)),
      tap(() =&gt; this.form.status &amp;&amp; console.log(this.form.status)),
      filter(() =&gt; this.form.valid)
    ), this.form.statusChanges, this.click$)
    .subscribe(this.search);
</code></pre>

<p>But in network tab in chrome I'm getting the call to api with query equal to status of the form (VALID or INVALID). What is the proper way to convert this?</p>
","2846167","","","","","2019-04-09 07:57:56","How should I convert merge used in pipe in v5 to v6","<angular><typescript><rxjs5><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"55615635","1","","","2019-04-10 14:54:28","","1","1007","<p>I have an angular component that polls for new data, and while we are waiting for a response it updates a message in the UI every X seconds.  It cycles through a simple string array of messages to show.</p>

<p>Once the correct data is received, we navigate to the appropriate page.</p>

<pre class=""lang-js prettyprint-override""><code>this.pollSubscription = timer(0, pollTimeInSeconds)
    .pipe(
        //convert each observable iteration into an interval in seconds
        map((count: number) =&gt; count * pollTimeInSeconds),
        //keep going if we are below the max poll time
        takeWhile((time: number) =&gt; time &lt; this.maxPollTime),
        //update the UI message
        tap((time: number) =&gt; this.updateCurrentMessage(time)),
        //
        switchMap(() =&gt; this.getDataOrError$())
    )
    .subscribe(
        //navigate to the correct page
        (d: IData) =&gt; this.navigateBasedOnStatus(d),
        //If an error occurs, OR the observable completes (which should not happen), navigate to the error page
        () =&gt; this.navigateToError(),
        () =&gt; this.navigateToError()
    );
</code></pre>

<p>I want to test this behavior, but I'm not entirely sure how to mock the <code>timer</code> for this situation.  I saw <a href=""https://stackoverflow.com/a/50770564/79677"">this SO answer</a> but I wasn't able to make that work for my situation.</p>

<p>Ideally I'd like to structure a test somewhat like this to ensure that each message shows and that if the timer goes longer than expected it loops back around to the first message:</p>

<pre class=""lang-js prettyprint-override""><code>it('should show every status as the timer changes', fakeAsync(() =&gt; {
    tick(0);
    fixture.detectChanges();
    expect(debugEl.nativeElement.innerText.trim()).toEqual('Message one');

    tick(1000);
    fixture.detectChanges();
    expect(debugEl.nativeElement.innerText.trim()).toEqual('Message two');

    tick(2000);
    fixture.detectChanges();
    expect(debugEl.nativeElement.innerText.trim()).toEqual('Message three');

    //etc...
}));
</code></pre>

<hr>

<p><strong>EDIT</strong> I'm including a new attempt at testing this based on some comments below, but this is stil not working</p>

<pre class=""lang-js prettyprint-override""><code>let timerTick: (milliseconds: number) =&gt; void;

beforeEach(() =&gt; {
    let fakeNow = 0;
    timerTick = (milliseconds: number): void =&gt; {
        fakeNow += milliseconds;
        tick(milliseconds);
    };
    asyncScheduler.now = (): number =&gt; fakeNow;
});

afterEach(() =&gt; {
    delete asyncScheduler.now;
});

it('should show every status as the timer changes', fakeAsync(() =&gt; {
    fixture.detectChanges(); // triggers ngOnInit()

    const pollTimeInSeconds = loginPollTime * 1000;
    let received: number | undefined;
    timer(0, pollTimeInSeconds, asyncScheduler).subscribe((value: number) =&gt; received = value);
    console.log(received);

    timerTick(0);
    fixture.detectChanges();
    expect(debugEl.nativeElement.innerText.trim()).toEqual('Message one');
    console.log(received)

    timerTick(pollTimeInSeconds);
    fixture.detectChanges();
    expect(debugEl.nativeElement.innerText.trim()).toEqual('Message two');
    console.log(received)

    timerTick(pollTimeInSeconds * 2);
    fixture.detectChanges();
    expect(debugEl.nativeElement.innerText.trim()).toEqual('Message three');
    console.log(received)
}));
</code></pre>

<p>The jasmine output is:</p>

<pre><code>Expected 'Message one' to equal 'Message two'.
Expected 'Message one' to equal 'Message three'.
</code></pre>

<p>The console output is:</p>

<pre><code>&gt; undefined
&gt; 0
&gt; 1
&gt; 3
</code></pre>
","79677","","79677","","2019-04-11 14:22:24","2019-04-11 14:22:24","How to mock RXJS timer() in jasmine test?","<jasmine><rxjs><karma-jasmine><rxjs6>","0","4","","","","CC BY-SA 4.0"
"55645335","1","55645548","","2019-04-12 05:58:19","","0","76","<p>There is an issue I'm facing. Not sure if it is working as expected. </p>

<pre><code>  startTimerSubscription(){
    this.timerSubscription.unsubscribe();
    let subscription = this._testService.getTimerData().subscribe((response) =&gt; {
      console.log(response);
    });
    this.timerSubscription.add(subscription);
  }
</code></pre>

<p>Whenever I'm calling the function, the data is never subscribed. i.e there is no console print of the data. </p>

<p>my test service has <code>getTimerData()</code> defined as: </p>

<pre><code>getTimerData(){
    return timer(0,10000).pipe(switchMap(()=&gt; {
      return of(this.testData);
    }));
  }
</code></pre>

<p>Can someone explain this behaviour to me? I'm unsubscribing the data before subscribing it. Shouldn't the data be logged every 10 seconds?</p>

<p>I tried using <code>interval</code> operator and the result is the same.</p>

<p>I have also created a <a href=""https://stackblitz.com/edit/subscription-issue"" rel=""nofollow noreferrer"">stackblitz example</a></p>

<p>Thanks in advance</p>
","6949235","","8199990","","2019-04-12 07:29:35","2019-04-12 07:29:35","Unsubscribe from Observable stopping the http call","<angular><rxjs><rxjs6>","2","1","","","","CC BY-SA 4.0"
"55647346","1","55649449","","2019-04-12 08:21:18","","0","35","<p>I have following function which calls the refresh service to get new token for authorization:</p>

<pre class=""lang-ts prettyprint-override""><code>private handle401Error(request: HttpRequest&lt;any&gt;, next: HttpHandler) {
  if(!this.isRefreshingToken) {
    this.isRefreshingToken = true;
    return this.authService.refreshToken()
    .subscribe((response)=&gt; {
      if(response) {
        const httpsReq = request.clone({
          url: request.url.replace(null, this.generalService.getUserId())
        });
        return next.handle(this.addTokenToRequest(httpsReq, response.accessToken));
      }
      return &lt;any&gt;this.authService.logout();
    }, err =&gt; {
      return &lt;any&gt;this.authService.logout();
    }, () =&gt; {
      this.isRefreshingToken = false;
    })
  } else {
    this.isRefreshingToken = false;
    return this.authService.currentRefreshToken
    .filter(token =&gt; token != null)
    .take(1)
    .map(token =&gt; {
      return next.handle(this.addTokenToRequest(request, token));
    })
  }
}
</code></pre>

<p>When the response is not undefined and request is returned back it does not call the new request</p>
","9855057","","6921829","","2019-04-12 23:03:50","2019-04-12 23:03:50","Changed request does not work in angular 6","<angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55651586","1","55651799","","2019-04-12 12:24:32","","0","52","<p>I need to filter a list of objects and create an distinct observable stream from a string[] member. Typescript 2.9.2</p>

<pre><code>interface Product2 {
  id: number;
  categories: string[];
}

const products: Product2[] = [
   {id: 1, categories: ['abc', 'def']},
   {id: 2, categories: ['def', 'xyz']}
];
const products$: Observable&lt;Product2&gt; = from(products);

const allCategories$: Observable&lt;string|void&gt; = products$
  .pipe(
      map((val: Product2) =&gt; { from(val.categories).subscribe(); } ),
      distinct()
  );

console.log('logging categories');
allCategories$.subscribe(val =&gt; console.log(val));
</code></pre>

<p>Expected 'abc', 'def', 'xyz' got undefined.</p>
","7425793","","","","","2019-04-12 12:37:32","I have an Observable object stream and am trying return a Observable<string> stream from an array member","<typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55659438","1","","","2019-04-12 21:07:34","","1","133","<p>I am looping through an array and calling <code>LoadReportsData</code>. The <code>getProjectReportsData</code> in <code>_reportingService</code>  gets called in the correct order. But when the controls returns back from service map is hit and then <code>.subscribe()</code> the code inside does not get hit until all the calls are made.</p>

<p>After that, result gets assigned to <code>this.reportData</code> but in random order. Due to this behavior my worksheets in the workbook are created randomly and not in intended order. Please suggest if there is a different way to make calls and or suggest some workaround.</p>

<pre><code>FetchProjectSubmissionReportingAssets(ID: number,
        mySelectiontot: number, PRsDelimitedList: string, StartDate: string, EndDate: string) {

        let currAsset: string = '';
        let ID: number;
        var fetchAssetData = {
            'CSID': ID
        }
        this._reportingService.isLoading = true;
        this._reportingService.getProjSubRptAssets(fetchAssetData).pipe(
            map(result =&gt; {
                if (result != null) {

                    for (var i = 0; i &lt; result.length; i++) {
                        this.ProjReqSubmissionReportingAssets = result;


                        currAsset = result[i].option;
                        ID = result[i].id;

                        this.LoadReportsData(ID, currAsset, i);

                    }
                }
            }))
            .subscribe();


    }


    LoadReportsData(CSAsID: number, currAsset: string, tabIndex: number) {

        this.wb = XLSX.utils.book_new();

            var indata = {
                'CSID': this.CSID,
                'CSAsID': CSAsID,
                'StartDate': this.StartDate,
                'EndDate': this.EndDate,
                'PRsDelimitedList': this.PRsDelimitedList

            }
            this._reportingService.getProjectReportsData(indata).pipe(
                map(result =&gt; {

                        this.reportData = result;

                        this.idx = this.idx + 1;

                        if (this.reportData != null) {
                            this.ws = this.ws + '_' + tabIndex.toString();
                            this.ws = XLSX.utils.json_to_sheet(this.reportData);
                            XLSX.utils.book_append_sheet(this.wb, this.ws, currAsset);
                            console.log(currAsset);
                        }
                        if (this.ProjReqSubmissionReportingAssets.length == this.idx) {
                            var currDateTime = this.fn_getTimeStamp();
                            XLSX.writeFile(this.wb, ""ProjReport_"" + this.HCs + ""_"" + currDateTime + "".xlsx"");
                        }

                }))
            .subscribe();

            this._reportingService.isLoading = false;

}
</code></pre>
","6686925","","6686925","","2019-04-18 00:13:28","2019-04-18 00:13:28","Angular 6 RxJS6 observable not returning data in right order","<angular><typescript><observable><rxjs6>","1","1","","","","CC BY-SA 4.0"
"55681597","1","","","2019-04-15 01:32:05","","1","208","<p>I am having an issue when using withLatestFrom. The console is showing the following error:</p>

<p><em>You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable</em></p>

<p>The code is:</p>

<pre><code>import { first, map, distinctUntilChanged, withLatestFrom } from 'rxjs/operators';

    this.subscriptionList.push(
        this.store
            .select(fromReducer.getSelectedProduct)
            .pipe(withLatestFrom(this.store.select(fromReducer.getAllUrlConfigurationEntities)))
            .pipe(
                map(([product, urlConfigurations]) =&gt; {
                    const my_product = product || {};
                    return {
                        urlConfigurations,
                        product: my_product
                    };
                }),
                distinctUntilChanged((previous: any, current: any) =&gt; current.urlConfigurations.length === 0 || previous.product.id === current.product.id)
            )
            .subscribe(data =&gt; {
                const urlConfigurations = data.urlConfigurations;
                console.log(urlConfigurations);
                if (urlConfigurations) {
                    this.urlConfigurations = JSON.parse(JSON.stringify(urlConfigurations));
                }

                return;
            })
    );
</code></pre>

<p>I tried returning an observable like <code>.pipe(withLatestFrom(this.store.select(fromReducer.getAllUrlConfigurationEntities)))</code>.</p>

<p>But I need the value afterwards and not the Observable.</p>

<p>Thank you for your help and time!</p>
","8164695","","","","","2019-04-15 11:03:13","Angular7 Ngrx6 withLatestFrom warning","<angular><ngrx><rxjs6>","1","7","","","","CC BY-SA 4.0"
"55685728","1","55685903","","2019-04-15 09:00:48","","0","404","<p>I have nested subscription that I would like to get rid of using a suitable <a href=""https://www.learnrxjs.io/"" rel=""nofollow noreferrer"">RxJS</a> operator. I have already tried <a href=""https://www.learnrxjs.io/operators/transformation/concatmap.html"" rel=""nofollow noreferrer"">concatMap</a> and <a href=""https://www.learnrxjs.io/operators/transformation/mergemap.html"" rel=""nofollow noreferrer"">mergeMap</a> with which I unfortunately could not solve my problem.</p>

<p>I have 3 subscriptions that depend on each other and trigger a new observable within the forEach loops for each value of the current loop. To illustrate this in more detail, here is my sample code:</p>

<pre><code>this.subscriptionOne = this.serviceOne.getStreets().subscribe((streets) =&gt; {
  streets.forEach((street) =&gt; {
    this.subscriptionTwo = this.serviceTwo.getMetaData(street.id).subscribe((metaDatas) =&gt; {
      metaDatas.forEach((md) =&gt; {
        // do some stuff and then trigger another observable..
        this.subscriptionThree = this.serviceTwo.getStuff(md.id, md.type, md.name).subscribe((stuff) =&gt; {
          // do some other stuff
        });
      });
    });
  });
});
</code></pre>

<p>How can I get rid of this nesting with RxJs?</p>
","6475284","","","","","2019-04-15 09:57:11","How to implement several nested and interdependent subscriptions with RxJS operators?","<angular><typescript><rxjs><observable><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"55686833","1","55687291","","2019-04-15 10:07:32","","1","483","<p>Using RxJS 6,</p>

<p>I have a stream of arbitrary data:</p>

<pre><code>[in] -&gt; a, b, c, d, e, f, g, h, i, ....
</code></pre>

<p>I want to split it into a fixed number N streams in an alternating order (in this case 3 output streams):</p>

<pre><code>[out] -&gt; stream1 -&gt; a, d, g
      -&gt; stream2 -&gt; b, e, h
      -&gt; stream3 -&gt; c, f, i
</code></pre>

<p>or more simply put:</p>

<pre><code>a =&gt; stream1
b =&gt; stream2
c =&gt; stream3
d =&gt; stream1
e =&gt; stream2
f =&gt; stream3
g =&gt; stream1
h =&gt; stream2
i =&gt; stream3
</code></pre>

<p>Any one know how I can do this?</p>
","2765977","","1000551","","2019-04-15 10:08:03","2019-04-15 10:39:46","How to split a stream into multiple streams in sequence","<javascript><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"55690867","1","","","2019-04-15 13:59:52","","0","137","<p>I am rather new to RxJS and was trying to figure out a simple pipe(toArray), but can't seem to make it work.  Every example I've seen suggests that this should work:</p>

<pre><code>import {toArray} from 'rxjs/operators';
import {of} from 'rxjs';

it('observable should generate array of length 3', done=&gt;{
    of(1,2,3).pipe(toArray).subscribe(val=&gt; {
        expect(val.length).toBe(3);
        done();
    });
});
</code></pre>

<p>Yet, it simply throws an error '.subscribe is not a function'</p>

<p>package.json:</p>

<pre><code>""rxjs"": ""^6.4.0"",
""rxjs-compat"": ""^6.4.0""
</code></pre>
","2765977","","2765977","","2019-04-15 14:08:10","2019-04-15 15:03:27","RxJS, can't get pipe(toArray).subscribe to work","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"55692603","1","55693182","","2019-04-15 15:31:52","","0","140","<p>I am using the Behavioursubject in my application i subscribed the Behavioursubject using async pipe and I have subscribed in my component. </p>

<p>issue: when ever i am trying to update the data in Behavioursubject the data is updating in the Behavioursubject. the component subscription is not getting updated. at the time of application initiation subscription getting executed. after initiation based on change i am updating the data in the service the data is updating in the service but the subscription inside the component is not updating.</p>

<p>I tried multiple ways like changing the service registration to root module and that too not worked</p>

<p>Here is my component code:</p>

<p>this is the method subscription called.</p>

<pre><code> ngOnInit() {
 this.getnotifications();
 }
 getnotifications() {
     this.notifications.getjsnotifications('all');
    this.notifications.jsnotifications.subscribe(data =&gt; {
      console.log(""came after the update"");
      this.jsnotifications = data;
    });
   }
</code></pre>

<p>Here is the code of service:</p>

<pre><code>
  public jsnotifications = new BehaviorSubject(null);

  constructor(){
   this.getjsnotifications(""all"");
  }

  getjsnotifications(type){
    this.http.get&lt;Config&gt;(`${environment.JS_API}/jobseeker/notifications/getJobSeekerNotifications?notificationType=`+type).subscribe(data =&gt;{
     console.log(data.map.notificationsVo);
      this.jsnotifications.next(data.map.notificationsVo);
      this.jsnotifications.subscribe(data =&gt; {
        console.log(data);
      })
      this.testbehaviour.next(data.map.notificationsVo);
      console.log(""data updated"");
    });
  }

</code></pre>

<p>Please help me to resolve the issue.</p>

<p>Thanks in advance.</p>
","8578078","","3814835","","2019-04-16 06:15:56","2019-04-17 06:59:28","How to fix Behavioursubject subscription issue from service to component","<angular><rxjs><angular7><rxjs6>","1","3","","","","CC BY-SA 4.0"
"55697208","1","","","2019-04-15 21:03:45","","1","3199","<p>I'm making a front end GUI for an API. One of the steps in this tool is polling an app for multifactor authentication, etc. I don't deal with that. </p>

<p>I'm trying to make an Angular 7 function that polls or calls this HTTP GET <code>/getmfa</code> API every 5 seconds until the MFA goes through and API gives me a JSON.</p>

<p>I'm having trouble getting interval to work. The internet is full of conflicting info with RxJS versions and <code>.pipe</code> syntax. I'm using RxJS 6+ and Angular 7</p>

<p>First I tried to get interval to work</p>

<pre><code>    poll(apiUrl: string, options?: any): Observable&lt;any&gt; {
        let url = apiUrl;
        let headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        let httpOptions = {
            headers: headers,
            withCredentials: true,
        };

        return interval(5000).pipe(map(() =&gt; {
            return this.http.get(url, httpOptions)
                .pipe(
                    map(
                        (data) =&gt; {
                            console.log('polling...');
                            console.log(data);
                            return data;
                        },
                        error =&gt; {
                            console.log('Error:', error);
                        }
                    )
                )
        }));
</code></pre>

<p>Even timeout doesn't work, but it's not what I want anyway. </p>

<pre><code>    poll(apiUrl: string, options?: any): Observable&lt;any&gt; {
        let url = apiUrl;
        let headers = new HttpHeaders({
            'Content-Type': 'application/json',
        });
        let httpOptions = {
            headers: headers,
            withCredentials: true,
        };
        setTimeout(() =&gt; {
            return this.http.get(url, httpOptions)
            .pipe(
                (data) =&gt; {
                    return data;
                }
            )
          }, 5000);
</code></pre>

<p>What am I doing wrong?</p>
","7977784","","3001761","","2019-04-15 21:15:43","2019-07-22 07:03:10","Angular 7 polling/get from an API every interval for response code","<typescript><api><angular7><polling><rxjs6>","1","3","","","","CC BY-SA 4.0"
"55697276","1","","","2019-04-15 21:08:33","","-1","71","<p>How do I get the code inside the skipWhile to show as covered by istanbul? I'm using Angular, jasmine and rxjs 6. It can be a completely trivial test as long as the coverage stat shows its covered.</p>

<pre><code>ngOnInit() {      
this.claimSubscription = this.store.pipe(select(ClaimStoreSelectors.selectClaim),
         skipWhile(
            clm =&gt;
               clm.claimId !== this.route.snapshot.params['id']
         ))
         .subscribe(claim =&gt; {
//unimportant for the question
      });
}
</code></pre>
","935618","","","","","2019-04-15 23:12:25","Angular - How do I unit test a function inside an rxjs 6 operator using jasmine so that it shows up as covered in istanbul?","<javascript><angular><rxjs><rxjs6><istanbul>","1","1","","","","CC BY-SA 4.0"
"55701314","1","55702859","","2019-04-16 05:47:21","","1","44","<p>I have a special epics</p>

<pre><code>const extraEpics = combineEpics(someEpic1, someEpicN);
</code></pre>

<p>Each of which will check their case, and they all listen to the same action</p>

<pre><code>action$.pipe(
    ofType(UPDATE_ACTION),
    pluck(""payload""),
    filter(checkSomeExtraCase)
</code></pre>

<p>There is also a default behavior when not one epic does not cause</p>

<pre><code>const defaultBehaviorWithoutFilter = action$.pipe(
        ofType(UPDATE_ACTION),
        pluck(""payload""),
</code></pre>

<p>I need to call it when extra logic was filtered
And I try concat</p>

<pre><code>export default (action$, state$) =&gt;
  concat(
    extraEpics(action$, state$), 
    defaultBehavior(action$, state$)
  )
</code></pre>

<p>But when called extra, default will call to
How can I only cause a default when extra has not been called?</p>
","6429824","","","","","2019-04-16 08:06:28","How not to call the second epic if the first one called?","<rxjs><rxjs6><redux-observable>","1","1","","","","CC BY-SA 4.0"
"55787655","1","56002219","","2019-04-21 23:33:48","","0","211","<p>I have request to google drive using gapi:</p>

<pre><code>getFolders(folderId: string): Observable&lt;{ id: string, name: string }[]&gt; {
    const promise = gapi.client.drive.files.list({
      fields: 'incompleteSearch,nextPageToken,files(id,name)',
      q: `'${folderId}' in parents`,
    }).then((res) =&gt; {
      return JSON.parse(res.result.files);
    });
    return from(promise);
  }
</code></pre>

<p>then I try to show this data in component:
.ts file <code>ngOnInit</code>:</p>

<pre><code>this.data$ = this.googleDriveService.getFolders(rootFolderId)
        .pipe(
          map((files) =&gt; {
            debugger;
            return files.map(file =&gt; ({ id: file.id, header: file.name, content: '', imageUrl: this.defaultImageUrl }));
          }),
          takeUntil(this.destroy$),
        );
</code></pre>

<p>and html file:</p>

<pre><code>  &lt;mat-grid-tile *ngFor=""let elem of (data$ | async)""&gt;
    &lt;app-card (input)=""returnCartItem(elem)"" (click)=""goto(elem.header, elem.id)""&gt;&lt;/app-card&gt;
  &lt;/mat-grid-tile&gt;
</code></pre>

<p>The problem is that <code>data$</code> always empty. I added <code>debugger</code> to <code>map</code> to check maybe something wrong with there, but it never goes in <code>map</code> function. From response, I get 2 files, so <code>res.result.files</code> isn't empty;</p>
","8054597","","8054597","","2019-05-07 08:13:44","2019-05-07 08:13:44","GAPI and Angular 7 issue","<angular><typescript><rxjs><rxjs6><rxjs-pipeable-operators>","4","4","","","","CC BY-SA 4.0"
"55788748","1","55789296","","2019-04-22 03:20:16","","4","6001","<p>For learning purposes, I'm creating a Node app that will need to take x RxJS observables from an array and combine into a single stream of events. I want to know when events occur in any observable, in any order (not in any sequence or full completion). I feel it should be in a single merged stream of events. Basically, the first event that comes through from any observable will complete.</p>

<p>For this, I felt merge() will do the trick. As merge doesn't take arrays directly as a parameter, I'm using reduce so far to help merge.</p>

<p>However, the end result is not an observable, but a function. I can't subscribe to it either. A simplified version of the code can be seen below. </p>

<p>How can I alter this Node 10.14.2, RxJS 6.4.x code to return an observable and not a ""[function]"" that I can tack a .subscribe() to?</p>

<pre><code>const { Observable } = require('rxjs');
const { merge } = require('rxjs/operators');

const observables = [
    Observable.create(observer =&gt; observer.next('Hello')),
    Observable.create(observer =&gt; observer.next('Hello')),
    Observable.create(observer =&gt; observer.next('Hello'))
];

const mergedObservables = observables.reduce((merged, observable) =&gt; {
    console.log(observable);
    return merge(merged, observable);
});

// outputs:
// Observable { _isScalar: false, _subscribe: [Function] }
// Observable { _isScalar: false, _subscribe: [Function] }

console.log(mergedObservables);

// outputs:
// [Function]

mergedObservables.subscribe();
// error:
// TypeError: mergedObservables.subscribe is not a function
</code></pre>
","1279000","","1279000","","2019-04-22 05:10:46","2019-04-22 05:17:02","How do I merge an array of Observables with RxJS 6.x and Node.js?","<node.js><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55788878","1","","","2019-04-22 03:44:49","","1","123","<p>i want to delay emit from observable based on item duration from inside array and print that duration value;id in subscribe ?</p>

<pre><code>[{id:1000},{id:2000},{id:3000},{id:4000}]
                  .map(x =&gt; of(x).pipe(delay( x.id)) )            
                     .subscribe(x=&gt;{ console.log (x.id)});
</code></pre>
","6069595","","","","","2019-04-22 04:41:02","Delay based on item inside collection","<rxjs><rxjs6>","1","3","1","","","CC BY-SA 4.0"
"55789362","1","55789614","","2019-04-22 05:06:12","","1","372","<p>I am working on an Angular7 project and have some issues about error handling on http requests. </p>

<p>Here is my Login Component with two functions</p>

<pre><code>export class LoginComponent implements OnInit, OnDestroy {

    emailLogin1() {

        this.authService.emailLogin1(this.loginForm.value).pipe(delay(1000)).subscribe(
            (response) =&gt; {
                console.log(response);
            },
            (error) =&gt; {
                console.log(error);
            }
        );

    }

    emailLogin2() {

        this.authService.emailLogin2(this.loginForm.value).pipe(delay(1000)).subscribe(
            (response) =&gt; {
                console.log(response);
            },
            (error) =&gt; {
                console.log(error);
            }
        );

    }

}
</code></pre>

<p>Here is my AuthService with two functions.</p>

<pre><code>export class AuthService {

    constructor(private http: HttpClient) {
    }

    emailLogin1(values): any {

        return this.http.post(environment.server + '/auth/emailLogin', values).pipe(
            tap(
                (response) =&gt; {
                    localStorage.setItem('token', response['token']);
                },
                (error) =&gt; {
                    console.log(error);
                }
            )
        );

    }

    emailLogin2(values): any {

        return this.http.post(environment.server + '/auth/emailLogin', values).pipe(
            tap(
                (response) =&gt; {
                    localStorage.setItem('token', response['token']);
                }
            ),
            catchError((error) =&gt; {
                console.log(error);
                throw error;
            })
        );

    }

}
</code></pre>

<p>When I make a request to the server, if response status is successful, it waits for 1000 ms and then shows the result as expected. But if response returns an error, delay(1000) function not working and error block working immediately. I tried with and without catchError. Both working exactly the same.</p>
","4934767","","","","","2019-04-22 05:37:23","How to delay http responses on errors in Angular 7","<angular7><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55797423","1","55797707","","2019-04-22 16:12:47","","1","790","<p>I have a data set of transactions, that I would like to enrich with additional data like the exchange rate at the given date and post it straight back to my api.
But I only get my original transactions without any modifications and I'm still new to Angular and Rxjs. So I could use some help with the operators.</p>

<p>I have a button that calls several apis from a function:</p>

<pre class=""lang-js prettyprint-override""><code>// component.ts
public click() {
    this.deposits = this.depositApi.getAllDeposits()
      .subscribe(
        result =&gt; {
          result.map(x =&gt; this.depositApi.enrichAndSaveDeposit(x));
        }
      );
  }
</code></pre>

<p>Get all raw transactions from local api which all have dates. (This works)</p>

<pre class=""lang-js prettyprint-override""><code>// depositApiService
public getAllDeposits(): Observable&lt;DepositModel[]&gt; {
    return this.http.get&lt;DepositModel[]&gt;(AppConfig.localJsonServerUrl + AppConfig.api.deposits)
      .pipe(
        catchError(this.handleError('getAllDeposits', null))
      );
  }
</code></pre>

<p>Here I call an external api to get the exchange rate for a given date and then make some calculations and  post it back to local api.</p>

<p>But it never gets into the mergeMap part.</p>

<pre class=""lang-js prettyprint-override""><code>// depositApiService
public enrichAndSaveDeposit(deposit: DepositModel): Observable&lt;DepositModel&gt; {
    return this.apiService.getHistoricEurRate(deposit.date)
      .pipe(
        mergeMap(data =&gt; {
          deposit.historicExchangeRate = data.rates.USD;
          deposit.exchangeRate = deposit.sellAmount / deposit.buyAmount;
          deposit.sellAmountInUsd = deposit.sellAmount * data.rates.USD;
          deposit.exchangeRateInUsd = deposit.exchangeRate * data.rates.USD;
          return this.saveLocalDeposit(deposit);
        }), catchError(this.handleError('enrichAndSaveLocalDeposit', deposit))
      );
  }
</code></pre>

<p>Here the external api is called (this works).</p>

<pre class=""lang-js prettyprint-override""><code>// apiService
public getRemoteExchangeRates(): Observable&lt;ExchangeRateModel&gt; {
    return this.http.get&lt;ExchangeRateModel&gt;(AppConfig.exchangeRateApi + '/latest')
      .pipe(
        catchError(this.handleError('getRemoteExchangeRates', null))
      );
  }
</code></pre>

<p>This is the post to local api. (Never gets to this point)</p>

<pre class=""lang-js prettyprint-override""><code>// depositApiService
private saveLocalDeposit(deposit: DepositModel): Observable&lt;DepositModel&gt; {
    return this.http.post&lt;DepositModel&gt;
      (
        AppConfig.localJsonServerUrl + AppConfig.api.deposits,
        deposit,
        { headers: new HttpHeaders().set('Accept', 'application/json') }
      )
      .pipe(
        catchError(this.handleError('saveLocalDeposit', deposit))
      );
  }
</code></pre>
","5815151","","","","","2019-04-22 16:45:03","Angular 7 / Rxjs: chaining and nesting observables","<angular><rxjs6><chain>","2","0","","","","CC BY-SA 4.0"
"55813458","1","55814858","","2019-04-23 14:25:55","","0","39","<p>In RxJS 6, how can I chain and pass data with promises?  I have to do a bunch of JIRA api calls in a row using the jira-connector npm library.  But I'm not sure how to execute and pass the data to functions.</p>

<p>Thanks!</p>

<p>Ex: </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>    const pipeData = Observable.from(jira.search.search({
        jql: 'team = 41 and type = ""Initiative""'
    }))

    pipeData.pipe(
        data =&gt; operators.flatMap(data.issues),
        issue =&gt; Observable.from(jira.search.search({
        jql: `team = 41 and ""Parent Link"" = ${issue.key}`
    }))).subscribe(results =&gt; {
        console.log(results)
    })</code></pre>
</div>
</div>
</p>
","542322","","","","","2019-04-23 15:41:20","Chaining RXJs promises Observable.from","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55846069","1","","","2019-04-25 09:32:44","","0","247","<p>I have an observable of array of items and an observable of item. I want subscribe to both and get the index of observable of item from observable of array of items</p>

<p>i already tried switchmap, concatmap and mergemap but didn't get any result</p>

<pre><code>selectedcategory$ = this.store.pipe(select(selectSelectedCategory));
```observable of array of items
allcategories$ = this.store.pipe(select(selectCategories));

```i am working with ngrx 

I an expecting index of item
</code></pre>
","4394288","","","","","2019-04-25 09:35:32","subscribe multiple observable and get only one after condition match","<angular><rxjs><angular7><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55858464","1","","","2019-04-25 22:34:59","","1","1610","<p>This might be a noob question, but I could find a reference on it.</p>

<p>I have two components placed in different places, each component uses a Service to query an endpoint and get some data (e.g. user profile).</p>

<p>The service returns an observable, I need the observable to be unique or at least to make a unique request.</p>

<pre><code>// Service, shared across multiple components
@Injectable()
export class SomeService {
    getData(): Observable&lt;DataModel&gt; {
        return this._http.get&lt;DataResponse&gt;('/some-route').pipe(
          map((response: DataResponse) =&gt; this.handleResponse(response)),
          share() // is this right ?
        );
    }

}

// Component requesting data
@Component({ selector: '...', ... })
export class FirstComponent implements OnInit {
  constructor(private _service: SomeService) { }

    ngOnInit() {
        this._service.getData().subscribe(
          data =&gt; {
            console.log(data);
          }
        );
      }
}

// Another component requesting the same data
@Component({ selector: '...', ... })
export class SecondComponent implements OnInit {
  constructor(private _service: SomeService) { }

    ngOnInit() {
        this._service.getData().subscribe(
          data =&gt; {
            console.log(data);
          }
        );
      }
}
</code></pre>

<p>The service works and it gets the data, but the request is sent twice, I only want a single request to be sent. The components live at the same time (let say one at the top and the second at the bottom of the screen). So they make the request simultaneously.</p>

<p>Is there a way the service only sent one request.</p>

<p>And BTW, the first request has a status of 200 and the second 304.</p>

<p>Thanks.</p>

<h2><strong>UPDATE</strong></h2>

<p><strong>Possible solution</strong></p>

<p>So far I managed by adding a Service variable</p>

<pre><code>private _observable: Observable&lt;DataModel&gt;;
</code></pre>

<p>Then when getting the data</p>

<pre><code>getData(): Observable&lt;DataModel&gt; {
    if (!this._observable) {
        this._observable = this._http.get&lt;DataResponse&gt;('/some-route').pipe(
          map((response: DataResponse) =&gt; this.handleResponse(response)),
          // HERE IS THE TRICK
          publishLast(),
          refCount()
        )
    }

    return this_observable;
}
</code></pre>

<p>The trick is using publishLast and refCount</p>

<p>Any better way/idea ?</p>
","4926588","","4926588","","2019-04-26 01:10:49","2019-04-26 06:22:01","Angular7 + RxJs Multiple Subscribers to Same Observable","<angular><rxjs><angular7><rxjs6>","4","1","","","","CC BY-SA 4.0"
"55860117","1","","","2019-04-26 02:45:53","","0","120","<p>I want to hide this HTTP error when I sign in with incorrect credentials
Here is my effect and can I handle an error message by myself ?</p>
<pre><code>@Effect()
   authSignin = this.actions$.pipe(
     ofType(AuthActions.TRY_SIGNIN),
     tap(() =&gt; console.log(&quot;signin effect&quot;)),
     map((action: AuthActions.TrySignup) =&gt; {
       return action.payload;
     }),
 switchMap((authData: { username: string; password: string }) =&gt; {
  return from(
    firebase
      .auth()
      .signInWithEmailAndPassword(authData.username, authData.password)
  ).pipe(
    switchMap(() =&gt; {
      return from(firebase.auth().currentUser.getIdToken());
    }),
    mergeMap((token: string) =&gt; {
      this.router.navigate([&quot;/&quot;]);
      return [
        {
          type: AuthActions.SIGNIN
        },
        {
          type: AuthActions.SET_TOKEN,
          payload: token
        }
      ];
    }),
    catchError(error =&gt;
      Observable.of(new AuthActions.AuthError(error.message))
    )
  );
}),
catchError(error =&gt; Observable.of(new AuthActions.AuthError(error.message)))
  );
</code></pre>
<p><a href=""https://i.stack.imgur.com/KDc8r.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KDc8r.png"" alt=""Console display an error"" /></a>
Console display an error</p>
","9211363","","-1","","2020-06-20 09:12:55","2019-04-26 02:45:53","How to hide HTTP error 400 Ngrx + Firebase","<angular><ngrx><rxjs6><ngrx-store><ngrx-effects>","0","2","","","","CC BY-SA 4.0"
"55875801","1","55875865","","2019-04-26 22:54:43","","0","149","<p>I'm trying to resolve after an async call to the websql api.
For now I'm returning a Promise and it's working. however, for some reasons of design,I would like to do it with rxjs6 observables.
Do you know how to have the same behavior with rxjs ?</p>

<p>Please take in account that <code>tx.executeSql</code> and <code>websqlDatabase.transaction</code> return void and I don't have access to the code of these functions.</p>

<p>Thanks in advance</p>

<pre class=""lang-js prettyprint-override""><code>    return new Promise((resolve, reject) =&gt; {
        this.websqlDatabase.transaction(tx =&gt; {
          tx.executeSql(statement, params, (transaction, results) =&gt; {
            resolve(results);
          }, (transaction, error) =&gt; {
            reject(error);
          });
        });
    });
</code></pre>
","4455028","","","","","2019-04-26 23:06:49","What is an equivalent in rxjs6 of Promise.resolve","<observable><es6-promise><web-sql><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55876625","1","","","2019-04-27 01:55:57","","0","88","<p>how i can get single item at a time (concatMerge) and delay it from result of group.pipe(toArray()). i want each item coming out of group array with delay inside that group item.</p>

<pre><code>const people = [
  { name: 'Sue', age: 25 },
  { name: 'Joe', age: 30 },
  { name: 'Frank', age: 25 },
  { name: 'Sarah', age: 35 }
];

from(people).pipe(
  groupBy(person =&gt; person.age, p =&gt; p.name),
  mergeMap(group =&gt; zip(of(group.key), group.pipe(toArray())))
).subscribe(console.log);
</code></pre>
","6069595","","6069595","","2019-04-27 16:31:05","2019-04-27 16:31:05","How to delay in result of group by","<rxjs><rxjs5><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"55887042","1","","","2019-04-28 04:31:40","","2","1737","<p>I am trying to implement login in @angular/core 7.1.0 and @ngrx/store 7.0. Now problem is when I dispatch a new Login action from my login component, it is correctly listen in Login effect, but even on dispatching new LoginSuccess action, the login action stuck in endless loop until the LoginFailure action occured.(When i stop the backend service).</p>

<p><strong>auth.effects.ts</strong></p>

<pre class=""lang-js prettyprint-override""><code>  @Effect()
  login$: Observable&lt;Action&gt; = this.actions$.pipe(
    ofType(AuthActionTypes.LOGIN),
    map((action: Login) =&gt; action.payload),
    switchMap(payload =&gt; {
      console.log('SwitchMap: Login [Effect]: payload', payload);
      return this.authService.login(payload.email, payload.password).pipe(
        map((loginResponse: LoginResponse) =&gt; {
          console.log('loginResponse:', loginResponse);
          return new LoginSuccess(loginResponse);
        }),
        catchError(error =&gt; {
          console.log(error);
          return of(new LoginFailure({ error: error }));
        })
      );
    })
  );


  @Effect({ dispatch: false })
  loginSuccess: Observable&lt;any&gt; = this.actions$.pipe(
    ofType(AuthActionTypes.LOGIN_SUCCESS),
    map((action: LoginSuccess) =&gt; action.payload),
    tap((loginResponse: LoginResponse) =&gt; {
      console.log('Login_Success [Effect]: payload', loginResponse);
      localStorage.setItem('accessToken', loginResponse.accessToken);
      localStorage.setItem('refreshToken', loginResponse.refreshToken);
      localStorage.setItem('user', JSON.stringify(loginResponse.user));
      // if (loginResponse.user.isSuperAdmin) {
      //   this.router.navigate(['/admin/dashboard']);
      // } else {
      //   this.router.navigate(['/dashboard']);
      // }
    })
  );
</code></pre>

<p><strong>login.component.ts</strong></p>

<pre><code>onSubmit() {
    // Will triggered only when form is submitted
    if (this.loginForm.valid) {
      console.log('Form Submitted: values', this.loginPayload);
      this.store.dispatch(new Login({ email: this.loginPayload.username, password: this.loginPayload.password }));
      this.loginForm.resetForm();
    }
  }
</code></pre>

<p><a href=""https://i.stack.imgur.com/vbDFC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vbDFC.png"" alt=""enter image description here""></a></p>

<p><strong>Edit: New Finding</strong>
When I am returning a http call (from authService) observable like:</p>

<pre><code>return this.http.put&lt;LoginResponse&gt;('/api/v1/entrance/login', body);
</code></pre>

<p>this bug is happening (i.e request get stuck in endless loop). But when I am faking the api by retunring new observable like below then it is not.</p>

<pre class=""lang-js prettyprint-override""><code>   return new Observable&lt;LoginResponse&gt;((observer) =&gt; {
      if (email === 'superadmin@xyz.com' &amp;&amp; password === 'abc123') {
        const data: LoginResponse = {
          accessToken: 'dadsfjhsjdahlfjh#324jk34h23343kkjlsadsads',
          refreshToken: 'jfjsdg-32432-sdf4543-sdff4234-3424-3434',
          user: {
            email: 'superadmin@xyz.com',
            name: 'Superadmin',
            isSuperAdmin: true,
            id: 1,
            isLdapUser: false,
            isAdUser: false,
            lastSeenAt: new Date().getTime()
          }
        };
        observer.next(data);
      } else {
        observer.error({ error: 'invalid credentials.' });
      }
      observer.complete();
    });
</code></pre>
","4654795","","4654795","","2019-04-28 19:08:31","2019-05-01 07:57:42","NGRX 7 - Stuck in endless loop even on dispatching new action of different type in ngrx/effects","<angular><rxjs><rxjs6><ngrx-store><ngrx-effects>","2","0","0","","","CC BY-SA 4.0"
"55916483","1","","","2019-04-30 08:08:34","","0","124","<p>I want to create an Observable-based poller that waits a certain amount of time between the previous request returning and the next request going out.</p>

<p>Here's the code I tried, but this sets a delay between requests going out:</p>

<pre><code>import {timer} from ""rxjs"";

    this.timer = timer(1, POLLING_INTERVAL)
     .pipe(concatMap(
        (_) =&gt; getData()
      )).subscribe((data) =&gt; {
        // do something with data     
      });

</code></pre>
","2693475","","","","","2019-04-30 08:43:02","Observable - set constant delay between one poll return and another poll start","<rxjs><rxjs6>","2","1","","","","CC BY-SA 4.0"
"55950670","1","55955304","","2019-05-02 10:42:28","","3","114","<p>I have a call to a service, that potentially returns to me a queue URL, if the server is to busy to handle the response.</p>

<p>I'm writing a service in angular, to handle these types of calls, and i'm struggling to figure out what kind of <code>RXJS 6+</code> operator to handle this for me.</p>

<p>This means that i want to make a fallback, that if the response returns to me a queuing URL, i will subscribe to this call, and retry it until i get an answer.</p>

<p>The wait time can be up to 30 seconds (<code>&lt; insert frustrations here&gt;</code>).</p>

<p>From what i can tell from the rxjs documentation page, i need to use the <code>concatMap</code> operator, and somehow <code>retry</code> the call until i get the correct response? Maybe with some <code>delay</code> operators to restrict the amount of calls?</p>

<p>I found this <a href=""https://stackblitz.com/edit/typescript-ec6wed?embed=1&amp;file=index.ts"" rel=""nofollow noreferrer"">snippet</a> from <a href=""https://www.learnrxjs.io/"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/</a>.</p>

<p>Thanks in advance!</p>
","7936022","","","","","2019-05-02 15:41:29","How do i handle sub sequential URL calls in RxJS that pass data to each other?","<angular><rxjs><angular7><angular-httpclient><rxjs6>","2","1","","","","CC BY-SA 4.0"
"55953746","1","55954528","","2019-05-02 13:38:08","","0","323","<p>I see in Rxjs tests sometimes <code>TestScheduler</code> and sometimes <code>VirtualTimeScheduler</code>. 
Could you explain what's the difference and where should I use what?</p>

<pre class=""lang-js prettyprint-override""><code>declare const rxTestScheduler: TestScheduler;
const scheduler = new VirtualTimeScheduler();
</code></pre>
","274500","","","","","2019-05-02 14:22:54","What's the difference between VirtualTimeScheduler and TestScheduler?","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"55959745","1","55975684","","2019-05-02 20:24:05","","0","679","<p>I am using redux-observable with rxjs's tap operator to initialize an ipcRenderer event. Before of that I want to dispatch another action. The question is how to proper pass the payload to the tap operator? -</p>

<p>Note: I want to keep the tap operator at the end of sequence</p>

<p>I have tried to pass it in the action's payload but It is not what I want.. check the example</p>

<pre><code>import { ipcRenderer } from 'electron';
import { map, tap, ignoreElements } from 'rxjs/operators';
import { ofType } from 'redux-observable';
import { pipe } from 'rxjs';

import { togglePackageLoader } from 'models/ui/actions'
import { viewPackageStart} from '../actions';

// I want to pass payload to tap
/* togglePackageLoader returns {  
  type: 'TOGGLE_LOADER',
  payload: {
    loading: true,
    options: {
      opt1: value1,
    }
  }
}

// i want to avoid passing options to toggleLoader payload..
*/
const viewPackageEpic = pipe(
    ofType(viewPackageStart.type),
    map(({ payload }) =&gt; togglePackageLoader({
        loading: true,
        options: payload
    })),
    tap(({ payload: { options } }) =&gt; {
        ipcRenderer.send('npm-view', options)
    }),
    ignoreElements()
);

export { viewPackageEpic };
</code></pre>

<p>I expected to dispatch toggleLoader first then make the ipcRenderer call</p>
","5252752","","5252752","","2019-05-02 20:36:40","2019-05-03 21:28:55","How to pass payload of an action to another rxjs operator in redux-observable?","<electron><rxjs6><redux-observable>","1","0","","","","CC BY-SA 4.0"
"55978553","1","55978940","","2019-05-04 00:42:55","","3","746","<p>I want to have an observable that when unsubscribed it calls a function but only when it is unsubscribed without error and without getting to complete. The observable I am trying to build usually gets raced with another observable. I want when the other observable ""wins"" this one executes a function.  </p>

<p>I tried finalize operator but it executes always. </p>

<p>playback.ts</p>

<pre><code>import { timer } from ""rxjs"";
import { takeUntil, finalize } from ""rxjs/operators"";
import errorobs$ from ""./errorobs"";

export default function() {
  return timer(10000).pipe(
    takeUntil(errorobs$),
    finalize(finalFunc)
  );
}

function finalFunc() {
  console.log(""final function executed"");
}
</code></pre>

<p>errorobs.ts</p>

<pre><code>import { fromEvent } from ""rxjs"";
import { map } from ""rxjs/operators"";

export default fromEvent(document.getElementById(""errorBtn""), ""click"").pipe(
  map(() =&gt; {
    throw new Error(""my error"");
  })
);

</code></pre>

<p>I have made a small demo here <a href=""https://codesandbox.io/s/q7pwowm4l6"" rel=""nofollow noreferrer"">https://codesandbox.io/s/q7pwowm4l6</a></p>

<p>click start to start ""the observable"".</p>

<p>click cancel to make the other observable win </p>

<p>click error to generate an error</p>
","2112047","","","","","2019-05-04 06:40:51","Execute function on observable cancellation","<javascript><rxjs><rxjs6>","2","1","","","","CC BY-SA 4.0"
"55982956","1","","","2019-05-04 13:22:24","","0","56","<p><strong>Goal</strong>: User moves the slider, and the slider value is sent to the server to calculate some value X, displayed next to the slider and updated gradually as slider value changes.</p>

<p><strong>What I did</strong>: used throttled Subject, <code>switchMap</code>'ped to fetch the value:</p>

<pre><code>sliderMoved$.pipe(
    throttleTime(200),
    switchMap(sliderVal =&gt; server.calculateX(sliderVal)
)
</code></pre>

<p>It does the job, but</p>

<p><strong>The Problem</strong>: if server responds longer than throttle time, the switchMap operator cancels the previos call. Thus slow movement of the slider results in sequence of cancelled requests, and value gets updated only when user stops sliding.</p>

<p><strong>Needed Improvement:</strong> for every server call I need to wait until the response comes, update the displayed value X, and then fire the new call with the latest value of the slider. If user stopped sliding when there was a pending request, a last one request with latest slider value has to be made.</p>

<p>(or if you have better idea how it should work)</p>
","1457181","","1457181","","2019-05-04 14:05:14","2019-05-04 14:05:14","rxjs: gradually fetch value as user moves slider, sending new requests after previous completed","<javascript><rxjs><rxjs6><switchmap>","0","5","","","","CC BY-SA 4.0"
"55986843","1","55988275","","2019-05-04 21:12:57","","0","118","<p>I'm working on a username search input that fires after a debounceTime(). I also filter out values. I want to trigger some side effects if values are filtered (such as setting an error message and stopping loaders).</p>

<p>I'm achieving this right now by using tap() and checking the same predicate that I later check in a filter() function. I feel this is bad/there is a more proper way to achieve this.</p>

<pre><code>private setUserSearchObservable() {
    this.userSearch = userSearch$.pipe(
      tap(() =&gt; this.loading = true),
      debounceTime(500),
      this.filterValuesWithErrorMessages(),
      ......
    );
}

private filterValuesWithErrorMessages() {
    return pipe(
      tap((val: string) =&gt; { if (this.usernamesMatch(val)) { this.errorMessage = 'You will be added to the frame automatically'; this.loading = false; }}),
      tap((val: string) =&gt; { if (this.usernameInArray(val)) { this.errorMessage = 'User is already added'; this.loading = false; }}),
      tap((val: string) =&gt; { if (val.length &lt; 2) { this.errorMessage = ''; this.loading = false; }}),
      filter((val: string) =&gt; (val.length &gt;= 2 &amp;&amp; !this.usernamesMatch(val) &amp;&amp; !this.usernameInArray(val))),
    );
}
</code></pre>

<p>As you can see, I explicitly check the exact same conditionals using tap() right before using them on filter(). Is there an operator/different pattern that will allow me to achieve this in a more concise way?</p>
","7892913","","","","","2019-05-05 02:06:43","Triggering side effects when a value is filtered using filter() operator","<rxjs><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"56036838","1","","","2019-05-08 08:46:44","","5","4101","<p>I need data from two sources to combine into one <code>res: {data1: any, data2: any}</code> object, and I need to achieve this <strong>even if one of the sources doesn't emit any values</strong></p>

<p>Here's the structure I expect:</p>

<pre><code>xxx (
    source1,
    source2,
    (data1, data2) =&gt; ({data1: data1, data2: data2})
).subscribe(res =&gt; {
    doSomething1(res.data1)
    doSomething2(res.data2)
})
</code></pre>

<p>Is there any rxjs operators that can do this?</p>

<p>currently I can solve this with combination of <code>startWith</code> and <code>combineLatest</code>- I emit null value so <code>combineLatest</code> can start emitting values - any better way to solve this without <code>startWith(null)</code>?</p>

<pre><code>combineLatest (
    source1.pipe(startWith(null)),
    source2.pipe(startWith(null)),
    (data1, data2) =&gt; ({data1: data1, data2: data2})
).subscribe(res =&gt; {
    if(res.data1) {
        doSomething1(res.data1)
    }
    if(res.data2) {
        doSomething2(res.data2)
    }
})
</code></pre>
","1665293","","1665293","","2019-05-08 08:52:43","2021-04-18 16:22:48","RxJS combineLatest even if one of the sources is not emitting values","<angular><rxjs><rxjs6>","3","3","1","","","CC BY-SA 4.0"
"56046188","1","56046389","","2019-05-08 17:31:08","","1","233","<p>I'm learning about the official angular tutorial (<a href=""https://angular.io/tutorial/toh-pt4"" rel=""nofollow noreferrer"">https://angular.io/tutorial/toh-pt4</a>). Excuse me for my low level :(</p>

<p>I'm trying to modify a service that returns the list of heroes ... As observables objects of rxjs, because it is the most efficient way to do it</p>

<pre><code>hero.service.ts
==============

import {Injectable} from '@ angular / core';

import {Observable, of} from 'rxjs';

import {Hero} from './hero';
import {HEROES} from './mock-heroes';
import {MessageService} from './message.service';

@Injectable ({
  providedIn: 'root',
})
export class HeroService {

  constructor (private messageService: MessageService) {}

  getHeroes (): Observable &lt;Hero []&gt; {
    // TODO: send the message _after_ fetching the heroes
    this.messageService.add ('HeroService: fetched heroes');
    return of (HEROES);
  }
}

mock-heroes
===========

import {Hero} from './hero';

export const HEROES: Hero [] = [
  {id: 11, name: 'Mr. Nice '},
  {id: 12, name: 'Narco'},
  {id: 13, name: 'Bombast'},
  {id: 14, name: 'Celeritas'},
  {id: 15, name: 'Magneta'},
  {id: 16, name: 'RubberMan'},
  {id: 17, name: 'Dynama'},
  {id: 18, name: 'Dr IQ'},
  {id: 19, name: 'Magma'},
  {id: 20, name: 'Tornado'}
];
</code></pre>

<p>I want to have a service that returns only a hero when I pass an id</p>

<pre><code>import {Injectable} from '@ angular / core';
import {Hero} from './hero';
import {HEROES} from './mock-heroes';
import {Observable, of} from 'rxjs';
import {MessageService} from './message.service';
import {map} from 'rxjs / operators';

@Injectable ({
  providedIn: 'root'
})
export class HeroService {

  private heroes: Observable &lt;Hero []&gt;;

  getHeroes (): Observable &lt;Hero []&gt; {
    this.messageService.add ('HeroService: fetched heroes');
    // return of (HEROES);
    this.heroes = of (HEROES);
    return this.heroes;
  }

  getHeroeById (id: number): Observable &lt;Hero&gt; {
    this.messageService.add ('A hero is queried with id' + id);
    

    return this.heroes.pipe (map (x =&gt; x.id === id));
  }

  constructor (private messageService: MessageService) {}

 / * getHeroes (): Hero [] {
    return HEROES;
  } * /

  //builder() { }
}
</code></pre>

<p>ERROR in src / app / hero.service.ts (26,5): error TS2322: Type 'Observable ' is not assignable to type 'Observable '.
  Type 'boolean' is not assignable to type 'Hero'.
src / app / hero.service.ts (26.40): TS2339 error: Property 'id' does not exist on type 'Hero []'.</p>

<p>Can you help me ?</p>
","1358518","","1358518","","2019-05-09 08:23:19","2019-05-09 08:23:19","filtering an array of observables efficiently","<angular><rxjs><rxjs6>","3","0","","","","CC BY-SA 4.0"
"56052824","1","","","2019-05-09 05:36:47","","1","241","<p>I'm trying to pull the last emitted value from an observable. But rxJS have two operator <a href=""https://rxjs.dev/api/operators/last"" rel=""nofollow noreferrer"">last()</a>  and <a href=""https://rxjs.dev/api/operators/publishLast"" rel=""nofollow noreferrer"">publishLast()</a>.</p>

<p>What is the difference between last and publishLast operator in rxJS?</p>
","1116399","","","","","2019-05-09 08:15:30","What is the difference between last and publishLast operator in rxJS?","<rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"56052960","1","","","2019-05-09 05:51:49","","1","88","<p>I have a network call where it's likely that api will throw an 400 error. I want to handle this gracefully.</p>

<p>Right now I do it like below - </p>

<pre><code>   private fetchStatus(objectId: string): Observable&lt;string&gt; {
      return Observable.create((observer) =&gt; {
        this.http.get('/api/data-one').subscribe(response =&gt; {
          if (response.result === 'SUCCESS') {
              observer.next('SUCCESS');
          } else {
              observer.next('DENIED');
          }
          observer.complete();
        },
        error =&gt; {
          observer.next('DENIED');
          observer.complete();
        });
      });
  }
</code></pre>

<p><strong>But I will prefer doing it with Observable.map operator.</strong> The problem with Observable.map is when api throws a 400 the entire observable goes in error mode. </p>

<p>I want to prevent this because this get call is being used in a forkJoin with other calls. Failure of this would mean failure of the entire forkJoin below</p>

<pre><code>forkJoin([
        this.http.get('/api/route-2'),
        this.http.get('/api/route-1'),
        this.fetchStatus('abc')
      ]).subscribe((responseCollection: any) =&gt; {
        observer.next({
          result1: responseCollection[0],
          result2: responseCollection[1],
          result3: responseCollection[2]
        });
        observer.complete();
      }, error =&gt; observer.error(error));
</code></pre>
","1078923","","","","","2019-05-09 06:14:53","RxJS do not throw error while mapping even when underlying observable throws error","<rxjs><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"56058891","1","","","2019-05-09 11:55:50","","3","1540","<p>I have a case, where i have to fire 2 GET Requests at the same time:</p>

<ol>
<li>First one of them is <strong>mandatory</strong>. I have to wait for response, and if some error pops up, i have an exception handling, and i also can already cancel my 2. request.</li>
<li>Second one is <strong>optional</strong>. In case of error, i can ignore the case. And i want to wait for max. 5 seconds ""more"" for this call, if it takes longer i want to cancel the request (i know i cant cancel the fired request but simply ignore the returned value/or returned error). So, if the 1. call may need 20sec. the 2. call may wait max. 25sec. If the 1. call needs just 1sec. the 2. call cannot wait more than 6 sec. etc.</li>
</ol>

<p>How can i implement this with rxjs?</p>

<p>I know i can zip multiple requests, but all the examples i have seen so far had just 1 error handling block, but here i need to differentiate between two error cases.</p>

<p>Thanks in advance</p>
","2224454","","","","","2020-07-22 10:25:11","RxJS: How to fire 2 parallel requests, one of which is optional, with a timeout","<angular><rxjs><rxjs6>","2","1","","","","CC BY-SA 4.0"
"56083837","1","56084345","","2019-05-10 19:33:50","","2","97","<p>I am thinking I might have made a fundamental mistake when typing out our endpoints.</p>

<p><a href=""https://www.learnrxjs.io/operators/transformation/map.html"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/operators/transformation/map.html</a>
Shows examples of an array of objects that seem to work fine with the operators in their examples.</p>

<pre><code>  this.taskService.getResponsibleParties().pipe(
        takeUntil(this.onDestroy$),
        map(({responPartyDesc}) =&gt; responPartyDesc)
    ).subscribe(responsibleParties =&gt; {
        this.responsableParties = responsibleParties;
    });
</code></pre>

<p>getResponsibleParties is defined with a return value below</p>

<pre><code>    getResponsibleParties(): Observable&lt;Array&lt;ResponsibleParty&gt;&gt;
</code></pre>

<p>Most items that come back from the backend will be an Array of some type interface. Why in this example does Rxjs yells about </p>

<pre><code>     map(({responPartyDesc}) =&gt; responPartyDesc)
</code></pre>

<p>ResponsibleParty[] has no property 'responPartyDesc'</p>

<p>Isn't this exactly the same thing that the docs lays out as working?</p>
","8479878","","8479878","","2019-05-10 23:35:57","2019-05-10 23:35:57","Why does rxjs complain about items defined as Type[] when it comes to operators?","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"56089472","1","","","2019-05-11 10:34:03","","2","108","<p>My component displays a selected building detail plus a list of building units (apartments) of the building. This is a component html:</p>

<pre class=""lang-html prettyprint-override""><code>    &lt;div *ngIf=""$building | async as building""&gt;
      ...
      &lt;div *ngIf=""$buildingUnits | async as buildingUnits""&gt;
        ...
      &lt;/div&gt;
    &lt;/div&gt;
</code></pre>

<p>This is a component controller:</p>

<pre class=""lang-js prettyprint-override""><code>    @Component({
      selector: 'building-dashboard',
      templateUrl: './building-dashboard.component.html',
      styleUrls: ['./building-dashboard.component.scss']
    })
    export class BuildingDashboardComponent implements OnInit {
      private buildingId: number;
      private $building: Observable&lt;Building&gt;;
      private $buildingUnits: Observable&lt;BuildingUnit[]&gt;;

      ngOnInit() {
        this.$building = this.route.paramMap.pipe(
          tap((params: ParamMap) =&gt; {
            this.buildingId = Number(params.get('id'));
          }),
          switchMap((params: ParamMap) =&gt; {
            return this.buildingService.getBuilding(this.buildingId);
          })
        );

        this.$buildingUnits = this.route.paramMap.pipe(
          switchMap((params: ParamMap) =&gt; {
            let buildingId = Number(params.get('id'));
            return this.buildingUnitsService.getBuildingUnits(buildingId);
          })
        );
      }

      reloadBuildingUnits() {
        this.$buildingUnits = this.buildingUnitsService.getBuildingUnits(this.buildingId);
      }
    }
</code></pre>

<p>ID of building is obtained from route parameters. When the ID of building changes I need to reload building details and a list of buildingUnits. There's a method <strong>reloadBuildingUnits()</strong> that can be activated by user by a button click. In such case I need to reload a list of buildingUnits and cancel the previous http request if it hasn't finished yet. I don't know how to do that. May be I should subscribe and then unsubscribe in the controller instead of using async? May be it would be better to use promise instead of observable? I'm new to Angular, I'll be thankful for any advices for improvements. I'm using Angular 7.2.0 and rxjs 6.3.3.</p>
","1071282","","9662601","","2019-05-12 12:55:56","2019-05-13 03:48:04","Cancel previous http request and run the new one using async","<angular><rxjs><angular7><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"56096450","1","56103956","","2019-05-12 05:28:22","","0","200","<p>So, let's say, I have an Observable which is created from a huge ordered array with the timestamp value, and I have another Observable that is created from the event(basically is emitting timestamp four times per second).</p>

<p>Here is the question, HOW can I implement so that with second Observable emits values, first Observable emits all value until reach a value that greater than second Observable's emitted value, then waiting for second Observable keep emitting</p>

<p>Keep it short is one Observable keeping emit until it's greater than another Observable's emitted value.</p>

<pre><code>e.g. : 
  Observable A [1,1.1,1.5,1.7,2,5,7]
  Observable B [1,2,3,4,5,6,7,8]
B emit 1 -&gt; A emit 1, wait
B emit 2 -&gt; A emit 1.1 1.5 1.7 2 wait
B emit 3........
B emit 7 -&gt; A emit 7
B emit 8 -&gt; A over
</code></pre>

<p>plus: B is seekable</p>

<pre><code>e.g. : 
  Observable A [1,1.1,1.5,1.7,2,5,7]
  Observable B [1,2,3,4,5,6,7,8]
B emit 1 -&gt; A emit 1, wait
B emit 2 -&gt; A emit 1.1 1.5 1.7 2 wait
B emit 3........
suddenly B seek to 2
B emit 2 -&gt; A emit the one in A array which closest to 2
then keep moving
B emit 7 -&gt; A emit 7
B emit 8 -&gt; A over
</code></pre>
","8282927","","","","","2019-05-12 22:24:53","How an Observable emits value according to another Observable","<rxjs><reactive-programming><rxjs6>","1","2","","","","CC BY-SA 4.0"
"56106478","1","","","2019-05-13 05:58:43","","0","524","<p>I have array of Observable, Used RxJS forkJoin to capture the results emitted by each of the Observable in the array. But if any of the observable fails to emit data, the forkJoin emits no data.
So I am trying for similar behavior like forkJoin with error handling. Please do suggest any alternative that can solve the problem described above.</p>

<p>For work around I have created for loop for array of observable and doing error handling for each of Observable subscription. however with help of Arrow function i am able to preserve the order of the result emitted by each observable. </p>

<pre><code>// Sample code block
const arrayOfObservable = [t,t,t,t,t];

arrayOfObservable.forEach((item, index) =&gt; {
    item.subscribe((result) =&gt; {
         // Success
    },
    (error) =&gt; {
         // Error
    },
    () =&gt; {
         // Completed
    });
});

</code></pre>
","4427551","","4427551","","2019-05-13 06:24:53","2019-05-13 07:14:00","How to do error handling when we want array of observable to be subscribed","<javascript><angular6><observable><subscription><rxjs6>","1","4","","","","CC BY-SA 4.0"
"56113773","1","","","2019-05-13 13:48:28","","2","1122","<p>I have this logic:</p>

<pre><code>  public setXXXInLocalStorage(): Observable&lt;boolean&gt; {

    return this.appConfig.getEndpoint('xxx')
      .pipe(
        switchMap((endpoint: Endpoint) =&gt; this.http.get(endpoint.toUrl(), {headers})),
        map((body: any) =&gt; { localStorage.setItem('myItem', body.item); }),
        timeout(5000),
        map(() =&gt; true),
        catchError(() =&gt; of(true))
      );
  }
</code></pre>

<p>What i wanted to achieve is, that i want to wait for max. 5 seconds for my get request.</p>

<ul>
<li>switchmap: calls my endpoint</li>
<li>map: deals with the answer</li>
<li>timeout: i tried to define max. 5 sec. for this call</li>
<li>map: if success, we should do nothing but just return true</li>
<li>catchError: if any error occurs from the request, or timeout occurs, we can also simply ignore the error and simply return true</li>
</ul>

<p>What is now happening is: timeout waits always 5 seconds, even when my get request returns success in 1 sec.</p>

<p>Thanks in advance..</p>
","2224454","","2224454","","2019-05-13 14:01:45","2019-05-14 12:04:03","RxJS: How to define a (maximum) duration for an (optional) request?","<angular><rxjs><rxjs6>","2","4","1","","","CC BY-SA 4.0"
"56116454","1","","","2019-05-13 16:31:25","","1","318","<p>I had the following function:</p>

<p><strong><em>Original Function</em></strong></p>

<pre><code>public FindCertType(CertTypeID: string) : Observable&lt;ICertType&gt; {
    console.log(""... FindCertType in Model-tools.service called ..."");
    return this.GetCertTypes()
      .pipe(
        map((CertTypeMap: IResponseObject&lt;ICertType&gt;) =&gt; {
          return CertTypeMap.Array
        }),
        filter((CertType: ICertType ) =&gt; CertType.Id === CertTypeID)[0]
      )
  }
</code></pre>

<p>This code resulted in the following error:</p>

<p><strong><em>Console Error</em></strong></p>

<pre><code>... ShowCertType called ...                           new-bcaba.component.ts:27 
... GetCertType in Certification Component called ... certification.component.ts:49
... FindCertType in Model-tools.service called ...                  model-tools.service.ts:53
... GetCertTypes in Model-tools.service called ...                  model-tools.service.ts:48

ERROR TypeError: fn is not a function                  NewBcabaComponent.html:3
    at pipe.js:18
    at Array.reduce (&lt;anonymous&gt;)
    at piped (pipe.js:18)
    at Observable.push../node_modules/rxjs/_esm5/internal/Observable.js.Observable.pipe (Observable.js:91)
    at ModelToolsService.push../src/app/_services/model-tools.service.ts.ModelToolsService.FindCertType (model-tools.service.ts:55)
    at NewBcabaComponent.push../src/app/certification/certification.component.ts.CertificationComponent.GetCertType (certification.component.ts:50)
    at NewBcabaComponent.get [as BaseCertType$] (certification.component.ts:54)
    at NewBcabaComponent.push../src/app/certification/application/new-bcaba/new-bcaba.component.ts.NewBcabaComponent.ShowCertType (new-bcaba.component.ts:28)
    at NewBcabaComponent.get [as ParentCertType$] (new-bcaba.component.ts:37)
    at Object.eval [as updateDirectives] (NewBcabaComponent.html:3)
</code></pre>

<p>When I modified the function to put the filter inline with the map the error went away and it started working as I expected.</p>

<p><strong><em>Modified Function</em></strong></p>

<pre><code>public FindCertType(CertTypeID: string) : Observable&lt;ICertType&gt; {
    console.log(""... FindCertType in Model-tools.service called ..."");
    return this.GetCertTypes()
      .pipe(
        map((CertTypeMap: IResponseObject&lt;ICertType&gt;) =&gt; {
          return CertTypeMap.Array.filter(CertType =&gt; CertType.Id === CertTypeID)[0];
        })
      )
  }
</code></pre>

<p>While my problem was solved with the modification I don't understand why this works but the first version doesn't.  I was importing the ""filter"" and ""map"" operators from 'rxjs/operators' for the original code and as I understand the operators inside pipe should work on the returning observable from the previous operator so filter should work on the return of map.  Can anyone explain why that doesn't work?</p>
","11120405","","","","","2019-05-13 16:31:25","Should the Rxjs 6 filter operator work on the return from a map operator?","<angular><rxjs6>","0","5","","","","CC BY-SA 4.0"
"56126246","1","56148083","","2019-05-14 08:38:21","","4","390","<p>The main goal is process my requests sequentially. I have input for scanning values by scanner in fast order. But sometimes server returns data slowly and if i scanning very fast, server is fell down and returns 500. My idea is process this request sequentially. I tried to find some solutions, but i don't found what i want. I don't know if i should use some interceptor, or save it in service or component.</p>

<p>I tried to find solution in interceptor, but there i don't found out when request is done and interceptor can process next request. I tried to use rxjs operators, but i don;t know how to incorporate to my solution. This is example what i want to in my solution</p>

<pre><code>from([1, 2, 3, 4])
  .pipe(
    concatMap(param =&gt;
      this.http.get(
        `http://localhost:6013/api/v1/test/buffer?data=${param}`
      )
    )
  )
  .subscribe(res =&gt; console.log(res));
</code></pre>

<p>from operator make observable of my requests and ConcatMap process it sequentially</p>

<p>There is my skeleton app</p>

<p>app.component.ts</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { FormBuilder, Validators } from '@angular/forms';
import { Subject } from 'rxjs';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit {
  form = this.fb.group({
    input: ['', Validators.required]
  });

  makeRequest$ = new Subject();
  constructor(private http: HttpClient, private fb: FormBuilder) {}

  onSubmit() {
    this.http
      .get(
        `http://localhost:6013/api/v1/test/buffer?data=${
          this.form.controls.input.value
        }`
      )
      .subscribe(res =&gt; {
        console.log(res);
      });

    this.form.reset();
  }

  ngOnInit() {}
}
</code></pre>

<p>app.interceptor.ts</p>

<pre><code>import { Injectable } from '@angular/core';
import {
  HttpInterceptor,
  HttpRequest,
  HttpHandler,
  HttpEvent
} from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class AppInterceptor implements HttpInterceptor {
  arrayRequest: Array&lt;HttpRequest&lt;any&gt;&gt; = [];

  intercept(
    req: HttpRequest&lt;any&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    return next.handle(req);
  }
}
</code></pre>

<p>app.components.html</p>

<pre><code>&lt;form [formGroup]=""form"" (ngSubmit)=""onSubmit()""&gt;
  &lt;label&gt;
    Data:
    &lt;input type=""text"" formControlName=""input"" /&gt;
  &lt;/label&gt;

  &lt;button type=""submit"" [disabled]=""!form.valid""&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>

<p>I excepted something like code above. ConcatMap process request sequentially, but i don't know how i should work with requests and how direction i should to choice.</p>
","9202425","","","","","2019-05-15 11:17:10","Process request sequentially","<angular><typescript><rxjs6>","2","1","","","","CC BY-SA 4.0"
"56126382","1","56135578","","2019-05-14 08:49:35","","1","79","<p>I have a Firestore collection with a number of jobs but I want to group them by the job number on the client side. I have gone through a lot of examples online like <code>this.jobs = this.afs.collection('jobs').valueChanges().pipe(groupBy((job: any) =&gt; job.jobNumber), mergeMap(group =&gt; group.pipe(toArray())));</code> but no success. What I have is</p>

<p>Job
    - job number 1
    - job number 2
    - job number 3
    - job number 1</p>

<p>But what i want is</p>

<p>Job
    - [job number 1, job number 1]
    - [job number 2]
    - [job number 3]</p>
","204675","","807126","","2019-05-14 14:38:21","2019-05-14 17:22:19","Using .groupBy with Firestore collection data","<rxjs><google-cloud-firestore><rxjs6><angularfire5>","1","0","","","","CC BY-SA 4.0"
"56130194","1","56130752","","2019-05-14 12:12:36","","1","453","<p>Trying to import catchError for rxjs v6.3.3 but import looks not working. I am getting error while using catch.</p>

<p>Found similar questions but looks none helped me. </p>

<p><strong>Code:</strong></p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { IWinServices } from './WinServices';
import { Observable } from 'rxjs';
import { catch } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class WinServicesService {

  private _url : string = './assets/Data/WinServicess.json'
  constructor(private http: HttpClient) { }

  getWinServices() :Observable &lt;IWinServices[]&gt;  {
      return this.http.get&lt;IWinServices[]&gt;(this._url).catch (this.errorHandler);

  }

  errorHandler(error: HttpErrorResponse) {

    return Observable.throw(error.message || ""Server Error"");
  }
}
</code></pre>

<p><strong>Tried Possible solution :</strong> None worked for me</p>

<pre><code>import { catchError } from 'rxjs/operators';
import 'rxjs/add/operator/catch';
import {Observable} from 'rxjs/Rx';
</code></pre>

<p><strong>Error:</strong> </p>

<blockquote>
  <p><code>Property 'catch' does not exist on type Observable&lt;IWinServices[]&gt;'.ts(2339)</code></p>

<pre><code>ERROR in src/app/employee.service.ts(16,52): error TS2339: Property 'catch' does not exist on type 'Observable&lt;IEmployee[]&gt;'
</code></pre>
</blockquote>
","503110","","","","","2019-05-14 12:59:42","rxjs catchError import issue for rxjs@6.3.3","<angular><typescript><visual-studio-code><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"56137518","1","","","2019-05-14 19:38:59","","0","218","<p>I want to place a condition such that I want to ignore the action event if the condition is not met in the nested pipe condition.</p>

<p>If I just return <code>ignoreElements</code> it is causing an error that the return value does not stream.</p>

<pre><code>export const getDataEpic: (action$, state$,
    { apolloClient, services }: { apolloClient: ApolloClient&lt;any&gt;, services: any }) =&gt; any
    = (action$, state$, { apolloClient, services }) =&gt;
        action$.pipe(ofType('TEST)).pipe(map(x =&gt; x))
            .pipe(
                switchMap((action) =&gt;
                    of([true, false, true]))
                        .pipe(
                            map(settings =&gt; ({ action, config: settings})), // true or false
                            switchMap(value=&gt; {
                                if(value.config)
                                  return of([1])
                                } else {
                                   // if condition not met then don't emit anything
                                    return ignoreElements();
                                }
                            }),
                        ),

                ),
                groupBy(value =&gt; value.action.payload.model.resource),
                mergeMap(ngroup =&gt; ngroup

</code></pre>
","1595858","","1595858","","2019-05-16 03:03:20","2019-05-27 04:50:30","How to ignore events in Observable if condition does not match?","<observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"56140700","1","56140747","","2019-05-15 01:38:29","","3","2524","<p>I have create a wrapper for fetch function. Based on the code below, test_3 passed but how come test_1 and test_2 hit success callback instead of error callback? I suspect there is something wrong in the way I use throwError. </p>

<pre><code>import { from, throwError } from 'rxjs'; // version 6.5.2
import { retry, catchError, switchMap } from 'rxjs/operators';

function getBody(response: Response): Promise&lt;any&gt; {
  const headers = response.headers;

  if (headers.has('content-type')) {
    const contentType: string = headers.get('content-type');
    if (contentType.includes('json')) return response.json();
  }
  return response.text();
}

const http = (url) =&gt; 
  from(fetch(new Request(url))
    .pipe(
      retry(3),
      catchError(error =&gt; { // fetch will throw error if page not found.
        console.log('hit catchError')
        return of(new Response(null, { status: 404, statusText: 'Page not found' }));
      }),
      switchMap(async (response: Response) =&gt; {
        console.log('response.ok = ', response.ok);
        return response.ok
          ? getBody(response) // all status &gt;= 200 and &lt; 400 
          : throwError({ 
              status: response.status, 
              statusText: response.statusText, 
              body: await getBody(response) 
            });
      }),
    );

// test_1
http('http://this_url_not_exists.com').subscribe(
  response =&gt; console.log('should not hit this'),
  errorResponse =&gt; console.log('should errorResponse.status = 404'),
);
// test_1 console result:
// hit catchError
// response.ok = false
// should not hit this

// test_2
http('http://this_url_require_authentication.com').subscribe(
  response =&gt; console.log('should not hit this'),
  errorResponse =&gt; console.log('should errorResponse.status = 401'),
);
// test_2 console result:
// response.ok = false
// should not hit this

// test_3
http('http://myurl.com').subscribe(
  response =&gt; console.log('should hit this'),
  errorResponse =&gt; console.log('should not hit this'),
);
// test_3 console result:
// response.ok = true
// should hit this

</code></pre>

<p>Please do not propose me to use rxjs's ajax.</p>
","4971940","","4971940","","2019-05-16 03:40:52","2020-03-06 15:40:10","How to use Rxjs switchMap to throwError","<javascript><browser><rxjs><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"56146420","1","56149201","","2019-05-15 09:51:07","","1","50","<p>I have the following code:</p>

<pre><code>this.type$.pipe(
        filter(val =&gt; !!val), // skip initial undefined value
        take(1), // unsubscribe after geting the first defined value
        map((type) =&gt; {
          this.store.dispatch(new LoadForms(type.schemaUid));
        })
      ).subscribe();
</code></pre>

<p>This is the pattern I use in few places across my app. Is there a way to shorten that by using any smarter RxJS operator? It should take just the value that is defined and immediately unsubscribe then.</p>
","5420497","","","","","2019-05-15 12:18:23","WHat's the best way to take a first defined value from a stream and unsubscribe in RxJS?","<javascript><angular><rxjs><rxjs6>","1","4","","","","CC BY-SA 4.0"
"56152026","1","56174212","","2019-05-15 14:41:39","","2","590","<p>I'm new with <strong>rxjs</strong> and <strong>redux-observable</strong> and I'm facing the following problem: </p>

<p>In an <strong>epic</strong>, I request something but I got a 401 because my current <code>access_token</code> is expired. So I need to get a new one and then retry the request. 
For this I use my stored <code>refresh_token</code>. I've found a solution that seems to work with rxjs verion 5.x and I'm trying to implement it using version 6 but I'm probably missing something and the operation never gets completed:</p>

<p>I make the request, it fails because of 401. Then, I've managed to request the new <code>access_token</code>, I get the new <code>access_token</code> back but that's it, the stream that was listening to recall the source never executes.</p>

<p>I've tried to adapt this: <a href=""https://stackoverflow.com/questions/46481144/rxjs-how-to-retry-after-catching-and-processing-an-error-with-emitting-somethi"">rxjs - How to retry after catching and processing an error with emitting something</a>
which is implemented with version 5.x of rxjs</p>

<p>Here's the epic that I'm writing:</p>

<pre><code>export const fetchItems= (action$: any) =&gt; action$.pipe(
  ofType(ActionTypes.REQUEST_ITEMS),
  switchMap((action: any) =&gt; {
    return request('get', '/items', '', true);
  }),
  map((response: any) =&gt; successResponse(response.data)),
  catchError((error: AxiosError, source: any) =&gt; {
    if (isError401(error) {
      return action$.pipe(
        ofType(ActionTypes.SUCCESS_REFRESH_TOKEN),
        takeUntil(action$.ofType(ActionTypes.FAILURE_REFRESH_TOKEN)),
        take(1),
        mergeMapTo(source),
        merge(
          of(requestRefreshToken())
        )
      );
    } else {
      return failureResponse(error);
    }
  })
);
</code></pre>

<p>I know that I have a few <em>any</em> that should not be there and that I'm not giving much context for you to help me but maybe you can give me a clue on where to look for the problem.</p>

<p>From the link that I've showed before, I'm not using the <code>Observable.defer()</code> part but I guess that's not the problem here. Anyways I also don't know how to implement that part using rxjs 6.</p>

<p>In my redux dev tools I see this actions:</p>

<pre><code>REQUEST_ITEMS
REQUEST_REFRESH_TOKEN (this is the request of a new access_token passing the current refresh_token)
SUCCESS_REFRESH_TOKEN (this means that I've got a new access_token stored)
</code></pre>

<p>after this, I was expecting that the <code>mergeMapTo(source)</code> will fire again
<code>REQUEST_ITEMS</code> (and having a new valid <code>access_token</code> the action can be completed, falling this time into <code>successResponse(response.data)</code>), but it never gets fired.</p>
","2217375","","2217375","","2019-05-16 12:52:50","2019-05-16 18:01:07","Get a new access token and retry action using redux-observable and rxjs 6?","<reactjs><rxjs><rxjs6><redux-observable>","1","0","2","","","CC BY-SA 4.0"
"56167045","1","56181855","","2019-05-16 11:01:48","","1","85","<p>I have service class that simply calls an api. This service class is being consumed in a component. Is there a way for consuming component to know when the subscribe of the service api is complete?</p>

<p>Right now I am sending a callback function from consuming component to service.
The callback function is one of the parameter of subscribe function is what I understand. </p>

<pre><code>class MyService {
constructor(httpClient: HTTPClient){}
fetchDetails (id, callback) {
 this.http.get('my/api/endpoint/url').subscribe(
  response =&gt; {
    // do something with response
  }
  error =&gt; { //do some processing for error}
  () =&gt; callback() // called when subscribe is done
 )
}
}
class MyList {
 constructor(myservice: MyService){}

 getDetails (id) {
  this.myservice.fetchDetails(id, this.detailsFetched);
 }
 detailsFetched () {
  // subscribe complete
  // do some processing like route to a state
 }
}
</code></pre>

<p>This currently works for me but somehow I feel that there must be better way of doing what I want. Since I am newbie to rxjs I am not able to understand how can I achieve it.</p>
","5686684","","","","","2019-05-17 07:43:51","Is it possible to share subscribe event in rxjs6 and angular?","<typescript><angular6><rxjs6>","2","0","","","","CC BY-SA 4.0"
"56175799","1","","","2019-05-16 19:58:45","","1","141","<p>Similar to <a href=""https://stackoverflow.com/questions/39940152/get-first-fulfilled-promise"">Get first fulfilled promise</a> but in RxJS</p>

<p>If I have two promises A and B, only one of which will succeed, how can I get whichever one fulfills successfully? Some of the promises will have rejection as well. Only the successful promise is needed.</p>

<p>I'm looking for something similar to Promise.race, but which will return only the first promise that fulfills. I'm using promises from RxJS6.</p>
","1595858","","1595858","","2019-05-16 20:17:17","2019-05-16 20:17:17","Get first fulfilled promise in RxJS","<rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"56176568","1","56176812","","2019-05-16 21:01:11","","0","130","<p>When my service method's <code>subscribe</code> runs I'm getting back an object instead of the actual class, and I can't figure out why.  I've created a method in my service that returns an actual class based off of the JSON, vs. just the json interface:</p>

<pre class=""lang-js prettyprint-override""><code>getById(id: number): Observable&lt;DetailsForLabAndCaller&gt; {
    return this.http.get&lt;DetailsForLabAndCaller&gt;(`${this.baseUrl}/${id}/new`).pipe(
        tap(x =&gt; DetailsForLabAndCaller.fromJson(x))
    );
}
</code></pre>

<p>And my <code>fromJson</code> method looks like this:</p>

<pre class=""lang-js prettyprint-override""><code>static fromJson(json: any): DetailsForLabAndCaller {
    const ret: DetailsForLabAndCaller = Object.assign(new DetailsForLabAndCaller(), json);

    ret.me = WorkerInfo.fromJson(ret.me);
    ret.lab = Lab.fromJson(ret.lab);

    console.info(`fromJson: has lab type: ${ret.lab instanceof Lab}`);
    console.info(`fromJson: has WorkerInfo type: ${ret.lab.delegate instanceof WorkerInfo}`);
    console.info(`fromJson: returns a DetailsForLabAndCaller: ${ret instanceof DetailsForLabAndCaller}`);

    return ret;
}
</code></pre>

<p>When the service is called I see each of those console messages return <code>true</code>.  However, when I then try and consume that service, I'm just getting an <code>object</code> back, not an actual class object:</p>

<pre class=""lang-js prettyprint-override""><code>this.spaceService.getById(id).subscribe(obj =&gt; {
    console.info(`Call returned a real class: ${obj instanceof DetailsForLabAndCaller}`);
</code></pre>

<p>That console message, which prints after the first three, is saying <code>false</code>.  Why am I just getting a vanilla object back at this point instead of the actual class?</p>
","1455351","","","","","2019-05-16 21:27:01","Angular subscribe loses actual class type","<typescript><rxjs><angular7><rxjs6>","1","3","","","","CC BY-SA 4.0"
"56187641","1","","","2019-05-17 13:40:13","","0","667","<p>I am using angular 7 Multiple FormControl valueChanges subscribe function.</p>

<p>how do I remove or unsubscribe specific FormControl subscribe function.</p>

<pre><code>FormControlsSubscribe(){
  const FormControlsArray = Object.keys(this.FGroup.controls);
     FormControlsArray.map(controlName =&gt; {
     const control = this.FGroup.controls[controlName] as FormControl;
     control.valueChanges.subscribe(change =&gt; {
        console.log(controlName + '&gt;&gt;&gt;' + change);
     });
  });
};



RemoveControl(ControlKey: any) {
  this.FGroup.removeControl(ControlKey);
}
</code></pre>

<p>I expect the removed control unsubscribed;</p>
","8024633","","","","","2019-05-17 15:03:58","how to remove specific subscribe in multiple subscribes list in angular 7 FormGroup valueChanges?","<angular><rxjs><angular-forms><rxjs6>","2","0","","","","CC BY-SA 4.0"
"56188762","1","56236301","","2019-05-17 14:43:50","","0","296","<p>Following several articles and SO posts, I have configured my app to display the page title to be a router data parameter of ""title"":</p>

<pre><code>const routes: Routes = [
  {
    path: '',
    component: BadgesComponent,
    data: {
      title: 'Design System - Badges'
    }
  }
];
</code></pre>

<p>However, some of my routes may not have this parameter added; in that case I want to display a catchall title, like just ""Design System"".  The code I pieced together (below) looks for the data element, but I don't know how to add a fallback to a simple string if the data element is missing.</p>

<p>It's worth noting that the <code>index.html</code> has a <code>title</code> of the default I want, which displayed before I added this code.  After I added the code, it gets overwritten — and <code>http://localhost:8082/#/badges</code> displays as the page title (for example)</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { Router, NavigationEnd, ActivatedRoute } from '@angular/router';
import { Title } from '@angular/platform-browser';

import { map, filter, mergeMap } from 'rxjs/operators';


@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent implements OnInit {

  constructor(
    private router: Router,
    private activatedRoute: ActivatedRoute,
    private titleService: Title
  ) {}

  ngOnInit() {
    this.router.events
      .pipe(
        filter(event =&gt; event instanceof NavigationEnd),
        map(() =&gt; this.activatedRoute),
        map(route =&gt; {
          while (route.firstChild) route = route.firstChild;
          return route;
        }),
        filter(route =&gt; route.outlet === 'primary'),
        mergeMap(route =&gt; route.data)
      )
      .subscribe(event =&gt; this.titleService.setTitle(event['title']));
  }
}
</code></pre>
","187835","","187835","","2019-05-17 15:01:20","2019-05-21 10:28:25","Angular 7 Router: use default title if one not provided in route data","<angular><angular-router><rxjs6>","1","2","","","","CC BY-SA 4.0"
"56215837","1","56216437","","2019-05-20 07:06:36","","18","7907","<p>I just watched a ngConf video of John Papa talking about SubSink as a best practice in order to unsubscribe from obversables.</p>

<p>I was actually using Subscriptions[] then push subscriptions into it then forEach unsubscribe at cmp destroy.</p>

<p>Is their something I missed or is it just a readability improvment to use SubSink ?</p>
","4583018","","","","","2020-05-30 08:11:17","What is the point of using SubSink instead of a Subscriptions array","<typescript><rxjs><observable><rxjs6>","2","0","4","","","CC BY-SA 4.0"
"56227619","1","56230910","","2019-05-20 20:17:21","","1","78","<p>I have an app which displays a table of stats about team members for all teams the current user is a member of.</p>

<ul>
<li>The team list api returns an array of team ids.</li>
<li>The team member list api accepts a team id and returns an array of team member ids.</li>
<li>The stats list api accepts a <em>list</em> of team member ids and returns an array of stats. </li>
</ul>

<p>When the app starts up, I:</p>

<ul>
<li>dispatch an action to fetch the user's list of teams. </li>
<li>when fetching the list of teams succeeds, I want to dispatch an action to fetch the list of team members for each team.</li>
<li>when fetching the team members for each team succeeds, I want to dispatch the stats list action with all the team ids. </li>
</ul>

<p>I'm not having any troubling dispatching a team member list action for each team id I receive, but I can't seem to 'wait for' all the team member list success actions to dispatch the stats actions.</p>

<p>Here's what I'm working with so far:</p>

<pre><code>// actions
const TEAM_LIST = 'TEAM_LIST';
const TEAM_LIST_SUCCESS = 'TEAM_LIST_SUCCESS';
const TEAM_MEMBER_LIST = 'TEAM_MEMBER_LIST';
const TEAM_MEMBER_LIST_SUCCESS = 'TEAM_MEMBER_LIST_SUCCESS';
const STATS_LIST = 'STATS_LIST';
const STATS_LIST_SUCCESS = 'STATS_SUCCESS';

// action creators
const teamList = () =&gt; ({ type: TEAM_LIST });
const teamListSuccess = (teamIds) =&gt; ({ type: TEAM_LIST_SUCCESS, teamIds });
const teamMemberList = (teamId) =&gt; ({ type: TEAM_MEMBER_LIST, teamId });
const teamMemberListSuccess = (teamId, teamMemberIds) =&gt; ({ type: TEAM_MEMBER_LIST_SUCCESS, teamId, teamMemberIds });
const statsList = (teamMemberIds) =&gt; ({ type: STATS_LIST, teamMemberIds });
const statsListSuccess = (stats) =&gt; ({ type: STATS_LIST_SUCCESS, teamMemberIds, stats });

// epic
const fetchAllStats = (action$) =&gt; {
  return action$.ofType(TEAM_LIST_SUCCESS)
    .switchMap((action) =&gt; {
      return concat(
        action.teamIds.map(teamMemberList),
        zip(action$.ofType(TEAM_MEMBER_LIST_SUCCESS)
          .take(action.teamIds.length)
        ).map(statsList)
      )
    });
};
</code></pre>

<p>I'm definitely using the zip/take combination wrong because I'm getting a STATS_LIST action for each TEAM_MEMBER_LIST_SUCCESS action emitted. </p>

<p>How can I modify this to dispatch the statsList action with the result of all team member list success actions?</p>
","1424572","","","","","2019-05-21 04:02:29","How to dispatch and wait for a variable number of actions?","<angular><redux><rxjs><rxjs6><redux-observable>","1","0","","","","CC BY-SA 4.0"
"56236295","1","56239513","","2019-05-21 10:28:09","","1","3810","<p>I want to retry a http request until some data exists up to 10 times with a delay of 2 seconds between each retry.</p>

<pre><code>const $metrics = from(axios(this.getMetrics(session._id, sessionRequest._id, side)));

const res = $metrics.pipe(
  map((val: any) =&gt; {
    console.log(""VALUE:"", val.data.metrics.length);
    if (val.data.metrics.length === 0) {
      throw val;
    }
    return val;
  }),
  retryWhen((errors) =&gt; errors.pipe(delay(2000), take(10))),
).subscribe();
</code></pre>

<p>I am trying to follow the example in the documentation. <a href=""https://www.learnrxjs.io/operators/error_handling/retry.html"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/operators/error_handling/retry.html</a></p>

<ol>
<li>I create <code>$metrics</code> observable from an axios http promise. </li>
<li>I use the map operator to check if the response of the http request matches my condition to retry. <code>val.data.metrics.length === 0</code>. If it does it throws an error.</li>
<li>I retry the http requests up to 10 times with a 10 second delay.</li>
</ol>

<p>I expect after 3-4 retries for this metrics array to have data, but in my console when i log the response i get the following.</p>

<pre><code>VALUE: 0
</code></pre>

<p>Im not sure if this is even making multiple http requests because the console log only returns one output instead of 10.</p>

<p><strong>UPDATE</strong></p>

<p>Ive updated the code to use retryWhen instead of retry, it does a delay of 2 seconds and will only take 10 errors before stopping.</p>

<p>Now i believe the problem is that it only makes 1 http request because the console log only returns a single output.</p>
","1548432","","1548432","","2019-05-21 11:10:07","2021-04-09 12:53:27","How to retry a http request until a condition is met using rxjs","<node.js><rxjs><rxjs6>","1","8","1","","","CC BY-SA 4.0"
"56238325","1","56276641","","2019-05-21 12:29:28","","5","6166","<p>I have some sibling components and a <code>DataService</code> in my <code>Angular</code> (v7) project and I call methods as the following scenario:</p>

<p><code>TicketComponent</code> adds ticket and calls <code>reloadTickets</code> method in <code>TicketListComponent</code> and similarly <code>FileComponent</code> adds file and calls <code>reloadFiles</code> method in <code>FileListComponent</code> via <code>DataService</code> as shown below:</p>

<p><strong><em>DatasService.ts:</em></strong></p>

<pre><code>export class DatasService {

    private eventSubject = new BehaviorSubject&lt;any&gt;(undefined);

    getEventSubject(): BehaviorSubject&lt;any&gt; {
        return this.eventSubject;
    }

    reloadTickets(param: boolean) {
        this.eventSubject.next(param);
    }

    reloadFiles(param: any) {
        this.eventSubject.next(param);
    }
}
</code></pre>

<p><strong><em>TicketComponent:</em></strong></p>

<pre><code>ngOnInit(): void {
    this.dataService.getEventSubject().subscribe((param: any) =&gt; {
        this.reloadTickets();
    });
}
</code></pre>

<p><strong><em>FileComponent:</em></strong></p>

<pre><code>ngOnInit(): void {
    this.dataService.getEventSubject().subscribe((param: any) =&gt; {
        this.reloadFiles();
    });
}
</code></pre>

<p><br/></p>

<p>When I use single <code>BehaviorSubject</code> for these 2 methods, both methods are called at the same time when one of them is called. I mean that <em>As both of them subscribed via getEventSubject() method, reloadTickets() methods also triggers reloadFiles() in the DataService as both of them use the same subject (eventSubject).</em> I know creating another <code>BehaviorSubject</code> and <code>getEventSubject</code> method fix the problem but I am confused if I should do this for all of the independent method calls or if there is a smarter way to fix the problem via using single <code>BehaviorSubject</code> as mentioned below:</p>

<p><a href=""https://stackoverflow.com/questions/51478183/behaviorsubject-subscriber-gets-same-next-element-multiple-times"">BehaviorSubject subscriber gets same next() element multiple times</a></p>

<p>Could you please post a proper usage for this scenario? </p>

<p><strong><em>Update:</em></strong></p>

<p>Finally I have used the following approach in order to call different methods between different components using <strong>a single BehaviorSubject</strong>. </p>

<p><strong><em>EventProxyService:</em></strong></p>

<pre><code>import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

@Injectable()
export class EventProxyService {

    private eventTracker = new BehaviorSubject&lt;any&gt;(undefined);

    getEvent(): BehaviorSubject&lt;any&gt; {
        return this.eventTracker;
    }

    setEvent(param: any): void {
        this.eventTracker.next(param);
    }
}
</code></pre>

<p><strong><em>CommentComponent:</em></strong> Call the method from ListComponent after a comment is added:</p>

<pre><code>import { EventProxyService } from './eventProxy.service';

export class CommentComponent implements OnInit {
    constructor(private eventProxyService: EventProxyService) {}        

    public onSubmit() {
        //...
        this.reloadComment(true);
    }

    reloadComment(param: boolean): void {
        this.eventProxyService.setEvent(param);
    }
}
</code></pre>

<p><strong><em>ListComponent:</em></strong> Triggered via reloadComment() method in CommentComponent :</p>

<pre><code>import { EventProxyService } from './eventProxy.service';

export class ListComponent implements OnInit {

    subscription;

    constructor(private eventProxyService: EventProxyService) {}

    ngOnInit() {
        this.subscription = this.eventProxyService.getEvent().subscribe((param: any) =&gt; {
            this.listComment(param);
        });
    }

    // Multi value observables must manually unsubscribe to prevent memory leaks
    ngOnDestroy(): void {
        this.subscription.unsubscribe();
    }

    listComment(param) {
        //retrieve data from service
    }
}
</code></pre>
","836018","","836018","","2019-05-29 23:03:38","2019-05-29 23:03:38","Should I use multiple BehaviorSubject for different subscriptions?","<angular><typescript><rxjs><rxjs5><rxjs6>","2","7","0","","","CC BY-SA 4.0"
"56241937","1","56256063","","2019-05-21 15:45:17","","0","1597","<p>I want to assign the result of creating SQLite database to variable database of type SQLiteObject for this reason I have to do this in ""then"" block but it shows   </p>

<blockquote>
  <p>error ERROR Error: Uncaught (in promise): TypeError: Cannot read property 'then' of undefined.</p>
</blockquote>

<p>I have tried most of the articles about this error ""ERROR Error: Uncaught (in promise): TypeError: Cannot read property 'then' of undefined""
but none of them is my answer</p>

<pre><code>constructor(public http: Http,
    private sqlitePorter: SQLitePorter,
    private storage: Storage,
    private sqlite: SQLite,
    private plateform: Platform) {
    this.databaseReady = new BehaviorSubject(false);
    this.plateform.ready().then(() =&gt; {
      this.sqlite.create({
        name: 'developers.db',
        location: 'default',
        })
        .then((db: SQLiteObject) =&gt; {
        this.database = db;
        this.storage.get('database_filled').then(val =&gt; {
          if (val) {
            this.databaseReady.next(true);
          } else {
            this.fillDatabase();
          }
        })
      })
    })
  }
</code></pre>

<p><a href=""https://i.stack.imgur.com/03DCw.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/03DCw.jpg"" alt=""This is the actual code""></a></p>

<p><a href=""https://i.stack.imgur.com/Pd8Vy.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Pd8Vy.jpg"" alt=""this is the error""></a></p>
","4884276","","137773","","2019-05-22 11:35:08","2019-05-22 11:41:45","IONIC 4 + Angular7: ERROR Error: Uncaught (in promise): TypeError: Cannot read property 'then' of undefined","<angular><typescript><observable><ionic4><rxjs6>","1","4","","","","CC BY-SA 4.0"
"56251489","1","56251834","","2019-05-22 07:28:56","","11","2447","<p>As expected, the following code emits 42 after 5 seconds:</p>

<pre><code>const valueObservable = of(42).pipe(delay(5000));
valueObservable.subscribe((value) =&gt; console.log(value));
</code></pre>

<p>However, this throwing version errors immediately on subscription:</p>

<pre><code>const throwingObservable = throwError(new Error('My Error')).pipe(delay(5000));
throwingObservable.subscribe((value) =&gt; console.log(value), (error) =&gt; console.error(error));
</code></pre>

<p>Why does this happen? How do I delay the throwing of the error?</p>
","82303","","82303","","2019-05-22 07:34:20","2021-03-12 12:08:03","How to delay throwError with RxJS?","<rxjs><rxjs6>","3","0","3","","","CC BY-SA 4.0"
"56273186","1","","","2019-05-23 10:26:23","","3","2609","<p>I have three observables <code>foo$</code>, <code>bar$</code> and <code>baz$</code> that I merge together to form another observable. This is working as expected:</p>

<ul>
<li>The stream starts with <code>&gt;&gt;&gt;</code></li>
<li>Each value are emitted one by one</li>
<li>The stream ends with <code>&lt;&lt;&lt;</code></li>
</ul>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const foo$ = of('foo');
const bar$ = of('bar');
const baz$ = of('baz');

merge(foo$, bar$, baz$).pipe(startWith('&gt;&gt;&gt;'), endWith('&lt;&lt;&lt;')).subscribe(str =&gt; {
  console.log(str);
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.5.2/rxjs.umd.min.js""&gt;&lt;/script&gt;
&lt;script&gt;const {merge, of} = rxjs; const {startWith, endWith} = rxjs.operators;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Now if none of the three observables above emit a value, I do not want to output neither <code>&gt;&gt;&gt;</code> nor <code>&lt;&lt;&lt;</code>. So <code>startWith</code> and <code>endWith</code> can only ""run"" if <code>merge(foo$, bar$, baz$)</code> actually emits a value.</p>

<p>In order to simulate that I'm rejecting all values emitted by <code>foo$</code>, <code>bar$</code> and <code>baz$</code> with a filtering function.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const foo$ = of('foo').pipe(filter(() =&gt; false));
const bar$ = of('bar').pipe(filter(() =&gt; false));
const baz$ = of('baz').pipe(filter(() =&gt; false));

merge(foo$, bar$, baz$).pipe(startWith('&gt;&gt;&gt;'), endWith('&lt;&lt;&lt;')).subscribe(str =&gt; {
  console.log(str);
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.5.2/rxjs.umd.min.js""&gt;&lt;/script&gt;
&lt;script&gt;const {merge, of} = rxjs; const {startWith, endWith, filter} = rxjs.operators&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>However as you can see in the output, both <code>startWith</code> and <code>endWith</code> have emitted their value even though the <code>merge()</code> hasn't produced any.</p>

<p><strong>Question</strong>: How can I prevent <code>startWith</code> and <code>endWith</code> from executing if the observable did not emit a single value?</p>
","1244884","","1244884","","2019-05-23 11:00:41","2019-06-06 08:47:45","In RxJS, how to prevent operators from emitting values if the source observable hasn't emitted any?","<rxjs><rxjs6>","5","0","","","","CC BY-SA 4.0"
"56281901","1","","","2019-05-23 19:36:30","","1","68","<p>Assume you have the following code:</p>

<pre><code>protected _state = new ReplaySubject&lt;CartState&gt;();

getTransformedState(id: number) {
    return this._state.pipe(map(({ items }) =&gt; items[id]));
}
</code></pre>

<p>And im getting this transformed Observable in another component, and I subscribe to it.</p>

<pre><code>ngOnInit() {
    this.cart.getTransformedState(this.product.id).pipe(takeUntil(this.destroy$)).subscribe((item) =&gt; {})
}
</code></pre>

<p>Diving into Rxjs documentation we can see that transforming one Observable with usage of pipeable operators and then subscribing to the 'outcome' observable also subscribes to 'origin' observable.</p>

<blockquote>
  <p>An Pipeable Operator is essentially a pure function which takes one Observable as input and generates another Observable as output. <b>Subscribing to the output Observable will also subscribe to the input Observable.</b></p>
</blockquote>

<p>My question arise from unit test provided in the project that is failing to complete</p>

<pre><code>it('should have one subscription for product cart item', async(() =&gt; {
    const mockSubject = ServiceMock.getItemUpdates(MockProduct);

    component.ngOnInit();
    fixture.detectChanges();

    expect(mockSubject['observers'].length).toEqual(1);
}));
</code></pre>
","6941058","","","","","2019-05-23 19:36:30","Using pipeable operators and subscribing to only ""inner"" observable","<angular><observable><rxjs6><rxjs-pipeable-operators>","0","2","","","","CC BY-SA 4.0"
"56293362","1","56445601","","2019-05-24 13:09:12","","0","124","<p>Trying to return an Observable from a rxjs6 Websocket Subject call. Having difficulty understanding the asynchronous nature for the subscribe. Code also filters into a returned envelope for extract the Product[].</p>

<p>I understand making a websocket call when the subscriber retrieves the result and routes for a new angular page. </p>

<pre><code>getAllProducts() : Observable&lt;Product[]&gt; {
  let document: GetAllDocument = new GetAllDocument().init();
  let envelope = 
    new AuctionEnvelope().init(AuctionMethods.getAll,document);
  this.ws.subject.next(envelope); // call server
  let result__: Product[] = [];
  this.ws.subject.asObservable().subscribe( (resp: AuctionEnvelope) =&gt; {
    pipe(
      filter((resp)=&gt;resp.method===AuctionMethods.getAllResponse,
      map((resp:AuctionEnvelope) =&gt;resp.getAllResponseDocument.result),
      map((products: Product[]) =&gt; this.result__ = products) 
    );
  }
  );
  return from(this.result__);
}
</code></pre>

<p>I would like to return the result in an asynchronous way so the application can get the result when it's ready with an Observable.</p>
","7425793","","","","","2019-06-04 14:06:28","Returning Observable Array from Rxjs WebSocket Subject call","<angular><websocket><rxjs6>","1","1","","","","CC BY-SA 4.0"
"56304812","1","","","2019-05-25 12:28:06","","0","1151","<p>I have two Observables, <strong>getUser</strong> and <strong>getUserAvatar</strong>.
Both of them emits two values - cached immediately using BehaviorSubject, and real after network request.</p>

<p>Now code works this way:</p>

<p>1) Send request to get user and immediately emit cached user</p>

<p>2)After cached user emited, code goes inside concatMap, and execute getUserAvatar first time</p>

<p>3)getUserAvatar send request to server and immediately emit cached userAvatar</p>

<p>4)Everything is completed and cached user with cached avatar returned</p>

<p>5) After some time, real user returned and getUser emits value again</p>

<p>6) <strong>At this step, I want to prevent call concatMap second time</strong>, because server request already in progress, I want just go to return 'USER LOADED.</p>

<pre><code>sendGetRequest('/user/').pipe(
        concatMap(() =&gt; {
            // HERE, after user data loaded, I have url for his avatar
            return sendGetRequest('/avatar/').pipe();
        }),
        map(() =&gt; {
            return 'USER LOADED';
        })
    )
</code></pre>

<p>Code for Server request</p>

<pre><code>sendGetRequest(url: string, ignoreCache?: boolean): any {

    let responseSubj = new Subject();

    const cachedData = this.cache.getItemForUrl(url);
    const cacheAllowed = cachedData &amp;&amp; !ignoreCache;
    if (cacheAllowed) {
        responseSubj = new BehaviorSubject(cachedData);
    }

    const getFromServer = this.http.get(environment.API_SERVER_URL + url, this.addAuth()).pipe(
        filter((res: any) =&gt; {

            if (cacheAllowed &amp;&amp; JSON.stringify(cachedData) === JSON.stringify(res)) {
                responseSubj.complete();
                return false;
            }

            this.cache.setItemForUrl(url, res).then(() =&gt; {
                responseSubj.complete();
            });
            return true;
        }),
        catchError((error, caught) =&gt; {
            console.log('ERROR FROM GET REQUEST', error);
            return throwError(error);
        })
    );


    return merge(responseSubj, getFromServer);
}
</code></pre>
","1227950","","1227950","","2019-05-28 10:04:56","2019-05-28 14:23:55","Rxjs execute concatMap only once","<angular><rxjs><rxjs6>","2","7","","","","CC BY-SA 4.0"
"56322998","1","","","2019-05-27 09:12:23","","-1","300","<p>I am using a Subject to add edit functionality to a basic phonebook app.
The changes that I make to component class variables inside of the subscribe callback are not reflected out of it or in the template.</p>

<p>I have tried the solutions listed in the answers to the following question:
<a href=""https://stackoverflow.com/questions/38445670/angular-2-view-will-not-update-after-variable-change-in-subscribe#comment89625904_40707669"">Angular 2 View will not update after variable change in subscribe</a></p>

<p>in service.ts:</p>

<pre><code>startedEditing= new Subject&lt;number&gt;();
</code></pre>

<p>in details.component.ts(where the data is passed on fu):</p>

<pre><code>onEdit(){
    this.contactsService.startedEditing.next(this.id);
  }
</code></pre>

<p>in edit-component.ts(in ngOnInit):</p>

<pre><code>this.subscription=this.contactsService.startedEditing.subscribe(
      (index:number)=&gt;{
        this.editMode=true; 
        this.editedItemIndex=index;
        this.editItem=this.contactsService.getContact(this.editedItemIndex);         
          this.editForm.setValue({
            address:this.editItem.address,
            name: this.editItem.name,
            phone:this.editItem.phone,
            profession:this.editItem.profession
          });
          console.log(""in subscribe: ""+this.editedItemIndex);

      }
    );
    console.log(""out of it :"" + this.editedItemIndex);
  }
</code></pre>

<p>output on the console:</p>

<pre><code>in subscribe: 0
out of it : undefined
</code></pre>

<p>expected result:</p>

<pre><code>in subscribe: 0
out of it :0
</code></pre>
","11560860","","","","","2019-05-27 09:24:44","Changes made in .subscribe() method not reflected out of it or in the template","<angular><observable><rxjs6><subject-observer>","2","1","","","","CC BY-SA 4.0"
"56358087","1","","","2019-05-29 10:09:08","","0","67","<p>I am reading a JSON file from an S3 bucket. I am able to read the JSON file which is in the S3 bucket but when I am trying to cast the String Value into JSON and return it with an Observable. While subscribing I am getting the result as undefined. Could you please suggest how to get value as JSON when subscribing the observable</p>

<p>someexampleservice.ts</p>

<pre><code>@Injectable()
export class SomeEXampleService  {

_test2:any;

public getJSON(): Observable&lt;any&gt;  {
return Observable.create(observer=&gt;{

   const params = {
  Bucket: 'some-bucket',
   Key: 'some.json'
    };

   let s3 = new AWS.S3();
  s3.getObject(params, function(err, data) {
     if (err) {
     console.error(err); // an error occurred
   } else {

      console.log(""S3 VAlue"",data.Body); // Here I am getting the value as  
     String

    this._test2= data.Body.toString();
    console.log(""S5 VAlue"",this._test2);
    }
    });

   observer.next( this._test2);

  observer.complete();


    }) ;
   }
</code></pre>

<p>Basically, I am trying to get a JSON like below</p>

<pre><code>public getJSON(): Observable&lt;any&gt; {
return this.http.get(""./assets/some.json"")//This same I am trying above 
with the s3 path
}
</code></pre>

<p>someTests.ts</p>

<pre><code> export class AuthorizationService  {

 constructor(private _auth: AuthorizationService,
          private _router: Router) { }

 ngOnInit(){


 this.getJSON().subscribe(data =&gt; {
 console.log(""JsonValue"",data); //This is coming as undefined
  });
  }
</code></pre>
","6550398","","6550398","","2019-05-29 10:44:47","2019-05-29 10:44:47","Observable casting from string to json","<angular><typescript><observable><rxjs6>","0","9","","","","CC BY-SA 4.0"
"56362474","1","56715821","","2019-05-29 14:05:43","","0","46","<p><strong>End Goal</strong><br>
I have a user/device registration method. In it I need to:</p>

<ol>
<li>Check whether local storage is ready</li>
<li>If so, check separately for deviceId and token</li>
<li>If either deviceId or token are not found, call registration endpoint</li>
</ol>

<p><strong>Where I'm At</strong><br>
During building, and for simplicity, I was not dealing with tokenization. I was only working with deviceId and the below worked/works perfectly fine. </p>

<p>I call my isStorageReady helper method, check the response, then call my getDeviceId helper method, and check that response. </p>

<pre><code>this.isStorageReadyAsync()
    .pipe(
        map(storageResponse =&gt; {
            // check storageResponse
            // if undefined throw error
            // error picked up by retryPipeline
            // if retryPipeline exhausted picked up 
            // by errorPipeline and stream is stopped
            if (storageRes === undefined ||
                storageRes['LOCALSTORAGE'] === undefined ||
                storageRes['LOCALSTORAGE'] === '') throw 'storageRes or 
                storageRes.LOCALSTORAGE are undefined or empty';
        }),
        flatMap(_ =&gt; this.getStoredDeviceIdAsync()),
        map(deviceId =&gt; {
            return iif(() =&gt; deviceId === undefined || 
                             deviceId === null || 
                             deviceId === '',
                       // no deviceId stored on device
                       // register device to get deviceId
                       this.registerDeviceAsync(), 
                       // deviceId found in local storage
                       of({id: deviceId, new: false}))
        }),
        this.storeDeviceIdPipeline, // store deviceId
        this.retryPipeline, // retry if e.g. experiencing network issues
        this.errorPipeline // catch and handle errors
    )
</code></pre>

<p><strong>Where I'm Stuck</strong><br>
I have a second helper method, <code>getStoredTokenAsync()</code> which I would like called in parallel with <code>getStoredDeviceIdAsync()</code>. I've tried using <code>forkJoin</code> and passing an array into the <code>map</code> operator that follows but my typescript linter doesn't like this at all. Everything before forkJoin gets underlined as though it is an error and the error reads as follows:</p>

<blockquote>
  <p>Argument of type OperatorFunction is not assignable to parameter of type OperatorFunction. Type void is not assignable to type {}.</p>
</blockquote>

<p>So I don't quite understand. I was hoping to use something like this:</p>

<pre><code>...
forkJoin([this.getStoredDeviceIdAsync(), this.getStoredTokenAsync()]),
map(authArr =&gt; {
   let deviceId = authArr[0];
   let token = authArr[1];
   ...
})
...
</code></pre>
","3908574","","","","","2019-06-22 13:20:03","Using forkJoin as lettable operator in RxJS 6 pipe","<rxjs6>","1","8","","","","CC BY-SA 4.0"
"56372751","1","","","2019-05-30 06:22:53","","0","91","<p>I am trying to use rxjs with amqplib to convert the received messages from rabbit to a stream of messages:</p>

<pre><code>const connection = await amqplib.connect(constr);
const channel = await connection.createChannel();
const callBack: any = bindCallback(channel.consume);
const observalble = callBack(""queue"");
</code></pre>

<p>the problem is callBack returned from bindCallback is a method with no parameters..
what am is doing wrong here?</p>

<p>I depended on the example:</p>

<pre><code>// From a callback (last argument is a callback)
// fs.exists = (path, cb(exists))
var exists = Rx.Observable.bindCallback(fs.exists);
exists('file.txt').subscribe(exists =&gt; console.log('Does file exist?', exists));
</code></pre>

<p>form the rxjs documentation...</p>

<p>please help</p>

<p>im using rxjs 6.5.2
typescript 3.4.5
amqplib 0.5.2</p>
","1997656","","","","","2019-05-30 11:01:13","rxjs and typescript return an function with no parameters","<typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"56380641","1","","","2019-05-30 14:51:40","","0","75","<p>I am expecting for the functionality using NestJS to make API call, and in case if I get token for next call then I need to make a request to the same API with that token as query params. The limitation is API returns only 50 records without token so to get next records I need to attach query params. In case if the token is empty I need to end the call. Fetching videos from youtube against particular uploaderId.</p>

<p>Sample I have written.</p>

<pre><code>getPlaylistVideos(playlistId: string): any {
    this.videos = [];
    return new Promise((resolve, reject) =&gt;
        this.http
            .get(this.getPlaylistURL(playlistId, ''))
            .pipe(
                map(response =&gt; response.data),
                tap(() =&gt; console.log('\t', `Getting details by URL: this.http.get(this.getPlaylistURL(${playlistId})`)),
                tap(videoResponse =&gt; {
                    this.videos.push(...videoResponse.items);
                    if (videoResponse['nextPageToken']) {
                        console.log('\t', 'NextToken: ', videoResponse['nextPageToken']);
                        return mergeMap(video =&gt; {
                            console.log('\t', `this.http.get(this.getPlaylistURL(${playlistId}, ${video['nextPageToken']})`);
                            return this.http.get(this.getPlaylistURL(playlistId, video['nextPageToken']));
                        });
                    } else {
                        console.log(`videoResponse:`, videoResponse['nextPageToken']);
                        return empty();
                    }
                })
            )
            .toPromise()
            .then(response =&gt; resolve(this.videos))
            .catch(err =&gt; reject(err))
    );
}
</code></pre>

<p>It fails to fetch next set of records.</p>
","672297","","","","","2019-05-30 14:51:40","Recursive HTTP call using rxjs with changing queryParams","<javascript><rxjs><es6-promise><rxjs6><nestjs>","0","3","0","","","CC BY-SA 4.0"
"56394878","1","","","2019-05-31 12:10:26","","2","141","<p>I have a function <code>doSomething()</code> that can be triggered by 
many different DOM events.
Is it possible to listen not to an event, but to a moment, when that function is being called/ listen to a function execution? </p>

<p>I mean - I cannot edit the original function and looking for a solution on don't want to reapeat everything attatching another function to all those events.</p>
","7607735","","8820972","","2019-05-31 12:11:44","2019-05-31 12:28:15","listening for a function execution","<javascript><rxjs><rxjs5><rxjs6>","2","1","1","","","CC BY-SA 4.0"
"56395879","1","56396323","","2019-05-31 13:19:15","","4","2151","<p>In our application we have some components that inherit from a <code>BaseComponent</code>. 
<br></p>

<p>The base component implements <code>OnDestroy</code> interface and emits with a Subject to notify the children to unsubscribe from eventual open streams. <br></p>

<p>Is this an acceptable approach or rather every single component should have its own <code>ngOnDestroy</code> implementation? From this <a href=""https://medium.com/@saniyusuf/part-1-the-case-for-component-inheritance-in-angular-a34fe2a0f7ac"" rel=""nofollow noreferrer"">article</a> I read that Lifecycle hooks are <strong>not</strong> inherited.</p>

<p><strong>BaseComponent</strong></p>

<pre><code>export abstract class ComponentBase implements OnDestroy {
  protected destroy$ = new Subject&lt;boolean&gt;();

  ngOnDestroy() {
    this.destroy$.next(true);
  }
}
</code></pre>

<p><strong>ChildComponent</strong></p>

<pre><code>export class ChildComponent extends ComponentBase implements OnInit {

 ngOnInit() {
    this.service
      .getById(userId)
      .pipe(takeUntil(this.destroy$)) // this is emitted by the parent
      .subscribe(user =&gt; { ...}
 }
}
</code></pre>
","706293","","706293","","2019-05-31 13:39:13","2021-01-11 02:29:17","Using single ngOnDestroy in parent component","<angular><inheritance><rxjs6>","3","4","","","","CC BY-SA 4.0"
"56401349","1","56402629","","2019-05-31 20:25:52","","1","369","<p>I am building a new web application in Angular7.</p>

<p>I have a data table and I want to build server-side search functionality based on search values for each column. I have an input element at the top of each column in the data table. The search filtering should be triggered each time the search value changes in any of the input boxes.</p>

<p>I think I need to bind the keyup event to detect the change of value. I am using rxjs fromEvent and this does work, however, it detects the keyup of ANY keyboard event, not just the events tied to the relevant input boxes. I want to avoid unnecessary events since this will call the server-side filtering each time.</p>

<p>HTML</p>

<pre><code>&lt;table mat-table [dataSource]=""data"" class=""example-table"" matSort&gt;
  &lt;!-- ItemID Column --&gt;
  &lt;ng-container matColumnDef=""ItemID""&gt;
    &lt;th class=""header"" mat-header-cell *matHeaderCellDef&gt;
      &lt;div mat-sort-header&gt;ItemID&lt;/div&gt;
      &lt;mat-form-field class=""filter"" floatLabel=""never""&gt;
        &lt;input
          matInput
          placeholder=""Search ItemID""
          #input
          [(ngModel)]=""searchValues.ItemID""
        &gt;
      &lt;/mat-form-field&gt;
    &lt;/th&gt;
    &lt;td mat-cell *matCellDef=""let row""&gt;{{row.ItemID}}&lt;/td&gt;
  &lt;/ng-container&gt;

  &lt;!-- IdentificationID Column --&gt;
  &lt;ng-container matColumnDef=""IdentificationID""&gt;
    &lt;th class=""header"" mat-header-cell *matHeaderCellDef&gt;
      &lt;div mat-sort-header&gt;IdentificationID&lt;/div&gt;
      &lt;mat-form-field class=""filter"" floatLabel=""never""&gt;
        &lt;input
          matInput
          placeholder=""Search IdentificationID""
          #input
          [(ngModel)]=""searchValues.IdentificationID""
        &gt;
      &lt;/mat-form-field&gt;
    &lt;/th&gt;
    &lt;td mat-cell *matCellDef=""let row""&gt;{{row.IdentificationID}}&lt;/td&gt;
  &lt;/ng-container&gt;
&lt;/table&gt;
</code></pre>

<p></p>

<p>TS component</p>

<pre><code>// TODO: bind to relevant input elements only
fromEvent&lt;KeyboardEvent&gt;(document, 'keyup')
  .pipe(
    debounceTime(150),
    distinctUntilChanged(),
    tap(() =&gt; {

      // call search function

    })
  )
  .subscribe();
</code></pre>
","2183592","","","","","2019-06-06 17:17:45","Angular 7 rxjs 6 bind to certain elements only","<angular><typescript><rxjs6>","1","1","","","","CC BY-SA 4.0"
"56441017","1","","","2019-06-04 09:21:09","","0","2210","<p>New to RXJS and trying to figure out how to setup my autocomplete. 
Right now I have a <code>typeahead</code> component that handles the <code>input</code> element and emits the value ('term'). 
In my <code>filters</code> component (parent) I handle the logic of making api calls and dealing with the data (via a service). I have a function in this component that is called with the <code>term</code> change and makes an api call. Having trouble setting this up with some of the examples I saw, namely switchMap seems to be needed to make the correct calls. 
Basically the function should do 2 things: 1. Send requests to the api and handle the return data.
2. Push that into a list that will be display as autocomplete options. 
Right now it looks like this but there is a syntax error:</p>

<pre><code>public IdTypeahead(term: string) {
    this.model.NctIdList = [];

    if (!(term &amp;&amp; term.length &gt; 0)) {
      return;
    }

    this.searchCriteria.nctIdPrefix = term;
    this.searchCriteria.aggregateOn = 'nctid';
    // this.NctIdList = of(term)
    let input$ = of(term)
      .switchMap(() =&gt; from(this.filterService.GetNctIdFilterData(this.searchCriteria))
          .subscribe((result: any) =&gt; {
            this.NctIdList.push(result.nctid)
              return result.nctid
          }

          )
  }
</code></pre>

<p>Previously it looked like this, but was making the wrong calls (calls were lagging):</p>

<pre><code>public IdTypeahead(term: string) {
    this.model.NctIdList = [];

    if (!(term &amp;&amp; term.length &gt; 0)) {
      return;
    }

    this.searchCriteria.nctIdPrefix = term;
    this.searchCriteria.aggregateOn = 'nctid';
    this.NctIdList = 
    this.filterService.GetNctIdFilterData(this.searchCriteria).pipe(
    map((result: any) =&gt; result.nctid) as Observable&lt;string[]&gt;
  }

</code></pre>
","9266540","","","","","2019-06-04 15:59:16","Autocomplete with Angular and RXJS","<angular><rxjs><rxjs6><angular2-observables>","2","0","","","","CC BY-SA 4.0"
"56467176","1","56467270","","2019-06-05 19:58:16","","0","695","<p>I am doing an auto-complete search box and the problem I have is that when I write a word in the input, the service return very well the list of the items result. The service return if there are elements that match or empty if there are not, but the problems is that the list of my component doesn't update with the service values and I don't know why. I was following an example, and mine doesn't work. I hope someone can help me.</p>

<p>This is the service request.</p>

<pre><code>searchNewsInList2(filterValue:any):Observable&lt;New[]&gt;{
    return this.httpClient.get&lt;New[]&gt;(this.basePath)
    .pipe(
            tap((response:any)=&gt;{
                response=response
                .filter(news=&gt;news.title.includes(filterValue))
            return response;
            })

        );

    }
</code></pre>

<p>This is the request in the component, the list doesn't update with the service return data.</p>

<pre><code>constructor(private notificationService:NotificationsService,private newsService: NewsService, private router: Router,private tost:ToastrService) {

    this.notificationRequest=new Notification();
    this.newsSelected=new New();
    this.newsCntrlToAdd = new FormControl();

    }

    ngOnInit() {
    this.filteredNews=this.newsCntrlToAdd.valueChanges
        .pipe(
            debounceTime(300),
            startWith(''),
            switchMap(value =&gt;this.newsService.searchNewsInList2( value))
        );
    }

    displayFn(newFound: New) {
        if (newFound) {
            return newFound.title;
        }
    }
</code></pre>

<p>This is the view.</p>

<pre><code>&lt;mat-form-field class=""example-full-width""&gt;
    &lt;input matInput placeholder=""Specify a news to add""[formControl]=""newsCntrlToAdd""
    [matAutocomplete]=""auto"" required minlength=""4""&gt;
    &lt;/mat-form-field&gt;
        &lt;mat-autocomplete #auto=""matAutocomplete"" [displayWith]=""displayFn""&gt;
            &lt;mat-option *ngFor=""let newFound of (filteredNews | async)"" [value]=""newFound""&gt;
            &lt;span&gt;{{ newFound.title }}&lt;/span&gt;
            &lt;!--small&gt; | ID: {{newFound.id}}&lt;/small--&gt;
            &lt;/mat-option&gt;
        &lt;/mat-autocomplete&gt;
</code></pre>
","8722606","","5437671","","2019-06-05 20:04:37","2019-06-05 20:05:43","Angular autocomplete async dont filter","<angular><autocomplete><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"56475246","1","","","2019-06-06 10:01:01","","0","59","<p>Live: <a href=""https://stackblitz.com/edit/rxjs-6aikyy?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-6aikyy?file=index.ts</a></p>

<pre class=""lang-ts prettyprint-override""><code>const sub = new ReplaySubject(1);
const source = combineLatest(
  of('World'),
  sub,
).pipe(
  map(([, n]) =&gt; n) ,
  tap(x =&gt; console.log('Tap', x)),
  publishReplay(1),
  refCount(),
);

sub.next(1);

const subscription = source.subscribe(x =&gt; console.log('Sub', x));
sub.next(2);

subscription.unsubscribe();
sub.next(3);

console.log('pause');
sub.next(4);

source.subscribe(x =&gt; console.log('Sub', x));


/**
 * Tap 1 (unwanted)
 * Sub 1 (unwanted)
 * Tap 2
 * Sub 2
 * pause
 * Sub 2 (why exaclty does this happened?)
 * Tap 4
 * Sub 4
 */
</code></pre>

<p>This is simplified a bit, but it shows my problem well. In my actual code, I combine 1 <code>BehaviourSubject</code> and 2 <code>ReplySubject</code>s, then pipe it into <code>switchMap</code> and fetching data from the server. I really don't want to keep making HTTP calls unless someone actually listens.</p>

<p>Does someone know why do I get the first notification from the ReplaySubject (Tap 1 &amp; Sub 1), and also why does ""Sub 2"" appear after the pause?</p>

<hr>

<h3>Actual test case</h3>

<pre class=""lang-ts prettyprint-override""><code>this.currentPage = new BehaviourSubject(1);
// Internal
const folderIDAndPage: Observable&lt;[string, number]&gt; = combineLatest(
  /** Angular's BehaviourSubject of URL maped to id */
  activatedRoute.url.pipe(
    switchMap(segments =&gt; folderService.getFoldersFromSegments(segments)),
    distinctUntilChanged(),
  ),
  /** BehaviourSubject/ReplaySubject (either) of QueryString maped to page */
  this.currentPage.pipe(
    distinctUntilChanged(),
  ),
).pipe(
  // Prevent repeating HTTP somehow...
);

// Public
this.folders = folderIDAndPage.pipe(
  switchMap(([folderID, page]) =&gt; folderService.getFfolders(folderID, page)),
  // Prevent repeating HTTP somehow...
);

// Public
this.files = folderIDAndPage.pipe(
  switchMap(([folderID, page]) =&gt; fileService.getFiles(folderID, page)),
  // Prevent repeating HTTP somehow...
);
</code></pre>

<p>As of now, I have it that if I don't subscribe to either, no HTTP will be made, but if I subscribe to files or folders, the <code>folderService.getFoldersFromSegments</code> seems to get called twice.</p>
","3001856","","3001856","","2019-06-11 13:28:26","2019-06-11 13:28:26","ReplySubject turns whole combineLastest hot","<rxjs><rxjs6>","0","5","","","","CC BY-SA 4.0"
"56489180","1","56496562","","2019-06-07 06:42:59","","2","4392","<p>I am fetching a pets list from the swagger pets API. I want to remove pets with duplicate ids and then send it to React to avoid the duplicate key problem. I tried the code below but does not work for me. Can anyone help me out with this?</p>

<p>I am new to RxJS so want to remove the commented code which filters distinct objects based on pet id.</p>

<pre><code>export function fetchPetEpic(action$) {
    return action$.pipe(
        ofType('GET_PETS'),
        switchMap(action =&gt; 
            ajax.getJSON(`https://petstore.swagger.io/v2/pet/findByStatus?status=${action.payload}`).pipe(
                map( response =&gt; response.map( (pet) =&gt; ({
                    id: pet.id,
                    pet: pet.pet
                }))),
                distinct( petList =&gt; petList.id),
                // map( petList =&gt; petList.filter((pet, index, list) =&gt; {
                //                     return list.map(petObj =&gt;
                //                         petObj.id).indexOf(pet.id) === index;
                //                     })),
                map(response =&gt; petActions.setPets(response))
        )),
        catchError( error =&gt; ({ type: 'ERROR_PETS_FETCH', payload: error})),
    )
}
</code></pre>

<p>Suppose the pets array is something like [
{ id: 1, pet: dog}, { id: 2, pet: cat }, { id: 3, pet: fish}, { id: 2, pet: rat }, { id: 4, pet: parrot}, { id: 1, pet: owl }
]</p>

<p>Expected output:[{ id: 1, pet: dog}, { id: 2, pet: cat }, { id: 3, pet: fish}, { id: 4, pet: parrot}]</p>

<p>The output I am getting is the same array as input.</p>
","6778561","","6778561","","2019-06-08 13:11:20","2019-06-08 13:11:20","How to apply distinct() to array of objects RxJS?","<rxjs6><redux-observable>","1","3","2","","","CC BY-SA 4.0"
"56490770","1","","","2019-06-07 08:34:51","","0","422","<p>I know <code>activatedRoute</code> is actually <code>BehaviourSubject</code>, but since it's exposed API is observable, I don't want to take chances.</p>

<pre><code>activatedRoute.queryParams.pipe(
    take(1),
).subscribe(query =&gt; {  // { page?: '1' | '2' | '3'... }
    this.currentPage = new BehaviourSubject(+(query.page) || 1);
    // Other components actually change this
});

console.log(this.currentPage); // I need this to not be undefined!
</code></pre>

<p>Does a pipe resembling this exists? <code>takeSynchonously(1, { page: 1 })</code></p>
","3001856","","","","","2019-06-07 09:46:02","RXJS take 1 if synchronous, else use defaultValue","<rxjs><rxjs6>","1","6","","","","CC BY-SA 4.0"
"56494907","1","","","2019-06-07 13:02:20","","0","1288","<p>I would like your help with something I have in mind to be used for things like deleting notifications.</p>

<p>Basically, my users have a list of notifications which they can mark as read.<br>
Now, my back-end is very sluggish (and I have no control over it).<br>
Right now, when a user clicks on the notification's <strong>&#9993;</strong> button :  </p>

<ol>
<li>A request to the back-end is made to mark the notification, then after a back-end response, refresh data with another request;</li>
<li>The entry is modified in app memory, <em>the view is modified</em></li>
<li>Refreshed data from <strong>1.</strong> comes back, <em>the view is modified</em></li>
</ol>

<p>This tanslates to something like this (using Angular's <code>HttpClient</code>) :</p>

<pre class=""lang-js prettyprint-override""><code>markAsRead(id: string): void {
  this.http.post(url, body, options)
  .subscribe(() =&gt; this.reloadNotifications());

  this.markAsReadInternal(id);
}
</code></pre>

<p>Here comes the trouble : when my user decides to do a single action, all is good. But when the user decides to read many notifications, the view can be altered many times as the data refresh.</p>

<p>I can see a way of preventing the problem, but that would mean</p>

<ol>
<li>Button is clicked;</li>
<li>Store the id in an array;</li>
<li>Wait for X milliseconds for another click;</li>
<li>If a click occured back to <strong>2.</strong>, else</li>
<li>Send the request with the array of ids and refresh the data</li>
</ol>

<p>Any help to translate that into rxjs code?</p>

<p><em>Bonus point</em>: My data is refreshed every 5 seconds in any case...</p>
","3456021","","","","","2019-06-17 11:55:01","Rxjs - Table with buttons, wait a certain time after last button pressed before request","<angular><rxjs><rxjs6>","2","5","","","","CC BY-SA 4.0"
"56496767","1","","","2019-06-07 14:58:30","","2","98","<p>I have to write Unit Test for this effect that is calling the service every 1 sec when it went in error.
I need to test for example that after 3 times of calling a service, I'll receive a good response.</p>

<p>I tried some way to test but without any result.</p>

<p>This is the effect that I have to test:</p>

<pre class=""lang-js prettyprint-override""><code>@Effect()
  updateEffect$ = this.actions$.pipe(
    ofType(featureActions.ActionTypes.UPDATE_PRODUCT),
    switchMap((action: UpdateProduct) =&gt;
      this.productService.getProducts().pipe(
        retryWhen((attempts) =&gt; attempts.pipe(delay(1000))),
        map((productsResponse: Products) =&gt;
          productsResponse
            ? new featureActions.LoadProductSuccess(productsResponse)
            : new featureActions.LoadProductError(productsResponse)
        )
      )
    )
  );
</code></pre>

<p>This is the unit test that I did just to see the success scenario.
What I want to test is the reload logic</p>

<pre class=""lang-js prettyprint-override""><code> it('should return UpdateProduct if service response success ', () =&gt; {
    const action = new UpdateProduct('123456');
    const completion = new LoadProductSuccess(productsResponseMock);

    actions$ = hot('-a-', { a: action });
    const response = cold('-b', { b: productsResponseMock });
    const expected = cold('--c', { c: completion });

    productService.getProducts.and.returnValue(response);
    expect(effects.updateEffect$).toBeObservable(expected);
  });
</code></pre>
","8539571","","2611237","","2019-06-07 16:33:44","2019-06-07 16:33:44","How to write unit test for effect that after n times return a valid response?","<angular><integration-testing><rxjs6><jasmine-marbles><rxjs-marbles>","1","1","","","","CC BY-SA 4.0"
"56499330","1","","","2019-06-07 18:09:04","","2","216","<p>I'm displaying a list of messages using <code>*ngFor</code> and wish to apply a css class to items added to the collection <em>after</em> the list was originally rendered.</p>

<p>i.e. I don't want to apply the class when the view initially loads, but only when the <code>messages</code> collection gets a new item.</p>

<p>The source of this collection is an observable from a service which can change at any time.</p>

<pre><code>&lt;div *ngFor=""let message of thread.messages""&gt;
    &lt;div [class.fade-in-text]=""threadWasLoaded""&gt;
        {{ message.text }}
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>I thought I would just set a variable after I know the thread got loaded, but this has not worked.  I tried subscribing to the observable in basically every Angluar lifecycle hook.</p>

<p>The results are either that the css class is always applied to all list items OR I get the following error:</p>

<blockquote>
  <p>Error: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked.</p>
</blockquote>

<hr>

<pre><code>this.thread$ = 
    this.storeQuery.getThreadWithMessages(this.threadId)
        .pipe(
            map(t =&gt; this.thread = new Thread(t)),
            tap(t =&gt; this.threadWasLoaded = true)
        );
</code></pre>

<p>It's possible I'm asking the wrong question entirely.  Please let me know if my overall approach is off base. :-)</p>

<p><strong>Edit:
I've found a solution to my problem from <a href=""https://www.bennadel.com/blog/3417-using-no-op-transitions-to-prevent-animation-during-the-initial-render-of-ngfor-in-angular-5-2-6.htm"" rel=""nofollow noreferrer"">This Article</a> which approaches this in a different way by suppressing child animations on page load.</strong></p>
","1858357","","1858357","","2019-07-29 16:15:49","2019-07-29 21:45:33","How to know when item has been rendered in DOM using *ngFor?","<angular><rxjs><rxjs6>","4","7","1","","","CC BY-SA 4.0"
"56513781","1","","","2019-06-09 10:24:09","","2","1252","<p>I'm trying to build a pluggable <code>ProgressService</code>.</p>

<p>The service should track how many ""things"" are currently loading. And have an <code>isLoading()</code> method that returns an <code>Observable&lt;boolean&gt;</code> to indicate if anything is loading at all.</p>

<p>My first solution was very naive using a <code>new BehaviorSubject(0)</code> and then each loading provider just called <code>ProgressService.increase()</code> and <code>ProgressService.decrease()</code>. This worked fine. But now I'd like to go more reactive, if possible.</p>

<hr>

<p>Then I came across <code>merge</code>, which works fine when all loading providers are known at the beginning:</p>

<pre class=""lang-js prettyprint-override""><code>this.progress = merge(...progressProviders).pipe(
  scan((acc, curr) =&gt; acc + (curr ? 1 : -1), 0)
);
</code></pre>

<p>This will simply increase / decrease the <code>progress</code> value, when any loading provider emits <code>true</code> or <code>false</code>.</p>

<p>But I also need some kind of register / unregister functionality. This should basically add a new <code>Observable</code> to the <code>merge</code> chain (or remove it).</p>

<hr>

<p>The new <code>ProgressService</code> should look like this:</p>

<pre class=""lang-js prettyprint-override""><code>class ProgressService {

  progress: Observable&lt;number&gt; = EMPTY; // value &gt; 0 when something is loading

  addLoadingProvider(lp: Observable&lt;boolean&gt;) {
    // increment this.progress, when lp emits true
    // decrease this.progress, when lp emits false
    // nice to have: ignore if lp's first emitted value is false
  }

  removeLoadingProvider(lp: Observable&lt;boolean&gt;) {
    // stop listening to lp
    // clean up: decrease this.progress, if lp last emitted true
  }

  isLoading(): Observable&lt;boolean&gt; {
    return this.progress.pipe(
      map(val =&gt; val !== 0)
    );
  }

}
</code></pre>

<p>Maybe the <code>removeLoadingProvider</code> method isn't needed at all (?), if we return a <code>Subscription</code> from <code>addLoadingProvider</code>, and use <code>Subscription.unsubscribe()</code> to unregister.</p>

<p>Hopefully someone can tell me how to <code>merge</code> and <code>unmerge</code> additional Observables on demand.</p>
","1321564","","","","","2019-06-09 17:33:35","RxJS: dynamically add and remove Observable with merge","<angular><typescript><rxjs><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"56564281","1","","","2019-06-12 14:13:51","","0","473","<p>I have ""mainData"" service, it consists of 3 parts:</p>

<ul>
<li><code>currentPage</code> used by paginator component to switch page. Can be updated at any point.</li>
<li><code>folders</code> contains all folders in the current folder. There are <strong>2</strong> components that use this observable (Types of listing of folder content)</li>
<li><code>files</code> contains all files in the current folder. There are <strong>3</strong> components that use this observable (Types of listing of folder content)</li>
</ul>

<p>The default view is the one without folders, thus I would like not to make unnecessary HTTP calls.</p>

<pre class=""lang-ts prettyprint-override""><code>public currentPage = new ReplaySubject(1);
public folders: Observable&lt;FLFolder[]&gt;;
public files: Observable&lt;FLFile[]&gt;;

constructor(
  activatedRoute: ActivatedRoute,
  folderService: FolderService,
  fileService: FileService,
) {
  // Populate `this.currentPage`
  activatedRoute.queryParams.pipe(
    take(1),
    //  Wait until end of this sync tick. If no emission is made, it will use default in the next tick.
    takeUntil(timer(1, queueScheduler)),
    defaultIfEmpty&lt;Params&gt;({}),
  ).subscribe(query =&gt; {
    if (query.page) {
      this.currentPage = +query.page;
    } else {
      this.currentPage = 1;
    }
  });

  /** This observable is internal, only to be used by `folders` and `files` */
  const folderIDAndPage: Observable&lt;[string, number]&gt; = combineLatest(
    activatedRoute.url.pipe(
      switchMap(segments =&gt; folderService.getFoldersFromSegments(segments)),
      distinctUntilChanged(),
    ),
    this.currentPage.pipe(
      distinctUntilChanged(),
    ),
  ).pipe(
    // Prevent repeating HTTP somehow...
    publishReplay(1),
    refCount(),
  );

  this.folders = folderIDAndPage.pipe(
    switchMap(([folderID, page]) =&gt; folderService.getFfolders(folderID, page)),
    // Prevent repeating HTTP somehow...
    publishReplay(1),
    refCount(),
  );

  this.files = folderIDAndPage.pipe(
    switchMap(([folderID, page]) =&gt; fileService.getFiles(folderID, page)),
    // Prevent repeating HTTP somehow...
    publishReplay(1),
    refCount(),
  );
}
</code></pre>

<p>When there is no subscribe to either <code>folders</code>, or <code>files</code>, no HTTP are made. But even if one subscribes to only one of them, both <code>folders</code> and <code>files</code> get populated (while making the HTTP call) and updated at the same time.</p>
","3001856","","9246344","","2019-06-12 18:03:26","2019-06-13 05:33:57","RXJS/Angular Prevent multiple HTTP on multiple subscribers","<angular><typescript><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"56565232","1","","","2019-06-12 15:01:47","","1","161","<p>I am trying filtering the return of HTTP request in Angular 7 using RXJS6.</p>

<p>I must filter the response; only get the Users with IdSkill equals to 1234.</p>

<p>However, I cannot achieve this. I just received this error:</p>

<p><em>Type 'Observable' is not assignable to type 'Observable>'.
  Type 'User[]' is missing the following properties from type 'Pagination': total, items</em></p>

<p>RXJS is not my strong skill; I just use the basics, only to do simple get/post HTTP requests.</p>

<p>My code:</p>

<pre><code>/* Interface */
export interface Pagination&lt;t&gt; {
    total: number;
    items: t[];
}

export interface User {
    idUser: number;
    name: string;
    active: boolean;
    skill: Skill;
}

export interface Skill {
    idSkill: number;
    name: string;
}

/* Service */
getUsers(): Observable&lt;Pagination&lt;User&gt;&gt; {
    return this._httpClient.get&lt;Pagination&lt;User&gt;&gt;(
      'http://localhost/api/users',
      { headers: this._auth }
    ).pipe(
      filter(x =&gt; x.items.filter(user =&gt; user.skill.idSkill == 1234))
    );
}
</code></pre>

<p>Thank you</p>
","1898938","","","","","2019-06-12 16:01:40","Filtering array with RXJS","<javascript><angular><rxjs><observable><rxjs6>","2","0","","","","CC BY-SA 4.0"
"56565315","1","56565607","","2019-06-12 15:06:18","","-2","128","<p>I'm using Angular 6 and RxJs 6.5.2. I cannot for the life of me figure out the syntax for chaining observables to add an access token to HTTP requests and return the type needed to satisfy the intercept method. I've tried all permutations of subscribe, pipe, map...</p>

<pre><code>  private getApiToken(): Observable&lt;any&gt; {
    // TODO load from configuration
    return this.httpClient.post(""https://localhost:1234/connect/token"",
      {
        grant_type: ""client_credentials"",
        client_id: ""MyClient"",
        client_secret: ""MySecret"",
        scope: ""ApiScope""
      });
  }


  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
   // how do I call getApiToken here?
   return next.handle(req);
  }
</code></pre>

<p>Note that if I ever get this working I will of course cache the token.</p>
","12752","","","","","2019-06-12 16:12:17","How do I write an HttpInterceptor that gets and adds a token?","<angular><rxjs><rxjs6>","1","5","","2019-06-12 16:16:12","","CC BY-SA 4.0"
"56569946","1","","","2019-06-12 20:29:45","","0","155","<p>Background:
Using rxjs Observables</p>

<p>I'm trying to call a method (with an observable) that calls another method.  This current setup isn't working for me  with the following compilation error in checkIfTrue function in service 1...</p>

<blockquote>
  <p>A function whose declared type is neither 'void' nor 'any' must return
  a value.ts(2355)</p>
</blockquote>

<pre><code>//component
//makes call to service
process = () =&gt; {
     this.service1.checkIfTrue().subscribe(x =&gt; {console.log(x)});
};

//service 1
//makes call to service 2
checkIfTrue = (): Observable&lt;boolean&gt; =&gt; {
     this.service2.getInt().subscribe(y =&gt; { return y == 1;});
};


//service 2
//makes call to service 2
getInt = (): Observable&lt;number&gt; =&gt; {
     return Observable.of(1);
};
</code></pre>

<p>It seems like I can't return the response from the second method...How can I achieve this?</p>
","1706578","","1706578","","2019-06-12 22:11:04","2019-06-13 05:05:36","Typescript Nested Observables","<typescript><rxjs6>","1","0","","","","CC BY-SA 4.0"
"56582295","1","56585056","","2019-06-13 14:04:04","","0","123","<p>I am running an Angular 8 app, and I am getting an error which seems to be a major bug in RxJS or I am missing something.</p>

<pre><code>import { of } from 'rxjs';
import { switchMap } from 'rxjs/operators';
of(1,2,3)
  .pipe(
    switchMap((x) =&gt; of(x + 1))
  )
</code></pre>

<p>Now I would expect a subscriber to receive the following output:</p>

<pre><code>//2, 3, 4
</code></pre>

<p>But instead, its outputting the actual observable that I return in the switchMap operation:</p>

<pre><code>//Observable&lt;number&gt;, Observable&lt;number&gt;, Observable&lt;number&gt;
</code></pre>

<hr>

<p><strong>SUMMARY</strong></p>

<p>Essentially it seems that switchMap is returning a value of type <code>Observable&lt;Observable&lt;number&gt;&gt;</code> instead of just <code>Observable&lt;number&gt;</code>.</p>

<p>I am not sure if this if this is a TypeScript or RxJS error, but it seems that when I revert RxJS to version 6.0.0 the issue goes away.</p>

<hr>

<p><strong>Versions:</strong></p>

<ul>
<li>Angular 8.0.0</li>
<li>TypeScript 3.4.5</li>
<li>RxJS 6.4.0</li>
</ul>

<p>I've just tested and dthe same thing is happening with <code>flatMap</code></p>
","2287428","","2287428","","2019-06-13 14:58:02","2019-06-13 16:39:14","RXJS v6.4 switchMap operator returns an Observable rather than the result (accordinng to TypeScript linter)","<typescript><rxjs6><angular8><switchmap>","1","1","","","","CC BY-SA 4.0"
"56587218","1","","","2019-06-13 19:15:49","","3","4520","<p>I have a source Observable (actually a Subject) and when that Observable emits a value, I need to kick off a load of values that results in 2 more observables being updated, and when that load is done take the value of the source and combine it with the latest values of the 2 ""dependent"" observables, but only the values from AFTER the source observable emits.  So if the 2 dependent observables have values when the source emits, I need this to wait until the 2 dependents get updates before emitting the latest of all 3 observables.  I've tried using various incantations of withLatestFrom, switchMap, and combineLatest, but nothing is giving me the desired output:</p>

<p>This will emit values in the right shape, but not at the right time, it is using the values from before the SelectExpenseSummary has done its thing and the expenseDetails$ and expenseReceipts$ have updated.</p>

<pre><code>      this.editExpenseSubject.pipe(
        takeWhile(() =&gt; this.active),
         tap(x =&gt; this.userStore.dispatch(new SelectExpenseSummary(x))),
         tap(x =&gt; this.log.verbose({type: 'ExpensesFeatureComponent:editExpenseSubject:tap', x})),
         withLatestFrom(
          this.expenseDetails$,
          this.expenseReceipts$,
          )
        )
      .subscribe(x =&gt; {
        this.log.verbose({type: 'ExpensesFeatureComponent:editExpenseSubject:subscribe', x});
      });
</code></pre>

<p>This emits a bunch of times, with the last time having the correct values, which would be OK, but emits the wrong shape, it's missing the source observable from the output:</p>

<pre><code>      this.editExpenseSubject.pipe(
        takeWhile(() =&gt; this.active),
         tap(x =&gt; this.userStore.dispatch(new SelectExpenseSummary(x))),
         tap(x =&gt; this.log.verbose({type: 'ExpensesFeatureComponent:editExpenseSubject:tap', x})),
         switchMap(() =&gt;
            combineLatest(this.expenseDetails$,
            this.expenseReceipts$,
            )
          )
        )
      .subscribe(x =&gt; {
        this.log.verbose({type: 'ExpensesFeatureComponent:editExpenseSubject:subscribe', x});
      });
</code></pre>

<p>This has the right output shape, having all 3 observables, but it never emits anything in the subscribe, I'm guessing because of the use of editExpenseSubject inside:</p>

<pre><code>      this.editExpenseSubject.pipe(
        takeWhile(() =&gt; this.active),
         tap(x =&gt; this.userStore.dispatch(new SelectExpenseSummary(x))),
         tap(x =&gt; this.log.verbose({type: 'ExpensesFeatureComponent:editExpenseSubject:tap', x})),
         switchMap(x =&gt;
          combineLatest(
            this.editExpenseSubject
            , this.expenseDetails$
            , this.expenseReceipts$
          )
        )
      )
      .subscribe(x =&gt; {
        this.log.verbose({type: 'ExpensesFeatureComponent:editExpenseSubject:subscribe', x});
      });
</code></pre>

<p>Can someone point me to the correct incantation to get what I'm after, preferably with detailed explanation as to why.</p>

<hr>

<p>Update for additional info (I think this gets you through the whole flow):</p>

<pre><code>    this.expenseDetails$ = this.expenseStore.pipe(
      select(fromExpenses.getExpenseLines)
    );
    this.expenseReceipts$ = this.expenseStore.pipe(
      select(fromExpenses.getExpenseReceipts)
    );

export const getExpenseLines = createSelector(StateFeatureSelector, x =&gt; x.expenseLines);
export const getExpenseReceipts = createSelector(StateFeatureSelector, x =&gt; x.expenseReceipts);

export interface State {
  expenseSummaries: Array&lt;IExpenseSummary&gt;;
  expenseLines: Array&lt;IExpenseLine&gt;;
  expenseReceipts: Array&lt;IExpenseReceipt&gt;;
  selectedUser: IDirectReport;
  selectedExpenseSummary: IExpenseSummary;
}


  @Effect() LoadExpenseLines$ = this.actions$.pipe(
    ofType&lt;fromExpense.LoadExpenseLines&gt;(fromExpense.ActionTypes.LoadExpenseLines)
    , tap(action =&gt; this.log.debug({type: 'ExpenseEffects:LoadExpenseLines$:filtered', action}))
    , mergeMap(x =&gt;
      this.service.getExpenseLines(x &amp;&amp; x.payload)
        .pipe(
          tap(receipts =&gt; this.log.debug({type: 'ExpenseEffects:getExpenseLines', receipts}))
          , map(lineItems =&gt; new fromExpense.SetExpenseLines(lineItems))
        )
    )
  );
  @Effect() LoadExpenseReceipts$ = this.actions$.pipe(
    ofType&lt;fromExpense.LoadExpenseReceipts&gt;(fromExpense.ActionTypes.LoadExpenseReceipts)
    , tap(action =&gt; this.log.debug({type: 'ExpenseEffects:LoadExpenseReceipts$:filtered', action}))
    , mergeMap(x =&gt;
      this.service.getExpenseReceipts(x &amp;&amp; x.payload)
        .pipe(
          tap(receipts =&gt; this.log.debug({type: 'ExpenseEffects:getExpenseReceipts', receipts}))
          , map(receipts =&gt; new fromExpense.SetExpenseReceipts(receipts))
        )
    )
  );

  @Effect() SelectExpenseSummary$ = this.actions$.pipe(
    ofType&lt;fromExpense.SelectExpenseSummary&gt;(fromExpense.ActionTypes.SelectExpenseSummary)
    , tap(action =&gt; this.log.debug({type: 'ExpenseEffects:SelectExpenseSummary$:filtered', action}))
    , mergeMap(x =&gt;
        [
          new fromExpense.LoadExpenseLines(x.payload)
          , new fromExpense.LoadExpenseReceipts(x.payload)
        ]
    )
  );

export class SelectExpenseSummary implements Action {
  readonly type = ActionTypes.SelectExpenseSummary;
  constructor(public payload: IExpenseSummary) {}
}

export class LoadExpenseLines implements Action {
  readonly type = ActionTypes.LoadExpenseLines;
  constructor(public payload: IExpenseSummary) {}
}
export class SetExpenseLines implements Action {
  readonly type = ActionTypes.SetExpenseLines;
  constructor(public payload: Array&lt;IExpenseLine&gt;) {}
}

export class LoadExpenseReceipts implements Action {
  readonly type = ActionTypes.LoadExpenseReceipts;
  constructor(public payload: IExpenseSummary) {}
}

export class SetExpenseReceipts implements Action {
  readonly type = ActionTypes.SetExpenseReceipts;
  constructor(public payload: Array&lt;IExpenseReceipt&gt;) {}
}

export function reducer (state = initialState, action: actions.ActionsUnion): State {
  switch (action.type) {
// ...  other actions cut
    case actions.ActionTypes.SetExpenseLines:
      return {
        ...state,
        expenseLines: action.payload &amp;&amp; [...action.payload] || []
      };
    case actions.ActionTypes.SetExpenseReceipts:
      return {
        ...state,
        expenseReceipts: action.payload &amp;&amp; [...action.payload] || []
      };
    default:
      return state;
  }
}

// from the service class used in the effects

  getExpenseLines(summary: IExpenseSummary): Observable&lt;Array&lt;IExpenseLine&gt;&gt; {
    this.log.debug({type: 'ExpenseService:getExpenseLines', summary, uri: this.detailUri});
    if (summary) {
      return this.http
        .post&lt;Array&lt;IExpenseLine&gt;&gt;(this.detailUri, {ExpenseGroupId: summary.ExpReportNbr})
        .pipe(
          tap(data =&gt; this.log.verbose({ type: 'ExpenseService:getExpenseLines:reponse', data }))
        );
    } else {
      this.log.log({ type: 'ExpenseService:getExpenseLines null summary'});
      return of&lt;Array&lt;IExpenseLine&gt;&gt;([])
      .pipe(
        tap(data =&gt; this.log.verbose({ type: 'ExpenseService:getExpenseLines:reponse', data }))
      );
    }
  }
  getExpenseReceipts(summary: IExpenseSummary): Observable&lt;Array&lt;IExpenseReceipt&gt;&gt; {
    this.log.debug({type: 'ExpenseService:getExpenseReceipts', summary, uri: this.receiptUri});
    if (summary) {
      return this.http
      .post&lt;Array&lt;IExpenseReceipt&gt;&gt;(this.receiptUri, {ExpenseGroupId: summary.ExpReportNbr})
      .pipe(
        tap(data =&gt; this.log.verbose({ type: 'ExpenseService:getExpenseReceipts:reponse', data }))
      );
    } else {
      this.log.log({ type: 'ExpenseService:getExpenseReceipts null summary'});
      return of&lt;Array&lt;IExpenseReceipt&gt;&gt;([])
      .pipe(
        tap(data =&gt; this.log.verbose({ type: 'ExpenseService:getExpenseReceipts:reponse', data }))
      );
    }
  }
</code></pre>
","264607","","264607","","2019-06-14 17:24:58","2019-06-25 11:08:30","Combine latest value of observables AFTER every emission from source observable","<angular><rxjs><rxjs6>","2","4","1","","","CC BY-SA 4.0"
"56609155","1","56609261","","2019-06-15 09:35:35","","3","547","<p>Previously I was using rxjs-5 and I was using observable.partition as follows:</p>

<pre><code>const [isTiming$, isNotTiming$] = this.store.select(state =&gt; state.tetris.isTiming)
        .partition(value =&gt; value);
</code></pre>

<p>After upgrade <code>angular</code> to <code>8</code> <code>rxjs</code> got upgraded to <code>rxjs-6</code> which started throwing following error:</p>

<pre><code> providers/timer.provider.ts(27,5): error TS2339: Property 'partition' does not exist on type 'Observable&lt;boolean&gt;'.
</code></pre>

<p>when I checked in older rxjs implementation it was implemented as follows: </p>

<pre><code>  import { Observable } from '../Observable';
  import { partition as higherOrder } from '../operators/partition';
  /**
   * Splits the source Observable into two, one with values that satisfy a
   * predicate, and another with values that don't satisfy the predicate.
   */
   export function partition&lt;T&gt;(this: Observable&lt;T&gt;, predicate: (value: T, index: number) =&gt; boolean, thisArg?: any): [Observable&lt;T&gt;, Observable&lt;T&gt;] {
    return higherOrder(predicate, thisArg)(this);
  }
</code></pre>
","11584774","","","","","2019-06-15 10:11:34","error TS2339: Property 'partition' does not exist on type 'Observable<boolean>'","<angular><observable><rxjs5><rxjs6><angular8>","2","0","1","","","CC BY-SA 4.0"
"56626587","1","","","2019-06-17 07:26:27","","0","72","<p>I have some code that goes to my server and returns some data. I have noticed, that i am unable to catch/handle a 403 response.</p>

<p>Code:</p>

<pre><code>canActivate(route: ActivatedRouteRequest, state: RouterStateSnapshot): Observable &lt;boolean&gt; {

    return this.myService.getEntitlements()
        .pipe(
            map(data =&gt; {
                this.isEntitled = data.hasEntitlements;

                if(this.isEntitled === true) {
                    return true;
                }
                else {
                    return false;
                }
            }),
            catchError((err: any) =&gt; {
                return of(false);
            })       

        };
}
</code></pre>
","2244072","","","","","2019-06-17 07:26:27","Unable to handle 403 (forbidden) in RXJS pipe, map","<javascript><rxjs><http-status-code-403><rxjs6>","0","2","","","","CC BY-SA 4.0"
"56637378","1","","","2019-06-17 19:00:56","","1","64","<p>I'm following <a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/v6/migration.md"" rel=""nofollow noreferrer"">this migration guide</a> to update from <em>rxjs 5.5.5 to 6.</em>.**. 
It looks from this article and many other posts that simply having <em>rxjs-compat</em> in my project will allow to migrate step-by-step. Even worse it seems to work for everyone else. What I understand is that <em>rxjs-compat</em> will allow me to use both pipeable operators as well as Observable prototype operators. But either this is not the case with <em>rxjs-compat</em> or something is wrong.</p>

<p>So my expectation is for instance that I can use <em>map</em> in both forms when observable is imported from <code>rxjs</code>. But I get the following error <em>""error TS2339: Property 'map' does not exist on type 'Observable'.""</em>. Which of course means that typings are incorrect.</p>

<pre><code>import {of} from 'rxjs';
import {map} from 'rxjs/operators';

const arr$ = of([1, 2, 3, 4]);
arr$.map(x=&gt; console.log(x));
arr$.pipe(
    map(x =&gt; console.log(x))
);
</code></pre>

<p>I've tried different versions of typescript (<code>2.7.2</code>,<code>2.9.1</code>,<code>3.1.1</code>) also <em>rxjs</em> and <em>rxjs-compat</em> starting from <code>6.0.0</code> till the <code>latest</code> vesrion. Also tried playing with <em>tsconfig paths</em> and aliasing <em>rxjs to rxjs-compat</em> but its never enough.</p>

<p>So just tell me the truth, does it really support prototype operators. Do I need some additional config? some matching versions? anything?</p>

<p>I can provide additional info if needed (package.json, tsconfig, etc).</p>

<p><a href=""https://stackblitz.com/edit/typescript-pnaidg"" rel=""nofollow noreferrer"">this is setup</a> that can be downloaded for testing. Locally I just run <em>tsc index</em> and it fails</p>
","2740498","","2740498","","2019-06-17 19:13:12","2019-06-17 19:42:20","TS rxjs-compat doesn't support prototype operators?","<typescript><rxjs><rxjs6><rxjs-compat>","0","3","","","","CC BY-SA 4.0"
"56649187","1","","","2019-06-18 12:28:46","","0","168","<p>I am appending authorization header using interceptor. Now in interceptor I am also checking only for http error related to 401 i.e bad credentials which means the case when valid access token doensnot exist in the sever to access the resource. So if I get 401 error I am logging user out and redirecting to login page. Now for any other server related error I am catching in error block of service call inside component, and displaying appropriate message on UI. But it seems there is some problem when I logout the user via interceptor. The logout and redirect works fine but the screen goes unresponsive they way it becomes in case of javascript alert message.</p>

<p>component.ts :</p>

<pre><code> this.Servicefunction(arg).subscribe((Response: any) =&gt; {
        //somthing/
        }, (err: any) =&gt; {
            alert(""Server error occured"");
        });
</code></pre>

<p>Service.ts</p>

<pre><code>Servicefunction(arg): Observable&lt;any&gt; {
    let body = { ""arg"": arg }
    return this.httpClient.post(""http://xx.xx.xx:xx/CheckExistenceOfRecord', body);
}
</code></pre>

<p>interceptor.ts:</p>

<pre><code>import { Injectable } from ""@angular/core"";
import { HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpHeaders, HttpParams, HttpResponse, HttpErrorResponse } from ""@angular/common/http"";
import { Observable } from 'node_modules/rxjs';
import { CookieService } from 'ngx-cookie-service';
import { ActivatedRoute, Router } from '@angular/router';
import { AppComponent } from './app.component';
import { AuthService } from './route-auth';
import { map, catchError, filter, switchMap } from 'rxjs/operators'

@Injectable()
export class Interceptor implements HttpInterceptor {
  constructor(private cookieService: CookieService, private route: Router, private appComp: AppComponent,  private authService: AuthService) { }
  intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    const token: string = this.cookieService.get('authToken');
        const headers = new HttpHeaders().append('Authorization', token).append('Content-Type', 'application/json');
        const AuthRequest = request.clone({ headers: headers });
        return next.handle(AuthRequest).pipe(catchError((err: any, caught) =&gt; {
          if (err instanceof HttpErrorResponse) {
            if (err.status === 401) {
              console.info('err.error =', err.error, ';');
              this.authService.logout();
              this.route.navigateByUrl('');
              this.cookieService.deleteAll('/');
            }
            return Observable.throw(err);
          }
        }));
      }
  }
</code></pre>
","9040429","","9040429","","2019-06-19 06:41:30","2019-06-19 06:41:30","Error handling for authorized request in angular 6 using interceptor","<angular><angular6><rxjs6>","1","2","","","","CC BY-SA 4.0"
"56691676","1","","","2019-06-20 18:09:43","","4","4071","<p>In our Single Page Application we've developed a centralized store class that uses an RxJS behavior subject to handle the state of our application and all its mutation.  Several components in our application are subscribing to our store's behavior subject in order to receive any update to current application state.  This state is then bound to UI so that whenever state changes, UI reflect those changes.  Whenever a component wants to change a part of the state, we call a function exposed by our store that does the required work and updates the state calling next on the behavior subject.  So far nothing special.  (We're using Aurelia as a framework which performs 2 way binding)</p>

<p>The issue we are facing is that as soon as a component changes it's local state variable it receives from the store, other components gets updated even if next() wasn't called on the subejct itself.</p>

<p>We also tried to subscribe on an observable version of the subject since observable are supposed to send a different copy of the data to all subscriber but looks like it's not the case.</p>

<p>Looks like all subject subscriber are receiving a reference of the object stored in the behavior subject.</p>

<pre class=""lang-js prettyprint-override""><code>import { BehaviorSubject, of } from 'rxjs'; 

const initialState = {
  data: {
    id: 1, 
    description: 'initial'
  }
}

const subject = new BehaviorSubject(initialState);
const observable = subject.asObservable();
let stateFromSubject; //Result after subscription to subject
let stateFromObservable; //Result after subscription to observable

subject.subscribe((val) =&gt; {
  console.log(`**Received ${val.data.id} from subject`);
  stateFromSubject = val;
});

observable.subscribe((val) =&gt; {
  console.log(`**Received ${val.data.id} from observable`);
  stateFromObservable = val;
});

stateFromSubject.data.id = 2;
// Both stateFromObservable and subject.getValue() now have a id of 2.
// next() wasn't called on the subject but its state got changed anyway

stateFromObservable.data.id = 3;
// Since observable aren't bi-directional I thought this would be a possible solution but same applies and all variable now shows 3
</code></pre>

<p>I've made a stackblitz with the code above.
<a href=""https://stackblitz.com/edit/rxjs-bhkd5n"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-bhkd5n</a></p>

<p>The only workaround we have so far is to clone the sate in some of our subscriber where we support edition through binding like follow:</p>

<pre class=""lang-js prettyprint-override""><code>observable.subscribe((val) =&gt; {
  stateFromObservable = JSON.parse(JSON.stringify(val));
});
</code></pre>

<p>But this feels more like a hack than a real solution.  There must be a better way...</p>
","4801683","","4801683","","2019-06-20 18:19:36","2019-07-26 11:22:01","BehaviorSubject send the same state reference to all subscribers","<rxjs><aurelia><rxjs6>","3","4","1","","","CC BY-SA 4.0"
"56696407","1","56696434","","2019-06-21 03:16:09","","2","127","<p>I recently upgrade app from Angular 5 to Angular 8 and I change the imports
rxjs to match the new version of rxjs which is rxjs 6 now.</p>

<p>I have the following import statement:</p>

<pre><code>import { map, mergeMap, startWith, mergeMapTo } from 'rxjs/operators';
</code></pre>

<p>An I'm using it inside the component:</p>

<pre><code>public myObservable: any;

 myMethod() {

    this.myObservable = timer(1, 1000);
        this.myObservable
        .mergeMapTo(this.myService.loadData(this.myId))
        .subscribe((data) =&gt; {
                this.myData = data;                
            }, (errRes)=&gt;{
            console.log(errRes);
        });
  }
</code></pre>
","2304483","","","","","2019-06-21 03:20:32","Why I get mergeMapTo is not a function when using rxjs?","<angular><rxjs6><angular-observable>","1","0","","","","CC BY-SA 4.0"
"56710178","1","56733691","","2019-06-21 20:38:12","","2","200","<p>I have this sample code:</p>

<pre><code>interval(500).pipe(
  throttleTime(1000)
).subscribe(arg =&gt; {
  console.log(arg);
});
</code></pre>

<p>Which emits:</p>

<pre><code>0
3
6
...
</code></pre>

<p>I understand that it emits the latest value every 1000 milliseconds.  My problem is that it ignores the values that aren't the latest.  Is there an operator similar to throttleTime, but one that saves these ignored values?  I'd like it to emit:</p>

<pre><code>[0]
[1,2,3]
[4,5,6]
...
</code></pre>

<p>Edit: Ideally, I'd like something that listens to clicks of a button.  When the first click happens, the code starts a timer for N milliseconds.  The user can keep clicking during this time.  Once N milliseconds are up, the operator fires with an array holding all of the events that happened during those N milliseconds.</p>

<p>Super-ideally, I'd like the timer to reset everytime the user clicks the button.</p>
","2023861","","4554116","","2019-06-25 05:02:48","2019-06-25 05:02:48","Is there an RXJS operator similar to throttleTime, but one that doesn't ignore inermediate events?","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"56722117","1","56752931","","2019-06-23 08:10:11","","0","101","<p>Using these RxJS tools: BehaviorSubject, Subscribe and Next</p>

<p>Please refer to the this codesandbox, and look at the console to see a visual: <a href=""https://codesandbox.io/s/fancy-bird-0m81p"" rel=""nofollow noreferrer"">https://codesandbox.io/s/fancy-bird-0m81p</a></p>

<p>You will notice the object ""C"" value in the subscription is ""1 stream behind</p>

<p>Consider the the following code:</p>

<pre><code>const initialState = { a: 1, b: 2, c: 3 };

const Store$ = new BehaviorSubject(initialState);

const StoreUpdates$ = Store$.pipe(
  scan((acc, curr) =&gt; {
    return Object.assign({}, acc, curr);
  }, initialState),
  share()
);

export const updateStore = update =&gt; {
  Store$.next(update);
};

StoreUpdates$.pipe(
  distinctUntilChanged((p, n) =&gt; {
    return p.b === n.b;
  })
).subscribe(store =&gt; {
  Store$.next({ c: Math.random() });
});

StoreUpdates$.subscribe(store =&gt; {
  console.log(""Subscription Check:: Notice issue here"", store);
});
</code></pre>

<p>When you call the updateStore function, in the console.log you will notice that the C value, which is updated in a next call within a subscription, appears in the first iteration and the older value appears in the last iteration. So somehow it looks the next.call within the subscription happens ""Before""</p>

<p>I believe the codesandox will illustrate and make it more clear.</p>

<p><strong>How do I maintain the correct order of events so that the latest update appears last in the subscription?</strong></p>
","4088633","","","","","2019-06-25 11:21:54","RXJS: Subscription to share operator causes strange behaviour","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"56735044","1","","","2019-06-24 10:52:56","","1","835","<p>Consider an RxJs Operator Problem As </p>

<pre><code>//emit (1,2,3)
const source = Rx.Observable.of(1,2,3);
//start with 0
const example =  source.startWith(0);
//output: 0,1,2,3
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre>

<p>Now I want <strong>startWith()</strong> to be a result of a Promise. </p>

<pre><code>// - 1
var pr = new Promise((res, rej) =&gt; {
  setTimeout(() =&gt; res(-1), 1000);
});
</code></pre>

<p>Promise Errors to be caught in the Subscriptions error block.</p>

<p>The Final output should look like </p>

<pre><code>-1, 1, 2, 3
</code></pre>

<h2>------------------------------------------------</h2>

<p><strong>Attempt 1:</strong> I tried putting in the promise but it does not get resolved.</p>

<pre><code>const example =  source.startWith(pr);
</code></pre>

<p><strong>Attempt 2:</strong>: I tried using async await but was stuck with the try catch block.</p>
","7582534","","7582534","","2019-06-24 10:59:44","2019-09-26 18:29:43","Rx JS startsWith() operator resolves Promise's Result?","<angular><rxjs><rxjs6>","2","6","","","","CC BY-SA 4.0"
"56736757","1","56736894","","2019-06-24 12:36:01","","1","75","<p>I have a list of observables that needs to invoke APIs synchronously. The APIs fails for asynchronous operation. Hence an observable needs to wait for the previous observable to complete before executing, I have written a recursive solution as shown below, is there a better way to do it.</p>

<pre><code> private myMethod(params) {
    let paramsCopy = params.slice();
    let param = paramsCopy.shift();
    if (param) {
     let resource: ResourceModel= param.resource;
     return resource.doPost(JSON.stringify(param.data))
                    .pipe(mergeMap(res =&gt; {return myMethod(paramsCopy)})
                    ,catchError((err) =&gt; handleError()));
    } else { 
       return //completed actions;
    }
 } 
</code></pre>
","1994646","","1994646","","2019-06-24 12:43:51","2019-06-24 12:44:22","How to make observable wait for the previous observable to complete","<angular><rxjs6>","2","3","0","","","CC BY-SA 4.0"
"56749714","1","","","2019-06-25 08:21:14","","0","171","<p>I'm trying to share a Subject source across multiple functions that filter their actions and do appropriate tasks, the ones that are not filtered should fall trough without modifications. </p>

<p>I've tried merging same source but it doesn't really work the way I need it to... </p>

<pre><code>const source = new Subject()

source.next({ type: 'some type', action: {} })

merge(
  source,
  source.pipe(filter(...), do something),
  source.pipe(filter(...), do something),
  source.pipe(filter(...), do something),
  source.pipe(filter(...), do something),
).subscribe(...)
</code></pre>

<p>In this case I get original source + filtered ones.</p>

<p>I'm expecting to be able provide same source to multiple functions that can filter on types and do async behaviours, rest of the types that were not filtered should fall trough. Hope this is clear enough, or otherwise will try to make a better example. Thanks!</p>

<p><a href=""https://codesandbox.io/s/hungry-williamson-12owx"" rel=""nofollow noreferrer"">example here</a></p>
","2897609","","2897609","","2019-06-25 11:40:37","2019-06-26 18:49:16","How to share a single Subject source","<rxjs><rxjs6>","1","5","","","","CC BY-SA 4.0"
"56753422","1","56768441","","2019-06-25 11:50:49","","0","108","<p>I have a custom pipe, that is only a collection of multiple pipes. I, however, would like to test the code.</p>

<pre class=""lang-ts prettyprint-override""><code>export type AnnotatedResponse&lt;T&gt; = T &amp; {
    awaitingNewValues: boolean;
    failed: boolean;
};

function merge&lt;T&gt;(
    original: T,
    awaitingNewValues: boolean,
    failed: boolean,
): AnnotatedResponse&lt;T&gt; {
    return Object.assign({},
        original,
        { awaitingNewValues, failed },
    );
}

export function annotateAwaiting&lt;I, T extends {}&gt;(
    initialValue: T,
    toAnnotate: (input: I) =&gt; Observable&lt;T&gt;,
): (source: Observable&lt;I&gt;) =&gt; Observable&lt;AnnotatedResponse&lt;T&gt;&gt; {
    return (source: Observable&lt;I&gt;) =&gt; {
        let lastValue: T = initialValue;
        return source.pipe(
            switchMap(input =&gt; concat(
                of(merge(lastValue, true, false)),
                toAnnotate(input).pipe(
                    take(1),
                    map(result =&gt; {
                        lastValue = result;
                        return merge(result, false, false);
                    }),
                    catchError(() =&gt; {
                        return of(merge(lastValue, false, true));
                    }),
                ),
            )),
            finalize(() =&gt; {
                //  Free reference to prevent memory leaks
                lastValue = undefined as any;
            }),
        );
    };
}
</code></pre>

<p>The test</p>

<pre class=""lang-ts prettyprint-override""><code>fdescribe('annotateAwaiting$', () =&gt; {
    let subject: Subject&lt;string&gt;;
    let annotated: Observable&lt;AnnotatedResponse&lt;{ letter: string }&gt;&gt;;
    let response: Subject&lt;Error | { letter: string }&gt;;

    beforeEach(() =&gt; {
        subject = new Subject&lt;string&gt;();
        response = new Subject();
        annotated = subject.pipe(
            annotateAwaiting(
                { letter: '' },
                letter =&gt; response.pipe(
                    take(1),
                    map(val =&gt; {
                        if (val instanceof Error) {
                            throw val;
                        } else {
                            return val;
                        }
                    }),
                ),
            ),
            shareReplay(1),
        );
    });

    afterEach(() =&gt; {
        subject.complete();
        response.complete();
    });

    it('should emit immediately', () =&gt; {
        let i = 0;
        subject.next('a');
        annotated.pipe(
            take(1),
        ).subscribe(obj =&gt; {    //  Runs
            expect(obj.awaitingNewValues).toBe(true);
            expect(obj.failed).toBe(false);
            expect(obj.letter).toBe('');
            i++;
        });

        expect(i).toBe(1);

        response.next({ letter: 'a'});
        annotated.pipe(
            take(1),
        ).subscribe(obj =&gt; {    //  Doesn't run (neither async)
            expect(obj.awaitingNewValues).toBe(false);
            expect(obj.failed).toBe(false);
            expect(obj.letter).toBe('a');
            i++;
        });

        expect(i).toBe(2);
    });
});
</code></pre>

<p>What am I missing? Why it doesn't seem to run at all?</p>
","3001856","","","","","2019-06-26 08:27:43","Testing RXJS custom pipes","<unit-testing><testing><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"56762201","1","56762767","","2019-06-25 21:24:49","","-1","41","<p>i have following code written in rxjs5 and it broke with rxjs6</p>

<p>can some one help me with write in rxjs 6</p>

<p>its failing mergemap receiving groupedObserable which does not have count method and along also filter method does not exist.</p>

<pre><code>list [

{id: '1', type: 't1',  name: 'f1', des:'d1', selected: true},
{id: '2', type: 't1',  name: 'f2', des:'d2', selected: false},

{id: '3', type: 't1',  name: 'f11', des:'d11', selected: false},
{id: '4', type: 't1',  name: 'f22', des:'d22', selected: true},
]

Observable.from(list)
.filter(a =&gt; a.name != null)
.groupBy(i =&gt; i.type)
.mergeMap(list =&gt; {
let count = list.count;
let selectedCount = 0;
list.filter( f =&gt; f.selected).count.subscribe(c =&gt; selectedCount = c)
return count.map(count =&gt;  {
   {
     key: list.key,
     totalCount: count,
     selected: selectedCount
   }
}
}).reduce((x, y) =&gt; {
x.isValid = x.selectedCount &gt; 0 
return x;
}).subscribe(r =&gt; {
  console.log(r + 'any item selected')
}
)
</code></pre>

<p>when i tried to write in rxjs6 only progress i was able to made till here
thanks in advance.</p>

<pre><code>from(list)
    .pipe(
    filter( s=&gt; s.name != null) ,
    groupBy(i =&gt; i.type),
    mergeMap( (value, index) =&gt; {
      value.count // that's where it starts to fail
    }
    ))
</code></pre>
","216431","","","","","2019-06-26 16:17:00","convert rxjs5 operators into rxjs6","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"56832151","1","","","2019-07-01 08:15:01","","2","582","<p>It may be a stupid question to ask but i have created a interceptor where i catch if the response fails with code 401 and refresh token with an api. it is working fine but i also want to catch the error if for some reason the refresh token api also fails, here the code</p>

<pre><code>@Injectable()
export class TokenInterceptor implements HttpInterceptor {

    constructor(private authService: AuthService) { }

    isRefreshingToken: boolean = false;
    tokenSubject: BehaviorSubject&lt;string&gt; = new BehaviorSubject&lt;string&gt;(null);

    intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpSentEvent | HttpHeaderResponse | HttpProgressEvent | HttpResponse&lt;any&gt; | HttpUserEvent&lt;any&gt; | any&gt; {

        return next.handle(this.addTokenToRequest(request, this.authService.getJWT()))
            .pipe(
                catchError(err =&gt; {
                    if (err instanceof HttpErrorResponse) {
                        switch ((&lt;HttpErrorResponse&gt;err).status) {
                            case 401:
                                return this.handle401Error(request, next);
                            case 400:
                                return &lt;any&gt;this.authService.logout();
                        }
                    } else {
                        return throwError(err);
                    }
                }));
    }

    private addTokenToRequest(request: HttpRequest&lt;any&gt;, token: string): HttpRequest&lt;any&gt; {
        return request.clone({ setHeaders: { Authorization: `Bearer ${token}` } });
    }

    private handle401Error(request: HttpRequest&lt;any&gt;, next: HttpHandler) {

        if (!this.isRefreshingToken) {
            this.isRefreshingToken = true;

            // Reset here so that the following requests wait until the token
            // comes back from the refreshToken call.
            this.tokenSubject.next(null);

            return this.authService.refreshToken()
                .pipe(
                    switchMap((refreshToken: any) =&gt; {
                        console.log('here');
                        if (refreshToken) {
                            this.tokenSubject.next(refreshToken.token);
                            this.authService.setJWT(refreshToken.token);
                            this.authService.setRefreshToken(refreshToken.refreshToken);
                            // localStorage.setItem('currentUser', JSON.stringify(user));
                            return next.handle(this.addTokenToRequest(request, refreshToken.token));
                        }else{

                        }

                        return &lt;any&gt;this.authService.logout();
                    }),
                    catchError(err =&gt; {
                        console.log('here', err);
                        return &lt;any&gt;this.authService.logout();
                    }),
                    finalize(() =&gt; {
                        console.log('here');
                        this.isRefreshingToken = false;
                    })
                );
        } else {
            this.isRefreshingToken = false;

            return this.tokenSubject
                .pipe(filter(token =&gt; token != null),
                    take(1),
                    switchMap(token =&gt; {
                        return next.handle(this.addTokenToRequest(request, token));
                    }));
        }
    }
}
</code></pre>

<p>notice on the line where <code>return this.authService.refreshToken()</code> is called it does not reach to catchError if the <code>refreshToken()</code> fails</p>

<p>i understand that it may only reach to catchError when the original request will fail. so in the service i tried to catch the error from refresh token api, code below:</p>

<pre><code>refreshToken(): Observable&lt;any&gt; {
    let jwt = this.getJWT();
    let refreshToken = this.getRefreshToken();

    debugger;
    return this.http.post&lt;any&gt;(this.api.REFRESH_TOKEN, { refreshToken: refreshToken, expiredToken: jwt })
      .pipe(
        map(result =&gt; {
          console.log('here');
          debugger;
          return result;
        }),
        catchError(e =&gt; {
          debugger;
          console.log(e, 'here');
          return null;
        })
      );
  }
</code></pre>

<p>it does not even reach to that point if the refresh token api fails, my question is to how do i catch the error from refresh token api and redirect user to login.
Thanks.</p>
","2234630","","","","","2019-07-01 08:47:41","pipe catchError not working while refreshing the token in interceptor","<angular><ecmascript-6><interceptor><rxjs6>","1","1","","","","CC BY-SA 4.0"
"56846374","1","56851640","","2019-07-02 06:15:58","","-1","223","<p>I am getting this error after using api call. I am trying to fetch data from myjson api. Am i doing something wrong with the current implementation or Is there any better way to call the same api.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>import { createAction, handleActions } from 'redux-actions'
import { PLUGIN_NAME, STORE_MOUNT_POINT } from '../constants'
import { Epic,ofType } from 'redux-observable'
import { Store } from '../Store'
import { defer, of } from 'rxjs'
import { mergeMap } from 'rxjs/operators'
import { ajax } from '../util'

const fetchReportTemplate$: Epic&lt;Store.IFSA&gt; = (action$, state$) =&gt;
  action$.ofType(startFetchReportsTemplate.toString(),
      return  ajax(
          {
            url: 'https://api.myjson.com/bins/15dcd9',
            body: ''
          }
        )
      ).map(({ response: { data } }) =&gt; {
        return of(clearAllHttpErrors(), receiveReportsTemplateRows(data))
        })</code></pre>
</div>
</div>
</p>
","3124703","","3124703","","2019-07-02 13:11:07","2019-07-02 13:11:07","'Argument expression expected' error during ajax call in rxjs","<javascript><reactjs><react-redux><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"56880075","1","56997750","","2019-07-04 02:52:11","","0","62","<p>Users can fire off a search where I chain a variable number of HTTP requests using this approach: <a href=""https://stackoverflow.com/questions/44698649/angular-2-combine-three-http-calls-with-flatmap-rxjs"">Angular 2 combine three http calls with flatMap? RxJs?</a>.</p>

<p>That's all fine and dandy, but I want to cancel the old search if it's still running when they fire off a new one. Something like this:</p>

<ul>
<li>User starts Search A

<ul>
<li>Search A part 1 starts</li>
<li>Search A part 1 ends</li>
<li>Search A part 2 starts</li>
</ul></li>
<li>User starts Search B

<ul>
<li>Search B part 1 starts</li>
<li>Search B part 1 ends</li>
<li>Search B completes</li>
</ul></li>
<li>User sees results for B (B part 1)</li>
</ul>

<p>The closest I can find is <a href=""https://rxjs-dev.firebaseapp.com/api/operators/switchAll"" rel=""nofollow noreferrer"">switchAll</a> which does discard/cancel A part 2, but I'm getting A part 1 mixed into the results. Note: Only the last finished part is included, so if the user starts a new search during part <code>n</code>, then only <code>n - 1</code> is included (for <code>n &gt; 1</code>) and <code>n - 2</code> and prior are discarded.</p>

<p>So my questions:</p>

<ul>
<li><strong>Why are the intermediate results running together?</strong></li>
<li><strong>How do I achieve the effect I want?</strong>

<ul>
<li><strong>Can I discard the previous search's intermediate results?</strong></li>
<li><strong>Can I treat the searches as singular emissions?</strong></li>
</ul></li>
</ul>

<p>The code I've got is a bit messy, but here's a rough, simplified outline:</p>

<pre><code>// User fires this event.
startSearch() {
    this.searchSubject(getUsersCriteria());
}

ngOnInit() {
    // The event is transformed into a search request.
    this.searchSubject
        .asObservable()
        .pipe(
            map((criteria) =&gt; search(criteria)),
            switchAll(), // FIXME Not sufficient.
            tap((results) =&gt; this.setResults(results))
        )
        .subscribe();
}

/**
 * Execute the search and return the results.
 **/
search(criteria): Observable&lt;Result[]&gt; {
    return this.http.get('https://proprietary.com/endpoint', criteria)
        .pipe(flatMap((results) =&gt; {
            // Process results. Conditionally continue.
            if (done()) return of(results);
            else return search(criteria.nextCriteria())
                .pipe(map((moreResults) =&gt; [...results, ...moreResults]));
        });
}
</code></pre>

<p><em>Note: Presently using RxJS 6.</em></p>
","1680677","","1680677","","2019-07-08 15:51:50","2019-07-11 21:53:01","Ignore intermediate emissions of canceled Observable","<angular><rxjs><rxjs6>","2","4","","","","CC BY-SA 4.0"
"56888286","1","","","2019-07-04 12:46:25","","1","37","<p>I am currently experimenting with building a little app for helping my local roleplay group. Amongst the tools they wanted was a scriptable randomizer so that they could build dice roll tables. Unfortunately, I've hit a bit of a brick wall with regards to needing to recursively call a function with an Observable in it.</p>

<p>I've had a look through a few different questions on here and Reddit covering how to get results from Observables or wait for it to resolve but all the solutions I've tried either are invalid code in this context or the parent call doesn't wait for the child to resolve. This includes using map, switchMap and async/await. I'm left wondering if I'm wrong to be using an Observable for the file load on this.</p>

<p>Here's the full context in case the short example misses somehting: <a href=""https://github.com/Acaeris/draconika/blob/rolltable/src/app/providers/table.service.ts"" rel=""nofollow noreferrer"">https://github.com/Acaeris/draconika/blob/rolltable/src/app/providers/table.service.ts</a></p>

<p>In short:</p>

<pre class=""lang-js prettyprint-override""><code>@Injectable()
export class TableService {
  constructor(private http: HttpClient) {}

  get(tableId: string): Observable&lt;RollCollection&gt; {
    return this.http.get&lt;RollCollection&gt;('assets/tables/' + tableId + '.json')
      .pipe(
        catchError(this.handleError)
      );
  }

  // Roll a result from a given table or sub entry.
  roll(tableId: string, entryKey: string) {
    return this.get(tableId).pipe(
      map(data =&gt; {
        output = data[entryKey];
        parts = this.findParts(output);

        parts.forEach((part: string) =&gt; {
          if (part[1].includes('.')) {
            const splitPart = part[1].split('.');

            // Roll refers to an entry in another table.
            // This needs to finish before the return...
            this.roll(splitPart[0], splitPart[1]).toPromise()
              .then(rollOutput =&gt; output = output.replace(part[0], rollOutput));

          } else {
            // Process rolls for current file.
          }
        });

        return output;
      }
    );
  }

  private findParts(entry: string) {
    const regex = /\[([a-zA-Z.]*)\]/g;
    const parts: string[] = [];
    let m;

    do {
      m = regex.exec(entry);

      if (m) {
        parts.push(m);
      }
    } while (m);

    return parts;
  }
}
</code></pre>

<p>This is currently called in a component like so:</p>

<pre class=""lang-js prettyprint-override""><code>this.tableService.roll('heirloom').subscribe(
  data =&gt; this.output.push(data),
  error =&gt; console.log(error)
);
</code></pre>

<p>The heirloom.json table has some rolls that result in calls to [name.format] which should then roll the 'format' entry of the name.json file.</p>

<p>What I expect it to do is roll the result and replace the [name.format] part of the string from the heirloom roll.</p>

<pre class=""lang-js prettyprint-override""><code>this.tableService.roll('name', 'format').subscribe(
  data =&gt; this.output.push(data),
  error =&gt; console.log(error)
);
</code></pre>

<p>^ This will successfully return a generated name, and indeed the internal roll will also result in a name but it applies too late for the output and so the component receives the result before it's finished.</p>

<p>What I'm currently getting is: ""The heirloom is a helmet that once belonged to [name.format]"" instead of ""The heirloom is a helmet that once belonged to Lady Amberline Dawnstrider""</p>
","3274779","","3274779","","2019-07-09 17:04:08","2019-07-09 17:04:08","Is there a way to wait for the result of an Observable called within another Observable?","<angular><rxjs><electron><rxjs6><angular8>","0","0","","","","CC BY-SA 4.0"
"56947479","1","56948036","","2019-07-09 07:33:44","","0","484","<p>I have a 'get' call that returns a list of users that contains a user id and a name.
After the call succeeded, I need to call another rest for <em>each</em> user to bring his picture.</p>

<p>Currently I am doing this in this way-</p>

<p>component-</p>

<pre><code>users;
userPhotos = {};

constructor(private dashboardService: DashboardService) {
  this.dashboardService.bringUsers().subscribe((data) =&gt;{
    this.users = data;
    this.users.forEach((user) =&gt; {
      this.dashboardService.getPicture(user.userID).subscribe((data) =&gt; {
        if (data){
          this.userPhotos[user.userID] = window.URL.createObjectURL(data);
        } else {
          this.userPhotos[user.userID] = '';
        }
      });
    });
  });
}
</code></pre>

<p>In my html-</p>

<pre><code>&lt;ng-container *ngFor=""let user of users""&gt;
  &lt;div&gt;
      {{user.displayName}}
  &lt;/div&gt;

  &lt;display-picture [image]=""userPhotos[user.userID]""&gt;&lt;/display-picture&gt;
&lt;/ng-container&gt;
</code></pre>

<p>Where display-picture is a component that just presents the image.</p>

<p>Is there any efficient way using rxjs to do it?</p>
","10122561","","9974904","","2019-07-09 07:58:59","2019-07-09 09:44:05","angular 5 - loop of observers inside an other observer - efficient way to do it","<javascript><angular><typescript><rxjs><rxjs6>","2","6","","","","CC BY-SA 4.0"
"56960256","1","","","2019-07-09 20:42:49","","0","113","<p>I am using the <code>defer</code> to convert a promise (<code>getAuthToken</code>) to an observable. Then using <code>subscribe</code> to assign the <code>token</code> variable to the response. </p>

<p>*new to observables, but tried as long as I could alone</p>

<p>I've tried using <code>from</code> to convert the promise, although not really a solution to the problem, but did try using it. Also used pipe(map())...</p>

<p>I am referring to this <a href=""https://itnext.io/javascript-promises-vs-rxjs-observables-de5309583ca2"" rel=""nofollow noreferrer"">article</a> that explains the observables should be synchronous. Although my example does not seem to act that way.</p>

<pre class=""lang-js prettyprint-override""><code>getFakeConfig() {
  const token = defer(getAuthToken).subscribe(res =&gt; {
    console.log('res =', res)
    return res
  })

  console.log('token =', token)

  return {
    headers: {
      'content-type': 'application/json',
      Authorization: `${token}`,
    },
  }
}

makeRequest() {
  const config = this.getFakeConfig()
  console.log('config =', config)
}

</code></pre>

<pre class=""lang-js prettyprint-override""><code>// in a different file, basically what it does
export const getAuthToken = () =&gt; {
  return axios(options)
    .then(response =&gt; response.data.token)
}
</code></pre>

<p>Hitting <code>makeRequest()</code> outputs:</p>

<pre><code>token = Subscriber {
  ...
}

config = {
  headers: {
    'content-type': 'application/json',
    Authorization: '[object Object]'
  }
}

res = token234234234
</code></pre>

<p>I expect it to output:</p>

<pre><code>res = token234234234

token = token234234234

config = {
  headers: {
    'content-type': 'application/json',
    Authorization: 'token234234234'
  }
}
</code></pre>
","9958411","","9958411","","2019-07-09 20:48:03","2019-07-09 23:10:30","Observable not acting synchronously","<typescript><promise><rxjs><axios><rxjs6>","2","3","","","","CC BY-SA 4.0"
"56967516","1","","","2019-07-10 09:23:05","","0","30","<p>I'm implementing an angular interceptor service which looks for error and shows a snackbar, now I'm trying to add functionality to handle ""No internet"" or ""Slow Internet"". I tried with timeout operator but after the timeout, the HTTP call is canceled but my requirement is to notify the user that their internet is slow and then maybe cancel after some time, so I need the timeout operator to trigger a function rather than triggering an error </p>

<p>This is my code</p>

<pre><code>
  intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

    request = request.clone({

      setHeaders: {
        Authorization: `Bearer ${this.user.getToken()}`
      }
    });

    return next.handle(request).timeout(8000)
      catchError((error) =&gt; {
        console.log(error)
        console.log(error.name)
        if(error.name == 'TimeoutError'){
          this.alert.snack('Your Internet seems to be very slow','OK',4000)
          this.alert.showSlowInternet()

        }
        else if(error.error.detail === ""Given token not valid for any token type""){
          this.global.refresh(this.router.url)
        }
        else if(error.error.detail === ""No Connectivity""){
          this.alert.dismissableSnack('No Connectivity detected','DISMISS',)
        }
        else if(error.error.detail){
        this.alert.snack(error.error.detail,'OK')
        }

        else{
            this.alert.snack('Server not responding','OK')
        }
          return throwError(error);
      })
  }
</code></pre>
","10773800","","","","","2019-07-10 09:23:05","Can rxjs timeout operator trigger a function instead of returning error and cancelling the http call","<angular><rxjs><rxjs6><angular-http-interceptors><angular-httpclient-interceptors>","0","2","","","","CC BY-SA 4.0"
"56968005","1","57022943","","2019-07-10 09:48:18","","2","847","<p>I have a stream of files and I want to fill additional information about it, but I would like to present the currently obtained data to the user, as it is all that is initially visible anyway.</p>

<p>I want observable that: </p>

<ul>
<li>Get cancelled on new emission (like <code>switchMap</code>)</li>
<li>Does not wait for the observable to finish before emitting (like <code>tap</code>)</li>
</ul>

<p>What I have currently is awaiting the result, before emitting the files.</p>

<p>Set-up &amp; current try itteration:</p>

<pre><code>this.pagedFLFiles = fileService.getFiles().pipe(
    switchMap(response =&gt; concat(
        of(response),
        fileService.getAdditionalInfo(response.items).pipe(
            switchMap(() =&gt; EMPTY),
        ),
    )),
    shareReplay(1),
);
</code></pre>

<p><code>fileService.getAdditionalInfo(response.items)</code> - it is modifing the data</p>

<pre><code>getAdditionalInfo(files: FLFile[]): Observable&lt;FLFile[]&gt; {
    return this.api.getWithToken(token =&gt; {
        return { path: `v5/user/${token}/files/${files.map(file =&gt; file.id).join(',')}}/facilities` };
    }).pipe(
        map(information =&gt; {
            files.forEach(file =&gt; {
                const info = information[file.id];
                (Object.entries(info) as [keyof typeof info, any][]).forEach(([key, value]) =&gt; {
                    file[key] = value;
                });
            });
            return files;
        }),
    );
}
</code></pre>
","3001856","","","","","2019-07-13 21:23:32","RXJS switchmap + tap like operator","<rxjs><rxjs6>","1","0","2","","","CC BY-SA 4.0"
"56997261","1","57006444","","2019-07-11 21:02:17","","1","290","<p>I am working on a project where parents and children need to  communicate via service. Following <a href=""https://angular.io/guide/component-interaction#parent-and-children-communicate-via-a-service"" rel=""nofollow noreferrer"">this article</a> in the official documentation I am not able to make it work.</p>

<p>This is the service I created:</p>

<pre><code>import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';

@Injectable()
export class CommonService {
    private _propertyChangeAnnouncedSource = new Subject&lt;string&gt;();
    propertyChangeAnnounced$ = this._propertyChangeAnnouncedSource.asObservable();

    public announcePropertyChange(data: string) {
        this._propertyChangeAnnouncedSource.next(data);
    }
}
</code></pre>

<p>In the parent component, I import all I need:</p>

<pre><code>@Component({
    selector: 'app-parent',
    templateUrl: './parent.component.html',
    styleUrls: ['./parent.component.scss'],
    providers: [CommonService]
})
export class ParentComponent implements OnInit {

    constructor(private _commonService: CommonService) {

    }

    tellChild(data): void {
        this._commonService.announcePropertyChange(data);
    }

}
</code></pre>

<p>This is the child's code:</p>

<pre><code>@Component({
    selector: 'app-child',
    templateUrl: './child.component.html',
    styleUrls: ['./child.component.scss']
})
export class ChildComponent implements OnInit, OnDestroy {
    private subscription: Subscription;

    constructor(private _commonService: CommonService) {
        this.subscription = this._commonService.propertyChangeAnnounced$.subscribe(
            data =&gt; {
                console.log(data);
          });
    }
}
</code></pre>

<p>When I call the announcePropertyChange the child is not responding. Any suggestion?</p>

<p>Thanks!</p>
","2064999","","2064999","","2019-07-12 18:47:37","2019-07-12 18:47:37","Communication via service isn't working Angular 8","<angular><rxjs6>","2","2","1","","","CC BY-SA 4.0"
"57007118","1","57009988","","2019-07-12 12:32:30","","11","4606","<p>To avoid Observable memory leaks inside Components, I am using <code>takeUntil()</code> operator before subscribing to Observable.</p>

<p>I write something like this inside my components:</p>

<pre><code>private unsubscribe$ = new Subject();

ngOnInit(): void {
  this.http
    .get('test')
    .pipe(takeUntil(this.unsubscribe$))
    .subscribe((x) =&gt; console.log(x));
}

ngOnDestroy(): void {
  this.unsubscribe$.next();
  this.unsubscribe$.complete(); // &lt;--- ??
}
</code></pre>

<p>Finally my question is following:</p>

<p><strong>Do I need to write <code>this.unsubscribe$.complete();</code> or <code>next()</code> is enough?</strong></p>

<p><strong>Is <code>unsubscribe$</code> going to be grabbed by garbage collector without completing?</strong></p>

<p>Please explain is there difference or doesn't matter. I don't want memory leaks in my components.</p>
","8578281","","8578281","","2019-07-12 13:14:18","2020-04-19 17:55:30","Do I need to `complete()` takeUntil Subject inside ngOnDestroy?","<angular><typescript><rxjs><rxjs6>","3","3","7","","","CC BY-SA 4.0"
"57008861","1","","","2019-07-12 14:18:06","","1","164","<p>I understand the difference between ShareReplay and PublishReplay but in my following example I could use some clarification why a PublishReplay shortly after a previous PublishReplay does not emit any events but ShareReplay does. </p>

<p>I have an Angular service which provides some API data to several components. I use publishReplay to multicast the data to the components without refetching the data several times, and it is cleaned up once all of the components unsubscribe. </p>

<pre><code>@Injectable()
export class APIService {

  data = this.http.get(url).pipe(
      publishReplay(1)
  );
}
</code></pre>

<p>The components build FormControls once they receive the data event, and still use the raw data in the html hence the tap</p>

<pre><code>@Component()
export class SomeComponent {

  data = this.apiService.data.pipe(
      tap((data) =&gt; buildControls(data))
  );
}
</code></pre>

<p>In a few instances I need to create some observables from the formControls after they have been built. I need to multicast this otherwise the formControls are rebuilt on each subsequent subscription and don't bind properly.</p>

<pre><code>@Component()
export class SomeComponent {

  data = this.apiService.data.pipe(
      tap((data) =&gt; buildControls(data)),
      shareReplay(1) // PublishReplay does not work here
  );

  someObservable = this.data.pipe(
    switchMap(() =&gt; buildLinkedControls())
  );
}
</code></pre>

<p>In the component example above, why does PublishReplay not fire any events, yet shareReplay does. Is there any danger to using shareReplay here, since the buffer will live on?</p>

<p>For completeness below is an simple example of the html</p>

<pre><code>&lt;ng-container *ngIf=""(data | async)?.properties as props""&gt;
   &lt;input *ngIf=""props?.someInput"" [formControl]=""formGroup.get('someInput')""&gt;
    ...
   &lt;div&gt;{{ someObservable | async }}&lt;/div?
&lt;/ng-container&gt;
</code></pre>
","1750067","","1750067","","2019-07-12 14:58:01","2019-07-12 14:58:01","RxJS ShareReplay and PublishReplay","<angular><rxjs6>","0","1","","","","CC BY-SA 4.0"
"57020431","1","57054479","","2019-07-13 15:21:09","","3","1384","<p>So I have a stream of, let's say letters, and I need all letters in the right order to put them together into a word. Everything works fine until the user changes tab, minimize browser or switches application - behavior is almost the same as if I was using <code>setTimeout()</code> - messed up the order, lost items, etc. I tried to achieve my goal by using <code>bufferWhen()</code>, <code>bufferToggle()</code>, <code>takeUntil()</code>, <code>publish()</code> and <code>connect()</code> but nothing succeeded. I considered to use <code>delayWhen</code> as well, but it's deprecated and probably not suitable as it stops the stream immediately. Which functions should I use and how? Here's my code:</p>

<pre class=""lang-js prettyprint-override""><code>export class MyComponent implements AfterViewInit {
  private visibilityChange$ = fromEvent(document, 'visibilitychange').pipe(startWith('visible'), shareReplay({ refCount: true, bufferSize: 1 }));
  private show$ = this.visibilityChange$.pipe(filter(() =&gt; document.visibilityState === 'visible'));
  private hide$ = this.visibilityChange$.pipe(filter(() =&gt; document.visibilityState === 'hidden'));

  public ngAfterViewInit() {
    const lettersStream$ = zip( // add delay for each letter
            from(['w', 'o', 'r', 'd']),
            interval(1000))
           // pause when hide$ fires, resume when show$
          .pipe(map(([letter, delayTime]) =&gt; letter))
          .subscribe(console.log);
  }
}
</code></pre>

<p>I made a demo on <a href=""https://stackblitz.com/edit/typescript-ohkzkm?file=index.ts"" rel=""nofollow noreferrer"">stackblitz</a> - all I want is to see (stop writing when the tab is inactive) how the phrase is written on the screen.</p>
","3159399","","3159399","","2019-07-13 18:30:07","2019-09-02 10:03:49","RxJS 6 Pause or buffer observable when the page is not active","<angular><typescript><asynchronous><rxjs><rxjs6>","2","7","1","","","CC BY-SA 4.0"
"57020853","1","","","2019-07-13 16:18:36","","0","388","<p>Created a generic httpServie for all calls.</p>

<pre><code>  export class HttpApiService {
    constructor( private httpClient: HttpClient) {}
    public getData&lt;T&gt;(url: string, headers?: HttpHeaders): Observable&lt;T&gt; | Observable&lt;any&gt; {
        this.customReqOptions = this.getHeaders(headers);
        return this.httpClient.get(`${this.endPoint}${url}`, { headers: this.customReqOptions});
    }
  }
</code></pre>

<p>Calling it from UserSevice</p>

<pre><code>export class UserService {
    constructor(private httpApi: HttpApiService) {
    }

    public getUsers(): Observable&lt;any&gt;{
      return this.httpApi.getData('users')
      .pipe(
        tap((res) =&gt; {console.log('res,',res)}),
        publishReplay(1),
        refCount()
      );
    }
}
</code></pre>

<p>The pipe () one giving error TS2554: Expected 0 arguments, but got 3.</p>

<p>Created a code for ref: <a href=""https://stackblitz.com/edit/anglearn"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/anglearn</a></p>

<p>Even when run in VS code getting same issue
<a href=""https://i.stack.imgur.com/7uoua.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7uoua.png"" alt=""enter image description here""></a></p>

<p>What I am missing ?
Although using the latest version @angular: v8, rxjs: 6.4 using ngcli.</p>
","3456481","","","","","2019-07-13 17:25:47","Angular Error_for_TS2554 Expected 0 arguments, but got 3","<angular><rxjs6><angular8>","2","0","","","","CC BY-SA 4.0"
"57045892","1","","","2019-07-15 19:13:04","","6","2038","<h1>The abstract problem</h1>
<p>Is there any way to consume the result of a <code>mergeMap</code> in the original order of the outer observable, while still allowing the inner observables to run in parallel?</p>
<hr />
<h2>More detailed explanation</h2>
<p>Let's look at two merge-mapping operators:</p>
<ul>
<li><p><a href=""https://rxjs.dev/api/operators/mergeMap"" rel=""nofollow noreferrer""><code>mergeMap</code></a></p>
<p>...which takes a mapping callback, and a number of how many inner observables may run concurrently:</p>
  <pre class=""lang-js prettyprint-override""><code>  of(1, 2, 3, 4, 5, 6).pipe(
      mergeMap(number =&gt; api.get('/double', { number }), 3)
  );
</code></pre>
<p><strong>See it here in action</strong>: <a href=""https://codepen.io/JosephSilber/pen/YzwVYNb?editors=1010"" rel=""nofollow noreferrer"">https://codepen.io/JosephSilber/pen/YzwVYNb?editors=1010</a></p>
<p>This will fire off 3 parallel requests for <code>1</code>, <code>2</code> and <code>3</code>, respectively. As soon as one of those requests completes, it'll fire off another request for <code>4</code>. And so on and so forth, always maintaining 3 concurrent requests, until all of the values have been processed.</p>
<p>However, since previous requests may complete before subsequent requests, the values produced may be out of order. So instead of:</p>
  <pre class=""lang-js prettyprint-override""><code>  [2, 4, 6, 8, 10, 12]
</code></pre>
<p>...we may actually get:</p>
  <pre class=""lang-js prettyprint-override""><code>  [4, 2, 8, 10, 6, 12] // or any other permutation
</code></pre>
</li>
<li><p><a href=""https://rxjs.dev/api/operators/concatMap"" rel=""nofollow noreferrer""><code>concatMap</code></a></p>
<p>...enter <code>concatMap</code>. This operator ensures that the observables are all concatenated in the original order, so that:</p>
  <pre class=""lang-js prettyprint-override""><code>  of(1, 2, 3, 4, 5, 6).pipe(
      concatMap(number =&gt; api.get('/double', { number }))
  );
</code></pre>
<p>...will always produce:</p>
  <pre class=""lang-js prettyprint-override""><code>  [2, 4, 6, 8, 10, 12]
</code></pre>
<p><strong>See it here in action</strong>: <a href=""https://codepen.io/JosephSilber/pen/OJMmzpy?editors=1010"" rel=""nofollow noreferrer"">https://codepen.io/JosephSilber/pen/OJMmzpy?editors=1010</a></p>
<p>This is what we want, but now <em>the requests won't run in parallel</em>. As <a href=""https://rxjs.dev/api/operators/concatMap"" rel=""nofollow noreferrer"">the documentation</a> says:</p>
<blockquote>
<p><code>concatMap</code> is equivalent to <code>mergeMap</code> with <code>concurrency</code> parameter set to <code>1</code>.</p>
</blockquote>
</li>
</ul>
<p><strong>So back to the question</strong>: is it possible to get the benefits of <code>mergeMap</code>, whereby a given amount of requests can be run in parallel, while still having the mapped values be emitted in the original order?</p>
<hr />
<h1>My concrete problem</h1>
<p>The above described the problem in abstract. It is sometimes easier to reason about a problem when you know the actual problem at hand, so here goes:</p>
<ol>
<li><p>I have a list of orders that have to be shipped:</p>
 <pre class=""lang-js prettyprint-override""><code> const orderNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
</code></pre>
</li>
<li><p>I have a <code>shipOrder</code> method that actually ships the orders. It returns a <code>Promise</code>:</p>
 <pre class=""lang-js prettyprint-override""><code> const shipOrder = orderNumber =&gt; api.shipOrder(orderNumber);
</code></pre>
</li>
<li><p>The API can only process up to 5 order shipments simultaneously, so I'm using <code>mergeMap</code> to handle that:</p>
 <pre class=""lang-js prettyprint-override""><code> from(orderNumbers).pipe(
     mergeMap(orderNumber =&gt; shipOrder(orderNumber), 5)
 );
</code></pre>
</li>
<li><p>After an order is shipped, we need to print its shipping label. I have a <code>printShippingLabel</code> function that, given the order number of a shipped order, will print its shipping label. So I subscribe to our observable, and print the shipping labels as the values come in:</p>
 <pre class=""lang-js prettyprint-override""><code> from(orderNumbers)
     .pipe(mergeMap(orderNumber =&gt; shipOrder(orderNumber), 5))
     .pipe(orderNumber =&gt; printShippingLabel(orderNumber));
</code></pre>
</li>
<li><p>This works, but <strong>now the shipping labels are printed out of order</strong>, since <code>mergeMap</code> emits values based on when <code>shipOrder</code> completes its request. What I want is for <strong>the labels to print in the same order as the original list</strong>.</p>
</li>
</ol>
<p>Is that possible?</p>
<hr />
<h2>Visualization</h2>
<p>See here for a visualization of the problem: <a href=""https://codepen.io/JosephSilber/pen/YzwVYZb?editors=1010"" rel=""nofollow noreferrer"">https://codepen.io/JosephSilber/pen/YzwVYZb?editors=1010</a></p>
<p>You can see that earlier orders are being printed before later orders are even shipped.</p>
","825568","","825568","","2020-06-23 14:50:03","2020-06-25 17:56:35","RxJS mergeMap() with original order","<javascript><rxjs><rxjs6><rxjs-pipeable-operators>","3","1","3","","","CC BY-SA 4.0"
"57051334","1","57054094","","2019-07-16 06:36:37","","9","547","<p>I was checking RxJS api documents. I always face problem in understanding the weird syntax written on the top, Which is like below as an example:</p>

<pre><code>combineLatest&lt;O extends ObservableInput&lt;any&gt;, R&gt;(...observables: (O | ((...values: ObservedValueOf&lt;O&gt;[]) =&gt; R) | SchedulerLike)[]): Observable&lt;R&gt;
</code></pre>

<p>I wanted to understand this kind of syntax and further write it by my own. </p>

<p><strong>So, It will be great help if anyone explain what's going on in above example.</strong></p>
","5306974","","5306974","","2019-07-16 08:35:20","2019-07-16 15:20:51","How to understand complicated typescript generic types?","<angular><reactjs><typescript><rxjs6><typescript-generics>","1","2","2","","","CC BY-SA 4.0"
"57059666","1","57097217","","2019-07-16 14:30:26","","12","1281","<p>I have read the <a href=""https://rxjs-dev.firebaseapp.com/api/operators/throttleTime"" rel=""noreferrer"">throttleTime documentation</a>, but I don't get the operator fully.</p>

<p>I know how <code>throttleTime(1000)</code> works. After an event arrives it will skip all subsequent events for 1 second and then start this process again.</p>

<p>What I have trouble to understand is how exactly <code>ThrottleConfig</code> works, which is the third parameter of the operator.</p>

<pre><code>throttleTime&lt;T&gt;(
  duration: number, 
  scheduler: SchedulerLike = async, 
  config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction&lt;T&gt;
</code></pre>

<p><strong>How do <code>leading</code> and <code>trailing</code> properties change the functionality of the source Observable?</strong></p>

<p>I have read many documentations but they don't clearly explain this.</p>

<p>So there are four options:</p>

<ol>
<li><code>{ leading: true, trailing: false }</code>:<br>
default option, after receiving event skips other events for specified duration and then repeat.</li>
<li><code>{ leading: false, trailing: true }</code>:<br>
???</li>
<li><code>{ leading: false, trailing: false }</code>:<br>
Tested this and the Observable doesn't emit anything at all.</li>
<li><code>{ leading: true, trailing: true }</code>:<br>
???</li>
</ol>
","8578281","","9423231","","2019-07-18 15:39:05","2021-05-28 11:25:07","How does throttleTime operator's config parameter work? (ThrottleConfig)","<javascript><typescript><rxjs><rxjs6>","3","0","1","","","CC BY-SA 4.0"
"57065724","1","57065884","","2019-07-16 21:33:46","","3","1245","<p>I have an observable stream set up as below. I have an interval that is polling every two seconds. I then switchMap that to make two dependent API calls (mocked here with 'of's). After, I want to use distinctUntilChanged to make sure the final object is different. The only thing is that distinctUntilChanged doesn't fire.</p>

<p>I'm assuming it has SOMETHING to do with the fact that we are creating new streams and therefore never collects two objects to compare, but I don't fully understand.</p>

<pre><code>interval(2000).pipe(
    switchMap(() =&gt; loadData()),
  )
  .subscribe(res =&gt; console.log(res)); // { name: 'test' } is printed every two seconds

function loadData() {
  return of('API call').pipe(
     mergeMap(numb =&gt; of({ name: 'test' })),
     distinctUntilChanged((prev, cur) =&gt; {
       console.log('CompareFn'); // This will never fire.
       return JSON.stringify(prev) === JSON.stringify(cur)})
  );
}
</code></pre>

<p>Stackblitz: <a href=""https://stackblitz.com/edit/rxjs-ko6k3c?devtoolsheight=60"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-ko6k3c?devtoolsheight=60</a></p>

<p>In this case, I would like there to only be a single value ever printed from the next handler as distinctUntilChanged should stop all values after the first.</p>

<p>Would appreciate an explanation as to why this isn't working as I would expect it to.</p>
","7892913","","7892913","","2019-07-16 21:41:32","2019-07-16 21:49:06","distinctUntilChanged in nested pipe with switchMap","<rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57082131","1","","","2019-07-17 18:23:52","","1","886","<p>When composing Observables ShareReplay is not working as expected. The following is a simple example.</p>

<pre><code>apiData = this.api.get(url).pipe(
  tap(() =&gt; console.log('Data Fetched')),
  shareReplay(1)
);

work = this.apiData.pipe(
  tap(() =&gt; console.log('Building Controls')),
  tap((data) =&gt; this.buildControls(data)),
  shareReplay(1)
);

dataBasedOncontrols = this.work.pipe(
  tap(() =&gt; console.log('Computed Data')),
  switchMap(() =&gt; this.controlDataStream())
);
</code></pre>

<p>In my .html both <code>work</code> and <code>dataBasedOncontrols</code> are subscribed to via the async pipe. The console output is </p>

<pre><code>Data Fetched
Building Controls
Building Controls &lt;- This shouldn't happen
Computed Data
</code></pre>

<p>Shouldn't the <code>ShareReplay</code> on the <code>work</code> Observable prevent the two tap functions from being executed twice? If I remove the element subscribing to <code>dataBasedOncontrols</code> I get the expected behavior. Additionally, when I add a second pipe async element to the work observable I get the duplicated behavior which leads me to believe the <code>ShareReplay(1)</code> isn't working properly. </p>

<p>Can someone explain what is going on why <code>buildControls(data)</code> in the <code>work</code> Observable is being executed twice. </p>
","1750067","","","","","2019-07-18 23:46:49","RxJS Chained ShareReplay doesn't multicast properly","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57085555","1","","","2019-07-18 00:24:50","","1","1234","<p>I have an array of type BehaviourSubject defined and initialized in service and it gets updated upon editing it using another function. However, the results displayed on the UI are not of the new edited array but the changes are successfully applied to the external database on a server.</p>

<p>I have tried many online solutions but still, it won't work.</p>

<p>Here is the code for the Array initialization in the service named 'ServicesService'.</p>

<pre><code>private _nationalProps: BehaviorSubject&lt;NationalProp[]&gt; = new BehaviorSubject&lt;NationalProp[]&gt;([]);
</code></pre>

<p>Here is the function in the service to access the array as an observable;</p>

<pre><code>get national() {
    return this._nationalProps.pipe(take(1), map(nprops =&gt; {
      return [...nprops];
    })
    );
</code></pre>

<p>}</p>

<p>Here is the function in the service for deleting one element in the array. First, it deletes it on the server than on the local array.</p>

<pre><code>deleteNationalProp(id: string) {
    return this.http.delete(this.serverUrl + `/national_props/${id}.json`)
          .pipe(
          switchMap(() =&gt; {
            return this._nationalProps;
          }),
          take(1),
          tap(props =&gt; {
      this._nationalProps.next(props.filter(b =&gt; b.id !== id));
    }));
  }
</code></pre>

<p>This is the code in another component where I subscribe to the BehaviourSubject to keep track of any changes;</p>

<pre><code>propSub: Subscription; // imported from rxjs
loadedProps: NationalProp[];

ngOnInit() {
 this.propSub = this.servicesSrv.national.subscribe(props =&gt; {
      this.loadedProps = props;
    });
</code></pre>

<p>I call the delete method in the service to remove one element using this function;</p>

<pre><code>this.servicesSrv.deleteNationalProp(pId).subscribe();
</code></pre>

<p>What I expected was that once I delete an element from the array it should also be removed from the list on the UI without having to refresh the page or revisit the page but this does not seem to work.</p>

<p>I will appreciate your help on how to solve this.</p>
","10176181","","9088454","","2019-07-18 05:47:40","2019-07-19 00:33:52","Rxjs Behavior subject not updating data on the UI using ionic 4 and angular 7","<angular><typescript><behavior><rxjs6><subject-observer>","2","0","1","","","CC BY-SA 4.0"
"57115305","1","57115528","","2019-07-19 15:12:35","","1","1091","<p>I've run into an interesting issue where my Angular Guard doesn't seem to do anything when I try to redirect in cases where the user is trying to access routes that they shouldn't be.</p>

<p>As you can see, I've placed console.log calls throughout the process and I see the messages I'd expect, but the navigation never occurs and the originally requested page loads like normal.  This has really got me stumped - any help would be much appreciated!</p>

<p><strong>The Guard</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// angular dependencies
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, UrlTree, Router } from '@angular/router';

// rxjs utils
import { Observable } from 'rxjs';
import { take, map, tap } from 'rxjs/operators';

// service(s)
import { AuthService } from './services/auth/auth.service';

// interface(s)
import User from './interfaces/user.interface';

@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {

    constructor(private _authService: AuthService, private _router: Router) { }

    canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable&lt;boolean | UrlTree&gt; | Promise&lt;boolean | UrlTree&gt; | boolean | UrlTree {
        const url = state.url;
        console.log('Auth Guard hit', { url: url });

        return this._authService.user.pipe(
            take(1),
            map(user =&gt; {
                console.log(user);
                return !!user;
            }),
            tap(authenticated =&gt; {
                console.log(`Authenticated: ${authenticated}`);
                // not authenticated
                if (!authenticated) {
                    // accessing sign in or sign up pages
                    if (['/login', '/register'].includes(url)) {
                        console.log('Allow through');
                        return true;
                    }
                    // accessing application
                    else {
                        console.log('Should bounce to login');
                        return this._router.createUrlTree(['/login']);
                    }
                }
                // authenticated
                else {
                    // accessing sign in or sign up pages
                    if (['/login', '/register'].includes(url)) {
                        console.log('Should bounce to dashboard');
                        return this._router.createUrlTree(['/dashboard']);
                    }
                    // accessing application
                    else {
                        console.log('Allow through');
                        return true;
                    }
                }
            })
        );
    }

}</code></pre>
</div>
</div>
</p>

<p><strong>AuthService</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// angular dependencies
import { Injectable } from '@angular/core';

// firebase dependencies
import { AngularFireAuth } from '@angular/fire/auth';
import { AngularFirestore } from '@angular/fire/firestore';

// RXJS helpers
import { Observable, of } from 'rxjs';
import { switchMap } from 'rxjs/operators';

// interfaces
import User from '../../interfaces/user.interface';

@Injectable({ providedIn: 'root' })
export class AuthService {
    public user: Observable&lt;User&gt; = null;

    constructor(private _auth: AngularFireAuth, private _firestore: AngularFirestore) {
        this.user = this._auth.authState.pipe(
            switchMap(({ uid }) =&gt; {
                if (uid) {
                    return this._firestore.doc(`users/${uid}`).valueChanges();
                } else {
                    return of(null);
                }
            })
        );
    }

    public async createAccount(email: string, password: string, forename: string, surname: string, relevantTags: string[] = []) {
        // create the user in the auth system
        let authUser;
        try {
            authUser = await this._auth.auth.createUserWithEmailAndPassword(email, password);
        } catch (error) {
            console.error('Failed to create user in auth system', { reason: error.message });
            throw error;
        }

        // flesh out the user data
        const data: User = {
            uid: authUser.user.uid,
            forename: forename,
            surname: surname,
            displayName: `${forename} ${surname}`,
            roles: ['user'],   // everyone has user role, can be promoted by admin as required
            relevantTags: relevantTags,
            emailVerified: false
        };

        // create the user in the database
        try {
            this._firestore.doc(`users/${data.uid}`).set(data);
        } catch (error) {
            console.error('Failed to create user in database', { reason: error.message });
            throw error;
        }

        // attempt to send the initial verification email
        try {
            this.sendVerification();
        } catch (error) {
            console.warn('Failed to send verification email', { reason: error.message });
            throw error;
        }
    }

    public async signIn(email: string, password: string) {
        // attempt to sign in
        let result: firebase.auth.UserCredential;
        try {
            result = await this._auth.auth.signInWithEmailAndPassword(email, password);
        } catch (error) {
            console.error('Failed to log in', { reason: error.message });
            throw error;
        }

        // store the user data for access by controllers
        try {
            this.user = this._firestore.doc&lt;User&gt;(`users/${result.user.uid}`).valueChanges();
        } catch (error) {
            console.error('Failed to set user on service', { reason: error.message });
            this._auth.auth.signOut();
            throw new Error('Failed to log in');
        }
    }

    public async signOut() {
        // attempt to sign out
        try {
            await this._auth.auth.signOut();
        } catch (error) {
            console.error('Failed to log out', { reason: error.message });
            throw new Error('Failed to log out');
        }
    }

    public async sendVerification() {
        // attempt to send verification email
        try {
            this._auth.auth.currentUser.sendEmailVerification();
        } catch (error) {
            console.error('Failed to send verification', { reason: error.message });
            throw new Error('Failed to send verification');
        }
    }
}</code></pre>
</div>
</div>
</p>

<p><strong>The App</strong>
As you can see from the screenshot below, the logs are correct, and we <em>should</em> be redirected to the dashboard, yet the Login component and route are still activated.
<a href=""https://i.stack.imgur.com/89Y6F.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/89Y6F.png"" alt=""Screenshot containing the console logs and showing the login route is still active""></a></p>
","3267439","","","","","2020-06-22 14:07:32","Navigation from Angular Guard not working when using Observables","<angular><rxjs6><angular-guards>","2","0","","","","CC BY-SA 4.0"
"57127585","1","57128410","","2019-07-20 18:38:16","","1","120","<p>Is it possible to convert or cast the BehaviorSubject to an array stream? Or pls advise best practice.</p>

<h3>Objective is to return the total price of groceries ###</h3>

<p><em>data.js</em></p>

<pre><code>export const ShoppingList = {
  id: 22,
  username: 'Duff',
  groceries: [
    {
      day: 'Monday',
      purchases: [ { item: 'Beer', price: 10 }, { item: 'Pizza', price: 15 } ]
    },
    {
      day: 'Tuesday',
      purchases: [ { item: 'Wine', price: 10 }, { item: 'Steak', price: 15 } ]
    },
  ]
}
</code></pre>

<p><em>service.ts</em></p>

<pre><code>import { Injectable } from '@angular/core';
import { ShoppingList } from './data.js'
//
import { BehaviorSubject } from 'rxjs';
import { pluck } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})

export class DataService {
  shopping_list$ = new BehaviorSubject&lt;any&gt;(ShoppingList);

  user_name$ = this.shopping_list$.pipe(pluck('username');
  id$ = this.shopping_list$.pipe(pluck('id')

  **day$ = new BehaviorSubject&lt;[]&gt;(ShoppingList_groceries[0].day);**

  **purchases$ = new BehaviorSubject&lt;[]&gt;(ShoppingList_groceries[0].purchases);**

  constructor() {}
}
</code></pre>

<h3>#</h3>

<p><em>list-component.ts</em></p>

<pre><code>import { DataService } from '../service/data.service.ts';
//
import { from, Observable } from 'rxjs';
import { tap, map, pluck, reduce, switchMap } from 'rxjs/operators';

@Component({
  selector: 'app-list',
  templateUrl: './list.component.html',
  styleUrls: ['./list.component.css']
})

export class ListComponent implements OnInit {

  shopping_list = this.dataService.shopping_list$;
  user_name = this.dataService.user_name$;
  id = this.dataService.id$;
  day = this.dataService.day$

  ***prices = this.dataService.purchases$.pipe(
       pluck('prices'),
       reduce((a:number, c:number) =&gt; a + c),
       tap(y =&gt; console.log(y))
     );***


  constructor(private dataService: DataService) {}



  ngOnInit() {
    this.shopping_list.subscribe(val =&gt; console.log(val))
    this.prices.subscribe(val =&gt; console.log(val))
  }

}
</code></pre>

<h3>> returns undefined</h3>

<h3>> or without pluck and reduce returns whole array [{},{}]</h3>

<p><em>list-component.html</em></p>

<pre><code>&lt;h1&gt;{{ user_name }} {{ id }} &lt;/h1&gt;
&lt;p&gt;{{ day }}&lt;/p&gt;
&lt;p&gt;{{ prices }}&lt;/p&gt;
</code></pre>

<p>is it possible to pipe a <strong><em>BehaviorSubject</em></strong> to work like <strong>*from</strong> function? Is this best practice or is there a better pattern to build?
Any feedback would be much appreciated.</p>
","8954465","","","","","2019-07-20 20:43:59","Is possible to cast BehaviorSubject into an array stream?","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57164278","1","57164493","","2019-07-23 12:31:18","","2","65","<p>I am not able to emit user id when it is defined. This is what i know once you subscribe to observable it will listen for changes and emit. Is there any operator which can emit when user id is defined.</p>

<p>I have tried with of and new Observable operators too, I am getting same output.</p>

<pre><code>  constructor() {
    setTimeout(() =&gt; {
      this.user.id = 1
      ,5000})
   }


   getUserIdChat(): Observable&lt;any&gt; {
      return Observable.create(data=&gt; {
        console.log("" i called"")
        if(typeof this.user.id != 'undefined') {
          console.log('next called')
          data.next(this.user.id);
          data.complete();
        }
      })
    }

</code></pre>

<pre><code>constructor(private user: UserService) {
    this.user.getUserIdChat().subscribe(data =&gt; {
      console.log('data from user', data)
    })
   }
</code></pre>

<p>i should get output 1 in console</p>
","10842900","","","","","2019-07-23 12:55:07","Observable create emit after when user.id is defined","<angular><rxjs6>","2","1","","","","CC BY-SA 4.0"
"57196188","1","","","2019-07-25 07:09:37","","1","3308","<p>I am trying to build an old project but unable to do it because of below errors.Using angular 5.2.9 to build the project but getting these errors.Can someone help</p>

<p>My package.json file looks like this</p>

<pre><code>""dependencies"": {
 ""@angular/core"": ""&gt;=5.2.9"",
 ""@angular/router"": ""&gt;=5.2.9"",
 ""ng-packagr"": ""^3.0.6"",
 ""rxjs-compat"": ""^6.2.2""
 },

  ""devDependencies"": {
    ""@angular/common"": ""&gt;=5.2.9"",
    ""@angular/compiler"": ""&gt;=5.2.9"",
    ""@angular/compiler-cli"": ""^6.1.0"",
    ""@angular/platform-browser"": ""&gt;=5.2.9"",
    ""@angular/platform-browser-dynamic"": ""&gt;=5.2.9"",
    ""@angular/platform-server"": ""&gt;=5.2.9"",
    ""@types/es6-shim"": ""^0.31.32"",
    ""@types/jasmine"": ""^2.5.40"",
    ""@types/selenium-webdriver"": ""^2.53.39"",
    ""awesome-typescript-loader"": ""^3.1.2"",
    ""extract-text-webpack-plugin"": ""^2.1.0"",
    ""jasmine-core"": ""^2.5.2"",
    ""rxjs"": ""^6.5.2"",
    ""source-map-loader"": ""^0.2.0"",
    ""ts-helpers"": ""^1.1.2"",
    ""tslint"": ""^4.5.1"",
    ""tslint-loader"": ""^3.4.3"",
    ""typescript"": ""^2.2.1"",
    ""webpack"": ""2.1.0-beta.22"",
    ""webpack-dev-middleware"": ""^1.10.1"",
    ""webpack-dev-server"": ""^2.4.1"",
    ""webpack-md5-hash"": ""0.0.5"",
    ""webpack-merge"": ""^4.0.0"",
    ""zone.js"": ""&gt;=0.7.2""
  },
</code></pre>

<p>Build is happening but I am getting these warnings when running test cases</p>

<pre><code>WARNING in ./~/rxjs-compat/observable/merge.js
Cannot find source file '../src/compat/observable/merge.ts': Error: Can't resolve '../src/compat/observable/merge.ts' in 'D:\MASTERS\master-sales\node_modules\rxjs-compat\observable'
 @ ./~/rxjs/observable/merge.js 6:9-48
 @ ./~/@angular/core/esm5/core.js
 @ ./src/master-sales.service.ts
 @ ./src/master-sales.service.spec.ts
 @ ./src \.spec\.ts
 @ ./spec-bundle.js

WARNING in ./~/rxjs-compat/add/observable/from.js
Cannot find source file '../../src/compat/add/observable/from.ts': Error: Can't resolve '../../src/compat/add/observable/from.ts' in 'D:\MASTERS\master-sales\node_modules\rxjs-compat\add\observable'
 @ ./~/rxjs-compat/Rx.js 24:0-32
 @ ./~/rxjs/Rx.js
 @ ./spec-bundle.js

WARNING in ./~/rxjs-compat/add/observable/fromEvent.js
Cannot find source file '../../src/compat/add/observable/fromEvent.ts': Error: Can't resolve '../../src/compat/add/observable/fromEvent.ts' in 'D:\MASTERS\master-sales\node_modules\rxjs-compat\add\observable'
 @ ./~/rxjs-compat/Rx.js 25:0-37
 @ ./~/rxjs/Rx.js
 @ ./spec-bundle.js
WARNING in ./~/rxjs-compat/add/observable/defer.js
Cannot find source file '../../src/compat/add/observable/defer.ts': Error: Can't resolve '../../src/compat/add/observable/defer.ts' in 'D:\MASTERS\master-sales\node_modules\rxjs-compat\add\observable'
 @ ./~/rxjs-compat/Rx.js 21:0-33
 @ ./~/rxjs/Rx.js
 @ ./spec-bundle.js
</code></pre>
","8286878","","8286878","","2019-07-27 08:41:06","2019-07-27 08:41:06","@angular/common error TS2304 cannot find name 'unknown'","<angular><rxjs><node-modules><rxjs5><rxjs6>","1","2","","","","CC BY-SA 4.0"
"57214234","1","","","2019-07-26 06:24:49","","21","9282","<p>The old code uses rxjs v5.5.12, We copied the same code to our new project which uses rxjs v6.4.0. We are getting this error when we tried to run the test case.</p>

<p><strong>Old Code:</strong></p>

<pre class=""lang-js prettyprint-override""><code>import * as ObservableEvents from 'rxjs/Observable/fromEvent';
spyOn(ObservableEvents, 'fromEvent').and.returnValue(new Subject&lt;any&gt;().asObservable());
</code></pre>

<p><strong>New Code:</strong></p>

<pre class=""lang-js prettyprint-override""><code>import * as rxjs from 'rxjs';
spyOn(rxjs, 'fromEvent').and.returnValue(new Subject&lt;any&gt;().asObservable());
</code></pre>

<p>In both cases we are getting this error:</p>

<blockquote>
  <p>Error:  : fromEvent is not declared writable or has no setter</p>
</blockquote>

<p>We couldn't find a valid resource to solve this issue.</p>

<p><strong>Update #1</strong></p>

<p>We tried using </p>

<pre class=""lang-js prettyprint-override""><code>import * as rxjs from 'rxjs';
spyOn(jasmine.createSpyObj(rxjs), 'fromEvent').and.returnValue(new Subject&lt;any&gt;().asObservable());
</code></pre>

<p>but this time, we got </p>

<blockquote>
  <p>createSpyObj requires a non-empty array or object of method names to create spies for thrown</p>
</blockquote>

<p><strong>Update #2:</strong></p>

<p>We used the code from @Omair-Nabiel, now getting a new error</p>

<pre><code>      TypeError: Object(...) is not a function
          at XxxPopoverDirective.fromEvent [as createPopover] (http://xxx:xxxx/src/app/shared/xxx/xxx.directive.ts?:113:37)
          at XxxPopoverDirective.createPopover [as mouseClick] (http://xxx:xxxx/src/app/shared/xxx/xxx.directive.ts?:70:14)
          at runTest (http://xxx:xxxx/src/app/shared/xxx/xxx.directive.spec.ts?:181:19)
</code></pre>

<p><strong>xxx.directive.ts</strong></p>

<pre><code>line 113-&gt; this.componentRef &amp;&amp; this.componentRef.destroy();
this.componentRef = null;

line 70-&gt; constructor(
...
private resolver: ComponentFactoryResolver,
...
  ) { }
</code></pre>

<p><strong>Update #3</strong></p>

<p>Hi Omair Nabiel, 
Please find the below code we are using, please let me know the solution,</p>

<p>file=""popover.directive.ts""
Code:</p>

<pre><code>import { fromEvent } from 'rxjs/Observable/fromEvent';

this.clickOutSub = fromEvent(this.documentRef.getDocument(), 'click').subscribe(this.clickOut.bind(this));

file=""popover.directive.spec.ts""
Code:
import * as ObservableEvents from 'rxjs/Observable/fromEvent';

function runTest() {

spyOn(ObservableEvents, 'fromEvent').and.returnValue(new Subject&lt;any&gt;().asObservable());

 }

it('...', () =&gt; {
expect(ObservableEvents.fromEvent).toHaveBeenCalled();
});
</code></pre>
","11763304","","11763304","","2019-08-01 10:39:17","2021-09-06 21:29:02","Error: <spyOn> : fromEvent is not declared writable or has no setter","<angular><rxjs><karma-jasmine><rxjs6>","5","3","3","","","CC BY-SA 4.0"
"57243086","1","","","2019-07-28 16:58:41","","1","1510","<p>Am going to start working with RXJS and socket io in Angular 6+ but before that I want to know whether this both are same or in a different case. Can anybody assist me in where to use these both in Angular?</p>
","7633343","","7633343","","2019-07-28 18:03:11","2020-02-28 04:29:00","What is the difference between RXJS and Socket.io","<typescript><socket.io><angular6><rxjs6>","1","10","1","","","CC BY-SA 4.0"
"57271541","1","","","2019-07-30 12:20:29","","0","27","<p>This code works on Rxjs5. How can I write this code with Rxjs6.</p>

<pre><code>this.searchTerm$.distinctUntilChanged().combineLatest(
  this.selectedLg$.distinctUntilChanged(), (_term, _lg) =&gt; {
    return {
      term: _term,
      lg: _lg
    }
  }
)
  .switchMap(t =&gt; this.service.search(t.lg, t.term))
  .subscribe((results: any[]) =&gt; {
    this.list= results;
  });
</code></pre>
","7078980","","","","","2019-07-30 12:20:29","Updating from RxJS5 to RxJS6","<angular><rxjs6>","0","4","","","","CC BY-SA 4.0"
"57300530","1","","","2019-08-01 00:49:08","","0","447","<p>I've just upgraded from Angular 7.1.4 to 8.2.0, Typescript 3.1.6 to 3.5.3, RxJS </p>

<p>Before the upgrade, TS correctly identified that this array item is not undefined, but now I'm getting this frustrating compilation error. (note, I'm using lo-dash below, but the same error occurs if I use <code>if (autoCorrectionData[action.algorithmId] !== undefined) {</code></p>

<p><code>src/app/state/edit/edit.reducer.ts(417,29): error TS2532: Object is possibly 'undefined'.</code></p>

<p>How can I get TypeScript to recognize that the Object IS defined after I check using the <code>if</code> condition?</p>

<p>*edit* This might have something to do with recent changes to NGRX Dictionaries, but I'm not sure why. Dictionary values can now be undefined.</p>

<p><a href=""https://i.stack.imgur.com/Wgz8a.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Wgz8a.png"" alt=""enter image description here""></a></p>
","4518468","","4518468","","2019-08-01 21:43:59","2019-08-01 21:43:59","Asserting NGRX Dictionary value is defined","<angular><typescript><ngrx><rxjs6><ngrx-entity>","1","3","","","","CC BY-SA 4.0"
"57325404","1","","","2019-08-02 11:15:53","","-1","60","<p>Am using rxjs 6.3.3 version it throw error on <code>console</code> after logged to webpage. I didn't get any idea to clear this error</p>

<pre><code>    at subscribeTo (subscribeTo.js:41)
    at subscribeToResult (subscribeToResult.js:11)
    at MergeMapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/mergeMap.js.MergeMapSubscriber._innerSub (mergeMap.js:74)
    at MergeMapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/mergeMap.js.MergeMapSubscriber._tryNext (mergeMap.js:68)
    at MergeMapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/mergeMap.js.MergeMapSubscriber._next (mergeMap.js:51)
    at MergeMapSubscriber.push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.next (Subscriber.js:54)
    at Observable._subscribe (subscribeToArray.js:5)
    at Observable.push../node_modules/rxjs/_esm5/internal/Observable.js.Observable._trySubscribe (Observable.js:43)
    at Observable.push../node_modules/rxjs/_esm5/internal/Observable.js.Observable.subscribe (Observable.js:29)
    at MergeMapOperator.push../node_modules/rxjs/_esm5/internal/operators/mergeMap.js.MergeMapOperator.call (mergeMap.js:29)
</code></pre>
","10818695","","7562711","","2019-08-02 11:19:21","2019-08-02 11:44:24","I got an console error, after logged to website in chrome","<javascript><angular><reactjs><rxjs6>","2","3","","","","CC BY-SA 4.0"
"57325581","1","","","2019-08-02 11:26:39","","0","369","<pre><code>httpResp.subscribe({
 next: this.someMethod.bind(this)
})
</code></pre>

<p>Sonar (""Deprecated APIs should not be used"" rule) flags the use of subscribe with:
""subscribe is deprecated: Use an observer instead of a complete callback""</p>

<p>This is in regards with the RXJS6 changes where the use of subscribe(callback) is considered deprecated. I've changed the call as stated here <a href=""https://stackoverflow.com/a/55472361"">https://stackoverflow.com/a/55472361</a> but I still get the line flagged.
Does anyone know why?</p>
","8944188","","8944188","","2019-08-02 11:50:49","2019-08-02 11:50:49","Sonar deprecated rule flags the use of 'subscribe' as deprecated","<callback><rxjs><sonarqube><deprecated><rxjs6>","0","3","","","","CC BY-SA 4.0"
"57387352","1","57387890","","2019-08-07 05:13:51","","2","907","<p>I'm new to rxjs in Angular 7 , i have an api that returns the user details.I want to remove objects that are having same name,i hardly tried it using distinctUntilKeyChanged() but getting output in console as same as from the api response. and also can i directly use returned data  from service as the responce is already a Observable using Interface without using From() or 0f() in component.</p>

<p>This is for angular 7 and Rxjs 6 , i have been using angular for one year but i didnt used Rxjs till now,am getting lots of confusions in Rxjs, that can i use the Http response from service directly in component or else do i want to use any operators for converting the response as stream in brief can i use the Json responce directly in component for using different operators like find(),first(),ignoreElements etc... </p>

<p>user.service.ts</p>

<pre><code>  private urlLara = 'http://laravel.technalatus.com/public/api/'
  public getusers(): Observable&lt;User&gt; {
    const head = new HttpHeaders({
      'Accept': 'application/json',
      'Content-Type': 'application/json',
    })
    return this.http.get&lt;User&gt;(this.urlLara + 'users', { headers: head 
    });
  }
</code></pre>

<p>component.ts</p>

<pre><code>export class AppComponent implements OnInit {
  title = 'angularrxjs';
  items: {};
  post: Post;
  user: User;
  public searchTerm: string;

  constructor(private UserService: UserService) {

  }

  ngOnInit() {
    this.distinct()
  }

  public Duchanged() {
    // custom compare for name
    this.UserService.getusers().pipe(distinctUntilChanged((prev, curr) =&gt; prev.name === curr.name))
      .subscribe(console.log);

  }
</code></pre>

<p>Getting output as </p>

<pre><code>[
{id: 2, name: ""alshoja"", email: ""alshoja@gmail.com"", email_verified_at: null, type: ""admin""},
{id: 3, name: ""Ellaware"", email: ""abhi@gmail.com"", email_verified_at: null, type: ""user""},
{id: 17, name: ""alshoja"", email: ""c@g.com"", email_verified_at: null, type: ""user""}
]
</code></pre>

<p>Expecting Output as </p>

<pre><code>[
{id: 2, name: ""alshoja"", email: ""alshoja@gmail.com"", email_verified_at: null, type: ""admin""},
{id: 3, name: ""Ellaware"", email: ""abhi@gmail.com"", email_verified_at: null, type: ""user""},
]
</code></pre>
","10379165","","10379165","","2019-08-07 05:28:49","2019-08-07 06:57:15","Can i use distinctUntilKeyChanged for removing duplicate objects?","<angular><typescript><rxjs><angular7><rxjs6>","3","0","","","","CC BY-SA 4.0"
"57459894","1","57460105","","2019-08-12 10:56:15","","1","257","<p>I'm using ngrx effects to fetch data from an API. I've tried different combination of rxjs operators to achieve this. Currently using groupBy operator to acheive the following</p>

<p>API data:</p>

<pre><code>projects = [{id: 1, name: project1, department: dept1, instance_count: 3},
{id: 2, name: project2, department: dept2, instance_count: 6},
{id: 3, name: project3, department: dept1, instance_count: 1},
{id: 1, name: project1, department: dept1, instance_count: 8}]
</code></pre>

<p>I have option to filter based on department. So the output when 'dept1' is selected should be</p>

<p>Result:</p>

<pre><code>filteredProjects = [{id: 1, name: project1, department: dept1,   instance_count: 11 }, {id: 3, name: project3, department: dept1, instance_count: 1}] 
</code></pre>

<p>I've tried to use groupBy to group the data based on 'id' or 'department' and then apply filter and add the counts of the grouped data.</p>

<pre><code>this.projects$: Observable&lt;Project[]&gt; = this._store.select(state =&gt; state.projects.allProjects)
  .map((projects: Project[]) =&gt; projects);

this.projects$.pipe(
groupBy(
project =&gt; project.id)
   ).subscribe(console.log);
</code></pre>

<p>I'm not able to get the groupBy and mergeMap working. Most of the examples I saw doesn't use pipe operator. This was throwing error ' Property 'id' does not exist on type 'Project[]'.</p>
","11304021","","11304021","","2019-08-12 12:04:19","2019-08-12 12:04:19","RxJS groupBy on ngrx effects to observable custom array","<angular><rxjs><ngrx><rxjs6><ngrx-effects>","1","2","","","","CC BY-SA 4.0"
"57467764","1","","","2019-08-12 20:19:54","","2","3726","<p>I am using rxjs switchMap to get the latest form value from a subject, set a local variable and then perform a query based on that value.</p>

<p>Long story short I am populating select box options based on the current value of the form.</p>

<pre><code>  // Get current value of Record Form
  this.recordFormService.recordForm$
    .pipe(
      switchMap(recordForm =&gt; {
        // Get current Product Owner on Record Form
        this.currentProductOwner = recordForm.value.ProductOwner;

        // Search People
        return this.recordsApiService.searchPeople$(this.currentProductOwner);
      }),
      catchError(err =&gt; {
        console.error(`get recordForm$ failed ${err}`);
        return throwError(err);
      })
    )
    .subscribe(results =&gt; {
      // Set Product Owners select box options
      this.productOwners = results.data;
    });
</code></pre>

<p>This is all working properly.</p>

<p>However, I also need to perform the same exact logic when a specific form value changes.</p>

<pre><code>// Run the same logic when the ProductOwner value changes
this.parentFormGroup.controls['ProductOwner'].valueChanges.subscribe(val =&gt; {});
</code></pre>

<p>I tried putting the combineLatest operator at the top, however that only resolves when both observables have emitted at least one value.</p>

<p>The <code>valueChanges</code> observable may not necessarily ever change, but recordFormService.recordForm$ will run at least once when the page is loaded. </p>

<p>Note: The result of the <code>valueChanges</code> observable is a string and the result of the <code>recordForm$</code> observable is a FormGroup object, they need to be processed entirely differently.</p>

<p>What operator can I use to achieve this requirement?</p>

<pre><code>// Get latest value of all observables
combineLatest(
  this.parentFormGroup.controls['ProductOwner'].valueChanges,
  // Get current value of Record Form
  this.recordFormService.recordForm$
)
.pipe(
  switchMap(recordForm =&gt; {
    // Get current Product Owner on Record Form
    this.currentProductOwner = recordForm.value.ProductOwner;

    // Search People
    return this.recordsApiService.searchPeople$(this.currentProductOwner);
  }),
  catchError(err =&gt; {
    console.error(`get recordForm$ failed ${err}`);
    return throwError(err);
  })
)
.subscribe(results =&gt; {
  // Set Product Owners select box options
  this.productOwners = results.data;
});
</code></pre>

<p>UPDATE:</p>

<p>I also tried <code>merge</code>. However the results of both observables are entirely different (one is a formGroup and one is a string) and they both need to be processed differently.</p>

<pre><code>// Get latest value of all observables
merge(
  this.parentFormGroup.controls['ProductOwner'].valueChanges,
  // Get current value of Record Form
  this.recordFormService.recordForm$
)
</code></pre>
","2183592","","2183592","","2019-08-13 13:42:18","2019-08-13 13:42:18","Angular 8 rxjs get values from multiple observables","<angular><observable><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"57539071","1","57539144","","2019-08-17 18:51:34","","1","108","<p>I've usecase wherein call HTTP get request, get a list of objects, get a distinct values of one of the properties of the object and call another HTTP request, then enrich the objects with response from second HTTP request. Below is code snippet I had written.</p>

<pre><code>const retrieveData = this.http.get('/url1');
const retreiveNameMap = retrieveData.pipe(map(e=&gt;KUtils.distinct(e)), switchMap(e=&gt;this.http.get('/url2',e)));

const source = zip(retrieveData, retreiveNameMap).subscribe(e=&gt;console.log(e));
</code></pre>

<p>However when I debug in browser, I notice that there is two HTTP request being triggered for <code>url1</code>(first HTTP request), how to avoid calling <code>url1</code> twice?</p>
","1279145","","","","","2019-08-17 19:02:26","Rxjs zip with rest call called twice","<angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"57559220","1","","","2019-08-19 14:54:20","","1","594","<p>I am building an application in angular 8. I have an API call in staff.service.ts which gets the list of staff. In my ts file I am trying to use the map function but it throws an error saying Property 'map' does not exist on type 'ArrayBuffer'.</p>

<p>staff.service.ts </p>

<pre><code>import { HttpClient } from ""@angular/common/http"";
  public getStaffList(){
    let url = this.apiUrl + `api/v1/staff`;

    this.options = this.authService.getAuthInfo();
    return this.http.get(url, this.options)
  }
</code></pre>

<p>staff.component.ts </p>

<pre><code>import { forkJoin } from 'rxjs';

    forkJoin(
      this.staffAdminService.getStaffList(),
      this.staffAdminService.getTitles(),

    ).subscribe(data =&gt; {
data[0].map({
})
})
</code></pre>
","7582976","","","","","2019-08-19 15:05:15","Angular 8: Property 'map' does not exist on type 'ArrayBuffer'","<angular><rxjs><rxjs6><angular8>","1","8","","","","CC BY-SA 4.0"
"57571609","1","57574319","","2019-08-20 10:27:58","","0","342","<p>I receive my data from an API call. The data is received via ngrx-effects and passed into the state tree. Then I'm able to fetch the data in my angular component's constructor and do some rxjs operations like mergeMap and reduce to convert it to a format that I need to display the data in UI. </p>

<p>I tried replicate the scenario in stackblitz and it's working as expected. Please find the link below</p>

<pre><code>link: https://stackblitz.com/edit/typescript-rxjs-reduce
</code></pre>

<p>workflow state tree:</p>

<pre><code>export interface WorkflowsState {
    workflows : workflow[] | [],
    allWorkflowsLoaded : false
}
</code></pre>

<p>Overall App State tree:</p>

<pre><code>interface Appstate {
    workflows: WorkflowsState,
    smartNav: SmartNavState
}
</code></pre>

<p>Effect method:</p>

<pre><code>@Effect() loadWorkflows$ = this.actions$.pipe(
    ofType(WorkflowsActionTypes.LoadWorkflows),
    switchMap((action: LoadWorkflows) =&gt;
    this.http.get(url)
    .pipe(map((res: Workflow[]) =&gt; new WorkflowsLoaded(res))))
);
</code></pre>

<p>Reducer section:</p>

<pre><code>switch (action.type) {
    case: WorkflowsActionTypes.WorkflowsLoaded:
    return {
        allWorkflowsLoaded : true,
        workflows: action.payload
};
</code></pre>

<p>public variables declared in dashboard component:</p>

<pre><code>public workflows$ : Observable&lt;workflow[]&gt;;
public dashboardTile$ : Observable&lt;dashboardTile[]&gt;;
</code></pre>

<p>constructor with selector:</p>

<pre><code>constructor(private store : Store&lt;AppState&gt;) {
    this.workflows$ = this.store.select(state =&gt; state.workflows.workflows);
}
</code></pre>

<p>Not sure about why it's not working when the data is fetched from API. I require the same output as displayed in the sample's (stackblitz link) console section. I'm able to get the data from api but dashboardTile$ is returning as null.</p>
","11304021","","10143290","","2019-08-20 10:41:28","2019-08-20 13:02:00","Grouping and reducing a custom observable array which was received from ngrx state tree","<angular><typescript><observable><ngrx><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57578976","1","57579383","","2019-08-20 17:41:33","","1","999","<p>I got a situation where I'd like to dynamically add a property to some object in <code>BehaviorSubject&lt;any[]&gt;</code>. I got component A and B, where A is subscribed to observable from service. I need to be able to somehow manipulate that stream from component B where I would attach some prop to an index item of that array in BehaviorSubject. </p>

<p>Component A:</p>

<p>.html</p>

<pre><code>&lt;pre&gt;{{ data$ | async | json }}&lt;/pre&gt;
</code></pre>

<p>.ts</p>

<pre><code>export class DummyComponent implements OnInit {
  data$: Observable&lt;any&gt;;

  constructor(private dummyService: DummyService) { }

  ngOnInit() {
    this.data$ = this.dummyService.someData$;
  }
}
</code></pre>

<p>Component B:</p>

<p>.html</p>

<pre><code>&lt;button (click)=""foo()""&gt;Click&lt;/button&gt;
</code></pre>

<p>.ts</p>

<pre><code>export class Dummy2Component {

  constructor(private dummyService: DummyService) { }

  foo() {
    this.dummyService.someAction(0, () =&gt; {
      console.log('test');
    });
  }
}
</code></pre>

<p>Service with data (Dummy Service):</p>

<pre><code>
export const someRandomData = [
  {
    id: 1,
    label: 'foo'
  },
  {
    id: 2,
    label: 'bar'
  }
]

@Injectable()
export class DummyService {
  private someDataSource$: BehaviorSubject&lt;any&gt; = new BehaviorSubject(someRandomData);
  someData$: Observable&lt;any&gt; = this.someDataSource$.asObservable();

  someAction(index: number, fn: () =&gt; void): void {
    this.someData$ = this.someData$.pipe(
      map(items =&gt; {
        console.log(items);
        items[index].onClick = fn;
        return items;
      })
    )
  }
}
</code></pre>

<p>In Component B I got the button that calls <code>foo()</code> function and that function gets executed, but when it calls someAction() in DummyService, it doesn't modify stream. That stream stays unchanged. It never console.logs(item) even tho someData$ is subscribed in Component A.</p>

<p>Not sure what I'm missing here.</p>

<p>Here's stackblitz demo: <a href=""https://stackblitz.com/edit/angular-zyr5r6"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-zyr5r6</a></p>
","9055053","","","","","2019-08-20 18:10:35","Modify Behavior Subject stream dynamically","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57583347","1","57583956","","2019-08-21 01:30:46","","2","371","<p>My application receives responses from a server. These responses may be received singly or in multiples, but they'll always be received in the order they should be individually dealt with and rendered.</p>

<p>Upon receiving a response, the following things need to happen, in order:</p>

<ol>
<li>A typing indicator is rendered and displayed (sync)</li>
<li>The response data is parsed and massaged into the correct format (sync)</li>
<li>An artificial delay is run to emulate a ""real person"" typing (async)</li>
<li>The typing indicator should be removed/hidden (sync)</li>
<li>The formatted response is rendered to the screen (sync)</li>
</ol>

<p>Now, all of these steps need to occur in order for EACH response received, ALSO in order. The end result of this should be typing indicators being shown for a random amount of time, then disappearing, then the response being shown, then the indicator being shown again for a random amount of time, then disappearing, then the next response being shown, etc.</p>

<p>I've tried a variety of techniques for accomplishing this with RxJS but I'm struggling to get this to work. I'm finding that regardless of my approach, responses (added to a queue-like structure and/or executed sequentially) keep firing off the chain of events concurrently. I cannot figure out how to execute the chain of events sequentially AND wait for each previous chain of events to be completed before the next begins.</p>

<p>I've attempted solutions using a <code>.pipe</code> chain containing <code>.tap</code> and <code>.concatMap</code> functions, as well as creating a queue from <code>new Subject()</code> and adding new items to it to be executed using <code>next()</code>. None of these things solves my problem.</p>

<p>It's essential that the core construct be a queue of some sort that I can continue adding items to and they'll automatically be executed when the queue is finished/empty.</p>
","846062","","","","","2019-08-21 03:09:09","How to create proper queue in RxJS consisting of Observables containing both sync and async functions","<javascript><promise><rxjs><observable><rxjs6>","1","1","","","","CC BY-SA 4.0"
"57583419","1","57585018","","2019-08-21 01:45:46","","1","32","<p>I'm trying to figure out how - using RxJS 6 - to check a cache for a value and only if the value isn't found in the cache, request the value from the database.  Ideally, I'd then be able to add the value received from the DB to the cache.</p>

<p>So far, I've looked at <code>race</code>, but that's going to request both and take whichever responds first.  I don't want to request from the DB if the value is available in cache.  <code>flatMap</code> seems to have the same issue?</p>

<p>I'm aware of <code>defaultIfEmpty</code> but that only provides a default <strong>value</strong>, not subscribe to a new Observable and emit those values instead.</p>

<p>Thanks,</p>

<p>TTE</p>
","1816009","","","","","2019-08-21 05:45:07","RxJS operator to subscribe to a new source only if the first source is empty?","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"57603724","1","57603747","","2019-08-22 07:03:01","","3","3118","<p>This gives me a headache... following code does work as expected:</p>

<pre><code>const s$ = new Subject&lt;any&gt;();
  s$.pipe(
      switchMap(
        x =&gt; {
          debugger;
          return myService.getSth();
        }
      )
    ).subscribe(x =&gt; {
    debugger;
  });
  s$.next();
</code></pre>

<p>Both <code>debugger</code> in the <code>switchMap</code> and <code>subscribe</code> part are hit.<br>
But if I split it up (I would like to move the whole piping stuff into separate libraries), the debugger in the <code>switchMap</code> is not hit anymore, meaning the service in this particular example is not called:</p>

<pre><code>  const s$ = new Subject&lt;any&gt;();
  s$.pipe(
      switchMap(
        x =&gt; {
          debugger;
          return myService.getSth();
        }
      )
    );

  // ...

  s$.subscribe(x =&gt; {
    debugger;
  });
  s$.next();
</code></pre>

<p>What do I miss here?</p>
","598516","","","","","2019-08-22 07:05:17","rxjs pipe and subscribe (on a Subject) in two separate steps not working as expected","<typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57605718","1","57633651","","2019-08-22 09:04:18","","1","54","<p>I have an array of data which describes entity relationships.
My code:</p>

<pre><code>services
            .tree
            .collection
            .find()
            .$
            .pipe(
                switchMap(from),
                groupBy((value) =&gt; value.get('parent_id')),
                mergeScan((memo, group$) =&gt; {
                    const key = group$.key;

                    return group$.pipe(
                        map((value) =&gt; {
                            if(!(key in memo)) {
                                memo[key] = [];
                            }
                            memo[key].push(value);

                            return memo;
                        })
                    )
                }, {}),
            )
            .subscribe((data) =&gt; console.log('data', data));
</code></pre>

<p>But instead of one log a have many. How can I merge all it in one pipeline to have a single data at the end?</p>
","3110920","","","","","2019-08-23 22:41:13","Right way to create a tree data view in rxjs","<javascript><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"57631094","1","57638940","","2019-08-23 18:02:50","","2","2497","<p>I'm trying to implement a data stream that has to use <strong>inner observables</strong>, where I use one from <code>mergeMap</code>, <code>concatMap</code> etc.  </p>

<p>e.g.: </p>

<pre><code>const output$$ = input$$.pipe(
    mergeMap(str =&gt; of(str).pipe(delay(10))),
    share()
  );

  output$$.subscribe(console.log);
</code></pre>

<p>This works fine when logging into console. 
But when I try to use it in React like below utilizing <code>useEffect</code> and <code>useState</code> hooks to update some text: </p>

<pre><code>function App() {
  const input$ = new Subject&lt;string&gt;();
  const input$$ = input$.pipe(share());
  const output$$ = input$$.pipe(
    mergeMap(str =&gt; of(str).pipe(delay(10))),
    share()
  );

  output$$.subscribe(console.log);
  // This works

  const [input, setInput] = useState("""");
  const [output, setOutput] = useState("""");

  useEffect(() =&gt; {
    const subscription = input$$.subscribe(setInput);

    return () =&gt; {
      subscription.unsubscribe();
    };
  }, [input$$]);

  useEffect(() =&gt; {
    const subscription = output$$.subscribe(setOutput);
    // This doesn't

    return () =&gt; {
      subscription.unsubscribe();
    };
  }, [output$$]);

  return (
    &lt;div className=""App""&gt;
      &lt;input
        onChange={event =&gt; input$.next(event.target.value)}
        value={input}
      /&gt;
      &lt;p&gt;{output}&lt;/p&gt;
    &lt;/div&gt;
  );
}

</code></pre>

<p>it starts acting weird/unpredictable (e.g.: sometimes the text is updated in the middle of typing, sometimes it doesn't update at all).  </p>

<p>Things I have noticed:  </p>

<ul>
<li>If the inner observable completes immediately/is a promise that
resolves immediately, it works fine. </li>
<li>If we print to console instead of <code>useEffect</code>, it works fine. </li>
</ul>

<p>I believe this has to do something with the inner workings of <code>useEffect</code> and how it captures and notices outside changes, but cannot get it working.<br>
Any help is much appreciated.  </p>

<p>Minimal reproduction of the case:<br>
<a href=""https://codesandbox.io/s/hooks-and-observables-1-7ygd8"" rel=""nofollow noreferrer"">https://codesandbox.io/s/hooks-and-observables-1-7ygd8</a> </p>
","3977826","","","","","2020-07-30 21:32:26","Using React useEffect hook with rxjs mergeMap operator","<javascript><reactjs><rxjs><react-hooks><rxjs6>","2","1","1","","","CC BY-SA 4.0"
"57679136","1","57679418","","2019-08-27 16:46:48","","1","567","<p>I am developing an Ionic 5 application and I have encountered such an error.</p>

<p><a href=""https://stackoverflow.com/questions/39685450/property-map-does-not-exist-on-type-object"">Property &#39;map&#39; does not exist on type Object</a> I tried the solution here, but this time he couldn't find first map.</p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';
//import { map } from 'lodash';
@Injectable({
  providedIn: 'root'
})
export class UnitService {
baseUrl='https://jsonplaceholder.typicode.com';
  constructor(private http:HttpClient) { }

  getUnit(){
    return this.http.get(`${this.baseUrl}/users`).pipe(
      map(unit =&gt; {
        return unit.map((un, index) =&gt; {
          un.unIndex = index + 1;
          return un;
        });
      })
    )
  }
}
</code></pre>

<p>How can I resolve this error</p>
","8477659","","","","","2019-08-27 17:10:48","Property 'map' does not exist on type 'Object'.ts(2339)","<angular><typescript><ionic-framework><rxjs><rxjs6>","1","4","","","","CC BY-SA 4.0"
"57702475","1","57703067","","2019-08-29 03:09:27","","0","47","<p>I'm trying to create a search engine (input) where each time a user starts typing, it'll wait a bit before sending a query call. From my understanding, we would import</p>

<pre><code>import { of } from ""rxjs"";
import { debounceTime } from ""rxjs/operators"";
</code></pre>

<p>The purpose of using <code>of</code> is because we will be using a string. As for <code>debounceTime</code>, we want to only process (make a request) to the last input that has been written in the set amount of time we pick. For this implementation, the way I have it set is</p>

<pre><code>const PostTypeSelection = ({ client }) =&gt; {
  const [search, updateSearch] = useState("""");
  const [tags, updateTags] = useState([]);
  const searchObserver = of(search);

  const handleChange = e =&gt; {
    const { value } = e.target;
    updateSearch(value);
    searchObserver
      .pipe(
        debounceTime(1000),
        distinctUntilChanged()
      )
      .subscribe(x =&gt; console.log(""we run query here"", x));
  }

  return (
    &lt;div&gt;
      &lt;p&gt;Select tags you'll want to see&lt;/p&gt;
      &lt;input
        type=""text""
        name=""search""
        placeholder=""Type tag name""
        onChange={handleChange}
      /&gt;
      {tags.map(tag =&gt; {
        return (
          &lt;div key={tag.id}&gt;
            {tag.name} ({tag.count})
          &lt;/div&gt;
        );
      })}
    &lt;/div&gt;
  );
};
</code></pre>

<p>My main question is what is wrong with my implementation? There is no delay when I start typing and the <code>console.log</code> get run immediately. Another problem I noticed is if I tried to use <code>delay</code>, it doesn't remove previous request just sends them all after a set amount of time.</p>

<p>All help is appreciated especially in better understanding how to use an <code>Observer</code> and better understand the right use of <code>debounceTime</code></p>
","4203814","","","","","2019-08-29 04:39:06","Better understand debounceTime (RXJS) for an API request","<reactjs><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"57705917","1","57706102","","2019-08-29 08:16:32","","2","2684","<p>I have a subscription to get providers from a NgRx reducer. I want to use <code>takeUntil()</code> to automatically close the subscription when is finally returns an array that has content:</p>

<pre><code>// Fetch providers
this.store.pipe(select(reducer.getProviders))
//  .takeUntil(reducer.getProviders.length &gt; 0)
    .subscribe(providers =&gt; {
        if (providers) {
            this.providers = providers;
//          takeUntil(/** something **/);
        }
    });
</code></pre>

<p>Can someone help me with this?</p>

<p>I can't figure out how to make use of <code>takeUntil()</code></p>
","1173390","","","","","2019-08-29 08:28:20","Close subscription on condition with takeUntil()","<angular><ngrx><rxjs6><ngrx-store>","2","0","","","","CC BY-SA 4.0"
"57716752","1","","","2019-08-29 19:31:50","","0","1171","<p>I'm trying to throw timeout error from the observable pipe to the observer as an error but I am still getting the timeout error in the val callback (in subscribe) while I want to get it in the error callback:</p>

<p>For who is experimented, you can test this code easly and edit it in stackblitz in this link:</p>

<p><a href=""https://stackblitz.com/edit/typescript-eegqyz?file=index.ts&amp;devtoolsheight=100"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-eegqyz?file=index.ts&amp;devtoolsheight=100</a></p>

<pre class=""lang-js prettyprint-override""><code>of(4000, 3000, 2000)
    .pipe(
        concatMap(duration =&gt;
            makeRequest(duration).pipe(
                timeout(2500),
                catchError(error =&gt; {
                    //throwError('Valid token not returned');
                    return of(`Request timed out after: ${duration}`)
                })
            )
        )
    )
    .subscribe(
        val =&gt; console.log(val),
        error =&gt; console.log(""error"", error)
    );
</code></pre>
","7041095","","7041095","","2019-08-29 20:59:24","2019-08-29 21:01:18","Rxjs throw timeout error from pipe to observable error section","<angular><rxjs><observable><rxjs6><redux-observable>","1","0","","","","CC BY-SA 4.0"
"57726021","1","57746473","","2019-08-30 11:36:20","","0","43","<p>There has to be a better way to do this, right?</p>

<pre class=""lang-ts prettyprint-override""><code>const source$ = combineLatest([
    folder$.pipe(
        filter(folder =&gt; folder.canBeLoaded()),
    ),
    page$,
    sort$,
]).pipe(
    takeUntil(this.onceDestroyed$),
    switchMap(([folder, page, sort]) =&gt; combineLatest([
        of(folder),
        of(page),
        of(sort),
        // buffer$: BehaviourSubjhect&lt;number&gt;
        buffer$.pipe(
            startWith(-1),
            pairwise(),
            filter(([buffered, wanted]) =&gt; wanted &gt; buffered ),
            map(([, current]) =&gt; current),
            distinctUntilChanged(),
        ),
    ])),
);
</code></pre>

<p><code>withLatestFrom</code> comes to my mind, but it will return once per parent, I need <code>buffer$</code> to be able to emit multiple times!</p>
","3001856","","","","","2019-09-02 02:13:15","Optimisation of RXJS chain","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"57742082","1","","","2019-08-31 22:49:59","","0","118","<p>I am trying to do service with multiple methods - each method will return pipe. The only one method can be called at a time; otherwise, the switch of pipe should happen.</p>

<p>This is an example of how I achieved it -- <a href=""https://stackblitz.com/edit/rxjs-3pry8u?devtoolsheight=60"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-3pry8u?devtoolsheight=60</a> . It looks too complicated and has a potential memory leak, but it works. If you will try to click fast ""Make red""/""Make green""/""Make blue"" buttons, only the last will be triggered(see the console.log).</p>

<p>As requirement - it is important to control pipe run inside Color, not outside. I can imagine how it can be solved with the outside way: I could merge all click events to one pipe and use switchMap(). But it is interesting for me - how this problem can be solved properly inside Color class.</p>
","3872807","","","","","2019-09-01 13:56:50","Run only one pipe at a time","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57765745","1","57765949","","2019-09-03 05:54:37","","0","106","<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>  var a$= from(['aaaa','bbbb'])
        var b$=from(ajax(`https://api.myjson.com/bins/no8tj`))
        a$.pipe(mergeMap(post =&gt; b$).subscribe(res =&gt; console.log(res)));</code></pre>
</div>
</div>
</p>

<p>I am trying to make use of mergeMap operator. But while subscribing i am getting an error 'TypeError: Object(...)(...).subscribe is not a function'. I am trying out this example from the following link
<a href=""https://netbasal.com/rxjs-six-operators-that-you-must-know-5ed3b6e238a0"" rel=""nofollow noreferrer"">https://netbasal.com/rxjs-six-operators-that-you-must-know-5ed3b6e238a0</a></p>
","3124703","","3124703","","2019-09-03 06:40:20","2019-09-03 06:43:50","Getting error while subscribing. subscribe is not a function","<javascript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57786729","1","57787021","","2019-09-04 10:42:47","","-1","669","<p>Want to filter array of objects in Angular8 with Observable. Did it with @Pipe but client recommends to use Observable.</p>

<p>I have an array. Need to filter it with 3 different inputs given in the UI.
Done this using the @Pipe like below.</p>

<pre class=""lang-html prettyprint-override""><code>&lt;tr *ngFor=""let d of data | filter : input1: input2: input3 &gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
</code></pre>

<p>But recommendation is to use observable. How can we do this?</p>
","1142530","","9423231","","2019-09-04 10:52:16","2019-09-04 11:01:30","How can I filter array with multiple criteria in Angular8 using Observable?","<angular><rxjs><rxjs6><angular8><angular2-observables>","1","2","0","","","CC BY-SA 4.0"
"57812770","1","57813241","","2019-09-05 20:45:00","","0","43","<p>I'm using an API from a Cordova plugin (<a href=""https://github.com/mauron85/cordova-plugin-background-geolocation"" rel=""nofollow noreferrer"">https://github.com/mauron85/cordova-plugin-background-geolocation</a>) in Ionic that allows you to subscribe to events like so:</p>

<pre><code>BackgroundGeolocation.on('location', (loc) =&gt; {
  // Handle location
});

BackgroundGeolocation.on('error', (error) =&gt; {
  // Handle error
});
</code></pre>

<p>I'm trying to wrap this interface into a single Observable so that I can subscribe to it the regular way and get updates:</p>

<pre><code>source.subscribe((loc) =&gt; {
  // handle location
}, (err) =&gt; {
  // handle error
})
</code></pre>

<p>How can I do this?</p>

<p>I've tried using <a href=""https://xgrommx.github.io/rx-book/content/getting_started_with_rxjs/creating_and_querying_observable_sequences/bridging_to_events.html#bridging-to-custom-events-with-fromeventpattern"" rel=""nofollow noreferrer""><code>fromEventPattern</code></a> and I can get the 'location' event like below but I'm not sure how to add in the errors as well.</p>

<pre><code>const source = fromEventPattern(
  function addHandler(h) {
    return BackgroundGeolocation.on('location', (location) =&gt; {
      h(location);
    });
  }, function delHandler(h, signal) {
    signal.remove();
  }
);
</code></pre>
","3312114","","","","","2019-09-05 21:34:30","Combining a source event and error event using RxJS","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"57843691","1","","","2019-09-08 16:23:34","","2","629","<h1>Problem</h1>

<p>Suppose there is a Http request observable that errored, we can just retry it. But I also want the UI to inform the user that this resource failed to load. What is the best architecture?</p>

<h1>Intended Behavior for the Target Observable</h1>

<ol>
<li>Retry-able.</li>
<li>Long-running. Doesn't complete or error.</li>
<li>Shared. Does not generate unnecessary requests when multiple subscriber.</li>
<li>Load on need. Does not generate unnecessary requests when not subscribed.</li>
<li>Inform UI of the errors.</li>
</ol>

<p>(3 and 4 can be achieved by <code>shareReplay({bufferSize: 1, refCount: true})</code>)</p>

<h1>My Attempts</h1>

<p>I think it's best to pass an error message to the downstream observer while keeping retrying the source. It causes minimum changes to the architecture. But I didn't see a way I can do it with Rxjs, because </p>

<ol>
<li><code>retry()</code> always intercepts the error. If you materialze the error, then <code>retry()</code> won't retry. If not, then no error will propagate to the downstream.</li>
<li><code>catchError()</code> without rethrowing will always complete the stream.</li>
</ol>

<p>Although let the UI observer <code>tap(,,onError)</code> and <code>retry()</code> can satisfy this need, but I think it is dangerous to let the UI take this responsibility. And multiple UI observer means a LOT of duplicated retries.</p>
","10657409","","10657409","","2019-09-08 16:33:41","2019-09-08 22:09:43","Rxjs - How to retry an errored observable while informing UI of the error","<rxjs><rxjs6><reactivex><data-layers>","2","0","","","","CC BY-SA 4.0"
"57844852","1","","","2019-09-08 18:49:26","","1","123","<h1>Problem</h1>

<p><code>mergeMap</code> has a static counterpart as <code>merge</code></p>

<p><code>concatMap</code> has a static counterpart as <code>concat</code></p>

<p>So is there something like a static <code>switch</code>?</p>

<h1>Motivation</h1>

<p>It might be useful if I want to have a <code>Subject</code>-like behavior with an async-ly loaded initial value (like a network request). If the user manually set its value before the async results arrives, then we cancel the initialization process.</p>

<p>So there is no data race (if we use <code>merge</code> or <code>source.pipe(take(1)).subscribe(val =&gt; subj.next(val))</code>) or blocking (if we use <code>concat</code>).</p>

<pre><code>let setValue$ = new Subject();
let getValue$ = switchStatic(
  getInitialValue().pipe(take(1)),
  setValue
)
</code></pre>

<p>If none, how do we implement this behavior?</p>
","10657409","","","","","2019-09-08 18:49:26","Rxjs - Is there a static creation operator behaves like 'switchMap'?","<rxjs><rxjs6><reactivex>","0","4","","","","CC BY-SA 4.0"
"57942192","1","","","2019-09-15 07:56:45","","2","1153","<p>I am creating an application in angular 8 and presently working on dashboard module where i have a scenario where onPush Strategy doesn't seems to be working i will be explaining my scenario with div structure if anyone can help me on this.</p>

<pre><code>&lt;div class=""parent"" *ngFor=""dashcontent of dashbboardsData""&gt;

&lt;app-widget-body [widget]=""dashcontent.widget""&gt;&lt;/app-widget-body&gt;


&lt;/div&gt;


&lt;div class=""sidebar""&gt; 

&lt;app-sidebar [(selectedWidget)]=""dashbboardsData[0].widget""&gt;

&lt;app-widget-settings [(widget)]=""selectedWidget""&gt;&lt;/app-settings&gt;

&lt;/app-sidebar&gt;

&lt;/div&gt;
</code></pre>

<p>Above is the scenario where i am changing widget.widgetName in <strong>app-widget-settings</strong> component, where app-widget-settings consist of text box which is bind with <strong>widget.widgetName</strong> using <strong>ngModel</strong>.</p>

<pre><code>&lt;input type=""text"" [(ngModel)]=""widget.widgetName""&gt;
</code></pre>

<p>here but my changes is not reflected in <strong>app-widget-body</strong> component where i am using</p>

<p><code>changeDetection: ChangeDetectionStrategy.OnPush</code></p>

<p>if i am removing changeDetection from app-widget-body then changes are reflected.</p>

<p>So in above what should we use so that changes when done in <strong>app-widget-settings</strong> component are reflected in <strong>app-widget-body</strong> component and i want to use ChangeDetectionStrategy.OnPush.</p>

<p>Below is the link for stackblitz</p>

<blockquote>
  <p><a href=""https://stackblitz.com/edit/angular-gjdjzg?file=src%2Fapp%2Fapp.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-gjdjzg?file=src%2Fapp%2Fapp.component.ts</a></p>
</blockquote>
","3013623","","3013623","","2019-09-15 16:06:17","2019-09-23 17:40:38","onPush Detection strategy not working in angular 8","<angular><performance><angular8><rxjs6><angular2-changedetection>","3","0","","","","CC BY-SA 4.0"
"58004185","1","58004323","","2019-09-19 05:23:25","","-1","87","<p>I am subscribing a value from a reducer, where it will always <code>true</code>. when first time i subscribes it works. but next time it's not. from my research always the value is <code>true</code> if i change value to <code>false</code> then it works fine.</p>

<p>so subscribe expect the different value to observer or unsubscription.  at present I do like this:</p>

<pre><code>this.store.dispatch(new actionsMc.CheckConcurrencySuccess(false));
this.store.dispatch(new actionsMc.CheckConcurrency(true));
</code></pre>

<p>even though I required to pass <code>true</code> always i do above to subscribe my update. instead of this work around any other way is there is <code>rxjs</code> any one help me?</p>

<p>in subscription i tried with take <code>once</code> but it not working further. but looking for some other work around.</p>

<p>here is my subscription:</p>

<pre><code>this.store.pipe(last(select(subscribe.newvalue))).subscribe(res =&gt; {
   console.log('new res', res);
}) 
</code></pre>

<p>but not works. as a simple how to subscribe and unsubscribe on each value received?</p>
","218349","","","","","2019-09-19 05:36:37","Is there a way to subscribe the same value all time without subscribe break?","<rxjs><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"58018134","1","58018467","","2019-09-19 19:54:20","","1","297","<p>I need an observable that emits an array of previous values upto X number of values.</p>

<p>Basically, something like <a href=""https://www.learnrxjs.io/operators/transformation/buffercount.html"" rel=""nofollow noreferrer"">bufferCount()</a> except that I want it to emit immediately and keep a running history.</p>

<pre class=""lang-js prettyprint-override""><code>of(1,2,3,4,5,6,7,8,9).pipe(
   bufferHistory(3)  // &lt;-- something like this
).subscribe(v =&gt; console.log(v));
// starts
// [1]
// [2,1]
// [3,2,1]
// [4,3,2]
// [5,4,3]
// [6,5,4]
// [7,6,5]
// [8,7,6]
// [9,8,7]
// competes
</code></pre>

<p>I can't find an operator for Rxjs 6 that does this, and the closest is <code>bufferCount()</code> but it <em>resets</em> after each array is emitted.</p>

<p>The order of the array output doesn't really matter. It can be <code>[3,2,1]</code> or <code>[1,2,3]</code> as that's just semantics right now.</p>
","1031569","","","","","2019-09-19 20:48:28","Emit previous values as an array in Rxjs 6?","<javascript><angular><rxjs><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"58109896","1","","","2019-09-26 05:07:57","","2","1090","<p>I have created a service which sends a request to the backend and makes the result available to the component via an observable.</p>

<pre><code>export class QuestionManagementService {

  questionsArray$: Observable&lt;Result&gt;;
private questionsArraySubject: BehaviorSubject&lt;Result&gt;; //to send list of questions
...
constructor(private http: HttpClient, private helper:HelperService, private bs:WebToBackendInterfaceService, private loaderService:LoaderService) {
    this.questionsArraySubject = new BehaviorSubject&lt;Result&gt;(new Result('initial',{})); //A Subject can act both as an Observable and an Observer
    this.questionsArray$ = this.questionsArraySubject.asObservable(); //create Observable. Other components can subcribe to it now to get notifications/values

...
}

//this method sends the request to network via another `bs` service. The request is sent using `http.post` 

getQuestions(questionFilter:GetQuestionsfilter){
    console.log(""In QuestionManagementService: getQuestions"");
    let observable:Observable&lt;HttpEvent&lt;any&gt;&gt; = this.bs.getQuestions(questionFilter);
    let subscription:Subscription =  observable.subscribe((ev:HttpEvent&lt;any&gt;)=&gt;{
          if(ev.type === HttpEventType.Response) { //null means that the response wasn't an HttpResponse but probably some internal Rxjs event (eg type 0)
            let response= &lt;HttpResponse&lt;any&gt;&gt;ev;
            console.log(""http response received: "",response);
            //should remove the token from storage

            console.log('response body from server: ',ev.body);
            let isResponseStructureOK: boolean = this.helper.validateServerResponseStructure(ev.body);
            if (isResponseStructureOK) {
              console.log(""response structure is OK"");
              let response: ServerResponseAPI = ev.body;
              let result:string = response.result;
              console.log(""result is : "" + result);
              /*if result could be success or error*/
              /*additionalInformation is a string and the string contains a valid json which has array of questions
              in format {""questions-list"":[{""tag"":""some tag1"",""description"":""some description1""},{{""tag"":""some tag2"",""description"":""some description2""},...]}
              */

              let message:string = response['additional-info'];
              console.log(""message is ""+message);

              if(result === ""success"") {
                let jsonQuestionList: string = response['additional-info'];
                console.log(""jsonQuestionList response as string: "", jsonQuestionList);
                //let jsonQuestions: PracticeQuestionsListAPI = JSON.parse(jsonQuestionList);
                //console.log(""jsonQuestion array:"", jsonQuestions);
                //this.questionsArraySubject.next(jsonQuestions['questions-list']);
                this.questionsArraySubject.next(new Result('success', response[""additional-info""]));
              } else {
                this.questionsArraySubject.next(new Result('error', response[""additional-info""]));
              }
            }
            else {
              /**
               * If something goes wrong, send error rather than send next with result=""error""
               */
              console.log(""received incorrect response structure from server: "", ev.body);
              //TODOM - need to change hard coded responses and pick them from a config or global variable.
              this.questionsArraySubject.error(new Result('error',""Invalid response structure from server""));
            }
          }
          else {
            console.log(""not response. ignoring"");
          }
        },
        (error:ServerResponseAPI)=&gt;{/*web to backend service will send error in ServerResponseAPI format. This is what handleError throws*/
          console.log(""got error from the Observable: "",error);
          this.questionsArraySubject.error(new Result('error',error['additional-info']));
        },
        ()=&gt;{ //observable complete
          console.log(""observable completed"")


        });


  }
}
</code></pre>

<p>The following component subscribes to this service.</p>

<pre><code>export class PraticeQuestionListComponent implements OnInit, OnDestroy {
questions: PracticeQuestionsListAPI; //the result from observable will be stored here.
questionListSubscription:Subscription; //reference of the subscription

ngOnDestroy(): void {
    console.log(""destroying component. unsubscribing"");
    this.questionListSubscription.unsubscribe()
  }
//on initialisation, I subscribe to the observable

  ngOnInit(){
    console.log(""in question list on init. question is "",this.questions);
   ...
    this.questions= new PracticeQuestionsListAPI(new AdditionalPagingInfo("""",new PartitionInfo(0,0)),
      []);

 let tagSubscription = this.questionManagementService.getSupportedTags(new TagId(""coding""));

    console.log(""subscribing to question mgmt service"");
    this.questionListSubscription = this.questionManagementService.questionsArray$.subscribe((result:Result)=&gt;{
      console.log('received result from question mgmgt service - array observable',result);
      if(result.result === ""success"") { //received response from server
        let questionList = JSON.parse(result.additionalInfo) as PracticeQuestionsListAPI;
        console.log(""got list of questions value "", questionList);
        this.questions['pagination-info'] = questionList['pagination-info'];
        this.questions['questions-list'] = questionList['questions-list'];
        /*
       0 length of questions-list means no questions.
       this could be response from the server indicating that there are no more questions
         */
        /*
        * the server indicates that there are no more questions by either sending empty question list or by sending
        * 0 values for pagination state and partition info
        */
        if (questionList[""questions-list""].length !== 0) { //server has send list of questions
          this.questions['pagination-info']['page-state'] = questionList['pagination-info']['page-state'];
          this.questions['pagination-info']['partition-info'] = questionList['pagination-info']['partition-info'];
          this.questions['questions-list'] = questionList['questions-list'];
          console.log(""previous question filter is "",this.questionsFilter);

          this.questionsFilter[""pagination-info""][""page-state""]=questionList[""pagination-info""][""page-state""];
          this.questionsFilter[""pagination-info""][""partition-info""].month=questionList[""pagination-info""][""partition-info""].month;
          this.questionsFilter[""pagination-info""][""partition-info""].year=questionList[""pagination-info""][""partition-info""].year;

          console.log(""new question filter is "",this.questionsFilter);
          //TODOM - maybe this assignment below was causing memory leak. So changed this as above
          //this.questionsFilter['pagination-info'] = questionList['pagination-info'];
          this.lastPage = false; //the server indicates that there are no more questions by sending these values (no paging state and no partition info)
          if (this.questions['pagination-info']['page-state'].length == 0 &amp;&amp;
            this.questions['pagination-info']['partition-info'].year == 0 &amp;&amp;
            this.questions['pagination-info']['partition-info'].month == 0) {
            this.lastPage = true;
          } else {//if the list is empty then there are no (more) questions for the selected tag
            this.lastPage = false;

          }
        } else {
          this.lastPage = true; //Don't show next button if there are no questions.
          this.showDialog(new PracticeQuestionListContext(""Reached end of the search. No more results available"", new PracticeQuestionListAdditionalInfo()));
        }
      } else {
        //TODOM - I should probably display the error in case there is an error from the server
        console.log(""ignoring value"");
      }
    },
    (err:Result)=&gt;{
        console.log(""received error from QuestionArray observable"",err);
        //TODOM - probably should change the name of DialogContext to Component specific additional context
        this.showDialog(new PracticeQuestionListContext(err.additionalInfo,new PracticeQuestionListAdditionalInfo()));
      },
      ()=&gt;{
      console.log(""question mgmt service, questionarray observable completed."");
      });
  }
}
</code></pre>

<p>The issue I am facing is that if I visit the component for the first time, I get the values from the observable after making some selections in the UI (expected behavior). Then i visit the home page of the application, the component gets destroyed (again, expected behavior). Then if I visit the component again, the observable sends the old values (from the first visit) even when I have not made any UI selections.</p>

<p>Why is the observable sending old values and how can I stop it from doing that? I have created another question in <code>SO</code> with pictures which might explain the scenario better</p>

<p><a href=""https://stackoverflow.com/questions/58103125/angular-component-is-retaining-old-value-maybe-because-the-observable-is-resendi"">angular component is retaining old value maybe because the observable is resending past data</a></p>
","6703783","","","","","2019-09-26 05:07:57","Why is the observable sending old values","<angular6><rxjs6>","0","3","","","","CC BY-SA 4.0"
"58111396","1","","","2019-09-26 07:14:30","","0","63","<p>I have a <code>BehaviorSubject</code>. I am trying to convert its <code>Observable</code> into a <code>ConnectableObservable</code> but I am getting error <code>publishBehaviour</code> is not a function. What am I doing wrong?</p>

<blockquote>
  <p>this.questionsArray$.publishBehavior is not a function TypeError:
  this.questionsArray$.publishBehavior is not a function</p>
</blockquote>

<p>The code snippet is</p>

<pre class=""lang-ts prettyprint-override""><code>private questionsArraySubject: BehaviorSubject&lt;Result&gt;; 
questionsArray$: Observable&lt;Result&gt;;
questionsArrayConnectable$:ConnectableObservable&lt;Result&gt;;

this.questionsArraySubject = new BehaviorSubject&lt;Result&gt;(new Result('initial',{}));

// create Observable. Other components can subcribe to it now to get notifications/values
this.questionsArray$ = this.questionsArraySubject.asObservable(); 
this.questionsArrayConnectable$ = this.questionsArray$.publishBehavior(new Result('initial',{}))
</code></pre>
","6703783","","9423231","","2019-09-26 15:11:46","2019-09-26 15:11:46","unable to convert an Observable into a ConnectableObservable","<rxjs><rxjs6><rxjs-observables>","0","3","","","","CC BY-SA 4.0"
"58129850","1","58131914","","2019-09-27 07:31:15","","1","108","<p>I have a method that gets the userlist from the api and populates the list component. Now what i want to do 
is highlight the first element of the list once the list is loaded from the api.
I have tried the following approach and it is working fine with setTimeout but how can i make it happen without setTimeout function</p>

<p>Here is the code that i tried,</p>

<pre><code>public getUserList(){ 
    return this.http.get('https://jsonplaceholder.typicode.com/users').pipe(tap(x =&gt; {
      this.lists = x;
    }))
    .subscribe((data) =&gt; {
      setTimeout(() =&gt; { 
        this.clickFirstList();
      }, 1000);
    });
  }

clickFirstList() {
    Array.from(this.ulElement.nativeElement.children).forEach((element: HTMLElement, index: number) =&gt; {
      if (index === 0) {
        console.log(element);
        element.click();
      }
    });
}
</code></pre>

<p>Here is the working code on stackblitz. <a href=""https://stackblitz.com/edit/angular-brpz2j?file=src/app/search-list.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-brpz2j?file=src/app/search-list.component.ts</a></p>
","4646531","","","","","2019-09-27 10:29:10","How to wait for data from api to be loaded and then perform another action in the UI?","<javascript><angular><typescript><rxjs><rxjs6>","4","7","","","","CC BY-SA 4.0"
"58140621","1","58141145","","2019-09-27 19:50:36","","2","1548","<p>I am having issue with setting interval between http requests within one observable.
Thing is - i want to have delay between each http request, wait for all requests to be completed, and perform operation on combined data from all requests.
Of course length of documents array is not known.</p>

<p>Example code:</p>

<pre><code>const documents = [
  {
    'documentId': 1,
    'documentName': 'DocName1'
  },
  {
    'documentId': 2,
    'documentName': 'DocName2'
  },
];

function saveDocumentService(document) {
  document['someAnotherData'] = '123';

  return of(document); // in real world http.post()
}

const documentsToSave$ = zip(
  documents,
  interval(200),
  document =&gt; {
    document['someDataToBeInserted'] = {'data': 123};
    return saveDocumentService(document);
  }
);

const sub = forkJoin(documentsToSave$).subscribe(documents =&gt; {
  console.log('All documents uploaded', documents); // array of responses
});
</code></pre>

<p>With this approach, only last value is outputted.</p>

<p>Thanks.</p>
","966644","","","","","2019-09-27 21:33:17","RXJS how to delay each observable (http request) and combine all requests output","<angular><rxjs><observable><rxjs6>","4","0","1","","","CC BY-SA 4.0"
"58172059","1","58182660","","2019-09-30 16:45:13","","-1","101","<p>I am making an api call and expecting a response from it which can be passed to 2nd api call but I am getting an error</p>

<blockquote>
  <p>ERROR TypeError: this.helperService.getPointIdbyTags(...)[0].pipe is not a function</p>
</blockquote>

<p>on line .pipe(switchMap((resarray:any)=>{</p>

<p>TS code</p>

<pre><code>someFunction(floor){
 floor.entities.forEach(element =&gt; {
       let desiredTempForZone;

       this.getCurrentValue(element.name).subscribe((des) =&gt; 
                      {
                         currentTempForZone = des
                       });
       console.log(currentTempForZone);
})
}

getCurrentValue(eleName){
    let roomObj = this.getRoomObj(eleName);
    let equipRef = roomObj.map(equip =&gt; equip.entities.filter(entity =&gt; entity.entities.length &gt; 0)[0])[0];

    return this.helperService.getPointIdbyTags(this.buildings, ['current', 
             'temp'], equipRef.referenceIDs.room)[0]
              .pipe(switchMap((resarray:any)=&gt;{
                   const res = resarray[0]
                   return  this.siteService.getHisPointData(res, 'current')
                       .pipe(
                           map(this.helperService.stripHaystackTypeMapping),
                       )
              }));
}
</code></pre>

<p>And then I am trying to pass it on to</p>

<pre><code>switchMap((resarray:any)=&gt;{
               const res = resarray[0]
               return  this.siteService.getHisPointData(res, 'current')
</code></pre>
","7468279","","7468279","","2019-10-02 09:19:22","2019-10-02 09:19:22","After getting the response from post api call , an error is thrown => .pipe is not a function","<angular><rxjs><observable><rxjs6>","1","8","","","","CC BY-SA 4.0"
"58181411","1","","","2019-10-01 09:01:53","","0","31","<p>Please advise how to tackle this.<br>
How to remove specific element e1 from Observable myObserv (received after calling getAllProducts API) . </p>

<p>This specific element <strong>e1</strong> is determined based on the response from (subsequent call) getUsedProducts API Observable</p>

<pre><code>myObserv.subscribe(next:resp1 =&gt; {},error: err =&gt;{},()=&gt;{}) 
</code></pre>
","1157070","","1157070","","2019-10-01 14:53:27","2019-10-01 15:38:29","How to remove specific element e1 from Observable<MyModel>","<angular><rxjs6>","2","1","","","","CC BY-SA 4.0"
"58199431","1","58199592","","2019-10-02 10:06:28","","2","69","<p>I am making 4 asynchronous api calls</p>

<pre><code>floor.entities.forEach(elementId =&gt; {
  let objTemp: any = {};

  objTemp.main = elementId.name

  let currentTempForZone;

//1st async function
   this.getCurrentValue(objTemp.main).subscribe((curr) =&gt;
       { 
         objTemp.currentTemp = curr.rows[0].val
        }
     );
//2nd async function
    this.getDesiredHeatingTemp(elementId._id).subscribe(([des]) =&gt;
       {
         objTemp.desiredTempHeating = des.rows[0].val.split(':')[1]
        }
      );
//3rd async function
     this.getDesiredCoolingTemp(elementId._id).subscribe(([des]) =&gt; 
        {
          objTemp.desiredTempCooling = des.rows[0].val.split(':')[1]
          }
       );

let condition;

//4th
   this.deviceHelper.getConditioningStatusForZone(elementId._id);
   this.deviceHelper.conditioningTypeSubject.subscribe(condType =&gt; {
                                  console.log(condType);
                                  condition = condType                                    
               });

if(condition == 'first' ){
     let zoneTempDiff1 = objTemp.currentTemp - objTemp.desiredTempHeating;
     let tempColor1 = this.customColors.filter(color =&gt; zoneTempDiff1 &lt; (color.temp + 1) &amp;&amp; zoneTempDiff1 &gt; (color.temp - 1));
     objTemp.tempColorToInsert = tempColor1.color
    }
else if(condition == 'second' ){
     let zoneTempDiff2 = objTemp.currentTemp - objTemp.desiredTempCooling;
     let tempColor2 = this.customColors.filter(color =&gt; zoneTempDiff2 &lt; (color.temp + 1) &amp;&amp; zoneTempDiff2 &gt; (color.temp - 1));
     objTemp.tempColorToInsert = tempColor2.color
      }

      floor.droppeditem.push(objTemp);
}
</code></pre>

<p>I am getting all the 3 values objTemp.currentTemp, objTemp.desiredTempHeating, objTemp.desiredTempCooling and the condition but they all are asynchronous
How can I assign value to objTemp.tempColorToInsert after doing calculations using the above 4 values.</p>

<p>============================================================================</p>

<pre><code>customColors: any = [
    {
        color: '#50B3D3',
        temp: -1
    },
    {
        color: '#25CBE4',
        temp: -2
    },
    {
        color: '#25CBE4',
        temp: 0
    },
    {
        color: '#7EE2DD',
        temp: 1
    },
    {
        color: '#7EE2DD',
        temp: 2
    }
    ]
</code></pre>

<p><strong>Update</strong></p>

<p>I have done something like and I am getting values , just wanted to know the response will automatically be mapped to their respective element </p>

<pre><code>   forkJoin([this.getCurrentValue(objTemp.main),this.getDesiredHeatingTemp(elementId._id),this.getDesiredCoolingTemp(elementId._id)])
        .subscribe(([current,[desiredheat], [desirecooling]])=&gt;{
            objTemp.currentTemp = current.rows[0].val;
            objTemp.desiredTempHeating = desiredheat.rows[0].val.split(':')[1];
            objTemp.desiredTempCooling = desirecooling.rows[0].val.split(':')[1];

                let condition = 'first'

                    if(condition == 'first' ){
                        let zoneTempDiff1 = objTemp.currentTemp - objTemp.desiredTempHeating;
                        let tempColor1 = this.temperatureColors.filter(color =&gt; zoneTempDiff1 &lt; (color.temp + 1) &amp;&amp; zoneTempDiff1 &gt; (color.temp - 1));
                        objTemp.tempColorToInsert = tempColor1.color
                    }else if(condition == 'second' ){
                        let zoneTempDiff2 = objTemp.currentTemp - objTemp.desiredTempCooling;
                        let tempColor2 = this.temperatureColors.filter(color =&gt; zoneTempDiff2 &lt; (color.temp + 1) &amp;&amp; zoneTempDiff2 &gt; (color.temp - 1));
                        objTemp.tempColorToInsert = tempColor2.color
                    }
  })
</code></pre>
","7468279","","7468279","","2019-10-02 10:55:51","2019-10-02 10:55:51","Using values from multiple async calls and then performing calculations to push the value","<javascript><angular><rxjs><observable><rxjs6>","4","0","","","","CC BY-SA 4.0"
"58212176","1","58216372","","2019-10-03 04:08:57","","1","62","<p>Compare this</p>

<pre><code>return this.httpClient.get('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/suggest', {params: data}).pipe(
            map((x: any) =&gt; x.suggestions.map((y) =&gt; {
                return {
                    ...y,
                    title: y.text
                };
            })),
        );
</code></pre>

<p>with this</p>

<pre><code>return this.httpClient.get('https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/suggest', {params: data}).pipe(
            map((x: any) =&gt; x.suggestions),
            map((y: any) =&gt; y.title = y.text)
        );
</code></pre>

<p>Why these cases are not equal?</p>

<p>The first work as expected, ""remove"" suggestions property and duplicate property text to title</p>

<p>The second returns me a value... not array</p>

<p>Can I use only map() function instead of .map()?</p>
","913951","","913951","","2019-10-03 05:35:08","2019-10-03 09:40:15","Rxjs - Comparing .map() with map()","<angular><rxjs><rxjs6>","2","1","","","","CC BY-SA 4.0"
"58231964","1","58232697","","2019-10-04 07:42:39","","1","71","<p>I have two pipes, one is used as data for a graph, the other is used as a data loading indicator</p>

<pre><code>graphData$: Observable&lt;GraphData&gt;;
dataLoaded$: Observable&lt;boolean&gt;;
</code></pre>

<p>I need the following pipe: <code>graphData$</code> emissions need to be stopped when <code>dataLoaded$</code> is emitting <code>false</code>. When <code>dataLoaded$</code> switches from <code>false</code> to <code>true</code>, I want the last stopped emission of <code>graphData$</code> to be emitted through the pipe. When <code>graphData$</code> is emitting <code>true</code> I want to simply bypass the pipe.</p>

<p>For now I'm solving it in the following fashion:</p>

<pre><code>combineLatest([
  graphData$,
  dataLoaded$
]).pipe(
    filter(([_, dataLoaded]) =&gt; dataLoaded),
    map(([graphData]) =&gt; graphData)
).subscribe(graphData =&gt; blabla)
</code></pre>

<p>But there are an arbitrary number of data streams that need to be curbed by whether or not data is loaded, so I'd prefer a pipe that allows me to simply:</p>

<pre><code>graphData$.pipe(
  dataLoaded()
).subscribe(graphData =&gt; blabla)
</code></pre>

<p>Any elegant solutions on how to do this?</p>
","8779395","","","","","2019-10-04 08:34:55","RxJs pipe that holds data when loading, emits on load, allows emit when loaded","<observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"58237453","1","58237662","","2019-10-04 13:31:29","","1","35","<p>I'm having trouble promises and observables.  I have a handful of http requests which are defined in a package using promises.  In the rest of my code I am using observables for various things, including other http calls.  In one particular section I am checking to see if the user's bearer token is expired and if so then I get a new token and then proceed with the rest of the call.</p>

<pre><code>if (!token || token.exp &lt; Math.round((new Date()).getTime() / 1000)) {
  from(this._store.refreshBearerToken())
    .pipe(flatMap(resp =&gt; {
       let newToken = resp.data;
       newToken.exp = (new Date()).getTime() / 1000 + newToken.expires_in;
       localStorage.setItem('token', JSON.stringify(newToken))

       options = options || {};
       options.headers = new HttpHeaders({
         ""Authorization"": `${newToken.token_type} ${newToken.access_token}`,
         ""Content-Type"": ""application/json""
        });
       return this._http$.request&lt;T&gt;(method, url, options as Object).pipe(share());
     }));
}
</code></pre>

<p>Bearer Token method:</p>

<pre><code>async refreshBearerToken() {
    const response = await this._q2.sources.requestExtensionData({
        route: ""refreshBearerToken""
    });
    console.log(response);
    return response;
}
</code></pre>

<p>Since <code>this._store.refreshBearerToken</code> returns a promise I wrapped the call in a <code>from</code> to convert it to an observable.  This compiles but when it runs I get ""Cannot read property 'pipe' of undefined"".  </p>

<p>How can I convert this promise to an observable so that I can refresh the token and then continue with the rest of the call?</p>

<p>Edit:</p>

<p>I am importing <code>from</code> via <code>import { Observable, from } from ""rxjs"";</code>.</p>

<p>So, I thought the error was coming from the line <code>.pipe(flatMap(resp =&gt;...</code> but I was wrong.  The error is coming from the method which is calling this.</p>

<pre><code>GetInitialLinkList(): Observable&lt;Institution[]&gt;
{
    let base = { 'MemberId': localStorage.getItem('memberId') };
    let ins = localStorage.getItem(""initialInstitutionList"");
    if (ins)
    {
        return of(JSON.parse(ins));
    }
    return this._settingsService.get().pipe(
        flatMap(settings =&gt;
        {
            this._settings = settings;
            return this._api.request&lt;Institution[]&gt;(""Post"", `${this._settings.mea}/GetInitialLinkList`, { body: base })
                .pipe(
                    retry(1),
                    catchError(this.handleError)
                )
                .pipe(flatMap(instList =&gt;
                {
                    localStorage.setItem(""initialInstitutionList"", JSON.stringify(instList));
                    return of(instList);
                }))
        }));
}
</code></pre>

<p>and that is being subscribed to inside my component:</p>

<pre><code>private GetLinkList()
{
    this.showWaiting.emit(true);
    this._data.GetInitialLinkList().subscribe((result) =&gt;
    {
        this.initialList = result;
        this.showWaiting.emit(false);
    });
}
</code></pre>

<p>From what Brandon said (I forgot to return /facepalm...) I added the return so I have <code>return from(this._store.refreshBearerToken())</code> which changed my error to </p>

<pre><code>ERROR Error Code: undefined
Message: You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
defaultErrorLogger @ core.js:6014
</code></pre>
","3043148","","3043148","","2019-10-04 14:09:25","2019-10-04 14:09:25","How do I blend a promise with an observable?","<rxjs><angular8><rxjs6>","1","6","","","","CC BY-SA 4.0"
"58261991","1","","","2019-10-06 23:19:42","","0","367","<p>I am writing an Angular8 application where the server always gives 200s series answers. All errors from the server side are wrapped inside the <code>Response object</code> therefore, I have to create errors from it.</p>

<p><strong>A typical answer looks like the following</strong>; where the <code>APP_CODE</code> property represents health of the answer, <code>APP_CODE: '001'</code> means I can read it from result array. If it is <code>APP_CODE=""002""</code> or <code>APP_CODE=""002""</code> then there is an error and I should read the error array, etc.</p>

<pre><code>{ ""input"": null, 
  ""warningMessages"": [],
  ""errorMessages"": [
     ""Please enter at least 3 characters""
  ],
  ""numFound"": 0,
  ""results"": [],
  ""APP_CODE"": ""003""
}
</code></pre>

<p><strong>Solution Strategy</strong>: There are several strategies that I can go with, but the one that I want is at service level using <code>map</code> in <code>pipe</code>, generate application specific error then <code>catchError()</code>, and pass it to component to decide how to show it whether in a toast, or somehow in the form.</p>

<p>Therefore the code should look like this</p>

<pre><code>private handleError(error: MyAppError) {
    console.log('******got you inside handleError', error);
    return throwError(error);
  }

private handleErrorAppCodes(res: any[]) {
    console.log('**** handleErrorAppCodes ****');
    console.log(""%o"", res);
    if (res[""APP_CODE""] === ""003"") {
    console.log('dataAccess service| Results APP_CODE is', res[""APP_CODE""]);
    return throwError(new MyAppError('APP CODE 3:' + res[""errorMessages""][0]));
  } 
}
  return res;
}


getMyObject(objectName: string):Observable&lt;any[]&gt; {

let url = 'thisIsAUrl';

return this.http.get&lt;any[]&gt;(url).pipe(
  map(this.handleErrorAppCodes),
  catchError(this.handleError)
);
</code></pre>

<p>Seems to be a descent error. BUT I get the following error during compile</p>

<pre><code>error TS2322: Type 'Observable&lt;any[] | Observable&lt;never&gt;&gt;' is not assignable to type 
'Observable&lt;any[]&gt;'.Type 'any[] | Observable&lt;never&gt;' is not assignable to type 'any[]'.
Type 'Observable&lt;never&gt;' is missing the following properties from type 'any[]': length, pop,  
push,concat, and 25 more.
</code></pre>

<p>I also tried <code>map(res =&gt; this.handleErrorAppCodes(res))</code> the compile error is similar.</p>

<p>Later I tried <code>map&lt;any[]&gt;(this.handleErrorAppCodes)</code> but I got</p>

<pre><code>error TS2558: Expected 2 type arguments, but got 1.
</code></pre>
","2809423","","","","","2020-02-23 14:08:32","Creating custom errors hidden in backend response in Angular","<angular><observable><angular-httpclient><rxjs6><rxjs-pipeable-operators>","2","1","1","","","CC BY-SA 4.0"
"58368844","1","","","2019-10-14 00:34:11","","0","78","<p>The situation is as follows:
There is a text. Every text change, and I submit a request. 
The response text is divided into parts.
Then I send each part to the server again.</p>

<p>Example:</p>

<p>Request - Response
<strong>1234567 => [1], [2], [3,4], [5, 6, 7]</strong>
Request Queue
<strong>[1] => [2] => [3,4] => [5,6,7]</strong></p>

<p>Change the text</p>

<p>Request - Response
<strong>12334567 => [1], [2], [3,3,4], [5, 6, 7]</strong></p>

<p>Here I want to compare prev answer with new one, to send only
<strong>[3, 3, 4]</strong></p>

<p>I decided to make it all as stream, and finally deal with RxJS.
Actually looking for RxJS way</p>
","5242690","","","","","2019-10-14 04:55:26","How do I cache requests using RXjs?","<rxjs><rxjs5><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"58375178","1","58401440","","2019-10-14 10:48:32","","2","1428","<blockquote>
  <p>When run the tests i am getting i am getting the  ""TypeError: this.dashboardService.serviceAgents$.pipe is not a function"" error.</p>
</blockquote>

<ul>
<li>ServiceDashboard page code as below :</li>
</ul>

<pre><code>
     import { Component } from '@angular/core';
     import { ServiceDashboardService } from '../services/service-dashboard.service';
     import { tap } from 'rxjs/operators';
     import { ServiceAgent } from '../interfaces/service-agent';
     @Component({
         selector: 'app-service-dashboard',
         templateUrl: './service-dashboard.page.html',
         styleUrls: ['./service-dashboard.page.css'],
     })
     export class ServiceDashboardPage {
         serviceAgentSlideOptions: any = {
             slidesPerView: 4
         };
         serviceAgents$ = this.dashboardService.serviceAgents$
             .pipe(
                 tap(serviceAgents =&gt; {
                     this.serviceAgentSlideOptions.slidesPerView = serviceAgents.length &lt; 4 ? serviceAgents.length : 4;
                 })
             );
         constructor(private dashboardService: ServiceDashboardService) { }
     }  
</code></pre>

<ul>
<li>Following is the unit test code for the ServiceDashboardPage.</li>
</ul>

<pre><code>      import { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
      import { async, ComponentFixture, TestBed } from '@angular/core/testing';
      import { ServiceDashboardPage } from './service-dashboard.page';
      import { ServiceDashboardService } from '../services/service-dashboard.service';
      import { ServiceAgent } from '../interfaces/service-agent';
      import { of } from 'rxjs';
      describe('ServiceDashboardPage', () =&gt; {
          let component: ServiceDashboardPage;
          let fixture: ComponentFixture&lt;ServiceDashboardPage&gt;;
          let serviceDashboardServiceSpy: ServiceDashboardService;
          beforeEach(async(() =&gt; {
              serviceDashboardServiceSpy = jasmine.createSpyObj('ServiceDashboardService', 
           ['serviceAgents$']);
              TestBed.configureTestingModule({
                  declarations: [ServiceDashboardPage],
                  schemas: [CUSTOM_ELEMENTS_SCHEMA],
                  providers: [
                      { provide: ServiceDashboardService, useValue: serviceDashboardServiceSpy }
                  ]
              })
              .compileComponents();
          }));
          beforeEach(() =&gt; {
              fixture = TestBed.createComponent(ServiceDashboardPage);
              component = fixture.componentInstance;
              fixture.detectChanges();
          });
          it('should create', async(() =&gt; {
              (serviceDashboardServiceSpy.serviceAgents$ as unknown as 
           jasmine.Spy).and.returnValue(of([] as ServiceAgent[]));
              expect(component).toBeTruthy();
          }));
      });  
</code></pre>
","2056483","","","","","2019-10-15 19:27:15","Getting TypeError pipe is not a function while testing angular component using observable with declarative approach using async","<javascript><angular><jasmine><karma-runner><rxjs6>","1","5","0","","","CC BY-SA 4.0"
"58381961","1","58382505","","2019-10-14 18:04:29","","1","3277","<p>As per the title, I've been trying to figure out a way to make multiple HTTP calls from an action payload and basically merging all results into a single array and then map the result to another action as a payload.</p>

<p>Here is my existing code, it works but it seems it seem not merging both responses and only cares about last response from the request's response, perhaps I'm using the wrong operator, I'm just picking up RxJS and trying different things to learn, hopefully somebody is able to explain where I'm going wrong.</p>

<p>Any help or direction is much appreciated.</p>

<pre><code>
{
    type: 'FETCH_DATA',
    payload: {
        key: 'standings',
        value: [
                'http://url-1',
                'http://url-2'
        ],
    })
}


// The epic is listening to the above action

const fetchDataEpic = action$ =&gt; action$.pipe(
    ofType('FETCH_DATA'),
    mergeMap(action =&gt; {
        const { key, value } = action.payload;
        if (Array.isArray(value) &amp;&amp; value.length) {
            const makeRequest = value.map((x, i) =&gt; ajax.getJSON(value[i]))

            return (
                forkJoin(
                    makeRequest,
                    response =&gt; {
                        return ({
                            type: 'FETCH_DATA_SUCCEEDED',
                            payload: {
                                key,
                                value: response,
                            },
                        })
                    }
                )
            )
        }
    })
);
</code></pre>

<p>NOTE: Both request's response is in same JSON format with same properties, but different data.</p>

<p>Thanks in advance</p>
","12216137","","","","","2019-10-14 22:53:54","How to make multiple HTTP requests with RxJS and merge the response into one payload and map it to another action?","<javascript><reactjs><rxjs><observable><rxjs6>","2","0","","","","CC BY-SA 4.0"
"58383112","1","","","2019-10-14 19:40:55","","0","466","<p>I'm trying to create a custom <code>retryWhen</code> strategy which attempts to <code>retry</code> N times with X delay in-between and fail afterwards. To some extent the <a href=""https://www.learnrxjs.io/operators/error_handling/retrywhen.html"" rel=""nofollow noreferrer"">learnrxjs.io</a> example is exactly what I'm looking for. </p>

<p>Unfortunately there is an issue with this code which I can't seem to figure how to resolve.
In my case, the observable can fail randomly - you can have <code>2 successful</code> attempts and then <code>2 unsuccessful</code> attempts. After a while the subscription will automatically complete, because the <code>retryAttempt</code>s will exceed the maximum although that has not happened in practice.</p>

<p>To better understand the issue I've created a <a href=""https://stackblitz.com/edit/rxjs-retry-strategy-issue?embed=1&amp;file=index.ts&amp;hideExplorer=1&amp;devtoolsheight=50"" rel=""nofollow noreferrer"">StackBlitz</a></p>

<p>The response will be:</p>

<pre><code>  Attempt 1: retrying in 1000ms
  0
  1
  Attempt 2: retrying in 2000ms
  Attempt 3: retrying in 3000ms
  0
  1
  We are done!
</code></pre>

<p>But it should actually be</p>

<pre><code>  Attempt 1: retrying in 1000ms
  0
  1
  Attempt 1: retrying in 1000ms &lt;-- notice counter starts from 1
  Attempt 2: retrying in 2000ms
  0
  1
  Attempt 1: retrying in 1000ms &lt;-- notice counter starts from 1
  0
  1
  Attempt 1: retrying in 1000ms &lt;-- notice counter starts from 1
  Attempt 2: retrying in 2000ms
  0
  1
  ... forever
</code></pre>

<p>I feel like I'm missing something here.</p>
","393805","","393805","","2019-10-14 20:26:52","2019-10-14 22:22:52","rxjs custom retryWhen strategy with auto incremented delay not working properly","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"58397600","1","58397838","","2019-10-15 14:59:06","","0","293","<p>Ok so this will seem silly but please help if you can.
I want to start using RXJS.</p>

<p>as opposed to vanilla javascript it doesnt seem to work by just downloading it and then importing from the local source file.
(simple example):</p>

<p>HTML:</p>

<pre><code>    &lt;head&gt;
    &lt;meta charset=""utf-8""&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;script src=""app.ts""&gt;&lt;/script&gt;
    &lt;/body&gt;
</code></pre>

<p>app.ts:</p>

<pre><code>    // RxJS v6+
    import { interval } from 'rxjs';
    import { sample } from 'rxjs/operators';
</code></pre>

<p>I get an error though that this is a valid object (obviously because there is no rxjs loaded via the initial html page as a script)</p>

<p>QUESTION: What is a good way to load rxjs assuming that I want to create an offline site that the user downloads once and then uses the resources importing them from this local file (not all at once obviously) for route?</p>

<p>** I dont want to run a server on client side though if possible**</p>

<p>Thanks,
Alex</p>

<pre><code>    HTML:

    &lt;head&gt;
        &lt;meta charset=""utf-8""&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=""app.ts""&gt;&lt;/script&gt;
    &lt;/body&gt;
</code></pre>

<p>app.ts:</p>

<pre><code>    // RxJS v6+
    import { interval } from 'rxjs';
    import { sample } from 'rxjs/operators';
</code></pre>
","10810648","","","","","2019-10-15 19:20:23","Can RXJS run without a server on (client side)?","<javascript><rxjs6>","2","4","","","","CC BY-SA 4.0"
"58398112","1","58422120","","2019-10-15 15:26:57","","1","97","<p>I have an array of objects with children and have a need to set a field (hidden) in each of those objects recursively. The value for each is set in a subscription. I want to wait until each item in the array is recursively updated before the subscription is complete.</p>

<p>The hidden field will be set based on roles and permissions derived from another observable. In the example I added a delay to simulate that.</p>

<p>Here's my first pass at it. I'm certain there is a much cleaner way of going about this.</p>

<p><a href=""https://codesandbox.io/s/rxjs-playground-hp3wr"" rel=""nofollow noreferrer"">https://codesandbox.io/s/rxjs-playground-hp3wr</a></p>

<pre><code>// Array structure. Note children.
const navigation = [
  {
    id: ""applications"",
    title: ""Applications"",
    children: [
      {
        id: ""dashboard"",
        title: ""Dashboard""
      },
      {
        id: ""clients"",
        title: ""Clients""
      },
      {
        id: ""documents"",
        title: ""Documents"",
        children: [
          {
            id: ""dashboard"",
            title: ""Dashboard""
          },...
        ]
      },
      {
        id: ""reports"",
        title: ""Reports""
      },
      {
        id: ""resources"",
        title: ""Resources""
      }
    ]
  }
];
</code></pre>

<p>In the code sandbox example, looking at the console messages, I get the correct result. However, I would like to avoid having to subscribe in setHidden and recursivelySetHidden. I would also like to avoid using Subject if possible.</p>
","2162473","","","","","2019-10-16 21:49:49","Wait for Subscription set Recursively to Complete","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"58398632","1","58401493","","2019-10-15 15:59:57","","1","48","<p>I just want to log an error and skip this step, but with delay and with true typescript infer.</p>

<pre class=""lang-js prettyprint-override""><code>const fetch = () =&gt;
  Math.random() &gt; 0.5
    ? Promise.resolve(""Success"")
    : Promise.reject(""Some error"");

const x = timer(0, 1000).pipe(
  mergeMap(() =&gt; fetch()),
  catchError((err, caught) =&gt; {
    console.log(""Error: "", err);
    return caught; // After this a pipe starts again, but without delay, because a timer starts with 0 !!!
  }),
);

x.subscribe((data) =&gt; {
  console.log(data);
});

</code></pre>

<p>I need to make a delay after caught error.</p>
","3551506","","","","","2019-10-15 19:31:28","How to skip error with delay in RxJS with a right typescript infer?","<rxjs><rxjs6>","1","0","0","","","CC BY-SA 4.0"
"58414661","1","58416675","","2019-10-16 13:34:54","","2","3958","<p>I find myself puzzled trying to set a very simple rxjs flow of subscriptions. Having multiple non-related subscriptions nested into another.</p>

<p>I'm in an angular application and I need a subject to be filled with next before doing other subscriptions.</p>

<p>Here would be the nested version of what I want to achieve.</p>

<pre><code>subject0.subscribe(a =&gt; {

    this.a = a;

    subject1.subscribe(x =&gt; {
        // Do some stuff that require this.a to exists
    });

    subject2.subscribe(y =&gt; {
        // Do some stuff that require this.a to exists
    });

});
</code></pre>

<p>I know that nested subscriptions are not good practice, I tried using <code>flatMap</code> or <code>concatMap</code> but didn't really get how to realize this.</p>
","7635889","","","","","2019-10-16 15:18:07","Multiple subscriptions nested into one subscription","<rxjs><observable><rxjs6><subject><angular-observable>","3","1","","","","CC BY-SA 4.0"
"58444934","1","","","2019-10-18 06:13:38","","0","119","<p>I have created one monthly dashboard in my Angular 7 application, it show 8 charts(built by google charts) for every month and first chart details as a table to the bottom of charts div.</p>

<p>When I change month 8 different APIs will call and load data for 8 charts.</p>

<p>Here the issue is my application was getting slow down for the time been. Even though I followed API unsubscribe methodology in a correct way, page was falling in slow performance issues.</p>

<p>Only this dashboard page was facing this issue remaining pages are working fine.</p>

<p>Here is the sample code</p>

<pre><code>this.widgetsList.forEach((eachWidget, i) =&gt; {
this.subsWidg.add(this.dashboardsService.getCountOfInProcessApprovals(this.monthId, this.processType, eachWidget.id).subscribe((res: any[]) =&gt; { }))
})

public ngOnDestroy() {
    this.subsWidg.unsubscribe();
}
</code></pre>

<p><strong>Another Observation</strong>: I have removed all my code in component and added charts with static data(There was no API calls) but still page response is same no change. I guess something is dominating google charts in my application.</p>
","7434324","","7434324","","2019-10-18 06:31:33","2019-10-18 06:31:33","Angular 7 Application Performance Slowdown","<angular><rxjs6><google-visualization>","0","8","","","","CC BY-SA 4.0"
"58482591","1","58488595","","2019-10-21 08:36:51","","0","672","<p>I am trying to write a Grafana plugin using RxJS. 
Every logic to get my data stream to Grafana works and the complete pipeline works. </p>

<p>Now I need to stop the stream in case any options are changed.
I found in different blog posts and in the documentation 
the advice to use <code>takeUntil</code>.</p>

<p>Therefore, I created a observable emitting a event when I want to abort the stream. But any try to subscribe to the stream fails now, with </p>

<blockquote>
  <p>You provided an invalid object where a stream was expected. You can provide an Observable, Promise, Array, or Iterable. </p>
</blockquote>

<p>This problem exists only when takeUntil is introduced. This is especially weird since I use TypeScript and therefore the Return Type should be safe.</p>

<p>To debug the problem I pasted the example from the <a href=""https://www.learnrxjs.io/operators/filtering/takelast.html"" rel=""nofollow noreferrer"">docs</a></p>

<pre><code>/// RxJS v6+
import { interval, timer } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

//emit value every 1s
const source = interval(1000);
//after 5 seconds, emit value
const timer$ = timer(5000);
//when timer emits after 5s, complete source
const example = source.pipe(takeUntil(timer$));
//output: 0,1,2,3
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre>

<p>The problem persists. I checked my installed version of rxjs and yarn resolved it to 6.5.3. I checked the GitHub Issues of rxjs but didn't find any related issues.</p>

<p>I suppose the problem lies within my environment and conclusively I included all of my depedencies:</p>

<pre><code> ""dependencies"": {
    ""@grafana/toolkit"": ""next"",
    ""@grafana/ui"": ""latest"",
    ""@types/grafana"": ""github:CorpGlory/types-grafana.git"",
    ""@stomp/rx-stomp"": ""latest"",
    ""rxjs-tslint-rules"": ""^4.25.0""
    ""sockjs-client"": ""^1.4.0"",
    ""ts-loader"": ""^6.2.0"",
    ""typescript"": ""^3.6.4""    
  }
</code></pre>

<p>Snippet of my own implementation </p>

<pre><code>class LiveStreams {
 private streams;
 private stop$: Subject;

 constructor() {
   this.stop$ = new Subject&lt;string&gt;();
 }

 getStream(target): Observable&lt;DataFrame[]&gt; {
     const stop_id = this.stop$.pipe(takeWhile(id =&gt; id == target.streamId));
     stream = this.rxStomp.watch(target.streamName).pipe(
                finalize(() =&gt; {
                    delete this.streams[target.streamId];
                }),
                map((message: IMessage) =&gt; {
                    let content = JSON.parse(message.body).content;
                    appendResponseToBufferedData(content, data);
                    return [data];
                }),
                throttleTime(target.throttleTime),
                takeUntil(stop_id)
            );
       this.streams[target.streamId] = stream;
   } 
}
</code></pre>

<p>Any clues on which parts of my environment to check would be appreciated.</p>
","7918176","","7918176","","2019-10-21 09:48:25","2019-10-24 07:57:29","Subscribing to pipe containing TakeUntil fails","<rxjs><grafana><rxjs6>","3","5","","","","CC BY-SA 4.0"
"58565988","1","58566236","","2019-10-25 21:32:07","","1","84","<p>I am new to RXJS and I am writing a validation function where potentially 2 modals pop up (one after the other) and the user has to confirm they are okay with breaking the validation rules. </p>

<p>I am calling it like this:</p>

<pre><code>this.isValidAssignment(x,y,z).subscribe(result =&gt; {
    if (!result) { return; }
    ...do something...
});
</code></pre>

<pre><code>isValidAssignment(x, y, z): Observable&lt;boolean&gt; {
      if (x === y){
          of(false)
      }
      if (x &lt; y) {
          return this.confirmIncorrectAssignment();
      }
      if (y !== z) {
          return this.confirmIncorrectAssignment();
      }

      return of(true)
  }

// returns true if they click yes and false if they click no
confirmIncorrectAssignment(): Observable&lt;boolean&gt; {
    const dialogRef = this.dialog.open(ConfirmCancelModalComponent);

    return dialogRef.afterClosed();
  }
</code></pre>

<p>My problem is if the first confirmation executes it goes ahead and returns an Observable and it the second validation is never checked.</p>

<p>What is the best way in RXJS to make sure the user confirms both modals?  I only want it to emit true if both observables have completed and they clicked yes on both. </p>
","4812782","","","","","2019-10-28 17:30:20","RXJS - waiting until both observables are complete","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"58590896","1","","","2019-10-28 12:24:01","","0","96","<p>Is there a way to add more operations to an observable that has already been subscribed? I tried the below code, which doesn't work, as the <em>One more tap after subscribe</em> part is not executed (code is <a href=""https://stackblitz.com/edit/typescript-aznfoh"" rel=""nofollow noreferrer"">here</a>)</p>

<pre><code>import { of, timer } from 'rxjs';
import { tap, map, take } from 'rxjs/operators';

const source = timer(1000, 1000);
//transparently log values from source with 'do'
const example = source.pipe(
  take(3),
  tap(val =&gt; console.log(`BEFORE MAP: ${val}`)),
  map(val =&gt; val + 10),
  tap(val =&gt; console.log(`AFTER MAP: ${val}`))
);

//'do' does not transform values
//output: 11...12...13...14...15
const subscribe = example.subscribe(val =&gt; console.log(val));

example.pipe(
  tap(val =&gt; console.log(`One more tap after subscribe: ${val}`))
);
</code></pre>

<p>The use cas I have in mind is where for example I make an http call, and more than one service needs to be updated with the reponse of the call.</p>
","1029825","","1029825","","2019-10-28 12:36:30","2019-10-28 14:25:31","Tap after observable has been subscribed","<rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"58597296","1","58597793","","2019-10-28 19:33:15","","0","46","<p>I have create timer using RXJS:</p>

<pre><code>let timer1value = null;
let timeFinish =  30;
let finishDate = new Date();

return timer(1000)
      .pipe(
        takeWhile(() =&gt; new Date() &lt; finishDate),
        finalize(() =&gt; {
          timeFinish = finishDate;
        })
      )
      .subscribe((t) =&gt; {
      timer1value = t;
});
</code></pre>

<p>I need to create some timers and show result on the page: </p>

<pre><code>{{timer1value}}
</code></pre>

<p>So, I have added observer to array <code>this.timers</code>:</p>

<pre><code>this.timers.push(timer(1000)
      .pipe(
        takeWhile(() =&gt; new Date() &lt; finishDate),
        finalize(() =&gt; {
          timeFinish = finishDate;
        })
      ));
</code></pre>

<p>Then how to get in template actual value of each timers in subscription?</p>

<pre><code>
{{timer2value}}

{{timerNvalue}}```
</code></pre>
","","user11314257","","","","2019-10-28 22:02:46","How to create some timers and show result from them?","<angular><rxjs><rxjs6>","2","2","","","","CC BY-SA 4.0"
"58598965","1","58599397","","2019-10-28 22:01:50","","0","339","<p>I have a method that creates timer:</p>

<pre><code> create(options: any) {
    return timer(0, 1000).pipe(
      map(() =&gt; {
        return options;
      }),
      takeWhile(() =&gt; new Date() &lt; options.finishDate)
    );
  }
</code></pre>

<p>Then this timer I add to array <code>this.timers</code> of Observables:</p>

<pre><code>this.timers.push(this.create({finishDate: new Date()}))
</code></pre>

<p>When I merge observers:</p>

<pre><code>this.mergeObserver = Observable.merge(this.timers).subscribe(x =&gt; {
   console.log(x);
});
</code></pre>

<p>I see that <code>console.log(x);</code> continues work despite timer was finished.</p>

<p>Why? And how to stop all timers in array?</p>

<p>I can unsubscribe  here:</p>

<pre><code> Observable.merge(this.timers).subscribe(x =&gt; {
   x.unsubscribe();
});
</code></pre>

<p>But it does not stop <code>Observable.merge</code>.</p>
","","user11314257","","user11314257","2019-10-28 22:11:33","2019-10-28 22:55:45","How to stop observers in Observable.merge?","<javascript><rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"58608627","1","58608721","","2019-10-29 13:42:43","","-1","37","<p>I have old Rxjs merge:</p>

<pre><code>Observable.merge(this.timers).subscribe(x =&gt; {
      let subscription = x.subscribe((value: ITimer) =&gt; {});

});
</code></pre>

<p>How to rewrite it on new Rxjs notation?</p>

<p>I have tried import this:</p>

<pre><code>import { merge } from ""rxjs/operators"";
</code></pre>
","8291684","","","","","2019-10-29 13:47:55","How to rewrite merge on new Rxjs?","<rxjs><rxjs5><rxjs6>","1","1","1","","","CC BY-SA 4.0"
"58614775","1","","","2019-10-29 20:15:27","","1","202","<p>I would like to allow a client to dynamically change the url to a <code>webSocket</code> and maintain Observables on connection to the new <code>webSocket</code>. Looking over the RxJS Github and Stackoverflow, this is not something that is supported by RxJS (see <a href=""https://github.com/ReactiveX/rxjs/issues/4355"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/4355</a>)</p>

<p>The referenced Github links to a Stackoverflow (<a href=""https://stackoverflow.com/questions/51145664/resetting-replaysubject-in-rxjs-6/51147023#51147023"">Resetting ReplaySubject in RxJS 6</a>) where a <code>resettable</code> is used to ""reset"" a subject.</p>

<p>Could this be used to dynamically modify the url of a <code>webSocket</code>?</p>

<p><a href=""https://github.com/cartant/rxjs-etc/blob/master/source/observable/resettable.ts"" rel=""nofollow noreferrer"">https://github.com/cartant/rxjs-etc/blob/master/source/observable/resettable.ts</a></p>

<p>Here's what I've tried so far:</p>

<pre><code>function resettable&lt;T, U extends any[]&gt;(
  factory: (...args: U) =&gt; WebSocketSubject&lt;T&gt;,
  ...args: U
): {
  readonly closed: boolean;
  readonly observable: Observable&lt;T&gt;;
  readonly subject: Subject&lt;T&gt;;
  reset(...args: U): void;
  unsubscribe(): void;
} {
  const resetter = new Subject&lt;any&gt;();
  const source = new Subject&lt;T&gt;();
  let destination = factory(...args);
  let subscription = source.subscribe(destination);
  return {
    reset(...args: U): void {
      subscription.unsubscribe();
      destination = factory(...args);
      subscription = source.subscribe(destination);
      resetter.next();
    },
    unsubscribe(): void {
      subscription.unsubscribe();
      /*tslint:disable:rxjs-no-subject-unsubscribe*/
      source.unsubscribe();
      /*tslint:enable:rxjs-no-subject-unsubscribe*/
    },
    get closed(): boolean {
      return subscription.closed;
    },
    get observable(): Observable&lt;T&gt; {
      return resetter.asObservable().pipe(
        startWith(null),
        switchMap(() =&gt; destination)
      );
    },
    get subject(): Subject&lt;T&gt; {
      return source;
    }
  };
}
</code></pre>

<p>If there are any other ways to accomplish this, I'm all ears! Thanks!</p>
","10060512","","","","","2019-10-29 20:15:27","RxJS webSocket Dynamic URL","<javascript><rxjs><rxjs6>","0","1","","","","CC BY-SA 4.0"
"58617865","1","58618347","","2019-10-30 02:17:39","","2","839","<p>I use <code>rxjs</code> in <code>React Native</code>. I call <code>Observable.fromPromise(storage.load({key: key})).map(() =&gt; value);</code> shows the error.</p>

<p>My rxjs version:</p>

<pre><code>""rxjs"": ""^6.5.3"",
""rxjs-compat"": ""^6.5.3"",
</code></pre>

<p>I have three steps.</p>

<p>Step1:</p>

<pre><code>rxInit().flatMap(() =&gt; {

  console.log('I can not see the console log');

  return rxInit()

}).subscribe(() =&gt; {

  console.log('I can not see the console log');
  // some code...

})
</code></pre>

<p>Step2 rxInit():</p>

<pre><code>import { Observable } from 'rxjs';

  rxInit() {
    console.log('I can see the console log')

    return StorageService.shared.get('deviceuuid').flatMap((deviceuuid) =&gt; {

      console.log('I can't not see the console log')

      if (deviceuuid == null) {
        return StorageService.shared.set('deviceuuid', this.deviceuuid);
      } else {
        return Observable.of(this.deviceuuid);
      }

    }).do((deviceuuid) =&gt; {
        // some code...
    })
  }
</code></pre>

<p>Step3 about the get():</p>

<pre><code>import { Observable } from 'rxjs';
import Storage from 'react-native-storage';
import AsyncStorage from '@react-native-community/async-storage';

let storage = new Storage({
  size: 1000,
  storageBackend: AsyncStorage,
  defaultExpires: null,
})  

export default class StorageService {
  set(key, value) {
    console.log('StorageService set');
    return Observable.fromPromise(storage.save({ key: key, data: value })).map(() =&gt; value);
  }

  get(key) {
    console.log('It is a ', storage.load({key: key}));  // It is a Promise
    return Observable.fromPromise(storage.load({key: key})).map(() =&gt; value);
  }

  remove(key) {
    return Observable.fromPromise(storage.remove({key: key})).catch(() =&gt; Observable.of(null))
  }
}

StorageService.shared = new StorageService();
</code></pre>

<p>I looking for some answer, somebody says it is because rxjs is above 6.0, so I try to use </p>

<pre><code>import { from } from 'rxjs';

return from(storage.load({key: key})).map(() =&gt; value);
</code></pre>

<p>It sill shows </p>

<pre><code>TypeError: _rxjs.from.fromPromise is not a function
</code></pre>

<p>or</p>

<pre><code>_rxjs.from().map is not a function.
</code></pre>

<p>Any help would be appreciated.</p>
","6902961","","6902961","","2019-10-30 02:36:27","2019-10-30 03:29:01","TypeError: _rxjs.Observable.fromPromise is not a function","<react-native><rxjs><rxjs5><rxjs6><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"58619944","1","58620434","","2019-10-30 06:48:35","","0","704","<p>I use the code with <code>rxjs 5.5.12</code> in React Native, it works.</p>

<p>In rxjs 5.5.12:</p>

<pre><code>// the function will return Observable
  rxInit() {
    return Observable.combineLatest(
      myObservable1,
      myObservable2,
    ).flatMap((result) =&gt; {
      console.log('rxInit result =&gt;', result) // I can see the result
      const [token, email] = result

      this.token = token
      this.email = email

      // check the value is empty or not and return Observable.

      if (this.token != null &amp;&amp; this.email != null) {
        return Observable.fromPromise(myApiPromise).catch(handleErrorFunction)
      } else if (this.token != null &amp;&amp; this.uid != null) {
        return Observable.fromPromise(myApiPromise).catch(handleErrorFunction)
      } else {
        return Observable.of(null)
      }
    })
  }
</code></pre>

<p>In rxjs 6.5.3:</p>

<p>import some oerator first:</p>

<pre><code>import { combineLatest } from 'rxjs';
import { flatMap } from 'rxjs/operators';
</code></pre>

<p>I change the code:</p>

<pre><code>rxInit() {
  console.log('rxInit start');

  return combineLatest(
    myObservable1,
    myObservable2
   ).flatMap((result) =&gt; {
     console.log('rxInit result =&gt;', result)
   });

   console.log('rxInit end');
 }
</code></pre>

<p>It will show error <code>TypeError: (0 , _rxjs.combineLatest)(...).flatMap is not a function</code>.</p>

<p>So I note that may be I have to use <code>pipe</code>, I try to change the code.</p>

<pre><code>rxInit() {
    console.log('rxInit start'); // it works.

    return combineLatest(
      myObservable1,
      myObservable2
    ).pipe(flatMap((result) =&gt; {
      console.log('rxInit result =&gt;', result);  // the console log doesn't work
    }));
    console.log('rxInit end'); // the console log doesn't work
  }
</code></pre>

<p>I have no idea why I can't get the result in my console.log.</p>

<p>Any help would be appreciated.</p>
","6902961","","","","","2019-10-30 07:30:58","How to use combineLatest with flatMap in rxjs6?","<react-native><rxjs><rxjs5><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"58622320","1","58622526","","2019-10-30 09:33:49","","0","180","<p>In <code>rxjs 5.5.12</code>, I created a <code>login()</code> to <code>subscribe</code> with multiple observable by <code>do()</code></p>

<pre><code>login(userEmail, userPassword).subscribe((response) =&gt; {
  console.log(response);

  if (response === 'something') {
    // some actions
  } else {
    // some actions
  }
},(error) =&gt; {
  // some error actions
});
</code></pre>

<p>I use rxLoginPOST to call api:</p>

<pre><code>rxLoginPOST(url, params) {
  return Rx.Observable.fromPromise(somePromise).catch(handleErrFunction);
}
</code></pre>

<p>I use it in login function it return multiple observable:</p>

<pre><code>login(email, password) {
  return APIService.shared.rxLoginPOST('users/signin', { ...arguments })
  .flatMap((response) =&gt; {
    if (response.status === 200) {
        return Rx.Observable.combineLatest(
          myObservable1,
          myObservable2,
          myObservable3
        )
      } else {
        return Rx.Observable.of(response)
      }
  }).do((result) =&gt; {
      if (result.length &gt; 0) {
        // some logic
      } else {
        return Rx.Observable.of(result)
      }
  }).flatMap((result) =&gt; {
      if (result.length &gt; 0) {
        return this.checkUserIsRegistered()
      } else {
        return Rx.Observable.of(result)
      }
  })
}
</code></pre>

<p>In <code>rxjs 6.5.3</code>, I had changed all the import like</p>

<pre><code>import { Observable, combineLatest, of } from 'rxjs';
import { mergeMap, map, catchError, flatMap, tap } from 'rxjs/operators';
</code></pre>

<p>If I trigger <code>login()</code> it will show <code>do is not a function</code></p>

<p>So I change the code:</p>

<pre><code>login(userEmail, password) {
    return APIService.shared.rxLoginPOST('users/signin', { ...arguments }).pipe(
        mergeMap((response) =&gt; {
        if (response.status === 200) {
          return combineLatest(
            myObservable1,
            myObservable2,
            myObservable3
          )
        } else {
          return of(response)
        }
      }).tap((result) =&gt; { // I am stuck here, I have no idea how to continue with it...
         console.log('check 4');  // check 4 does not appear.
         console.log('response', response);
         return of(response)
      }
    );
</code></pre>

<p>I try to use <code>tap</code> instead of <code>do</code>, but check 4 does not appear.</p>

<p>Any help would be appreciated.</p>
","6902961","","","","","2019-11-04 16:39:04","How to subscribe multiple observable in rxjs 6 ? do is not a function in rxjs 6","<react-native><rxjs><rxjs5><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"58728020","1","","","2019-11-06 10:28:49","","1","370","<p>For instance :</p>

<ol>
<li>npm i @reactivex/rxjs</li>
<li>Create a index.ts file with some function that use RxJs</li>
<li>Create an index.html file that reference RxJs UMD build and the
index.js file  created by the typescript compiler from the index.ts
one.</li>
</ol>

<p>here there is a repro : <a href=""https://github.com/valeriob/Repro_rxjs_typescript"" rel=""nofollow noreferrer"">https://github.com/valeriob/Repro_rxjs_typescript</a>
Just run ""tsc"" and see the compiling error.</p>

<p>How do i get type definitions while editing index.ts in this scenario ?</p>

<p>Following those guidelines <a href=""https://github.com/zspitz/TypeScript-Handbook/blob/release-2.0/pages/Modules.md#umd-modules"" rel=""nofollow noreferrer"">https://github.com/zspitz/TypeScript-Handbook/blob/release-2.0/pages/Modules.md#umd-modules</a> 
i was able to make it work by appending ""export as namespace rxjs;""
to the file node_modules/rxjs/index.d.ts .</p>

<p>If this should be the solution, should it be done by the library authors ?</p>
","333265","","333265","","2019-11-08 09:06:46","2021-06-01 05:06:07","How do use RxJS with type definitions when using the UMD build?","<typescript><rxjs><rxjs6><umd>","2","2","","","","CC BY-SA 4.0"
"58729254","1","58729522","","2019-11-06 11:35:06","","0","55","<p>I used <code>concatmap</code> to call the multiple requests. Following is my code</p>

<pre><code>getGeneDetail() {
    const obs = from(this.genes);
    obs.pipe(
        concatMap(res =&gt; {
            const ep = this.callService.getAll(this.resource + '/' + res.name + '/status');
            return ep.pipe(map(r =&gt; {
                this.tableData[res.i]['x'] = r.gene[x].xpos;
            }));
        })
    ).subscribe();
}
</code></pre>

<p>And the <code>this.genes</code> contains the following data </p>

<pre><code>    [
        {
            ""name"": ""tim"",
            ""i"": 0
        },
        {
            ""name"": ""keratin"",
            ""i"": 1
        },
        {
            ""name"": ""isomerase"",
            ""i"": 2
        },
        {
            ""name"": ""evps"",
            ""i"": 3
        },
        {
            ""name"": ""ank1"",
            ""i"": 4
        },
        {
            ""name"": ""cdsn"",
            ""i"": 5
        }
        .. ,more than 100 entities
</code></pre>

<p>Above code is working fine. But the problem if I navigates to another component the APIs are still calling.  So How to prevents the call if the page is navigates?</p>
","3961170","","1033581","","2020-02-23 15:31:47","2020-11-17 08:08:40","How to Destroy the call if the page is navigate?","<angular><rxjs6>","2","4","","2019-11-06 12:46:39","","CC BY-SA 4.0"
"58735667","1","58739490","","2019-11-06 17:34:17","","1","1403","<p>I have a component which shows information only if the <code>observable</code> has data. but when I try to use <code>async</code> operator on the <code>observable</code> I <strong>don't see</strong> any value. I am confused with the way how <strong>async pipe</strong> works I think it takes some <strong>time to initialize the observable</strong> in that case <code>async pipe</code> will not do anything on undefined observable and that's why the component is not showing.</p>

<pre class=""lang-ts prettyprint-override""><code>@Component({
  template: `
    &lt;div *ngIf=""todo$ | async as todo""&gt;
      &lt;div {{todo.name}} &lt;/div&gt;
    &lt;/div&gt;   
  `
})
export class TodosComponent implements OnInit, OnDestroy {

  todo$: Observable&lt;Todo&gt;;

  constructor(private store: Store&lt;State&gt;) {}

  ngOnInit() {
    this.todo$ = this.store
      .pipe(select(selectTodos));
  }

  ngOnDestroy(): void {
  }
}
</code></pre>

<p>I know that <code>async</code> pipe will handle <code>Observable</code> but what if Observable is still <strong>undefined</strong> will async pipe handle that scenario too. if so is there any suggestion on what I might be doing wrong please note that I have subscribed and check if observable has data.</p>
","5794129","","5794129","","2019-11-07 01:00:38","2019-11-07 01:00:38","async operator on undefined observable","<angular><rxjs><ngrx><rxjs6>","3","3","","","","CC BY-SA 4.0"
"58772085","1","","","2019-11-08 18:36:07","","0","389","<p>I am making multiple rest calls and i can can see all but the one failing in the network tab. but for some reason if one of them has a 404 the other calls never <code>finalize</code>. Is this expected behavior? Im running angular 8.2 </p>

<pre><code> public intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

    console.log(`${request.method} '${request.urlWithParams}' ProgressInterceptor ++.`);

    this.progressService.increase();

    return next.handle(request)
      .pipe(
        finalize(() =&gt; {
         console.log(`${request.method} '${request.urlWithParams}' ProgressInterceptor --.`);

          this.progressService.decrease();
        }),
      );
  }
</code></pre>

<p><a href=""https://i.stack.imgur.com/zbzdk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zbzdk.png"" alt=""enter image description here""></a></p>
","338456","","","","","2019-11-08 19:07:36","Angular HttpInterceptor Finally Never Called on Error","<angular><rxjs6><angular-http-interceptors>","1","0","","","","CC BY-SA 4.0"
"58775174","1","","","2019-11-09 00:05:28","","1","33","<p>For some reason having a tap operator is altering the output of a stream (actually providing my expected result). When I remove the tap the subsequent filter no longer appears to work.  </p>

<p>I have run the code below on codesandbox with the </p>

<pre><code>  tap(([prevMouseEvent, currentMouseEvent]) =&gt;
    console.log(directionChange(prevMouseEvent, currentMouseEvent))
  ),
</code></pre>

<p>included as well as commented out.  Without the tap the subsequent filter doesn't appear to work and I get a constant stream of paired mouse events.</p>

<pre><code>// Returns true if the predominant movement in the mouse has changed direction
  const directionChange = (prevMouseEvent, currentMouseEvent) =&gt; {
     const dominantAxisMovement =
       Math.abs(currentMouseEvent.movementX) &gt;
       Math.abs(currentMouseEvent.movementY) ? ""X"" : ""Y"";

     if (dominantAxisMovement === ""X"") {
       return (
         Math.sign(currentMouseEvent.movementX) !==
         Math.sign(prevMouseEvent.movementX)
       );
     } else {
       return (
         Math.sign(currentMouseEvent.movementY) !==
         Math.sign(prevMouseEvent.movementY)
       );
    }
};

const mouseDirectionSwitch$ = fromEvent(document, ""mousemove"").pipe(
  pairwise(),
  tap(([prevMouseEvent, currentMouseEvent]) =&gt;
    console.log(directionChange(prevMouseEvent, currentMouseEvent))
  ),
  filter(([prevMouseEvent, currentMouseEvent]) =&gt;
    directionChange(prevMouseEvent, currentMouseEvent)
  )
);

mouseDirectionSwitch$.subscribe(passed =&gt; console.log(passed));
</code></pre>

<p>What I am trying to achieve is an observable that only emits when the user changes the direction of a mouse movement (and by change movement I mean up to down and left to right, not subtle changes). With the tap it works but can anyone explain why the tap operator is required here to get the desired output?  I thought the tap operator returned an identical observable and would therefore have no effect on the output of the stream it is in.</p>
","9140532","","","","","2019-11-09 03:09:53","Why is the tap operator impacting stream flow?","<javascript><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"58834551","1","","","2019-11-13 10:02:10","","0","76","<p>How to skip the element if the request get's failed in concatMap</p>

<pre><code>const obs = from(this.genes);
this.subs = obs.pipe(
    concatMap(res =&gt; {
        const gn = this.service.getData(this.resource + '/' + res.name);
        return gn.pipe(map(r =&gt; {
            for (let x = 0; x &lt; res.l; x++) {
                this.tableData[res.i + x]['g'] = r.gene;
            }
        }, err =&gt; {
            console.log(err);
        }));
    })
).subscribe(x =&gt; {}
);
</code></pre>

<p>Following is my data</p>

<pre><code>[
        {
            ""name"": ""tim"",
            ""i"": 0
        },
        {
            ""name"": ""keratin"",
            ""i"": 1
        }...
</code></pre>

<p>If the first URL gets failed this is not going for the next url. How to skip it?</p>
","3961170","","","","","2019-11-13 11:02:39","ConcatMap skip the element if the request failed","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"58840940","1","","","2019-11-13 15:58:00","","0","41","<p>As the title suggests, I want to delay each value in an iterable by some amount of time while keeping the iterable lazily evaluated. Here's the closest I've got so far which works fine for finite iterables or those which don't throw an error</p>

<pre><code>function* iter () {
  let i = 0
  while (true) yield i++
}

rxjs.zip(
  rxjs.from(iter()),
  rxjs.timer(500, 500),
  x =&gt; x
).subscribe(console.log)
</code></pre>
","1580478","","","","","2019-11-13 19:25:30","Lazily delay each value of a infinite stream","<rxjs><observable><rxjs6>","1","1","0","","","CC BY-SA 4.0"
"58842835","1","58844592","","2019-11-13 17:49:27","","0","38","<p>Service:</p>

<pre><code>import { Injectable } from ""@angular/core"";
import { Subject } from ""rxjs"";

@Injectable({
  providedIn: ""root""
})
export class AdminRoleLocalService {
    public newRoleAdded = new Subject&lt;boolean&gt;();
    constructor() {}
       newRoleAddedEvent() {
       this.newRoleAdded.next(true);
    }
}
</code></pre>

<p>component-1:</p>

<pre><code>submitAddRoleForm(addRoleForm: AddRoleData) {
    this.isFetching = true;
    this.roleService.addRoleData(addRoleForm).subscribe(
    httpResponse =&gt; {
       console.log(httpResponse);
       this.isFetching = false;
       this.roleLocalService.newRoleAddedEvent();
       this.router.navigate([""/role-management""]);
    },
    errorMessage =&gt; {
     console.log(errorMessage);
     this.errorMessageContent(errorMessage);
    }
   );
}
</code></pre>

<p>component-2:</p>

<pre><code>ngOnInit() {
   this.roleLocalService.newRoleAdded.subscribe(flag =&gt; {
      this.newRoleAddedFlag = flag;
   });
}
</code></pre>

<blockquote>
  <p>i am seeing newRoleAddedFlag as undefined where as i am expecting value as True. I am unable to find out where i am seeing. Request you to help me out. </p>
</blockquote>
","10826688","","6664264","","2019-11-13 19:06:36","2019-11-13 19:51:34","I am unable to access condition set up in component-1 by Subject of rxjs in component-2","<angular><rxjs6>","2","1","","","","CC BY-SA 4.0"
"58860785","1","","","2019-11-14 15:50:44","","-1","348","<p>I am getting this in my Console. Since it's not pointing to my code I have no idea what it's all about:</p>

<pre><code>TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.
at subscribeTo (subscribeTo.js:28)
at subscribeToResult (subscribeToResult.js:15)
at CatchSubscriber.push../node_modules/rxjs/_esm5/internal/operators/catchError.js.CatchSubscriber.error (catchError.js:43)
at CatchSubscriber.push../node_modules/rxjs/_esm5/internal/OuterSubscriber.js.OuterSubscriber.notifyError (OuterSubscriber.js:13)
at InnerSubscriber.push../node_modules/rxjs/_esm5/internal/InnerSubscriber.js.InnerSubscriber._error (InnerSubscriber.js:18)
at InnerSubscriber.push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.error (Subscriber.js:59)
at Observable._subscribe (throwError.js:5)
at Observable.push../node_modules/rxjs/_esm5/internal/Observable.js.Observable._trySubscribe (Observable.js:43)
at Observable.push../node_modules/rxjs/_esm5/internal/Observable.js.Observable.subscribe (Observable.js:29)
at subscribeToResult (subscribeToResult.js:13)
</code></pre>

<p>Can someone please help?</p>

<p>Update. Here is the actual call:</p>

<pre><code>this.http.get(`${environment.apiUrl}/api/home/`)
   .subscribe((data: any) =&gt; {console.log(data);
});
</code></pre>

<p>Update 2.
Here is my interceptor where it's most like happening:</p>

<pre><code> intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
  // add authorization header with jwt token if available
  request = this.addTokenToRequest(request);
  return next.handle(request);
  // .pipe(
  //   catchError((error: HttpErrorResponse) =&gt; {
  //     if (error instanceof HttpErrorResponse) {
  //       switch (error.status) {
  //         case 406: {
  //           return this.handle406Error(request, next);
  //         }
  //         // case 'Unauthorized': {
  //         //   // return this.handle401Error(request, next);
  //         // }
  //     }}
  //   }));
}
</code></pre>

<p>So, if I comment out <code>.pipe</code> I don't get the message. But I still want to process errors if any.</p>

<p>Update 3.
Here is the initial call:</p>

<pre><code>ngOnInit(): void {    
    this.http.get(`${environment.apiUrl}/api/web/home/`)
      .subscribe((data: any) =&gt; {
        console.log(data);
    });
}
</code></pre>
","1580092","","3780040","","2019-11-14 17:02:07","2020-06-10 11:14:16","You provided 'undefined' where a stream was expected","<angular><rxjs6>","1","13","","","","CC BY-SA 4.0"
"58862731","1","","","2019-11-14 17:36:11","","1","51","<p>I am trying to implement  a global error handling by creating an interceptor. here is its code:</p>

<pre><code>intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpSentEvent
   HttpHeaderResponse | HttpProgressEvent | HttpResponse&lt;any&gt; | HttpUserEvent&lt;any&gt; | any&gt; {
return next.handle(request)
  .pipe(
    catchError((error: HttpErrorResponse) =&gt; {
      if (error instanceof HttpErrorResponse) {
        switch (error.status) {
          case 406: {
            return error406(request, next);
          }
      }} else {
        return throwError(error);
      }
    })); 
</code></pre>

<p>The initial call is like this:</p>

<pre><code>ngOnInit(): void {
this.http.get(`${environment.apiUrl}/api/web/wrongapi/`)
  .subscribe((data: any) =&gt; {
    console.log(data);
});
</code></pre>

<p>}</p>

<p>The console looks like this:
11:23:04.568 GET <a href=""https://localhost/api/web/wrongapi/"" rel=""nofollow noreferrer"">https://localhost/api/web/wrongapi/</a> 404</p>

<p>11:23:04.608 ERROR OK</p>

<p>When I check ""error"" it is a string = ""Ok""</p>

<p>My question is:
Why I am not getting an error object in my catchError?</p>

<p>If my backend returns just a string how then Console knows it is 404?</p>

<p>Thanks</p>
","1580092","","","","","2019-11-14 17:36:11","Angular httpClient catchError doesn't return error object","<angular-httpclient><rxjs6>","0","0","","","","CC BY-SA 4.0"
"58870889","1","","","2019-11-15 05:32:37","","0","88","<p>I'm using a Redux Store within an Angular app to hold application state.</p>

<p>But in my view I want to assign this Redux store state to an Observable$ variable that the Angular view can bind to and update as state changes.</p>

<pre><code>import { of } from 'rxjs';

.....

// Using RxJS operator to cast Redux store state to an Observable
public viewData: any[] = [];
this.viewData$ = of(this.store.getState());

</code></pre>

<p>But when I try to bind <code>viewData</code> to the view in an ngFor I get an error stating the viewData is not in the correct format of an array <code>..ngFor didn't expect [Object object]</code> </p>

<pre><code>&lt;div *ngFor=""let data of viewData| async""&gt; 
    &lt;div&gt;{{ data }}&lt;/div&gt;
  &lt;/div&gt;


</code></pre>

<p><code>Question</code></p>

<p>How can you cast Redux store state to an Angular Observable using RxJs operators?</p>

<p>I know if I was to use NgRx Store I could just wrap it in a store.select like <code>viewData = this.store.select(store.getState);</code> but <em>Redux</em> doesn't have an equivalent <code>select</code> method to cast state as an Observable.
See: <a href=""https://ngrx.io/api/store/select"" rel=""nofollow noreferrer"">https://ngrx.io/api/store/select</a></p>
","1829251","","1829251","","2019-11-15 05:38:01","2019-12-20 09:49:40","How can you cast Redux state to an Angular view Observable?","<redux><observable><angular8><rxjs6>","1","0","","","","CC BY-SA 4.0"
"58946920","1","","","2019-11-20 04:52:18","","1","88","<p>In Angular when deal with cache which technique better between shareReplay and interceptor if concern about invalidate cache when new data coming? </p>

<p>In scenario I implement list of product page , product detail page and customer's order list page</p>

<ol>
<li>If I decide to use shareReplay while I stay on customer's order list page and new order coming Is possible way to invalidate data cache in shareReplay for getting new order in list. Or Incase While I stay on product list page and have someone edit product detail name A and I don't know that product detail of item A have been changed already then I click to look product detail item A , problem is product A still not change because it has bees cached by sharePlay . Ok may be I can set duration to get new data every 5 min but this way look bother server too much? I'm very new to cached so I don't know this way is normal or not? </li>
</ol>

<p>but there is some another problem If user click to view product A detail but setting in shareReplay suppose I set clear every 5 min but when I click to view product detail time not reach 5 min so user will see old detail product. Thing I want is shareReplay must clear cache and get new data if someone do http put post or delete Is that possible to do this way to get always fresh data and not bother sever too much?</p>

<ol start=""2"">
<li><p>If I decide to use Interceptor to deal with cache , Ok I can implement If I do http post put delete , It will clear cache data but If someone not ""me"" do another device to put post delete how can I invalidate my cache data to get new one? </p></li>
<li><p>Which is best way to deal with cache between shareReplay and interceptor to deal with cache data.</p></li>
<li><p>In this scenario should I cache ? because product can be change often and order can always coming ?</p></li>
</ol>

<p>Thank you</p>
","12401532","","","","","2019-11-20 04:52:18","In Angular when deal with cache which technique better between shareReplay and interceptor if concern about invalidate cache when new data coming?","<angular><caching><rxjs6><angular-http-interceptors>","0","0","","","","CC BY-SA 4.0"
"58947556","1","58947688","","2019-11-20 05:49:44","","0","50","<p>There is small correction.
What we are returning is Object[] and not Object. 
The method signature is also changed as below - 
I have a method which returns <code>Observable</code> as below- </p>

<pre><code> getData(url: string): Observable&lt;Object[]&gt; {

    return this.http.get&lt;Object[]&gt;(url);
  }
</code></pre>

<p>Where the <code>Object</code> is like below : </p>

<pre><code>{

  property1 : value1 
  property2 : value2 
  property3 : """" // no value right now 
}
</code></pre>

<p>What I want to do is : </p>

<p>return <code>Observable&lt;Object[]&gt;</code> (<strong>Please note same object</strong>)</p>

<p>Where the Object is like below : </p>

<pre><code>{

  property1 : value1 
  property2 : value2 
  property3 : value1 + value2; //combine property1 and property2 values 
} 
</code></pre>

<p>How can we achieve this ? </p>

<p>I know we have to use <code>rxjs map operator</code> but how do we use it ? </p>

<p>The url <a href=""https://stackoverflow.com/questions/46197223/transforming-observable-with-map"">Transforming Observable with .map</a> talks about transforming Array but not Map </p>

<p>How can we achieve this using <code>Map operator</code> on <code>Observable</code> ? </p>
","1281182","","1281182","","2019-11-20 06:23:20","2019-11-20 06:33:51","Transform the array of objects returned as Observable","<angular><rxjs6>","1","4","","","","CC BY-SA 4.0"
"58950284","1","58951823","","2019-11-20 08:56:14","","0","35","<p>I'm implementing following case:</p>

<p>We have multiple exactly same forms. One of the forms is a 'master' form, content of other forms is being compared to master form content. The purpose is to check if form is filled the same as 'master' form. Both 'master' and other forms are being changed over time.</p>

<p>My implementation is working perfectly fine:</p>

<p>Registering master form source:</p>

<pre><code>    public setMasterFormValueSource(masterValue$: Observable&lt;SomeFormValue&gt;, initialValue: SomeFormValue): void {
        this._masterFormValue$ = masterValue$.pipe(
            startWith(initialValue)
        );
    }
</code></pre>

<p>Returning Observable for other forms:</p>

<pre><code>public isSameAsForm$(formToCompare$: Observable&lt;SomeFormValue&gt;): Observable&lt;boolean&gt; {

        return combineLatest(this._masterFormValue$, formToCompare$).pipe(
            map(([formValue1, formValue2]) =&gt; areObjectsEqual(formValue1, formValue2)),
            distinctUntilChanged()
        );

    }
</code></pre>

<p><strong>PROBLEM:</strong></p>

<p>In some moment <code>setMasterFormValueSource</code> function is being called again setting new <code>this._masterFormValue$</code>. The problem is all other forms are listening on changes of old <code>this._masterFormValue$</code>. Is there a way to 'hot swap' master form value producer?</p>
","8245136","","","","","2019-11-20 10:15:41","RXJS: Reference to one of event producers changed in runtime","<angular><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"58952373","1","58952578","","2019-11-20 10:41:17","","0","87","<p>I have one third Party API which returns data as below -
It has been called from Angular Service using <code>HttpClient.</code> </p>

<pre><code>const someObject = {

    employees:[   

        {name:""XYZ"",age:30},
        {name:""ABC"",age:28},
    ]
}
</code></pre>

<p>I want to transform this data into below structure where 
<strong>name, age</strong> are as it is and <strong>description will be calculated based on name and age</strong> </p>

<pre><code>{ 
  name : 
  age  : 
  description: //calculate based on name and age 
},
{ 
  name : 
  age  : 
  description:  //calculate based on name and age 
}
</code></pre>

<p>Above structure will be typed to some <code>Interface</code> and this is ultimately returned from my <code>Angular service</code> </p>

<p>How can I do this using <code>RxJS</code> ? </p>

<p>Can anybody please help me as I am struggling with it </p>

<p>Ultimately , my Angular service will return data as above structure ?  </p>

<p><strong>EDIT :</strong> </p>

<p>Based on responses got , I tried below : </p>

<pre><code>return this.http.get&lt;any&gt;(url).pipe(
            map(data =&gt; data.employees),
            map(employees =&gt;{
              values.map(employee =&gt;{
                console.log('individual value =',employee);
                return{
                  employee,
                  description:employee.name + """" + employee.age 
                }
              })          
            })
        )  
</code></pre>

<p>But when this Observable is subscribed , I am getting value as <code>undefined</code>.</p>

<p>Is it because the second map operator <code>map(employees</code> is not returning anything ? 
How can I make it return object constructed from <strong>inner map</strong> ? </p>
","1281182","","1281182","","2019-11-20 11:38:01","2019-11-20 11:38:01","Tranform Data Using Map Operator in RxJS","<angular><rxjs6>","3","1","","","","CC BY-SA 4.0"
"58958555","1","58962686","","2019-11-20 15:59:41","","0","26","<p>I'm trying to implement a scenario in rxjs where:</p>

<ol>
<li>I make an ajax call to an api to fetch some data.</li>
<li>If the jwt token has expired, I get a response with the updated
token</li>
<li>If token has been updated, I need to re-execute the previous API
call</li>
<li>If not I return the result as usual.</li>
</ol>

<p>To do that, I'm trying to execute a promise in map() when the token has been updated, to re-execute the initial API call</p>

<p>Everytime it says:  ""Actions must be plain objects. Use custom middleware for async actions"" –</p>

<pre><code>const fetchEpic = (action$, store) =&gt;
    action$.pipe(filter(filterActions)).pipe(
        mergeMap((actionParams) =&gt; {

                const ajaxObservables = ajax(request).pipe(
                        takeUntil(action$.ofType(`${type}_CANCEL`, CANCEL_ALL_FETCH)),
                        map( ({ response: payload}) =&gt; {
                            if (payload.tokenUpdated) {

                                const promiseFetch = () =&gt; new Promise(resolve =&gt; {
                                    ajax(request).pipe(map(({ response }) =&gt; resolve(response)));
                                });


                                return from(promiseFetch).pipe(
                                    concatMap((result) =&gt; of(
                                        { type: SET_USER_TOKENS, payload },
                                        {...onCompleteAction, payload: result, extraParameters}
                                    )),
                                    catchError(err =&gt; {
                                        console.log(err)
                                    })
                                );

                            }
                            else if (isJWTError(payload)) {
                                return ({ type: USER_LOGOUT })
                            } else {
                                return ({...onCompleteAction, payload, extraParameters});
                            }
                        }),
                        catchError(({ xhr: { response: payload }}) =&gt; {
                            const obsLogoutAction = (of({ type: USER_LOGOUT, error: true}));
                            const obsReturnAction = (of({ type, payload, error: true}));
                            if (isJWTError(payload)) {
                                return obsLogoutAction;
                            }
                            return obsReturnAction
                        })
                    );
                let obs = [...loadingActionObservable, ajaxObservables ];

                return concat(...obs);
}));
</code></pre>
","2094686","","","","","2019-11-20 20:17:58","How to do an ajax call as a result for a previous ajax call which in return should dispatch multiple actions","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"58995499","1","","","2019-11-22 13:41:01","","1","97","<p>I have one third Party API which returns data as below - It has been called from Angular Service using <code>HttpClient</code>.</p>

<pre><code>const someObject = {

    employees:[   

        {name:""XYZ"",age:30},
        {name:""ABC"",age:28},
    ]
}
</code></pre>

<p>Now I have one <code>interface</code> with structure as below - </p>

<pre><code>interface EmployeeData{

   campus:{

     property1:string;
     property2:string;

   };
   details:{

     name:string;
     age:number

   }
}
</code></pre>

<p>So <code>EmployeeData.details</code> exactly mimics <code>someObject.employees</code> structure </p>

<p>Now I want to return data from my service as below - </p>

<pre><code>getData():Observable&lt;EmployeeData[]&gt;{

}
</code></pre>

<p>So , employees <strong>array from someObject</strong> should map to <strong>EmployeeData.details</strong> </p>

<p>and this should be returned as <code>EmployeeData[].</code> </p>

<p>How can I achieve this ?</p>

<p>I have tried below approach but it is giving different results. </p>

<pre><code>getData():Observable&lt;EmployeeData[]&gt; {


     return this.http.get&lt;any&gt;(url).pipe(

        tap(value =&gt; console.log(value)),
        map(data =&gt; data.employees),
        map(employees =&gt;{

              return employees.map(employee =&gt;{

                return{

                    details:{
                        name:employee.name,
                        age:employee.age,

                    }                       

                }           
            }
          }
        ) 

    }
</code></pre>

<p>What it returns is - </p>

<pre><code>details:{}
details:{}
</code></pre>

<p>But what I want is : </p>

<pre><code>{
    details:{}
}
{
    details:{}
}
</code></pre>

<p>Can anybody please help here ? </p>
","1281182","","","","","2019-11-22 15:53:58","Returning Array of objects using RxJS map operator","<angular6><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59018712","1","","","2019-11-24 14:27:43","","1","429","<p>I'm trying to implement a CRUD functionality in a reactive programming way. I have a form where one of it's field <code>identifier_name</code> must be unique.</p>

<p>But, before calling the create new or update method, I need to check first if the value of <code>identifier_name</code> field that I'm creating or updating is already exists in the observable where my observable is like this.</p>

<pre><code>this.userService.users$;
</code></pre>

<p>Below is my code in my component.</p>

<pre><code>@Component({...})
    export class UserEditComponent implements OnInit, OnDestroy {

        subscription: Subscription = new Subscription();

        ngOnDestroy() {
          this.subscription.unsubscribe();
        }

        saveUser(): void {
            if (this.userForm.valid) {
                this.identifierExists$.subscribe(exists =&gt; {
                      if (exists) {
                        this.snackBar.open('The scope identifier must be unique.', 'Close', { duration: 5000 });
                      } else {
                        if (this.isNewRecord) {
                            this.createNewUser();
                        } else {
                            this.updateUser();
                        }
                      }
                    })          
            } else {
                this.snackBar.open(""An error occured while saving your changes. Please try again."", ""Close"", { duration: 5000 });
            }
        }

      createNewUser(): void {
        this.subscription.add(
          this.userService.saveUser(this.userForm.value)
            .pipe(catchError(this.handleError))
            .subscribe(() =&gt; {
              this.snackBar.open('New user successfully created.', 'Close', { duration: 5000 });
            })
        )
      }

      updateUser(): void {
        this.subscription.add(
          this.userService.selectedUserIdAction$
            .pipe(
              switchMap(id =&gt; this.userService.updateUser(id, this.userForm.value))
            )
            .subscribe(_ =&gt; {
              this.snackBar.open(""User successfully updated."", ""Close"", { duration: 5000 })
            })
        )
      }

    }
</code></pre>

<p>What I have in mind is to do like this.</p>

<pre><code>    private identifierSubject = new BehaviorSubject&lt;string&gt;('');
    identifierAction$ = this.identifierSubject.asObservable();

    identifierExists$ = this.identifierAction$.pipe(
            switchMap(identifier =&gt; {
                this.userService.users$
                    .pipe(
                        map(users =&gt; users.some(user =&gt; user.identifier_name === identifier))
                    )
            })
        )
</code></pre>

<p>I'm not sure if this is the correct way to achieve my requirement as I'm very new in the concept of reactive programming.</p>

<p>Additionally, if you noticed my 2 methods <code>createNewUser()</code> and <code>updateUser</code>. Is there a way I can trigger the <strong>create</strong> and <strong>update</strong> without subscribing? What I know in reactive programming was to avoid the <code>subscribe</code>. But, not really sure how to do this the right way.</p>

<p>Hope you can guide me on how to properly do this in a reactive programming way.</p>

<p>TIA</p>
","1160123","","1160123","","2019-11-25 01:45:29","2019-11-25 01:45:29","How to check Observable if data exist in Angular 8","<angular><reactive-programming><angular-reactive-forms><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59041990","1","","","2019-11-26 00:26:44","","0","320","<p>I have the following in <em>app.component.html</em></p>

<pre><code> &lt;label class=""label""&gt;Trigger Observables: &lt;/label&gt;
 &lt;div class=""control""&gt;
   &lt;input class='input is-primary' type='text' placeholder=""enter some text"" (input)='obs4chain()' #inp/&gt;
 &lt;/div&gt;
</code></pre>

<p>And in <em>app.component.ts</em></p>

<pre><code>obs4chain(){
  this.clearSubscription();
  const observable = fromEvent(document, 'input');

  this.subscription = observable.pipe(
    map(&lt;InputEvent&gt;(eventInfo) =&gt; eventInfo.target.value),
    debounceTime(500),
    distinctUntilChanged()
  ).subscribe(
    (evt) =&gt; console.log(evt)
  );

}
</code></pre>

<p>This code works fine and as expected, however in the case of having more than one input field I only want a specific one so using the local ref and viewchild so I have: </p>

<pre><code>@ViewChild('inp') myInput: ElementRef; 
</code></pre>

<p>And adjust my obervable declaration like so: <code>const observable = fromEvent(this.myInput.nativeElement, 'input');</code> </p>

<p>I can see that with viewChild I'm passing in the native html element of input rather than listening to the entire document which should work according to the docs: </p>

<blockquote>
  <p>fromEvent accepts as a first argument event target, which is an object with methods for registering event handler functions.  </p>
</blockquote>

<p>So I'm not sure why in this case the observable fails to create. Any ideas? </p>

<hr>

<p><strong>Edit</strong> Following @bryan60's example and refactoring my own code I noticed something. </p>

<p>Subscribing immediately after making the observable has the intended behavior: </p>

<pre><code>  const observable = fromEvent(this.myInput.nativeElement, 'input').pipe(
    map(&lt;InputEvent&gt;(eventInfo) =&gt; eventInfo.target.value),
    debounceTime(500),
    distinctUntilChanged()
  ).subscribe(
    (evt) =&gt; console.log(evt)
  );
</code></pre>

<p>But storing it as a var and subscribing after does not: </p>

<pre><code>  let observable = fromEvent(this.myInput.nativeElement, 'input').pipe(
    map(&lt;InputEvent&gt;(eventInfo) =&gt; eventInfo.target.value),
    debounceTime(500),
    distinctUntilChanged()
  );
  this.subscription = observable.subscribe(
    (evt) =&gt; console.log(evt)
  );
</code></pre>

<p>And I'm still not sure why that is.</p>
","4986641","","4986641","","2019-11-26 00:53:21","2019-11-26 00:53:21","fromEvent() not triggering observable on ViewChild?","<angular><rxjs6>","0","7","","","","CC BY-SA 4.0"
"59055632","1","59057128","","2019-11-26 16:42:12","","0","2980","<p>Seems like a dumb question, but for some reason I can't figure out the answer.</p>

<p>I have an auth guard, which checks the expiration of the JWT token stored in local storage and throws ""Your session has expired"" dialog which redirects the user to login onClose.</p>

<p>In the current state, the dialog is thrown only if the browser has this token in the storage; otherwise it redirects to login page straight.</p>

<pre><code>canActivate(
    next: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): boolean {
        if (!this._auth.isAuthenticated()) {
            if (this._auth.hasToken()) {
                this._dialogService.openErrorDialog('Your session has expired, please re-login', 0)
                    .afterClosed()
                    .subscribe(() =&gt; this.navigateToLogin(state.url));
            } else {
                this.navigateToLogin(state.url);
            }

            return false;
        }

    return true;
}
</code></pre>

<p>I want to implement the following logic: token expired while user browsed on some app page -> user navigated to another page -> dialog thrown -> redirect to login; but if user navigates to some page in the app from the <em>outside</em>, it should redirect him the login page straight, without throwing the dialog, even if there's already an expired token in the browser local storage.</p>

<p>I've tried to hack some solutions based on <a href=""https://stackoverflow.com/a/50885787/2313004"">this</a>, but it didn't work out - although I can return an <code>Observable&lt;boolean&gt;</code> from canActivate function, I couldn't figure out how can I make the rxjs <code>map</code> work with the results of <code>pairwise</code> - so I could use the fact of existence of the previous URL to determine where the user came from.</p>

<p>Any help greatly appreciated.</p>
","2313004","","6118550","","2019-11-26 19:45:05","2019-11-27 02:44:59","Angular 8 auth guard - determine if user came from outside or from inside the app","<angular><angular2-routing><angular8><rxjs6><angular-router-guards>","2","2","","","","CC BY-SA 4.0"
"59055780","1","","","2019-11-26 16:51:28","","0","1083","<p>I need to make multiple http calls (angular) and return the results of one forkJoin to another.
the following will not work:</p>

<pre><code>Observable.forkJoin([
       this.userService.createAccountHttp(accountRequest),
       this.userService.verifyAccountHttp(res)
 ]);

createAccount() {
  return this._http.jsonp&lt;any[]&gt;('http://...', 'callback').pipe(
      map(v =&gt; {
        return v;
      })
}
verifyAccountHttp(res) {
  return this._http.jsonp&lt;any[]&gt;('http://some url/' + res, 'callback').pipe(
      map(v =&gt; {
        return v;
      })
}

</code></pre>

<p>as res is undefined.
Is there a way to use forkJoin to run sequential http calls and pass results of one http call to the next?</p>

<p>Thanks</p>
","2040670","","2040670","","2019-11-26 17:07:09","2019-11-26 17:12:12","best way to pass results of one forkJoin to another via http","<angular><rxjs><rxjs6><fork-join>","1","2","","","","CC BY-SA 4.0"
"59071026","1","59071424","","2019-11-27 13:11:41","","0","155","<p>I have local storage for the sort data which can take a while:</p>

<pre><code>private store: IBacktest[] = [];

public setStore(content: string): Observable&lt;void&gt; {
    return new Observable&lt;void&gt;((observer) =&gt; {
            this.store = content
                .trim()
                .split('\n')
                .map(item =&gt; toTestCase(item))
                .sort((a, b) =&gt; b.profitToDropDown - a.profitToDropDown);
            observer.next();
            observer.complete();
        }
    );
}
</code></pre>

<p>Amount of elements 5000 - 10000 and it get 10 - 30 seconds because of <code>toTestCase</code>, not a cheap operation. And I want to render loader a more user-friendly interface:</p>

<pre><code>this.isLoader = true;
this.backtestService
    .setStore(content)
    .pipe(finalize(() =&gt; {
        this.isLoader = false;
    }))
    .subscribe(() =&gt; {...});
</code></pre>

<p>And <code>&lt;app-loading-overlay *ngIf=""isLoader""&gt;&lt;/app-loading-overlay&gt;</code> in template.</p>

<p>But when <code>isLoader = true</code> and I can see it in debug mode loading-overlay not rendering.</p>

<p>But when I try to test its logic with <code>setTimeout()</code> like this: <code>setTimeout(() =&gt; { this.isLoader = false; }, 100000)</code> all work properly and loader is visible.</p>

<p>What is the problem with my observable use and how to fix it without redundant wrappers like <code>setTimeout()</code> or something similar crutches?</p>
","7548062","","7548062","","2019-11-27 13:40:56","2019-11-27 17:07:20","Difference Observable wait and setTimeout for rerendering view template in Angular","<angular><typescript><rxjs6><angular2-observables>","2","9","","","","CC BY-SA 4.0"
"59100900","1","59103116","","2019-11-29 08:01:42","","5","1216","<p>When is <code>asObservable()</code> needed on a Subject (e.g. BehaviorSubject) to get a observable of the subject? The subject isself can be casted to an Observable as well.</p>

<h3>Questions</h3>

<ol>
<li>What are the technical differences between <code>name1$</code> and <code>name2$</code>?</li>
<li>Which one should be used (<code>name1$</code> or <code>name2$</code>)?</li>
</ol>

<h2>Code Sample</h2>

<pre class=""lang-js prettyprint-override""><code>import { Observable } from 'rxjs/Observable';
import { BehaviorSubject } from 'rxjs';

export class Person {
  private nameSubject: BehaviorSubject&lt;string&gt; = new BehaviorSubject&lt;string&gt;('lorem');

  public get name1$(): Observable&lt;string&gt; {
    return this.nameSubject.asObservable();
  }

  public get name2$(): Observable&lt;string&gt; {
    return this.nameSubject;
  }

  public setName(value: string): void {
    this.nameSubject.next(value);
  }
}
</code></pre>

<p>Thank You for your answers in advance!</p>
","4362911","","","","","2021-01-08 07:35:14","RxJS6 asObservable() needed on a Subject?","<javascript><typescript><rxjs><rxjs6>","3","1","1","","","CC BY-SA 4.0"
"59101004","1","59101042","","2019-11-29 08:10:37","","2","147","<p>I'm working with angularfire and I'm getting a continuous stream of arrays with mission ids in it. I need to fetch the mission document of each id in the array as a new observable. Then return an array of mission docs into the stream so that I'll be able to subscribe to it in my component and display a list of missions.</p>

<p>So far I got it to work with mergeMap. I split the array and fetch the mission docs and return them into the stream. Only problem with my solution is, that when I subscribe to the Observable I don't get an array of missions but every mission as a single change which I can not loop with ngFor. using the toArray() operator does in this case not work, because its a continuous stream which never ends.</p>

<p>This is my code so far:</p>

<pre><code>this.db.collection(`games/${gameId}/missions`).valueChanges().pipe(
    mergeMap(missions =&gt; missions),
    mergeMap((mission: any) =&gt; {
        return this.db.doc(`missions/${mission.id}`).snapshotChanges();              
    }),
);
</code></pre>

<p>This generates the following output in single events:</p>

<pre><code>{ id: 1, missionProperties }
{ id: 2, missionProperties }
{ id: 3, missionProperties }
</code></pre>

<p>But I would like to have it in one event as array of missions:</p>

<pre><code>[
    { id: 1, missionProperties },
    { id: 2, missionProperties },
    { id: 3, missionProperties }
]
</code></pre>
","11697270","","","","","2019-11-29 14:02:27","RxJs Observable in Observable from Array","<angular><rxjs><angularfire2><rxjs6>","2","0","","","","CC BY-SA 4.0"
"59108372","1","","","2019-11-29 16:35:13","","0","971","<p>Angular 7 - rxjs - Unable to get response data when response code is 422</p>

<p><strong>Request</strong></p>

<pre><code>Request URL: url
Request Method: POST
Status Code: 422 Unprocessable Entity
</code></pre>

<p><strong>api_service.ts has</strong></p>

<pre><code>validate(){
    return this.http.post&lt;any&gt;(url).pipe(
        map(res =&gt; res || []),
        catchError(error =&gt; throwError(error.message || error))
    );
}
</code></pre>

<p><strong>While calling api service validateCard</strong></p>

<pre><code>this._apiService.validate().subscribe((res) =&gt; {
  console.log(res)
}, (error) =&gt; {
  console.log(error)
})
</code></pre>

<p>HttpInterceptor</p>

<pre><code>return next.handle(request)
.pipe(tap(
    (response: HttpEvent&lt;any&gt;) =&gt; {
        return response
    },
    (error: HttpErrorResponse) =&gt; {
        console.warn('ERROR Interceptor', error);
        return error
    },
    () =&gt; {
        console.log(""completed successfully"");
    }
))
</code></pre>

<p>Issue is it doesn't even console log anything.
and in catchError(error) error is undefined.</p>
","3572008","","3572008","","2019-11-30 05:12:07","2019-12-17 11:59:34","Angular 7 - rxjs - Unable to get response data when response status code is 422 (Unprocessable Entity)","<angular><angular7><rxjs6>","2","5","0","","","CC BY-SA 4.0"
"59130911","1","","","2019-12-01 23:19:43","","4","474","<p>In some cases we need to fetch data from the store to do some work, is it ok to call the store inside a pipe ?</p>

<p>I want to know if this will harm my angular app and cause some <strong>performance issues</strong>.</p>

<p><strong><em>Basic example:</em></strong></p>

<pre><code>@Pipe({name: 'myPipe'})
export class MyPipe implements PipeTransform {

    _result = null;

    constructor(private _store: Store&lt;AppState&gt;) {}

      transform(value: any, params?: any): any {
        this._store.select(selector).subscribe(data =&gt; {
          // traitement
        });

        return _result;
      }
    }
</code></pre>
","11860076","","11860076","","2019-12-02 00:17:49","2019-12-02 01:03:23","Is it recommended to subscribe to the store (ngRx) inside a pipe?","<angular><performance><ngrx><rxjs6>","1","2","","","","CC BY-SA 4.0"
"59198084","1","","","2019-12-05 15:11:49","","-1","37","<p>In this effect I’m getting product and if this product has “childProducts” it becomes array of products.</p>

<p>Then, on the map function there is a pop up modal for each of the products in the array.</p>

<p>I want to make some action when the map is finished with all products.</p>

<p>How it be achieved?</p>

<pre><code>    @Effect()
    selectProductPage$ = this.actions$.ofType&lt;SelectProduct&gt;(OrderActionTypes.SelectProduct).pipe(
      map(action =&gt; action.payload),
      switchMap((product) =&gt; {
        const allTests = [product, ...(product.product.childProducts || [])].map(cloneDeep);
        return from(allProducts);
      }),
      map((product: any) =&gt; {
        // pop up modal for each product
      })
    );
</code></pre>
","5047599","","4604894","","2019-12-05 15:16:48","2019-12-05 15:26:18","Perform an action when map finished with async function","<angular><rxjs6>","1","1","","","","CC BY-SA 4.0"
"59198402","1","59198614","","2019-12-05 15:30:13","","0","82","<p><strong>Scenario:</strong> </p>

<p>I have a api call (<code>this.service.checkStatus(this.movieForm.value.movie)</code>) which should be consumed at every 60 seconds. and between the 60 second, I need to show a 1 second counter (something like <code>x seconds until next call</code>). So I'm using two timer (<code>source$</code> &amp; <code>source2$</code>). But the problem with the below code is <code>source2$</code> doesn't stops after a new api call, instead a new subscription is created for every 60 seconds. The old <code>source2$</code> subscription is still incrementing by 1 and the new one starts with 0 and making a mess. How can I fix this?</p>

<p>Below is my code. </p>

<p><strong>Code:</strong></p>

<pre><code>source$ = timer(0, 60000); // every 60 seconds it will emit
source2$ = timer(0, 1000); // every 1 second it will emit
...
getStatus() {
    this.apiSubscription$ = this.source$.subscribe(() =&gt; {

      // I need to reset this timersubscription. so that the val always starts from 0

      this.timerSubscription$ = this.source2$.subscribe((val: number) =&gt; {
          this.timer = 60 - val;
          this.progress.nativeElement.style.width = (val / 60) * 100 + '%';
        });
      this.service.checkStatus(this.movieForm.value.movie)
        .pipe(take(1))
        .subscribe(res =&gt; {
          const response: any = res;
          if (!response.status) {
            // do stuff 1
          } else {
            // do stuff 2
            this.apiSubscription$.unsubscribe();
          }
        });
    });
  }
</code></pre>
","4365228","","","","","2019-12-05 16:57:58","Reset subscription inside a timer","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59213545","1","59213820","","2019-12-06 12:51:19","","1","1495","<p>I have a mobile app, built with ionic and angular and I want to upgrade that from rxjs 5.5 to rxjs 6. However it appears that there are some breaking changes in the way rxjs uses operators, especially in the way values returned by one switchMap-operator are handled in the next operator in the pipe-chain. This is not clear from the migration docs (<a href=""https://rxjs-dev.firebaseapp.com/guide/v6/migration"" rel=""nofollow noreferrer"">https://rxjs-dev.firebaseapp.com/guide/v6/migration</a>), and I cannot find a way to work around it.</p>

<p>The problem might be in my use of function bodies within the switchMap-operators. That approach was based on older Internet-sources, but I see it less in more recent examples, and not sure if it is still supposed to be used. </p>

<p>The reason I need that approach is that the way I use observables is more or less as a replacement for promises - it's a way to make sure that different steps run in sequence. So there is not a single data-stream that runs through the operators, but any operator might be the start of a new type of event. That was a decision made in the past, in order to prevent constant conversions between observables and promises. Looking at it now, it might not be good practice, but for now, I would prefer to leave as is, if possible.  </p>

<p>Anyway, take the following as an example:</p>

<pre><code>initializeStatisticsObs(): Observable&lt;any&gt; {
    return this.speciesService.getImagesSizeInBytesObs()
      .pipe(
        switchMap((fSizeInBytes: number) =&gt; {
          this.imagesSizeInBytes = fSizeInBytes;
          return this.speciesService.getImagesNumberOfItemsObs();
        }),
        switchMap((fNumberOfItems: number) =&gt; {
          this.imagesNumberOfItems = fNumberOfItems;
          return of({});
        }),
..
      )
  }

  getImagesSizeInBytesObs(): Observable&lt;number&gt; {
    return this.speciesLocalStorageService.getSizeInBytesObs();
  }

  getImagesNumberOfItemsObs(): Observable&lt;number&gt; {
    return this.speciesLocalStorageService.getNumberOfItemsObs();
  }
</code></pre>

<p>As you can see, the higher level function initializeStatisticsObs() calls two other functions, that both return a number, wrapped in an Observable. Both numbers should ultimately be stored in variables of type number. I know that in this case the whole idea of running asynchronously doesn't really seem to make sense, but it is just a simplified example.</p>

<p>So the call to this.speciesService.getImagesSizeInBytesObs() is called outside a pipe-chain, its output is picked up in the first switchMap, and stored in a variable of type number. </p>

<p>Then a call is made to a second, similar function, this.speciesService.getImagesNumberOfItemsObs(), which again returns a number wrapped in an Observable. This second call should be picked up by the second switchMap operator and again stored in a variable of type number.</p>

<p>This approach worked perfectly well in rxjs 5.5, but I get build-errors in version 6.4.0 or higher. The issue is that apparently the switchMap-operator now adds an additional Observable wrapper, so the second switchMap gets as input a value of type <code>&lt;Observable&lt;number&gt;&gt;</code>, conflicting with the number type of this.imagesNumberOfItems.</p>

<p>The build error I get looks like this:</p>

<pre><code>    Argument of type 'OperatorFunction&lt;number, Observable&lt;{}&gt;&gt;' is not assignable to parameter of type
    'OperatorFunction&lt;Observable&lt;number&gt;, Observable&lt;{}&gt;&gt;'. Type 'number' is not assignable to type
    'Observable&lt;number&gt;'.
</code></pre>

<p>The reason why I believe the use of function bodies is the cause of the problem is that when I use this:</p>

<pre><code> initializeStatisticsObs(): Observable&lt;any&gt; {
    return this.speciesService.getImagesSizeInBytesObs()
      .pipe(
        switchMap((fSizeInBytes: number) =&gt; of(23)),
        switchMap((fNumberOfItems: number) =&gt; {
          this.imagesNumberOfItems = fNumberOfItems;
          return of({});
        })
 ..
      )
  }
</code></pre>

<p>it works fine.</p>

<p>And by the way, the tap() operator can be used with function bodies without these problems, but they aren't suitable for my purposes.
Is there a way to resolve this?</p>
","10219616","","5437671","","2019-12-06 12:57:04","2019-12-06 13:06:59","How to chain switchMap-operators with function bodies in rxjs 6","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59246207","1","59246472","","2019-12-09 09:47:25","","0","198","<p>I am using concat to call multiple API sequentially, but when error, concat stop call api, so how to get error and continue to call next API, here is my code:</p>

<pre><code>getData() {
    concat(...this.data.map(asset =&gt;
      this.assetService.requestData({ assetId: asset._id })
    ))
      .pipe(catchError(error =&gt; {
        console.log(error);
        // return of(null);
        this.error = error;
        return throwError(error);
      }))
      .subscribe();

  }
</code></pre>
","10830139","","","","","2019-12-09 10:09:20","How can I continue to call API after get error when using rxjs concat?","<angular><rxjs6>","1","2","","","","CC BY-SA 4.0"
"59257679","1","59259751","","2019-12-09 22:37:46","","1","624","<p>I'm new to Angular and I'm filtering the user with the id same as in the JWT payload.</p>

<p>I can do this in the subscribe() of the Observable like this:</p>

<pre><code>  this.route.data.subscribe((data) =&gt; {
      this.users = data.users.filter((u: User) =&gt; u.id !== +this.authService.decodedToken.nameid);
  });
</code></pre>

<p>I also can do this in the pipe() method like:</p>

<pre><code>this.route.data
  .pipe(map(data =&gt; data.users.filter((u: User) =&gt; u.id !== +this.authService.decodedToken.nameid)))
  .subscribe((data) =&gt; {
    this.users = data;
  });
</code></pre>

<p>Resolver code (probably irrelevant to the question):</p>

<pre><code>  resolve(route: ActivatedRouteSnapshot): Observable&lt;User[]&gt; {
        return this.userService.getUsers().pipe(
            catchError(error =&gt; {
                this.alertify.error('Problem retrieving data');
                this.router.navigate(['/home']);
                return of(null);
            })
        );
    }
</code></pre>

<p>Now why should I use the pipe() method rather than filtering directly in the subscribe() method are there any advantages or disadvantages of using pipe() in this scenario? Which of the two is the conventional Angular way of doing this?</p>

<p>I would think that the pipe() would be a little bit slower, since it first maps and then filters.</p>
","12336785","","12336785","","2019-12-09 22:44:18","2019-12-10 03:26:06","What are the advantages/disadvantages of performing operations in pipe() rather than directly in subscribe() method?","<angular><rxjs><observable><rxjs6><rxjs-pipeable-operators>","2","4","","","","CC BY-SA 4.0"
"59258622","1","","","2019-12-10 00:39:59","","2","34","<p>I have an observable for which I would want to call cancellation (teardown) logic when subscriber unsubscribes from it but only if the source observable haven't completed yet (or failed) by itself.</p>

<p>The built-in <code>finalize</code> operator lets to register custom callback when <code>unsubscribe</code> occurs but it being called whenever the unsubscription was caused by subscriber or completion of the source observable.</p>

<p>I implemented the this helper function:</p>

<pre class=""lang-js prettyprint-override""><code>function withCancellation(source, onCancel) {
  return new Observable(subscriber =&gt; {
    let completed = false;

    const cancellable = source.pipe(
      tap({
        error: () =&gt; { completed = true; },
        complete: () =&gt; { completed = true; },
      })
    );

    const subscription = cancellable.subscribe(subscriber);
    subscription.add(() =&gt; { if (!completed) onCancel(); });

    return subscription;
  });
}
</code></pre>

<p>Which I can use the following way:</p>

<pre class=""lang-js prettyprint-override""><code>const sourceStream = startJob(jobId); // returns source observable
const cancellableStream = withCancellation(sourceStream, () =&gt; stopJob(jobId));
</code></pre>

<p>Is there any more concise way to achieve the same using any built-in primitives?</p>
","191683","","191683","","2019-12-10 15:47:51","2019-12-10 15:47:51","Cancellation on unsubscribe only if observable hasn't completed","<rxjs><rxjs6>","0","2","","","","CC BY-SA 4.0"
"59281881","1","59281996","","2019-12-11 08:50:15","","2","2927","<p>In my angular apps, I want to show a text/modal that have a <strong>cancel</strong> and <strong>reload</strong> button, when the server responds slowly. </p>

<p>If the user click cancel, current http request will be cancelled. If the user click reload, current http request will be retried. If the text/modal already shown and the HTTP request already respond/completed, then the text/modal should disappear.</p>

<p>I have an idea using HTTP interceptor, RxJS, and global service, but implementing it is not that easy. </p>

<p>Is there anyone who have an idea, how to do this the right way?</p>

<p>EDIT: Oh and I want to make it a generic module so every http request can be cancellable or reloadable. So every page could have this functionality</p>
","10655754","","10655754","","2019-12-11 09:06:37","2019-12-11 12:13:11","Angular: How to show something on slow HTTP response","<angular><rxjs><rxjs6><angular-http-interceptors>","4","2","","","","CC BY-SA 4.0"
"59284059","1","59284708","","2019-12-11 10:46:43","","2","2196","<p><strong>I don't want to use forkJoin inside effect</strong></p>

<p>In my effect, I am getting one array of id's and with the help of those ids, I want to call service multiple times. 
and every time when I get a response I want to dispatch an action to update my store</p>

<pre><code>@Injectable()
export class MovieEffects {
  loadMovies$ = createEffect(() =&gt;
    this.actions$.pipe(
      ofType('[Movies Page] Load Movies'),

     //here i am getting one array object via action,  e.g. = [{id: 1},{id: 2},{id: 3},{id: 4} ]
     //and here i want to call same service 4 time as per array length
     // every time when get response i want to dispatch one action with response payload

      mergeMap((action) =&gt; this.moviesService.getAll()
        .pipe(
          map(movies =&gt; ({ type: '[Movies API] Movies Loaded Success', payload: movies })),
          catchError(() =&gt; of({ type: '[Movies API] Movies Loaded Error' }))
        )
      )
    )
  );

  constructor(
    private actions$: Actions,
    private moviesService: MoviesService
  ) {}
}
</code></pre>
","2968851","","2968851","","2019-12-11 11:15:27","2021-03-04 10:31:24","NGRX: How to call same service multiple time with different payload from inside effect","<angular><typescript><ngrx><rxjs6>","3","0","1","","","CC BY-SA 4.0"
"59323056","1","59323279","","2019-12-13 12:55:29","","0","231","<p>I have two api calls, one for getting all categories and another to get the posts. In posts api, I'm getting the categories ids, I just need to call the categories and get the categories name and add the name instead of ids in the post calls. I know it's not recommended to use nested api calls, so I used <code>flatMap</code> but have no idea how to implement it.</p>

<p><strong>categories</strong></p>

<pre><code>[
  {
    ""id"": 5,
    ""name"": ""Angular"",
    ""slug"": ""angular"",
    ""parent"": 4
  },
  {
    ""id"": 4,
    ""name"": ""Tutorial"",
    ""slug"": ""tutorial"",
    ""parent"": 0
  }
]
</code></pre>

<p><strong>posts</strong></p>

<pre><code>[
  {
    ""id"": 1,
    ""categories"": [
      5,
      4
    ]
  },
  {
    ""id"": 2,
    ""categories"": [
      5
    ]
  }
]
</code></pre>

<p><strong>code</strong></p>

<pre><code>this.blogService.getCategories()
  .pipe(
  flatMap((categories: BlogCategoryModel[]) =&gt; {
    console.log(JSON.stringify(categories)); // I think I have to do logic here
    return this.blogService.getPosts();
  })
).subscribe(posts =&gt; console.log(JSON.stringify(posts)));
</code></pre>

<p><strong>expected result</strong></p>

<pre><code>[
  {
    ""id"": 1,
    ""categories"": [
      ""Angular"",
      ""Tutorial""
    ]
  },
  {
    ""id"": 2,
    ""categories"": [
      ""Angular""
    ]
  }
]
</code></pre>
","4365228","","4365228","","2019-12-13 13:02:30","2019-12-13 13:10:39","Joining two observables based on id","<angular><rxjs><rxjs6>","3","1","","","","CC BY-SA 4.0"
"59333755","1","","","2019-12-14 09:11:14","","0","161","<p>Three api calls, in which two of them has no parameter to pass. So I used forkJoin the two api calls, but the third one needs a parameter which is gotten from the first two apis. I have no idea how to implement it.</p>

<p>Here is my code so far.</p>

<pre><code>ngOnInit();
{
  const categories$ = this.blogService.getCategories(); // one
  const posts$ = this.blogService.getPosts(); // two

  forkJoin([
    categories$,
    posts$
  ]).pipe(
    map(([categories, posts]) =&gt; {
      return posts.map(post =&gt; {
        ... // doing some stuff here
        return post;
      });
    }),
    mergeMap(posts =&gt; {
      return posts.map(post =&gt; this.blogService.getFeaturedImage(post.featured_media)); // three
    }, y =&gt; console.log(y))
  ).subscribe();
}
</code></pre>

<p>In the above code, forkJoin works as I expected. but the third call is not happening. I need to pass a value to the third service. How to do that? </p>

<p>P.S <code>y returns the value of second call as expected</code></p>
","4365228","","","","","2019-12-14 09:54:04","combining three observables two using forkjoin and one using mergemap","<angular><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"59358712","1","59408911","","2019-12-16 14:31:38","","0","218","<p>I am building a chat app in Angular 8 via Websocket on a .Net backend. I need some help trying to get ""User typing..."" event from Angular to the socket. My socket server needs to receive when the user has started typing and when they stopped which it will pass to the recipient. I have a basic reactive form with a single input control which gives me valueChanges event. I have tried many possible combinations of RxJS operators to acheive this but cant make it to work. Please help.</p>

<p>The closest i have gotten is below.</p>

<pre><code>this.newMessageForm.get('message').valueChanges
  .pipe(
    first(),
    tap(value =&gt; console.log('User is typing...')),
    debounceTime(1000)
  )
  .subscribe(value =&gt; {
    console.log('User has stopped typing');
  });
</code></pre>

<p>The above gives me start typing event by giving me the first value of the stream but it doesn't reset if the user stops and starts typing again. I am new to Rxjs. Please help...</p>

<p>Thanks</p>
","9556934","","9556934","","2019-12-19 10:49:28","2019-12-19 11:31:56","Angular 8 Websocket user typing event using rxjs","<angular><typescript><websocket><chat><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59392534","1","59392719","","2019-12-18 12:53:57","","0","911","<p>I have an <code>update()</code> method, with which I search for certain entries in a table and update/filter the entries for each keystroke inside an input field.</p>

<p>My goal is to wait about 400ms after each keystroke before firing the request into the backend so that I avoid too many meaningless requests.</p>

<p>Currently I have implemented it with the <code>setTimeout()</code> function, but I am sure that there is a more elegant way with RxJS.</p>

<pre><code>  update(searchInput: string) {
    setTimeout(() =&gt; {
      this.myService.search(searchInput)
      .subscribe((res) =&gt; {
        this.myArray.content = res;
      });
    }, 400);
  }
</code></pre>

<p>Does somebody has any idea?</p>
","6475284","","","","","2019-12-18 15:10:13","More elegant way to subscribe with rjxs instead of setTimeout function?","<javascript><angular><typescript><rxjs><rxjs6>","6","2","2","","","CC BY-SA 4.0"
"59454623","1","","","2019-12-23 11:32:47","","0","867","<p>we have one Behavior subject in some service</p>

<pre class=""lang-js prettyprint-override""><code>  city = new BehaviorSubject(config.defaultCity);

  get cityObservable(){
    return this.city.asObservable();
  }
</code></pre>

<p>when we get the observable in some component we can listen for the value changes so we fetch different data based on city.</p>

<p>like this</p>

<pre class=""lang-js prettyprint-override""><code>
  categories: Observable&lt;any&gt;;
  activeCoupons: Observable&lt;any&gt;;

  ngOnInit() {

    this.categories = this.utilsService.cityObservable
    .pipe(
      debounceTime(100),
      switchMap(cityId =&gt; this.categoryService.fetchCategories(cityId)),
      map((response: any) =&gt; response.data)
    );


    this.activeCoupons = this.utilsService.cityObservable
    .pipe(
      debounceTime(100),
      switchMap(cityId =&gt; this.couponService.fetchActiveCoupons(cityId))
    );


  }

</code></pre>

<p>the problem is that <code>fetchCategories</code> get called once when city value change and <code>fetchActiveCoupons</code> get called twice when city value change! why did it get its value emitted twice? are not they have the same code?</p>
","8667766","","","","","2019-12-23 11:40:54","Behavior subject has different emit count on value change","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59460578","1","59463063","","2019-12-23 19:45:56","","0","51","<p>Language: Typescript 3.5x</p>

<p>Environment: Angular 8.x, RxJS 6.x</p>

<p>I'm trying to figure out how to get rid of a chain of promises that looks (simplified) like this:</p>

<pre><code>ClassA.methodA1 is called

 -methodA1 does an if/then check and if true, calls ClassB.methodB1

 --methodB1 calls a different function and combines the results with a parameter passed to it, and ultimately calls ClassC.methodC1

 ---methodC1 does some validation and then calls ClassD.methodD1 if valid

 ----methodD1 makes an async call (to a DB) and waits for it to finish before returning back the value it received (an ID).

When methodA1 receives the id, it calls ClassA.methodA2 and passes that Id in as a parameter
</code></pre>

<p>The method called by methodD1 is outside my control, and returns a Promise.  I can't change that.  However, I need methodA1 to wait until methodD1 is complete, and it receives the ID - each intervening method simply passes that return value back up to its caller.</p>

<p>Even this simplified version smells.  NONE of the intervening methods (methodB1 or methodC1, and there are actually 2 more in the real code) need to be async.  The only reason they are currently is that I need everything to wait until methodD1 finishes before continuing.  Each intervening method simply returns the Promise returned from the method it calls.</p>

<p>I refactored with async/await and while there is less code, it is still a series of methods that simply pass the return value they receive from a method call back up the chain, and it's still a bunch of unnecessary async/await on the intervening methods.</p>

<p>I refactored to RxJS Subjects and having methodA1 subscribe and then methodD1 call <code>.next(id)</code> when it is complete but this doesn't really feel any better.  I potentially have several dozen similar flows across my app and it feels like going the Subject route is a lot of extra plumbing overhead and keeping straight which subscription response belongs to which subscription instance is going to be problematic.</p>

<p>My gut tells me that the Subject route is the right approach, but I was wondering if there was something I was missing that makes it cleaner.  Is there some built-in mechanism to tag subscription responses to a given subscription instance so that the subscription code only processes the response to ITS call and then unsubscribes?</p>

<p>The only other approach I can think of, which is just plain <strong>UGLY</strong> is to pass my ClassA instance all the way down to ClassD and have ClassD call methodA2 when it receives the id from the DB.  But this is even worse.</p>

<p>Is there something I'm missing?  If so, what?  Any guidance or a pattern reference is appreciated.</p>
","1816009","","","","","2019-12-24 02:03:25","Break out of promise chain running through multiple classes/methods","<javascript><typescript><promise><rxjs6>","2","10","","","","CC BY-SA 4.0"
"59531241","1","","","2019-12-30 12:56:27","","1","936","<p>I'm trying to make multiple http requests depends of previous one and combine returned data to final result object.</p>

<p>I have two endpoints: </p>

<ol>
<li><p><code>/properties</code> which returns me something like that:</p>

<pre><code>{ 
  ""data"":[ 
    { 
      ""id"":1,
      ""name"":""Property 1"",
      ""units"":[ 
        { 
          ""id"":1,
          ""name"":""Property 1 - Unit 1"",
        },
        { 
          ""id"":2,
          ""name"":""Property 1 - Unit 2"",
        },
      ],
    },
    { 
      ""id"":2,
      ""name"":""Property 2"",
      ""units"":[ 
        { 
          ""id"":3,
          ""name"":""Property 2 - Unit 3"",
        }
      ]
    }
  ]
}```
</code></pre></li>
<li><p><code>/properties/${property.id}/units/${unit.id}/bookings</code> which returns me some object related to previous request for instance: </p>

<pre><code>{
  ""data"": {
    ""id"": 1
  },
  ""meta"": {
    ""count"": 5
  }
}
</code></pre></li>
</ol>

<p>What I would like to achieve is combine those two responses into one on single unit level.
Like this: </p>

<pre><code>{
  [
    ...

    { 
      ""id"":2,
      ""name"":""Property 2"",
      ""units"":[ 
        { 
          ""id"":3,
          ""name"":""Property 2 - Unit 3"",
          ""bookings_meta"": {
            ""count"":5
          }
        }
      ]
    }
  ]
}
</code></pre>

<p>I created something like this and it works fine: </p>

<pre class=""lang-js prettyprint-override""><code>
    list(): Observable&lt;any&gt; {
      return this.http.get('/properties').pipe(
        map((results: any) =&gt; results.data),

        flatMap((properties: any[]) =&gt; {
          if (properties.length &gt; 0) {
            return forkJoin(properties.map((property: any) =&gt; {
              return forkJoin(property.units.map((unit: any) =&gt; {
                return this.http.get(`/properties/${property.id}/units/${unit.id}/bookings`).pipe(
                  map(({ meta }) =&gt; {
                    unit.bookings_meta = meta
                    return unit;
                  })
                )
              }))
            }))
          }
          return of([]);
        })
      );
    }


    this.list().subscribe(response =&gt; {
        console.log(response)
    })
</code></pre>

<p>But I think it is not in 100% correct solution. 
I'm feeling there are too many <code>forkJoin</code> and maybe it shouldn't be there <code>flatMap</code>?</p>

<p>The requests for <strong>bookings</strong> between <strong>units</strong> should be independent. </p>

<p>Some one have an idea how to improve the code above? </p>
","1331309","","1331309","","2019-12-30 13:06:57","2019-12-30 18:48:28","Angular 8 + RxJS and problem with combine flatMap and forkJoin","<javascript><angular><angular8><rxjs6><flatmap>","2","0","","","","CC BY-SA 4.0"
"59563449","1","59563511","","2020-01-02 12:35:23","","1","172","<p>I need to make a API call before another API call conditionally. The scenario is that I have a form along with two buttons, save and finalize. When I press finalize, the form value needs to be saved first if it has been changed. This is my current solution, but it's not really how I want to do this (I don't want an array as the result, I only want the last one):</p>

<pre><code>const operations$ = [];

if (form.dirty) {
  operations$.push(myService.saveTheThing(form.value).pipe(...))
}

operations$.push(myService.finalizeTheThing().pipe(...));

combineLatest(operations$).subscribe(() -&gt; { ... });
</code></pre>

<p>I don't really care about the save operation result in the subscribe block, I'd rather just receive the one value returned by <code>finalizeTheThing()</code> instead of an array that the <code>combineLatest</code> returns. Here's another thing I tried which resembles what I want, but obviously it doesn't work this way:</p>

<pre><code>const stream$ = of(null);

if (form.dirty) {
  stream$.pipe(
    switchMap(() =&gt; myService.saveTheThing(form.value).pipe(...))
  );
}

stream$.pipe(
  switchMap(() =&gt; myService.finalizeTheThing()
);

stream$.subscribe(myThing =&gt; { ... })
</code></pre>

<p>And of course if <code>saveTheThing()</code> fails, <code>finalizeTheThing()</code> should not be called. What would be the proper pattern for this kind of scenario?</p>
","1144506","","","","","2020-01-02 13:08:52","Add an operation to pipe conditionally with RXJS","<angular><rxjs><rxjs6>","2","1","","","","CC BY-SA 4.0"
"59570873","1","59570967","","2020-01-02 22:32:30","","2","684","<pre><code>source&lt;http&gt;
  .pipe(
    switchMap(d =&gt; this.http.get(d))
      .pipe(
        switchMap(j =&gt; this.http.get(j))
      )
  )
  .subscribe()
</code></pre>

<p>Hello, I need to make 3 http requests consecutively where each call contains data for the next call.. are nested switch maps the best practice for this case?</p>
","6939539","","","","","2020-01-03 00:14:19","RXJS - multiple consecutive http requests","<angular><rxjs><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"59632322","1","59632408","","2020-01-07 16:25:48","","0","42","<p>I have a stream of observableA, emitting regularly.</p>

<p>When observableB emits, I want to start watching ObservableA at that point, until it emits a value, capture it and then stop watching again.  Once more I will now wait until observableB emits again.  Rinse and repeat.</p>

<p>I can think of a couple of ways to do this, but none of them are very 'pretty'.</p>

<p>Is there a 'correct' way to do this in RXjs6?</p>
","2765977","","","","","2020-01-07 16:30:55","RXjs - How to wait for new value on observable A, every time observable B says its okay to start 'watching'","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"59670953","1","","","2020-01-09 19:33:59","","2","291","<p>I had a perfectly running code (and still running perfectly). When I upgraded from angular 7 to angular 8,  my visual studio code started showing errors for HttpClient.get methods. </p>

<p>The errors are coming in the catch part of the HttpClient.get method. Code is compiling fine and working fine as well. I checked angular examples and everything looks correct. I am not sure why editor showing issues. </p>

<pre><code>     getLaborStats(dt: string, hotelId: string): Observable&lt;LaborStats&gt; {
    let lastDayLaborURL = HelloGMVars.varServiceURL + 'laborstats' ;
    const options = { headers: new HttpHeaders().append('AccessToken', this.accessToken)};
       return this.httpC.get&lt;LaborStats&gt;(lastDayLaborURL + '/' + hotelId + '/' + dt, options)
     .pipe(
        catchError(this.handleError('getLastDayLabor', null))
     );
     }
</code></pre>

<p>Here are the errors my editor is showing -</p>

<pre><code>""[ts]
Type 'Observable&lt;LaborStats | Observable&lt;any&gt;&gt;' is not assignable to type 'Observable&lt;LaborStats&gt;'.
  Type 'LaborStats | Observable&lt;any&gt;' is not assignable to type 'LaborStats'.
    Type 'Observable&lt;any&gt;' is not assignable to type 'LaborStats'.
      Property 'today' is missing in type 'Observable&lt;any&gt;'.
(method) Observable&lt;LaborStats&gt;.pipe&lt;LaborStats | Observable&lt;any&gt;&gt;(op1: OperatorFunction&lt;LaborStats, LaborStats | Observable&lt;any&gt;&gt;): Observable&lt;LaborStats | Observable&lt;any&gt;&gt; (+10 overloads)
""
</code></pre>

<p>If I remove the .pipe part, then errors go away. So, it tells me that something is problem in the catchError part. </p>

<p>Here is my error handler -</p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpErrorResponse } from '@angular/common/http';

import { Observable ,  of } from 'rxjs';

import { MessageService } from './message.service';
import { OktaAuthService } from './services/okta-auth.service';

/** Type of the handleError function returned by HttpErrorHandler.createHandleError */
export type HandleError =
  &lt;T&gt; (operation?: string, result?: T) =&gt; (error: HttpErrorResponse) =&gt; Observable&lt;T&gt;;

/** Handles HttpClient errors */
@Injectable()
export class HttpErrorHandler {
  constructor(private okta: OktaAuthService, private messageService: MessageService) { }

  /** Create curried handleError function that already knows the service name */
  createHandleError = (serviceName = '') =&gt; &lt;T&gt;
    (operation = 'operation', result = {} as T) =&gt; this.handleError(serviceName, operation, result);

  /**
   * Returns a function that handles Http operation failures.
   * This error handler lets the app continue to run as if no error occurred.
   * @param serviceName = name of the data service that attempted the operation
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  handleError&lt;T&gt; (serviceName = '', operation = 'operation', result = {} as T) {

    return (error: HttpErrorResponse): Observable&lt;T&gt; =&gt; {
      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      const message = (error.error instanceof ErrorEvent) ?
        error.error.message :
       `server returned code ${error.status} with body ""${error.error}""`;

      // TODO: better job of transforming error for user consumption
      this.messageService.add(`${serviceName}: ${operation} failed: ${message}`);

      if (error.status === 401) {
        console.log('401 returned so logging out') ;
        this.okta.logout() ;
      }
      // Let the app keep running by returning a safe result.
      return of( result );
    };
  }
}
</code></pre>
","10987869","","10987869","","2020-01-10 14:37:04","2020-01-10 19:55:56","Angular 8 upgrade - typescript error - Type 'Observable<XYZ | Observable<any>>' is not assignable to type 'Observable<XYZ>'","<angular><typescript><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"59715013","1","59755953","","2020-01-13 10:42:14","","2","739","<p>I have the problem with the progress bar. I am using for it ng-bootstrap module. </p>

<p>I have multiple option in dropdown, and I would like below behavior:
- I can start/stop progress bar for each option from dropdown separatly,
- When I change option to another option, and come back -> counting will be in the background.</p>

<p>Below solution was working perfectly. But, like in IT, sth was changed and I did not see the bug.</p>

<p>Service file:</p>

<pre><code>@Injectable()
export class TimerService {

    constructor(private httpClient: HttpClient) {
    }

    private timer = [];
    private timerStarted: boolean [] = [false];
    private stopTimer$: Subject&lt;any&gt; [] = [];


    startTimer(duration: number, indexDropdown: number) {
        this.stopTimer$[indexDropdown] = new Subject();
        this.timerStarted[indexDropdown] = false;
        this.timer[indexDropdown] = interval(duration).pipe(take(1000), takeUntil(this.stopTimer$[indexDropdown]), share());
        this.timer[indexDropdown].pipe(
            tap(() =&gt; this.timerStarted[indexDropdown] = true),
            finalize(() =&gt; this.timerStarted[indexDropdown] = false)
        ).subscribe();
    }

    getTimer(indexDropdown: number) {
        return this.timer[indexDropdown];
    }

    getTimerStarted(indexDropdown: number) {
        return this.timerStarted[indexDropdown];
    }

    stopTimer(indexDropdown: number) {
        this.stopTimer$[indexDropdown].next();
    }
}
</code></pre>

<p>And component file:</p>

<pre><code>export class TimerComponent implements OnInit, OnDestroy, OnChanges {

    @Input() optionDropdownArray: string[];

    isLoading: boolean;
    progress: number [] = [0];

    private destroy$: Subject&lt;boolean&gt;[] = [];
    private loadingIndexSub: Subscription;
    selectedIndex = 0;



    timerObserver$ = [];


    constructor(
        private timerService: timerService,
        private timerStore$: Store&lt;TimerStatus&gt;,
        private indexService: TimerService,
        private config: NgbProgressbarConfig) {
          config.max = 1000;
          config.striped = false;
          config.animated = false;
          config.type = 'success';
          config.height = '3.5em';
    }

    ngOnChanges(): void {
        this.loadingIndexSub = this.indexService.gettingIndexSelected.subscribe(getIndex =&gt; {
            this.selectedIndex = getIndex;
            this.isLoading = false;
            this.checkProgressSubscriptions();
            if (this.timerService.getTimerStarted(getIndex)) {
                this.destroy$[this.selectedIndex] = new Subject&lt;false&gt;();
                this.progress[getIndex] = this.timerService.getTimer(getIndex).pipe(take(1)).subscribe();
                this.checkProgressSubscriptions();
                this.subscribeToStartedTimer(getIndex);
                this.isLoading = true;
            }
        });
    }

    ngOnInit() {
        this.loadingIndexSub = this.indexService.gettingIndexSelected.subscribe(getIndex =&gt; {
            this.selectedIndex = getIndex;
        });

    }

    private startProcessing() {
        this.destroy$[this.selectedIndex] = new Subject&lt;boolean&gt;();
        this.isLoading = true;
        this.progress[this.selectedIndex] = 0;
        this.timerStore$
            .select(selectDurationActiveWorkStep, {timerSelectorProps: this.selectedIndex}).subscribe(timeArray =&gt; {
            this.timerService.startTimer(timeArray.activeTaskDuration, this.selectedIndex);
            this.subscribeToStartedTimer(this.selectedIndex);
        });
    }

    private stopProcessing() {
        this.isLoading = false;
        if (this.destroy$[this.selectedIndex] != undefined) {
            this.destroy$[this.selectedIndex].next(true);
        }
        this.timerService.stopTimer(this.selectedIndex);
    }


    private subscribeToStartedTimer(dropdownIndexId: number) {
        this.timerObserver$[dropdownIndexId] = this.timerService.getTimer(dropdownIndexId).pipe(
            takeUntil(this.destroy$[dropdownIndexId])
        ).subscribe((val =&gt; {
            this.progress[dropdownIndexId] = val + 1;
        }));
    }

    private checkProgressSubscriptions() {
        for (let i = 0; i &lt; this.optionDropdownArray.length; i++) {
            if (this.timerObserver$[i]) {
                this.timerObserver$[i].unsubscribe();
            }
        }
    }

    ngOnDestroy() {
        if (this.destroy$[this.selectedIndex] != undefined) {
            this.destroy$[this.selectedIndex].next(true);
        }
    }

}
</code></pre>
","10239144","","10239144","","2020-01-14 10:27:08","2020-01-15 16:42:55","Angular, progress bar - asynchronous starting/stoping","<angular><typescript><angular8><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"59755974","1","59756503","","2020-01-15 16:44:08","","1","370","<p><strong>First Step:</strong></p>

<p>Imagine, there is an object named <code>RouteObservables</code> somewhere in the project which I want to use (import) in many components:</p>

<pre class=""lang-js prettyprint-override""><code>export const RouteObservables = {
  state$: 'this.route.paramMap.pipe(map(() =&gt; window.history.state))',
  url$: 'this.route.url',
  params$: 'this.route.params',
  queryParams$: 'this.route.queryParams',
  fragment$: 'this.route.fragment',
  data$: ' this.route.data'
};
</code></pre>

<p><strong>Second Step:</strong></p>

<p>I want to get to the following situation (by using the RouteObservables object above):</p>

<pre class=""lang-js prettyprint-override""><code> const state$ = this.route.paramMap.pipe(map(() =&gt; window.history.state));
 const url$ = this.route.url;
 const params$ = this.route.params;
 const queryParams$ = this.route.queryParams;
 const fragment$ = this.route.fragment;
 const data$ = this.route.data;
</code></pre>

<p><strong>Third Step</strong></p>

<p>I want to use the same collection <code>RouteObservables</code> to start an <code>forkJoin</code> automatically:</p>

<pre class=""lang-js prettyprint-override""><code>forkJoin([...Object.keys(RouteObservables)]).subscribe(
  (routeData: any) =&gt; {
    this.routeData = routeData;
  }
);
</code></pre>

<p><strong>Why do I need the <code>RouteObservables</code> object?</strong></p>

<p>I need the ordered sequence to access the correct data (e.g., <code>routeData[0]</code> will be my state object potentially transferred from the previous route). This object helps me not to miss some subscriptions to unsubscribe at the end (<code>ngOnDestroy</code>) too.</p>

<p><strong>My Question(s):</strong></p>

<ul>
<li><p>What is the most efficient way, to declare Observables in a sequence (I am interested in) in an object (or in a collection) so that I do some operations dynamically? </p></li>
<li><p>If there is no proven (state of the art) way, how can I get from step first to step two? </p></li>
<li><p>Can I spare the second step at all and get more elegantly to the third step?</p></li>
</ul>

<p><strong>Edit1:</strong></p>

<p>Btw: <code>forkJoin</code> does not work with route (ActivatedRoute) observables in this way, because route observables do not complete. Following approach works but my questions are still existing:</p>

<pre class=""lang-js prettyprint-override""><code>// excerpt!
// routeData is a public property 

ngOnInit() {
    this.getAllRouteData();
}

getAllRouteData() {
  const state$ = this.route.paramMap.pipe(map(() =&gt; window.history.state));

  const url$ = this.route.url;
  const params$ = this.route.params;
  const queryParams$ = this.route.queryParams;
  const fragment$ = this.route.fragment;
  const data$ = this.route.data;

  forkJoin(
    state$.pipe(first()),
    url$.pipe(first()),
    params$.pipe(first()),
    queryParams$.pipe(first()),
    fragment$.pipe(first()),
    data$.pipe(first())
  ).subscribe(
    (routeData: any) =&gt; {
      this.routeData = routeData;
      this.start();
    },
    (error: any) =&gt; {
      console.log('Error: ', error);
    }
  );
}
</code></pre>

<p><strong>Edit2: Current Workaround</strong> (<code>routeObservables</code> is not really reusable in other components)</p>

<pre class=""lang-js prettyprint-override""><code> getAllRouteData() {
    const routeObservables = [
      this.route.paramMap.pipe(map(() =&gt; window.history.state)),
      this.route.url,
      this.route.params,
      this.route.queryParams,
      this.route.fragment,
      this.route.data
    ];

    forkJoin(routeObservables.map(r =&gt; r.pipe(first()))).subscribe(
      (routeData: any) =&gt; {
        this.routeData = routeData;
      }
    );
  }
</code></pre>

<p><strong>Why do I ask?</strong></p>

<p>My biggest problem is ""single responsibility"", I am trying to avoid copy+paste-code (e.g. <code>routeObservables</code> above in each component, that needs route related data). </p>
","3025289","","3025289","","2020-01-15 19:03:26","2020-01-15 19:03:26","Angular 8/9 - (Subscribing dynamically): How to automatically forkJoin while getting Observables from a collection?","<angular><typescript><dynamic><rxjs6><fork-join>","1","1","","","","CC BY-SA 4.0"
"59760590","1","59761453","","2020-01-15 22:42:41","","2","494","<p>I am trying to migrate a production Angular application from 7 to 8.  When I try to build I get the following error:  </p>

<pre><code>ERROR in app/vehicle/vehicle.component.ts:90:36 - error TS2344: Type 'IOwnerVehicle' does not satisfy the constraint 'ObservableInput&lt;any&gt;'.
Property '[Symbol.iterator]' is missing in type 'IOwnerVehicle' but required in type 'Iterable&lt;any&gt;'.

90             flatMap&lt;IVehicleOwner, IOwnerVehicle&gt;(owner =&gt; {
                                      ~~~~~~~~~~~~~

  ../node_modules/typescript/lib/lib.es2015.iterable.d.ts:43:5
    43     [Symbol.iterator](): Iterator&lt;T&gt;;
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    '[Symbol.iterator]' is declared here.  

</code></pre>

<p>I believe I have found a clue to the source of the problem in the <strong>TypeScript Subscribable interface issue topic</strong> in the <a href=""http://reactivex.io/rxjs/class/es6/MiscJSDoc.js~SubscribableOrPromiseDoc.html"" rel=""nofollow noreferrer"">RXJS Subscribable documentation</a>.  But I still can't figure out how to solve the problem.  </p>

<p>VSCode shows no errors in the vehicle component.  I thought the numbers following the ts file should represent line and column, but the component is only 50 lines long and line 36 is blank.</p>

<p>The Subscribable docs say something about ""TypeScript has problem supporting interfaces with methods defined as symbol properties."", but the IOwnerVehicle interface is only a property bag.  It has no methods.</p>

<p>The only code having anything to do with a subscription is the constructor</p>

<pre class=""lang-js prettyprint-override""><code>   constructor(@Inject(MAT_DIALOG_DATA) private owner: IVehicleOwner,
      private svc: SearchService,
      private searchDlg: MatDialogRef&lt;OwnerVehicleComponent, IOwnerVehicle&gt;) {
      this.svc.getOwnerVehicles(owner.id.toString()).subscribe(
         list =&gt; {
            if (list.length &gt; 0)
               this.list = list;
            else
               this.searchFailed = true;
         });
   }
</code></pre>

<p>And the service couldn't be simpler</p>

<pre class=""lang-js prettyprint-override""><code>   getOwnerVehicles(vehicleId: string): Observable&lt;IOwnerVehicle[]&gt; {
      const url = `${this.webApi}/vehicle`;
      return this.http.get&lt;IOwnerVehicle[]&gt;(url,
         {params: {owner : vehicleId}});
   }
</code></pre>

<p>Can someone help me figure out what I need to change or where else I need to look?</p>
","428688","","1889607","","2020-01-16 00:28:49","2020-01-16 00:28:49","How do I fix Typescript subcribable interface error?","<angular><typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59785246","1","59785750","","2020-01-17 10:12:02","","1","791","<p>Based on the <a href=""http://pranayamr.blogspot.com/2018/06/way-to-handle-parallel-multiple-requests.html"" rel=""nofollow noreferrer"">article</a> 
I tried to implement parallel update logic with multiple requests to a server:</p>

<pre><code>const prouctIds: number[] = [1, 2, 3];
const requests = from(prouctIds)
    .pipe(mergeMap(id =&gt; /* Emulating error when updating some entity*/ throwError(id + '/err')));
requests.subscribe(success =&gt; console.log(success), err =&gt; console.error('error block', err));
</code></pre>

<p>As the author said: </p>

<blockquote>
  <p>So if there is any request fails i.e. throws server side error, then it doesn't affect other parallel requests.</p>
</blockquote>

<p>But in my case if some of the requests returns an error, other active requests are cancelling. If you run the code snippet above, you can notice one error message in console only.</p>

<ol>
<li>I know that I can use <code>forkJoin</code> with inner <code>catchError</code> pipe, but
what then is the difference between these operators if <code>mergeMap</code>
also cancels parallel requests if an error occurred in one of them?</li>
<li>How to achieve my goal without using inner <code>catchError</code> pipe and transform the error to a regular observable, i.e. <code>catchError(err =&gt; of(err));</code></li>
</ol>

<p>Thanks in advance!</p>
","3818229","","","","","2020-01-17 10:41:46","RxJS: mergeMap operator cancelling other active requests when one of them throws an error","<javascript><angular><rxjs6>","1","2","","","","CC BY-SA 4.0"
"59795854","1","","","2020-01-17 22:56:54","","0","55","<p>I want to perform a side effect after every 20 emits on an interval stream that continues indefinitely. Is it possible to perform a do/take side effect after n emits on a repeating cycle with an rxjs observable stream?</p>

<p>Thanks</p>
","1236657","","1236657","","2020-01-17 23:23:23","2020-01-17 23:23:23","rxjs observable stream: how to perform a side effect on every nth event?","<rxjs6>","1","0","","","","CC BY-SA 4.0"
"59814503","1","","","2020-01-19 21:21:49","","0","56","<p>I'm trying to make a series of XHR GETs based on results of an initial request. I have an array of observables of the secondary requests I want to make, and I can use Array.map to iterate over them and subscribe in sequence to log all of their returned values, but I cannot understand how to format them into a flattened observable that I can print to the screen using the <code>async</code> pipe's single subscription:</p>

<pre><code>ngOnInit() {
  // initial request - returns data on a planet
  this.planet$ = this.starWarsService.getEntityById(""planets"", ""1"");
  this.residentData$ = this.planet$.pipe(
    map(planets =&gt;
      planets.residents.map(planet =&gt;
        // get character data for each resident, `split` just grabs the index to construct the URL
        this.starWarsService.getEntityById(""people"", planet.split(""/"")[5])
      )
    ),
    tap(results =&gt; {
      results.map(result =&gt; {
        result.subscribe(data =&gt; {
          // this prints resident/character data correctly
          console.log(""data"", data);
        });
      });
    })
  );
}
</code></pre>

<h3>How can I unwrap this array of observables into something I can unpack with a single <code>async</code> pipe?</h3>

<p><a href=""https://stackblitz.com/edit/angular-wnxb79?file=src/app/star-wars.component.ts"" rel=""nofollow noreferrer"">StackBlitz</a> </p>
","1252748","","","","","2020-01-19 22:29:25","Array of HTTP Obserables to Async-Pipeable Observable","<javascript><angular><rxjs><observable><rxjs6>","2","0","","","","CC BY-SA 4.0"
"59832442","1","59832513","","2020-01-20 23:56:56","","0","42","<p>I'm learning Angular and trying to listen to a variable holding the http request value. Here's the service</p>

<pre><code>export class UsersService {
 message = new Subject&lt;string&gt;();
 constructor(private http: HttpClient) { }
 addUser(userData: {username, email, password, school}) {
   this.http.post&lt;any&gt;('http://127.0.0.1/apiapp/insert.php', userData).subscribe( (r) =&gt; {
     this.message = r.message;
   });
}
</code></pre>

<p>When I log the message I get <code>success</code>
Now I want to call this function and listen to that variable from the component</p>

<pre><code>result = '';
private resultSubscription: Subscription;

  ngOnInit() {
    this.resultSubscription = this.userS.message.subscribe( (r) =&gt; {
      this.result = r;
    });
 }

  addPost(userData: {username: string, email: string, password: string, school: string}) {
    this.userS.addUser(userData);
    console.log(this.result);    
 }
</code></pre>

<p>I get a blank data (nothing logged just a blank row in the console). Why is that and how to fix it?
Thanks in advance</p>
","1104292","","9493547","","2020-01-21 00:19:15","2020-01-21 00:47:01","Angular 8 issue with subscribing to variable in service","<angular><rxjs><httprequest><listener><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59877325","1","","","2020-01-23 11:17:22","","1","270","<p>I need to make request three times a day at a certain time (8 AM, 12 AM, 4 PM).
What is the best way to implement this?</p>
","4958303","","","","","2020-01-23 11:50:23","How to make requests using rxjs at the certain time?","<javascript><angular><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"59916768","1","59917111","","2020-01-26 08:38:56","","2","147","<p>I want to create an Observable of many observables (merge them). This could be achieved with <code>merge(...arrayOfObservables)</code>. The problem is that some time this array will be changed and the observable should subscribe to the new observables, too.</p>
","3084507","","3084507","","2020-01-26 08:43:58","2020-01-26 09:36:50","RxJS dynamic source of observables","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59919593","1","59920909","","2020-01-26 15:06:35","","1","1046","<p>My requirement is every 10 seconds, need to fetch data from Back end and update the properties for list of input. Also, request should hit the back end one by one. I have searched in the net and found that queue scheduler will be useful for this. (Let me know if my understanding is wrong). So i created the following code:</p>

<ol>
<li>Starting interval for every 10 seconds</li>
</ol>

<pre><code>      private initializeInterval() {
        interval(10000).subscribe(x =&gt; {
          this.queueItems();
        });
      }
</code></pre>

<ol start=""2"">
<li>Creating Queue Scheduler:</li>
</ol>

<pre><code>  private queueItems() {
    let taskEntry: = ['111','2222','333']
    console.log(""Started adding item in queue"");
    taskEntry.forEach(item =&gt; {
      queue.schedule(this.retrieveData.bind(this), 100, item);
    })

    console.log(""Completed adding item in queue"");
  }
</code></pre>

<ol start=""3"">
<li>Retrieving data from backend</li>
</ol>

<pre><code>  private async retrieveData(item) {
    console.log(""Starting"");
    let result = await this.rest.downloadPrope(item);
    console.log(result)
    console.log(""Completed"");
  }

</code></pre>

<p>My Expectation is QueueScheduler calls retrieveData after completing the previous request...But all the request landing into retrieveData simultaneously.</p>

<p>My Output is:</p>

<p>Started adding item in queue</p>

<p>Completed adding item in queue</p>

<p><strong>Starting (3 times)</strong> (Before getting Completed, next request landed from the queue)</p>

<p>Started adding item in queue</p>

<p>Completed adding item in queue</p>

<p><strong>Starting (3 times)</strong></p>

<p>completed (3 times)</p>

<p>completed (3 times)</p>

<p>Could you please tell me what is the issue?</p>
","1862354","","5437671","","2020-01-26 15:45:39","2020-01-26 17:35:43","RxJS Queue Scheduler","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"59986852","1","60015945","","2020-01-30 13:12:56","","1","76","<p>I am trying to poll an API call to my backend. The idea is that the server will send a 202 error until it has finished processing a job and after so many requests will return a 200 with some results. I don't want the error to kill the stream. The API call is only made once.</p>

<p>""rxjs"": ""~6.4.0"",
""@angular/core"": ""~8.2.14""</p>

<p>Kick-off code:</p>

<pre><code>     onSubmit() {
    return this.scraperService.postUrl(this.form.value.url)
      .pipe(
        switchMap( val =&gt; {
          return this.scraperService.pollUntilTaskFinished(val);
        })
      ).subscribe( val =&gt; console.log(val))
  }
</code></pre>

<p>Service code:</p>

<pre><code>     postUrl(url: string): Observable&lt;any&gt; {
    return this.http.post('/api/start', {url})
      .pipe(
        map((res: { jobId: string }) =&gt; {
          if (res.jobId) {
            return res.jobId;
          }
        }));
  }
  pollUntilTaskFinished(jobId): Observable&lt;any&gt; {
        return interval(2000)
          .pipe(
            switchMap(() =&gt; this.http.get(`/api/results/${jobId}`)))
          .pipe(
            catchError(err =&gt; this.handleError(err)),
            map(res =&gt; console.log(res)));
      }
   handleError(data: HttpErrorResponse) {
    if (data.status === 202) {
      return of('continue');
    }
  }
</code></pre>

<p>How can I ensure that the interval repeats until I get a 200 with the JSON I need? </p>
","6364117","","5003490","","2020-02-03 11:30:08","2020-02-03 11:30:08","Rxjs interval is not polling observable server API call","<rxjs><angular8><rxjs6>","1","0","","","","CC BY-SA 4.0"
"60039709","1","","","2020-02-03 12:56:45","","3","644","<p>I am trying to figure out how to structure a jest unit test for the following:</p>

<p>I have a bunch of existing observables and subjects I want to test in a project.  So I have started off with what I would assume to be a simple test case using RXjs marbles inside jest:</p>

<pre><code>      const testScheduler = new TestScheduler((actual, expected) =&gt; {
        expect(actual).toEqual(expected);
      });

      testScheduler.run(({cold, expectObservable}) =&gt; {
        const inputSubject = new Subject();
        const outputSubject = new Subject();
        inputSubject.pipe(map(val =&gt; val * 2)).subscribe(outputSubject);

        cold('a|', {a:1}).subscribe(inputSubject);

        expectObservable(outputSubject).toBe('a|', {a:2});
      });
    }

</code></pre>

<p>While this test does run, it fails.  I am having trouble understanding the output from the test run.  I would like to know if I am doing something wrong, or if I am misunderstanding things in general incorrectly.  Or perhaps just some explanation of the output would be helpful.</p>

<pre><code>    - Expected
    + Received

    @@ -1,16 +1,7 @@
      Array [
        Object {
    -     ""frame"": 0,
    -     ""notification"": Notification {
    -       ""error"": undefined,
    -       ""hasValue"": true,
    -       ""kind"": ""N"",
    -       ""value"": 2,
    -     },
    -   },
    -   Object {
          ""frame"": 1,
          ""notification"": Notification {
            ""error"": undefined,
            ""hasValue"": false,
            ""kind"": ""C"",

...... the code ......

      at TestScheduler.assertDeepEqual (common/chat/newMessages/ratifiedSendMessages/twilioRatifiedSendMessages.unit.test.js:27:24)
      at node_modules/rxjs/src/internal/testing/TestScheduler.ts:159:14
          at Array.filter (&lt;anonymous&gt;)
      at TestScheduler.Object.&lt;anonymous&gt;.TestScheduler.flush (node_modules/rxjs/src/internal/testing/TestScheduler.ts:157:39)
      at TestScheduler.run (node_modules/rxjs/src/internal/testing/TestScheduler.ts:392:12)
      at Object.&lt;anonymous&gt; (common/chat/newMessages/ratifiedSendMessages/twilioRatifiedSendMessages.unit.test.js:30:21)
</code></pre>
","2765977","","2071697","","2020-02-03 12:59:04","2020-02-03 12:59:58","Jest RXjs6 Marbles, how to test existing observable","<jestjs><rxjs6><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"60089079","1","60253753","","2020-02-06 06:40:30","","5","263","<p>I've got a chain of observables. Here is the piece of code:</p>

<pre><code>        //get dynamic tree 
      flatMap(res =&gt; this.dynamicReportId !== null ? this.reportService.getDynamicTree(this.dynamicReportId) : of({})),
      tap(res =&gt; this.dynamicTree = res),
        //get dynamic report 
      flatMap((res) =&gt; this.dynamicReportId !== null ? this.reportService.getDynamicReport(this.dynamicReportId) : of({})),
</code></pre>

<p>However when I got 500 API error from the first request(get dynamic tree), the chain stops and never enters the second flatMap(dynamic report).</p>

<p>Here is the function <code>this.reportService.getDynamicTree()</code>:</p>

<pre><code> get(path: string, params: HttpParams = new HttpParams()): Observable&lt;any&gt; {
    return this.http.get(`${environment.apiBaseUrl}${path}`, {headers: this.setHeaders(true), params: params}).pipe(
      catchError(error =&gt; this.processError(path, error)),
      map((res: Response) =&gt; res));
  }
</code></pre>

<p>where <code>this.processError</code> returns <code>observableThrowError(res);</code></p>

<p>What should I return in case of error to continue the chain? Or is the reason in other things?</p>
","10161976","","10161976","","2020-02-14 10:49:14","2020-02-16 22:42:42","How to keep observable chain going after http error in one observable","<angular><rxjs6>","2","2","1","","","CC BY-SA 4.0"
"60097260","1","","","2020-02-06 14:29:24","","3","826","<p>Let's assume we have a Subject, that can return a given set of values, all of which might require a different approach to them. We could debate whether or not that should ever be the case BUT not quite the point of my inquiry. </p>

<p>So...to handle that we might have our code look something like: </p>

<pre><code>var sub = new Subject(); 

sub.subscribe( 
    data =&gt; {
        if (caseA) {
            // do something
        }
        if (caseB) {
            // do something else
        }
     });
</code></pre>

<p>which is all swell and great and all...but I was wondering if there's some operator that we can chain to make it more rx-ish? Thought of filter, but chaining caseA and caseB will just make it not work (obviously) since it ends up filtering both out. </p>

<p>So, my question boils down to this: is it possible to have anything remotely resembling the bellow pseudocode? Any operator(s) you know that would work like this?</p>

<pre><code>var sub = new Subject(); 

sub.pipe(
    magicOperator(//handles caseA),
    magicOperator(//handles caseB),
)
subscribe( 
    data =&gt; {
        // handles common thread
     });
</code></pre>
","3278687","","","","","2020-02-07 06:23:03","RxJS pipe to filter into 2+branches","<javascript><rxjs><rxjs6><rxjs-pipeable-operators>","2","4","","","","CC BY-SA 4.0"
"60155426","1","","","2020-02-10 17:28:31","","1","836","<p>I'm trying to build one of those more modern paginations where there's not dedicated links for the individual pages but one where more results are loaded automatically when the user scrolls to the bottom. On the web page are multiple widgets that allow you to modify the search parameters. When the parameters change more results should be fetched via ajax beginning from the first page again.
I'm fairly new to RxJs and I'm having issues wrapping my head arround how to identify the observables/subjects I need and how to compose them to achive the described behavior.</p>

<p>Here's the specific flow I have in mind:</p>

<p>When the page is first loaded an initial set of parameters is taken and used to load the first page. When a ""load more"" event is fired the next page should be fetched and rendered to the page.</p>

<p>When the parameters change the page should be loaded starting from page 1 again.</p>

<p>When the server signals that there are no more results to load I should get notified about that via an observable. If further ""load more"" events are fired after no more pages are available the ajax request should not be made to save bandwidth on mobile devices.</p>

<p>Lastly as long as a network request is open i want to be able to display a loader so i need an observable that informs me about whether there are open requests or not.</p>

<p>As a bonus: Currently I've implemented signaling no more results by returning a 404 from the backend when a page one bigger than last page is requested. I'd like to use <code>catchError</code> on the ajax observable in such a way, that it gracefully stops the ajax request without breaking the subscription.</p>

<p>Here's what I was able to come up with so far, but it has multiple Problems (described below):</p>

<pre class=""lang-js prettyprint-override""><code>import { BehaviorSubject, Subject, fromEvent } from 'rxjs'; 
import { map, mergeMap, switchMap, takeUntil, tap } from 'rxjs/operators';
import { ajax } from 'rxjs/ajax';
import { stringify } from 'qs';

const paramsEl = document.querySelector&lt;HTMLTextAreaElement&gt;('#params');
const paramsChangedBtn = document.querySelector&lt;HTMLButtonElement&gt;('#paramsSubmit');
const loadNextPageBtn = document.querySelector&lt;HTMLButtonElement&gt;('#loadNextPage');

const getParams = () =&gt; JSON.parse(paramsEl.value);

const params$ = new BehaviorSubject(getParams());
const page$ = new BehaviorSubject(1);
const noMoreResults$ = new Subject&lt;void&gt;();       // &lt;- public
const connections$ = new BehaviorSubject(0);
const loading$ = new BehaviorSubject(false);      // &lt;- public

// for the sake of this example we're not using an IntersectionObserver etc. but a plain button to fire a ""load more"" event
const loadNextPage$ = fromEvent(loadNextPageBtn, 'click');
// same for params changed event. In my real app I've got a working stream fed from the widgets
fromEvent(paramsChangedBtn, 'click').subscribe(e =&gt; params$.next(getParams()));

// when the params change, reset page to 1
params$.subscribe(() =&gt; page$.next(1));

// update loading$ observable for displaying/hiding a loader
connections$.subscribe(connections =&gt; {
  if(connections &gt; 0 &amp;&amp; loading$.getValue() === false) loading$.next(true);
  if(connections &lt;= 0 &amp;&amp; loading$.getValue() === true) loading$.next(false);
});

// when we need to load the next page, increment the page observable
loadNextPage$.subscribe(e =&gt; page$.next(page$.getValue() + 1));

//////////////

// whenever a new page should be requested, get the current parameters and fetch data for this page
page$
  .pipe(
    takeUntil(noMoreResults$),
    tap(() =&gt; connections$.next(connections$.getValue() + 1)),
    mergeMap(page =&gt; {
      const qs = stringify({
        ...params$.getValue(),
        page,
      });
      return ajax.getJSON&lt;any&gt;(`https://httpbin.org/get?${qs}`)
        // this doesn't seem to do anything
        // furthermore the ajax request would already have been made at this point
        // .pipe(
        //   takeUntil(noMoreResults$)
        // );
    }),
    tap(() =&gt; connections$.next(connections$.getValue() - 1)),
  )
  .subscribe(data =&gt; {
    console.log(data.args);
    // for testing purposes pretend we have no more data at page 5
    if(data.args.page === ""5"") noMoreResults$.next();
  });

// for debugging purposes
loading$.subscribe(loading =&gt; console.log('loading: ', loading));
noMoreResults$.subscribe(() =&gt; console.warn('no more results'));
</code></pre>

<p>You can find the running version of this here on <a href=""https://stackblitz.com/edit/rxjs-rcfsko-modern-pagination-attempt-3?file=index.ts"" rel=""nofollow noreferrer"">stackblitz</a>.</p>

<p>Here's the issues with the code:</p>

<ol>
<li>Current pace of <code>takeUntil(noMoreResults$)</code> breaks the subscription when <code>noMoreResults$</code> has been triggered and then <code>params$</code> emits no further pages are loaded. (See comment in the code for the other location in the ajax pipe).</li>
<li>using <code>params$.getValue()</code> when mergeMapping to the ajax observable feels wrong, however I don't know how to pass down both the page number as well as the parameters in one stream properly.</li>
<li>In general I think I've overused Subjects / BehaviorSubjects quite a bit but I'm not sure. Can you either confirm or deny this?</li>
<li>The composition of the observables feel very messy and hard to follow. Is this based on what I'm trying to do or is there room for improvement for this problem?</li>
</ol>

<p>Can you please provide a working example as well as elaborating on the biggest mistakes I've made.</p>
","966530","","","","","2020-09-24 12:20:48","RxJs 6 load more pagination stream","<javascript><rxjs><rxjs6>","1","1","1","","","CC BY-SA 4.0"
"60158754","1","","","2020-02-10 21:32:14","","0","53","<p>I have the following function that should trigger an HTTP Get call (getPollResults) every 3 seconds. The problem that I'm seeing is that only the initial event fires. </p>

<pre><code>pollResults() {
  return timer(0, 3000)
  .pipe(
    switchMap(() =&gt;  this.pollService.setPollResults()),
    tap(results=&gt; {
      console.log(`updated results: `${results}`);
    })
  );
}

this.pollResults().subscribe()
</code></pre>

<p>If i remove the switchMap, it's working fine (I see a new console log every 3 seconds). So I believe it has to do with how switchMap works. Why would this be impeding on new events from the timer?</p>
","5332322","","","","","2020-02-10 21:57:11","Timer function not firing on subsequent events","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","2","","","","CC BY-SA 4.0"
"60181723","1","","","2020-02-12 05:31:51","","0","49","<p>Demo: <a href=""https://stackblitz.com/edit/rxjs-unsubscribe-issue?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-unsubscribe-issue?file=index.ts</a></p>

<p><strong>Below code is not working</strong></p>

<blockquote>
  <p>Error: Cannot read property 'unsubscribe' of undefined</p>
</blockquote>

<pre class=""lang-js prettyprint-override""><code>    const a = (): Observable&lt;any&gt; =&gt;
    new Observable(sub =&gt; {
      sub.next(1);
      return () =&gt; {
        console.log('unsubscribe');
      };
    });
    const observer = a().subscribe(
      value =&gt; {
        console.log('Subscription');
        observer.unsubscribe();
      },
      e =&gt; console.log(e),
      () =&gt; console.log('complete')
    );
</code></pre>

<p><strong>But the following code is working</strong></p>

<pre class=""lang-js prettyprint-override""><code>    const b = (): Observable&lt;any&gt; =&gt;
    new Observable(sub =&gt; {
      setTimeout(()=&gt;sub.next(1),0);
      return () =&gt; {
        console.log('unsubscribe');
      };
    });
    const observer2 = b().subscribe(
      value =&gt; {
        console.log('Subscription b');
        observer2.unsubscribe();
      },
      e =&gt; console.log(e),
      () =&gt; console.log('complete')
    );
</code></pre>

<p><em>Help me understand the reason behind it</em></p>
","10120247","","946789","","2020-02-12 05:36:02","2020-02-12 07:54:35","Synchronous RxJs unsubscription not working","<rxjs><observable><subscription><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60298213","1","60299039","","2020-02-19 10:29:54","","1","78","<p>I'm trying to create an observable with behavior similar to what is returned by <code>defer</code>, but using <code>create</code> method. So I try:</p>

<pre><code>const obs = Observable.create(function(observer) {
   from(fetch('https://jsonplaceholder.typicode.com/todos/1').then(console.log('fetch done'))).subscribe(observer)
})

setTimeout(()=&gt;obs.subscribe((resp)=&gt;console.log(resp.statusText)), 5000)
</code></pre>

<p>But when I run it in <code>node</code> It just prints ""fetch done"" (on subscription, after 5 seconds as expected) but waits forever there.</p>

<p>When I wrap the <code>from(..)</code> in <code>setImmediate()</code> or <code>setTimeout(,0)</code>, then sometimes it prints both messages (""Fetch done"", ""OK"") and exits and <strong>sometimes it only prints ""fetch done"" and waits forever.</strong></p>

<p>code:</p>

<pre><code>const obs = Observable.create(function(observer) {
    setTimeout(()=&gt;from(fetch('https://jsonplaceholder.typicode.com/todos/1').then(console.log('fetch done'))).subscribe(observer), 0)
})

setTimeout(()=&gt;obs.subscribe((resp)=&gt;console.log(resp.statusText)), 5000)
</code></pre>

<p>Why this happens? What am I doing wrong?</p>
","1555615","","","","","2020-02-19 11:09:54","How can I create an observable like the one returned by defer using Observable.create?","<rxjs><observable><rxjs6>","2","0","","","","CC BY-SA 4.0"
"60320538","1","60335912","","2020-02-20 13:00:02","","1","773","<p>Now there is an array, the array value is the image link, for example:</p>

<pre class=""lang-js prettyprint-override""><code>const imageList = [
  'https://cdn.pixabay.com/photo/2020/02/16/20/29/new-york-4854718_960_720.jpg',
  'https://cdn.pixabay.com/photo/2020/02/14/16/04/mallorca-4848741_960_720.jpg',
  'https://cdn.pixabay.com/photo/2020/02/14/04/20/old-city-4847469_960_720.jpg',
  // more...
];
</code></pre>

<p>I want to use <code>rxjs</code> to download them sequentially(I’m an Electron app, so I can download it)</p>

<p>When the download of the first picture is completed, then download the second picture. When the third picture is being downloaded, the user clicks the pause button and waits for the download of the third picture to complete. Then no more downloads. When the user clicks the continue button, the download starts from the fourth picture.</p>

<p>I refer to this article: <code>Buffering (lossless)</code> section in <a href=""https://medium.com/@kddsky/pauseable-observables-in-rxjs-58ce2b8c7dfd"" rel=""nofollow noreferrer"">https://medium.com/@kddsky/pauseable-observables-in-rxjs-58ce2b8c7dfd</a>. The code in this article is:</p>

<pre class=""lang-js prettyprint-override""><code>merge(
  source$.pipe( bufferToggle(off$, ()=&gt;on$)  ),
  source$.pipe( windowToggle(on$, ()=&gt;off$) )
).pipe(
  // then flatten buffer arrays and window Observables
  flatMap(x =&gt; x)
)
</code></pre>

<p>The demo URL is: <a href=""https://thinkrx.io/gist/cef1572743cbf3f46105ec2ba56228cd"" rel=""nofollow noreferrer"">https://thinkrx.io/gist/cef1572743cbf3f46105ec2ba56228cd</a></p>

<p>But there are two problems in this code, which do not meet my needs. I don't know how to modify it.</p>

<ol>
<li>I use <code>redux-observable</code>, so I want to trigger them with two actions: (<code>this.props.start()</code> / <code>this.props.pause()</code>)</li>
<li>After recovery, data is still transferred one by one, not a one-time release</li>
</ol>

<p>The current code looks like this:</p>

<pre><code>export const epicDownloadResources = (
  action$: ActionsObservable&lt;AnyAction&gt;,
  store$: StateObservable&lt;RootState&gt;,
) =&gt; {
  return action$.pipe(
    ofType(appActions.other.start()),
    of([
      'https://cdn.pixabay.com/photo/2020/02/16/20/29/new-york-4854718_960_720.jpg',
      'https://cdn.pixabay.com/photo/2020/02/14/16/04/mallorca-4848741_960_720.jpg',
      'https://cdn.pixabay.com/photo/2020/02/14/04/20/old-city-4847469_960_720.jpg',
    ]),
    mergeMap(() =&gt; {
      // code
    }),
    mergeMap((url: string) =&gt; {
      // downloading
    })
}
</code></pre>

<blockquote>
  <p>In the real product, it will be downloading the company's internal picture resources, not other non-copyright pictures.</p>
</blockquote>
","6596777","","","","","2020-10-06 12:41:46","How to make rxjs pause / resume?","<reactjs><redux><rxjs><rxjs6><redux-observable>","3","0","1","","","CC BY-SA 4.0"
"60338314","1","","","2020-02-21 12:03:46","","0","78","<p>I'm using Angular 6: I have a service httppost with return type <code>Observable&lt;IResourceInfo&gt;</code>.</p>

<pre><code>searchResourceSuggestion(param: ISearchResourceParam): Observable&lt;IResourceInfo[]&gt;{
return this.httpClient.post&lt;IResourceInfo[]&gt;(url, param); }
</code></pre>

<p>And in my component file: 
I call it in event : </p>

<pre><code>this.searchResourceService.searchResourceSuggestion(param).pipe(takeUntil(this.destroy)).subscribe(data =&gt; {
this.data= data;});
</code></pre>

<p>But <code>this.data</code> is <code>ReplaySubject&lt;IResourceInfo[]&gt; = new ReplaySubject&lt;IResourceInfo[]&gt;(1);</code>
and it show error missing the following properties from type ReplaySubject.</p>

<p>Can anyone help me?</p>
","12938415","","7508700","","2020-02-21 15:34:03","2020-02-21 15:34:03","Angular 6: How to convert Observable[anyobject] to ReplaySubject","<rxjs><angular6><rxjs6>","0","2","1","","","CC BY-SA 4.0"
"60371598","1","61296550","","2020-02-24 07:58:04","","0","183","<p>How could I use rxjs <code>debounceTime</code> and <code>distinctUntilChanged</code> with angular input events <code>(input)</code> or <code>(click)</code></p>

<p>I can't use <code>fromEvent</code> because I also need to pass parameter (Example below)</p>

<pre><code>&lt;li *ngFor=""let item of items&gt;
 &lt;input [(ngModel)]=""item.name"" (input)=""inputChanged(item.id)""&gt;
&lt;/li&gt;
</code></pre>

<p>So I went with <code>Subject</code> (Example below)</p>

<pre><code>&lt;input type=""text"" placeholder=""Type something..."" (input)=""inputFn($event, 'myParam')""  #myInput&gt;

@ViewChild(""myInput"", { static: true }) myInput;
private inputEvent = new Subject&lt;any&gt;();

ngOnInit() {
    this.inputEvent
      .pipe(
        // map((obj: any) =&gt; obj.evt.target.value),
        debounceTime(1000),
        distinctUntilChanged()
      )
      .subscribe(res =&gt; {
        console.log(""res"", res.evt.target.value);
      });
  }

  inputFn(evt, param) {
    this.inputEvent.next({evt, param});
  }
</code></pre>

<p>In the above example, there is no use of <code>distinctUntilChanged()</code>. If I filter with map <code>map((obj: any) =&gt; obj.evt.target.value)</code> and look for value change (distinct) I am going to get only input value not parameter.</p>

<p>My requirement is - I want to wait until user finished entering text and also if user re-enter want to check if value is not same as previous and also want to get parameter.</p>
","11719787","","","","","2020-05-08 20:50:23","How could I use rxjs debounceTime and distinctUntilChanged with angular input events (e.g., click or input)","<angular8><rxjs6>","1","0","","","","CC BY-SA 4.0"
"60418574","1","","","2020-02-26 16:37:53","","0","212","<p>I am using RxJs concatMap to control the saving of some data in my application.</p>

<pre><code>this.myService.saveData(this.updatedData)
  .pipe(
    tap(data1Res =&gt; this.onData1Success(data1Res)),
    concatMap(() =&gt; this.myService.saveOne(this.OneData)),
    tap(data2Res =&gt; this.onData2Success(data2Res)),
    concatMap(() =&gt; this.myService.saveTwo(this.TwoData)),
    tap(data3Res =&gt; this.onData3Success(data3Res)),
    concatMap(() =&gt; this.myService.saveThree(this.ThreeData)),
    tap(data4Res =&gt; this.onData4Success(data4Res)),
    concatMap(() =&gt; this.myService.saveFour(this.FourData)),
  )
  .subscribe(
    res =&gt; this.onSaveSuccess(), // Reload values
    err =&gt; console.log('error while saving', err) // Save to file or db
  );
</code></pre>

<p>Currently this works however it also executes even if say ""this.OneData"" is empty or null...how can I keep it from sending essentially a NoOpp request?</p>
","3557112","","","","","2020-02-27 11:29:02","Using RxJs ConcatMap don't send a value of null or empty string","<angular><rxjs><rxjs5><rxjs6><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"60439817","1","60440078","","2020-02-27 18:44:08","","0","34","<p>I have 2 observables.</p>

<p>This is the method thats return the observable</p>

<pre><code>const rxjs = require('rxjs');
const op = require('rxjs/operators');


const retornaObs = (arg, timeout) =&gt; {
    return rxjs.of(arg)
    .pipe(tap(res =&gt; {
        setTimeout(() =&gt; {
            console.log(res);
        }, timeout);
    }));
}
</code></pre>

<p>and the callers</p>

<pre><code>retornaObs([1,2,3], 4000)
.pipe(op.switchMap(() =&gt; {
    return retornaObs([4,5,6], 2000);
})).subscribe()
</code></pre>

<p>When I do this, my return is <code>[4,5,6]</code> and then <code>[1,2,3]</code>, but I need the sequential return.</p>
","8127564","","8127564","","2020-02-27 18:52:46","2020-02-27 20:30:17","Fisrt observable return after the second they have different timeouts","<angular><observable><rxjs6>","2","2","","","","CC BY-SA 4.0"
"60452901","1","","","2020-02-28 13:36:29","","0","49","<p>How to pause observable every 15 seconds then wait for 5s and then continue emitting? 
I made this example:</p>

<pre><code>const digits = interval(1000);
const pauser$ = interval(20000).pipe(mapTo(true));
pauser$.subscribe(item =&gt;
  console.log(`${new Date().toISOString()} pause fired`)
);
const pauseStopper$ = pauser$.pipe(
  concatMap(_ =&gt; timer(5000)),
  tap(() =&gt; console.log(`${new Date().toISOString()} pause stopped`)),
  mapTo(false)
);

const observable = merge(pauser$, pauseStopper$).pipe(
  startWith(false),
  switchMap(paused =&gt; (paused ? NEVER : digits))
);

observable.subscribe(
  item =&gt; console.log(`${new Date().toISOString()}: ${item}`),
  console.error,
  () =&gt; console.log(""complete"")
);
</code></pre>

<p>After first pause cycle it behaves nearly close to what I need. Any ideas on how to make this more clear?
<a href=""https://stackblitz.com/edit/rxjs-g43kph?devtoolsheight=60"" rel=""nofollow noreferrer"">stackblitz example</a></p>
","7250342","","","","","2020-03-02 08:22:40","Observable periodically pause then continue","<rxjs><rxjs6>","1","4","","","","CC BY-SA 4.0"
"60471598","1","","","2020-03-01 02:53:49","","0","1502","<p>Lately, I have been trying to pull up API requests using rxjs in a react app and this is the solution that I came up with.</p>

<p>What about your thoughts on this?</p>

<p>Are there any good practices which I should follow up?</p>

<p>If there any good solutions please let me know.</p>

<pre><code>import axios from 'axios';
import { Observable } from 'rxjs';

import './App.css';

export class App extends Component {
  state = {
    users: []
  };
  componentDidMount() {
    const fetchUserSubscription$ = this.fetchUsersObservables();

    fetchUserSubscription$.subscribe(data =&gt;
      this.setState({
        users: data
      })
    );
  }

  fetchUsers = async () =&gt; {
    const response = await axios.get(
      'https://jsonplaceholder.typicode.com/users'
    );
    const data = response.data;
    this.setState({ users: data });
  };

  fetchUsersObservables = () =&gt;
    new Observable(observer =&gt; {
      axios
        .get('https://jsonplaceholder.typicode.com/users')
        .then(res =&gt; {
          observer.next(res.data);
          observer.complete();
        })
        .catch(err =&gt; observer.error(err));
    });

  render() {
    const { users } = this.state;
    return (
      &lt;div className=""App""&gt;
        {users.map(u =&gt; (
          &lt;ul key={u.id}&gt;
            &lt;li&gt;{u.name}&lt;/li&gt;
          &lt;/ul&gt;
        ))}
      &lt;/div&gt;
    );
  }
}

export default App;

</code></pre>
","11482414","","","","","2020-03-01 07:09:19","Migrate a API request from using promises to observable (using axios)","<javascript><reactjs><typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"60492870","1","60492943","","2020-03-02 16:22:12","","0","180","<p>I have an array of objects. I need to get array if ids, then call 2 APIs, then close the modal window.</p>

<p>My code is:</p>

<pre><code>from(this.alerts)
      .pipe(map(alert =&gt; alert._id))
      .subscribe(alertIds =&gt; zip(
          this.alertApi.someCall1(alertIds, ...),
          this.alertApi.someCall2(alertIds, ...),
        ).subscribe(() =&gt; {
          this.activeModal.close();
        }),
      );
</code></pre>

<p>Do you have any idea with preventing <code>subscribe</code> inside <code>subscribe</code>?</p>
","8054597","","","","","2020-03-02 16:42:07","Rxjs prevent subscribe in subscribe","<javascript><angular><rxjs><rxjs6><subscribe>","2","1","0","","","CC BY-SA 4.0"
"60504849","1","60504934","","2020-03-03 10:12:08","","3","105","<p>Why do we use two filters in code below instead one?</p>

<pre><code> fromEvent&lt;MouseEvent&gt;(this.mapElement, ""click"")
    .pipe(
        filter(e =&gt; !this.props.disableEvents),
        filter(_ =&gt; !this.mouseState.moved &amp;&amp; mouseDownInMap)
    )
    .subscribe(e =&gt; {});
</code></pre>

<p>Why not:</p>

<pre><code>fromEvent&lt;MouseEvent&gt;(this.mapElement, ""click"")
    .pipe(filter( e =&gt; !this.props.disableEvents &amp;&amp; !this.mouseState.moved &amp;&amp; mouseDownInMap))
    .subscribe(e =&gt; {});
</code></pre>

<p>Also, why we need <code>.pipe()</code> if it works without pipe too?</p>
","8291684","","8291684","","2020-03-03 10:19:52","2020-03-03 10:23:32","Why do we use two filters?","<javascript><rxjs><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"60508561","1","","","2020-03-03 13:40:10","","0","206","<p>Here I want to combine values from observables. 
This code works, but nesting subscribes in such fashion is not good.
I'm looking for better solutions.
Thanks in advance.</p>

<pre><code>someObservable().subscribe(
      data =&gt; {                      // array of elements
        data.forEach(
          element =&gt; {
            anotherObservable(element.id)
              .subscribe(
                anotherData =&gt; doSomething(data, anotherData); // both data needed
              );
          }
        );
      }
    );
</code></pre>
","9981417","","","","","2020-03-03 14:31:31","Combine observable with multiple observables","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"60534077","1","60534613","","2020-03-04 20:19:44","","1","350","<p>I have an array of 'roles' and need to check if the user has each of these roles. The function to check this, returns an Observable:</p>

<pre><code>let roles: string[] = ['role1', 'role2']

public userHasRole(role: string): Observable&lt;boolean&gt; {&lt;already implemented&gt;}
</code></pre>

<p>I need to return an <code>Observable&lt;boolean&gt;</code> or a <code>Promise&lt;boolean&gt;</code> which indicates whether or not the user owns each role.</p>

<p>I can solve this with Promises:</p>

<pre><code>let promises: Promise&lt;boolean&gt;[] = roles.map(r =&gt; this.auth.currentUserHasRole(r).toPromise());
return Promise.all(promises).then(results =&gt; results.every(x =&gt; x));
</code></pre>

<p>but I'm assuming there is a more elegant solution with RxJS? I'm using rxjs 6.5.</p>
","5044561","","5044561","","2020-03-05 07:44:00","2020-03-05 07:44:00","RxJS: ES6 Array every() equivalent to check each item in an array of Observable booleans","<angular><rxjs><observable><rxjs6>","3","0","","","","CC BY-SA 4.0"
"60553986","1","60556806","","2020-03-05 21:10:37","","4","2048","<p>Things I have tried include following where values is array of values of which I want to find the sum.</p>
<p>I have also added necessary functions from rxjs as follows:
I get an error saying</p>
<blockquote>
<p>typeError: Rx.Observable.from(...).sum is not a function</p>
</blockquote>
<pre><code>const { merge , interval ,from} = rxjs;
const { tap ,take ,sum } = rxjs.operators;   
             
var sumSource = Rx.Observable.from(values).sum(function (x) {
    return x;
});

var subscription = sumSource.subscribe(
    function (x) {
        console.log('Next: ' + x);
        x.target.value = x;
    },
    function (err) {
        console.log('Error: ' + err);
    },
    function () {
        console.log('Completed');
    }
);
</code></pre>
<p>Not much is available about sum on internet.Any inputs to fix and get the sum?</p>
","4206540","","6324775","","2020-10-28 10:37:53","2020-10-28 10:37:53","How to use sum operator of rxjs?","<javascript><rxjs><rxjs6><rxjs-pipeable-operators>","1","6","","","","CC BY-SA 4.0"
"60567691","1","","","2020-03-06 16:03:38","","1","160","<p>I have multiple inputs that are created dynamically (Can add or delete inputs). and a text field that shows the sum of the inputs. How can I attach observable dynamically and how can my text subscribe to all of them?</p>

<p>Since I am not able to figure out how to create and attach observables to field or how to access them using their id maybe. I don't have much code to post! Any input ?</p>

<p><strong><em>Function has loop and returns list of obeservables</em></strong></p>

<pre><code>    var source = Rx.Observable.fromEvent(cellVal, 'keyup',(evt) =&gt; evt.target.value).startWith(cellVal.value);
    arr.push(source); 
    }
    return arr;


    values = funct() //calls function that returns array of obervables
    var example = Rx.Observable.combineLatest(values);
    example.subscribe(val =&gt; {
        console.log('Sum:', val);
    });
</code></pre>

<p><a href=""https://i.stack.imgur.com/9t5o5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9t5o5.png"" alt=""The inputs can be created or deleted and sum shud be updated accordingly""></a></p>
","4206540","","4206540","","2020-03-06 16:54:15","2020-03-07 14:27:29","How to update sum from dynamically created inputs?","<javascript><rxjs><rxjs6><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"60607260","1","","","2020-03-09 19:35:47","","0","43","<p>Im trying to update this code to version 6 but I cannot figure out how rework the flow, from reading and playing around I think I need to pipe results etc but I cant see how it can be done using the flow of merge, filter, timer, map, first, toPromise() that used to work. Any RxJS folks able to educate me or point me in the right direction ?</p>

<pre class=""lang-js prettyprint-override""><code>const chats: chats[] = &lt;chats[]&gt;await Observable.merge(
  this.chatService.$chats.filter(chats =&gt; chats.length &gt; 0),
  Observable.timer(5000).map(x =&gt; { 
    throw 'Timeout'
  })
).first().toPromise()

if(chats.find( chat =&gt; chat.id === chatId )) {
  this.log.log(`Found active chat ${chatId}, navigating to it from push notification...`)                       
}
</code></pre>
","12903777","","9423231","","2020-03-10 12:31:39","2020-03-10 12:31:39","Converting old RxJS code to v6 : merge, filter, timer, map, first, toPromise()","<rxjs><rxjs5><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"60618489","1","60619083","","2020-03-10 13:18:45","","0","82","<p>So we have an async class constructor like this</p>

<pre><code>class Task {
    constructor(name, url) {
        return (async () =&gt; {
             this.name = name;
             this.response = await fetch(url);
             return this;             
        })();
    }
}
</code></pre>

<p>Then we want to use that in an observable chain like this</p>

<pre><code>Observable.of({name: ""Task1"", url: ""http://example.com""})
    .pipe(
        switchMap(item =&gt;
            fromPromise(new Task(item.name, item.url)),
            (item, task) =&gt; ({item, task})
        )
    ).subscribe();
</code></pre>

<p>The constructor runs as expected. I have tried from, fromPromise and defer, to get the returned result of the constructor. Used tap to see if the async constructor ever emits. It does not.</p>

<p>Any help?</p>
","5225435","","5225435","","2020-03-10 13:28:22","2020-03-10 13:56:13","Create observable from async class constructor","<javascript><rxjs><rxjs6>","1","4","","","","CC BY-SA 4.0"
"60637952","1","","","2020-03-11 14:07:06","","0","374","<p>I have a variable which is a list <br><br>
<code>this.formListModel = [studentData1,studentData2,studentData3]</code>
<br><br>
Now i have to iterate each Student data in above list and need to pass in a method and that method will send these data to backend via API <br><br>
So here is the small code</p>

<pre><code> 1. this.odataNotificationService.cancelNotification(this.model)
 2.            .pipe(
 3.                tap(() =&gt; {
 4.                    someFunctionality..
 5.                    someFunctionality..
 6.                }),
 7.                flatMap(() =&gt; this.someFunctionWhichReturnsObservable()),
 8.                flatMap(() =&gt;  this.someSecondFunctionWhichReturnsObservable()),
 9.                flatMap(() =&gt; this.formListModel.map(()=&gt;{
                                      return this.thirdFunctionWhichReturnsObservable(form.identifier)
                                   }))
</code></pre>

<p>Now I have a problem in line 9 and 10 <br><br>
Here i have a list which is stored in a variable <code>this.formListModel</code> where i need to iterate data nd need to send in
the Next function <code>this.thirdFunctionWhichReturnsObservable(form)</code></p>

<p>I have used a map inside flatMap which will never work. 
So I am looking for a solution where I can iterate inside the pipe</p>
","11475320","","","","","2020-04-01 06:05:29","How to iterate the List inside the pipe in RXJS","<angular><rxjs><angular8><rxjs6><flatmap>","2","0","","","","CC BY-SA 4.0"
"60659274","1","","","2020-03-12 17:39:32","","0","143","<p>In my TypeScript app I've reached the point where I have a method that internally does several <code>fromPromise</code> and <code>toPromise</code> operations:</p>

<pre><code>  myMethod(...): Promise&lt;string&gt; {
    return fromPromise(this.someService1.someMethod1(...)).pipe(
      mergeMap(param =&gt; fromPromise(this.someMethod2(...))),
      map(param =&gt; getSomethingFromParam(param)),
    ).toPromise();
  }
</code></pre>

<p>also the <code>someMethod1</code> and <code>someMethod2</code> internally use <code>toPromise</code> and <code>fromPromise</code>.</p>

<p>I understand that if I put it like this, it looks quite messy. However the reason is to have a clean API in every service (e.g. I mostly use the result of <code>someMethod1</code> and <code>someMethod2</code> as promises so I convert their internal observable to a Promise and expose it like this).</p>

<p>I could of course refactor the whole thing, having my services to expose more methods so I can for example call a method that returns me directly an Observable instead of a Promise.</p>

<p>My question is: do I need such a refactor?</p>

<p>In other words: currently my services' APIs are quite clean, they only expose Promises. But I do have to play with <code>fromPromise</code> and <code>toPromise</code> whenever I want to benefit from rxjs operators. So I would like to keep things the way they currently are, unless these operations are expensive  (in terms of performance).</p>
","3497671","","","","","2020-03-12 21:57:38","Rxjs: are the fromPromise and toPromise operations expensive?","<typescript><rxjs><es6-promise><rxjs6><rxjs-observables>","1","0","1","","","CC BY-SA 4.0"
"60676047","1","60676939","","2020-03-13 19:12:18","","0","727","<p>I have an input element, where I want to show an autocomplete solution. I try to control the HTTP request's number with RxJS. I want to do: the HTTP request start only after 1 second of the user stop the typing.</p>

<p>I have this code:</p>

<pre class=""lang-js prettyprint-override""><code>of(this.inputBox.nativeElement.value)
  .pipe(
    take(1),
    map((e: any) =&gt; this.inputBox.nativeElement.value),
    // wait 1 second to start
    debounceTime(1000),
    // if value is the same, ignore
    distinctUntilChanged(),
    // start connection
    switchMap(term =&gt; this.autocompleteService.search({
      term: this.inputBox.nativeElement.value
    })),
  ).subscribe((result: AutocompleteResult[]) =&gt; {
    console.log(result);
  });
</code></pre>

<p>The problem is the <code>debounceTime(1000)</code> didn't wait to continue the pipe. The switchMap start immediately after every keyup event.</p>

<p>How can I wait 1 second after the user finishes typing?</p>
","972828","","1244884","","2020-03-13 20:38:33","2020-03-13 20:50:59","How to start processing after the user finishes typing with RxJS?","<rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"60684347","1","","","2020-03-14 15:29:52","","-2","376","<p>In my app I use rxjs and I have a method that looks like this:</p>

<pre><code>query&lt;T extends TableRow&gt;(queryString: string, silent = false): Observable&lt;T[]&gt; {
  return this.sqliteService.dbQuery&lt;T&gt;(queryString).pipe(
    tap(val =&gt; {
      if (this.configService.debugMode &amp;&amp; !silent) {
        console.log(`\n${queryString}`);
        console.log(val);
      }
    })
  );
}
</code></pre>

<p>My <code>query</code> method interlly calls <code>dbQuery</code> that queries an sqlite database.</p>

<p>Also, the <code>query</code> method is called many times in my app. So I'd like to globally cache the result whenever the <code>queryString</code> is the same.</p>

<p>In other words, I'd like the <code>query</code> method to avoid calling again <code>dbQuery</code> when called with a <code>queryString</code> parameter that has been called before, by returning the previously-cached value.</p>

<p>Not sure if this is relevant: my <code>query</code> method lives in an Angular singleton service.</p>
","3497671","","","","","2020-03-15 09:48:32","Rxjs how to cache the result of an observable for a given argument?","<angular><typescript><rxjs><rxjs6><rxjs-observables>","2","0","1","","","CC BY-SA 4.0"
"60752347","1","","","2020-03-19 07:06:51","","1","204","<p>I'm trying to figure out a way to cancel all the HTTP request once the user logs out.
I've created a generic function that is responsible for creating the ajax request. This is the function </p>

<pre><code>const createRequest = (ajaxParameters) =&gt; {
  return ajax(ajaxParameters).pipe(
    takeUntil([ofType(""LOGOUT"")])
  )
};
</code></pre>

<p>and all of my epic functions are importing the above function to make the HTTP request. I'm doing something like this </p>

<pre><code>   const sendRequest = (url) =&gt; {
       xhr = createRequest(_.merge({}, requestDefaults, {
             method: ""GET"",
             url: url
          }, token))
      xhr.pipe(
          map( 
             // some code over here and triggering some actions over here
          )
      )
   }
</code></pre>

<p>The problem is whenever I add <code>takeUntil</code> like the way I did above it stops triggering all of the epics. Any idea what is it that I'm doing wrong over here?</p>

<p>epic code </p>

<pre><code>const fetchUserData = action$ =&gt; action$.pipe(
  ofType(user.FETCH_USER_DATA.PENDING),
  mergeMap(sendRequest(URL_OVER_HERE))
);
</code></pre>

<hr>
","4468132","","4468132","","2020-03-19 08:54:05","2020-03-20 01:37:08","Adding takeUntil stops triggering all the actions rxJS, redux-observable","<reactjs><redux><rxjs><rxjs6><redux-observable>","1","2","","","","CC BY-SA 4.0"
"60783410","1","60785631","","2020-03-21 00:46:35","","1","1804","<p>In Rxjs, there is the pipe <em>takeUntil</em> but there isn't a pipe  <strong><em>wait Until</em></strong>, that makes the current observable waiting for a seconde Observable to emit.</p>

<p>My Final Goal is to make many Observable still waiting until my Observable init$ emits just one value, to continue their execution. So that my Observable init$ has to been executed once and before that my other observable have to wait until inits emits any value different from null.</p>

<p>In this simple exemple, I want to add a pipe to <strong>pipedSource</strong> doing <strong><em>wait Until</em></strong> init$ , So the source has to wait until init$ emits to emit its value.</p>

<pre><code>import { interval, timer, Subject, combineLatest } from 'rxjs';
import { takeUntil, skipWhile, skipUntil, concatMap, map, take } from 'rxjs/operators';
import { BehaviorSubject } from 'rxjs';

const init$ = new BehaviorSubject(null);

const source = new BehaviorSubject(null);
const pipedSource = source
.pipe(
    skipWhile((res)=&gt; res === null)
    //wait until init$ emits a non null value
)

//first subscription to source
pipedSource.subscribe(val =&gt; console.log(val));

source.next({profile:""me""});

//init emits once
setTimeout(()=&gt;{
  init$.next(1);
},2000);

// a second subscription to source
setTimeout(()=&gt;{
  pipedSource.subscribe(val =&gt; console.log(val));
},3000);
</code></pre>

<p>wanted result:</p>

<pre><code>//after 2s of waiting
//first subscription returns ""profile""
//after 3s
//second subscription returns ""profile"" 
</code></pre>
","7041095","","7041095","","2020-03-21 11:26:52","2020-03-21 11:46:01","wait Until a second Observable emits","<angular><rxjs><angular8><rxjs6><angular9>","2","2","","","","CC BY-SA 4.0"
"60805149","1","60871576","","2020-03-22 21:25:50","","0","56","<p>I am using RxJS. I have two Observables (API calls) that return a different amount of information for the same array. I want to switch between the Observables and have the subscription recognize both results, i.e. fire each time a value is returned.</p>

<p>Here's an example using Typescript (this does <em>not</em> work):</p>

<pre class=""lang-js prettyprint-override""><code>let foo = [];
const callOne$ = this.service.getSomeData$; // this should take 0.5 seconds
const callTwo$ = this.service.getAllTheData$; // this should take 6 seconds

callOne$.pipe(
    switchMap(data =&gt; data.length &gt; 0 ? callTwo$ : of(data)
).subscribe(data =&gt; {
    console.log(data); // this fires once but I want it to fire twice
    foo = data;
});
</code></pre>

<p>The above example retrieves <code>callOne$</code>, then retrieves <code>callTwo$</code>, and then gives me the result. Instead I want the results of both in order. How would I subscribe to the Observables so that the first result is received and then updated by the second call?</p>
","3357958","","3357958","","2020-03-22 21:31:32","2020-03-26 16:17:14","How do I switch between two Observables in order and have the subscription fire twice?","<rxjs><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"60846068","1","60846494","","2020-03-25 09:30:22","","4","236","<p>I am trying to run a pool of observables in chunks and add an interval in between. I tried below code:</p>

<pre><code>    let i = 0;
    from([].constructor(20)).pipe(
      concatMap(a =&gt; of(i).pipe(delay(1000))), // add a delay
      mergeMap(obj =&gt; of(i++), 5) // run 5 in parallel
    ).subscribe(res =&gt; {
      console.log('done', new Date().toISOString(), res);
    });
</code></pre>

<p>Now this adds delay to all the observable so the output I get is:</p>

<pre><code>done 2020-03-25T09:23:34.151Z 0
done 2020-03-25T09:23:35.151Z 1
done 2020-03-25T09:23:36.151Z 2
done 2020-03-25T09:23:37.151Z 3
done 2020-03-25T09:23:38.151Z 4
done 2020-03-25T09:23:39.151Z 5
done 2020-03-25T09:23:40.153Z 6
done 2020-03-25T09:23:41.155Z 7
done 2020-03-25T09:23:42.161Z 8
done 2020-03-25T09:23:43.163Z 9
done 2020-03-25T09:23:44.167Z 10
done 2020-03-25T09:23:45.170Z 11
done 2020-03-25T09:23:46.171Z 12
done 2020-03-25T09:23:47.177Z 13
done 2020-03-25T09:23:48.178Z 14
done 2020-03-25T09:23:49.182Z 15
done 2020-03-25T09:23:50.183Z 16
done 2020-03-25T09:23:51.186Z 17
done 2020-03-25T09:23:52.188Z 18
done 2020-03-25T09:23:53.192Z 19
</code></pre>

<p>As you can see it runs each of them and adds 1 second delay. What I want to achieve is run first 5 parallel and then add 1 second delay and then run next five and so on.</p>

<p>I even tried swapping mergeMap and concatMap order in the pipe, but it gives same result.</p>

<p>Any thoughts on how to do that?</p>
","559070","","559070","","2020-03-25 09:52:58","2020-03-25 09:59:56","Running group of observables in chunks in RxJS","<javascript><angular><rxjs><rxjs6>","1","0","2","","","CC BY-SA 4.0"
"60865277","1","","","2020-03-26 10:33:49","","0","248","<p>I need to do these things:</p>

<ul>
<li>delete an item from remote server</li>
<li>if it's success, delete item from local storage</li>
<li>if it's success, reload the items from remote server</li>
</ul>

<p>Now I have this code, but it's not working well, because the third step isn't run.</p>

<pre class=""lang-js prettyprint-override""><code>delete(model: T, paginate: PaginateInterface): Observable&lt;any&gt; {
  return this.remoteStorageService.delete(model).pipe(map((resultDelete: boolean) =&gt; {
    if (resultDelete) {
      this.localStorageService.delete(model);
      return this.remoteStorageService.getAll().pipe(map( (resultGetAll: PaginateInterface) =&gt; {
        return resultGetAll;
      }));
    }

    return paginate;
  }));
}
</code></pre>

<p>I tried to use RxJS switchMap function, but I'm totally lost.</p>

<p>How can I run a function depends on observable's result, and then another observable what return with results?</p>
","972828","","","","","2020-03-26 13:15:55","How to run observable depends on previous observable's result with RxJS in Angular?","<angular><rxjs><rxjs6>","2","8","","","","CC BY-SA 4.0"
"60910575","1","60927754","","2020-03-29 05:40:09","","0","79","<p>I am trying to make nested calls using rxjs with nested forkjoins. However, I am facing an issue where the outer forkJoin stops returning a result when the inner observable has a flatMap inside it.</p>

<p>Here's the code to illustrate.</p>

<pre><code>  // Only returns a value when the flatMap statements are removed from the inner observables it is waiting for
  searchAdmin(searchKey: string): Observable&lt;[StudentAccountSearchResult[], InstructorAccountSearchResult[]]&gt; {
    return forkJoin(
      this.getStudentAccountSearchResults(searchKey),
      this.getInstructorAccountSearchResults(searchKey)
    );
  }

  private getStudentAccountSearchResults(searchKey: string): Observable&lt;StudentAccountSearchResult[]&gt; {
    return this.getStudents(searchKey).pipe(
      map((students: Students) =&gt; students.students),
      // Outer forkjoin in searchAdmin returns when I remove the line below
      flatMap((studentsArray: Student[]) =&gt; forkJoin(studentsArray.map(student =&gt; this.createStudentAccountSearchResult(student)))),
    );
  }

  private getInstructorAccountSearchResults(searchKey: string): Observable&lt;InstructorAccountSearchResult[]&gt; {
    return this.getInstructors(searchKey).pipe(
      map((instructors: Instructors) =&gt; instructors.instructors),
      // Outer forkjoin in searchAdmin returns when I remove the line below
      flatMap((instructorsArray: Instructor[]) =&gt; forkJoin(instructorsArray.map(instructor =&gt; this.createInstructorAccountSearchResult(instructor))))
    )
  }

</code></pre>

<p>Both <code>getStudentAccountSearchResults</code> and <code>getInstructorAccountSearchResults</code> return the proper value when I subscribe to them directly, so there's no error while mapping the observables.
Does anyone know why the flatMap in innerObservables causes the outer forkJoin to stop returning any results? Thanks!</p>

<p>I'm on rxjs 6.4</p>
","12050641","","","","","2020-03-30 09:38:53","RxJS forkjoin stops subscribing if theres a flatMap inside one of the observables it is waiting for","<angular><rxjs><observable><rxjs6>","2","2","","","","CC BY-SA 4.0"
"60921045","1","","","2020-03-29 21:37:38","","0","21","<p>How can we simplify the below mentioned function, basically i want to get rid of nested map operations.</p>

<pre><code>  static getEmployees(data: Observable&lt;any&gt;): Observable&lt;Employee[]&gt; {
   return data.pipe(map(data=&gt;{
        return data.map(item=&gt;{
          return  {
            id: item.id,
            first_name: item.first_name,
            last_name: item.last_name,
            age:item.age,
            is_active:item.is_active
          }
        })
    })) as Observable&lt;Employee[]&gt;;
  }
</code></pre>
","245306","","","","","2020-03-31 11:55:51","How to simplify the a rxjs operator based function","<typescript><rxjs6>","1","1","","","","CC BY-SA 4.0"
"60949661","1","","","2020-03-31 11:37:27","","1","367","<p>I need advice on how I achieve the stated title.
My scenario is this. I have three methods in my service <code>isUserEnable()</code>, <code>isLicenseStatusEnable()</code> and <code>resetPassword()</code> and should be executed sequentially. First, I need to ensure that user is enabled. If user is enabled, I need to ensure that license status is enabled also. Then finally, I can now execute the reset method in my service. If any of the first 2 method return <code>false</code>, then it should abort the reset password and should not continue to execute the succeeding methods.</p>

<p><strong>Service</strong></p>

<pre><code>@Injectable({
    providedIn: 'root'
})
export class PasswordResetService {
    isUserEnable(user: string): Observable&lt;boolean&gt; {
        return true;
    }

    isLicenseStatusEnable(user: string): Observable&lt;boolean&gt; {
        return true
    }

    resetPassword() {
        // reset password code
    }
}
</code></pre>

<p>I have the below code and put <code>delay(5000)</code> to simulate the execution. But, it was not executed one by one. I'm not sure how do I implement it to execute one by one.</p>

<pre><code>  /**
   * Check user status
   */
  userPasswordReset() {
    let userEnabled ;

    this.passwordResetService.isUserEnable('example_user')
      .pipe(
        tap(_ =&gt; TASKS_DATA[0].status = TaskStatus.Started),
        delay(5000),
        map(x =&gt; {
          TASKS_DATA[0].taskdescription = ""User is enable"";
          TASKS_DATA[0].status = TaskStatus.Success;
        })
      )
      .subscribe(result =&gt; {
        userEnabled = result;
      });

    this.passwordResetService.isLicenseStatusEnable('example_user')
      .pipe(
        tap(_ =&gt; TASKS_DATA[1].status = TaskStatus.Started),
        delay(5000),
        map(x =&gt; {
          TASKS_DATA[1].taskdescription = ""License is enable"";
          TASKS_DATA[1].status = TaskStatus.Success;
        })
      )
      .subscribe(result =&gt; {
        return result;
      });
  }
</code></pre>

<p>Any suggestions will be very appreciated. TIA!</p>
","1160123","","1160123","","2020-03-31 12:52:57","2020-03-31 13:41:21","How to execute Observable sequentially that is dependent to each other","<angular><observable><rxjs6>","3","0","","","","CC BY-SA 4.0"
"60976419","1","","","2020-04-01 17:05:39","","0","103","<p>I have a two components whith a shared service and the service is connected to an NGRX Data store. The <code>Button-Component</code> triggers a request via the service by calling the <code>getByKey()</code> method of NGRX-Data. The <code>Display-Component</code> has an Observable which is subscribed with the async pipe.</p>

<pre class=""lang-js prettyprint-override""><code>// Observable subscribed with async pipe
identifiers$: Observable&lt;Identifiers&gt; = new Observable&lt;Identifiers&gt;();

// Method called by the `Button-Component`
callApi(key) {
    // When this emits I want to map the value to `identifiers$`
    this.service.getByKey(key);
}
</code></pre>

<p>So far I'm not able to trigger the call with the Subscrption in the <code>Display-Component</code>. It works if I manually subscribe in the Service and the <code>entities$</code> in the Store are updated too. I could use that but then I need some logic to store the <code>key</code> which I would like to avoid. </p>

<p>So how can I map from the Observable returned by the Store to the one of the <code>Display-Component</code> in one go?</p>
","1453887","","","","","2020-05-20 18:56:17","Angular nested components data flow with NGRX-Data","<angular><ngrx><rxjs6><angular-ngrx-data>","1","0","1","","","CC BY-SA 4.0"
"60978632","1","","","2020-04-01 19:14:19","","0","251","<p>I have an Angular application (9) and have multiple components that request calculation operations over rest and the displays the result in different editors.
Now before I make the request I call a loading panel and after the request fininished I hide the loading panel in the finalize callback. Something like this:</p>

<pre><code>this.isloading = false;
httpclient.get('http://localhost/calculate').pipe(finalize(() =&gt;this.isloading=false).subscribe(v=&gt;{
 //make some operations with the data and set editor values
});
</code></pre>

<p>now the loading panel disappers before all editor values are set. The finalize callback is called directly if the request fininishes, but how to call something like finalize, if the code inside of subscribe or error finishes?</p>
","1959238","","","","","2020-04-01 19:23:41","Rxjs finalize after code in subscribtion ends","<angular><observable><rxjs6><rxjs-pipeable-operators><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"60982979","1","","","2020-04-02 01:39:13","","0","54","<p>So I've seen a lot online, one of the big problems I'm encountering is half the examples either don't compile in typescript, or they use now deprecated methods in RxJs 6.</p>

<p>this is what I'm starting with</p>

<pre><code>@registrah([
  { token: 'test', useValue: 1},
  { token: LoggerDefault, useFactory: memoize( createDefaultLogger ) },
  { token: LoggerTypeOrm, useFactory: memoize( createTypeOrmLogger ) },
  { token: LoggerSecurity, useFactory: memoize( createSecurityLogger ) },
])
</code></pre>

<p>my current attempt is this</p>

<pre><code>  const res = from(registrations).pipe(groupBy(
    (p) =&gt; {
      const {token, ...provider } = p;
      return Object.keys(provider)[0];
    }),
    mergeMap(group =&gt; group.pipe(
      reduce((acc: Array&lt;AllProvider&lt;any&gt;&gt;, cur) =&gt;[...acc, cur], [])
    ))
  );
  res.subscribe((next) =&gt; console.log(next) );
</code></pre>

<p>which is outputting</p>

<pre><code>[ { token: 'test', useValue: 1 } ]
</code></pre>

<pre><code>[
  { token: 'defaultLogger', useFactory: [Function: bound variadic] },
  { token: 'typeormLogger', useFactory: [Function: bound variadic] },
  { token: 'securityLogger', useFactory: [Function: bound variadic] }
]
</code></pre>

<p>what I want is</p>

<pre><code>{ useValue: [ { token: 'test', useValue: 1 } ] },
</code></pre>

<pre><code>{
 useFactory: [
  { token: 'defaultLogger', useFactory: [Function: bound variadic] },
  { token: 'typeormLogger', useFactory: [Function: bound variadic] },
  { token: 'securityLogger', useFactory: [Function: bound variadic] }
]}
</code></pre>

<p>and since I've been fighting with it for far too long I'd also like to see the answer for </p>

<pre><code>{ 
  useValue: [ { token: 'test', useValue: 1 } ],
  useFactory: [
    { token: 'defaultLogger', useFactory: [Function: bound variadic] },
    { token: 'typeormLogger', useFactory: [Function: bound variadic] },
    { token: 'securityLogger', useFactory: [Function: bound variadic] }
  ]
}
</code></pre>
","206466","","","","","2020-04-02 04:36:35","rxjs, how do I groupBy into an object?","<typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61014485","1","","","2020-04-03 14:47:40","","0","101","<p>Hi i am showing a notification message in a div for 10 seconds on button click by using setTimeout().</p>

<pre><code>const ms = 10000;
new Promise&lt;void&gt;(resolve =&gt; setTimeout(resolve, ms)).then(() =&gt; {
        this.startNotification();
 });
</code></pre>

<p>The above code will start showing a notification message upto 10 seconds. Now i would like to extends the time. (i.e) if i hover on the notification message after 5sec of notification started and i placed the mouse on the notification message for 10seconds then the timeout will need to extends total of 20 seconds . (i.e) the seconds which i hover on the message (10 sec) + origonal delay time(10 sec) totally 20 sec. i tried by searching multiple resources unable to find a exact solution.
Is it possible to extend or update the running timeout delay time in setTimeout() or debounceTime(). Eventhough i tried debounceTime it only behave like setimeout. but my need is to update the existing delaytime after it starts running.
kindly help . Thanks in advance.</p>
","3541967","","3541967","","2020-04-05 09:13:42","2020-04-05 09:13:42","How to increase or update the Set timeout or timeout delay while doing a mouse over in Angular 2+ / Javascript / Typescript","<javascript><angular><typescript><rxjs><rxjs6>","0","3","","","","CC BY-SA 4.0"
"61023472","1","61024353","","2020-04-04 03:39:37","","3","2756","<p>What is the difference between merge and mergeAll? They both seem identical to me:
<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeAll"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-mergeAll</a>
<a href=""http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge"" rel=""nofollow noreferrer"">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-merge</a></p>
","2620860","","","","","2020-04-04 14:17:08","What is the difference between merge and mergeAll?","<rxjs><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61023546","1","","","2020-04-04 03:52:07","","1","77","<p>I'm trying to run this MEAN stack authentication code from github: <a href=""https://github.com/sitepoint-editors/mean-authentication"" rel=""nofollow noreferrer"">https://github.com/sitepoint-editors/mean-authentication</a></p>

<p>This is my first time working with MEAN stack specifically.</p>

<p>I have connected the back-end local MongoDB successfully and the front-end Angular compiles and runs as intended. However, when I try to register I get this error:</p>

<p><a href=""https://i.stack.imgur.com/WyU1t.png"" rel=""nofollow noreferrer"">Front end Angular site running</a></p>

<p><a href=""https://i.stack.imgur.com/fwPdY.png"" rel=""nofollow noreferrer"">Error in console</a></p>

<p>Here is the line where data is mapped with RxJS. The if(data.token) line is where it crashes due to data being null.</p>

<pre><code>const request = (base$).pipe(map((data: TokenResponse) =&gt; {
        if (data.token) {
          this.saveToken(data.token);
        }
        return data;
</code></pre>

<p>Here is the full code for the page:</p>

<pre><code>import { Injectable } from ""@angular/core"";
import { HttpClient } from ""@angular/common/http"";
import { Router } from ""@angular/router"";
import { Observable } from ""rxjs"";
import { map } from ""rxjs/operators"";

export interface UserDetails {
  _id: string;
  email: string;
  name: string;
  exp: number;
  iat: number;
}

interface TokenResponse {
  token: string;
}

export interface TokenPayload {
  email: string;
  password: string;
  name?: string;
}

@Injectable({
  providedIn: ""root""
})
export class AuthenticationService {
  private token: string;

  constructor(private http: HttpClient, private router: Router) {}

  private saveToken(token: string): void {
    console.log(""hi"");
    localStorage.setItem(""mean-token"", token);
    this.token = token;
  }

  private getToken(): string {
    if (!this.token) {
      this.token = localStorage.getItem(""mean-token"");
      console.log(this.token);

    }
    return this.token;
  }

  private request(
    method: ""post"" | ""get"",
    type: ""login"" | ""register"" | ""profile"",
    user?: TokenPayload
  ): Observable&lt;any&gt; {
    let base$;
    if (method === ""post"") {
      base$ = this.http.post(`/api/${type}`, user);
      console.log(""basepost"", base$);
    } else {
      base$ = this.http.get(`/api/${type}`, {
        headers: { Authorization: `Bearer ${this.getToken()}` }
      });
    }
    console.log(""base"", base$);

    const request = (base$).pipe(map((data: TokenResponse) =&gt; {
        if (data.token) {
          this.saveToken(data.token);
        }
        return data;
      })
    );

    return request;
  }

  public logout(): void {
    this.token = """";
    window.localStorage.removeItem(""mean-token"");
    this.router.navigateByUrl(""/"");
  }

  public getUserDetails(): UserDetails {
    const token = this.getToken();
    let payload;
    if (token) {
      payload = token.split(""."")[1];
      payload = window.atob(payload);
      return JSON.parse(payload);
    } else {
      return null;
    }
  }

  public isLoggedIn(): boolean {
    const user = this.getUserDetails();
    if (user) {
      return user.exp &gt; Date.now() / 1000;
    } else {
      return false;
    }
  }

  public register(user: TokenPayload): Observable&lt;any&gt; {
    return this.request(""post"", ""register"", user);
  }

  public login(user: TokenPayload): Observable&lt;any&gt; {
    return this.request(""post"", ""login"", user);
  }

  public profile(): Observable&lt;any&gt; {
    return this.request(""get"", ""profile"");
  }
}

</code></pre>

<p>I would like data to not be null so that it will save the token. Any ideas why I am getting this result of data being null?</p>

<p>This is the guide I found the github through:
<a href=""https://www.sitepoint.com/mean-stack-angular-angular-cli/"" rel=""nofollow noreferrer"">https://www.sitepoint.com/mean-stack-angular-angular-cli/</a></p>
","13217590","","13302","","2020-04-04 05:49:05","2020-04-04 05:49:05","MEAN stack authentication issue RxJS not working?","<angular><rxjs><mean-stack><rxjs6>","0","2","","","","CC BY-SA 4.0"
"61035351","1","61036283","","2020-04-04 21:57:34","","0","217","<p>I am working on a front-end project with Rxjs and Angular Framework and I want to get json data from a api ""api/data_processor_classlib.php...."". There are three parts was subscribed the pipe this.webProtectionHTML$ at HTML. I don't know why the pipe this.webProtectionHTML$ made requests 3 times. Is any possible solution that just sent one request and update all data in HTML? Thanks.</p>

<p>HTML Code:</p>

<pre><code>    &lt;div class=""tr""&gt;
      &lt;div class=""align-left""&gt;Phishing &amp; Other Frauds&lt;/div&gt;
      &lt;div class=""align-right""&gt;{{ (webProtectionHTML$|async)?.phishing}}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=""tr""&gt;
      &lt;div class=""align-left""&gt;Spam URLs&lt;/div&gt;
      &lt;div class=""align-right""&gt;{{ (webProtectionHTML$|async)?.spamURLs}}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=""tr""&gt;
      &lt;div class=""align-left""&gt;Malware Sites&lt;/div&gt;
      &lt;div class=""align-right""&gt;{{ (webProtectionHTML$|async)?.malware}}&lt;/div&gt;
    &lt;/div&gt;
</code></pre>

<p>Component:</p>

<pre><code>this.webProtectionHTML$ = this.dayService$
      .pipe(
        mergeMap((days: DaysPeriod // params added to request url) =&gt; this.httpClient.get(`api/data_processor_classlib.php....`//request url, { responseType: 'text' })),
        map((html: string) =&gt; {
          //get html code and find data return as json data
          let result = this.getWebProtectionData(html)
          return result
        }))
</code></pre>

<p>Network log:</p>

<p><a href=""https://i.stack.imgur.com/H4asb.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/H4asb.jpg"" alt=""enter image description here""></a></p>
","12919784","","","","","2020-04-05 12:25:52","How to remove the redundant requests in RXJS?","<angular><rxjs><rxjs5><rxjs6><rxjs-observables>","5","0","1","","","CC BY-SA 4.0"
"61044793","1","61046068","","2020-04-05 15:14:36","","1","48","<p>I would like to change Or update the setimeout delay time while it's running. I have verified by using debounceTime() as an alternate. But need to find how to update the ulready mentioned delay time.instead of creating new. </p>

<p>In the above code snippet I have mentioned the delay as 10 sec. But my need is after this settimeout is started when a mouseevent is triggered I need to update the delay time while settimeout is running. </p>

<p>Kindly advise. Thanks</p>
","13229312","","13229312","","2020-04-05 15:40:35","2020-04-05 16:50:00","Changing setimeout delay time while its running","<javascript><angular><typescript><rxjs6>","1","3","","","","CC BY-SA 4.0"
"61065038","1","","","2020-04-06 17:03:02","","2","181","<p>My HTML has the following code:</p>

<pre><code>button (click)=""doFunc()"" 
</code></pre>

<p>In my ts-file I have the following:</p>

<pre><code>doFunc(){
    this.service.executeAFuncWhichIsAsynchronous().subscribe(x =&gt; { updateMyUi(); });
}
</code></pre>

<p>When I click the button twice, two service calls are made. I don't want this to happen. Instead, subsequent clicks should be ignored.</p>

<p>How can I accomplish this?</p>
","13238759","","78972","","2020-04-07 20:09:21","2020-04-07 20:09:21","How do i use rxjs to ignore second,third button click till my first button click process is complete","<rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"61070613","1","","","2020-04-06 23:41:07","","0","55","<p>I have this, right now I'm getting single values on <code>subscribe</code> but what I really want is one big array. I've tried toArray, zipAll, and a number of other things (note that the concatAll() is probably completely unecessary, but I'm not sure). How do I get from a stream of observables, to a stream of 1 observable that is an array.</p>

<pre><code>    from(registrations)
      .pipe(
        groupBy((p) =&gt; {
          const { token, ...provider } = p;
          return Object.keys(provider)[0];
        }),
        mergeMap((group) =&gt; group.pipe(map((value) =&gt; mapper[group.key](value))).pipe(toArray())),
      )
      .pipe(concatAll())
</code></pre>
","206466","","","","","2020-04-07 00:19:36","How do I take all observables and consolidate them into 1 array?","<typescript><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"61080993","1","61081132","","2020-04-07 13:21:04","","0","55","<p>Imagine I have the following code, where one observable throws error and another one succeeds after a delay:</p>

<pre><code>let observables: Observable&lt;String&gt;[] = [
  of(""string 1"").pipe(delay(1000)),
  throwError(""error"")
];

observables.forEach((observable, i) =&gt; {
  observable.subscribe(val =&gt; {
    console.log('success ' + i);
  }, error =&gt; {
    console.log('error ' + i);
  })
})

forkJoin(observables).subscribe(res =&gt; {
  console.log('final success');
}, error =&gt; {
  console.log('final error');
});
</code></pre>

<p>This code will log the following:</p>

<pre><code>error 1
final error
success 0
</code></pre>

<p>What kind of operator or callback could I use in order to execute some code <em>after</em> all observables have either succeeded or errored? The goal is to log in this order:</p>

<pre><code>error 1
success 0
final error
</code></pre>

<p>Another acceptable outcome would be to catch the error somewhere, and log:</p>

<pre><code>error 1
success 0
final success
</code></pre>

<p>I made a demo: <a href=""https://stackblitz.com/edit/typescript-myfstw?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-myfstw?file=index.ts</a></p>
","5098386","","","","","2020-04-07 13:27:50","RxJs forkJoin: Execute when all observables have errored or succeeded","<typescript><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61089215","1","61089465","","2020-04-07 20:51:10","","0","26","<p>I have stream that is triggered by <code>next()</code> method of Rx <code>BehaviorSubject</code>. How do I share the <code>pipedData$</code> stream between subscribers? </p>

<p>I tried to use <code>share</code> operator here to avoid heavy recalculations inside the <code>map</code> operator but no luck - every subscriber produces recalculations.</p>

<p><a href=""https://stackblitz.com/edit/rxjs-share-with-behavior-subject?devtoolsheight=100"" rel=""nofollow noreferrer"">here's stackblitz for this issue</a></p>

<p>Also is it possible to get number of subscribers from the source?</p>

<pre><code>import { interval, BehaviorSubject } from 'rxjs';
import { take, map, tap, share, debounceTime } from 'rxjs/operators';

const data$ = new BehaviorSubject(null);

interval(1000).pipe(
  tap(x =&gt; console.log('emit:')),
  take(3)
).subscribe((x)=&gt;{
  data$.next(x)
});

const pipedData$ = data$.pipe(
  debounceTime(30),
  share(),
  map(x =&gt; Math.random()),
);

console.log(""--=-=-=-=--=-=----=-=-=-=-==-"")
pipedData$.subscribe(x =&gt; console.log(x));
pipedData$.subscribe(x =&gt; console.log(x));
pipedData$.subscribe(x =&gt; console.log(x));
</code></pre>
","1665293","","1665293","","2020-04-07 20:56:59","2020-04-07 21:10:22","How do I use share() operator properly?","<rxjs><rxjs6><reactivex>","1","0","","","","CC BY-SA 4.0"
"61142959","1","61143223","","2020-04-10 14:57:31","","0","137","<p>I am following <a href=""https://stackoverflow.com/questions/46798981/firestore-how-to-get-random-documents-in-a-collection"">this question</a> to create a query that retrieves one random item from a firebase collection in an Angular 9 app using AngularFire. </p>

<p>The solution works fine and I get an expected outcome except when the query returns 0 results. If that happens I want to repeat the query changing some parameters until I get one item, and only then return an observable which to subscribe to in other services. I am learning how to use Observables and RxJS 6 operators, and I think that the <code>expand</code> operator is what I need. However, I am unable to prevent <code>expand</code> from exiting of the recursive loop until I achieve the desired result.</p>

<p>This is my code:</p>

<p><strong>random-query.service.ts</strong></p>

<pre><code>  fetchDocumentoAleatorio(coleccionPath: string): Observable&lt;any&gt; {
    const IdRandom = this.db.createId();
    return this.consultaAleatorio(coleccionPath, '&gt;=', IdRandom)
      .pipe(expand((document: any) =&gt; document === null ? this.consultaAleatorio(coleccionPath, '&lt;=', IdRandom) : EMPTY
        ), // I expect to repeat the query here changing '&gt;=' to '&lt;=' and using the same randomly generated Id
        map((document) =&gt; { // The recursive loop never takes place since the map operator triggers even if consultaAleatorio() returns null one single time, sending that result to the subscribers
            return publicacion.payload.doc.data();
          }
        ));
  }



consultaAleatorio(path: string, operador: any, idRandom: string): Observable&lt;any&gt; {
    return this.db
      .collection(path, ref =&gt; {
        let query: firebase.firestore.CollectionReference | firebase.firestore.Query = ref;
        query = query.where('random', operador, idRandom);
        query = query.orderBy('random');
        query = query.limit(1);
        return query;
      }).snapshotChanges()
      .pipe(map((arrayDatos: any) =&gt; {
        if (arrayDatos &amp;&amp; arrayDatos.length) {
          return arrayDatos[0];
        } else {
          return null; // It indeed reaches this point if the query returns empty results
        }
      }));
  }
</code></pre>

<p>If any other service makes use of this code, it does it this way:</p>

<p><strong>subscriber-example-service.ts</strong></p>

<pre><code> private firebaseSubscriptions: Subscription [] = [];
  publicacionAleatoriaSubject = new Subject&lt;IpublicacionMiniatura&gt;();
  private publicacionAleatoria: IpublicacionMiniatura;

constructor(
    private db: AngularFirestore,
    private randomQueryService: RandomQueryService) {
  }
  fetchPublicacionAleatoria(): void {
    this.firebaseSubscriptions.push(this.randomQueryService.fetchDocumentoAleatorio('publicaciones-meta')
      .pipe(map((publicacion) =&gt; {
          return {
           //processes data
              };
            })
      )
      .subscribe((publicacionAleatoria: IpublicacionMiniatura) =&gt; {
          this.publicacionAleatoria = publicacionAleatoria;
          this.publicacionAleatoriaSubject.next(this.publicacionAleatoria);
        }
      ));
</code></pre>

<p>In sum:</p>

<ul>
<li>The recursive loop never takes place since the <code>map</code> operator triggers even if <code>consultaAleatorio()</code> returns <code>null</code> one single time, sending that result to the subscribers</li>
<li>When I subscribe to this Observable in other services, it works smoothly and as expected except for the case described, so I think that the problem lies in my misunderstanding on how handle the <code>expand</code> operator to achieve what I need. </li>
</ul>

<p>Thank you in advance for your time.</p>
","13279438","","","","","2020-04-11 09:07:56","Unable to query recursively using RxJS 6 and expand operator (Angular, Firebase & Observables)","<angular><rxjs><observable><expand><rxjs6>","1","1","","","","CC BY-SA 4.0"
"61148401","1","","","2020-04-10 20:43:40","","0","21","<p>I am working on a project that uses a SSO accross multiple applications. However, the application has it's own separate subscription service. We get the username and the email from the SSO, to create the subscription. If the subscription already exists, we edit it, otherwise we create a new one.</p>

<p>I am trying to write this in an observable pipe to subscribe too.</p>

<p>Basically first try to edit the subscription (we assume it exists), however, if that fails with a certain error (user doesnt exist) - create a brand new subscription, then go back to editing it. If it fails with a different error, like a server error, then just throw that error.</p>

<p>My issue is writing this logic properly. Here is what I have:</p>

<pre><code>
    this.userSubscriptionService.getSubscriptions(this.userName).pipe(
      catchError((err) =&gt; {
        if (err.error.message === 'Enter a valid username') {
          return this.userSubscriptionService.createSubscription(this.userName, this.emailAddress);
        } else {
          return throwError(err);
        }
      }),
      flatMap((userSubs: IUserSubscriptions) =&gt; this.editSubscription(userSubs))
    ).subscribe();
</code></pre>

<p>First I get the subscription, so I can edit it with the new information. However, if getSubscription throws an error, I want to then create the subscription using the username and email obtained from a separate SSO service, and then edit the brand new subscription to include the new information.</p>

<p>createSubscription will only return a boolean based on if it worked, whereas getSubscription returns all the information I need.</p>

<p>I am having trouble figuring out how to write the retry logic after I catch the error.</p>

<p>Please let me know if you need info..</p>

<p>Thank you for any feedback.</p>

<p>========================== Edit =======================</p>

<p>So ultimately what I am trying to solve, is if the user doesn't exist, create the user, then restart the whole pipe. And I came up with this</p>

<pre><code>
    this.userSubscriptionService.getSubscriptions(this.userName).pipe(
      catchError((err) =&gt; {
        if (err.error.message === 'Enter a valid username') {
          return this.userSubscriptionService.createSubscription(this.userName, this.emailAddress);
        } else {
          return throwError(err);
        }
      }),
      flatMap((userSubs: IUserSubscriptions) =&gt; this.editSubscription(userSubs)),
      retryWhen(err =&gt; {
        return err;
      }),
    ).subscribe();
</code></pre>

<p>Which works - unless the backend is down or there is some other reoccuring error. If the error can't be resolved, it will retry my pipe infinitely.</p>
","13282244","","13282244","","2020-04-10 21:20:11","2020-04-10 21:29:55","Observable error, execute different observable, retry original observable (Angular, RxJs6)","<angular><typescript><rxjs><observable><rxjs6>","1","4","","","","CC BY-SA 4.0"
"61175303","1","61175766","","2020-04-12 17:17:34","","1","113","<p>Inside a merge I want the first observable to be conditional between two different ones, but it seems adding a switchMap inside a merge doesn't work.</p>

<p>I don't understand why the <code>switchMap</code> inside the <code>merge</code> never triggers and only handle pure observables.</p>

<pre><code>switchMap(() =&gt; {
       return merge(
          switchMap(() =&gt; {
            if (condition) {
              return of(something);
            }
            return of(somethingelse);
          }),
         obs2$
        );
      })
</code></pre>
","1091470","","","","","2020-04-12 17:51:56","RxJS: switchMap inside merge doesn't work to make a conditional observable return","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61195597","1","61195772","","2020-04-13 19:49:38","","0","89","<p>I'm working with <strong>Angular 9 / rxjs 6.5.2</strong>,</p>

<p>I want to get only the latest value when I subscribe to the Observable, 
I want the <strong>latest</strong> and not the <strong>last</strong>, because for the last, it will wait until Observable completes but in my case I want the latest at this moment.</p>

<p><strong>My Code:</strong> </p>

<p>PS: You can test it directly in this link:
<a href=""https://stackblitz.com/edit/pjreww"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/pjreww</a></p>

<pre class=""lang-js prettyprint-override""><code>const observable = new Observable(subscriber =&gt; {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  setTimeout(() =&gt; {
    subscriber.next(4);
    subscriber.complete();
  }, 1000);
});

observable
  .pipe(
    //some pipe to make me take the latest value only
  )
  .subscribe({
    next(x) { console.log('got value ' + x); },
  });
</code></pre>

<p><strong>Output Wanted:</strong>:</p>

<pre><code>3
4
</code></pre>

<p><strong>Actual Output</strong></p>

<pre><code>1
2
3
4
</code></pre>
","7041095","","5583283","","2020-04-14 15:35:42","2020-04-14 15:35:42","get the newest value only from an Observable","<angular><rxjs><rxjs6><angular9>","1","0","","","","CC BY-SA 4.0"
"61201219","1","61201453","","2020-04-14 05:27:25","","0","608","<p>I have two interfaces, they are Team and Company</p>

<pre><code>public interface Team {
  id: number;
  name: string;
  companyId: number;
}

public interface Company {
  id: number;
  name: string;
}
</code></pre>

<p>This is the sample data:</p>

<pre><code>""companies"": [
    {
      ""id"": 3,
      ""name"": ""XSoftware"",
      ""location"": ""Nagar""
    },
    {
      ""id"": 5,
      ""name"": ""Google"",
      ""location"": ""Seattle""
    },
    {
      ""id"": 7,
      ""name"": ""YS"",
      ""location"": ""Dhanmondi""
    },
    {
      ""id"": 8,
      ""name"": ""Amazon"",
      ""location"": ""Seattle DC""
    },
    {
      ""name"": ""ToTD"",
      ""location"": ""Pink City"",
      ""id"": 10
    }
]
</code></pre>

<pre><code>""teams"": [
    {
      ""id"": 1,
      ""name"": ""Team X"",
      ""expertise"": ""Java"",
      ""companyId"": 3
    },
    {
      ""id"": 2,
      ""name"": ""Team Y"",
      ""expertise"": ""Angular"",
      ""companyId"": 3
    },
    {
      ""id"": 3,
      ""name"": ""Team Z"",
      ""expertise"": ""Spring Boot"",
      ""companyId"": 8
    },
    {
      ""id"": 4,
      ""name"": ""Team M"",
      ""expertise"": ""Node Js"",
      ""companyId"": 5
    }
]
</code></pre>

<p>So I want to assign <strong>company</strong> as property to each team based on <strong>companyId</strong>.
Like this:</p>

<pre><code>""teams"": [
    {
      ""id"": 1,
      ""name"": ""Team X"",
      ""expertise"": ""Java"",
      ""companyId"": 3,
      ""company"": {
         ""id"": 3,
          ""name"": ""XSoftware"",
          ""location"": ""Nagar""
       }
    },
    {
      ""id"": 2,
      ""name"": ""Team Y"",
      ""expertise"": ""Angular"",
      ""companyId"": 3,
      ""company"": {
         ""id"": 3,
          ""name"": ""XSoftware"",
          ""location"": ""Nagar""
       }
    },
    {
      ""id"": 3,
      ""name"": ""Team Z"",
      ""expertise"": ""Spring Boot"",
      ""companyId"": 8,
      ""company"": {
         ""id"": 8,
         ""name"": ""Amazon"",
         ""location"": ""Seattle DC""
       }
    },
    {
      ""id"": 4,
      ""name"": ""Team M"",
      ""expertise"": ""Node Js"",
      ""companyId"": 5,
      ""company"": {
         ""id"": 5,
         ""name"": ""Google"",
         ""location"": ""Seattle""
       }
    }
]
</code></pre>

<p>So how can I achieve this using RxJs.
I have two observables that return Observable of Team[] and Company[] respectively.</p>

<pre><code>const teams$: Observable&lt;Team[]&gt; = this.httpClient.get&lt;Team[]&gt;('/teams');
const companies$: Observable&lt;Company[]&gt; = this.httpClient.get&lt;Company[]&gt;('/companies');
</code></pre>

<p>So, How to do this? I know it can be done in imperative way (by using loops, if-else etc), but I want to do this in reactive way by only using reactive operators, observers. </p>
","7515993","","","","","2020-04-14 05:58:01","How to combine two arrays into a single array using RxJs where 2nd array's each element will be assigned to first arrays each object property?","<arrays><angular><reactive-programming><rxjs6><rxjs-observables>","3","1","","","","CC BY-SA 4.0"
"61240544","1","61257762","","2020-04-16 00:01:22","","2","214","<p>I already solved my issue, but I would like to understand why this happens.</p>

<p>I'm banging my head reading and stuff but can't find why it's duplicating the output on the subscribe block.</p>

<p>Here is a stackblitz with the code </p>

<p><a href=""https://stackblitz.com/edit/angular-szwnz7"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-szwnz7</a></p>

<p>My train of thought is.</p>

<p>On that component, on every router event of type NavigationEnd I want to get the section id.</p>

<p>But nothing inside the event from the router interests me.
So I do a <code>switchMap</code>  with the <code>activatedRoute.queryParamMap</code> Observable, to inside the subscription block get the id number.</p>

<p>And everytime that I click between links it shows two console.logs.</p>
","1518284","","1518284","","2020-04-16 13:23:29","2020-04-16 18:47:09","Router event with switchMap duplicated output","<angular><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"61274145","1","","","2020-04-17 14:33:57","","0","196","<p>I have in my Angular 9 Project (rxjs v. 6.5.4) a code like:</p>

<pre><code>export class MyServiceService {
   private myBS = new BehaviorSubject&lt;SomeObject&gt;(null);
   public myBS$ = this.myBS.asObservable();
   setMyBS(value: SomeObject): void {
      this.myBS.next(value);
   } 
}

export class Class1 {
   constructor(private myServiceService: MyServiceService) {}
   myServiceServiceSub = myServiceService.subscribe(result =&gt; {
       // Every time I leave the component and enter it again, this part will be called +1 time more
   });
}

export class Class2 {
   constructor(private myServiceService: MyServiceService) {}
   someMethod() {
       myServiceService.setMyBS(someValue);
   }
}
</code></pre>

<p>As described, every time if I leave the page including component (Class1) and enter it again, the part within the subscription will be called +1 time more. So if I 5 time leave and enter the page, the code within the subscription will be called 5 times.</p>

<p>I've found out, i have to unsubscribe the Observable by destroying the component. But I cannot understand, why it calls the subscription multiple times, since the component will be destroyed by leaving the page and create a new instance by entering?</p>
","6510020","","","","","2020-04-17 14:33:57","RxJS Subscription in Angular 9 Service incremented calls by leaving and entering page including component","<javascript><observable><rxjs6><angular9>","0","6","","","","CC BY-SA 4.0"
"61324410","1","61325784","","2020-04-20 14:04:00","","1","224","<p>I have a costly server ajax request which has one input (<code>full: boolean</code>). If <code>full</code> is <code>false</code>, the server can return either a partial or a full response (<code>response.isFull == true</code>); but if <code>full</code> is <code>true</code>, the server <strong><em>will</em></strong> return a full response. Normally the partial response is good enough, but there are certain conditions that will require a full response. I need to avoid requesting a full response explicitly as much as possible, so I thought I'd start with a <code>BehaviorSubject</code> which I can eventually feed with <code>true</code> and combine it with <code>distinctUntilChanged</code> if I ever need to get the full response. This will give me an observable with <code>false</code> initially and that can give me <code>true</code> if I feed that into it:</p>

<pre><code>const fullSubject = new BehaviorSubject&lt;boolean&gt;(false);
</code></pre>

<p>Then I've got a function that takes a boolean parameter and returns an observable with the server request (retried, transformed, etc.). As said, the answer can be partial or full, but it can be full even if the input parameter was false at the server's discretion. For example:</p>

<pre><code>interface IdentityData {
    ...
    isFull: boolean;
}

private getSimpleIdentity(full: boolean): Observable&lt;IdentityData&gt; {
    return Axios.get(`/api/identity${full?""?full=true"":""""}`)
    .pipe( ... retry logic ...,
        ... transformation logic ...,
        shareReplay(1) );
}
</code></pre>

<p>I need to know how can I combine these so that the following is true:</p>

<ul>
<li>The server needs to be queried at most twice.</li>
<li>If the first answer is a full answer, no further queries must be performed to the server.</li>
<li>If the first answer is a partial answer, and <code>true</code> is fed into <code>fullSubject</code>, a full answer must be requested.</li>
</ul>

<p>The expected output from all this is an observable that emits either one full response, or a partial response and, when asked, a full response.</p>

<p>Environment: Vue 2.6.11, RxJS 6.5.5, Axios 0.19.2, TypeScript 3.7.5.</p>

<p>Thanks in advance</p>
","225979","","","","","2020-04-22 07:08:22","RXJS subscribe only if previous value is not that great and I really need a better one","<rxjs><rxjs6>","2","1","","","","CC BY-SA 4.0"
"61358936","1","61359681","","2020-04-22 06:52:24","","0","185","<p>I am new to rjxs programming so wondering how can I do the following.</p>

<pre><code>    const downloadUrls$: any = filelist.map((file: any) =&gt; {
      const fileName = ...
      const path = ...
      const fileRef = ....
      const task: any = ...

      // get notified when the download URL is available
      return task.snapshotChanges().pipe(
        filter(snap =&gt; snap.state === TaskState.SUCCESS),
        switchMap(() =&gt; from(fileRef.getDownloadURL()))
      );
    });
</code></pre>

<p>So in the above code instead of doing <code>from(fileRef.getDownloadURL())</code> is there is a way I can do create a object like below and the return will be a  list of below objects.</p>

<pre><code>             from (
                {
                 name: fileName,
                 filepath: fileRef.getDownloadURL(),
                 relativePath: path
                }
              )
</code></pre>

<p>Method signature</p>

<pre><code> `.getDownloadURL(): Observable&lt;any&gt;`  
</code></pre>
","663011","","663011","","2020-04-22 07:28:23","2020-04-22 07:38:55","Return object inside switchMap","<rxjs><rxjs5><rxjs6><switchmap>","1","1","1","","","CC BY-SA 4.0"
"61361838","1","","","2020-04-22 09:36:29","","0","34","<p>I have the following code</p>

<p>I am new to rjxs programming so wondering what can be the root cause. I am trying to do a certain task and first combine all latest result, then subscribe to assign results.  But combineLatest is not working seems like. What can be the cause ?</p>

<pre><code>const downloadUrls$: any = Array.from(event.target.files).map((file: any) =&gt; {
  const fileName = ...
  const path = ...
  const fileRef = ....
  const task: any = ...

  return task.snapshotChanges().pipe(
    filter(snap =&gt; snap.state === firebase.storage.TaskState.SUCCESS),
    switchMap(() =&gt; {
      return fileRef.getDownloadURL().pipe(
        map((url: string) =&gt; ({
          name: fileName,
          filepath: url,
          relativePath: path,
        }))
      );
    })
  );
});

combineLatest(...downloadUrls$).subscribe((urls: any) =&gt; {
  console.log(hi); // not printing
});
</code></pre>
","663011","","","","","2020-04-22 18:09:38","combineLatest is not getting called","<firebase><rxjs><rxjs5><rxjs6><combinelatest>","2","2","","","","CC BY-SA 4.0"
"61376628","1","","","2020-04-22 23:10:04","","1","2043","<p>I have an epic works well with concat operator. Webstorm starts saying it is deprecated in the way I use it. Says </p>

<blockquote>
  <p>deprecated export function concat&lt;{type: string}[]>(     v1: {type: string}[],     scheduler: SchedulerLike): Observable>
  Use scheduled and concatAll (e.g. scheduled([o1, o2, o3], scheduler).pipe(concatAll())</p>
</blockquote>

<p>Can't figure out, how to rewrite this code?</p>

<pre><code>const epic = action$ =&gt; action$.pipe(
  ofType(TYPE),
  mergeMap(() =&gt;
    concat(
      of({type: 'START'}),
      ajax.getJSON('someurl').pipe(
        mergeMap(serverResponse =&gt; ([
          {type: 'LOADED'},
          {type: 'DO_JOB', serverResponse}
        ]))
    )
  )
)
</code></pre>
","2722228","","","","","2020-04-22 23:50:48","deprecated concat operator in RxJS epic","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61383783","1","61388256","","2020-04-23 09:26:52","","-1","38","<p>I have an array of objects data/ids received as parameter in the function where I should execute a post request for each element/id:</p>

<pre><code>fillProfile(users) {

    const requests = [];
    console.log( 'USERS.length:', users.length );
    requests.push( this.http.post( '/test/add', users[i] ) );

    for ( let i = 0; i &lt; users.length; i++) {
        return this.http.post( '/test/add', users[i] ).pipe(
            map( (res) =&gt;  {
                console.log( 'res: ', res );
                return res;
            }),
            catchError(err =&gt; {
                return throwError(err);
            })
        );
    }
</code></pre>

<p>It's working but it's not a good praxis and so fare I did search, it can be done via <strong>forkJoin</strong> or other operators. Have been trying these options/answers found in SO but unfortunately none of them did work.</p>

<p>One option I tried which doesn't work:</p>

<pre><code> ....
 return from(requests2).pipe(
     concatMap((request) =&gt; request.pipe(
         delay(500),
         map( res =&gt; {
             // console.log( 'res: ', res );
             return res;
         })
    ))
);
</code></pre>

<p>Any idea how to execute multiple requests and also get response and error of each one separately in a better approach?  </p>
","5310217","","","","","2020-04-23 13:20:07","Why concatMap does not work for multiple requests at once?","<angular><typescript><xmlhttprequest><rxjs6>","1","1","","","","CC BY-SA 4.0"
"61399384","1","","","2020-04-24 01:00:46","","0","80","<p>I want to send a bulk of data and after completing it, want to move to the next one. For example: 
I have this function: </p>

<pre><code>async function test() {
  await sample.sampleStructure()
  await sample.sampleDataAdd()
  await sample.sampleDataGet()
}
</code></pre>

<p>Where I am calling the 3 functions for each call. But I wanted to send for example 200 data for <code>await sample.sampleDataAdd()</code> and if the first 200 data response is 'Success' then it will send the rest of the 200 datas. After completing 1000 datas, I want to move on to the next function call.
So I looked and I think RXJS can provide the solution. But I am not use if is it possible to use the filter and next for this scenario. </p>

<pre><code>async function test() {
  await sample.sampleStructure()
  // let observable = Observable.range(1,1000)
  let observable = Observable.create()
  observable
  .filter(aysnc function () {
    await sample.sampleDataAdd()
   })
  .subscribe({
    .next: async function () {
       // await sample.sampleDataAdd()
    },
    .error: function (error) {
      console.log(error)
     }
   })
</code></pre>

<p>I am very new at rxjs, so there are lots of mistakes as well. Please can anyone help me regarding this matter ? </p>
","12882502","","","","","2020-04-28 12:10:11","Bulk data call using RXJS in nodejs","<javascript><node.js><rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61423790","1","61423823","","2020-04-25 09:48:18","","0","574","<p>I use <code>combineLatest</code> to get latest values from each observables:</p>

<pre><code>combineLatest$ = combineLatest(_block$, _field$);
    combineLatest$.subscribe(() =&gt; {
      console.log(""Completed..."");
    });
</code></pre>

<p>Then I have another observable that works until <code>forkJoin$</code> sends data:</p>

<pre><code>of(true).pipe(delay(1000), takeUntil(combineLatest$)).subscribe(() =&gt; console.log());
</code></pre>

<p>How to complete <code>combineLatest$</code>? And should I unsubscribe from <code>of()</code> or it will be destroyed automaticaly?</p>
","","user13295902","","user13295902","2020-04-25 09:55:27","2020-04-25 16:34:36","How to complete combineLatest?","<rxjs><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"61432196","1","61436756","","2020-04-25 20:29:58","","-1","35","<p>I need to run observer if after one second there is no result from forkJoin:</p>

<pre><code> of().pipe(delay(1000), skipUntil(!forkJoin$))
.subscribe(());
</code></pre>

<p>It does not work for me...</p>
","","user13406409","","user13406409","2020-04-25 20:50:43","2020-04-26 06:39:30","How to run observer if no result from forkJoin?","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61432825","1","","","2020-04-25 21:25:30","","0","51","<p>I have the following problem.</p>

<p>Given two files, <code>intents.ts</code> and <code>login.ts</code> where <code>intents.ts</code> contains among others</p>

<pre><code>export const loginUiEventsHandler =
    publish((uiEvents: Observable&lt;UiEvents&gt;) =&gt;
        merge(
            uiEvents.pipe(filter(e =&gt; e.type === 'EMAIL_LOGIN_CHANGE'), flatMap((e: EmailLoginChange) =&gt; validateEmailLogin(e.emailLogin))),
            uiEvents.pipe(filter(e =&gt; e.type === 'PASSWORD_CHANGE'), flatMap((e: PasswordChange) =&gt; validatePassword(e.password))),
            uiEvents.pipe(filter(e =&gt; e.type === 'LOGIN_CLICK'), flatMap((e: LoginClick) =&gt; login(e.emailLogin, e.password)))
        )
    )
</code></pre>

<p>and <code>login.js</code> contains among others</p>

<pre><code>events
    .pipe(loginUiEventsHandler)
    .subscribe(e =&gt; console.log(e))
</code></pre>

<p>When I try to import the function <code>loginUiEventsHandler</code> from <code>intents.ts</code> into <code>login.ts</code> using <code>import { loginUiEventsHandler } from './intents';</code> I get the error</p>

<p><code>TypeError: selector(...).subscribe is not a function</code></p>

<p>However, when I just copy paste the same function into <code>login.ts</code> everything seems to work fine.</p>

<p>What do I do wrong? How can I reuse an rxjs UnaryFunction across files.</p>

<p>Please excuse me if this question is obvious, I only just started out using typescript.</p>
","1937872","","","","","2020-04-25 21:37:24","Rx js - .subscribe is not a function when importing a UnaryFunction from different file","<javascript><typescript><rxjs><rxjs6>","0","2","","","","CC BY-SA 4.0"
"61439376","1","","","2020-04-26 10:43:42","","1","130","<p>I can now cache 1 to 2 http request at the same time in same component and recache it after the cache expired, but when I try to add 1 more publishReplay() in a service, when I navigate to other component and back, it freezed for seconds, before it goes back.</p>

<pre><code>getAllUsers(): Observable&lt;any&gt; {
if (this.reuse) {
  return this.reuse;
} else {
  return this.reuse = this.http.get(`${environment.url.userProfile}account-info`, this.userprofileKey()).pipe(
    publishReplay(1, 20000),
    refCount(),
    take(1)
  );
}
</code></pre>

<p>}</p>

<pre><code>enter getUserInterests(): Observable&lt;any&gt; {
if (this.reuse3) {
  return this.reuse3;
} else {
  return this.reuse3 = this.http.get(`${environment.url.userProfile}interest`, this.userprofileKey()).pipe(
    publishReplay(1, 20000),
    refCount(),
    take(1)
  );
}
</code></pre>

<p>}</p>

<pre><code>getEntitlementPlan(): Observable&lt;any&gt; {
if (this.reuse2) {
  return this.reuse2;
} else {
  return this.reuse2 = this.http.get(`${environment.url.entitlement}bau/subscription/current`, this.paymentKey()).pipe(
    publishReplay(1, 20000),
    refCount(),
    take(1)
  );
}
</code></pre>

<p>}</p>

<p>if I remove 1 publishReplay() from any from above. It works smoothly.</p>
","6027226","","","","","2020-04-26 10:43:42","Angular 8 - Cache HTTP Request using PublishReplay","<javascript><angular><rxjs><rxjs6>","0","5","","","","CC BY-SA 4.0"
"61441036","1","61441208","","2020-04-26 12:47:03","","0","21","<p>I have custom function:</p>

<pre><code>activate(seconds: number) {
   of(true)
      .pipe(delay(seconds))
      .subscribe(
        () =&gt; {
          console.log(""Run..."");

        },
        (error) =&gt; console.log(error)
      );
}
</code></pre>

<p>And I call this like:</p>

<pre><code>activate(4);
</code></pre>

<p>Why I get <code>console.log(""Run..."");</code> instantly, wihtout delay?</p>
","","user13406409","","","","2020-04-26 12:58:53","Delay is not working for obserber passing delay time?","<rxjs><rxjs5><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61446419","1","","","2020-04-26 19:00:17","","0","47","<p>My http service:</p>

<pre><code>@Injectable({
  providedIn: ""root"",
})
export class HttpService {
  public blocks$: Observable&lt;any&gt;;
  constructor(private http: HttpClient) {
    this.blocks$ = this.http
      .get(""URL"")
      .pipe(share());
  }
}
</code></pre>

<p>In the parent component, I subscribe to receive data:</p>

<pre><code> forkJoin([this.httpService.blocks$]).subscribe(() =&gt; {})
</code></pre>

<p>And after in child component is acync:</p>

<pre><code>*ngFor=""let block of httpService.blocks$  | async""
</code></pre>

<p>Why do I see two requests in network, why share() does not work?</p>

<p>Parent component has child component inside and activated by <code>*ngIf</code></p>
","","user13406409","","","","2020-04-26 19:00:17","Why share pipe sends two the same requests?","<angular><rxjs><angular8><rxjs6>","0","6","1","","","CC BY-SA 4.0"
"61467284","1","61487894","","2020-04-27 19:50:04","","2","52","<p>I have a stream of values</p>

<pre><code>[ 0.5, 0.3, 0.4, 0.6, 1.4, 0.3, 0.6 ]
</code></pre>

<p>and I want to turn this into</p>

<pre><code>[           1         2         1 ]
</code></pre>

<p>so, we're accumulating the values of the first stream till a whole number is reached (at least 1) and then emit the whole number while accumulating the remaining amount.</p>

<p>It completely boggles my mind and think a solution lies around the corner with switchMap. </p>
","393784","","393784","","2020-04-29 06:22:53","2020-04-30 08:03:30","RXJS bufferedAmount / accumulate value / reduce with reset","<typescript><rxjs><rxjs6>","2","0","1","","","CC BY-SA 4.0"
"61492443","1","61492526","","2020-04-29 00:53:41","","0","138","<p>I am using a route guard (or resolver, I have tried to use either but got the same error) where I want to get Observable as a return value:</p>

<pre><code>canActivate(): Observable&lt;boolean&gt; {
    return this.store.pipe(
      select(fromUserProfileState.getUserProfiles),
      tap((loaded: UserProfile[]) =&gt; {
        if (!loaded || loaded.length == 0) {
          this.store.dispatch(new fromUserProfileActions.LoadUPs());
        } else {
          return of(true);
        }
      }),
      filter((loaded: UserProfile[]) =&gt; loaded.length &gt; 0),
      first()
    );
  }
</code></pre>

<p>However, this doesn't return Observable, it returns Observable which is not acceptable. How can I tweak the rxjs (v 6.5.5) operators to return Observable only?</p>

<p><a href=""https://i.stack.imgur.com/b80Rt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/b80Rt.png"" alt=""enter image description here""></a></p>
","6741619","","","","","2020-04-29 01:45:21","Angular route guard/resolver - Type 'Observable<boolean | object[]>' is not assignable to type 'Observable<boolean>'","<angular><typescript><rxjs6><rxjs-pipeable-operators><rxjs-observables>","3","0","","","","CC BY-SA 4.0"
"61500538","1","61501281","","2020-04-29 11:17:21","","0","305","<p>I couldn't find any documentation related to this, so here it is. I have this usage of async pipe in a template:</p>

<pre><code>&lt;component [aliases]=""(users$ | async).profile.aliases$ | async""/&gt;
</code></pre>

<p>Is <code>aliases$</code> subscription correctly unsubscribed when <code>users$</code> emits? And what if there is an <code>*ngIf</code> on the wrapping element?</p>
","8836232","","","","","2020-04-29 11:57:15","Angular: are nested async pipe usage safe?","<angular><rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"61626612","1","","","2020-05-06 02:59:28","","0","341","<p>In Angular2+, How to make sure a HTTP request (or Observable) finish before it go to the next line.
<a href=""https://stackblitz.com/edit/angular-uvtfln"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-uvtfln</a></p>

<pre><code>export class AppComponent implements OnInit, AfterViewInit  {
  name = 'AngularX';
  systemPreference: any;

  constructor(private http: HttpClient){
  }

  ngOnInit(){
    console.log(""ngOnInit"");
    //get system preference, it is used in whole app,
    //it needs to be available so other component can use it.
    this.http.get(""https://data.hawaii.gov/api/views/usep-nua7/rows.json"").subscribe(res=&gt;{
      //How to make it is done before go to the next life circle event?
      this.systemPreference = res;
    })
  }

  ngAfterViewInit(){
    console.log(""ngAfterViewInit"");
    //the below got undefined, I expect the subscriber must be done at ngOnInit 
    //before reaching this function (ngAfterViewInit)
    console.log(this.systemPreference);
  }
}
</code></pre>
","3503844","","10959940","","2020-05-06 03:53:31","2020-05-06 03:53:31","Angular HTTP sync request in Life Cycle event","<angular><rxjs><observable><angular-httpclient><rxjs6>","1","3","","","","CC BY-SA 4.0"
"61638329","1","61638719","","2020-05-06 14:53:05","","0","397","<p>I'm using Rxjs, and I want to create an Observable from the following pattern (in order):</p>
<ol>
<li><p>get params from paramMap$, then ...</p>
</li>
<li><p>based on the value of params, get both (getData():Observable, getCategories():Observables) together, then ....</p>
</li>
<li><p>from ([data, categories]) create the final object.</p>
</li>
</ol>
<p>The code would look like:</p>
<pre><code>//route = this.ActivatedRoute

let obs$ = route.paramMap.pipe(

// combineLatest() is not a pipable operator, so it shouldn't be used inside .pipe()
// also it doesn't accept a function,
// but this just to show you what I want to do.

combineLatest(params=&gt;getData(params.id), params=&gt;getCategories(params.id)),

map(([data, categories])=&gt;{
//do some changes...
return {data,categories}
}
)
)

</code></pre>
<p>also where is the best place to put this code in Angular project:</p>
<ul>
<li><p><code>constructor()</code> is not the best practice, because this is a long-running operation (actually it has to do API requests)</p>
</li>
<li><p><code>ngOnInit()</code> is not recommended, because in some point I have to change <code>this.params</code> which is used in the template</p>
</li>
</ul>
<pre><code>...
combineLatest(params=&gt;
   getData(params.id).pipe(
        map(data=&gt;{
            this.params.type=data.type; 
            return data
           })), 
   params=&gt;getCategories(...) 
)
</code></pre>
<p>in template:</p>
<pre><code>&lt;div&gt;{{params.type}}&lt;/div&gt;
</code></pre>
","12577650","","13302","","2020-06-21 14:18:44","2020-06-21 14:18:44","Combine two observables inside pipe() chain","<angular><observable><rxjs6><rxjs-observables><combinelatest>","1","3","","","","CC BY-SA 4.0"
"61641434","1","","","2020-05-06 17:29:03","","0","37","<p>i have a little problem with this code : </p>

<pre><code>import { Injectable } from '@angular/core';
import { BehaviorSubject, Subject, merge } from 'rxjs';
import { scan, map } from 'rxjs/operators';
import { boatsList } from 'src/app/shared/mocks/boats.mock';
import { CatamaranModel } from 'src/app/shared/models/catamaran.model';
import { SailBoatModel } from 'src/app/shared/models/sail-boat.model';

@Injectable({
  providedIn: 'root'
})

export class BoatListService {

  private boatListInitSubject: BehaviorSubject&lt;(CatamaranModel|SailBoatModel)[]&gt; = new BehaviorSubject(boatsList);
  boatListInit$ = this.boatListInitSubject.asObservable();

  private addedBoatSubject: Subject&lt;(CatamaranModel|SailBoatModel)&gt; = new Subject();
  addedBoat$ = this.addedBoatSubject.asObservable();

  boatList$ = merge(
    this.boatListInit$,
    this.addedBoat$
  )
    .pipe(
      scan((acc: (CatamaranModel|SailBoatModel)[], value: CatamaranModel|SailBoatModel) =&gt; [...acc, value])
    );

  constructor() {
  }

  addBoat(boat: CatamaranModel | SailBoatModel){
    this.addedBoatSubject.next(boat);
  }
}
</code></pre>

<p>The problem is in my merge </p>

<pre><code> boatList$ = merge(
    this.boatListInit$,
    this.addedBoat$
  )
    .pipe(
      scan((acc: (CatamaranModel|SailBoatModel)[], value: CatamaranModel|SailBoatModel) =&gt; [...acc, value])
    );
</code></pre>

<p>I use this merge to had a new object to my collection but the object in the addedBoat$ is never added to the list and i don't know why.
When i do a map instead of the scan, i don't find the result of this.addedBoat$.</p>

<p>If i subscribe to this.addedBoat$ and i launch the addBoat function, i have the good object.</p>

<p>Do i make a bad use of the merge?</p>
","5266981","","","","","2020-05-20 19:19:08","merge observables don't get the value of the second observable","<angular><merge><observable><rxjs6>","2","5","","","","CC BY-SA 4.0"
"61660496","1","","","2020-05-07 14:35:03","","0","43","<p>i have a little problem, i subscribe to an observable 2 times.
On time i have the correct result but with my second subscribe, i always have the same result.
Here is my code : </p>

<pre><code>import { Injectable } from '@angular/core';
import { BehaviorSubject, Subject, merge, EMPTY, combineLatest, Observable, of } from 'rxjs';
import { scan, map, catchError, tap } from 'rxjs/operators';
import { boatsList } from 'src/app/shared/mocks/boats.mock';
import { CatamaranModel } from 'src/app/shared/models/catamaran.model';
import { SailBoatModel } from 'src/app/shared/models/sail-boat.model';

@Injectable({
  providedIn: 'root'
})

export class BoatListService {

  private boatListInitSubject: BehaviorSubject&lt;(CatamaranModel|SailBoatModel)[]&gt; = new BehaviorSubject(boatsList);
  boatListInit$ = this.boatListInitSubject.asObservable();

  private addedBoatSubject: Subject&lt;(CatamaranModel|SailBoatModel)&gt; = new Subject();
  addedBoat$ = this.addedBoatSubject.asObservable();

  boatList$: Observable&lt;(CatamaranModel|SailBoatModel)[]&gt; = merge(
    this.boatListInit$,
    this.addedBoat$
  )
    .pipe(
      scan((acc: (CatamaranModel|SailBoatModel)[], value: CatamaranModel|SailBoatModel) =&gt; [...acc, value]),
    );

  constructor() {
    this.addedBoat$.subscribe(data =&gt; console.log('DATA', data));
    this.boatList$.subscribe(data =&gt; console.log('DATA AFTER ADD', data));
  }

  addBoat(boat: CatamaranModel | SailBoatModel){
    this.addedBoatSubject.next(boat);
  }
}

</code></pre>

<p>In this code, the this.boatlist$.subscribe give me 5 objects in my array, which is good.</p>

<p>The addBoat is call like this : </p>

<pre><code> onSubmit(){
    if (this.addBoatForm.valid){
      this.boatListService.addBoat(
        new CatamaranModel(150, 150, 564, 15, false)
      );
      this.router.navigate(['/']);
      console.log('BATEAU AJOUTE');
    }
  }
</code></pre>

<p>But in this code : </p>

<pre><code>  constructor(
    private boatListService: BoatListService
  ) {
  }

  ngOnInit(): void {
    this.boatListService.boatList$.subscribe((data) =&gt; console.log('IN THE ADD COMPONENT', data));
  }
</code></pre>

<p>The subscribe is launching when it has to, but always send me the old value (the value used for the init).</p>

<p>I don't understand why i have two data for the same observable.</p>

<p>If someone has an idea...</p>
","5266981","","5266981","","2020-05-07 21:10:50","2020-05-11 15:59:15","Angular - multiple subscribe don't get the same answer","<angular><observable><rxjs6>","2","4","","","","CC BY-SA 4.0"
"61707376","1","","","2020-05-10 04:58:11","","1","399","<p>I have very simple code in my service class:</p>

<pre><code>userContext$ = this.http.post&lt;UserContext&gt;(this.userContextService, {}).pipe(
    shareReplay(1),
    tap((val: UserContext) =&gt; (this.userContext = val))
  );
</code></pre>

<p>This is called twice, first in Header and then in Body:</p>

<pre><code>changeDetection: ChangeDetectionStrategy.OnPush,
})
export class HeaderComponent{

  userContext$ = this.userContextService.userContext$;
</code></pre>

<p>2nd time:</p>

<pre><code>    export class PortfolioComponent {

  userContext$ = this.userContextService.userContext$;
</code></pre>

<p>But this doesn't seems to work, in my Network Tab I always have 2 calls, even if I do Console.log it's logged twice:</p>

<p><a href=""https://i.stack.imgur.com/gu389.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gu389.png"" alt=""enter image description here""></a></p>
","1032248","","3001761","","2020-05-28 22:03:22","2020-05-28 22:03:22","Why my Angular/Rxjs6.5 shareReplay(1) not working?","<angular><typescript><functional-programming><rxjs6><rxjs-observables>","1","10","","","","CC BY-SA 4.0"
"61761815","1","61761879","","2020-05-12 20:59:58","","1","34","<p>I'm using RXJS 6.5.4</p>

<p>In my typescript service I have:</p>

<pre><code>isAuthenticated(): Observable&lt;boolean&gt; {
   // request
}
currentUserPromise(): Promise&lt;User&gt; {
   // request the User model and return via Promise.
}
</code></pre>

<p>My second method, I need to verify if the session is authenticated, then request the current user and transform this to another Observable to resolve if the current user is an admin.</p>

<p>I'm trying this, but I'm getting errors:</p>

<pre><code>isAdmin(): Observable&lt;boolean&gt; {   
   this.isAuthenticated().pipe(map(authenticated =&gt; {
      if (authenticated) {   
          return from(this.currentUserPromise().then(user =&gt; user.roles.indexOf('ADMIN') &gt; -1)
      }
      return mapTo(false); // there is no authentication, so no current user and no admin!
   }));
}
</code></pre>

<p>And this is the compile error:</p>

<pre><code>Type 'Observable&lt;Observable&lt;boolean&gt;&gt;' is not assignable to type 'Observable&lt;boolean&gt;'.
   Type 'Observable&lt;boolean&gt;' is not assignable to type 'boolean'.ts(2322)
</code></pre>
","1470436","","","","","2020-05-12 21:09:00","Neasted RXJS Observables","<typescript><rxjs><observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61771578","1","61782146","","2020-05-13 09:57:55","","1","706","<p><strong>Note</strong> I have created a simplified version of this question at <a href=""https://stackoverflow.com/questions/61772610/template-binding-with-function-return-observable-and-async-pipe"">Template binding with function return Observable and async pipe</a></p>

<p>Template:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;div *ngIf=""entity?.ext.insuredDetails.insuredType$() | async as insuredType""&gt;
 {{insuredType}}
&lt;/div&gt;
</code></pre>

<p><code>insuredType$</code> definition:</p>

<pre class=""lang-js prettyprint-override""><code>@NeedsElement(sp(115621),ap(116215))
insuredType$(): Observable&lt;string&gt; {
  return empty();
}
</code></pre>

<p><code>NeedsElement</code> decorator:</p>

<pre class=""lang-js prettyprint-override""><code>export function NeedsElement(...mappings: NeedsElementMapping[]) {
  if (mappings.length === 0) {
    throw new Error('needs mapping expected');
  }

  let lookup = new Map&lt;ProductId, number&gt;();
  mappings.forEach((mapping) =&gt; {
    lookup.set(mapping.productId, mapping.elementId);
  });

  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; {
    descriptor.value = function (...args: any[]) {
      Logger.info(""bbbbb"");
      let entity = UcEntityStoreContext.currentEntity;
      let productId = entity['productId'];
      if (!productId) {
        throw new Error(`Cannot get product Id from host entity: ${entity.ucId}`);
      }
      let elementId: number = lookup.get(entity['productId']);
      if (!elementId) {
        throw new Error(`Cannot locate needs element ID by productId ${productId}`);
      };
      let enitityStore = UcEntityStoreContext.current;
      let entityApi = enitityStore.apiService as QuotePolicyApiBase&lt;any&gt;;
      let needsDefApi = NeedsDefinitionApi.instance;

      return needsDefApi.fetchOne(productId, elementId).pipe(
        concatMap(
          nd =&gt; {
            return entityApi.fetchNeedsElementValue(entity.ucId, elementId).pipe(
              concatMap(needsVal =&gt; {
                if (!needsVal) {
                  return of("""");
                }
                if (nd.lookupId) {
                  return LookupApi.instance.getByPrimaryValueId(nd.lookupId, needsVal).pipe(
                    map(res =&gt; res.primaryValue)
                  );
                } else {
                  return of(needsVal);
                }
              })
            )
          }
        )
      );
    };
  };
}
</code></pre>

<p>The problem is the the decorator is called multiple times:</p>

<p><a href=""https://i.stack.imgur.com/RBG9o.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RBG9o.png"" alt=""enter image description here""></a></p>

<p>And if it goes this branch:</p>

<p><a href=""https://i.stack.imgur.com/5UAjd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5UAjd.png"" alt=""enter image description here""></a></p>

<p>then it keep sending requests to the backend servcie and the binding never output anything:</p>

<p><a href=""https://i.stack.imgur.com/r8Nvq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/r8Nvq.png"" alt=""enter image description here""></a></p>

<p>It looks like it will always keep trying evaluate the observable without ending if it is an async obserable, say this one:
<a href=""https://i.stack.imgur.com/MfHUr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MfHUr.png"" alt=""enter image description here""></a></p>

<hr>

<p><strong>Updates 14/May/2020</strong></p>

<p>I got the answer from <a href=""https://stackoverflow.com/questions/61772610/template-binding-with-function-return-observable-and-async-pipe/61772828"">Template binding with function return Observable and async pipe</a></p>

<p>In the end I changed the Method Decorator to Property Decorator and issue fixed.</p>
","391227","","391227","","2020-05-13 22:14:57","2020-05-13 22:22:13","Angular template binding with Observable async pipe issue","<angular><rxjs><rxjs6><rxjs-observables>","2","0","1","2020-05-14 07:19:03","","CC BY-SA 4.0"
"61771781","1","","","2020-05-13 10:06:41","","2","81","<p>Suppose I have a list of items that is queried from an API depending on a parameter that can be changed in the UI. When changing the value of this parameter, I dispatch an action:</p>

<pre><code>this.store$.dispatch(new ChangeParameterAction(newParameterValue));
</code></pre>

<p>Now, on the receiving end, I want to trigger a new API call on every parameter change. I do this by subscribing to the store and then switching to the API observable. Then, I dispatch the result back into the store:</p>

<pre><code>/** Statement 1 **/
this.store$.select(selectParameter).pipe(
    switchMap(parameter =&gt; this.doApiCall$(parameter))
).subscribe(apiResult =&gt; {
    this.store$.dispatch(new ResultGotAction(apiResult))
});
</code></pre>

<p>My UI is receiving the items by subscribing to</p>

<pre><code>/** Statement 2 **/
this.store$.select(selectResults);
</code></pre>

<p>Now my question is: How can I join these two statements together so that we only have the subscription for Statement 1 for as long as the UI showing the results is active (and not destroyed)? I will always subscribe to the result of Statement 2, so Statement 1 will never be unsubscribed.</p>

<p>I've tried merging both observables and ignoring the elements for Statement 1, then subscribing tothe merged observables. But this looks like a very unreadable way for doing such a basic task. I think there must be a better way, but I can't find one. Hope you can help!</p>
","7247920","","7247920","","2020-05-13 13:11:29","2020-05-13 13:11:29","Unsubscribing from an observable when another observable is unsubscribed","<javascript><rxjs><ngrx><rxjs6>","1","6","","","","CC BY-SA 4.0"
"61772610","1","61772828","","2020-05-13 10:46:46","","1","1188","<p><strong>Note</strong> this is simplified question of <a href=""https://stackoverflow.com/questions/61771578/angular-template-binding-with-observable-async-pipe-issue"">Angular template binding with Observable async pipe issue</a></p>

<p>template:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;div&gt;{{foo()$ | async}}&lt;/div&gt;
</code></pre>

<p>source code:</p>

<pre class=""lang-js prettyprint-override""><code>import { Component } from ""@angular/core"";
import { BehaviorSubject, of, Observable } from ""rxjs"";
import { tap, delay, map, switchMap, concatMap } from ""rxjs/operators"";

@Component({
  selector: ""my-app"",
  templateUrl: ""./app.component.html"",
  styleUrls: [""./app.component.css""]
})
export class AppComponent {
  private index = 0;
  foo$(): Observable&lt;any&gt; {
    console.log(""aaa"")
    return of(""Delayed"");
  }
}
</code></pre>

<p>The above code works as expected:</p>

<p><a href=""https://i.stack.imgur.com/B8agY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B8agY.png"" alt=""enter image description here""></a></p>

<p>However if I added <code>.pipe(delay(1))</code> to the <code>foo$()</code>:</p>

<pre class=""lang-js prettyprint-override""><code>  foo$(): Observable&lt;any&gt; {
    return of(""Delayed"").pipe(delay(1));
  }
</code></pre>

<p>it won't work and keep ""aaa"" in the console log.</p>

<p>See <a href=""https://stackblitz.com/edit/angular-qbhkg3"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-qbhkg3</a></p>
","391227","","","","","2020-05-13 11:26:48","Template binding with function return Observable and async pipe","<angular><rxjs><rxjs6><rxjs-observables>","1","1","1","","","CC BY-SA 4.0"
"61811786","1","","","2020-05-15 04:29:01","","1","1534","<p>Here is my app.state.ts </p>

<pre><code>export interface AppState {
  getCards: Card[];
  getFlippedCards: Card[];
  currentPlayer: boolean;
  firstPlayerScore: number;
  secondPlayerScore: number;
  flipped: boolean;
  error: string;
}
export const initialState: AppState = {
  getCards: [],
  getFlippedCards: [],
  currentPlayer: false,
  firstPlayerScore: 0,
  secondPlayerScore: 0,
  flipped: false,
  error: '',
};
const appState = (State: AppState) =&gt; State;


export const getCards = createSelector(appState, (state) =&gt; state.getCards);
export const getFlippedCards = createSelector(
  appState,
  (state) =&gt; state.getFlippedCards
);
export const currentPlayer = createSelector(
  appState,
  (state) =&gt; state.currentPlayer
);
export const firstPlayerScore = createSelector(
  appState,
  (state) =&gt; state.firstPlayerScore
);
export const secondPlayerScore = createSelector(
  appState,
  (state) =&gt; state.secondPlayerScore
);
export const flipped = createSelector(appState, (state) =&gt; state.flipped);
export const error = createSelector(appState, (state) =&gt; state.error);
</code></pre>

<p>app.module.ts:</p>

<pre><code>imports: [
    BrowserModule,
    AppRoutingModule,
    StoreModule.forRoot({ AppReducer }),
  ],
</code></pre>

<p>app.reducer.ts</p>

<pre><code>export function AppReducer(state = initialState, action: AppActions): AppState {
  switch (action.type) {
    case ActionTypes.Load:
      return { ...state, getCards: action.payload };
    case ActionTypes.ToggleFlip:
....
</code></pre>

<p>app.actions.ts</p>

<pre><code>export enum ActionTypes {
  Load = 'Load Cards',
  ToggleFlip = 'Flip a Card',
}
export class ToggleFlip implements Action {
  readonly type = ActionTypes.ToggleFlip;
  constructor(public payload: Card) {}
}
export class Load implements Action {
  readonly type = ActionTypes.Load;
  constructor(public payload: Card[]) {
    console.log('load app.actions ', payload);
  }
}
export type AppActions = ToggleFlip | Load;
</code></pre>

<p>However, I cannot retrieve any information from the store, this.cards$ is undefined from the selector:</p>

<p>app.component.ts</p>

<pre><code>this.store.dispatch(new fromActions.Load(this.cards));
this.cards$ = this.store.pipe(select(fromState.getCards));
</code></pre>

<p>The store is being populated with the array just fine. So there is no problem there, I think my app.state.ts selectors are not set up properly (or maybe the part in app.module.ts). Where did I do wrong?</p>
","6741619","","","","","2020-05-15 04:48:16","Angular NgRx Selector returns undefined","<angular><rxjs><observable><ngrx><rxjs6>","1","0","","","","CC BY-SA 4.0"
"61861358","1","61880157","","2020-05-18 02:09:29","","0","174","<p>I am using ionic 5</p>

<p>when I try to connect to firebase using post and get the response data and process the response using <strong>pipe and tap</strong> then it's not working. The log is not printing. </p>

<p>But when I replace the pipe with subscribe then it's working correctly and I can see the log correctly. </p>

<p>Please see the working and not working code below.</p>

<p>Can someone please help me to solve this issue. Thanks for your help.</p>

<p><strong>WORKING CODE</strong></p>

<pre><code> return this.http.post(""https://project-name.firebaseio.com/offered-places.json"", {
    ...newPlace, 
    id: null
  }).subscribe(resDate =&gt; {
    console.log(resDate);
  });
</code></pre>

<p><strong>NOT WORKING CODE</strong></p>

<pre><code>return this.http.post(""https://project-name.firebaseio.com/offered-places.json"", {
    ...newPlace, 
    id: null
  }).pipe(
    tap(resData =&gt; {
      console.log(resData);
    })
  );
</code></pre>
","1848706","","","","","2020-05-18 22:35:14","Ionic rxjs pipe function not getting called after http post","<firebase><ionic-framework><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"61875792","1","61877200","","2020-05-18 17:48:01","","2","922","<p>Update Angular to 9th version and occurred on <code>startWith</code> function stay deprecated. The documentation linked to <code>AsyncScheduler</code> class, but how to use it in my simple case I can't figure out:</p>

<pre><code>private subscribeFilters(): void {
  this.filters.valueChanges
    .pipe(
      startWith(this.filters.value),
      pairwise(),
    )
    .subscribe(([prev, next]: [any, any]) =&gt; {
      if (JSON.stringify(prev) !== JSON.stringify(next)) {
        this.loadPage();
      }
    });
}
</code></pre>

<p>As you can see I'm using <code>startWith</code> for setting the filter initial state and exclude redundantly requests in the first time page load.</p>

<p>How I can implement the same logic without <code>startWith</code>. Perhaps as the documentation says with <code>AsyncScheduler</code> or another way?</p>
","7548062","","","","","2020-05-18 19:09:02","RxJS 6.5.5 startWith deprecated. Alternative","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"61880848","1","61881026","","2020-05-18 23:47:42","","0","242","<p>How does subscribe method work when http client requests data from endpoint?</p>

<p>Does it work as single request http? What if source in endpoint has new data, subscribe shows it after first call? </p>
","","user13406409","","","","2020-05-19 00:11:52","How does subscribe works for http request?","<angular><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"61884807","1","","","2020-05-19 06:45:45","","2","753","<p>I'm using RxJS <code>shareReplay()</code> operator on an observable (<code>courses$</code>) to share observable stream among other two observables (<code>beginnerCourses$</code> and <code>advancedCourses$</code>). It's working fine and single API call response is shared between both observables on success.</p>

<p>But, when it comes to error, these observable don't share error and error is seen to be thrown twice in the browser console. Doesn't <code>shareReplay()</code> operator shares error also? Is it an intended behavior?</p>

<pre class=""lang-js prettyprint-override""><code>const http$ = createHttpObservable('/api/courses');

const courses$ = http$
  .pipe(
    map(res =&gt; res['payload'] ),
    shareReplay(),
    catchError(err =&gt; {
      return throwError(err);
    })
  );

this.beginnerCourses$ = courses$
  .pipe(
    map(courses =&gt; courses
      .filter(course =&gt; course.category === 'BEGINNER')));

this.advancedCourses$ = courses$
  .pipe(
    map(courses =&gt; courses
      .filter(course =&gt; course.category === 'ADVANCED')));

}
</code></pre>
","6848923","","","","","2020-05-19 10:55:19","RxJS: Even if used `shareReplay()` on source observable, `throwError()` gets executed separately for each observable","<rxjs><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"61888899","1","","","2020-05-19 10:33:11","","1","555","<p>I am building an application using RxJS and one of the interesting problems I have come across is how I can implement an operator that will catch errors only when they are unhandled by the rest of the pipeline ahead of it. I'll call my operator <code>catchUnhandledError</code> for now.</p>

<p>The <code>catchError</code> operator is loosely similar (non stream) to</p>

<pre><code>try {
    // stream  
} catch (err) {
    // catchError handler
    // new stream
}
</code></pre>

<p>What I am trying to implement resembles the following</p>

<pre><code>try {
    // stream
} catch (err) {
    try {
        // original stream
    } catch (err2) {
        // catchUnhandledError handler
        // new stream
    }
}
</code></pre>

<p>The key takeaway here is that the new operator only catches errors that other operators do not catch further down the pipeline.</p>

<p>I appreciate that piped operators essentially wrap observables similar to how middleware works in popular application pipelines which means ""pushing the pipe to the end"" is nonsensical.</p>

<p>My stream (simplified) is created as follows.</p>

<pre><code>combineLatest([ page, filter ]).pipe(
    switchMap(([ page, { search, order }]) =&gt;
        apiQuery(search, order, page).pipe(
            map(/* combine response with filters */),
            catchError(/* ONLY handle http status 422 Unprocessable Entity for validation */),
            catchError(/* ONLY handle http status 409 Conflict for version conflicts *)
        )
    )
);
</code></pre>

<p>Where api.query returns:</p>

<pre><code>function errorHandler(errorMessage?: string) {
    return &lt;T&gt;(source: Observable&lt;T&gt;): Observable&lt;T&gt; =&gt; 
        source.pipe(
            /* replace with new catchUnhandledError operator */
            catchError(() =&gt; {
                /* More complex code than this to log the error */
                alert('unhandled error');

                return EMPTY;
            })  
        );
}

function apiQuery(search: string, order: string, page: number) {
    /* uses parameters to generate ajax payload */
    return ajax({
        url: 'url', 
        method: 'GET'
    }).pipe(
        map(r =&gt; r.response as T),
        errorHandler('An error message')
    );
}
</code></pre>

<p>The problem is the validation / request specific error handlers never get called because the generic <code>errorHandler</code> takes precedence. A couple of work arounds I will have to use if this is not possible:</p>

<ul>
<li>Pass everything in the pipe as a parameter / callback (convoluted)</li>
<li>Map success and errors to a single object then check <code>.success</code> (convoluted)</li>
<li>Copy and paste the generic <code>errorHandler</code> to every single place I call my api (duplicated)</li>
</ul>

<p>Does anyone have any ideas that will prevent me from having to have convoluted or duplicated code?</p>
","5973519","","5973519","","2020-05-19 10:40:03","2020-05-19 11:50:42","How can I catch an RxJS error only if it is unhandled","<javascript><rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"61990267","1","61991980","","2020-05-24 18:10:52","","1","36","<p>Im looking a way to simplify this and avoid managing subscriptions inside my pipe.</p>

<p>The general idea abought my code:</p>

<pre class=""lang-js prettyprint-override""><code>this.start$ubject // waiting for users call to start
  .pipe(
    mergeMap(() =&gt; from(this.thirdPartyService.start())), // now i need to wait for smth to start
    tap(() =&gt; {
      // only after thirdPartyService started i can subscribe because prior to that they are undefined
      this.subscriptions.push(
        this.thirdPartyService.alfa$.subscribe(this.first$ubject),
        this.thirdPartyService.beta$.subscribe(this.second$ubject),
      );
    }),
  );
</code></pre>

<p>Is there any way to deal with that? Something like <code>takeWhile</code> but for subscription?</p>
","6950901","","6950901","","2020-05-25 11:14:14","2020-05-25 11:36:43","Managing subscriptions based on async event","<asynchronous><rxjs><rxjs5><rxjs6>","1","3","","","","CC BY-SA 4.0"
"61998602","1","61999727","","2020-05-25 08:30:05","","1","1192","<p>I have a scenario like i need to fetch file content when click on a file.
I want to cache the file content API with shareReplay(), how can i achieve it?</p>

<p>fileService.getContent is an API service which will fetch content with params(repository_id, filePath);</p>

<p>Question:</p>

<ul>
<li>Where should i use the shareReplay() pipe? Inside API service? or the place i wrote below.</li>
<li><strong>Below code does not work as expected.</strong> The API will be triggered multi-times. How can i cache the API with shareReplay() to call only once.</li>
</ul>

<p><strong>Component</strong></p>

<p>`</p>

<pre><code>fileOpened$ = new Subject();
...

this.fileOpened$.pipe(
    switchMap(file =&gt; this.fileService.getContent(this.repository_id, file.filePath)),
    shareReplay(1)
);
</code></pre>

<p>`</p>

<p><strong>service</strong>:</p>

<p>`</p>

<pre><code>getContent(repoId: string, path: string): Observable&lt;string&gt; {
    return this.http.get&lt;string&gt;(
        `/api/xxx/${repoId}/files/${decodeURIComponent(path)}`,
        {
            responseType: 'text' as 'json'
        });
}
</code></pre>

<p>`</p>
","3943632","","3943632","","2020-05-25 11:43:55","2020-05-25 11:43:55","How to use shareReplay for cache HTTP response with request params","<angular><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"62018625","1","62019179","","2020-05-26 09:16:12","","1","185","<p>I'm having trouble with the return error in my retry sentence:</p>

<p>What I want to do is retry and httpRequest 10 times before considering it wrong, if it fails the 10 times, then throw the error to be caught by ErrorHandler:</p>

<pre><code>private handleError(error, req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;any&gt; {

  if (error.status === 0) {
    return next.handle(req).pipe(
      retryWhen(errors =&gt; errors.pipe(delay(1000), take(10), concatMap(throwError(errors)))));

  }
}
</code></pre>

<p>If I remove the concatMap it works, but with this, I'm not able to make it works. How can I solve it?</p>
","5212118","","12641190","","2020-05-26 09:50:19","2020-05-26 09:50:19","how to throw an error after retrying rxjs 6","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"62025167","1","","","2020-05-26 15:01:32","","0","33","<p>I am writing a log service, in the log service have several log info. if I fetch IP address, it will fetch IP address after some delay, IP address as undefined in the error object.because </p>

<pre><code> logError(response: any): any {

      let errors:any;
      console.log(response, ""log service error"");
      this.getIP();

      error = {
        ExceptionMessage: response.message,
        ipaddress: this.getIP(),//  is undefined

        htmlDOM: document.getElementsByTagName(""body"")
        screenShot:another service call,
      }

      console.log(error, 'logged');
      return error;
 }

 getIP() {
   this.getIPAddress().subscribe((res: any) =&gt; {
      //getting ipaddress
      return res.ip;
   });
 }

 getIPAddress() {
   return this.httpClient.get(""http://api.ipify.org/?format=json"");
 }

 getScreen() {}
</code></pre>

<p>O.p: currently it works by using this set timeout solution.Better solution appreciated.</p>

<p>Tried with async and await but it did not work,</p>

<pre><code> logError(response: any): any {

       setTimeout(()=&gt;{

          let errors:any;
          console.log(response, ""log service error"");
          this.getIP();
          error = {
            ExceptionMessage: response.message,
            ipaddress: this.getIP(),//  is undefined

            htmlDOM: document.getElementsByTagName(""body"")
            screenShot:another service call,
          }

          console.log(error, 'logged');
           return error;
         },7000);

         return error;
}
</code></pre>
","4031891","","6072233","","2020-05-26 16:15:29","2020-05-26 16:15:29","asynchronous execution issue while fetching ip address in angular service call","<angular><typescript><rxjs><rxjs6><rxjs-observables>","0","4","","2020-05-26 15:07:24","","CC BY-SA 4.0"
"62067277","1","62067543","","2020-05-28 14:30:20","","0","39","<p>I have a component somewhat like the pseudo-code snippet at the bottom.</p>

<p>I need to amend <code>onDeployForTesting()</code> so that it calls <code>myService.save()</code> before calling <code>myService.deployForTesting()</code>. I have been looking into nested Observables and nested calls to <code>httpClient</code> but I can never tell which Observable failed (if one does). I need to know this so that I can continue to set notifications.</p>

<h2>Question</h2>

<p>How do I nest two (or more) <code>httpClient</code> requests, and see which one in the chain failed (in an RxJS way)?</p>

<h2>What I have tried</h2>

<pre><code>onSaveAndDeployForTesting() {
    this.myService
        .save(arg1)
        .pipe(
            concatMap(  // also tried: switchMap, mergeMap
                () =&gt; this.myService.deployForTesting(arg2),
            ),
        )
        .subscribe(
            console.info,
            console.error,  // this gives a very generic error with no pointer to which Observable actually failed
            console.info,
        );
}
</code></pre>

<h2>Existing code</h2>

<pre><code>class MyClass {
    // other code

    onSave() {
        this.myService.save(arg1)
            .subscribe(
                (data) =&gt; {
                    this.notificationService.set({
                        type: NotificationType.SUCCESS,
                        title: 'Success',
                        description: 'Lorem ipsum dolor sit amet',
                    });
                },
                (err) =&gt; {
                    if (err.errorCode === 409) {
                        this.notificationService.set({
                            type: NotificationType.WARNING,
                            title: 'Save Conflict',
                            description: 'Lorem ipsum dolor sit amet',
                        });
                    } else {
                        this.notificationService.set({
                            type: NotificationType.ERROR,
                            title: 'Error',
                            description: 'Lorem ipsum dolor sit amet',
                        });
                    }
                },
            );
    }

    onDeployForTesting(arg1) {
        this.myService.deployForTesting(arg1)
            .subscribe(
                (data) =&gt; {
                    if (data.status === 207) {
                        this.notificationService.set({
                            type: NotificationType.WARNING,
                            title: 'Unable to deploy configuration',
                            description: 'Lorem ipsum dolor sit amet',
                        });
                    } else {
                        this.notificationService.set({
                            type: NotificationType.SUCCESS,
                            title: 'Success',
                            description: 'Lorem ipsum dolor sit amet',
                        });
                    }
                },
                (err) =&gt; {
                    this.notificationService.set({
                        type: NotificationType.ERROR,
                        title: 'Error',
                        description: 'Lorem ipsum dolor sit amet',
                    });
                },
            );
    }
}

class MyService {
    // other code

    save(data) {
        return this.http.put('/my/save/url', data);
    }

    deployForTesting(data) {
        return this.http.post('/my/deploy/url', data);
    }
}
</code></pre>
","633056","","","","","2020-05-28 14:42:47","Nest httpClient calls and tell which one failed?","<angular><rxjs><angular7><rxjs6>","1","0","","","","CC BY-SA 4.0"
"62083596","1","62083885","","2020-05-29 10:12:13","","0","98","<p>I'm building a small function that will refresh the access token after a specific time (base on calculation).</p>

<pre><code>public buildRefreshTokenTimerAsync(): Observable&lt;LoginResultViewModel&gt; {

        let accessToken = '';
        let refreshToken = '';
        let lastRefreshTokenTime: number;
        let issuedTokenTime: number;
        let accessTokenLifeTime = ACCESS_TOKEN_LIFE_TIME;
        let user: ProfileViewModel;
        let retriedTime = 0;

        // Load the last time the application refresh the access token.
        const loadLastRefreshTokenTimeObservable = this.storageMap
            .get&lt;number&gt;(LocalStorageKeyConstant.lastRefreshTokenAt)
            .pipe(
                tap((time: number) =&gt; {
                    lastRefreshTokenTime = time;
                })
            );

        // Load login result from storage map observable.
        const loadLoginResultObservable = this.storageMap
            .get&lt;LoginResultViewModel&gt;(LocalStorageKeyConstant.loginResult)
            .pipe(
                tap((loginResult: LoginResultViewModel) =&gt; {
                    if (!loginResult || !loginResult.accessToken || !loginResult.accessToken.trim()) {
                        throw new Error(ExceptionCodeConstant.accessTokenNotFound);
                    }

                    if (!loginResult.refreshToken || !loginResult.refreshToken.trim()) {
                        throw new Error(ExceptionCodeConstant.refreshTokenNotFound);
                    }

                    accessToken = loginResult.accessToken;
                    refreshToken = loginResult.refreshToken;
                    issuedTokenTime = loginResult.issuedAt;
                    accessTokenLifeTime = loginResult.lifeTime;
                    user = loginResult.user;
                })
            );

        return of(null)
            .pipe(
                flatMap(_ =&gt; {
                    return forkJoin([
                        loadLastRefreshTokenTimeObservable,
                        loadLoginResultObservable]);
                }),
                flatMap(() =&gt; {

                    // Get the current time in the system.
                    const currentTime = new Date().getTime();

                    // Calculate the time to refresh the access token.
                    const timeToRefreshToken = this.calculateAccessTokenRefreshTime(issuedTokenTime, ACCESS_TOKEN_LIFE_TIME);

                    // Access token hasn't been refreshed before.
                    if (lastRefreshTokenTime === undefined || lastRefreshTokenTime === null) {

                        // Refresh time was in the past. Refresh the token now.
                        if (currentTime &gt;= timeToRefreshToken) {
                            return timer(0);
                        }
                    }

                    // Access token has refreshed before, however, another thread is handling the operation.
                    // Retry after the specific time.
                    if (currentTime - lastRefreshTokenTime &lt; REFRESH_TIME_GAP) {
                        throw new Error(ExceptionCodeConstant.accessTokenIsRefreshing);
                    }

                    // Refresh time is in the future.
                    if (currentTime &lt; timeToRefreshToken) {
                        const delayTime = timeToRefreshToken - currentTime;
                        return timer(delayTime);
                    }

                    return timer(0);
                }),
                flatMap(_ =&gt; this.loadRefreshTokenAsync(refreshToken)),
                flatMap((loginResult: LoginResultViewModel) =&gt; {
                    loginResult.user = user;
                    return this.storageMap
                        .set(LocalStorageKeyConstant.loginResult, loginResult)
                        .pipe(
                            flatMap(_ =&gt; {
                                return this.storageMap.set(LocalStorageKeyConstant.lastRefreshTokenAt, new Date().getTime());
                            }),
                            map(() =&gt; {
                                return loginResult;
                            })
                        );
                }),
                retryWhen(errors =&gt; {
                    return errors
                        .pipe(
                            flatMap(error =&gt; {
                                retriedTime++;
                                if (retriedTime &gt; 2) {
                                    throw error;
                                }

                                if (!(error instanceof Error)) {
                                    return throwError(error);
                                }

                                if (ExceptionCodeConstant.accessTokenIsRefreshing === (error as Error).message) {
                                    return timer(2000);
                                }

                                return throwError(error);
                            })
                        );
                })
            );
    }
</code></pre>

<p>What I expect is when <code>ACCESS_TOKEN_IS_REFRESHING</code> exception is thrown, the function will retry after 2 seconds. </p>

<p>If I use <code>retry</code> instead of <code>retryWhen</code>, the function is OK, but when I changed to <code>retryWhen</code> and return a <code>timer</code>, function does not retry after 2 second.</p>

<p>Am I doing anything wrong ?</p>
","3301076","","","","","2020-05-29 11:43:42","rxjs6: RetryWhen not work when returning timer","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"62109984","1","","","2020-05-30 23:43:38","","0","418","<p>I have a child component that selects a file with a 2 way data binding called file$ so the parent can receive the selected file.</p>

<p>The parent needs to receive the file when it is emitted, but the child also needs to display the file name in the template.</p>

<p>For some reason the file name is not being displayed in the child's html template. Why is this? I have subscribed to the file$ event emitter and console logged the emitted value which is indeed a file.</p>

<p>in child component .ts:</p>

<pre><code>@Output() public file$ = new EventEmitter&lt;any&gt;(true);

private setDocument(uploadedFile: File): void {
    if (this.isFilesizeValid &amp;&amp; this.isFileExtensionValid) {
        this.file$.emit(uploadedFile);
        this.isFileValidAndUploaded = true;
    }
}
</code></pre>

<p>in child component .html:</p>

<p><code>&lt;h4 class=""cb-padding-bottom""&gt;{{file$.name | async}}&lt;/h4&gt;</code></p>

<p>In parent file .html:</p>

<pre><code>      &lt;cb-drag-and-drop-file fxFlex
                             [allowedFileTypes]=""[FILE_TYPE_ENUM.Xlsx]""
                             [(file$)]=""file""&gt;
      &lt;/cb-drag-and-drop-file&gt;
</code></pre>

<p>In parent file .ts:</p>

<pre><code>public file;
</code></pre>
","3935156","","","","","2020-05-31 03:42:50","Display event emitter value in html template with async pipe","<angular><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"62110547","1","","","2020-05-31 01:28:31","","0","1234","<p>I'm trying to do a two way data binding so that a property (<code>file</code>) in the parent can be updated by the child, whenever the child changes it.</p>

<p>The value in the parent is only ever undefined. What am I doing wrong?</p>

<p>In the child component (<code>&lt;cb-drag-and-drop-file&gt;</code>):</p>

<pre><code>@Output() public fileChange = new EventEmitter&lt;File&gt;();
private fileValue: File;

@Input()
get file() {
    return this.fileValue;
}

set file(value) {
    this.fileValue = value;
}

private setDocument(uploadedFile: File): void {
    if (this.isFilesizeValid &amp;&amp; this.isFileExtensionValid) {
        this.file = uploadedFile;
        this.fileChange.emit(uploadedFile);
        this.isFileValidAndUploaded = true;
    }
}

private clearOldFileReference(): void {
    this.file = undefined;
    this.fileChange.emit(undefined);
}
</code></pre>

<p>In the parent component ts file:</p>

<pre><code>file;
ngOnInit() {
   interval(1000).pipe(mapTo(this.file), tap(x =&gt; console.log(x))).subscribe(console.log);
}
</code></pre>

<p>In the parent component html file:</p>

<pre><code>&lt;cb-drag-and-drop-file fxFlex
                       [allowedFileTypes]=""[FILE_TYPE_ENUM.Xlsx]""
                       [(file)]=""file""
                       description=""faslkdfjlsdkjf""&gt;
&lt;/cb-drag-and-drop-file&gt;
</code></pre>

<p>Surely I don't have to imperatively set file in the parent, that doesn't seem reactive which is what I thought Angular was going for with the event emitter? It would also mean I can't use banana box syntax wouldn't it? I've added <code>fileChange</code> to the parent and it is never fired when I use banana box syntax.</p>
","3935156","","","","","2020-05-31 07:42:24","Angular two way data binding with banana box syntax not working","<angular><rxjs><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"62127303","1","","","2020-06-01 07:14:37","","0","104","<p>I have a behavior subject boolean and it is assigned to an observable. I'm using this observable in a combineLatest. In Chrome and other browsers (Except Firefox and IE) this combine latest is triggering whenever the behavior subject value is changed. In Firefox and IE alone this is intermittently working.</p>
","13284115","","","","","2020-06-01 09:45:39","combine latest is not triggering properly in Firefox and IE","<javascript><rxjs><observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"62141474","1","","","2020-06-01 21:45:40","","0","105","<p>I am trying to use a conditional rxjs operator. I am checking if the data is stored in the <code>local storage</code>, return that, if not, make 2 HTTP calls to get the required data and return it.</p>

<p>Here's my code:</p>

<pre><code>// making nested API calls
    loggedInUserDetails$ = this._getPoid().pipe(
      concatMap((userData: any) =&gt; this._userData(userData)),
      map((userDetails: any) =&gt; userDetails.legalName.nameLastFirst),
      tap((user: string) =&gt; this._storage.saveUserInStorage(user)),
      catchError(() =&gt; of('some dummy name')),
   );

  storedUserData$ = of(this._storage.getUserFromStorage());

  loggedInUsername$ = of(this._storage.getUserFromStorage()).pipe(
    mergeMap((username: string) =&gt;
      iif(
        () =&gt; Boolean(username),
        this.storedUserData$,
        this.loggedInUserDetails$,
      ),
    ),
    tap(console.log),
  ); 


 loggedInUsername$.subscribe(data =&gt; console.log(data)); 
</code></pre>

<p><strong>The above code returns Maximum call stack size exceeded</strong></p>

<blockquote>
  <p>Observable.js:54 RangeError: Maximum call stack size exceeded
      at MergeMapSubscriber.push../node_modules/rxjs/_esm5/internal/OuterSubscriber.js.OuterSubscriber.notifyError
  (OuterSubscriber.js:12)
      at InnerSubscriber.push../node_modules/rxjs/_esm5/internal/InnerSubscriber.js.InnerSubscriber._error (InnerSubscriber.js:18)
      at InnerSubscriber.push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.error
  (Subscriber.js:59)
      at TapSubscriber.push../node_modules/rxjs/_esm5/internal/operators/tap.js.TapSubscriber._error
  (tap.js:61)
      at TapSubscriber.push../node_modules/rxjs/_esm5/internal/Subscriber.js.Subscriber.error
  (Subscriber.js:59)
      at </p>
</blockquote>
","5924007","","","","","2020-06-01 22:01:56","Making nested API calls using RxJS based on a condition using iif operator resulting in Maximum call stack size exceeded","<angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"62141648","1","62141649","","2020-06-01 21:59:48","","4","5457","<p>A very common problem when using RxJs seems to be to want the result of one or more observables to then use them in subsequent ones.</p>

<p>e.g. in pseudo-code (This is not rx or valid js syntax deliberately)</p>

<pre><code>var someResult = $observable-A; // wait to complete
var finalResult = $observable-B(someResult.aValueINeed);
</code></pre>

<p>This can be done in an ugly way where you could subscribe to both and call one inside the other.. however, this is very messy and doesn't afford you much flexibility.</p>

<p>e.g. (real syntax)</p>

<pre><code>$observable-A.subscribe(resultA =&gt; { 
    $observable-B(resultA.aValueINeed)
        .subscribe(resultB =&gt; { 
            console.log('After everything completes: ', resultB); 
        }
}
</code></pre>

<p>This also means that nothing else can easily consume this stream as you're completing both of the observables.</p>

<p>My specific use case requires the following:</p>

<ol>
<li>An initial call to get $observable-A as it doesn't require anything else (it's a basic http GET call)</li>
<li>An http GET call to another service that requires data from $observable-A, which returns $observable-B</li>
<li>Using both observable results (A + B) to create an object for my service (In my case, an Angular service) to return a single list.</li>
</ol>

<blockquote>
  <p>I also need to be able to subscribe to this function inside my service, this is why going with the subscribe method above, won't work for me.</p>
</blockquote>
","8974088","","","","","2020-06-01 21:59:48","RXJS How do I use the result of one observable in another (and then process those two results together)","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"62157529","1","62197074","","2020-06-02 17:12:42","","0","97","<p><strong>Scenario:</strong> I am using publishReplay to cache and replay certain Http requests within an Angular application (using publishReplay over shareReplay due to some bugs that have since been fixed in rxjs).</p>

<p>My problem is that I want to force the cached observable source to update itself and create a new cached observable with publishReplay if I detect a URL parameter change. I thought perhaps this could be accomplished by interrogating/comparing the newly proposed observable with the existing cached observable's source, but I have been unsuccessful in achieving this.</p>

<p><strong>What I am looking for:</strong>  A way to either interrogate an observable's source so I can compare it to the source of another observable to see if they are identical (url in this case), or some other means of detecting the url on an Http Observable changed with publishReplay. Furthermore I am attempting to abstract this logic away into a caching mechanism so I don't have to sprinkle code throughout the apps that detects if the parameter changes.</p>

<p>Here is a very naive example of what I'd like to do that isn't working, the input source parameter is the new Observable which contains a handle to an http request, and the origSource is the previous observable which contains the same (though potentially with a different url parameter that publishReplay doesn't seem to acknowledge). </p>

<pre><code>  // determine if key exists and source is un-modified (i.e params did not change)
protected isEntreeValid&lt;T&gt;(key: ICacheKeyConstantsModel, source: Observable&lt;T&gt;): boolean {
    if (!this.has(key)) { return false; }
    if (this.has(key)) {
        let origSource = this.cache.registry.get(key).source; // observable previously cached used to resubscribe to later and returned cached publishReplay response, or can be tickled to make the original http request again effectively busting the cache.
        console.log('source: ', source);
        console.log('are they equal', source.source === origSource.source); //always returns false but assume need to check some inner value of observable anyways and do a fuzzy comparison.
        if (source.source !== origSource.source) { return false; }
    }

    return true;
}
</code></pre>

<p><strong>Above Method:</strong> The input 'source' param in above method is just a pointer to an http.get method and stored in a Map in key/value pair fashion: 
i.e. Map 
so that we can marshal their caching state and other attributes in a centralized way more easily. Basically it is here that if a 'key' already exists I'd like to evaluate 'source' to see if parameters on the URL changed so if they have we can bust the cache, alternatively if they haven't we'll just return the publishReplay result.</p>

<p><strong>Note:</strong> I do not intend/want to connect to the Observable in this case, I am interested only in comparing the source of these Observables, not the potential streams they will emit.</p>

<p><strong>Update:</strong> Found what I was looking for, though not sure why it is WAAAY down there. Is there a slick way of iterating down to this, seems consistent structurally with Observables and not an artifact of something weird I did when creating these ones. Seems odd indeed that this very basic info would be so far down in there (note url has been obfuscated and this example didn't have params):</p>

<p><strong>Property location is:</strong> Observable.value.source.source.source.source.source</p>

<p><strong>Structure of object at this location is:</strong></p>

<p>{</p>

<pre><code>value: HttpRequest

body: null

headers: HttpHeaders {normalizedNames: Map(0), lazyUpdate: null, headers: Map(0)}

method: ""GET""

params: HttpParams {updates: null, cloneFrom: null, encoder: HttpUrlEncodingCodec, map: Map(0)}

reportProgress: false

responseType: ""json""

url: ""https://my-dev-server.com/primary/HealthCareApp/Patients""

urlWithParams: ""https://my-dev-server.com/primary/HealthCareApp/Patients""

}
</code></pre>

<p><strong>Question:</strong> Any clean/reliably ways to flatten, or drill-down to the inner most Observable without subscribing?</p>

<p><strong>Update 2:</strong></p>

<p>For now I'm using a method like the one below to extract the innerObservable, there are probably better ways but here's what we're rocking with for the time being: </p>

<pre><code>// retrieve inner meta-data from cold observable for interrogation without subscribing
private extractInnerObservable&lt;T&gt;(source: Observable&lt;T&gt;): Observable&lt;T&gt; {
    let target = observableOf(source)['value'];
    while (target['source']) {
        target = target['source'];
    }

    return target;
}
</code></pre>

<p><strong>Resulting Method:</strong></p>

<p><a href=""https://i.stack.imgur.com/0TsGE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0TsGE.png"" alt=""enter image description here""></a></p>

<p>Conclusion: Still open to exploring other options for sure, but I’ve updated this question multiple times to share where I’m at as am at least in a state now where it addresses the original problem (though certainly not in the most elegant fashion). However Incase someone else is struggling with something similar thought there would be value in sharing the result of where some of this madness ended up.</p>
","8657553","","8657553","","2020-06-05 03:36:57","2020-06-05 03:36:57","How to compare two cold Observable's sources (not the potential streams they emit)","<angular><typescript><rxjs6>","1","7","1","","","CC BY-SA 4.0"
"62174622","1","62175049","","2020-06-03 13:53:56","","1","348","<p>I am using rxjs to build a searching and filtering system in an angular App.</p>

<p>I have the following:</p>

<pre><code>interface User{ //exmaple model
 _id: string;
 name: string;
}

filters$ = new BehaviorSubject&lt;Array&lt;User&gt;&gt;([]);
search$ = new BehaviorSubject&lt;Array&lt;User&gt;&gt;([]);

// I use these two and merge them in another function as following

const myData$ = merge(this.search$.asObservable(), this.filters$.asObservable())
.pipe(distinctUntilChanged(distinctCheck))

</code></pre>

<p>With the utility function <code>distinctCheck</code> being something like:</p>

<pre><code>const distinctKey = (elem) =&gt; {
    if(elem === null){
      return elem
    }
    if(this.hasId(elem)){
      return elem[""_id""];
    }
    if(this.hasName(elem)){
      return elem[""name""]
    }
    return this.createComparisonString(elem)
  }
</code></pre>

<p>But this biges me either one or the other observable. So my question is:</p>

<p>How can I merge the two observables and emit only the values that are common to both arrays? Where sometimes filters$ might emit an array of 30 elements. And sometimes search$ might emit an array of only 2 elements?</p>

<p>I.E:</p>

<p>if <code>filter$</code> contains:</p>

<pre><code>[{_id:'1', name:'jhon'},{_id:'2', name:'doe'},{_id:'3', name:'jolly'},{_id:'4', name:'some random dude'},{_id:'5', name:'some random other dude'},{_id:'6', name:'johny'},{_id:'7', name:'bravo'}]

</code></pre>

<p>and <code>search$</code> contains:</p>

<pre><code>[{_id:'1', name:'jhon'},{_id:'101', name:'myDoe'},{_id:'301', name:'some-jolly'},{_id:'4', name:'some random dude'}, {_id:'7', name:'bravo'}]

</code></pre>

<p>I would like <code>myData$</code> to emit something like:</p>

<pre><code>[{_id:'1', name:'jhon'},{_id:'4', name:'some random dude'}, {_id:'7', name:'bravo'}]
</code></pre>

<p>Thank you all! :)</p>
","3620691","","3620691","","2020-06-03 14:13:02","2020-06-03 14:15:14","RxJs merging two observables uniquely","<angular><typescript><rxjs><rxjs6>","3","0","","","","CC BY-SA 4.0"
"62180284","1","","","2020-06-03 18:37:26","","0","137","<p>I'm using an rxjs observable to model a sequence of steps that occurs in my app.</p>

<p>Pseudocode</p>

<pre><code>const steps = [{id: ""step1""}, {id: ""step2""}, {id: ""step3""}]

//... then at some point later do things based on the steps
from(steps).pipe(
    concatMap((step) =&gt; {
        ... do stuff with each step, perhaps including needing to go back to previous step
    })
)
</code></pre>

<p>Given this pattern how might I model ""going back"" if some condition makes it necessary?</p>

<p>For example going from step1 -> step2 -> step3 -> step2 -> step3</p>

<p>From what I can tell rxjs seems to be pretty strictly one-way-linear. I haven't found a way to set the position/index of an observable (if that's the right way to conceptualize it).</p>

<p>Apologies if I'm missing something obvious but it seems like this could be a fairly common use case for observables created from arrays.</p>
","1294382","","","","","2020-06-04 15:24:27","How to set current index of or move backwards though an rxjs observable?","<rxjs><rxjs6><rxjs-pipeable-operators><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"62182616","1","62182914","","2020-06-03 20:59:11","","0","46","<p>Upon clicking a button, I want to switch to my file$ observable, check that it is populated, and use it to upload the file inside <code>uploadRates(file, date)</code>.</p>

<pre><code>const click$ = Observable.fromEvent(this.uploadButton.nativeElement, 'click').pipe(
    switchMapTo(this.file$),
    filter(file =&gt; !!file &amp;&amp; !!this.dateForRates),
    tap(_ =&gt; this.isLoading$.next(true)),
    exhaustMap(file =&gt; this.uploadRates(file, this.dateForRates))
).subscribe({
    next: x =&gt; {
        this.handleUploadRatesResult(x);
        this.isLoading$.next(false);
    },
    complete: () =&gt; {
        console.log('complete');
        this.isLoading$.next(false);
    },
    error: err =&gt; {
        console.log(err);
        this.isLoading$.next(false);
    }
});
</code></pre>

<p>It works, but I just don't want any of that pipe to re-run when i do something like <code>this.file$.next(undefined);</code> elsewhere in code, and it does. I only want it to run when I click the button. How do I cause the pipe in <code>ngOnInit</code> to re-run only when clicking the button, but still extract the file from my <code>file$</code> variable to check it is populated and upload it upon clicking the button?</p>
","3935156","","","","","2020-06-03 21:40:32","RxJS - Piped observable re-running too often","<angular><rxjs><rxjs6>","3","2","1","","","CC BY-SA 4.0"
"62198285","1","","","2020-06-04 15:23:19","","1","54","<p>I have to make 5 requests (order doesn't matter) to 5 different endpoints. The URL of these endpoints is the same, except for the business line. These business lines are the array of the <code>from</code>.</p>

<p>I want show a skeleton loader before each request and hide once it finish. So, basically the flow is:</p>

<pre><code>1. [Hook - before request]
2. [Log of data fetched]
3. [Hook - after request]
</code></pre>

<p>This is my service:</p>

<pre><code>export function getInsurances(
    userIdentity: string,
    hooks?: RequestHooks
): Observable&lt;Policy[]&gt; {
    return from([""all"", ""vehicle"", ""health"", ""soat"", ""plans""]).pipe(
        tap(() =&gt; hooks?.beforeRequest &amp;&amp; hooks.beforeRequest()),
        flatMap&lt;string, Observable&lt;Policy[]&gt;&gt;(businessLine =&gt; {
            return InsurancesApi.getPolicies&lt;Policy&gt;(
                userIdentity,
                businessLine
            ).pipe(
                map(policies =&gt; {
                    return policies.map(policy =&gt; PolicyStandarizer(policy));
                }),
                finalize(() =&gt; {
                    hooks?.afterRequest &amp;&amp; hooks.afterRequest();
                })
            );
        }),
        catchError(err =&gt; of(err)),
        takeUntil(HttpCancelator)
    );
}
</code></pre>

<p>This is my subscribe:</p>

<pre><code>const hooks = {
    beforeRequest() {
        Log.info(""Before Request"");
        setStatus(HttpRequestStatus.PENDING);
    },
    afterRequest() {
        Log.warn(""After Request"");
        setStatus(HttpRequestStatus.RESOLVED);
    },
};
getInsurances(userIdentity, hooks).subscribe(
    policies =&gt; {
        Log.normal(""Policies:"", policies);
        setInsurances(policies);
    },
    (err: Error) =&gt; {
        setError(err);
    }
);
</code></pre>

<p>And have this output (sorry for paste the link, I can't embed the image because rep):</p>

<p><a href=""https://i.stack.imgur.com/Nbq49.png"" rel=""nofollow noreferrer"">https://i.stack.imgur.com/Nbq49.png</a></p>

<p>The <code>finalize</code> is working fine, but the <code>tap</code> is executing five times at once.</p>

<p>Thank you.</p>
","","user13362804","","","","2020-06-04 17:32:28","Intercept each request with before and after hooks","<ajax><rxjs><observable><rxjs6>","1","0","","","","CC BY-SA 4.0"
"62213554","1","62213861","","2020-06-05 10:45:42","","2","745","<p>I have a fetchDrives method which will return an observable which on subscription will return a list of drives</p>

<pre><code>this.fetchDrives(points).subscribe(drives =&gt; {
     console.log(drives);
});
</code></pre>

<p>Assume The drives array which I got on subscription look some what like this</p>

<pre><code>[ {driveId: 1}, {driveId: 2}, {driveId: 3} ]
</code></pre>

<p>Now I need to use the driveId one by one and make three calls ( three because length of the drives array is 3 ) by passing driveId to each api call.I need to pass driveId to the below method one at a time and get the lat and lon and store the result of three calls in an array.</p>

<pre><code>this.getLatLong(driveId).subscribe( res =&gt; console.log(res))
</code></pre>

<p>The res will contain an object like <code>{ lat: 12, lon: 54 }</code></p>

<p>I don't want to do two subscriptions, is there a way I can use the Rxjs operators and achieve this with one subscription using the result of previous observable, loop through the drives array and make three calls to <code>getLatLong</code> method using <code>mergeMap</code> as the sequence of the calls doesn't matter and store the result of those three calls in an array?</p>

<p>I tried using scan operator to loop through but failed to use it to get the desired output</p>

<p>Thanks for the help in advance :)</p>
","6072233","","6072233","","2020-06-05 10:57:58","2020-06-05 11:39:48","Using MergeMap with the array of data received from another observable - RxJs Angular","<javascript><angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"62214426","1","","","2020-06-05 11:35:20","","0","74","<p>I am writing a script using an external API that needs to limit the requests based on:</p>

<ul>
<li>a maximum number of requests per second</li>
<li>a maximum of current requests</li>
</ul>

<p>I found and achieved have this behavior working for a single request, but I have a workflow where I need to:</p>

<ul>
<li>deal with pagination</li>
<li>make two different kind of requests to the same API, the second one being dependent of the first one.</li>
</ul>

<p>The snippet below illustrates the requests workflow, I tried several things with the <code>mergeMap</code> and <code>expand</code> <code>concurrent</code> parameters and some techniques I found here that has I said work well for one request but I am a little bit confused on how to track all the requests to ""sync"" the limits across all the requests.</p>

<pre><code> * Get a page of 1000 companies and the total number of companies.
 *
 * @param afterId Optional id of the last fetched company (to get the next ones).
 */
function getCompanies(afterId?: string): Observable&lt;{ count: number; companies: Company[] }&gt; {
  const options = { limit: 1000, afterId }
  return this.http.post('https://example.com/searches/companies', options)
}

function getAllCompanies(): Observable&lt;Company[]&gt; {
  let alreadyFetchedCount = 0
  this.getCompanies().pipe(
    expand(({ count, companies }) =&gt;
      count &lt;= alreadyFetchedCount ? EMPTY : this.getCompanies(companies[companies.length - 1].uuid)
    ),
    tap(({ companies }) =&gt; (alreadyFetchedCount += companies.length))
  )
}

/**
 * Get a page of 1000 funding rounds.
 *
 * @param companyUuid The funding rounds company uuid.
 * @param afterId Optional id of the last fetched company (to get the next ones).
 */
function getFundingRounds(
  companyUuid: string,
  afterId?: string
): Observable&lt;{ count: number; fundingRounds: FundingRound[] }&gt; {
  const options = { limit: 1000, companyUuid, afterId }
  return this.http.post('https://example.com/searches/companies', options)
}

function getAllFundingRounds(companyUuid: string): Observable&lt;FundingRound[]&gt; {
  let alreadyFetchedCount = 0
  this.getFundingRounds().pipe(
    expand(({ count, fundingrounds }) =&gt;
      count &lt;= alreadyFetchedCount ? EMPTY : this.getFundingRounds(fundingrounds[fundingrounds.length - 1].uuid)
    ),
    tap(({ fundingrounds }) =&gt; (alreadyFetchedCount += fundingrounds.length)),
    reduce((acc, value) =&gt; [...acc, ...value], [])
  )
}

function main() {
  getAllCompanies().pipe(
    // Here I get a stream of 1000 or less companies until all companies have been fetched.
    // Let's work one company by one company.
    mergeMap((companies) =&gt; companies),
    // For each company, get the funding rounds and return the company extended with them.
    mergeMap((company) =&gt;
      getAllFundingRounds(company.uuid).pipe(map((fundingRounds) =&gt; ({ ...company, fundingRounds })))
    ),
    toArray(),
    tap(companies =&gt;
      // Do something with the result
    )
  )
}

</code></pre>
","5683651","","1858357","","2020-06-06 04:32:00","2020-06-06 04:32:00","RxJS: Rate limit and concurrently limit HTTP requests made at different places","<rxjs><rxjs6>","1","3","","","","CC BY-SA 4.0"
"62247638","1","","","2020-06-07 15:30:58","","2","79","<p>I dont have a lot experience in RxJS and I want to do the following thing with a RxJS pipe in my Angular service.</p>

<p>I tried with the iif function but I simply have not enough experience in it.</p>

<p>Angular Version is: <strong>Angular 9</strong><br>
RxJS Version: <strong>6.5.5</strong></p>

<p>check response from GET request true via HttpClient<br>
.... true -> check if can access website via HttpClient<br>
................ true -> set this.isOnline = true<br>
............................ get a response from another url via HttpClient<br>
............................ true -> set this.result = responseFromUrl<br>
........................................ end pipe<br>
............................ false -> throwError(""cant get result"")<br>
................ false -> set this.isOnline = false<br>
............................. end pipe<br>
.... false -> end pipe  </p>
","9313852","","","","","2020-06-07 16:22:26","complicated pipe chain with the HttpClient in Angular with RxJS","<javascript><angular><rxjs><rxjs5><rxjs6>","1","2","0","","","CC BY-SA 4.0"
"62311328","1","62311847","","2020-06-10 19:10:03","","-1","46","<p>How to correctly send RxJS requests, when there are 4 different API endpoints, I need to request each endpoint until previous does not return data.</p>

<p><strong>Schema is:</strong></p>

<pre><code>Request 1 -&gt; Return Void
Request 2 -&gt; Returned data, stop working and return data
Request 3 -&gt; Will fail
</code></pre>

<p><strong>Result is:</strong></p>

<p>Only one result from one of request.</p>

<p><strong>I tried this:</strong></p>

<pre><code>req1$ = of(response);
req2$ = of(response);

req1$.pipe( flatMap((result) =&gt; {
   if (result) { return of(result); } else {return of([]);}
}));
</code></pre>
","","user13664319","","user13664319","2020-06-10 19:16:38","2020-06-10 20:08:33","How to send requests to server one after one RxJS?","<rxjs><rxjs5><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"62326617","1","62326702","","2020-06-11 14:23:45","","0","80","<p>How do I merge two function returns (one returns a promise, one returns a object) from an Observables?
How do I chain the results? What is the proper way to do this?</p>

<pre><code>functionReturnObservable(
        element: SomeInterface,
    ): Observable&lt;Interface&gt; {
        return this.someService.fn2ReturnObservable().pipe(
            map((result) =&gt; {
                // the promise function needs to merge with the funcObject
                const updatedElement= from(this.fnPromise(element))
                return this.funObject(updatedElement, result);
            }),
        );
    }

funcObject(
        updatedElement: Readonly&lt;Interface&gt;,
        listItems: IInterface[],
    ): IObject {
        // returns a revised Object
        return updatedObjects;
    }

async fnPromise(elements: IElements): Promise&lt;SomeInterface&gt; {
        // ... some other stuff 
        let result;
        result.Name = ""John""
        if( elements.References) {
            await this.otherService
            .lookup(elements.References)
            .then((result) =&gt; {
                result.Secret= result;
            });
        }
        return result;
    }
</code></pre>
","3232194","","","","","2020-06-11 14:28:14","Merging an Observable and Promise to an Object","<angular><rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"62344288","1","","","2020-06-12 12:28:17","","1","166","<p>I have one scenario where I need to fetch the mapping for status and priority from backend, as it is static values so once the application loads I do not want to get those values multiple time from backend so for that I need a way which can give me values again without calling the backend here is the snippet for that which I am using.</p>

<pre class=""lang-js prettyprint-override""><code>    ngOnInit() {
        const status  = this.http.get('https://my-json-server.typicode.com/darpankumar/Fakedb/status').pipe(
          shareReplay(1)
        );

        const priority = this.http.get('https://my-json-server.typicode.com/darpankumar/Fakedb/priority').pipe(
          shareReplay(1)
       );
        this.statusPriority$ = combineLatest(status,priority)
      }

</code></pre>

<p>and the place where I need to use it I use it like this</p>

<pre class=""lang-js prettyprint-override""><code>    btnClick() {
        this.task$ = this.statusPriority$.pipe(flatMap((data :Array&lt;any&gt;) =&gt; {
          const [status, priority] = [...data];
          return this.http.get('https://my-json-server.typicode.com/darpankumar/Fakedb/data').pipe(
          map((data : any) =&gt;{
            // this is the place where i do the mapping. 
            data.status = status[data.statusCode];
            data.priority = priority[data.priorityCode];
            return data;
          })
        );
        }))  
      }
</code></pre>

<p>So my question in brief is, is it a right way to implement this behaviour, as one thing which is bothering me is <code>shareReplay</code> gives a <code>multicast observable</code> and I am not using it multiple places.</p>

<p>but apart from this, I can not find any way which can achieve the same functionality for me.</p>

<p>And another question is is there any way I can make this status and priority observable hot so that it fetches the values on load time, not on the button click.</p>

<p>I know I can use <code>behavioursubject(withsomeinitialValue)</code> and then can do the backend call and subscribe to those values in ts and can do the next on behavioursubject but i do not want to do the subscription in the component.</p>

<p><a href=""https://stackblitz.com/edit/angular-ivy-mdehhl?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">fiddle</a></p>
","9834715","","2304474","","2020-06-13 23:00:40","2020-06-13 23:00:40","does it make sense to use shareReplay where i want to replay the value but do not want it to share with multiple observer","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"62404350","1","","","2020-06-16 08:37:21","","0","109","<pre><code>getInactiveTimerTabSynchronizer() {
    return fromEvent(window, 'storage').pipe(
      filter((x: StorageEvent) =&gt; {
        return x.key === this.inactivityTabSynchronizerStorageKey;
      }),
      debounceTime(350));
  }
</code></pre>

<p>The above code has unit test case as below:</p>

<pre><code>import { Observable, of as observableOf } from 'rxjs';


it(
    'getInactiveTimerTabSynchronizer() function should return an observable that looks for storage events ' +
      'and filters it to only ""INACTIVE_TIMER_RESET"" keyed events',
    fakeAsync(
      inject([AuthService], (service: AuthService) =&gt; {
        spyOn(Observable, 'fromEvent').and.returnValue(
          observableOf({ key: 'INACTIVE_TIMER_RESET' } as StorageEvent, { key: 'SOME_OTHER_KEY' } as StorageEvent)
        );

        let counter = 0;
        service.getInactiveTimerTabSynchronizer().subscribe(x =&gt; {
          counter++;
          expect(counter).toBe(1);
        });
        tick(350);
        tick(350);
      })
    )
  );
</code></pre>

<p>It was working fine when i had angluar 6 and rxjs 5.5, but after i upgraded to angular 7 and rxjs 6.5 it throws error as:</p>

<pre><code>Argument of type '""fromEvent""' is not assignable to parameter of type '""prototype"" | ""create"" | ""if"" | ""throw""'
</code></pre>

<p>Any help for the fix or workaround ?</p>
","7068024","","","","","2020-06-16 09:42:01","spyOn(Observable, 'fromEvent') throws error after upgrading to rxjs 6.5","<angular><jasmine><rxjs5><rxjs6><spyon>","1","0","","","","CC BY-SA 4.0"
"62434697","1","62435334","","2020-06-17 17:15:30","","-1","335","<p>I have a <code>BehaviourSubject</code> that is subscribed to via the getSaveBehaviorSubject() in the constructor of a <code>Service</code>.This behavioursubject can receive multiple types of data from other components/services of which some types need to be stored in the backend while others do not. When it receives a value that does need to be stored it sends it to the backend via a <code>put/post</code> request. As a request rate limiter I'm using the <code>debounce(300)</code> operator so that the actual request to the server is made after 300 ms of inactivity have passed. This will prevent the server from throwing a <code>429 Too many requests</code> error. The debounce operator should only be applied when a value type is pushed that needs to be stored. I've tried creating such a condition with the <code>iif()</code> operator. My code looks like this:</p>

<pre><code>this.myService.getSaveBehaviorSubject()
.pipe(
  tap(pair =&gt; {
    if(this.dataStoreServiceJustInitialized){
      this.dataStoreServiceJustInitialized = false; 
      return;
    }

    if (pair.length &gt; 1){
        this.updateDataTypeValue(pair);
        localStorage.setItem(pair[0], JSON.stringify(pair[1]));
        if(pair[0] === DataType.MEASURE_SYSTEM_PREFERENCE)
            this.adjustSearchRadiusToChangedMeasureSystem();
    }
  }),
  mergeMap(pair =&gt;
    iif(() =&gt; !!(this.loggedInSubject.value &amp;&amp; this.dataTypeExclusionList.includes(pair[0])), 
    of(pair).pipe(debounceTime(2000)), of(pair)
    )))
.subscribe(pair =&gt; {If (this.loggedInSubject.value) // make request to server...}
</code></pre>

<p>My solution is based on this tutorial: <a href=""https://www.learnrxjs.io/learn-rxjs/operators/conditional/iif"" rel=""nofollow noreferrer"">https://www.learnrxjs.io/learn-rxjs/operators/conditional/iif</a> and the code of interest starts at <code>mergeMap</code>.</p>

<p>If the user is logged in and the datatype should be saved to the database (is not contained in the <code>dataTypeExclusionList</code>) then <code>iif()</code> should return an observable with a pipe containing a <code>debounceTime</code> operator. Else it should just return a new observable with the original value.</p>

<p>When the <code>iif</code> condition is true debounceTime does not seem to be working. No matter if i'm loggedin or not or if the datatype should be saved or not it will always send the request immediately. Clearly i'm doing something wrong.</p>

<p>Could anyone tell me what the correct way is to use the iif operator in combination with the debounceTime operator? Thank you</p>
","6351733","","6351733","","2020-06-17 17:20:51","2020-06-17 17:56:15","How do i correctly implement a conditional debounceTime() operator with the use of the iif() operator?","<angular><rxjs><rxjs6><iif>","1","0","","","","CC BY-SA 4.0"
"62481717","1","","","2020-06-20 04:38:45","","0","83","<p>Im wondering if someone could please advise.</p>

<p>I have data coming in through a Socket.io service to a component.  Trying to decide what approach is most logical?</p>

<p>I can either:</p>

<p>A. Have the parent component call the observer and Push the data to the variable via an @Input and then update it via OnChange.</p>

<p>B. Call the service in the component and just update the variable from the subscriber.</p>

<p>C. call the service in the component and update the variable in the ngDoCheck.</p>

<p>Just wondering which makes the most logical sense? or does it actually even matter seeing as the data updates regardless of each route?</p>
","10497708","","","","","2020-06-20 04:38:45","Angular OnChange, DoCheck and Observables","<angular><observable><rxjs6><subscribe><ngonchanges>","0","4","","","","CC BY-SA 4.0"
"62499871","1","","","2020-06-21 14:23:18","","0","1258","<p>i'm working with Angular 9 and rxjs 6, and i'm trying to get a list of Nodes :</p>
<p>NodeService.ts</p>
<p><code>public getList(): Observable&lt;Nodes[]&gt; { return this.http.get&lt;Nodes[]&gt;(URL); }</code></p>
<p>Nodes Entity:</p>
<pre><code>export class Nodes {
     public id: number;
     public name: string;
     public site_id: number;
     public site: Site;
}
</code></pre>
<p>nodes.component.ts:</p>
<pre><code>public getAllNodes() {
  this.dataSource.data = [];
  this.nodeService.getList()
    .subscribe(
      nodes =&gt; {
        nodes.map(
          (node) =&gt; {
            this.siteService.getSiteById(node.site_id).subscribe(site =&gt; {
              node.site = site;
            })
          });
        this.dataSource.data = nodes;
        console.log(nodes);
      },
      error =&gt; {
        console.log(error);
      },
      () =&gt; {
      }
    );
}
</code></pre>
<p>=&gt; By default, node.site = null, so i use node.site_id to get the complete &quot;Site&quot; object in the subscribe method.
But i have almost 6000 call to &quot;siteService.getSiteById()&quot; and i have error like: Insufficient resources.</p>
<p>Do you have any better way to do it,</p>
<p>Thank you</p>
","7176984","","","","","2020-06-25 11:35:12","Angular 9 Subscribe inside subscribe","<angular><rxjs6>","2","3","","","","CC BY-SA 4.0"
"62534516","1","62534582","","2020-06-23 12:16:56","","0","226","<p>I would like to have the ability to reinitialize an Observable object.
I don't know if &quot;reinitialize&quot; is the corrent term, but what I mean by that is that I would like to refresh the data</p>
<ol>
<li>without creating a new Observable object, and</li>
<li>without creating new subscriptions (existing subscriptions to the existing Observable object should work seamlessly)</li>
</ol>
<pre><code>@Injectable({
  providedIn: 'root',
})
export class MyService {
  private url = 'http://mydummydomain.com/api/entries';
  private data$: Observable&lt;any&gt;;

  constructor(private http: HttpClient) {
    this.data$ = this.http.get(this.url).pipe(
      shareReplay(1)
    );
  }

  getData(): Observable&lt;any&gt; {
    return this.data$;
  }
  
  reloadData() {
    // TODO:
    // Refresh data from the url
    // Theoretically this should be a function with no input parameters and no return value
  }
}
</code></pre>
<p>Thanks</p>
","12356861","","12356861","","2020-06-25 05:28:45","2020-06-25 05:28:45","Reinitializing an Observable object","<angular><typescript><rxjs><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"62575329","1","","","2020-06-25 12:26:46","","0","40","<p>for example,
I have 2 API service, returning type is Observable.</p>
<pre><code>function add(row) {
    let r = Math.ceil(Math.random() * 2000);
    let k = row + 1;
    return timer(r).pipe(mapTo(k));
}

function mutiple(row) {
    let r = Math.ceil(Math.random() * 2000);
    let k = row * 10;
    return timer(r).pipe(mapTo(k));
}
</code></pre>
<p>there is an array <code>[1, 2, 3, 4, 5]</code>, I use the two function as follow:</p>
<pre><code>from([1, 2, 3, 4, 5]).pipe(
        mergeMap((row) =&gt; {
            return add(row);
        }),
        mergeMap((row) =&gt; {
            return mutiple(row);
        }),
        toArray()
    ).subscribe((_) =&gt; {
        console.log(&quot;sub&quot;, _);
    });
</code></pre>
<p>the result is</p>
<pre><code>sub [ 50, 20, 60, 40, 30 ]
</code></pre>
<p>the answer is that I want.</p>
<p>however, I don't know the source of the element of the array,
I hope the result is</p>
<pre><code>[ [4, 50], [1, 20], [5, 60], [3, 40], [2, 30] ] 
</code></pre>
<p>or</p>
<pre><code>[
  { sourceData: 4, result: 50 },
  { sourceData: 1, result: 20 },
  ...
]
</code></pre>
<p>if I use contactMap to keep the sequence, the program will execute one by one,
I don't care the sequence, I just wanna know how to connect the source and the result.</p>
<p>Thank you so much~</p>
","13812418","","","","","2020-07-06 11:00:57","rxjs, how to merge several requests, one serial request in parallel requests, and get one result","<javascript><typescript><rxjs6>","1","0","","","","CC BY-SA 4.0"
"62579086","1","62612568","","2020-06-25 15:37:23","","-1","45","<p>Using the typical HttpClient service for angular 6, I am struggling to retrieve the error output as an object in the error callback, instead its an observable.</p>
<pre><code>   ...
    }, (e) =&gt; {
       HttpErrorHandling.process(e, this.messageService, this.loggerService, () =&gt; {
       this.messageService.send(NotificationMessage['USER_REGISTRATION_TECHNICAL_ERROR'], MessageTypes.error);
       });
     });
   });
</code></pre>
<p>This does not suit my case when I want to retrieve the error status, when I attempt to get it with err.status, it is undefined because I am doing it on an observable</p>
<pre><code>class HttpErrorHandling

 public static process(err: HttpErrorResponse, messageService: MessageService, logger: LoggerService, callback: any) {
    switch(err.status) {
      case HttpStatusCodeEnum.HttpFailure: {
        // Http failure, no internet connection
        this.handleError(err.name, logger, null);
        break;
      }
    ...
</code></pre>
<p>if instead I subscribe to the error observable like so, I do retrieve the error as an object, but this is messy and bad for performance (nested subscribes). Is there another way to approach this?</p>
<pre><code>     }, (e) =&gt; {
    e.subscribe(
          err =&gt; HttpErrorHandling.process(err, this.messageService, this.loggerService, () =&gt; {
            this.messageService.send(NotificationMessage['USER_REGISTRATION_TECHNICAL_ERROR'], MessageTypes.error);
          })
        });
      });
    });
</code></pre>
","6595661","","","","","2020-06-27 16:23:38","when httpClient fails it returns an observable error in the error callback instead of an error object","<angular><http><rxjs6>","1","2","","","","CC BY-SA 4.0"
"62583382","1","","","2020-06-25 19:57:58","","0","68","<p>in my code i had an interceptor which handled all outbound http Requests and added the token to it.
The code looked like this</p>
<pre><code>intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {

const promise = this.storage.get('token');

return Observable.fromPromise(promise)
  .mergeMap(token =&gt; {
    const clonedReq = this.addToken(request, token);
    return next.handle(clonedReq).pipe(
      catchError(async err =&gt; {
        // Perhaps display an error for specific status codes here already?
        if (err.status === 400 &amp;&amp; err.error.message === 'Failed to authenticate token.') {
          this.auth.logout(true);
        }

        if (err.status === 401 &amp;&amp; err.error.error === 'TokenExpiredError') {
          this.auth.logout();
          // this.unauthorizedWatcher.getInterceptedSource().next(err.status);
        }

        let errorText = '';
        if (err.error) {
          errorText = err.error.message;
        } else if (err.statusText) {
          errorText = err.statusText;
        }

        const toast = this.toastCtrl.create({
          message: errorText ? errorText : err.name,
          duration: 3000,
          position: 'top',
          cssClass: 'error',
        });
        (await toast).present();

        // Pass the error to the caller of the function
        return throwError(err);
      })
    );
  });
}
</code></pre>
<p>since i upgraded from rxjs: &quot;5.5.11&quot; to rxjs: &quot;6.5.1&quot; fromPromise is no longer avail. How would i convert this line to valid 6.5.x jxjs code</p>
","13252392","","13252392","","2020-06-25 20:15:52","2020-06-25 20:15:52","After upgrade to RXJS 6.5 fromPromise no longer availabe","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"62585148","1","62589480","","2020-06-25 22:14:43","","0","154","<p>Hi I am newbie in Rxjs and its operators.</p>
<p>I am having difficulty to understand below code</p>
<pre class=""lang-js prettyprint-override""><code>canActivate(route: ActivatedRouteSnapshot): Observable&lt;boolean&gt; {
        const id = route.paramMap.get('id');

        console.log('Entered in Can-Activate');
        return this.store.select(policy)
            .pipe(
                tap(policy =&gt; {
                    console.log('-------------------' + JSON.stringify(policy));
                    if (policy.model.id !== id &amp;&amp; policy.meta.loading !== 'progress') {
                        console.log('--------------dispaching-----');
                        this.store.dispatch(new Load(id));
                    }
                }),
                filter(policy =&gt; (
                    policy.model.id === id &amp;&amp;
                    (policy.meta.loading === 'done' || policy.meta.loading === 'failed')
                )),
                map(s =&gt; s.meta.loading ==='done'),
                take(1)
            );
    }
</code></pre>
<p>The console output for this is</p>
<pre><code>Entered in Can-Activate
-------------------{&quot;meta&quot;:{&quot;loading&quot;:&quot;start&quot;.........}
-------------------{&quot;meta&quot;:{&quot;loading&quot;:&quot;progress&quot;.........}
-------------------{&quot;meta&quot;:{&quot;loading&quot;:&quot;done&quot;.........}
</code></pre>
<p>Can anyone explain me why below line executed multiple time when function only called once?
console.log('-------------------' + JSON.stringify(policy));</p>
<p>Is it because ngrx store or RxJS operators?</p>
","6359611","","","","","2020-06-26 06:52:11","why the console.log prints multiple times","<angular><rxjs><ngrx><rxjs6><ngrx-store>","1","1","","","","CC BY-SA 4.0"
"62592903","1","","","2020-06-26 10:34:27","","92","103738","<p>I am trying to upgrade my angular 9 app to angular 10 version, but getting below warning after the upgrade</p>
<pre><code>rxjs\BehaviorSubject.js depends on rxjs-compat/BehaviorSubject
</code></pre>
<p>Any idea how to fix this?</p>
","7984313","","5486116","","2021-05-23 13:49:49","2021-05-23 13:49:49","Upgrading to Angular 10 - Fix CommonJS or AMD dependencies can cause optimization bailouts","<javascript><angular><rxjs><rxjs6><angular-upgrade>","9","3","11","","","CC BY-SA 4.0"
"62594424","1","62596537","","2020-06-26 12:08:07","","0","49","<pre><code>save(): void {
 combineLatest(this.selectedSorting$, this.selectedFilters$)
                .pipe(
                    map((data) =&gt; {
                        let obj = {};
                        if (data[0]) {
                            obj['filters'] = data[0];
                        }
    
                        if (data[1]) {
                            obj['sorting'] = data[1];
                        }
    
                        return obj;
                    }),
                )
                .subscribe((response) =&gt; {
                    console.log(response);
                });

}
</code></pre>
<p>I observe two problems:</p>
<ol>
<li>Dirty a map operator</li>
<li>Problem with undefined or null observables <code>this.selectedSorting$, this.selectedFilters$</code></li>
<li>When any of observers are changed it has effect to <code>save()</code></li>
</ol>
<p>How to improve it?</p>
<p>As result I expect one object from:</p>
<pre><code>{filters: []}
{sorting: []}
{filters: [], sorting: []}
</code></pre>
<p>My full code:</p>
<pre><code>public selectedFilters$ = new Observable();
public selectedSorting$ = new Observable();
public filterButtonDisabled$: Observable&lt;any&gt;;
public setttings$ = new Observable();

@ViewChildren(FilterComponent) filtersList: QueryList&lt;FilterComponent&gt;;

constructor(private settingsService: SettingsService, private applicationService: ApplicationService) {}

public saveSettings(): void {
    this.setttings$.subscribe((res) =&gt; console.log(res));
}

public resetFilter(): void {
    this.filtersList.forEach((flt) =&gt; flt.reset());
}

public doFilter(): void {
    this.selectedFilters$.pipe(switchMap((data) =&gt; this.applicationService.filterExecutionApplications(data))).subscribe();
}

public onSorting(sorted: any) {
    this.selectedSorting$ = of(sorted);
}

ngAfterViewInit() {
    this.selectedFilters$ = combineLatest(...this.filtersList.map((f) =&gt; f.changeFilter.pipe(filter((data) =&gt; !!data))));
    this.selectedFilters$.subscribe((data) =&gt; console.log(data));
    this.setttings$ = combineLatest(this.selectedSorting$, this.selectedFilters$).pipe(
        map((data) =&gt; ({ filters: data[1], sorting: data[0] })),
    );
}
</code></pre>
<p>I have tried to get last chnages from <code>this.selectedSorting$</code> and <code>this.selectedFilters$</code> and call save method. But only when user click over buttons and calls <code> public saveSettings(): void {}</code></p>
","","user13406409","","user13406409","2020-06-26 13:59:45","2020-06-26 14:06:46","How to improve Rxjs expression?","<angular><rxjs><rxjs6>","1","8","","","","CC BY-SA 4.0"
"62597851","1","62598173","","2020-06-26 15:19:48","","0","117","<p>I'm using Angular(9) Powered Bootstrap (ng-bootstrap 6.1) and am providing ngbTypeahead with an Observable&lt;IKeyValue[]&gt; like so:</p>
<pre><code>search = (text$: Observable&lt;string&gt;) =&gt; {
    return text$.pipe(
      debounceTime(200),
      distinctUntilChanged(),
      // switchMap allows returning an observable rather than maps array
      switchMap((searchText) =&gt; {
        if (!searchText || searchText.trim().length &lt; 3) {
          // when the user erases the searchText
          return EMPTY;
        } else {
          // get a list of dealer reps
          return this.myService.getKeyValues(searchText);
        }
      })
      , catchError((error) =&gt; of(this.myService.postErrorMessage(error)))
    );
  }
</code></pre>
<p>I need to transform the output of this.myService.getKeyValues from Observable&lt;IKeyValue[]&gt; to Observable&lt;string[]&gt; by mapping each IKeyValue item to its item.value property.</p>
<p>How do I modify the code above to do that using rxjs 6.5.5?</p>
","773906","","","","","2020-06-26 21:27:16","Angular9/rxjs6.5: How to Transform an Array of Observable Object Array to an Observable Object Property Array?","<rxjs><observable><angular9><rxjs6><switchmap>","1","0","","","","CC BY-SA 4.0"
"62608353","1","62615525","","2020-06-27 09:41:49","","1","70","<p>Say I want a queue where only 3 items are being processed asynchronously at any one time, how do I go about this?</p>
<p><strong>This is what I mean:</strong> If I have a collection of items to upload to the backend i.e. upload some artefacts to cloud storage and consequently create/update a doc to reflect the url of each artefact and <strong>I don't want to:</strong></p>
<ol>
<li>Async/Await each upload operation before the next - as this would be slow</li>
<li>Send everything off at the same time - this could lead to write hot-spotting or rate limiting</li>
<li>Do a promise.race - this eventually leads to (2)</li>
<li>Do a promise.all - the process becomes slow if there's one long running upload.</li>
</ol>
<p><strong>And what I want to do is:</strong></p>
<ol>
<li>Have a queue of all the uploads, say with an RxJs create method e.g. <code>from(array-of-upload-items)</code> with a stack of 3 items being processed at any one time.</li>
<li>And when one item leaves the stack i.e. completes, we add a new item to the queue</li>
<li>Ensure that at any one point, there are always 3 items in the stack being processed until there are no more items in the queue waiting to be put in the stack.</li>
</ol>
<p>How would I go about this using RxJs?</p>
<p><strong>EDITED: 27/June/2020</strong></p>
<p>Here's what I am thinking of:</p>
<pre><code> const rxQueue = from(filesArray) // this is the list of files to upload say like 25 files or so

      rxQueue
        .pipe(
          mergeMap((item) =&gt;
            of(item).pipe(
              tap(async (item) =&gt; {
                  await Promise.race([
                      processUpload(item[0]),
                      processUpload(item[1]),
                      processUpload(item[2]),
                  ])
              }),
            ),
            3
          ),
        )
        .subscribe()
</code></pre>
<p>The goal is to ensure that at any point, 3 files are being processed (uploaded) so much so that if one file upload process ends, another file is added to keep the stack at 3 upload processes. Same way, if 2 file uploads end at the same time, 2 new files are added to the stack and so on until all the files in the file array are uploaded.</p>
","7617726","","7617726","","2020-06-27 20:51:23","2020-06-27 20:59:47","implement a queueing system with a fixed stack in RxJs","<javascript><rxjs><queue><rxjs6>","2","2","1","","","CC BY-SA 4.0"
"62653098","1","62657611","","2020-06-30 08:17:56","","1","168","<p>When I use <code>take(1)</code>, it will console.log twice <code>1</code>, like below code:</p>
<pre><code>  const a$ = new BehaviorSubject(1).pipe(publishReplay(1), refCount());
  a$.pipe(take(1)).subscribe();
  a$.subscribe((v) =&gt; console.log(v)); // emit twice (1 1)
</code></pre>
<p>But when I remove <code>take(1)</code> or remove <code>publishReplay(1), refCount()</code>, it follow my expected (only one <code>1</code> console.log).</p>
<pre><code>  const a$ = new BehaviorSubject(1).pipe(publishReplay(1), refCount());
  a$.subscribe();
  a$.subscribe((v) =&gt; console.log(v)); // emit 1

  // or

  const a$ = new BehaviorSubject(1);
  a$.pipe(take(1)).subscribe();
  a$.subscribe((v) =&gt; console.log(v)); // emit 1
</code></pre>
<p>Why?</p>
<p>Version: rxjs 6.5.2</p>
","6346367","","","","","2020-06-30 12:36:09","rxjs: why the stream emit twice when another stream use take(1)","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"62685357","1","","","2020-07-01 21:08:23","","0","69","<p>currently I've an implementation using Angular 8 and RxJS 6.5.2 that works perfectly on Google Chrome, but in Safari it's returning an error without sense for me. Below I'll share a fragment of this implementation:</p>
<pre><code>public getLoggedEmployee(): Observable&lt;any&gt; {
        if (this.employee) {
            return of(this.employee);
        }

        return this.authenticationService
            .getAuthenticatedUser()
            .pipe(
                tap(user =&gt; this.authUser = user),
                flatMap(user =&gt; this.findOneById(user.id)),
                map((employee) =&gt; {
                    this.employee = _.merge(employee.data, { user: this.authUser });

                    return this.employee;
                })
            );
    }
</code></pre>
<p>How I said, in Chrome works fine, but in Safari I've this error:</p>
<p><code>Error: Uncaught (in promise): TypeError: undefined is not an object (evaluating 'user.id')</code></p>
<p>For some reason on the <code>flatMap</code> action, the value for <code>user</code> still <strong>undefined</strong>, I can't imagine why. I did a check for compilerOption target of the project, currently using <code>es5</code>, checked for some missing polyfills for Safari but not luck so far.</p>
<p>If some one have any idea that can help me to find a solution I'll appreciate it. Thanks.</p>
","3724184","","","","","2020-07-06 10:36:23","RxJS .pipe doesn't working as expected on Safari","<safari><angular8><rxjs6>","1","2","","","","CC BY-SA 4.0"
"62689063","1","62708541","","2020-07-02 04:32:27","","0","25","<p>I am trying to make 2 api calls where one api gets the array of IDs that I needed to make another api call according to the IDs that were returned with some object where I can manipulate into displaying some form inputs according to the data I received from it.</p>
<p>But I am now stuck while attempting to make the second call. Any advice on how I could make the second call would be appreciated.</p>
<pre><code>//api.service.ts

import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';

@Injectable({
  providedIn: 'root'
})
export class ApiService {

  baseurl = 'http://localhost:5000';

  constructor(private http: HttpClient) { }

  getIds(id){
    return this.http.get(this.baseurl + '/types/' + id);
  }

  getCustomFieldsById(id){
    return this.http.get(this.baseurl + '/types/fields/' + id );
  }
}



</code></pre>
<pre><code>//custom.component.ts

import { Component, OnInit, Input } from '@angular/core';
import { ApiService } from '../api.service';
import { map, mergeMap, switchMap } from 'rxjs/operators';


@Component({
  selector: 'app-custom',
  templateUrl: './custom.component.html'
})

export class CustomComponent implements OnInit {

  constructor(private apiService: ApiService) {
  }

  ngOnInit(){
  }

  getCustomFields(id){
    this.apiService.getIds(id)
    //this returns an obj in which arrayData constains an array of ids that is needs to be passed into the other api call
    .pipe(
      map((obj: any) =&gt; {
        //trying to map the array from the obj
        const data = obj.arrayData;
        return data;
      }),
      mergeMap(data =&gt;
          //data here is an array of ids
          //suppose to receive the ids from the arrayData above 
          this.apiService.getCustomFieldsById(data)
      )
    ).subscribe(response =&gt; {
      console.log(response);
    });
  }
}
</code></pre>
","1908741","","","","","2020-07-03 04:28:58","Passing an array from an api call to a second api call","<angular9><rxjs6>","1","0","","","","CC BY-SA 4.0"
"62698054","1","62698108","","2020-07-02 13:58:38","","-1","43","<pre class=""lang-js prettyprint-override""><code>const arr =[
            {
                id:1,
                name: 'Name',
                country: 'UK',
            },
            {
                id:2,
                name: 'Name',
                country: 'USA',
            },
            {
                id:3,
                name: 'Name',
                country: 'USA',
            },
            {
                id:4,
                name: 'Name',
                country: 'UK',
            },
        ];

</code></pre>
","12893339","","10564525","","2020-07-02 22:56:08","2020-07-02 22:56:08","JS6 - How can I loop through an array of objects and filter where country = UK","<javascript><reactjs><web><frontend><rxjs6>","3","1","","","","CC BY-SA 4.0"
"62701858","1","","","2020-07-02 17:22:28","","1","38","<p>I have one Observable (redux Epic). I try group events by time. I use bufferTime but this operator not wait for first action :(</p>
<pre class=""lang-js prettyprint-override""><code>        action$.pipe(
            ofType(&quot;SOME_REDUX_ACTION&quot;), // custom filter operator 
            bufferTime(1000),
            tap((events) =&gt; console.log(&quot;WHY?&quot;, events))
            filter(events =&gt; !!events.length),
            [...]

</code></pre>
<p>Current output :</p>
<pre><code>WHY? []
WHY? []
WHY? []
WHY? []
WHY? []
WHY? []
WHY? []
WHY? [event1,event2]
WHY? []
WHY? []
WHY? []
WHY? [event3]
</code></pre>
<p>Expected output without filter.</p>
<pre><code>WHY? [event1,event2]
WHY? [event3]
</code></pre>
","10245635","","10245635","","2020-07-02 17:47:02","2020-07-03 06:38:51","How to get recent events in RxJS that occurred in one second?","<redux><rxjs><rxjs6>","1","5","","","","CC BY-SA 4.0"
"62739286","1","","","2020-07-05 10:00:58","","1","384","<p>The scenario I'm trying here is to read the data, loop based on the duration, so for example, take &quot;Adam&quot; first, play Adam for 15 seconds timer then go to the next beginner &quot;Andy&quot;, play Andy for 15 seconds.</p>
<p>Because &quot;play&quot; is 1, move to the next group &quot;intermediate&quot;, play &quot;Fam&quot; for 30s then move to &quot;Jamie&quot; &amp; play for 30s.. once done, loop intermediate because &quot;play&quot; is 2... Once complete, move to &quot;expert&quot;</p>
<pre><code>let data = [{
    &quot;play&quot;: 1,
    &quot;name&quot;: &quot;Adam&quot;,
    &quot;duration&quot;: 15,
    &quot;group&quot;: &quot;beginner&quot;
}, {
    &quot;play&quot;: 1,
    &quot;group&quot;: &quot;beginner&quot;,
    &quot;name&quot;: &quot;Andy&quot;,
    &quot;duration&quot;: 15
}, {
    &quot;duration&quot;: 30,
    &quot;play&quot;: 2,
    &quot;name&quot;: &quot;Fam&quot;,
    &quot;group&quot;: &quot;intermediate&quot;
}, {
    &quot;name&quot;: &quot;Jamie&quot;,
    &quot;group&quot;: &quot;intermediate&quot;,
    &quot;duration&quot;: 30,
    &quot;play&quot;: 2
},
{
    &quot;duration&quot;: 45,
    &quot;play&quot;: 2,
    &quot;name&quot;: &quot;Fam&quot;,
    &quot;group&quot;: &quot;expert&quot;
}, {
    &quot;name&quot;: &quot;Jamie&quot;,
    &quot;group&quot;: &quot;expert&quot;,
    &quot;duration&quot;: 45,
    &quot;play&quot;: 2
}];
</code></pre>
<pre class=""lang-js prettyprint-override""><code>destroy$: Subject&lt;boolean&gt; = new Subject&lt;boolean&gt;();
onStart() {
  from(data).pipe(
    takeUntil(this.destroy$),
    concatMap(record =&gt; timer(0, record.duration * 1000).pipe(
    map(i =&gt; data[i]))
  ))
  .subscribe(data =&gt; {
    this.currentItem = data;
  });
}

ngOnDestroy() {
  this.destroy$.next(true);
  this.destroy$.unsubscribe();
}
</code></pre>
<p>Huge thanks for sharing your idea in advance
Thanks!</p>
","4135725","","4135725","","2020-07-05 11:20:03","2020-07-05 16:50:18","Angular RxJS create timer loop based on varying duration in the objects of an array","<angular><typescript><rxjs><rxjs6>","3","2","","","","CC BY-SA 4.0"
"62904063","1","","","2020-07-14 21:10:22","","0","147","<p>I am using angularFireAuth for authentication and the firestore as the DB.</p>
<p>My use-case is pretty simple:</p>
<ol>
<li><p>register a new user with <code>email</code> and <code>password</code> using firebase JS SDK methods.</p>
</li>
<li><p>On successful registration, save the user's info in the <code>firestore</code> database.</p>
</li>
</ol>
<p>If I would simply use the promise, It works fine. However rest of the app, the code mostly uses observables and It simply feels unnatural to use promise in the middle since most of the APIs either consume<code>observable</code> or return <code>observable</code>.</p>
<p>So I started to convert these <code>()=&gt; promise&lt;void&gt;</code> types to <code>observable&lt;void&gt;</code> using the <code>defer</code> - Rxjs</p>
<p>Here is an example:</p>
<p>user.service.ts</p>
<pre><code>  export const USER_COLLECTION = 'users';
  private userCollection: AngularFirestoreCollection;
  constructor(    private db: AngularFirestore  ) {
    this.userCollection = this.db.collection(USER_COLLECTION);  
}    

//save user in firestore db  

saveUser(user: User): Observable {    
  return defer(() =&gt;        
   this.userCollection.doc(user.UID).set(classToPlain(user))    
  );  
}
</code></pre>
<p>The registeration method is like:</p>
<pre><code>registerUser(value: { email: string, password: string }): Observable {       
    return from(firebase.auth().createUserWithEmailAndPassword(value.email,value.password))      
              .pipe(switchMap(user =&gt; this.db.saveUser(user)))  
}
</code></pre>
<p><em>the switchMap never calls the <code>this.db.saveUser</code> . As a result, the user never is saved to firestore</em></p>
<p>... and in a component, I subscribe to the <code>registerUser method</code></p>
<pre><code> this.subs.sink = this.authService.registerUser(this.loginForm.value)      
.subscribe();
</code></pre>
<p>I am not sure what is going wrong, The <code>switchMap</code> operator should ideally unsubscribe the last observable(<code>from..</code>) and should subscribe to the <code>DB.saveUser</code></p>
","2321724","","2321724","","2020-07-15 15:12:51","2020-07-15 17:53:13","firebase.auth().createUserWithEmailAndPassword() - completes before a using any other rxJs operators","<angular><firebase><google-cloud-firestore><rxjs6><switchmap>","1","0","1","","","CC BY-SA 4.0"
"62934781","1","62946443","","2020-07-16 12:32:38","","0","829","<p>I have a user service which allows login, logout and maintains data about the currently logged in user:</p>
<pre class=""lang-js prettyprint-override""><code>user$ = this.http.get&lt;User&gt;('/api/user')
            .pipe(
              shareReplay(1),
            );
</code></pre>
<p>I am using <code>shareReplay(1)</code> because I do not want the webservice to be called several times.</p>
<p>On one of the components, I have this (for simplicity), but I have several other things I want to do if a user is logged in:</p>
<pre class=""lang-html prettyprint-override""><code>&lt;div *ngIf=&quot;isUserLoggedIn$ | async&quot;&gt;Logout&lt;/div&gt;
</code></pre>
<pre class=""lang-js prettyprint-override""><code>isUserLoggedIn$ = this.userService.user$
                    .pipe(
                      map(user =&gt; user != null),
                      catchError(error =&gt; of(false)),
                    );
</code></pre>
<p>However, the <code>isLoggedIn$</code> does not change after the user logs in or logs out. It does change when I refresh the page.</p>
<p>Here's my logout code:</p>
<pre class=""lang-js prettyprint-override""><code>logout() {
  console.log('logging out');
  this.cookieService.deleteAll('/');

  this.user$ = null;

  console.log('redirecting');
  this.router.navigateByUrl('/login');
}
</code></pre>
<p>I understand that the internal observable is not reset if I assign the variable to null.</p>
<p>So, for logout, I took clue from this answer: <a href=""https://stackoverflow.com/a/56031703"">https://stackoverflow.com/a/56031703</a> about refreshing a <code>shareReplay()</code>. But, the user$ being used in the templates causes my application to go into a tizzy as soon as I attempt to logout.</p>
<p>In one of my attempts, I tried <code>BehaviorSubject</code>:</p>
<pre class=""lang-js prettyprint-override""><code>user$ = new BehaviorSubject&lt;User&gt;(null);

constructor() {
  this.http.get&lt;User&gt;('/api/user')
    .pipe(take(1), map((user) =&gt; this.user$.next(user))
    .subscribe();
}

logout() {
  ...
  this.user$.next(null);
  ...
}
</code></pre>
<p>This works a little better except when I refresh the page. The auth-guard (<code>CanActivate</code>) always gets the user$ as null and redirects to the login page.</p>
<p>This seemed like an easy thing to do when I started out, but I am going on falling into a deeper hole with each change. Is there a solution to this?</p>
","6238914","","","","","2020-07-17 03:01:51","RxJS shareReplay() does not emit updated value","<angular><typescript><rxjs><rxjs6><rxjs-observables>","1","5","0","","","CC BY-SA 4.0"
"62944591","1","62945014","","2020-07-16 22:46:02","","6","1487","<h1>I wanna stop a observable subscription based on two conditions:</h1>
<ul>
<li>Time (using <code>import { timer } from 'rxjs/internal/observable/timer';</code>)</li>
</ul>
<p><strong>OR</strong></p>
<ul>
<li>Execution status (using the returned object from request that you'll see below)</li>
</ul>
<h1>What is happenning:</h1>
<p>It's only stoping execution based on Time (using <code>import { timer } from 'rxjs/internal/observable/timer';</code>)</p>
<h1>This is my current code:</h1>
<p>The names of attributes, variables and their values ​​have been changed for example purposes:</p>
<pre><code>import { finalize } from 'rxjs/internal/operators/finalize';
import { interval } from 'rxjs/internal/observable/interval';
import { timer } from 'rxjs/internal/observable/timer';
import { takeUntil, first } from 'rxjs/operators';
import { merge, EMPTY, of } from 'rxjs';

.
. // Attributes and Class declaration here
.


async startProcess(): Promise&lt;void&gt; {

    this.isProcessLoading = true;

    const { someId } = await this.exampleService.execute().toPromise();

    const interval$ = interval(1000);
    const timeLimiter$ = timer(10000);

    const request$ = this.exampleService.doRequest();
    
    const isEventFinished$ = EMPTY;

    // My goal here is for the result of this function to return an observable that notifies 
    // if the first parameter emits an event OR if the second parameter emits another. That is, I want to notify if any condition is valid
    const stopConditions$ = merge(isEventFinished$, timeLimiter$);

    const handleSuccess = (object: MyType) =&gt; {

      if (object.status === 'FINALIZED') {

        this.object = object;
        isEventFinished$.subscribe();
      }
    };

    const handleError = () =&gt;  this.showErrorComponent = true;

    interval$
    .pipe(takeUntil(stopConditions$))
    .pipe(finalize(() =&gt; this.isSimulationLoading = false))
    .subscribe(() =&gt; request$.subscribe(handleSuccess, handleError));
}

</code></pre>
<p>The code &quot;works&quot; because the <code>timeLimiter$</code> fires <code>takeUntil</code> after 10s. However, I want the possibility to stop before the time limit...</p>
<p>I want takeUntil to be able to run from here too:</p>
<p><code>isEventFinished$.subscribe()</code></p>
<p>if the above snippet performed correctly, it should be stop the interval$, but it does not. That is my problem</p>
<h1>What i already tried:</h1>
<ol>
<li><p>I dont know if two pipes made any difference than use only one like this: <code>.pipe(takeUntil(stopConditions$), finalize(() =&gt; this.isSimulationLoading = false))</code>. However, i already tried it and did not work</p>
</li>
<li><p>Already tried to replace this <code>isEventFinished$</code> for: <code>const isEventFinished$ = of(1)</code>
and his subscription by: <code>timeLimiter$.pipe(first()).subscribe()</code>.
But this does not works either. In reality, this prevents the request from being executed (I don't know why)</p>
</li>
</ol>
","8303951","","8303951","","2020-07-16 23:56:53","2020-07-17 00:12:15","How to stop subscription by using multiple conditions with takeUntil","<javascript><angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"63037352","1","63037969","","2020-07-22 15:02:44","","0","440","<p>I have one endpoint which returns <code>{ ids: [1, 2, 3, 45] }</code>.</p>
<p>And another one which returns a value for a given id: <code>{ id: 3, value: 30, active: true }</code>.</p>
<p>I'm trying to construct an observable which calls the first endpoint and for each id returned call the second enpoint and emits the sum of all <code>active = true</code> values:</p>
<pre><code>private getIds(group: string) {
  const url = '...';
  return this.http.get&lt;{ ids: number[] }&gt;(url, { params: { group } });
}

private getValue(id: number) {
  const url = '...';
  return this.http.get&lt;ActiveValue&gt;(url, { params: { id: id.toString() } });
}

public getSum(group: string) {
  let sum = 0;
  const bSubject = new BehaviorSubject(sum);

  const observables = this.getIds(group).pipe(
    mergeMap(({ ids }) =&gt; ids),
    map(id =&gt; this.getValue(id).pipe(tap(({ value, active }) =&gt; {
      if (active) {
        sum += value;
        bSubject.next(sum);
      }
    })))
  );

  const observable = forkJoin(observables).pipe(map(() =&gt; sum));
  return { bSubject, observable };
}

interface ActiveValue {
  value: number;
  active: boolean;
}
</code></pre>
<p>But it complains about:</p>
<pre><code>forkJoin is deprecated: Use the version that takes an array of Observables instead (deprecation)
</code></pre>
<p>Also, when I hover over <code>observables</code> it shows:</p>
<pre><code>const observables: Observable&lt;Observable&lt;ActiveValue&gt;&gt;
</code></pre>
<p>...while I thought it should be <code>Observable&lt;ActiveValue&gt;[]</code></p>
<p>How can I make it work?</p>
","6188402","","","","","2020-07-22 16:14:32","How to build an observable which calls multiple observables based on previous result?","<angular><typescript><rxjs><rxjs6>","2","1","2","","","CC BY-SA 4.0"
"63055027","1","63055115","","2020-07-23 13:07:24","","5","4435","<p>I my project I need to compare my paginator's <code>pageSize</code> value (items per page) with the previous value and if the new one is higher, then I need to load datas from storage. But if it's not higher I don't want to do anything.</p>
<p>For example in this code:</p>
<pre class=""lang-js prettyprint-override""><code>export class MyComponent {
  paginatorPageSize: BehaviorSubject&lt;number&gt; = new BehaviorSubject&lt;number&gt;(10);
  // ...

  savePageSettings() {
    this.pageService.save().pipe(
      map((result: any) =&gt; {
        // ...
      }),
      tap(() =&gt; this.anyCode.here()),
      switchMap((result: any) =&gt; {
        // ...
      }),
      switchMap(() =&gt; {
        const previousPageSize = ??? // &lt;--- here how can I get the prevoius value of paginatorPageSize?

        if (previousPageSize &gt;= this.paginatorPageSize.value) {
          return this.pageService.getAll();
        }

        return of(null)
      })
    ).subscribe();
  }
}
</code></pre>
<p>Is there any way to get the previous emitted value of a RxJS Subject / BehavioSubject or any kind of subjects?</p>
","972828","","","","","2021-04-14 08:44:57","How to get previous value of RxJS Subject?","<typescript><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"63061257","1","","","2020-07-23 18:55:01","","0","706","<p>This is a followup question for another question I had posted, which remains half-solved: <a href=""https://stackoverflow.com/questions/62934781/rxjs-sharereplay-does-not-emit-updated-value"">RxJS shareReplay() does not emit updated value</a></p>
<p>I am creating an Angular app and I'm trying to use Observables extensively. The problem is with creating a <code>UserService</code> class which has an observable <code>user$</code> which can be piped to throughout the application to get the currently logged in user.</p>
<p>The currently accepted answer (by @DeborahK - she had been very patient with me) is a great solution, but has a bug - A user logs in, then logs out. Then a second user logs in. The <code>user$</code> object for the second user is not refreshed (because it is <code>shareReplay()</code>) and they can see all the data of the first user.</p>
<p>If I refresh the page, things work just fine.</p>
<p>I found another question with a similar problem from 2018 and it still remains unsolved: <a href=""https://stackoverflow.com/questions/51213698/angular-2-typescript-reload-components-on-login-logout"">Angular 2 Typescript reload components on login/logout</a></p>
<p>I have tried several other ways, even with <code>BehaviorSubject</code>, but the problem there is that the <code>user$</code> is never ready in time for the <code>CanActivate</code> auth-guards. So, the auth-guards get the value of the user as <code>null</code> and redirect them to the login page.</p>
<p>I am looking for a way to serve the following use cases:</p>
<ol>
<li>User should be able to login</li>
<li>Show 'Logout' link (and/or other user related things) when the user is logged in.</li>
<li>Refreshing the page should load the user for the auth-guards, in order to redirect to the right page.</li>
<li>User should be able to logout</li>
<li>New user should be able to login</li>
<li><code>user$</code> could be used several times and still call the webservice only once throughout its lifetime.</li>
</ol>
<p>In one of the solutions (<a href=""https://stackblitz.com/edit/angular-user-logout-deborahk-hz1agh"" rel=""nofollow noreferrer"">stackblitz example here</a>), it appears that things are working fine, until you pop the hood to check the Network tab of the browser. Each time <code>$user</code> is used, a new network call is made. One of my pages has an array of data being looped through. With this approach, there are so many network calls made to the API, that the browser become irresponsive.</p>
<p>Even with the simplest of examples...</p>
<pre class=""lang-js prettyprint-override""><code>user$ = this.logInAction$.pipe(
    switchMap(userId =&gt; {
      console.log(&quot;userid = &quot;, userId);
      if (userId &gt; 0) {
        // returning webservice observable
        return this.callWS(userId);
      } else {
        // user logged out
        return of(null);
      }
    }),
  );
</code></pre>
<p>... a stream (or the observable) once returned is what is subscribed to. There is no way to actually switch the observable again when required.</p>
<p>Is there a way to achieve the desired result using RxJS and Observables?</p>
","6238914","","","","","2020-07-23 18:55:01","Angular app - User login, logout and session reload with Observables","<angular><typescript><rxjs><rxjs6><rxjs-observables>","0","0","","","","CC BY-SA 4.0"
"63069942","1","63070016","","2020-07-24 08:37:37","","2","216","<p>I have this RxJS code in my Angular project:</p>
<pre class=""lang-js prettyprint-override""><code>settingsService.getSetting('setting-name').pipe(
  map((setting: SettingInterface) =&gt; {
    // ...

    return setting;
  }),
  tap((setting: SettingInterface) =&gt; this.settingService.save(setting)),
  map((setting: SettingInterface) =&gt; {
    // ...
  })
);
</code></pre>
<p>In this code the <code>this.settingService.save(setting)</code> is an <code>Observable</code> too, and it isn't subscribed.</p>
<p>How can I start this observable in the pipe, wait for it and continue?</p>
<p>Important:</p>
<ul>
<li>the <code>save()</code> observable must start after prevoius <code>map()</code> operator</li>
<li>the result of the <code>save()</code> observable is irrelevant in the pipe and I want to drop it</li>
<li>the <code>save()</code> observable must start before next <code>map()</code> operator</li>
</ul>
<p>Is there any RxJS operator to do this?</p>
","972828","","","","","2020-07-24 08:52:59","How to start observable in the pipe in RxJS 6?","<angular><rxjs><observable><rxjs6>","1","1","","","","CC BY-SA 4.0"
"63081528","1","","","2020-07-24 21:13:08","","0","31","<p>Is there way to avoid storing a result using closures from an initial HTTP request for use in a second HTTP request, as well as, in the subscribe block?  The second request depends on the first so I can't use <code>combineLatest</code>, etc.</p>
<pre class=""lang-js prettyprint-override""><code>let acceptedOrgAgreement = false;

// Initial HTTP request
this.organizationResource
  .getOrganizationById(organizationId)
  .pipe(
    // Initial HTTP response
    map((organization: Organization) =&gt; !!organization.acceptedAgreementDate),
    exhaustMap((hasSignedOrgAgreement: boolean) =&gt; {

      // Would rather not have to temporarily store this in outer function scope
      acceptedOrgAgreement = hasSignedOrgAgreement;

      // Second HTTP request that relies on the initial request
      return this.siteResource.updateSite(payload, hasSignedOrgAgreement);
    }),
    // Pass first and second HTTP responses to subscribe as tuple
    map((response: any) =&gt; [response, acceptedOrgAgreement])
  )
  .subscribe(([response, hasSignedOrgAgreement]: [any, boolean]) =&gt; {
    // Do some work using both responses
  });
</code></pre>
","1148107","","","","","2020-07-29 03:28:26","Passing Multiple Values Through Pipe While Making Dependent HTTP Requests without Using Closures","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"63097372","1","","","2020-07-26 07:34:28","","2","160","<p>i want to run part of my logic after my subscription with an additional delay (with RxJS). I know about the finalize operator, which i could use with a pipe, but that would lead to an immediate execution after the completion of my observable.</p>
<p>Is there a way to create a delay before running finalize?</p>
<p>Additional information:</p>
<p>I am subscribing to a server call, meaning i am only expecting one value.</p>
","3410232","","","","","2020-07-26 07:43:43","How can I run delayed logic with rxjs after receiving a value from a subscription?","<javascript><typescript><rxjs><delay><rxjs6>","1","2","","","","CC BY-SA 4.0"
"63117082","1","63122575","","2020-07-27 14:06:58","","0","322","<p>I have two separate but overlapping user interaction flows that both trigger the same action. If one flow is started, the other one should not start until the first is complete. I'm probably overthinking this but I can't find a pattern that does what I want.</p>
<p><strong>Concrete example:</strong></p>
<p>I want to open a context menu for a selection in a text area with two separate interaction flows:</p>
<ol>
<li>Via Mouse: Mouse Down -&gt; Selection Changed -&gt; Mouse Up</li>
<li>Via Keyboard: Selection Changed -&gt; Timeout(500ms)</li>
</ol>
<p>As you can see, both flows overlap in the &quot;Selection Changed&quot; part, but the first and final conditions are different. When selecting with the keyboard, there is no definite end condition, so I rely on a timer. When selecting with the mouse there <em>is</em> a definite end condition (Mouse Up), so I want to show the menu immediately. Both are defined as separate Observables that complete on their end condition.</p>
<p>To differentiate between the two, I want to wait for whichever observable emits first and then only listen to that observable until it completes and then start again. So when there is a Mouse Down event I want to wait for the Mouse Up event to trigger. When there is a selection change without the Mouse Down, I start the timeout.</p>
<p><strong>Things I tried:</strong></p>
<p><strong>exhaust/exhaustMap:</strong> That is technically what I want (follow one Observable to the end before considering the next) but those don't take a list of Observables but a function that emits observables. My observables are fixed though. I don't know how to wire this up to do what I want.</p>
<p><strong>race:</strong> I can pass in a list of observables and whatever emits first is then followed through until the end. However, it won't resubscribe when it completes. <code>race()</code> simply completes and that's that. I tried something like this:</p>
<pre><code>const openMenu$ = of(true).pipe(
  startWith(race(a$, b$)),
  exhaust(),
  repeat()
);
</code></pre>
<p>or</p>
<pre><code>const openMenu$ = of(true).pipe(
  exhaustMap(() =&gt; race(a$, b$)),
  exhaust(),
  repeat()
);
</code></pre>
<p>or</p>
<pre><code>const openMenu$ = race(a$, b$).pipe(
  repeat()
);
</code></pre>
<p>but all of these just repeat the first Observable over and over. I found no way to restart the race.</p>
<p>Any ideas? Or am I going at this completely wrong?</p>
","3756015","","","","","2020-07-27 19:53:31","RxJS: repeatable race between Observables","<rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"63171295","1","63594039","","2020-07-30 10:30:58","","12","4392","<p><img src=""https://i.stack.imgur.com/qA4mX.png"" alt=""enter image description here"" /></p>
<p>I'm getting this issue after build successfully and run on browser with angular universal</p>
<p>Here is my package json :</p>
<pre><code>{
  &quot;name&quot;: &quot;ssr&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;@angular/animations&quot;: &quot;10.0.5&quot;,
    &quot;@angular/cdk&quot;: &quot;10.1.0&quot;,
    &quot;@angular/common&quot;: &quot;10.0.5&quot;,
    &quot;@angular/compiler&quot;: &quot;10.0.5&quot;,
    &quot;@angular/core&quot;: &quot;10.0.5&quot;,
    &quot;@angular/fire&quot;: &quot;^6.0.2&quot;,
    &quot;@angular/forms&quot;: &quot;10.0.5&quot;,
    &quot;@angular/http&quot;: &quot;^7.2.16&quot;,
    &quot;@angular/localize&quot;: &quot;^10.0.5&quot;,
    &quot;@angular/material&quot;: &quot;10.1.0&quot;,
    &quot;@angular/material-moment-adapter&quot;: &quot;10.1.0&quot;,
    &quot;@angular/platform-browser&quot;: &quot;10.0.5&quot;,
    &quot;@angular/platform-browser-dynamic&quot;: &quot;10.0.5&quot;,
    &quot;@angular/platform-server&quot;: &quot;^10.0.5&quot;,
    &quot;@angular/router&quot;: &quot;10.0.5&quot;,
    &quot;@ng-bootstrap/ng-bootstrap&quot;: &quot;^7.0.0&quot;,
    &quot;@ng-toolkit/universal&quot;: &quot;^8.1.0&quot;,
    &quot;@nguniversal/express-engine&quot;: &quot;^10.0.1&quot;,
    &quot;@types/jquery&quot;: &quot;^3.5.1&quot;,
    &quot;@types/node&quot;: &quot;^8.10.62&quot;,
    &quot;angular-in-memory-web-api&quot;: &quot;^0.11.0&quot;,
    &quot;angular-ng-autocomplete&quot;: &quot;^2.0.1&quot;,
    &quot;classlist.js&quot;: &quot;^1.1.20150312&quot;,
    &quot;codelyzer&quot;: &quot;^6.0.0&quot;,
    &quot;core-js&quot;: &quot;2.6.9&quot;,
    &quot;crypto-js&quot;: &quot;^3.3.0&quot;,
    &quot;express&quot;: &quot;^4.15.2&quot;,
    &quot;firebase&quot;: &quot;^7.17.1&quot;,
    &quot;hammerjs&quot;: &quot;^2.0.8&quot;,
    &quot;jquery&quot;: &quot;^3.5.1&quot;,
    &quot;localstorage-polyfill&quot;: &quot;^1.0.1&quot;,
    &quot;moment&quot;: &quot;2.24.0&quot;,
    &quot;ng2-slim-loading-bar&quot;: &quot;^4.0.0&quot;,
    &quot;ng5-slider&quot;: &quot;^1.1.14&quot;,
    &quot;ngx-order-pipe&quot;: &quot;^2.0.4&quot;,
    &quot;ngx-pagination&quot;: &quot;^3.2.1&quot;,
    &quot;ngx-spinner&quot;: &quot;^10.0.1&quot;,
    &quot;rxjs&quot;: &quot;^6.6.0&quot;,
    &quot;rxjs-compat&quot;: &quot;^6.6.0&quot;,
    &quot;sweetalert2&quot;: &quot;^8.19.0&quot;,
    &quot;tslib&quot;: &quot;^1.13.0&quot;,
    &quot;web-animations-js&quot;: &quot;^2.3.2&quot;,
    &quot;whatwg-fetch&quot;: &quot;^3.2.0&quot;,
    &quot;zone.js&quot;: &quot;0.10.3&quot;
  },
</code></pre>
","9363670","","12892553","","2021-09-17 09:18:34","2021-09-17 09:18:34","ERROR Error: Uncaught (in promise): TypeError: i.BehaviorSubject is not a constructor in Angular 10 SSR","<server-side-rendering><angular-universal><rxjs6><commonjs><angular10>","5","2","","","","CC BY-SA 4.0"
"63178596","1","63180930","","2020-07-30 17:46:22","","1","184","<p>I've started porting some async logic to redux-observables and I'm struggling a little with this.</p>
<p>My use case is this:
I have a UI overlay that's supposed to open on an <code>OPEN_OVERLAY</code> action, and automatically close after three seconds (by emitting <code>CLOSE_OVERLAY</code>) UNLESS either an <code>INTERRUPT_CLOSE_OVERLAY1</code> or <code>INTERRUPT_CLOSE_OVERLAY2</code> action is received, in which case the overlay shouldn't close.</p>
<p>My first take was this:</p>
<pre><code>export const epic = action$ =&gt; action$.pipe(
    filter(action =&gt; action.type === &quot;OPEN_OVERLAY&quot;), 
    delay(3000), 
    takeUntil(action$.ofType(&quot;INTERRUPT_CLOSE_OVERLAY1&quot;, &quot;INTERRUPT_CLOSE_OVERLAY2&quot;)),
    mapTo({type: &quot;CLOSE_OVERLAY})
);
</code></pre>
<p>Which works, but just once. That is, if you open the overlay and interrupt it, then after closing and opening it again it will never auto-close.</p>
<p>I understand that this happens because <code>takeUntil</code> effectively unsubscribes from the Observable. However the way I understand it with redux-observables you only define the epic once at setup and you're not supposed to be subscribing/unsubscribing.</p>
<p>So, how would I structure this that open/close/autoclose always works without unsubscribing?</p>
","954514","","","","","2020-07-30 20:30:11","What alternatives are there to takeUntil with redux-observable and RxJS","<rxjs><rxjs6><redux-observable>","1","0","","","","CC BY-SA 4.0"
"63185734","1","63191757","","2020-07-31 04:17:43","","1","48","<p>I have this custom child component in the template of a parent component:</p>
<p>parent html:</p>
<pre><code>&lt;cb-filter-chip-list [(filter-chips$)]=&quot;$ctrl.filterChips$&quot;
                     [(filter-chip-adds)]=&quot;$ctrl.filterChipAdds&quot;
                     [(filter-chip-deletes)]=&quot;$ctrl.filterChipDeletes&quot;
                     [(current-chip-count)]=&quot;$ctrl.currentChipCount&quot;
                     (update-data-behind-filter-chips)=&quot;$ctrl.updateDataBehindFilterChips($event)&quot;&gt;
&lt;/cb-filter-chip-list&gt;
</code></pre>
<p>parent ts:</p>
<pre><code>public filterChips$ = new BehaviorSubject&lt;Array&lt;FilterChip&gt;&gt;(undefined);
public filterChipAdds = new ReplaySubject&lt;any&gt;(10);
public filterChipDeletes = new Subject();
</code></pre>
<p>child ts:</p>
<pre><code>export class FilterChipListComponent implements OnInit {
    @Input() public filterChips$: BehaviorSubject&lt;Array&lt;FilterChip&gt;&gt;;
    @Input() public filterChipAdds: BehaviorSubject&lt;any&gt;;
    @Input() public filterChipDeletes: Subject&lt;any&gt;;
    @Output() public updateDataBehindFilterChips = new EventEmitter&lt;FilterChip[]&gt;();
    createChip: Observable&lt;any&gt;;
    deleteChip: Observable&lt;any&gt;;
    chipVariations: Observable&lt;unknown&gt;;
    @Input() public currentChipCount: any;

    constructor() { }

    public ngOnInit(): void {
        this.createChip = this.filterChipAdds.pipe(map(chip =&gt; ([{ ...chip, action: 'add' }])));
        this.deleteChip = this.filterChipDeletes.pipe(
            tap((chipId) =&gt; this.updateDataBehindFilterChips.emit(chipId)),
            map(chipId =&gt; ([{ id: chipId, action: 'delete' }])));
        this.chipVariations = merge(this.createChip, this.deleteChip);
        this.currentChipCount = this.chipVariations.pipe(
           // startWith(this.filterChips$.value),
            scan((totalCurrentChips: FilterChip[], changeInChips: ChipAction) =&gt; {
                if (changeInChips[0].action === 'add') {
                    if (totalCurrentChips.some(tcc =&gt; tcc.id === changeInChips[0].id)) {
                        totalCurrentChips.forEach(element =&gt; {
                            if (element.id === changeInChips[0].id) {
                                element.text = changeInChips[0].text;
                            }
                        });
                    } else {
                        totalCurrentChips.push(changeInChips[0]);
                    }
                } else if (changeInChips[0].action === 'delete') {
                    totalCurrentChips = totalCurrentChips.filter(chip =&gt; chip.id !== changeInChips[0].id);
                }
                return totalCurrentChips.sort((a, b) =&gt; a.sortOrder - b.sortOrder);
            })
        );

        // console.log(this.filterChipAdds);
        this.currentChipCount.subscribe();
        this.filterChipAdds.subscribe(x =&gt; console.log(&quot;fc&quot;, x));
    }
}
</code></pre>
<p>In the parent I make it emit by doing this:</p>
<pre><code>this.filterChipAdds.next({
                id: &quot;fromDate&quot;,
                sortOrder: 4,
                text: `From Date - ${this.datePipe.transform(this.userCacheItem.silentData.fromDate, &quot;dd MMM yyyy&quot;)
                    }`
            });
</code></pre>
<p>For some reason the <code>this.filterChipAdds.subscribe(console.log);</code> on the parent console logs the values being emitted, but the <code>this.filterChipAdds.subscribe(x =&gt; console.log(&quot;fc&quot;, x));</code> doesn't log anything. nothing emits on the child. even though it should technically emit for both since it is a two way data binding. Why is the emission not mirrored on the child component?</p>
","3935156","","","","","2020-07-31 14:35:58","Angular - 2 way data binding rxjs subject property, never emits on the child, yet emits on the parent","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"63187365","1","","","2020-07-31 07:15:14","","0","106","<p>I have a service file having a function call with rxjs debounce time, when on writing the spec for the same, the execution context is not reaching to the service file from running the test, but on commenting the  <code>debounceTime(1000)</code> then the spec works resulting in success expectation, And I can not remove the debounceTime for the spec purpose.</p>
<p>what I have tried : I have tried to add tick, fackAsync, flush combinations, but no clue what is the issue.</p>
<p>Here is the detailed code and screenshot for easy understanding</p>
<pre><code>const saveQuestion$ = this.assessmentDetailMiddleware$.pipe(
      filter(filterForQuestionSave),
      debounceTime(1000), //THIS IS CAUSING THE ISSUE, if i remove this, it will work. but it is needed
      rxMap(() =&gt; of(checkIfSupposedToTriggerTheSave())),
      switchMap(triggerSave =&gt; (!!triggerSave ? this.saveSectionResponses() : NEVER)),
      rxMap((assessmentModel: IAssessmentModel) =&gt;
        assessmentModel
          ? this.assessmentDetailAdapter.convertAssessmentStructure(assessmentModel)
          : false
      ),
      tap(
        (assessmentModel: IAssessmentModel) =&gt;
          assessmentModel &amp;&amp; handleSectionUpdatesToStore(assessmentModel)
      ),
      catchError(error =&gt; {
        console.log('First this should display'); //THIS IS NOT GETTING DISPLAYED
        this.aaDetailSaveHelperStoreService.saveInProgress(false);
        return throwError(error);
      })
    );
</code></pre>
<p>My unit test spec</p>
<pre><code> fit('should call saveInProgress on catchError', fakeAsync(() =&gt; {
        mockAaDetailSaveHelperStoreService.getSaveMetada.and.returnValue({
          questionIdsToSave: [1],
          subQuestionIdsToSave: [1],
        });        
        mockAaDetailSaveHelperStoreService.saving.and.returnValue(true);
        const spySaveSectionResponses = spyOn(service, 'saveSectionResponses');
        spySaveSectionResponses.and.returnValues(throwError('error 2'));
        const action = {
          type: 'SAVE_QUESTION',
          payload: () =&gt; Promise.resolve,
        };

        service.assessmentDetailMiddleware$.subscribe(data =&gt; {
          //  expect(true).toBe(true);
          console.log('now display this : ');
          expect(mockAaDetailSaveHelperStoreService.saveInProgress).toHaveBeenCalled(); //THIS IS NOT DETECTED, SINCE THE EXECUTION NOT REACHED THE SERVICE FILE DUE TO `debounceTime(1000)`.  
          //expect(true).toBe(true);
          flush();
          //
        });
        flush();
        tick(1000);
        service.assessmentDetailMiddleware$.next(action);
        discardPeriodicTasks();
      }));
    })
</code></pre>
<p>Now the problem is the flow of execution is coming like , first the console inside .spec is displayed WITHOUT displaying the console inside spec, due to this the expectation is not deetcted.</p>
<p><a href=""https://i.stack.imgur.com/UGsvZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UGsvZ.png"" alt=""Screenshot"" /></a></p>
<p>Now here is the success spec, WITHOUT debounceTime, and it is working</p>
<pre><code>const saveQuestion$ = this.assessmentDetailMiddleware$.pipe(
      filter(filterForQuestionSave),
      //debounceTime(1000), //NOW spec WORKS,
      rxMap(() =&gt; of(checkIfSupposedToTriggerTheSave())),
      switchMap(triggerSave =&gt; (!!triggerSave ? this.saveSectionResponses() : NEVER)),
      rxMap((assessmentModel: IAssessmentModel) =&gt;
        assessmentModel
          ? this.assessmentDetailAdapter.convertAssessmentStructure(assessmentModel)
          : false
      ),
      tap(
        (assessmentModel: IAssessmentModel) =&gt;
          assessmentModel &amp;&amp; handleSectionUpdatesToStore(assessmentModel)
      ),
      catchError(error =&gt; {
        console.log('First this should display');
        this.aaDetailSaveHelperStoreService.saveInProgress(false);
        return throwError(error);
      })
    );
</code></pre>
<p>Please Let me know if need more info</p>
<p><a href=""https://i.stack.imgur.com/628H0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/628H0.png"" alt=""Success"" /></a></p>
","665864","","","","","2020-07-31 07:38:43","Jasmine unit test Spec on debounceTime with tick and flush, execution context not reaching the service file","<angular><unit-testing><jasmine><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"63252170","1","","","2020-08-04 17:30:54","","0","214","<p>I have a service that returns an array of objects as an observable, a list of countries with objects with the country name and three-letter code,
<code>countries$ = this.mockData.get('countries.json');</code></p>
<p>If I have a 3-letter code for a country, I want to be able to filter the observable and return the matching name.  For example if I have &quot;GBR&quot; I want to return &quot;United Kingdom of Great Britain and Northern Ireland&quot;</p>
<p>I have tried this,</p>
<pre><code>  getfullCountryName() {
    const name = this.countries$.pipe(filter((c) =&gt; c.alpha3 === 'GBR'));
    console.log('name =', name);
    
    return name;
  }
</code></pre>
<p>but I must be forgetting something, since all I get in console is
<code>name =  Observable {_isScalar: false, source: Observable, operator: FilterOperator}</code></p>
<p>What am I leaving off?</p>
<p><code>countries$</code> is a type of Country</p>
<pre><code>export interface Country {
  numeric: string;
  alpha2: string;
  alpha3: string;
  name: string;
}
</code></pre>
<p>where should I put the type <code>&lt; &gt;</code> in that expression to get typings. e.g. that <code>c</code> has an attribute <code>alpha3</code></p>
","187835","","187835","","2020-08-04 17:57:11","2021-05-16 08:09:51","Angular RXJS 6: filter observable array for items matching object key","<angular><filter><observable><rxjs6>","1","4","","","","CC BY-SA 4.0"
"63271187","1","","","2020-08-05 18:13:42","","0","43","<p>I am testing some of the rxjs operators I stuck in particular problems</p>
<p>What I have is:</p>
<pre><code>export interface User{
   id: number;
   name: string;
}
export interface PersonalDetail {
   id: number;
   dob: Date;
}
export interface UserDetail {
   id: number;
   name: string;
   dob: Date;
}

this.userService() // return Observable&lt;User[]&gt;
this.userService.getUsersPersonalDataById(id) // return Observable&lt;PersonalDetail&gt;
</code></pre>
<p>What I am doing like this but it evaluates one by one</p>
<pre><code>this.users: UserDetail[] = [];
this.userService.getAllusers().pipe(
   concatMap((result: User[]) =&gt;
      from(result).pipe(
         concatMap(u =&gt; this.userService.getUsersPersonalDataById(u.id).pipe(
              map((p: PersonalDetail) =&gt; ({...u, ...p} as UserDetail)))
            )
         )
    )
).subscribe((res: UserDetail) =&gt; {
        this.users.push(res);
        console.log(res);
})
</code></pre>
<p>But it evaluates One By One what I actually need</p>
<pre><code>this.userService.getAllusers().pipe(
   concatMap((result: User[]) =&gt;
         from(result).pipe(
             concatMap(u =&gt; this.userService.getUsersPersonalDataById(u.id).pipe(
                map((p: PersonalDetail) =&gt; ({...u, ...p} as UserDetail))
             )
          )
     )
     // some code to return UserDetail[]
   )
).subscribe((res: UserDetail[]) =&gt; {
        this.users = res;
        console.log(res);
})
</code></pre>
","7965329","","12708583","","2020-08-18 01:44:10","2020-08-18 04:13:56","How to get merged Object with inner observable by using pipe operator","<angular><typescript><rxjs6>","1","0","","","","CC BY-SA 4.0"
"63271524","1","","","2020-08-05 18:35:38","","0","36","<p>I'm having trouble sequencing tiers of computation in my app. I'm using an Akita entity store to manage state and then observing changes and piping them through observables to generate the UI state. The overall flow is:</p>
<pre><code>EntityStore.selectAll()
  -&gt; pluck A  \     /  combineLatest(A, B) -&gt; map Q
  -&gt; pluck B  |    |   combineLatest(A, C) -&gt; map R
  -&gt; pluck C  |-&gt; -|   combineLatest(B, E) -&gt; map S
     ...      |    |   ...
  -&gt; pluck N  /     \  combineLatest(C, D) -&gt; map Z
</code></pre>
<p>(Assume distinctUntilChanged after each operator).</p>
<p>How do I ensure that A..N are calculated before any of their combinations? Ideally all in a single macro-cycle so the UI doesn't update with partial results.</p>
<p>I tried adding <code>asapScheduler</code> as the last parameter on combineLatest, but it doesn't seem to work, with some inputs updating before combineLatest is called and some after triggering more calls.</p>
<p>I'd also like to be able to add another level of combinations:</p>
<pre><code>EntityStore.selectAll()
  -&gt; pluck A  \     /  combineLatest(A, B) -&gt; map Q   \     / combineLatest(Q, R) -&gt; map W
  -&gt; pluck B  |    |   combineLatest(A, C) -&gt; map R   |    |  combineLatest(Q, S) -&gt; map X
  -&gt; pluck C  |-&gt; -|   combineLatest(B, E) -&gt; map S   |-&gt; -|  combineLatest(S, T) -&gt; map Y
     ...      |    |   ...                            |    |  ...                         
  -&gt; pluck N  /     \  combineLatest(C, D) -&gt; map U   /     \ combineLatest(R, U) -&gt; map Z
</code></pre>
<p>How do I ensure that A..N are all calculated before Q..U and similarly, Q..U before W..Z?</p>
","2487330","","","","","2020-08-05 18:35:38","Sequencing Observables with Schedulers","<angular><rxjs><rxjs6><angular-akita><akita>","0","4","","","","CC BY-SA 4.0"
"63272301","1","","","2020-08-05 19:29:35","","2","161","<p>Input Observable stream:
The data is obtained from an observable stream that is the result of a REST request for projects. The data is obtained as Observable&lt;Project[]&gt;.</p>
<pre><code>     const project1: Project = {
        id: 1,
        title: 'zebra',
        rootId: 1,
      }
    
      const project2: Project = {
        id: 2,
        title: 'algebra',
        rootId: 2,
      }
    
      const project3: Project = {
        id: 3,
        title: 'Bobcats',
        rootId: 1,
      }
    
      const project4: Project = {
        id: 4,
        rootId: 2,
      }
    
      const project5: Project = {
        id: 5,
        title: 'Marigolds',
        rootId: 1,
      }
    
      const project6: Project = {
        id: 6,
        title: 'whatever',
        rootId: null,
      }
    
      const project7: Project = {
        id: 7,
        title: 'peppercorns',
        rootId: null,
      }
    
    let groupProjects: Observable&lt;ProjectSummary[]&gt; 
= getGroupProjects(of([project1, project2, project3, project4, project5, project6, project7]]));
    
      getGroupProjects(projects$: Observable&lt;ProjectSummary[]&gt;): Observable&lt;ProjectSummary[]&gt; {
        const timer$ = timer(5000);
        const data = projects$.pipe(takeUntil(timer$), flatMap(projects =&gt; projects));
        const groupedObservables = data.pipe(
          groupBy(projects =&gt; projects.rootId),
          tap( a =&gt; console.log('groupBy:' + a.key))
        );
        const merged = groupedObservables.pipe(
          mergeMap(a =&gt; a.pipe(toArray())),
          shareReplay(1),
          tap( a =&gt; console.log('final:' + JSON.stringify(a)))
        );
        return merged;
      }
</code></pre>
<p>The desired output is:</p>
<pre><code>Object{  //Root of 1
  id: 1,
  title: 'zebra',
  rootId: null
}
Object{
  id: 3, //child of 1
  title: 'Bobcats',
  rootId: 1
} 
Object{
  id: 5, //child of 1
  title: 'Marigolds',
  rootId: 1
}
Object{
  id: 2, //root of 2
  title: 'algebra',
  rootId: 2
}
Object{
  id: 4,  //child of 2
  title: 'dogs',
  rootId: 2
}
Object{
  id: 6,  //unaffiliated
  title: 'whatever',
  rootId: null
}
Object{
  id: 7, //unaffiliated
  title: 'peppercorns',
  rootId: null
}
</code></pre>
<p>The requirement is that groups identified by rootId appear in sequence before their children (children appear after their root) and unaffiliated are listed together. roots are identified when id = rootId, children are identified when rootId != null &amp;&amp; id != rootId. Unaffiliated are identified by null root id.</p>
<p>Currently only the last group is emitted. How can I return an observable that emits all groups and in correct sequence? --thanks</p>
","124558","","124558","","2020-08-05 21:46:53","2020-08-06 01:03:43","How can I Use RxJs 6 GroupBy to organize stream? Need to concatenate all emissions from multiple Grouped Observables","<javascript><typescript><angular8><rxjs6>","1","2","","","","CC BY-SA 4.0"
"63305395","1","63308687","","2020-08-07 16:02:20","","0","138","<p><strong>StackBlitz:</strong> <a href=""https://stackblitz.com/edit/angular-ivy-s8mzka"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ivy-s8mzka</a></p>
<p>I have an Angular template that subscribes to an Observable using the <code>async</code> pipe. This Observable is created by:</p>
<ol>
<li>Subscribing to an NgRx Store Selector (that gives us selected user filters)</li>
<li>Switch-mapping to an API request with the selected user filters</li>
<li>Performing several operatos like <code>map</code>, <code>filter</code> etc. after the <code>switchMap</code></li>
<li>The steps 2 and 3 could repeat any amount of times</li>
</ol>
<p>The API request in <code>switchMap</code> can fail for several reasons, which might produce an error notification.</p>
<p>We want to handle that error by showing an error alert. This error alert should also be shown by subscribing to an Observable using the <code>async</code> pipe. This angry-path Observable should directly derive from the happy-path Observable without the use of intermediate Subjects or any other side effects.</p>
<p>Problems we've encountered with proposed solutions:</p>
<ul>
<li><code>catchError</code> or <code>materialize</code> inside <code>switchMap</code>: Wrapping the error in another object changes the data structure of the notification and makes using the following filters like <code>map</code>, <code>filter</code> etc. very hard. Operators like <code>debounceTime</code> or <code>delay</code> can't immediately forward the error because it's treated as a <code>next</code> notification.</li>
<li><code>retry</code>: Given that the source Observable is a replaying Subject, this will trigger a new API call on every re-subscribe, leading to an endless loop if the server keeps responding with errors. Also, we can't really forward the error notification using <code>retry</code>.</li>
<li>Dispatching actions, nexting a Subject or setting <code>this.error</code> inside a <code>tap</code>: Creating side effects like that for a trivial use-case like this seems unnecessary and go against functional design principles.</li>
</ul>
<p><strong>product.service.ts</strong></p>
<pre><code>getProducts$() {
  return this.store.select(selectProductFilters).pipe(
    switchMap(filters =&gt; this.http.get(&quot;/api/products?&quot; + encodeFilters(filters))
    // ... map, filter, delay
  );
}
</code></pre>
<p><strong>products.component.ts</strong></p>
<pre><code>products$: Observable&lt;Product[]&gt;
error$: Observable&lt;string&gt;

ngOnInit() {
  this.products$ = this.productService.getProducts$();
  
  this.error$ = this.products$.pipe(
    // what can we do here to get errors as notifications
  );
}
</code></pre>
<p><strong>products.component.html</strong></p>
<pre><code>&lt;div *ngIf=&quot;(products$ | async) as products&quot;&gt;{{products | json}}&lt;/div&gt;
&lt;div class=&quot;error&quot; *ngIf=&quot;(error$ | async) as error&quot;&gt;{{error}}&lt;/div&gt;
</code></pre>
<p>So the question is:</p>
<p>How can we create two Observables for our template: One that emits <code>next</code> notifications and one that emits <code>error</code> notifications while keeping the source Observable alive after errors?</p>
<p><strong>EDIT</strong></p>
<p>We're looking for a very general solution for this - the above example uses just one <code>switchMap</code>, but the solution should be applicable for any Observable pipeline. For example, imagine the Service looked like this:</p>
<p><strong>product.service.ts</strong></p>
<pre><code>getProducts$() {
  return this.store.select(selectProductFilters).pipe(
    switchMap(filters =&gt; this.http.get(&quot;/api/products?&quot; + encodeFilters(filters))
    // ... map, filter, delay
    switchMap(...)
    // ... map, filter, delay
    switchMap(...)
  );
}
</code></pre>
<p>The solution should be able to handle errors in any of these <code>switchMap</code> statements and propagate them to the template.</p>
","7247920","","7247920","","2020-08-07 20:50:10","2020-08-07 21:43:44","Handling errors for replaying, long-living Observables","<angular><typescript><rxjs><ngrx><rxjs6>","1","2","","","","CC BY-SA 4.0"
"63316478","1","63317510","","2020-08-08 14:25:44","","0","73","<p>I am trying to use the merge operator is given below. I want to put only 'Mr' before login but I am getting an error, your help is much appreciated, thank you</p>
<pre><code>  let data=this.http.get('https://api.github.com/users');
  let output=data.pipe(map(data=&gt;{'Mr, '+data.login}));
            output.subscribe(data=&gt;{
  console.log(data);
})
</code></pre>
","4747554","","1188074","","2020-08-09 01:25:22","2020-08-09 01:25:22","How do I map a list of objects from an HTTP API to a list of strings?","<angular><rxjs><rxjs5><rxjs6><rxjs-pipeable-operators>","2","1","","2020-08-09 01:29:02","","CC BY-SA 4.0"
"63381609","1","","","2020-08-12 17:13:37","","0","34","<p>Since i was with angular9 and ivy compiler enable false.Everything was working fine.But after upgraded app to angular v10 and getting rxjs related operator and observable related getting compile error.</p>
<p><strong>Before</strong>:</p>
<p>&quot;rxjs&quot;: &quot;^6.5.5&quot;,
&quot;rxjs-compat&quot;: &quot;^6.5.5&quot;</p>
<p><strong>After</strong>(now rxjs-compat removed):</p>
<p>&quot;rxjs&quot;: &quot;^6.6.2&quot;</p>
<p><strong>Error:</strong></p>
<pre><code> error TS2339: Property 'filter' does not exist on type 'Observable&lt;any&gt;'.
</code></pre>
<p><strong>Code:</strong></p>
<pre><code> let fromdate$ = of(fromdatevalue)
          let fromdateIfNull = fromdate$.filter(date =&gt; date != null)
            .map(date =&gt; {
              let fromdate = new Date(fromdatevalue);
              fromdate.setHours(8, 0, 0, 0);
              return fromdate;
            })
</code></pre>
<p>How to solve error and i want with properly use of <code>rxjs</code> import in angular v10 app.</p>
<p>Thanks.</p>
","9948050","","","","","2020-08-12 17:13:37","Property 'filter' does not exist on type 'Observable<any>'. rxjs v6","<javascript><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","0","7","","","","CC BY-SA 4.0"
"63409687","1","63411140","","2020-08-14 08:59:01","","0","709","<pre><code>&lt;input 
  type=&quot;text&quot; 
  class=&quot;form-control&quot; 
  id=&quot;search-text&quot; 
  [(ngModel)]=&quot;searchText&quot; 
  placeholder=&quot;Enter text to search&quot;
  autofocus
&gt;
&lt;div class=&quot;dropdown-divider m-0&quot;&gt;&lt;/div&gt;

&lt;ul class=&quot;list-group list-group-flush&quot; *ngIf=&quot;users$ | async as users&quot;&gt;
  &lt;li class=&quot;list-group-item d-flex justify-content-between align-items-center card-body__headings&quot;&gt;
    &lt;span class=&quot;float-left&quot;&gt;{{(users$| async)?.length}} users&lt;/span&gt;
  &lt;/li&gt;

  &lt;li 
    class=&quot;list-group-item d-flex justify-content-between align-items-center&quot; 
    routerLink=&quot;userdetail&quot;
    *ngFor=&quot;let user of users | search: searchText &quot;
  &gt;
    +++{{user | json}}
    &lt;span class=&quot;float-left w-100&quot;&gt;
              &lt;p class=&quot;user-initial&quot;&gt;{{user.NAME_INITIALS }}&lt;/p&gt;
              &lt;em class=&quot;list-group-item__detail&quot;&gt;
                {{user.FIRSTNAME}} {{user.LASTNAME}}
                &lt;br/&gt;
                &lt;em class=&quot;list-group-item__email&quot;&gt;{{user.EMAIL}}&lt;/em&gt;
              &lt;/em&gt;
            &lt;/span&gt;

    &lt;span class=&quot;badge&quot;&gt;
      &lt;ish-icon icon=&quot;user.remove&quot; cssClass=&quot;action-icon&quot;&gt;&lt;/ish-icon&gt;
     &lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>where search is the pipe for filtering the data. When i inspected in filter it is returning me the proper search result but it's not rendering on UI. Means the search result is not rendering.</p>
","2160340","","6823766","","2020-08-14 09:47:19","2020-08-14 10:36:46","Angular 9 Async pipe and search filter","<angular><rxjs6><angular-filters><angular-pipe>","1","2","","","","CC BY-SA 4.0"
"63491389","1","63492139","","2020-08-19 16:39:27","","1","83","<p>Theoretically, I know what mergeMap is and how it works, but when I try to understand using
practical approach I get confused, this is what I have done so far</p>
<pre><code>const input1$= of(&quot;value 1&quot;,&quot;value 2&quot;,&quot;value 3&quot;);
const input2$= of(1,2,3,4);
const obs=input1$.pipe(
            mergeMap(data1=&gt;{
              return input2$
              .pipe(map(ch=&gt;{ch+' '+data1}))})
        )   
</code></pre>
<p>unfortunately, I am getting undefined when I try to merge them, your help would be appreciated to make me understand how it works.</p>
","4747554","","","","","2020-08-19 17:30:55","undefined output while using mergeMap in Rxjs","<angular><rxjs><rxjs5><rxjs6><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"63510821","1","63513016","","2020-08-20 18:01:23","","1","58","<p>My app has a modal with a spinner that's displayed whenever a long blocking action is taking place.
There's several of these long blocking actions, each with an action that marks its start and finish.</p>
<p>Given the &quot;stream of actions&quot;, whenever one of the start action is dispatched, I want to dispatch the <code>showWaitingIndication</code> action until the corresponding end action is dispatched and then dispatch <code>hideWaitingIndication</code>. If another start action is dispatched and then it's corresponding end action is dispatched while the first blocking action is in progress, it shouldn't call <code>showWaitingIndication</code> again or <code>hideWaitingIndication</code>. Nor should <code>hideWaitingIndication</code> be dispatched while an action is still active.</p>
<p>Basically the idea is that as long as a blocking action is active, the waiting indication shouldn't hide.</p>
<p>e.g.</p>
<p><code>StartA</code> -&gt; dispatch(<code>showWaitingIndication</code>) -&gt; other events -&gt; <code>endA</code> -&gt; dispatch(<code>hideWaitingIndication</code>)</p>
<p><code>StartA</code> -&gt; dispatch(<code>showWaitingIndication</code>) -&gt; <code>startB</code> -&gt; <code>endB</code> (shouldn't call hide) -&gt; <code>endA</code> -&gt; dispatch(<code>hideWaitingIndication</code>)</p>
<p>Also
<code>StartA</code> -&gt; dispatch(<code>showWaitingIndication</code>) -&gt; <code>startB</code> -&gt; <code>endA</code> (shouldn't call hide!) -&gt; <code>endB</code> -&gt; dispatch(<code>hideWaitingIndication</code>)</p>
<p>I'm trying to wrap my head around how to implement this with streams (which I strongly believe are a good fit for this issue).</p>
<p>So far I've come up with something like this (which doesn't work)</p>
<pre><code>    let showHideActionPairs = getShowHideActionPairs(); // { &quot;startA&quot;: &quot;endA&quot;, &quot;startB&quot;: &quot;endB&quot;}
    let showActions  = Object.keys(showHideActionPairs);

    return action$ =&gt; action$.pipe(
        filter(action =&gt; Object.keys(showHideActionPairs).includes(action.type)),
        switchMap(val =&gt;
            {
                let hideAction = showHideActionPairs[val.type];
                return concat(
                    of(waitingIndicationShowAction),
                    empty().pipe(
                            ofType(hideAction),
                            mapTo(waitingIndicationHideAction)
                    ))
            }
        )
    );
</code></pre>
<p>What's the proper way of doing this?</p>
","954514","","954514","","2020-08-20 19:19:51","2020-08-23 13:12:23","Non-strict sequences with redux-observable and RxJS","<rxjs><rxjs6><redux-observable>","2","4","","","","CC BY-SA 4.0"
"63531645","1","63592339","","2020-08-22 01:04:39","","1","97","<p>I have a <code>Subject</code> that receives objects and then makes a call to a function that I have wrapped with <code>bindNodeCallback</code>. I'd like to retry execution of that function, using <code>retryWhen</code>, if it fails due to an error or if the result comes back false.</p>
<p>I've tried a few different approaches but haven't been successful at getting the bound function to fire off again.</p>
<p>I have a <a href=""https://codesandbox.io/s/youthful-wave-u5bhx?file=/src/index.ts"" rel=""nofollow noreferrer"">codesandbox setup here</a>.</p>
<pre class=""lang-js prettyprint-override""><code>function fakeSend(
  task: string,
  cb: (err: Error | null, result?: boolean) =&gt; void
) {
  console.log(&quot;fakesend&quot;, task);

  setTimeout(() =&gt; {
    const hasError = Math.random() &lt; 0.5;
    const res = Math.random() &lt; 0.5;
    console.log(hasError ? &quot;hasError&quot; : `responding with ${res}`);
    if (hasError) {
      return cb(new Error(&quot;error&quot;));
    }
    return cb(null, res);
  }, 100);
}

const boundSend = bindNodeCallback(fakeSend);
const subject = new Subject&lt;string&gt;();

subject.subscribe(
  (task) =&gt; {
    boundSend(task)
      .pipe(
        tap((status) =&gt; {
          if (!status) {
            throw new Error(&quot;Did not send&quot;);
          }
          return status;
        }),
        retryWhen((errs) =&gt;
          errs.pipe(
            delay(1000),
            tap((err) =&gt; console.log)
          )
        )
      )
      .subscribe({
        next: console.log,
        error: console.error,
        complete: () =&gt; {
          console.log(&quot;complete&quot;, task);
        }
      });
  },
  (error) =&gt; {
    console.log(&quot;error in subject subscribe&quot;);
  }
);

subject.next(&quot;test1&quot;);
subject.next(&quot;test2&quot;);
subject.next(&quot;test3&quot;);
subject.next(&quot;test4&quot;);

  
</code></pre>
<p>Thanks!</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const { Subject, bindNodeCallback } = rxjs;
const { tap, retryWhen, delay } = rxjs.operators;

function fakeSend(
  task,
  cb
) {
  console.log(""fakesend"", task);

  setTimeout(() =&gt; {
    const hasError = Math.random() &lt; 0.5;
    const res = Math.random() &lt; 0.5;
    console.log(hasError ? ""hasError"" : `responding with ${res}`);
    if (hasError) {
      return cb(new Error(""error""));
    }
    return cb(null, res);
  }, 100);
}

const boundSend = bindNodeCallback(fakeSend);
const subject = new Subject();

subject.subscribe(
  (task) =&gt; {
    boundSend(task)
      .pipe(
        tap((status) =&gt; {
          console.log('tap');
          if (!status) {
            throw new Error(""Did not send"");
          }
          return status;
        }),
        retryWhen((errs) =&gt;
          errs.pipe(
            delay(1000),
            tap((err) =&gt; console.log)
          )
        )
      )
      .subscribe({
        next: console.log,
        error: console.error,
        complete: () =&gt; {
          console.log(""complete"", task);
        }
      });
  },
  (error) =&gt; {
    console.log(""error in subject subscribe"");
  }
);

subject.next(""test1"");
subject.next(""test2"");
subject.next(""test3"");
subject.next(""test4"");</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.6.2/rxjs.umd.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<h3>edit</h3>
<p>I got it working with this:</p>
<pre class=""lang-js prettyprint-override""><code>subject.subscribe(
  (task) =&gt; {
    of(task).pipe(
      mergeMap((v) =&gt; boundSend(v)),
      tap((val) =&gt; {
        if (!val) throw new Error(&quot;Did not send&quot;);
      }),
      retryWhen((errs) =&gt; errs.pipe(delay(300)))
    ).subscribe();
  });
</code></pre>
<p>However, I don't understand why this doesn't work:</p>
<pre class=""lang-js prettyprint-override""><code>subject
  .pipe(
    mergeMap((task) =&gt; boundSend(task)),
    tap((val) =&gt; {
      if (!val) throw new Error(&quot;Did not send&quot;);
    }),
    retryWhen((errs) =&gt; errs.pipe(delay(300)))
  )
  .subscribe();
</code></pre>
<h2>Edit2</h2>
<p>Well. I guess this explains it:  <a href=""https://github.com/ReactiveX/rxjs/issues/1401"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/1401</a></p>
<p>Here I was thinking it was because I'm an RX noob :/</p>
","48266","","48266","","2020-08-22 05:55:38","2020-08-26 07:13:33","In RXJS, how do I force re-execution of an Observable created with bindNodeCallback using retryWhen?","<rxjs><rxjs6>","1","6","","","","CC BY-SA 4.0"
"63543315","1","63544004","","2020-08-23 04:14:44","","2","98","<p>Trying to hunt down the recipe i need but can't find it anywhere.</p>
<p>I have code that looks like this.</p>
<pre><code>const Listeners = listen(&quot;data:join&quot;); /* observable of people who want data */
const DataStream = stream(&quot;data&quot;); /* observable of data */
</code></pre>
<p>How can i build a pipeline that:</p>
<ul>
<li>For each <code>person</code> that joins my listeners stream i subscribe them to the data stream.</li>
<li>Each person that fires a <code>data:leave</code> event unsubscribes from the stream</li>
<li>DataStream's long list of pipe operators under the hood only fire once NOT once for every person who joins.</li>
</ul>
<p>EDIT: What is the equivilent to this in a memory safe way:</p>
<pre><code>Listeners.subscribe((personListening) =&gt; {
     DataStream.subscribe((data) =&gt; personListening.send(data))
     // And until fromEvent(personListening, &quot;data:leave&quot;) fires.
})
/* OR */
DataStream.subscribe((data) =&gt; {
    Listeners.subscribe((person) =&gt; {
        person.send(data);
    })
})
</code></pre>
","7428434","","7428434","","2020-08-23 05:36:10","2020-08-23 06:24:33","RXJS - Avoid inner subscription","<angular><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"63561907","1","63562542","","2020-08-24 13:21:05","","0","35","<p>I made this functionality, each iteration i have 7 requests that sent each environment.dashboard.frequency time,
but at the beginning, I see that i send 14 requests to the server instead of 7 :</p>
<pre><code>let requests: Observable&lt;ResourceResponse&gt;[] = initRequests(this.durationService.resourceDataDuration)
    timer(0, environment.dashboard.frequency)
      .pipe(
        takeUntil(this.destroy),
        startWith(0),
        switchMap(() =&gt; forkJoin(requests))
      )
      .subscribe((responsesArr: ResourceResponse[]) =&gt; {
        this.updateBegin()
        for (const response of responsesArr) {
          this.durationService.resourceDurationHandler.setPresentedDataRanges(
            response,
            this.durationService.resourceDataDuration,
            this.durationService.resourcePresnetedDataDurations
          )
          this.updateMany(response.Resource, response.Response, true)
        }
        this.updateEnd()
        requests = initRequests(this.durationService.resourceDataDuration)
      })
</code></pre>
","14157627","","","","","2020-08-24 13:57:59","rxjs : get duplicate http requests on the first set that I send","<rxjs><rxjs5><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"63635763","1","","","2020-08-28 14:28:13","","0","237","<p>I have implemented RXJS6 Websockets service in angular 8 I am getting the response in Network call but the problem is I am unable to show the response in console or to save the response in any variable.</p>
<p>The webservice code is as follow:</p>
<pre><code>import { Injectable } from '@angular/core';


import { Subject } from 'rxjs/Subject';
import { Observable } from 'rxjs/Observable';
import { AnonymousSubject } from 'rxjs/internal/Subject';
import { Observer } from 'rxjs/Observer';


@Injectable()
export class WebsocketService {

  constructor() { }

  private subject: Subject&lt;MessageEvent&gt;;
  private connected$ = new Subject&lt;any&gt;();

  public connect(url):Subject&lt;MessageEvent&gt; {
    if (!this.subject) {
      this.subject = this.create(url);
      console.log(&quot;Successfully connected: &quot; + url);
      this.connected$.next(true);
    }
    return this.subject;
  }

  public connected(): Observable&lt;any&gt; {
    return this.connected$.asObservable();
  }

  private create(url): Subject&lt;MessageEvent&gt; {
    let ws = new WebSocket(url);

    let observable = new Observable((obs:  Observer&lt;MessageEvent&gt;) =&gt; {
      ws.onmessage = obs.next.bind(obs);
      ws.onerror = obs.error.bind(obs);
      ws.onclose = obs.complete.bind(obs);

      return ws.close.bind(ws);
  });
    let observer = {
      next: (data: Object) =&gt; {
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(data));

        }
      }
    }
    return Subject.create(observer, observable);


}
}&quot;
</code></pre>
<p>and in my app.ts file m calling angular connect function it successfully connect to websocket  ad  i start recieving data in my network call but no data shows at console</p>
<pre><code>  async connect() {
      this.messages = &lt;Subject&lt;any&gt;&gt;this._websocket
        .connect(this.address).pipe(
        map((response: MessageEvent): any =&gt; {

          console.log(&quot;response1&quot;,response);


          return response.data;
        })) ;


        console.log(&quot;websocket&quot;,this._websocket);


      this.messageLog = this.messages.asObservable()
      .pipe(scan((current, change) =&gt; {

        return [...current, `RESPONSE: ${change}`]
        }, []));

        console.log(this.messageLog);
      // this.messages.next(`CONNECT: ${this.address}`);
    }
</code></pre>
<p>It also shows that Subject.create(observer, observable) is deprecated what else i can use instead of this ? and also to what change should i do to show data on console</p>
","10819716","","","","","2020-08-28 14:28:13","WebSocket Response Not Showing in Console Angular 8","<angular><typescript><websocket><rxjs6>","0","7","","","","CC BY-SA 4.0"
"63698509","1","63708451","","2020-09-02 03:59:35","","0","49","<p>I have a class with more than 30 observable attributes. Each time my server receives a payload containing these 30 attributes I call the <code>next()</code> method for all the corresponding attributes of the instance, so far so good.</p>
<p>The problem is that, sometimes, I have to check for an attribute's value, outside the scope of the observer that subscribed to that observable attribute.<br />
What comes to mind is that I have to have duplicate attributes for everything, one is the observable and the other one is a stateful attribute to save the arriving values for later consumption.<br />
Is there some way to avoid this with a method like: <code>Observable.getCurrentValue()</code>?</p>
<h1>As requested, some example code</h1>
<pre class=""lang-js prettyprint-override""><code>class Example {
    public subjects = {
        a1: new Subject&lt;any&gt;(),
        a2: new Subject&lt;any&gt;(),
        a3: new Subject&lt;any&gt;(),
        a4: new Subject&lt;any&gt;(),
        a5: new Subject&lt;any&gt;()
    }

    public treatPayload(data: any) {
        for (const prop in data) {
            if (data.hasOwnProperty(prop) &amp;&amp; prop in this.subjects){
                Reflect.get(this.subjects, prop).next(data[prop])
            }
        }
    }

    public test() {
        const a1_observable = this.subjects.a1.asObservable()
        const a2_observable = this.subjects.a2.asObservable()

        const example_payload_1 = {
            a1: &quot;first&quot;,
            a2: &quot;second&quot;,
            a10: &quot;useless&quot;
        }

        const example_payload_2 = {
            a1: &quot;first-second&quot;,
            a2: &quot;second-second&quot;,
            a10: &quot;useless-second&quot;
        }

        a1_observable.subscribe((a1_new_value: any) =&gt; {
            const i_also_want_the_last_value_emitted_by_a2 = a2_observable.last_value() // of course, this doesn't exist
            console.log(a1_new_value)
            console.log(i_also_want_the_last_value_emitted_by_a2)
        })
        
        this.treatPayload(example_payload_1)
        this.treatPayload(example_payload_2)

    }
}
</code></pre>
<p>So, is there a way to retrieve the correct value of <code>i_also_want_the_last_value_emitted_by_a2</code> without a pipe operator? I think it would be a problem to emit all values I could possibly use in a subscriber within a pipe of the <code>a2_observable</code>.</p>
","12603421","","12603421","","2020-09-02 14:47:32","2020-09-02 15:11:46","How to retrieve last value passed to next() of an Rxjs Observable outside the observer","<rxjs><rxjs6><rxjs-observables>","1","8","","","","CC BY-SA 4.0"
"63698797","1","","","2020-09-02 04:38:45","","1","151","<p>New to Angular. Wanted to learn how to manage state centrally so used ngRx. Also, have not used an Observable before so I am really stuck. Below is my code where the cart holds and array of objects. I just need to iterate over the <code>cart</code> which is array of objects with reduce() to get a total of the price. No matter what I try it does not work. Just to add, up till this point my code is working fine and I am able to get cart data from the store.
Appreciate if someone can guide me in the right direction.</p>
<p>Thank you!</p>
<pre><code>import { Component } from '@angular/core';
import { Store, select } from '@ngrx/store';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-cart-icon',
  templateUrl: './cart-icon.component.html',
  styleUrls: ['./cart-icon.component.scss']
})
export class CartIconComponent {

  constructor(private store: Store&lt;any&gt;) {}

  cart: Observable&lt;Array&lt;any&gt;&gt;

  ngOnInit() {
    this.cart = this.store.select('cart')
  }
}
</code></pre>
","812355","","","","","2020-09-03 05:48:17","Angular - How To Process an Observable in the Class","<javascript><angular><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"63721621","1","63721821","","2020-09-03 10:20:38","","-1","1639","<p>I implemented method using <code>combinlatest</code> rsjx/operator one, it work properly but sonar issue given said it deprecated.so , I need to convert it latest one. but I try, just replace import it gave error. I need some expert help to do this .</p>
<pre><code>gX$ = createEffect(() =&gt; this.actions$.pipe(
    ofType(ActionType.A),
    combineLatest(this.service.getoc()),
    mergeMap(([, oc]) =&gt; this.reviewService.findBy(oc.id,
      new Date(),
      new Date(new Date().setDate(new Date().getDate() + 1)))
      .pipe(
        mergeMap(d =&gt; {
          return of(reviewLoadSuccess({ reviews: getReviews(d) }));
        }
        ),
        catchError(error =&gt; {
          return of(reviewLoadFailure({ error: error }));
        })
      )
    )));
</code></pre>
","4108618","","13302","","2020-09-03 10:22:27","2020-09-03 13:16:54","How to replace method 'combineLatest' from rxJs with a not deprecated method?","<typescript><rxjs><rxjs6><ngrx-effects><combinelatest>","2","0","","","","CC BY-SA 4.0"
"63756566","1","63757204","","2020-09-05 17:14:28","","1","174","<p>I have a bit of a complicated observable in Angular (courtesy of using Akita, I cannot change this), it's a <code>|</code>'ed Observable of either an array of <code>Dinosaur</code> objects, <em>or</em> a single <code>Dinosaur</code> object, or undefined:</p>
<pre><code>import { QueryEntity } from &quot;@datorama/akita&quot;;

export class DinosaurQuery extends QueryEntity&lt;DinosaurState, Dinosaur&gt; {
  activeDinosaurs$ = this.selectActive(); // Type: Observable&lt;Dinosaur[]&gt; | Observable&lt;Dinosaur | undefined&gt;

  constructor(protected store: DinosaursStore) {
    super(store);
  }
}
</code></pre>
<p>What I want to get from this, as an observable, is either the single object, <em>or</em> the first object in the array in case it is an array. Or undefined, if there is none.</p>
<pre><code>export class DinosaurSelection {
    // I want singleSelectedDinosaur$ to be of type: Observable&lt;Dinosaur | undefined&gt;
    singleSelectedDinosaur$ = this.dinosaurQuery.activeDinosaurs$.pipe(???);

    constructor(protected dinosaurQuery: DinosaurQuery) {}

}
</code></pre>
<p>I presume there must be some pipe that does this, but I can't find something appropriate that can act on the <code>|</code> of an object and an array of that object at the same time. (Or maybe it can't be done with a pipe but in another way, that's also fine.)</p>
","1511627","","","","","2020-09-05 18:23:07","Angular2: get a pipe that selects from an array `|` a single object","<angular><typescript><rxjs6><akita>","1","0","","","","CC BY-SA 4.0"
"63795528","1","63796303","","2020-09-08 13:58:42","","2","1266","<p>I have multiple observables that emit values during the lifetime of the page. For example:</p>
<pre><code>chartData$: Observable;
tableData$: Observable;
filterData$: Observable;
</code></pre>
<p>At any time user can click the 'Download' button, and get the JSON combining the values that were last emitted from each of these observables:</p>
<pre><code>downloadButtonClicked$.pipe(
    combine chartData$, tableData$ and filterData$    // &lt;- how do I get latest values here?
).subscribe(([chart, table, filter]) =&gt; downloadJson(chart, table, filter))
</code></pre>
<p>but the <code>downloadJson</code> function shouldn't be called when any of these 3 observables emit values as part of page lifecycle, only on Download click.</p>
<p><strong>TLDR;</strong></p>
<p>working most elegant solution (as suggested by Mike)
<a href=""https://stackblitz.com/edit/typescript-jm3zma?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-jm3zma?file=index.ts</a></p>
","1457181","","1457181","","2020-09-08 15:14:05","2020-09-08 15:22:29","Rxjs: get latest values from multiple observables later after they emitted","<rxjs><rxjs6><rxjs-pipeable-operators>","4","0","","","","CC BY-SA 4.0"
"63807974","1","","","2020-09-09 08:44:25","","0","195","<p>i am having a custom component</p>
<pre class=""lang-js prettyprint-override""><code>export class SystemInputComponent implements OnInit, OnDestroy {

  @Input() ...

  @Output() enterFn: EventEmitter&lt;any&gt; = new EventEmitter&lt;any&gt;();
  ...
</code></pre>
<p>that has output that act as an event <em>as i know</em></p>
<p>and that component imported outside in other component html</p>
<pre class=""lang-html prettyprint-override""><code>&lt;div class=&quot;input-group&quot;&gt;
    &lt;system-input #systemInput&gt;&lt;/system-input&gt;
&lt;/div&gt;
</code></pre>
<p>the regular way to bind the event is add it into the component tag as attribute with () and bind it to a function</p>
<pre class=""lang-html prettyprint-override""><code>&lt;system-input #systemInput (enterFn)=&quot;someFunct($event)&quot;&gt;&lt;/system-input&gt;
</code></pre>
<p>the question is can i bind it from ts code with rxjs fromEvent function like this</p>
<p><strong>inside .ts file</strong></p>
<pre class=""lang-js prettyprint-override""><code>import { fromEvent } from 'rxjs';
.
.
..
@ViewChild('systemInput') systemInput:any;
ngOnInit(){
     fromEvent(this.systemInput.nativeElement,'enterFn').subscribe(a =&gt; //a is the $event );
}
..

</code></pre>
<p>and if it could how to it properly, because it give me a error</p>
<pre><code>Cannot read property 'nativeElement' of undefined
</code></pre>
<p><strong>EDIT</strong>
as JoH said in the first comment i moved it to ngAfterViewInit</p>
<pre class=""lang-js prettyprint-override""><code>ngAfterViewInit(){
     fromEvent(this.systemInput.elementRef.nativeElement,'enterFn').subscribe(a =&gt; //a is the $event );
}
</code></pre>
<p>it give me that new error</p>
<pre><code>Invalid Event Traget
</code></pre>
","13399674","","13399674","","2020-09-09 09:15:26","2020-09-24 19:31:10","can i bind from event to custom component output","<angular><rxjs6><rxjs-observables><angular10>","1","4","","","","CC BY-SA 4.0"
"63846906","1","63847606","","2020-09-11 12:14:39","","1","40","<p>I have one endpoint for getting list of users, and another for getting list of apartments for every user:</p>
<pre><code>getUsers() =&gt; Observable&lt;User[]&gt;;
getUserApartments(userId) =&gt; Observable&lt;Apartment[]&gt;`
</code></pre>
<p>How do I merge the data from the two into single observable:</p>
<pre><code>const usersWithApartments$: Observable&lt;{ user: User, apartments: Apartment[] }[]&gt; = getUsers().pipe(
    // users.map(user =&gt; { user, apartments: getUserApartments(user.id) }) &lt;-- turn this pseudocode into Rxjs
);
</code></pre>
","1457181","","1457181","","2020-09-11 13:03:26","2020-09-11 14:35:25","rxjs: load many for many from 2 endpoints and merge into single Observable","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"63870158","1","","","2020-09-13 11:23:13","","-2","524","<p>The <code>getDetails()</code> method returns an <code>Details[]</code> and with that array and there is a name property which I am passing to another http call</p>
<pre><code>Details {
    name: String;
</code></pre>
<p>Details</p>
<pre><code> getDetails()
     return this.https.get(&quot;/someValue&quot;) //this return Details[] from here I have to take  name property
</code></pre>
<p>return</p>
<pre><code>{name : hello}
</code></pre>
<p>Information</p>
<pre><code> getInformations(name:string) {
    return this.https.get(&quot;/anotherValue&quot;+&quot;?&quot;+ name)
 }
</code></pre>
<p>I am trying to first call <code>getDetails()</code> and pass the name property to</p>
<pre><code>Information{
  Hieght:string
  age:string
}

getInformations()
this.getDetails().pipe(mergeMap(x =&gt; 
 this.getInformations(x.name)).subscribe((inforamtionResults:Information[])=&gt;{
  console.log(&quot;Checking Informations&quot;+inforamtionResults.length) 
</code></pre>
<p>return</p>
<pre><code> {height:160,
   age: 23
   }
</code></pre>
<p>This is not working as x value is an array. How do iterate the array and pass the array property as parameter?</p>
","6550398","","6550398","","2020-09-13 13:33:39","2020-09-13 13:38:06","Angular merge map for one after another http calls","<angular><typescript><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"63886559","1","63887834","","2020-09-14 14:41:26","","2","51","<p>How do I access the <code>resultB</code> in the <code>tap</code> operator after it was <code>switchMap</code>ped ?</p>
<pre><code>streamA$.pipe(
    switchMap(resultA =&gt; {
        const streamB$ = resultA ? streamB1$ : streamB2$;

        return streamB$.pipe(                   // &lt;- nesting
            switchMap(resultB =&gt; loadData(resultB)),
            tap(data =&gt; {
                // how do I access resultB here?
            })
        );

    })
);
</code></pre>
<p>bonus question:
Is it possible to avoid the nesting here, and chain the whole flow under single pipe?</p>
","1457181","","","","","2020-09-15 05:25:27","rxjs: access the result of original observable after it was switchMap'ped","<rxjs><rxjs6><rxjs-pipeable-operators><switchmap>","3","1","","","","CC BY-SA 4.0"
"63970730","1","63971447","","2020-09-19 16:01:13","","2","81","<p>I am currently working on implementing a &quot;User is Typing&quot; feature for a multi-user chat room. With my limited knowledge of RXJS I was able to produce the following snippet of code which meets the bare minimum for the &quot;User is Typing&quot; feature:</p>
<pre><code>   this.messageForm.message.valueChanges
      .pipe(
        tap(() =&gt; this.convoService.isUserTyping(true)),
        debounceTime(500),
        map(() =&gt; this.convoService.isUserTyping(false))
      )
      .subscribe();
</code></pre>
<p>However this implementation is not ideal since it produces too many requests to the server. My goal is to <strong>limit requests to 2</strong>, and using RXJS operators create the following behaviors:</p>
<ol>
<li>Only emit a request on the first keypress</li>
<li>Ignore all subsequent keypresses</li>
<li>Wait an X amount of time after what may be the last keypress</li>
<li>Reset the countdown if new keypress is introduced before the countdown expires</li>
<li>Emit a request once the countdown expires</li>
</ol>
","14306230","","","","","2020-09-19 17:16:04","""User is Typing"" lean RXJS implementation","<angular><typescript><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"64035614","1","64037153","","2020-09-23 20:15:32","","2","138","<p>I am trying to create function which wraps given Observable and adds loading screen to it.<br>
The function <code>function wrapWithLoadingScreen&lt;T&gt;(obs$: Observable&lt;T&gt;): Observable&lt;T&gt;</code> should work like :</p>
<ol>
<li>show loading screen.</li>
<li>execute observable received as parameter</li>
<li>hide loading screen after all values are emitted.</li>
</ol>
<p>My initial idea of implementation was:</p>
<pre><code>function wrapWithLoadingScreen&lt;T&gt;(obs$: Observable&lt;T&gt;): Observable&lt;T&gt; {
  return of(null).pipe(
    tap(() =&gt; console.log(&quot;show loading screen&quot;)),
    switchMap(() =&gt; obs$),
    finalize(() =&gt; console.log(&quot;hide loading screen&quot;))
  );
}
</code></pre>
<p>but when i chain other operators to result of this function then &quot;hide loading screen&quot; is executed after those chains (not after original observable finishing).</p>
<p>Here is an example: <a href=""https://stackblitz.com/edit/rxjs-wrapping-observable"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-wrapping-observable</a></p>
<p>the result in console of above is</p>
<pre><code>show loading screen
im reducing
im reducing
reducing finished so loading screen should be hidden
the result is 6
hide loading screen
</code></pre>
<p>what im aiming for should be</p>
<pre><code>show loading screen
im reducing
im reducing
hide loading screen
reducing finished so loading screen should be hidden
the result is 6
</code></pre>
","2182067","","","","","2020-09-24 11:18:12","Wrapping rxjs observable to do something before and after (for example show/hide loading screen)","<typescript><rxjs><rxjs6>","1","0","1","","","CC BY-SA 4.0"
"64053491","1","","","2020-09-24 19:52:51","","0","71","<p>I am iterating an array of items via foreach method. Each item executes two http calls which are nested. I am unable to unsubscribe the observables when the loop finishes. Could you please provide an solution for this</p>
<pre><code>import { Observable, Subject } from 'rxjs';
import { mergeMap, take } from 'rxjs/operators';

private _unsubscribeAll: Subject&lt;any&gt;;

constructor(...) {
    this._unsubscribeAll = new Subject();
}

ngOnChanges(): void {

    //this.fileList is an array of ids

    this.fileList.forEach((id) =&gt; {

        this.getData(id).subscribe((res:any) =&gt; {
            console.log(res)
        })

    });

    getData(id): Observable&lt;any&gt; {

        return this.fileService.getFileDetails(id).pipe(take(1),
        mergeMap(data =&gt; {
            if(data != undefined) {
            return this.fileService.downloadFile(data[0].path)
            }
        }))

    }

}

ngOnDestroy() {

    this._unsubscribeAll.next();
    this._unsubscribeAll.complete();

} 
</code></pre>
","1153484","","","","","2020-09-25 03:17:24","Unable to unsubscribe while running observables in a foreach method","<angular><rxjs><observable><rxjs6>","2","0","","","","CC BY-SA 4.0"
"64065291","1","64065605","","2020-09-25 13:39:26","","0","46","<p>I want to get boolean for canActivate() method but nothing is working.
My code is:</p>
<pre><code>  login() {
      return this.http.get&lt;any&gt;('http://localhost/auth');
  }
</code></pre>
<p>and I want to do somthing like this:</p>
<pre><code>  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    return this.authenticationService.login().subscribe(
      () =&gt; true,
    () =&gt; false
    );
  }
</code></pre>
<p>What is the correct way to do this?</p>
","9935150","","","","","2020-09-25 14:06:50","Simplest way to return boolean from Observable","<angular><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"64122216","1","64122709","","2020-09-29 14:54:47","","1","45","<p>I have a service with a RXJS subject and i am assigning data to subject inside constructor doing an api call. This subject I am subscribing in a component template. Though the data is provided to the subject, it is not emitting immediately the first time.</p>
<pre><code>interface Employee {
employee_age: number;
employee_name: string;
employee_salary: number;
id: string;
profile_image: string;
}

@Injectable({
  providedIn: &quot;root&quot;,
})
export class EmployeeService {
 employeesSub = new Subject&lt;Employee[]&gt;();

 employees: Employee[];

 constructor(private http: HttpClient) {

this.api().subscribe((res) =&gt; {
  this.employees = res.data;
  this.employeesSub.next(this.employees);
});

}

 getEmployees(){
     this.employeesSub.next(this.employees);
 }

 addEmployee(name,age,salary) {
    this.employees.unshift({id:(this.employees.length + 
 1).toString(),employee_age:age,employee_name:name,employee_salary:salary,profile_image:&quot;&quot;});
   this.employeesSub.next(this.employees);
 }
 
 api() {
    return this.http
     .get&lt;any&gt;(environment.employeeUrl)
     .pipe(map((data) =&gt; data.items));
   }
  }

 Code in template

  &lt;h2&gt;List&lt;/h2&gt;
  &lt;div style=&quot;display: flex;&quot;&gt;&lt;/div&gt;
  &lt;table&gt;
     &lt;tr *ngFor=&quot;let item of employeeService.employeesSub|async&quot;&gt;
       &lt;td&gt;      {{ item.employee_name}}    &lt;/td&gt;
       &lt;td&gt;      {{ item.employee_age}}    &lt;/td&gt;
       &lt;td&gt;      {{ item.employee_salary}}    &lt;/td&gt;
     &lt;/tr&gt;
  &lt;/table&gt;
</code></pre>
<p>I am reassigning data by calling the getEmployees() function after 200ms and it is working. Any idea why this is happening.</p>
","9588631","","9588631","","2020-10-02 06:05:49","2020-10-02 06:05:49","Rxjs Subject not emitting data immediately","<angular><rxjs><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"64149074","1","","","2020-10-01 04:27:38","","1","56","<p>I've inherited some old <code>RxJs 5</code> code that smells awkward:</p>
<pre class=""lang-js prettyprint-override""><code>  myFunc = (tag: TagModel): Observable&lt;TagModel&gt; =&gt; {
    try {
      const foundTag = this.mappedTags.find((x) =&gt; {
        return x.name === tag;
      });
      const isAllowedToAdd = foundTag ? false : true;

      return Observable
        .of(tag)
        .filter(() =&gt; isAllowedToAdd)
        .mapTo(tag);

    } catch (err) {
      console.log(&quot;err: &quot;, err);
    }
  }
</code></pre>
<p>Is the purpose of that code to create an Observable with either a value of tag if it's found, otherwise empty? It looks so convoluted (plus some other choice words which I can't share here).</p>
<p><code>RxJs</code> introduced breaking changes where <code>of</code> and <code>mapTo</code> are no longer chainable. Would this be the correct way to refactor?</p>
<pre class=""lang-js prettyprint-override""><code>  return of(tag)
    .filter(() =&gt; isAllowedToAdd)
    .pipe(mapTo(tag));
</code></pre>
","705483","","13680115","","2020-10-19 17:15:11","2020-10-19 17:15:11","RxJs 5 of.filter.mapTo operators -> RxJs 6","<rxjs><observable><rxjs5><rxjs6>","1","2","","","","CC BY-SA 4.0"
"64196176","1","","","2020-10-04 15:00:13","","0","37","<p>I want to map HttpClient's error with its type and I have this code:</p>
<pre class=""lang-js prettyprint-override""><code>export class ErrorMessageInterceptor implements HttpInterceptor {
  constructor(private notifyService: NotifyService) {}

  public intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    return next.handle(req).pipe(
      catchError(error =&gt; {
        console.error(error);
        return throwError({
          ok: error.ok,
          status: error.status,
          statusText: error.statusText,
          code: error.error.error.code,
          message: error.error.error.message,
          headers: error.headers,
          url: error.url,
        } as OdataError);
      }),
      tap(() =&gt; {}, async error =&gt; {
        await this.notifyService.error(error.message);
      }),
    );
  }
}
</code></pre>
<p>But unfortunately the default type for <code>error</code> in <code>tap</code> operator remains <code>any</code> and I'd not want to map the error type wherever it'll be used. So I have 2 questions here:</p>
<ol>
<li>Why the mapped type error is not visible in the code above?</li>
<li>Is there a way to set custom error type globally or at least for injected <code>HttpClient</code>'s instance?</li>
</ol>
","3159399","","","","","2020-10-04 15:00:13","Map Angular HttpClient error with its type","<angular><typescript><rxjs><rxjs6>","0","5","","","","CC BY-SA 4.0"
"64208725","1","","","2020-10-05 12:35:23","","0","38","<p>I need to subscribe &amp; do some actions, when mouseover on particular elements in the DOM.</p>
<p>For Example: home.component.html</p>
<pre><code>        &lt;div class=&quot;container&quot;&gt;
              &lt;div class=&quot;row1&quot;&gt; &lt;/div&gt;
              &lt;div class=&quot;row2&quot;&gt; &lt;/div&gt;
              &lt;div class=&quot;row3&quot;&gt; &lt;/div&gt;
        &lt;/div&gt;
</code></pre>
<p>home.component.ts:</p>
<pre><code>         import {
                 AfterViewInit,
                 Component,
                 Input,
                 OnInit,
                } from '@angular/core';

                @Component({
                             selector: 'app-home',
                             templateUrl: './home.component.html',
                             styleUrls: ['./home.component.scss'],
                           })
          export class homeComponent implements OnInit {
          
               public hover: boolean;

               constructor() {}

               ngOnInit(): void {
                     this.hover= true;       // it may be false also.
               }

          }
</code></pre>
<p>In the above example when mouseover on row1 &amp; row3 elements then I need to subscribe. Also I need to check one variable called &quot;hover&quot;, if it is true then only I need todo the above action(mouseover). If the variable is false then no need to check for mouseover(no need to do any action), just I need to unsubscribe it. Can any one help me to achieve this.</p>
","7148829","","","","","2020-10-05 14:15:26","subscribing when mouseover on particular element in the DOM","<javascript><angular><rxjs5><rxjs6><rxjs-observables>","2","2","","","","CC BY-SA 4.0"
"64225268","1","64226851","","2020-10-06 11:53:11","","3","75","<p>I am investigating an issue which appears to be coming from the fact that the &quot;unsubscribe&quot; method of the &quot;Subscription&quot; class does not appear to be disposing of the resources quickly enough which creates a memory leak.</p>
<p>Here is my scenario:</p>
<p><a href=""https://i.stack.imgur.com/jpmaa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jpmaa.png"" alt=""enter image description here"" /></a></p>
<p>I have 2 components - <strong>LandingPageComponent</strong> (LPC) and <strong>WebPlayerComponent</strong> (WPC). The LPC is the first page that the user sees when they access the site. On that page, they have a link which takes them to the second page or WPC (passing an argument, e.g. &quot;<em>Operator Benchmarking</em>&quot;) The user goes back to the previous page by clicking the browser's back button. That triggers the WPC's <strong>ngOnDestroy</strong> method which disposes of subscribtions (see code below).</p>
<p>WebPlayerComponent</p>
<pre><code>export class WebPlayerComponent implements OnInit, OnDestroy {
    @Input() workbookId: string;
    @Input() workbookPage: string | number;

    private _workbooks: Workbook[];
    private _filters: Filter[];

    private _subscriptions: { [key: string]: Subscription } = {};
    
    ngOnInit() {
        this._subscriptions[&quot;combined&quot;] = combineLatest(
            this.workbookService.workbooks$,
            this.filterService.filters$,
            this.libraryService.userFolderInitialised$
        ).subscribe(([workbooks, filters, userFolderInitialised]) =&gt; {
            this._workbooks = workbooks;
            this._filters = filters;

            this._subscriptions[&quot;webPlayerServiceSubscription&quot;] = this.webPlayerService.openWorkbook(workbook.libraryPath, parameterString).subscribe(
                    (webPlayer) =&gt; {
                        console.log(&quot;_subscriptions before 'openWorkbook call'&quot;);
                        Object.keys(this._subscriptions).map((key) =&gt; {
                        console.log(key);
                        });

                        console.log(&quot;Openning document page: &quot; + this.workbookPage);
                        webPlayer.openDocument(&quot;spotfire-container&quot;, this.workbookPage);
                    });
        });

    }
    
    ngOnDestroy() {
        Object.keys(this._subscriptions).map((key) =&gt; {
            this._subscriptions[key].unsubscribe();
            console.log(&quot;---Unsubscribed &quot; + key + &quot;---&quot;);
        });
    }
}
</code></pre>
<p>The problem starts occuring if the user clicks the browser's Back button and clicks on the &quot;Link&quot; quickly enough (in my example that's anything less that 5seconds). The subscribtions that are supposed to be disposed are not and are still active. I am able to confirm that by looking at the console's output:</p>
<p><a href=""https://i.stack.imgur.com/fWJ5k.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fWJ5k.png"" alt=""enter image description here"" /></a></p>
<p>In the above image you can see that after clickon on the &quot;Link&quot; again from the <strong>LandingPageComponent</strong> we see 2 sets of calls (the green numbers (1) &amp; (2)), we also see the <em>&quot;Opening document page:&quot;</em> 3 times</p>
<p>This is how the output should look like if I wait 5 seconds before I click the link again</p>
<p><a href=""https://i.stack.imgur.com/yYsCE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yYsCE.png"" alt=""enter image description here"" /></a></p>
<p>I am not sure why my subscription resources are not being disposed of fast enough (at least that is what I think the problem here is).</p>
<p>Note: I am using <strong>RxJS 6.4.0</strong> and <strong>Angular 8.1.3</strong></p>
","3398554","","472495","","2020-11-24 23:03:25","2020-11-24 23:03:25","RxJS ""unsubsribe"" method in ngOnDestroy does not disposes resources quickly enough","<angular><rxjs><rxjs6><rxjs-observables>","1","4","","","","CC BY-SA 4.0"
"64287018","1","","","2020-10-09 20:39:46","","0","75","<p>I have an array of observables (HTTP POST requests) that I need to send off to an API after a specific event. The following is a simplified example of the approach, where I use <code>concat</code> so I can leverage success, error and complete callbacks.</p>
<pre><code>// build up an array of stored POST requests to fire off later
// array is indeterminate length, could be 1 request could be 1,000
let requests = [ req1, req2, req3, req4 ];

concat(...requests).subscribe(
  success =&gt; ... handle success ...
  error =&gt; ... handle error ...
  () =&gt; ... handle completion ...
);
</code></pre>
<p>The issue is the concat basically sends all the requests at once, raising the potential for concurrency issues in the API consuming the requests. This issue should be resolved if I am able to fire the requests off one-by-one rather than all at once. I've determined that a <code>forEach</code> loop is not an option.</p>
<p>Is there an RxJS approach such that <code>req2</code> only emits after <code>req1</code> completes and <code>req3</code> emits only after <code>req2</code> completes and so on? I've been reviewing the RxJS docs but have yet to find anything that fits this scenario.</p>
","4184075","","","","","2020-10-09 22:08:11","RxJS array of HTTP observables: fire next only after previous completes","<angular><rxjs><rxjs6><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"64303198","1","64340286","","2020-10-11 10:53:19","","0","143","<p>I have a Subject <code>refreshData$</code> that triggers data refetch:</p>
<pre><code>const data$ = refreshData$.pipe(
    switchMap(() =&gt; dataService.load())
);
</code></pre>
<p>I need to show loading indicator only if load take more than 1 second. If data arrives in under 1s - do not show the spinner.</p>
<p>Found very good answer <a href=""https://stackoverflow.com/a/56361092/1457181"">here</a>, but it recreates the observables on every refresh. And I want to reuse them. I have started with the following, but it it only works one time. I guess <code>takeUntil</code> has to be replaced with something else here.</p>
<pre><code>const showSpinner$ = merge(
    refreshData$.pipe(
        delay(1000),
        mapTo(true),
        takeUntil(data$)    // FIXME: only shows loading once
    ),
    data$.pipe(
        timeInterval(),
        mapTo(false)
    )
);

----
to be used in template as:
&lt;loading-spinner *ngIf=&quot;showSpinner|async&quot;&gt;&lt;/loading-spinner&gt;
</code></pre>
","1457181","","1457181","","2020-10-11 11:14:19","2020-10-13 17:39:02","rxjs: show loading spinner only if it takes > 1s to load","<rxjs><rxjs6><rxjs-pipeable-operators>","2","0","","","","CC BY-SA 4.0"
"64345924","1","64376245","","2020-10-14 02:50:59","","1","73","<p>I am trying to create an observable with a state to be able to show a loading in the UI.
The combineLatest works as it should, the pipe is only on the switchmap to prevent the observable (combineLatest) from closing in case of error
I found an example (<a href=""https://stackoverflow.com/a/52539834/3954928"">this</a> or <a href=""https://ng-run.com/edit/TmKtfF2wZL5HBnSUoPQS?open=app%2Fobs-with-status.pipe.ts"" rel=""nofollow noreferrer"">this</a>) of how I should use a stateful observable, but I can't merge the two, any help? thx</p>
<p><strong>My example</strong></p>
<pre><code>combineLatest([
    Observable_One,
    Observable_Two,
    Observable_Three,
  ]).pipe(
    switchMap(([R1, R2, R3]) =&gt;
      this.MyServiceWithPossibleError(...)
        .pipe(catchError(() =&gt; { return EMPTY }))))
</code></pre>
<p><strong>Web example</strong></p>
<pre><code>export enum ObsevableStatus {
  SUCCESS = 'Success',
  ERROR = 'Error',
  LOADING = 'Loading',
}

export interface ObservableWithStatus&lt;T&gt; {
  status: string;
  data?: T;
  error?: Error;
}

export function observableWithStatus&lt;T&gt;(x: Observable&lt;T&gt;): Observable&lt;ObservableWithStatus&lt;T&gt;&gt; {
  return x.pipe(
    map(x =&gt; ({ status: ObsevableStatus.SUCCESS, data: x })),
    startWith({ status: ObsevableStatus.LOADING }),
    catchError(x =&gt; {
      return of({ status: ObsevableStatus.ERROR, error: x });
    })
  );
}
</code></pre>
<p><strong>UPDATE</strong></p>
<ol>
<li>Show loading if &quot;Observable_One&quot;, &quot;Observable_One&quot; or &quot;Observable_Three&quot; emit some value</li>
<li>if my service (MyWebServiceWithPossibleError) throw some error, stop loading and show message, BUT not finish &quot;combineLatest&quot; (long-lived observable), so can continue receiving the events of the 3 observables</li>
<li>if not error, hide loading and show data</li>
</ol>
<p>The intention is not to literally combine the two examples, it is to build an example with both</p>
<p><strong>UPDATE 2</strong></p>
<pre><code>getEntities$ = combineLatest([
    Observable_One,
    Observable_Two,
    Observable_Three,
  ]).pipe(
    switchMap(
      ([R1, R2, R3]) =&gt;
        concat(
          of({ status: 'loading', value: '' }),
          this.MyServiceWithPossibleError$(...)
            .pipe(map(x =&gt; ({ status: 'success', value: SERVICE_RESPONSE })), catchError(() =&gt; EMPTY))
        )
    )
  )

&lt;div *ngIf=&quot;getEntities$ | async as obs&quot; [ngSwitch]=&quot;obs.status&quot;&gt;
  &lt;div *ngSwitchCase=&quot;'success'&quot;&gt;
    Success! {{ obs.value }}
  &lt;/div&gt;

  &lt;div *ngSwitchCase=&quot;'error'&quot;&gt;
    Error
  &lt;/div&gt;

  &lt;div *ngSwitchCase=&quot;'loading'&quot;&gt;
    Loading!
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
","3954928","","3954928","","2020-10-15 15:38:39","2020-10-15 16:49:13","Observable with status (for UI)","<angular><typescript><rxjs><rxjs6>","1","4","","","","CC BY-SA 4.0"
"64470927","1","64471036","","2020-10-21 20:01:27","","0","87","<p>I'm trying to determine how/if I can convert a Promise rejection into a typed Observable.</p>
<p>I have a login component with a function like this...</p>
<pre><code>login() {
  const login$ = this.authenticationService.login(this.loginForm.value)
  login$
  .pipe(
    finalize(() =&gt; {
      this.loginForm.markAsPristine();
      this.isLoading = false;
    }),
    untilDestroyed(this)
  )
  .subscribe(
    (credentials) =&gt; {
      log.debug(`${credentials.username} successfully logged in`);
      this.router.navigate([this.route.snapshot.queryParams.redirect || '/'], { replaceUrl: true });
    },
    (error) =&gt; {
      log.debug(`Login error: ${error}`);
      this.error = error;
    }
  )
}
</code></pre>
<p>and an authentication service with a method like this...</p>
<pre><code>login(context: LoginContext): Observable&lt;Credentials&gt; {

  var data = {} as Credentials
  
  // Call a method that returns a Promise
  this.server.authenticate(LoginContext)
  .then((result) -&gt; {
      data.username = result.user.username
      data.token = result.accessToken
      this.credentialsService.setCredentials(data, context.remember)
      // Not sure what to do here...need to return data somehow as an Observable
      // return data
    })
  .catch((err) =&gt; {
      // Not sure what to do here either...need to bubble the err up so that it's caught in subscribe
      // return throwError(err)
    })
}
</code></pre>
<p>How can I return an <code>Observable&lt;Credentials&gt;</code> if the Promise resolves, and bubble up the error if it rejects?</p>
<p>I know I can make everything work if I change the authentication service function to return <code>Promise&lt;Observable&lt;Credentials&gt;&gt;</code>, which is fine, but for the sake of learning new things I'm trying to figure out if this is possible.</p>
","862224","","","","","2020-10-21 20:22:32","Return Observable From Promise That Gets Rejected","<javascript><angular><typescript><rxjs6><feathersjs>","1","0","","","","CC BY-SA 4.0"
"64499461","1","","","2020-10-23 11:51:18","","1","322","<ul>
<li>There is a function that would get called from anywhere within the
application, which would be passed an object.</li>
<li>What we need to do, is call a backend API with this item as Post<br />
Body.</li>
<li>However, what I would like to do is collate these updates for
an interval of time - and then send them across together, to<br />
reduce the number of calls made to backend.</li>
</ul>
<p>So, I am thinking of <em>adding these items to an Array</em>
. Create an observable with this array
and pipe <strong>bufferTime</strong> to buffer the values for a specific amount of time, before emitting them.</p>
<p>I created a Stackblitz - <a href=""https://stackblitz.com/edit/typescript-fzezep?file=index.ts&amp;devtoolsheight=100"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/typescript-fzezep?file=index.ts&amp;devtoolsheight=100</a>
and if you see the output -
The first 20 values are output, the ones that are added before subscribing.
But the last 20 values are never emitted.</p>
<p>So the subscription is complete, but then <em><strong>how do we create a subscription with a dynamic array?</strong></em></p>
","1535830","","","","","2020-10-23 12:37:57","How to create a rxJS subscription with a dynamic array?","<angular><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64625561","1","64626728","","2020-10-31 19:18:51","","1","76","<p>I want to incrementally increase the delay for this:</p>
<pre><code>const source = from(839283, 1123123, 63527, 4412454); // note: this is random
const spread = source.pipe(concatMap(value =&gt; of(value).pipe(delay(1000)))); // how to incrementally increase the delay where the first item emits in a second, the second item emits in three seconds, the third item emits in five seconds, and the last item emits in seven seconds.
spread.subscribe(value =&gt; console.log(value));
</code></pre>
<p>I'm aware of using interval to incrementally increase the delay time as below. But I also need to consume this source <code>const source = from(839283, 1123123, 63527, 4412454); </code></p>
<pre><code>const source = interval(1000); // But I also need to use have this from(839283, 1123123, 63527, 4412454)
const spread = source.pipe(concatMap(value =&gt; of(value).pipe(delay(value * 200))));
spread.subscribe(value =&gt; console.log(value
</code></pre>
<p>How to incrementally increase the delay time when starting with <code>const source = from(839283, 1123123, 63527, 4412454); </code>?</p>
","3073280","","","","","2020-11-01 00:47:46","RxJS - How to incrementally increase the delay time without using interval?","<angular><rxjs><rxjs5><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"64634745","1","","","2020-11-01 17:21:40","","0","103","<p>This is the HTML tag:
Need to pass two parameters in key up event.</p>
<pre class=""lang-html prettyprint-override""><code>    &lt;div&gt;
      &lt;input type=&quot;text&quot; (keyup)='keyUp.next($event, field)'&gt;
    &lt;/div&gt;
</code></pre>
<p>TS: How to get the second parameter <strong>field</strong> to be used in TS code.</p>
<pre class=""lang-typescript prettyprint-override""><code>    ngOnInit() {
    
        fromEvent(this.movieSearchInput.nativeElement, 'keyup').pipe(
    
          // get value
          map((event: any) =&gt; {
            return event.target.value;
          })
          // if character length greater then 2
          , filter(res =&gt; res.length &gt; 2)
    
          // Time in milliseconds between key events
          , debounceTime(1000)
    
          // If previous query is diffent from current   
          , distinctUntilChanged()
    
          // subscription for response
        ).subscribe((text: string) =&gt; {
    
          this.isSearching = true;
    
          this.searchGetCall(text).subscribe((res) =&gt; {
            console.log('res', res);
            this.isSearching = false;
            this.apiResponse = res.data;
          }, (err) =&gt; {
            this.isSearching = false;
            console.log('error', err);
          });
    
        });
      }
</code></pre>
<p>How to access parameters in ts code</p>
","10077431","","13680115","","2020-11-01 17:23:20","2020-11-01 17:23:20","How to add more two parameters in (keyup)='keyUp.next($event)' in angular and make it accessible in ts","<angular><rxjs6>","0","2","","","","CC BY-SA 4.0"
"64646541","1","","","2020-11-02 13:31:25","","0","215","<p>How to use it in component to show a timer/ count down  number? Is it a good practice to have a service like this?</p>
<pre><code>import { Subscription, timer } from 'rxjs';
import { switchMap } from 'rxjs/operators';

export class IntervalRunnerOptions {
    constructor(
        public callback:()=&gt;void,
        public period:number=1000,
        public initialDelay:number=0,
        public TotalTime: number) {
    }
}

export class IntervalRunner {
    subscription: Subscription = null;

    start(options:IntervalRunnerOptions) {
        if(this.subscription==null) {
            this.subscription = timer(options.initialDelay, options.period).subscribe(result =&gt; options.callback());
        }
    }
    
    stop() {
        if(this.subscription!=null) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
}
</code></pre>
","5234396","","4054974","","2020-11-02 13:32:33","2020-11-04 08:09:12","how to use the following timer service in angular component","<angular><typescript><rxjs><rxjs6><angular10>","1","0","","","","CC BY-SA 4.0"
"64671169","1","64671471","","2020-11-03 21:46:21","","1","681","<p>I have an observable stream. The first operator is a mergeMap that returns an array of observables. I then have to have a second mergeMap to get the final values from the first mergeMap's return. I feel this second mergeMap should be unnecessary, but cannot find a way around it.</p>
<p>Example:</p>
<pre><code>source$.pipe(
  mergeMap(() =&gt; [of(1), of(2), of(3)]),
  mergeMap((val) =&gt; val)
)
</code></pre>
<p>This is ultimately what I have. The second mergeMap only exists to subscribe to the output of the first. Without it, my output is the observable (i.e. <code>of(1)</code> instead of the actual value 1). Is there a way around having this second mergeMap?</p>
","13382950","","","","","2020-11-03 22:14:51","RxJS return array of values from mergeMap","<rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"64672108","1","","","2020-11-03 23:15:55","","0","127","<p>I have a problem with fixing the unit test of the code that returns <code>NEVER</code> (<code>new Observable&lt;never&gt;()</code>).</p>
<p>My problem is, that I don't even know how to test for that, as <code>NEVER</code> will never run any function inside <code>subscribe</code>. As this is async code, I cannot test in outside of the method, because it has tendency to <strong>sometimes</strong> run in <code>afterAll</code> and that breaks the tests - random crashes.</p>
<p>Generally for async methods with <code>Observables</code> I normally use functions within <code>subscribe</code> method.</p>
<p>Ex.</p>
<pre><code>myFunction.subscribe(
  next =&gt; {
     fail();
  },
  error =&gt; { 
    expect(error).toBe(myError);
    done();
  },
  () =&gt; { 
    fail();
    done();
  });
</code></pre>
<p>This pretty work well with testing the async code.</p>
","1069969","","1069969","","2020-11-05 13:18:33","2020-11-05 22:54:07","RxJS: Check for NEVER?","<typescript><rxjs><jasmine><karma-jasmine><rxjs6>","1","3","1","","","CC BY-SA 4.0"
"64690731","1","","","2020-11-05 03:18:58","","0","22","<p>Writing database output to multiple CSV files. Using postgres cursor. I am getting</p>
<pre><code> error is TypeError: You provided 'undefined' where a stream was expected. You can provide an Observable, Promise, Array, or Iterable
</code></pre>
<p>When reading subsequent cursor iterations. Returning the wrong thing. Using Node 15, RxJS 6 and</p>
<pre><code>const Pool = require('pg-pool');
const SQL = require('sql-template-strings');
const Cursor = require('pg-cursor');
</code></pre>
<p>const {map, mergeMap, tap, observeOn, expand, concatAll, concatMap, catchError, takeWhile, takeUntil} = require('rxjs/operators');</p>
<p>The class</p>
<pre><code>class HandleQuery {
constructor(installations, weeks, client, ws) {
    this.processing = 0;
    this.installations = installations;
    this.weeks = weeks;
    this.client = client;
    this.csvStream = format({headers: true});
    return this;
}

runAll() {
    console.log('run all');
    const installationQueue = from(this.installations);
    installationQueue.subscribe(i =&gt; {
        console.log(i.installation);
        if (this.weeks.rows.length &gt; 0) {
            this.runWeek(this.weeks.rows, i);
        }
    });
}

createCsvPipe(week, installation) {
    const fileDate = week.readingdate.toISOString().split('T')[0];
    const fileName = 'creps_' + installation.installation + '_' + fileDate + '.csv';
    console.log('Writing to ' + fileName);
    const ws = fs.createWriteStream(fileName, {autoClose: false});
    return this.csvStream.pipe(ws);
}

runWeek(weeks, installation) {
    let latterWeek = {readingdate: new Date()};
    if (weeks.length &gt; 1) {
        latterWeek = weeks.pop();
    }

    from(weeks).subscribe(beginningWeek =&gt; {
        console.log('week');
        this.processing++;

        const csv = this.createCsvPipe(beginningWeek, installation);

        const cursor = weekDataQuery(this.client, installation.installation, beginningWeek.readingdate, latterWeek.readingdate);
        latterWeek = beginningWeek;

        const observableCursor = bindNodeCallback(cursor.read.bind(cursor));
        observableCursor(BATCH_SIZE)

            .pipe(map(rows =&gt; {
                console.log(JSON.stringify(rows));
                rows.forEach(row =&gt; {
                    console.log(JSON.stringify(row));
                    if (!(row instanceof Array)) {
                        // csv.write(row);
                    }
                });
            }))
            .pipe(expand(() =&gt; {
                    console.log('expanding');
                    console.log(typeof observableCursor);
                    observableCursor(BATCH_SIZE)
                        .pipe(map(meme =&gt; {
                            return meme
                        }));
                })
            )
            //  .pipe(takeUntil(rows =&gt; rows.length === 0))
            .subscribe((data) =&gt; {
                    if (data) {
                        console.log('data is ' + JSON.stringify(data));
                    }
                },
                err =&gt; {
                    console.log('error is ' + err);
                }, () =&gt; {
                    console.log('complete');
                    cursor.close();
                    csv.end();
                    this.ws.close();
                }
            );
    });   
</code></pre>
","1099823","","","","","2020-11-05 03:18:58","How to expand() in RxJS 6 and node when exporting data","<node.js><postgresql><rxjs6>","0","0","","","","CC BY-SA 4.0"
"64711926","1","64713308","","2020-11-06 09:24:03","","4","389","<p>I have a stream of data being long polled every 10 seconds. Long pol can be <strong>paused</strong> and be <strong>continued</strong>.</p>
<p><strong>Problem is</strong>: It starts over when It continues. I have to make It continue from the second It was paused.</p>
<p>So if:</p>
<p><strong>delay(10000)</strong></p>
<p><strong>paused at (7000)</strong></p>
<p>Then when I start the long polling again my data has to be pulled after (10000-7000)=<strong>3000</strong></p>
<p>Today is the <strong>fourth day</strong> I have been stuck with this problem and going insane..</p>
<p>I have created this blitz</p>
<p><a href=""https://stackblitz.com/edit/ang7-working-rxjs-stream-timer-combined?file=src/app/app.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/ang7-working-rxjs-stream-timer-combined?file=src/app/app.component.ts</a></p>
<p>Created a flow and a timer which pulls data. When flow and timer stops, sets the time that was left along with the new delay. But still when I press start It doesnt wait 3 more seconds It just cals the service right away which I dont want</p>
","1549707","","","","","2020-11-07 21:29:27","In Rxjs How to pause a stream of data and continue from the second It was paused?","<javascript><angular><rxjs><reactive><rxjs6>","3","3","3","","","CC BY-SA 4.0"
"64762537","1","64768159","","2020-11-10 03:41:32","","2","68","<p>Quick context: I'm displaying a &quot;live&quot; image slideshow, meaning as images are being displayed, users can upload images &amp; those new images should display (eventually). This is &quot;infinite&quot;, meaning I want to restart at the first image once all images have been emitted. New incoming images should go to the end of the queue &amp; emit once I loop back to them.</p>
<p>I've come up with what I think is a dirty &amp; incorrect solution that boils down to:</p>
<pre class=""lang-js prettyprint-override""><code>const srcArray = [-2, -1];
const userImageUpload$ = interval(2000).pipe(
  tap((val) =&gt; srcArray.push(val))
).subscribe();

const liveImages$ = zip(interval(1000), from(srcArray)).pipe(
  map(([a, b]) =&gt; b),
  repeat()
).subscribe((val) =&gt; console.log(&quot;Image &quot; + val));
</code></pre>
<p>Here we have a starting array of some &quot;images&quot;. The <code>userImageUpload$</code> represents the idea of new images incoming. When I get one I push it into the starting array. <code>liveImages$</code> represents the values I want emitted. This technically works, but altering this shared global array feels bad and may lead to issues. Is there a good solution to do this all in one, possibly with the use of subjects? I'm having trouble coming up with a solution.</p>
","13382950","","","","","2020-11-10 11:34:47","Repeatedly emitting values from a growing array","<rxjs><rxjs6>","3","0","","","","CC BY-SA 4.0"
"64773679","1","","","2020-11-10 17:22:55","","0","155","<p>How can I change the value of an observable <strong>multiple</strong> times using <a href=""https://github.com/cartant/rxjs-spy"" rel=""nofollow noreferrer"">rxjs-spy</a>'s <a href=""https://github.com/cartant/rxjs-spy#module-let"" rel=""nofollow noreferrer"">let()</a> method?</p>
<p>I was following <a href=""https://cartant.github.io/rxjs-spy/"" rel=""nofollow noreferrer"">this introduction</a> of the tool and when I came up to the example for using let():
<code>spy.let(&quot;people&quot;, source =&gt; source.mapTo(&quot;mallory&quot;));</code>
I got stuck because <code>source</code> is an <code>Observable&lt;any&gt;</code> which does not have a <code>mapTo()</code> method. So this line should <em>just work</em> when pasted into my chrome console but since mapTo() is long gone it throws an exception.</p>
<p>The only method that I could think of didn't work. This allows me to access the rxjs operators</p>
<pre><code>// In a top level typescript file (I add this file to debug builds only)
// This just lets me use rxjs operators, of, and tag, in the chrome console
import { tag } from 'rxjs-spy/operators/tag';
import { create } from 'rxjs-spy';
import * as operators from 'rxjs/operators';
import { of } from 'rxjs/observable/of';
window['debug'] = {
  rxjs: { operators, of },
  spy: { tag }
};
const spy = create();
</code></pre>
<p>then I have an observable somewhere</p>
<pre><code>myObservable.pipe(
  tag(&quot;foo&quot;)
)
</code></pre>
<p>And in the chrome console. (note: I have also tried this without using pipe and tag)</p>
<pre><code>spy.let(&quot;foo&quot;, fooObservable =&gt; window.debug.rxjs
    .of(1)
    .pipe(
        window.debug.spy.tag(&quot;foo&quot;)
    )
);
</code></pre>
<p><strong>This only works the first time I try to update the value</strong>. And I feel like this is way too much work anyway.</p>
<p>The last issue I'm not understanding is after using <code>spy.let(...)</code> I thought that <code>spy.undo(1)</code> (replacing 1 with whatever value is correct at the time) might be able to help me test multiple values but it blows out the snapshots, giving me something like:</p>
<pre><code>spy.show()
0 snapshot(s) matching /.+/
</code></pre>
<p>I also get this warning a lot while using the tool</p>
<pre><code>index.js:3551 Cyclic next detected; type = subject; value = [object Object]; subscribed at
Observable._subscribe (http://localhost:4200/vendor.js:291983:33)
Observable.subscribe (http://localhost:4200/vendor.js:291934:22)
http://localhost:4200/vendor.js:291217:44
notify_ (http://localhost:4200/vendor.js:291076:9)
</code></pre>
","4986679","","4986679","","2020-11-10 17:28:59","2020-11-10 18:09:58","How can I make rxjs-spy's let operator work?","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"64841098","1","","","2020-11-15 04:03:58","","0","33","<p>I'm making an 'alert' service. When a new alert comes in, I want to show an alert for a duration. During this duration, I don't want to show other alerts that may have come in. I only want to move to the next alert AFTER the current one is done. So essentially I want to emit the value then wait a duration before emitting the next value.</p>
<p>This can be represented like:</p>
<pre class=""lang-js prettyprint-override""><code>const incomingAlerts$ = interval(1000);

const alerts$ = incomingAlerts$.pipe(
  concatMap((alert) =&gt; alert.pipe(delay(3500)))
);
</code></pre>
<p>This is close to what I want, but delay waits BEFORE emitting the value. Is there an operator or possible set up that will emit the value then wait before emitting the next value (if there is one)?</p>
","13382950","","","","","2020-11-16 18:58:16","Emit value then wait for duration before next emission","<rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"65032362","1","","","2020-11-27 05:09:26","","1","212","<p>I am trying to load data in chunks on timely basis. for this I am using thee methods.</p>
<p><strong>This function loads data from a json object that I am using to mimic api data</strong></p>
<pre><code> getScrollingData(startIndex, endIndex){
    if(this.items.data.length&gt;endIndex){
      return of(this.items.data.slice(startIndex, endIndex));
    }else{
      return of(null)
    }
  }
</code></pre>
<p><strong>The getData method below is being used to send request every two seconds</strong></p>
<pre><code>getData(){
const secondsCounter = interval(2000); 
return secondsCounter
.pipe(
  flatMap((res) =&gt; {
    if(res!=null)
     return this.mimicApiService.getScrollingData(res, res+10)
            .takeUntil(v =&gt; v != null)// this causes error
  }),
  
  
)
</code></pre>
<p>}</p>
<p><strong>In the ngOnInit of component I am subscribing to  getData to load that data into array to be displayed on the screen</strong></p>
<pre><code>data = [];
ngOnInit() {
  this.dataService.getData().subscribe((res)=&gt;{
    this.data = [...this.data, ...res];
  });
}
</code></pre>
<p><strong>Questions</strong></p>
<ol>
<li>I am getting error <code>Argument of type '(v: any) =&gt; boolean' is not assignable to parameter of type 'Observable&lt;any&gt;'</code> from takeUntil. Can you please tell why this happens?</li>
</ol>
","3866848","","3866848","","2020-11-27 06:03:15","2020-11-27 06:40:48","How to get data in chunks from an API using rxjs interval and stop when there is no data left","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"65071040","1","","","2020-11-30 09:33:50","","1","139","<p>I have been struggling to figure out why the HTTP requests are not been canceled using the switchMap operator.</p>
<pre><code>import {Observable, of, Subject, Subscription, timer} from 'rxjs';
import {HttpClient} from '@angular/common/http';

constructor(private http: HttpClient) {}

ngOnInit(): void {
  const makeRequest$ = new Subject();
  const myResponse$ = makeRequest$.pipe(switchMap((id) =&gt; {
    const url = `${environment.apiUrl()}/accounts?${id}`;
    return this.http.get&lt;any&gt;(url, {
      headers: {
        'Content-Type': 'application/json'
      }
    });
}));

myResponse$.subscribe(d =&gt; console.log(d));


makeRequest$.next(1);
makeRequest$.next(-3);
makeRequest$.next(3); }
</code></pre>
<p>The following code will print only the response of the third call, but won't cancel the rest of the HTTP requests.</p>
<p>I have an interceptor for HTTP failure responses, which will fire an alert due to the second call with the wrong id.</p>
<p>When I am trying this code in stackblitz it WORKS and requests are been canceled.
I am using Angular10.</p>
<p>Any setting that I am missing?</p>
","6486203","","","","","2020-11-30 09:33:50","RxJS switchMap operator does not cancel http request","<angular><observable><rxjs6><angular10><switchmap>","0","7","0","","","CC BY-SA 4.0"
"65105471","1","65105826","","2020-12-02 09:36:49","","0","48","<p>I'm trying to do some Trello automation so I'm making an API call to create a list, which returns an ID. Then, if I specified card names, I need to make another set of calls in parallel using the list ID. Whether or not I create cards, I want to return the ID of the list which was created.</p>
<p>The compiler doesn't like what I did on the <code>iif</code> call though, saying this:</p>
<blockquote>
<p>TS2345: Argument of type 'Observable&lt;string[]&gt;' is not assignable to parameter of type '(value: HasId, index: number) =&gt; ObservableInput'.   Type 'Observable&lt;string[]&gt;' provides no match for the signature '(value: HasId, index: number): ObservableInput'.</p>
</blockquote>
<p>I'm not sure exactly why it wants to assign to <code>(value: HasId, index: number) =&gt; ObservableInput&lt;any&gt;</code> though, so I don't know how to fix.</p>
<p>This was the code that I tried to use.</p>
<pre class=""lang-js prettyprint-override""><code>interface HasId {
    id: string
}

private createCard(idList: string, name: string): Observable&lt;string&gt; { ... }

private createList(boardId: string, name: string, cards?: string[]): Observable&lt;string&gt; {
  let idList = ''

  return this.http.post&lt;HasId&gt;(`boards/${boardId}/lists`, null, {params: {name}})
    .pipe(
      tap(x =&gt; idList = x.id),
      mergeMap(
        iif(
          () =&gt; cards,
          forkJoin(cards.map(name =&gt; this.createCard(idList, name)))
      )),
      map(() =&gt; idList)
    )
}
</code></pre>
","1455351","","1455351","","2020-12-02 09:44:16","2020-12-02 10:32:02","Angular rxjs conditionally call HTTP endpoint","<rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"65111311","1","65111772","","2020-12-02 15:39:30","","2","247","<p>Why isn't it possible to convert a <code>promise</code> to an <code>observable</code> and then use it with <code>withLatestFrom</code>. It's not clear to me, why this doesn't resolve.</p>
<pre><code>of('')
  .pipe(
    withLatestFrom(from(myPromise)),
    map((res) =&gt; {
      console.log('does not resolve', res);
    })
  )
  .subscribe();
</code></pre>
","1494353","","","","","2020-12-03 14:57:41","How to use withLatestFrom with a promise?","<javascript><rxjs><rxjs6>","2","2","","","","CC BY-SA 4.0"
"65188540","1","65195570","","2020-12-07 19:59:13","","1","69","<p>Contrived example of what I'm trying to do here:</p>
<pre><code>const source = interval(1000);
const errorWhenThisEmits = timer(2500);

source.pipe(/* someOperatorHere? */).subscribe({
  next: () =&gt; console.log('next!'),
  error: (err) =&gt; console.log(err)
});

// desired outcome:
// 1000ms: next!
// 2000ms: next!
// 2500ms: error message
</code></pre>
<p>Is it possible to cause the source observable to error when the second observable emits a value?</p>
<p><code>takeUntil</code> gets close, but completes instead of errors.</p>
","2506594","","2506594","","2020-12-07 20:18:06","2020-12-08 08:31:53","RxJS Error Observable when another emits value","<javascript><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"65297321","1","","","2020-12-14 22:19:33","","0","45","<p>In my Angular app , and to test some features in HorLigne mode , i need to mock http usefull responses :</p>
<ul>
<li>the 200 OK return containing some data</li>
<li>the 404 KO return with no data</li>
</ul>
<p>Usually i tried this :</p>
<pre><code>@Injectable()
export class VerifService {
  mockedResult = false;
  verifData(mail, uuid) {
    if (this.mockedResult) {
      return ObservaleOf({ status: &quot;OK&quot; }).pipe(delay(3000));
    } else {
      return throwError({ status: 500, message: &quot;not found&quot; }).pipe(
        delay(3000)
      );
    }
  }
}
</code></pre>
<p>After that within my component i m doing this :</p>
<pre><code>this.verifService.verifData(mail, uuid).subscribe(data=&gt;{
  console.log('THIS WORKS')
}, err =&gt; {
  console.log('THIS FAILS')
}
</code></pre>
<p>For the case <strong>mockedResult</strong>  equals true , the successful 200 OK return is working</p>
<p>But for the 404 error return , it's not working</p>
<p>Is there any other good way to mock the <strong>404</strong> <strong>error</strong> <strong>observable</strong> return ?</p>
<p><strong>Suggestions ?</strong></p>
","4957388","","","","","2020-12-15 15:21:09","Angular 9 : rxjs 6 : how to return a manual Observable of Error","<javascript><angular><rxjs><rxjs6><rxjs-observables>","1","2","","","","CC BY-SA 4.0"
"65344324","1","65344653","","2020-12-17 16:11:29","","1","130","<p>I have an API with 3 GET calls.</p>
<ol>
<li>Get environments</li>
<li>Get products</li>
<li>Get status for specific product in specific environment</li>
</ol>
<p>What I am trying to do is to poll the status of each product in each environment every 5 minutes, so that I can display the data in a table which is refreshed.</p>
<p>The call to fetch envs and products should be executed once, since this is static information.</p>
<pre><code>let envs = this.http.get('http://my-api/envs);
let products = this.http.get('http://my-api/products);

forkJoin([envs, products]).subscribe(results =&gt; {
  //the code below should be executed every 5 mins and store the results in array
  results[0].forEach(env =&gt; {
    results[1].forEach(product =&gt; {
      this.http.get('http://my-api/status/${env}/${product}')
    })
  })
})
</code></pre>
<p>Any help would be appreciated.</p>
","1420142","","1420142","","2020-12-17 16:42:48","2020-12-17 18:29:13","Timer in ForkJoin","<angular><rxjs><rxjs6>","1","2","1","","","CC BY-SA 4.0"
"65368293","1","65370906","","2020-12-19 09:15:21","","1","44","<p>To emit any click from child to parent we can make use of @output in the child and in parent html we can listen to that event using the way shown below</p>
<p><strong>&lt;app-item-output (newItemEvent)=&quot;addItem($event)&quot;&gt;</strong></p>
<p>in parent we can write method <strong>addItem($event)</strong> and do our work but is there any way to convert it into stream so that i can use it in combination with other observable.</p>
<p>One way I can think of now is having a subject in parent and then emitting a value like below to create a stream in parent</p>
<pre><code>addItem($event) {
subject.emit()
}
</code></pre>
<p>But if we have any direct way to convert the event emitted from child into observable that would be better.</p>
","9834715","","5535245","","2020-12-19 09:33:14","2020-12-19 14:36:21","Is there any way to convert event emitted by child component using @output into observable stream in parent","<angular><rxjs><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"65378752","1","65381265","","2020-12-20 10:03:39","","0","42","<p>I use the <code>async</code> pipe in Angular, or <code>takeUntil(...)</code> on components using:</p>
<pre class=""lang-js prettyprint-override""><code>export class BaseComponent implements OnDestroy {
  ngUnsubscribe = new Subject&lt;void&gt;();

  ngOnDestroy(): void {
    this.ngUnsubscribe.next();
    this.ngUnsubscribe.complete();
  }

}
</code></pre>
<p>But, I've always wondered what I need to do when using <code>from(myPromise)</code>.  Promises only provide a single result, but I've converted it to an observable so it feels like if I make an equivalent method that provides an observable instead that I should be using <code>take(1)</code> or unsubscribing depending on use since I don't always subscribe directly and instead use it in an <code>exhaustMap(() =&gt; this.hasTokenExpired$()</code>.</p>
<pre class=""lang-js prettyprint-override""><code>  public async hasTokenExpired(): Promise&lt;boolean&gt; {
    const token = await this.getToken();

    if (token) {
      return this.jwtHelper.isTokenExpired(token);
    }

    return true;
  }

  // Observable equivalent method:
  public hasTokenExpired$(): Observable&lt;boolean&gt; {
    return from(this.hasTokenExpired()); // Could pipe `take(1)` permanently
  }
</code></pre>
<p>Should I being using <code>take(1)</code> on <code>from(myPromise)</code>? It's been on my mind for awhile in case this causes a memory leak, but I can't find an article confirming that I should.</p>
<p>Also, if there's a better way to make these kinds of observable equivalent methods I'm always open to suggestions.</p>
","1148107","","","","","2020-12-20 15:00:36","Using RxJs would you unsubscribe when using from(myPromise)?","<angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"65467190","1","","","2020-12-27 15:11:41","","1","48","<p>Haven't touched RxJs for a while :-(</p>
<p>I can't figure out how to take values in batches of 10, anybody can help ?</p>
<p>For example</p>
<pre><code>import { interval } from 'rxjs';
import { toArray, take, tap } from 'rxjs/operators';

interval(100)
  .pipe(
    take(10),
    tap(item =&gt; {
       // Should receive 10 x 10 items which would equal 100 
    })
  )
  .subscribe(console.log);
</code></pre>
<p>Trying to do so batch, the above is an example of a simplified version of what I am trying to acheive. Basically, the tap should receive 10 items at a time until there is no more.</p>
<p>Currently, the tap receives 10 items, 1 by 1, so I was thinking of using a toArray (anything better ? ) - but this doesn't help me with continuing after the 10 has been received.</p>
<p>What am I missing?</p>
<p>Thanks in advance</p>
","14896738","","","","","2020-12-28 01:25:31","RxJS: Take in batches of 10 until outer observable completes?","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"65502265","1","","","2020-12-30 05:03:41","","0","88","<p>I have an api that's returning a <code>400 Bad Request</code> with a <code>Content-Type=text/plain</code>, however I can't access the string response because the responseType is json, which produces an error on parsing the content, making the <code>response</code> null and by looking at the attached <code>XMLHttpRequest</code>, the <code>responseText</code> property says <code>[Exception: DOMException: Failed to read the 'responseText' property from 'XMLHttpRequest': The value is only accessible if the object's 'responseType' is '' or 'text' (was 'json'). at XMLHttpRequest.invokeGetter (&lt;anonymous&gt;:2:14)]</code>.</p>
<p>So, I'm left wondering how this responseType is set and eventually how to access the response as text content. The request is made by using the <code>ajax.post</code> method from rxjs with the only header set being <code>Content-Type: &quot;application/json&quot;</code>. By looking at the <a href=""https://github.com/ReactiveX/rxjs/blob/6.6.3/src/internal/observable/dom/AjaxObservable.ts#L90-L99"" rel=""nofollow noreferrer"">source code</a> it seems you can customize this property, however it also seems it would affect the <code>AjaxResponse</code> which actually is JSON, so I'll have a problem on the successfull response.</p>
<p>I think code isn't necessary but I'll add it to see if it might be a problem in the way I implemented the library:</p>
<p>baseApi.ts (just to simplify applying defaults, since rxjs lacks an <code>instance</code> option like axios, defaultHeaders is just content type):</p>
<pre><code>...
post&lt;ResponseType = unknown, BodyType = unknown&gt;(
    url: string,
    body?: BodyType,
    headers?: object,
  ) {
    return ajax
      .post(new URL(url, API_URL).toString(), body, {
        ...defaultHeaders,
        ...headers,
      })
      .pipe&lt;ResponseType&gt;(map(response =&gt; response.response));
  },
...
</code></pre>
<p>ApiClient.ts (as you can see, I'm not passing any other header)</p>
<pre><code>...
createAlarm: (alarm: Omit&lt;Alarm, &quot;Id&quot;&gt;) =&gt;
      baseApi.post&lt;Alarm&gt;(&quot;/alarms/create&quot;, alarm),
...
</code></pre>
<p>The ajax error in question:</p>
<pre><code>{
  &quot;message&quot;: &quot;ajax error 400&quot;,
  &quot;name&quot;: &quot;AjaxError&quot;,
  &quot;xhr&quot;: {
    &quot;onabort&quot;: null,
    &quot;onloadend&quot;: null,
    &quot;onloadstart&quot;: null,
    &quot;onprogress&quot;: null,
    &quot;readyState&quot;: 4,
    &quot;response&quot;: null,
    &quot;responseText&quot;: &quot;[Exception: DOMException: Failed to read the 'responseText' property from 'XMLHttpRequest': The value is only accessible if the object's 'responseType' is '' or 'text' (was 'json'). at XMLHttpRequest.invokeGetter (&lt;anonymous&gt;:2:14)]&quot;,
    &quot;responseType&quot;: &quot;json&quot;,
    &quot;responseURL&quot;: &quot;http://...:5000/alarms/create&quot;,
    &quot;status&quot;: 400,
    &quot;statusText&quot;: &quot;Bad Request&quot;,
    &quot;timeout&quot;: 0,
    &quot;withCredentials&quot;: false
  },
  &quot;request&quot;: {
    &quot;async&quot;: true,
    &quot;crossDomain&quot;: true,
    &quot;withCredentials&quot;: false,
    &quot;headers&quot;: {
      &quot;Content-Type&quot;: &quot;application/json&quot;
    },
    &quot;method&quot;: &quot;POST&quot;,
    &quot;responseType&quot;: &quot;json&quot;,
    &quot;timeout&quot;: 0,
    &quot;url&quot;: &quot;http://...:5000/alarms/create&quot;,
    &quot;body&quot;: &quot;{}&quot;
  },
  &quot;status&quot;: 400,
  &quot;responseType&quot;: &quot;json&quot;,
  &quot;response&quot;: null
}
</code></pre>
<p>My version of rxjs is <code>^6.5.4</code>.</p>
","4579817","","","","","2020-12-30 05:03:41","Wrong responseType in RXJS AjaxError","<javascript><typescript><rxjs><rxjs6>","0","0","","","","CC BY-SA 4.0"
"65572621","1","","","2021-01-05 02:56:08","","0","84","<p>I use angular9, rxjs6 and implement canActive: Observable <br>
But I got an error when use catchError, like this:</p>
<p><a href=""https://i.stack.imgur.com/Q0Xuu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Q0Xuu.png"" alt=""enter image description here"" /></a></p>
<p>How can I fix this?</p>
<p>I tried update to: but it still not work.
<a href=""https://i.stack.imgur.com/lxcaU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lxcaU.png"" alt=""enter image description here"" /></a></p>
","4732036","","4732036","","2021-01-05 07:37:21","2021-01-05 07:47:59","Angular 9 implement canActive: Observable<boolean>, catchError failed ts check","<angular><rxjs6>","2","0","","","","CC BY-SA 4.0"
"65665750","1","","","2021-01-11 11:07:58","","0","23","<p>I'm using a table component that renders tables dynamically.
It has an input property which takes</p>
<p><code>{data: observable&lt;array&lt;any&gt;&gt;, cols: array&lt;any&gt;}</code></p>
<p>Sometimes there are 2+ tables in a component active with different data and cols, but when one data observable is called the subscription gets executed in every table component.
The structure I use in my app:</p>
<pre><code>&lt;parent&gt;
  &lt;child1&gt;
    &lt;ctable TableParameters=tp&gt;
  &lt;/child1&gt;
  &lt;child2&gt;
   &lt;ctable TableParameters=tp&gt;
  &lt;/child2&gt;
&lt;/parent&gt;
</code></pre>
<p>I update the data in the child like this:</p>
<pre><code>class child1 {
  tp: TableParameters;
  private tableData = new BehaviorSubject&lt;Array&lt;Entry&gt;&gt;([]);
  private tableData_ = this.tableData.asObservable();
  constructor(..) {
   this.tp = { Data: this.tableData_, Columns: this.tableColums, Actions: true };
  }
.. 
  updateData(data) {
    this.tableData.next(data);
  }
}
</code></pre>
<p>When updating any dataset the subscription is executed in every table component, but with the right data.</p>
<p>Is there an explanation for this?</p>
","6236935","","","","","2021-01-11 11:07:58","Subscription executes from different observable and components","<angular><rxjs6>","0","0","","","","CC BY-SA 4.0"
"65673794","1","","","2021-01-11 20:07:05","","0","417","<p>As I'm trying to use <strong>filter</strong> like this.<br></p>
<pre><code>    beginnerCourses$: Observable&lt;Course[]&gt;;
    advancedCourses$: Observable&lt;Course[]&gt;;

    ngOnInit() {

      const http$ = createHttpObservables('/api/courses');

    const courses$ = http$.pipe(
      map(res =&gt; Object.values(res[&quot;payload&quot;]))
    )

      this.beginnerCourses$ = http$
      .pipe(
          map(courses =&gt; courses
              .filter(course =&gt; course.category == 'BEGINNER')) //here problem is showing
      );
      
      this.advancedCourses$ = http$
      .pipe(
        map(courses =&gt; courses
          .filter(course =&gt; course.category == 'ADVANCED')) //here problem is showing
      );

      courses$.subscribe(courses =&gt; {
        this.beginnerCourses$ = courses.filter(course =&gt; course.category == 'BEGINNER'); //its working here
        this.advancedCourses$ = courses.filter(course =&gt; course.category == 'ADVANCED'); //its working here
      }, noop,
      () =&gt; console.log('completed'));
    }
</code></pre>
<p>The problem is  <code>Property 'filter' does not exist on type 'unknown'</code> for <br>
<code>map(courses =&gt; courses.filter(course =&gt; course.category == 'BEGINNER')))</code> and <br><code>map(courses =&gt; courses.filter(course =&gt; course.category == 'ADVANCED')))</code></p>
<p>As i'm enrolled in a course it shows this way and in his tutorial its working. But i don't know what i'm missing here.</p>
<p><strong>Update 1:</strong>
Used it.</p>
<pre><code>.pipe(
  map((courses: any[]) =&gt; courses.filter(
    course =&gt; course.category == 'BEGINNER')
  )
);
</code></pre>
<p>But in Edge Console it shows.</p>
<pre><code>ERROR TypeError: courses.filter is not a function
</code></pre>
","10668235","","10668235","","2021-01-11 20:28:46","2021-01-11 21:31:04","Property 'filter' does not exist on type 'unknown' Observable<Course[]> in Rxjs 6","<javascript><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"65693554","1","","","2021-01-12 23:28:13","","-1","62","<p>Property 'interval' does not exist on type 'typeof Observable'. Even though its imported in and I dont know why it wont work. Ive seen some posts about this involving angular 6 but this is angular 11 so I hope someone can help me figure this out.</p>
<pre><code>import { Component, OnInit } from '@angular/core';
import { TokenService } from '../../authentication/services/token.service';
import { Router } from '@angular/router';
import { HttpErrorResponse } from '@angular/common/http';
import { AdminService } from '../../authentication/services/admin.service';
import { CrudService } from '../services/crud.service';
import { Observable } from 'rxjs';
import { switchMap, startWith } from 'rxjs/operators';
@Component({
  selector: 'app-admin-dashboard',
  templateUrl: './admin-dashboard.component.html',
  styleUrls: ['./admin-dashboard.component.css'],
})
export class AdminDashboardComponent {
  constructor(
    private _token: TokenService,
    private _router: Router,
    private _admin: AdminService,
    private _crud: CrudService
  ) {}

  adminId: string;
  adminName: string;
  adminEmail: string;
  userCount$: Observable&lt;any&gt;;
  userCount: string;

  ngOnInit(): void {
    this._token.verifyToken().subscribe(
      (res) =&gt; {
        this.adminId = res.admin._id;
        localStorage.setItem('adminid', this.adminId);
        this._admin.getAdminById(this.adminId).subscribe((res) =&gt; {
          this.adminName = res.admin.name;
          this.adminEmail = res.admin.email;
          // this._crud.getUserCount().subscribe((count) =&gt; {
          //   this.userCount$ = count.count;
          // });
          this.userCount$ = Observable.interval(1000)
            .startsWith(0)
            .switchMap(() =&gt; {
              this._crud.getUserCount().subscribe((count) =&gt; {
                this.userCount = count.count;
              });
            });
        });
      },
      (err) =&gt; {
        if (err instanceof HttpErrorResponse) {
          if (err.status === 400) {
            this._router.navigate(['/login']);
          }
        }
      }
    );
  }
}

</code></pre>
","14700925","","","","","2021-01-13 00:20:52","Property 'interval' does not exist on type 'typeof Observable'. Even though its imported","<javascript><angular><rxjs><rxjs6><rxjs-observables>","2","4","","","","CC BY-SA 4.0"
"65710733","1","65711943","","2021-01-13 22:30:45","","0","166","<pre><code>of([1,2,3]).subscribe(console.log)
</code></pre>
<p>prints:<code>[1,2,3]</code></p>
<p>But:</p>
<pre><code>of([1,2,3]).pipe(concatAll()).subscribe(console.log)
</code></pre>
<p>prints:</p>
<pre><code>1
2
3
</code></pre>
<p><strong>Why the above happens?</strong> Why adding <code>concatAll()</code> emits the elements of the array one by one? Isn't this somehow the opposite of what the word concat means?</p>
<p>I feel that <code>concatAll()</code> acts differently depending on the input.</p>
<p>Consider also this:</p>
<pre><code>from([of(1),of(2),of(3)]).pipe(concatAll()).subscribe(console.log)
</code></pre>
<p>It will again print:</p>
<pre><code>1
2
3
</code></pre>
<p>So <code>of([1,2,3]).pipe(concatAll())</code> <strong>==</strong> <code>from([of(1),of(2),of(3)]).pipe(concatAll())</code></p>
<p>But <code>of([1,2,3])</code> <strong>!=</strong> <code>from([of(1),of(2),of(3)])</code> because subscribing to the latter will print:</p>
<pre><code>Observable { _isScalar: false, _subscribe: [Function] }
Observable { _isScalar: false, _subscribe: [Function] }
Observable { _isScalar: false, _subscribe: [Function] }
</code></pre>
<p>The right side of the above equality is pretty clear to me, but where is documented that <code>concatAll()</code> should emit all the values of the array separately, acting like a pipeable <code>from</code>?</p>
","1555615","","","","","2021-01-14 00:55:04","How can of([1,2,3]).pipe(concatAll()) emit 3 values when of([1,2,3]) emits one?","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","0","1","","","CC BY-SA 4.0"
"65712585","1","65717677","","2021-01-14 02:31:01","","-1","62","<p>I'm using angular and <code>rxJS</code> I'm pretty new to <code>rxJS</code> operators and can't find a way to keep everything inside a stream.</p>
<p>My stream is pretty long so I'll get straigth to the point explaining the problem I'm dealing with</p>
<p>I need to run parralel <code>Observables</code> that can be triggered multiple times and process their data in the same manner, but their subscription needs to be in a certain order. for example</p>
<pre class=""lang-typescript prettyprint-override""><code>    firstObservable$.pipe(
      map(() =&gt; secondObservable$),//this will only be triggered once
      tap(value =&gt; doSomething(value)),//data is processed once following the stream
      mergeMap(() =&gt; ThirdObservable$),//this one will be triggered multiple times but is subscribed in a particular order
      tap(value =&gt; doAnotherThing(value)),//how can I attach the processing og data to the observable?
      mergeMap(() =&gt; FourthObservable$),//this one will be triggered multiple times but is subscribed in a particular order
      tap(value =&gt; andAnother(value)),//how can I attach the processing og data to the observable?
      map(() =&gt; FifthObservable$),//this will only be triggered once
      tap(value =&gt; again(value))//data is processed once following the stream
    ).subscribe()
</code></pre>
<p>now my problem is that if <code>ThirdObservable$</code> is triggered as second time it will continue the rest of the stream and call <code>FourthObservable$</code> and <code>FifthObservable$</code> I would like the equivalent of</p>
<pre class=""lang-typescript prettyprint-override""><code>    firtsObservable$.subscribe( // triggered Once
      (value) =&gt; secondObservable$.subscribe( // triggered Once
        (secondValue) =&gt; {
          processSecondValueOnce(secondValue)
          ThirdObservable$.subscribe(thirdValue =&gt; process(thirdValue)) // this can be triggered multiple times
          fourthObservable$.subscribe(fourthValue =&gt; process(fourthValue)) // this can be triggered multiple times
          fifthObservable$.subscribe( // triggered Once
            (fifthValue) =&gt; {
              process(fifthValue)
            }
          )
        }
      )
    )

</code></pre>
","1713208","","13680115","","2021-01-14 06:31:25","2021-01-14 10:55:19","is it possible to avoid nested subscription?","<angular><rxjs><rxjs6>","1","4","0","","","CC BY-SA 4.0"
"65734214","1","","","2021-01-15 10:15:00","","3","467","<p>I found various solutions for RxJS WebSocketSubject automatic reconnection, but nothing worked for me.</p>
<p>In my RxJS 6.5 / Angular Code there is a <code>connectToWebsocket()</code> function which is executed once on startup, containing this:</p>
<pre><code>    const openObserver: NextObserver&lt;Event&gt; = {
        next: () =&gt; console.debug('[Websocket] Connected')
    };
    const closeObserver: NextObserver&lt;CloseEvent&gt; = {
        next: () =&gt; console.debug('[Websocket] Disconnected')
    };

    // Connect to WebSocket Server
    this.websocketConnection= new WebSocketSubject({
        url: &quot;ws://localhost:4000&quot;,
        deserializer: e =&gt; e.data,
        openObserver,
        closeObserver
    });
</code></pre>
<p>After creating the Subject, I subscribe to it:</p>
<pre><code>    this.websocketConnection.subscribe((msg) =&gt; {
        this.data = msg;
    },
    (err) =&gt; {
        console.log(&quot;Error on on connection&quot;, err);
    },
    () =&gt; {
        console.log(&quot;Connection closed&quot;);
    });
</code></pre>
<p>So now, if initially or while connected, the connection is closed by any circumstances. How can I reconnect to the websocket server? Do I need to write an own reconnection strategy or is there one already in RxJS?</p>
<p>Thanks in advance!</p>
","11190764","","","","","2021-01-15 10:39:51","How to retry / reconnect to Websocket server with RxJS WebSocketSubject","<angular><websocket><rxjs><rxjs6>","0","0","1","","","CC BY-SA 4.0"
"65757049","1","","","2021-01-17 03:27:11","","0","31","<p>I have a expressjs backend as below:</p>
<pre class=""lang-js prettyprint-override""><code>import * as express from 'express';
import * as cors from 'cors';
import * as bodyParser from 'body-parser';
import * as compression from 'compression';
import * as cookieParser from 'cookie-parser';

const app = express();
app.use(cors());
app.use(compression());
app.use(bodyParser.text({ type: 'text/plain' }));
app.use(bodyParser.json({ type: 'application/json' }));

app.post('/login', (req, res, next) =&gt; {
  res.cookie('token', 'abc123', {
    httpOnly: false,
    path: '/token',
  })
  res.send('yada tada 123');
});

app.post('/token', cookieParser(), (req, res, next) =&gt; {
  const cookies = req.cookies;
  console.log('cookies:', cookies);
  res.json(cookies);    
});

...
</code></pre>
<p>It works well when I use Postman to test it out, but it doesn't in my frontend Reactjs with rxjs/ajax version 6.6.3.
Below is my frontend code:</p>
<pre class=""lang-js prettyprint-override""><code>const apiURL = 'https://localhost:3535';
export function claim(token: string) {
  const url = `${apiURL}/login`;

  const options = {
    'Content-Type': 'text/plain',
    withCredentials: true,
  };

  return ajax.post(url, token, options);
}

export function refreshToken() {
  const url = `${apiURL}/token`;

  return ajax.post(url);
}


claim(tokenId).subscribe(res =&gt; {
  refreshToken().subscribe(res =&gt; {
    console.log('res:', res); // res.response is empty object {}
  });
});
</code></pre>
<p>Is there anything I missed in my code?</p>
","4971940","","","","","2021-01-17 03:27:11","Unable get cookies using RXJS ajax","<express><rxjs><rxjs6>","0","0","","","","CC BY-SA 4.0"
"65768480","1","","","2021-01-18 03:32:53","","0","50","<p>I want to Bind a single Observable  to an element in Angular using two-way binding. I have tried below scenario but its getting error . How can I resolve it?.</p>
<p><strong>ProductService.ts</strong></p>
<pre><code>import { AngularFireDatabase } from '@angular/fire/database';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
@Injectable({
  providedIn: 'root'
})
export class ProductService {

  constructor(private db: AngularFireDatabase) { }

  create(product) {
    return this.db.list('/products').push(product);
  }
  getAll(): Observable&lt;any&gt; {
    return this.db.list('/products').snapshotChanges() as Observable&lt;any&gt;;
  }
</code></pre>
<p>//ERROR
get(productId): Observable {
return this.db.object('/products' + productId).valueChanges() as Observable;
}
}</p>
<p><strong>ProductFormComponent.ts</strong></p>
<pre><code>import { Router, ActivatedRoute } from '@angular/router';
import { ProductService } from './../../product.service';
import { CategoryService } from './../../category.service';
import { Component, OnInit } from '@angular/core';
import { take } from 'rxjs/operators';
@Component({
  selector: 'app-product-form',
  templateUrl: './product-form.component.html',
  styleUrls: ['./product-form.component.css']
})
export class ProductFormComponent implements OnInit {
  categories$;
  product: {};
  id: string;
  constructor(
    private router: Router,
    private route: ActivatedRoute,
    private categoryService: CategoryService,
    private productService: ProductService) {

    this.categories$ = categoryService.getCategories();

    this.id = this.route.snapshot.paramMap.get('id');
    if (this.id) this.productService.get(this.id).pipe(take(1)).subscribe(p =&gt; this.product = p);
  }

  ngOnInit(): void {
  }


  save(product) {
    this.productService.create(product);
    this.router.navigate(['/admin/products']);
  }
}
</code></pre>
<p><strong>ERROR</strong>
<a href=""https://i.stack.imgur.com/yEKpl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yEKpl.png"" alt=""Angular Template Error"" /></a></p>
<p><strong>product-form.component.html</strong></p>
<pre><code>&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;
    &lt;form #f=&quot;ngForm&quot; (ngSubmit)=&quot;save(f.value)&quot;&gt;
      &lt;div class=&quot;form-group col-md-6 mb-3&quot;&gt;
        &lt;label for=&quot;title&quot; class=&quot;form-label&quot;&gt;Product Name&lt;/label&gt;

        &lt;input #title=&quot;ngModel&quot; [(ngModel)]=&quot;product.name&quot; name=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot;
          aria-describedby=&quot;productHelp&quot; required&gt;
        &lt;div id=&quot;productHelp&quot; class=&quot;form-text&quot;&gt;Enter Product Name.&lt;/div&gt;
        &lt;div class=&quot;alert alert-danger&quot; *ngIf=&quot;title.touched &amp;&amp; title.invalid&quot;&gt;
          Product Name is Required.
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group mb-3&quot;&gt;
        &lt;label for=&quot;price&quot; class=&quot;form-label&quot;&gt;Price&lt;/label&gt;
        &lt;div class=&quot;input-group mb-3&quot;&gt;
          &lt;span class=&quot;input-group-text&quot;&gt;₹&lt;/span&gt;
          &lt;input #price=&quot;ngModel&quot; [(ngModel)]=&quot;product.price&quot; name=&quot;price&quot; type=&quot;number&quot; class=&quot;form-control&quot; id=&quot;price&quot;
            required [min]=&quot;0&quot;&gt;

        &lt;/div&gt;
        &lt;div class=&quot;alert alert-danger&quot; *ngIf=&quot;price.touched &amp;&amp; price.invalid&quot;&gt;
          &lt;div *ngIf=&quot;price.errors.required&quot;&gt;Price is Required.&lt;/div&gt;
          &lt;div *ngIf=&quot;price.errors.min&quot;&gt;Price should Be 0 'zero' or Higher.&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group mb-3&quot;&gt;
        &lt;label for=&quot;category&quot; class=&quot;form-label&quot;&gt;Category&lt;/label&gt;
        &lt;select #category=&quot;ngModel&quot; [(ngModel)]=&quot;product.category&quot; name=&quot;category&quot; id=&quot;category&quot; class=&quot;form-control&quot;
          required&gt;
          &lt;option value=&quot;&quot;&gt;&lt;/option&gt;
          &lt;option *ngFor=&quot;let c of categories$ | async&quot; [value]=&quot;c.key&quot;&gt;
            {{c.payload.val().name}}
          &lt;/option&gt;
        &lt;/select&gt;
        &lt;div class=&quot;alert alert-danger&quot; *ngIf=&quot;category.touched &amp;&amp; category.invalid&quot;&gt;
          Category is Required.
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group mb-3&quot;&gt;
        &lt;label for=&quot;imageUrl&quot; class=&quot;form-label&quot;&gt;Image Url&lt;/label&gt;
        &lt;input #imageUrl=&quot;ngModel&quot; [(ngModel)]=&quot;product.imageUrl&quot; name=&quot;imageUrl&quot; type=&quot;text&quot; class=&quot;form-control&quot;
          id=&quot;imageUrl&quot; required url&gt;
        &lt;div class=&quot;alert alert-danger&quot; *ngIf=&quot;imageUrl.touched &amp;&amp; imageUrl.invalid&quot;&gt;
          &lt;div *ngIf=&quot;imageUrl.errors.required&quot;&gt; Image Url is Required.&lt;/div&gt;
          &lt;div *ngIf=&quot;imageUrl.errors.url&quot;&gt; Please Enter a valid URL.&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;button class=&quot;btn btn-primary&quot;&gt;Save&lt;/button&gt;
    &lt;/form&gt;

  &lt;/div&gt;
  &lt;div class=&quot;col-md-6&quot;&gt;
    &lt;div class=&quot;card&quot; style=&quot;width: 18rem;&quot;&gt;
      &lt;img [src]=&quot;imageUrl.value&quot; class=&quot;card-img-top&quot;&gt;
      &lt;div class=&quot;card-body&quot;&gt;
        &lt;h5 class=&quot;card-title&quot;&gt;{{title.value}}&lt;/h5&gt;
        &lt;p class=&quot;card-text&quot;&gt;
          {{price.value | currency:'INR':'symbol'}}&lt;/p&gt;
        &lt;h6&gt;Category&lt;span class=&quot;badge rounded-pill bg-secondary&quot;&gt;{{category.value}}&lt;/span&gt;&lt;/h6&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
","7813148","","","","","2021-01-18 03:32:53","How To Bind Firebase Single Observable in Angular Two Way binding Method","<angular><observable><angularfire><angular-services><rxjs6>","0","0","","","","CC BY-SA 4.0"
"65834915","1","68132628","","2021-01-21 19:59:33","","1","23","<p>Here is an example that can be run with ts-node. Why is the value displayed in result 2 instead of 3.</p>
<pre><code>import { interval, Subject } from 'rxjs';
import { startWith, takeUntil, tap, map } from 'rxjs/operators';

const done = new Subject();
let times = 0;

function test() {
  return interval(5000).pipe(
    startWith(0),
    map(() =&gt; times++ ),
    tap(n =&gt; {
      console.log(n);
      if (n === 3) {
        done.next();
      }
    }),
    takeUntil(done),
  ).toPromise();
}

test().then(n =&gt; {
  console.log('result: ', n);
}).catch(err =&gt; {
  console.error('error: ', err.message);
});
</code></pre>
<p>output is: what expecting result: 3</p>
<pre><code>0
1
2
3
result:  2
</code></pre>
","2475472","","","","","2021-06-25 14:26:08","toPromise doesn't return last observed value","<rxjs6><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"65924044","1","65926439","","2021-01-27 17:13:24","","4","139","<p>I want to <strong>emit</strong> one value when the original observable completes let's say like below, using the imaginary operator <code>mapComplete</code>:</p>
<pre class=""lang-js prettyprint-override""><code>let arr = ['a','b', 'c'];

from(arr)
.pipe(mapComplete(()=&gt;'myValue'))
.pipe(map((v)=&gt;`further processed: ${v}`))
.subscribe(console.log)
//further processed: myValue
</code></pre>
<p>I tried the following which work but don't seem suitable:</p>
<p><strong>1.</strong></p>
<pre class=""lang-js prettyprint-override""><code>from(arr)
.pipe(toArray())
.pipe(map(()=&gt;'myValue'))
.pipe(map((v)=&gt;`further processed: ${v}`))
.subscribe(console.log);
//further processed: myValue
</code></pre>
<p><strong>Issue:</strong> If the original observable is a huge stream, i don't want to buffer it to an array, just to emit one value.</p>
<p><strong>2.</strong></p>
<pre class=""lang-js prettyprint-override""><code>from(arr)
.pipe(last())
.pipe(map(()=&gt;'myValue'))
.pipe(map((v)=&gt;`further processed: ${v}`))
.subscribe(console.log);
//further processed: myValue
</code></pre>
<p><strong>issue:</strong> If the stream completes without emitting anything I get an error: <code>[Error [EmptyError]: no elements in sequence]</code></p>
<p>What would be a correct (in rxjs terms) way to do the above?</p>
","1555615","","","","","2021-01-28 22:00:10","How should I emit a single value when observable completes?","<rxjs><observable><rxjs6>","3","0","","","","CC BY-SA 4.0"
"65993715","1","65995195","","2021-02-01 13:39:04","","0","65","<p>I'm trying to achieve next:</p>
<pre><code>private beginTransaction(): Observable() {
  ..
}

private test(): void {
  this.beginTransaction().subscribe((): void =&gt; {
    this.commitTransaction();
  });

  this.beginTransaction().subscribe((): void =&gt; {
     this.commitTransaction();
  });
}
</code></pre>
<p><strong>beginTransaction can be called concurrently, but should delay the observable until first or only one beginTransaction finished.</strong></p>
<p><strong>In order words: Only one transaction can be in progress at any time.</strong></p>
<p>What have I tried:</p>
<pre><code>private transactionInProgress: boolean = false;
private canBeginTransaction: Subject&lt;void&gt; = new Subject&lt;void&gt;();

private bla3(): void {

  this.beginTransaction().subscribe((): void =&gt; {
    console.log('beginTransaction 1');
    this.commitTransaction();
  });

  this.beginTransaction().subscribe((): void =&gt; {
    console.log('beginTransaction 2');
    this.commitTransaction();
  });

  this.beginTransaction().subscribe((): void =&gt; {
    console.log('beginTransaction 3');
    this.commitTransaction();
  });
}

private commitTransaction(): void {
  this.transactionInProgress = false;
  this.canBeginTransaction.next();
}

private beginTransaction(): Observable&lt;void&gt; {

  if(this.transactionInProgress) {
    return of(undefined)
    .pipe(
      skipUntil(this.canBeginTransaction),
      tap((): void =&gt; {
        console.log('begin transaction');
      })
    );
  }
  this.transactionInProgress = true;
  return of(undefined);
}
</code></pre>
","403145","","","","","2021-02-03 14:26:46","RxJs - how to make observable behave like queue","<rxjs><queue><rxjs6>","2","0","","","","CC BY-SA 4.0"
"66068156","1","","","2021-02-05 17:49:38","","0","38","<p>I have a product table with 20 rows. I have to display the product image on each row which I should get from another service. The limitation is the image API takes only one product id at a time to return the image URL. So I have to make 20 API calls to get 20 images.</p>
<p>I am trying to do using the reactive approach and trying to subscribe to the API in the template itself as below</p>
<pre><code>      &lt;div  let-product-data=&quot;getProductImage(1234)| async&quot; &gt;
        
          &lt;img  src=&quot;{{product-data.image}}&quot;&gt;

      &lt;/div&gt;
</code></pre>
<p>TS Code :</p>
<pre><code>      getProductImage(imageId) {
         const url = `${environment.DEV}/product/stockroomInfo`;
         return this.http.post(url, {id:imageId});
      }
     
</code></pre>
<p>But the above code is not working. Can someone help me with what I am making wrong here?</p>
<p>Or this won't work this way? should I go for some other approach. Suggestions, please</p>
","9588631","","9588631","","2021-02-05 17:59:48","2021-02-08 01:00:22","Creating a variable inside angular template and assign data from API in template itself","<angular><rxjs><rxjs6><rxjs-observables>","1","3","","","","CC BY-SA 4.0"
"66143095","1","66143236","","2021-02-10 18:44:56","","0","32","<p>As I'm using this technique to get dummy data from <strong>SWAPI</strong>.<br></p>
<pre><code>const httpStarwars$ = createHttpObservables('https://swapi.dev/api/films/');    
fromEvent&lt;any&gt;(this.sTxt.nativeElement,'keypress').pipe(
   map(event =&gt; event.target.value),
   debounceTime(400),
   distinctUntilChanged(),
   switchMap(val =&gt; httpStarwars$.pipe(
      map(res =&gt; Object.values(res[&quot;results&quot;]))
   ))
).subscribe(courses =&gt; console.log(courses));
</code></pre>
<p>Here is the expected result after key press.<br></p>
<pre><code>0: {title: &quot;A New Hope&quot;, episode_id: 4, opening_crawl: &quot;It is a period of civil war.
↵Rebel spaceships, st…er
↵people and restore
↵freedom to the galaxy....&quot;, director: &quot;George Lucas&quot;, producer: &quot;Gary Kurtz, Rick McCallum&quot;, …}
1: {title: &quot;The Empire Strikes Back&quot;, episode_id: 5, opening_crawl: &quot;It is a dark time for the
↵Rebellion. Although the… remote probes into
↵the far reaches of space....&quot;, director: &quot;Irvin Kershner&quot;, producer: &quot;Gary Kurtz, Rick McCallum&quot;, …}
2: {title: &quot;Return of the Jedi&quot;, episode_id: 6, opening_crawl: &quot;Luke Skywalker has returned to
↵his home planet of…
↵struggling to restore freedom
↵to the galaxy...&quot;, director: &quot;Richard Marquand&quot;, producer: &quot;Howard G. Kazanjian, George Lucas, Rick McCallum&quot;, …}
3: {title: &quot;The Phantom Menace&quot;, episode_id: 1, opening_crawl: &quot;Turmoil has engulfed the
↵Galactic Republic. The t…ustice in the
↵galaxy, to settle the conflict....&quot;, director: &quot;George Lucas&quot;, producer: &quot;Rick McCallum&quot;, …}
4: {title: &quot;Attack of the Clones&quot;, episode_id: 2, opening_crawl: &quot;There is unrest in the Galactic
↵Senate. Several t…THE REPUBLIC
↵to assist the overwhelmed
↵Jedi....&quot;, director: &quot;George Lucas&quot;, producer: &quot;Rick McCallum&quot;, …}
5: {title: &quot;Revenge of the Sith&quot;, episode_id: 3, opening_crawl: &quot;War! The Republic is crumbling
↵under attacks by t…ate mission to rescue the
↵captive Chancel
</code></pre>
<p>Now I want to filter the result of the above data below using filters.<br></p>
<pre><code>map(res =&gt; Object.values(res[&quot;results&quot;]))
</code></pre>
<p>What I will filter is <code>title</code>. So far what I used is this technique below.<br></p>
<pre><code>map(res =&gt; Object.values(res[&quot;results&quot;]).filter(j =&gt; j[&quot;title&quot;] == res))
</code></pre>
<p>It gave me empty array like this <code>[]</code>.</p>
<p><strong>UPDATE 1:</strong></p>
<p><a href=""https://i.stack.imgur.com/k6PzK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/k6PzK.png"" alt=""array of object"" /></a></p>
<p><strong>Update 2:</strong>
<a href=""https://i.stack.imgur.com/S13gv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/S13gv.png"" alt=""error"" /></a></p>
","10668235","","10668235","","2021-02-10 19:08:42","2021-02-10 19:28:33","Object.values filter on 'keypress'","<javascript><rxjs><javascript-objects><rxjs6><rxjs-observables>","1","4","","","","CC BY-SA 4.0"
"66196522","1","","","2021-02-14 14:42:41","","0","19","<p>saveData$ is an observable that emits multiple values.</p>
<p>I want to send an e-mail once all the values are successfully emitted.</p>
<p>Currently, an email is sent for every value that is emitted.</p>
<p>How do I send the email once, after all of the values are successfully emitted?</p>
<pre><code>saveData$.pipe(
  switchMap((value) =&gt; {
    return this.service
      .sendEmail(
        this.id
      )
      .pipe(
        catchError((error) =&gt; {
          return throwError({
            customErrorType: 'Error sending email on create',
            error,
          });
        })
      );
  })
).subscribe();
</code></pre>
","5606717","","","","","2021-02-14 15:08:45","Angular and RxJS - send email after all values successfully emitted","<angular><rxjs6>","1","1","","","","CC BY-SA 4.0"
"66199360","1","","","2021-02-14 19:38:30","","0","107","<p>I have problem with RxJS and redux-observable. I am newbie in RxJS. Generally, I have a epic which listen for me some action. And I would like to group these actions so that each of them is performed one after the other after and if some condition is a met. I try from a long time and I cannot find solution.</p>
<p>This is my case:</p>
<ul>
<li>I made upload files like in Google Drive.</li>
<li>User select 10 files and upload them, but at the same time can only be uploaded only 3 files, rest waiting in their queue.</li>
<li>Upload starts uploading the 1st, 2nd and 3rd file immediately.</li>
<li>After uploading one of them, the upload of the next one from the list starts (4 file from list, order is required)</li>
</ul>
<p>To show how it looks more or less I created such a pseudcode, the <code>waitUntilConditionIsMet</code> method does not exist, but it would show a method that would wait indefinitely until condition is true</p>
<pre><code>const MAX_PARALLEL_UPLOAD_QUERIES = 3
let currentlyUploadingCounter = 0

export const exampleEpic = (action$) =&gt; action$.pipe(
  ofType(
    EXAMPLE_ACTION,
  ),
  waitUntilConditionIsMet(() =&gt; (
    currentlyUploadingCounter &lt; MAX_PARALLEL_UPLOAD_QUERIES
  ), 1000),
  mergeMap(async (action) =&gt; {
    currentlyUploadingCounter += 1;
  
    await someAsyncAction()
    
    currentlyUploadingCounter -= 1;
    
    return {
      type: EXAMPLE_ACTION_SUCCESS,
    }
  }
)
</code></pre>
<p>Currently it works for me on a recursive basis (in mergeMap performs the same action with delay if condition is false), but this works bad (files are randomly loaded).</p>
","4230207","","","","","2021-02-14 19:38:30","RxJS and redux-observable. Wait until some condition is met","<javascript><reactjs><rxjs><rxjs6><redux-observable>","0","0","","","","CC BY-SA 4.0"
"66247366","1","","","2021-02-17 17:51:27","","1","29","<p>The following code works as I would expect.
It prints: <code>1000</code> after 1 second</p>
<pre class=""lang-js prettyprint-override""><code>const { of } = require('rxjs');
const { publish } = require('rxjs/operators');


const source = of(1000);
const connectable = source.pipe(publish());
connectable.subscribe((v)=&gt;console.log(v))
setTimeout(() =&gt; {
    connectable.connect();    
}, 1000);
</code></pre>
<p>But the following (where I use a Subject) doesn't print anything:</p>
<pre class=""lang-js prettyprint-override""><code>const { Subject } = require('rxjs');
const { publish } = require('rxjs/operators');

const source = new Subject();//Custom subject
const connectable = source.asObservable().pipe(publish());
source.next(1000);

connectable.subscribe((v)=&gt;console.log(v))
setTimeout(() =&gt; {
    connectable.connect();    
}, 1000);

</code></pre>
<p>Same happens if I move <code>source.next()</code> directly after <code>new Subject()</code></p>
<p>Why I don't see anything printed in the second case?</p>
","1555615","","1555615","","2021-02-17 18:01:07","2021-02-17 20:43:51","Why publish() / connect() works with of() but does not work with custom Subject?","<node.js><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"66311923","1","66312238","","2021-02-22 07:58:28","","0","61","<p>I want to find string sequence with rxjs</p>
<p>for example</p>
<p>Target string: <code>01234010</code></p>
<p>Match stringe: <code>01</code></p>
<p>answer = 2</p>
<p>I have a solution with using javascript</p>
<pre><code>let index = 0;
while (true) {
  let foundIndex = targetSequence.indexOf(matchSequence, index);
  if (foundIndex == -1) break;

  index = foundIndex + 1;
}
</code></pre>
<p>but the problem is that I have to use rxjs with those skeleton code</p>
<pre><code>import { from, Observable } from &quot;rxjs&quot;;
const targetSequence = `01234010`;
const matchSequence = &quot;01&quot;;

const _target = from(targetSequence);
const _output: Observable&lt;number&gt; = _target.pipe(
  // here is your code
);

_output.subscribe({
    next: val =&gt; console.log(`count : ${val}`)
  });
</code></pre>
<p>do you guys have any idea?</p>
","12905645","","","","","2021-02-22 08:25:22","I want to find string sequence with rxjs","<javascript><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66325390","1","","","2021-02-23 00:27:39","","0","73","<p>I'm trying to simulate read a binary file in chunks but despite using <code>bufferCount</code> it just read the whole thing in one shot...</p>
<p>Could someone enlighten me what is going on?
<a href=""https://jsfiddle.net/totszwai/h46mqupo/"" rel=""nofollow noreferrer"">https://jsfiddle.net/totszwai/h46mqupo/</a></p>
<pre><code>// A small 190kb PNG file showing a X
let xBase64PNG = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAhUlEQVQ4T6VTQQ6AMAiTN3j1uP+/yKNX3+CCCQuywproUUppO5Dt5yds/320J2L365SXwBf1ZwSiZsVAAisYSdZcElixmmwDhtxqkoGRvY/flVwUOB1YzGaywISGSGgLXr7PogxRgauXmBYJJZ5toWIhAbuN1CZ671EJfQvZbQwC9iIRrgPO/1gRgsLFCwAAAABJRU5ErkJggg==';

function base64ToBlob(dataUrl) {
  const arr = dataUrl.split(',');
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);

  while (n--) { u8arr[n] = bstr.charCodeAt(n); }
  return new Blob([u8arr], {type: mime});
}

let blob = base64ToBlob(xBase64PNG);

Rx.Observable.from(blob.arrayBuffer()).pipe(
  Rx.operators.bufferCount(10)
).subscribe(data =&gt; {
  // this dumps the whole thing in one shot instead of 19 chunks
 console.log(data); 
});

</code></pre>
","1009046","","","","","2021-02-23 00:27:39","How to read ArrayBuffer in small chunk with RxJS?","<javascript><rxjs><rxjs6>","0","1","","","","CC BY-SA 4.0"
"66330696","1","","","2021-02-23 09:45:49","","0","23","<p>I have the following code</p>
<pre><code>@Injectable()
export class ReceptionService {
 private generalInfoDataSrc$ = new BehaviorSubject&lt;any&gt;(null);
 public generalInfoData = this.generalInfoDataSrc$.asObservable();
 
 setGeneralInfo(dataSrc: GeneralInfoMModal) {
    this.generalInfoDataSrc$.next(dataSrc);
 }
}
</code></pre>
<p>From my component1 I will set the above as</p>
<pre><code>OnSelect(patient: any) {    
let generalInfo = new GeneralInfoMModal();    
generalInfo.id = patient.id;
// some other code here
// this.recepService.setGeneralInfo(generalInfo);
}

 // from component2
 // 
 ngOnInit() { getPatientDetails() }
 getPatientDetails() {
  this.receptionService.generalInfoData.pipe(mergeMap(response =&gt; {
  if (response &amp;&amp; response.id) {
    this.loading = true;
    return this.receptionService.get('User/Get' + response.id, this.sourceobj);
  } else {
    return of(null);
  }
}), takeUntil(this.unsubscribe$)).subscribe(response =&gt; {
  this.patient = response;
  this.loading = false;
}, error =&gt; {
  this.loading = false;
  // this.utility.showMsg('An error occurred while getting user.')
}, () =&gt; {

})
}
</code></pre>
<p>Every things works well. I keep on selecting a user thereby calling the User/Get api. But if in case if the api returns an error then error part is executed after which when there is a change in behaviorsubject(user is selected) it doesn't call the User/Get. Is there other way of handling errors with behaviorsubject or any other approach to handle the idea. How a behaviorsubject should be used in such a case.</p>
","4369277","","","","","2021-03-14 04:29:36","Rxjs BehaviorSubject error handling when used with mergemap","<angular7><rxjs6><behaviorsubject>","1","0","","","","CC BY-SA 4.0"
"66375595","1","","","2021-02-25 19:55:03","","1","42","<p>I'm having a problem that I want to resolve the best way. I have a request from the backend that send me a list of object <code>{key, value}</code> that is an enum, and the description of this enum. I need to use this description to &quot;translate&quot; the enum that I have in my code in some component. What I use is a pipe like this <code>{{ enum | translateEnum }}</code> this returns the description to show to the user. What I did is a Map that stores the enum as a key and the description as a value. So far so good I guess.</p>
<p>My problem: when I start the app or do a refresh and when the pipe triggers, the Map is empty because the request has been made but not have yet the result. (I trigger the request after the login). What is the best way to handle this? I'm switching to observable the Map in service but the need to subscribe this Map in every component and need to do a get like this</p>
<p><code>{{ enumsMap.has(enum) ? enumsMap.get(enum) : enum}}</code></p>
<p>seems not good. Any suggestions to do this other way?</p>
<p>All this because I see first the page only after I will receive the result of the request. After that everything works because the Map has content.</p>
<p>The pipe: (old version that I'm switching over)</p>
<pre><code>  transform(value: string): string {
    let valueTranslated = value;

    if (this.translateStatusService.enumsMap.has(value)) {
      valueTranslated = this.translateStatusService.enumsMap.get(value);
    }

    return valueTranslated;
  }
</code></pre>
<p>The service that gets the request (Already with observable):</p>
<pre><code>export class TranslateStatusService {
  
  private enumTranslateBehavior = new BehaviorSubject&lt;Map&lt;string, string&gt;&gt;(undefined);
  enums$ = this.enumTranslateBehavior.asObservable();

  enumsMap: Map&lt;string, string&gt;;

  domainURL = `${environment.API_BASE_URL}`;

  constructor(private http: HttpClient) {
    this.enumsMap = new Map&lt;string, string&gt;(undefined);
    this.saveStatusTranslations();
  }

  getStatusTranslations() {
    return this.http.get(`${this.domainURL}/enums/list`);
  }

  saveStatusTranslations() {
    this.getStatusTranslations().subscribe(mainEnum =&gt; {
      mainEnum['enums'].forEach(enumObject =&gt; {
        this.enumsMap.set(enumObject['name'], enumObject['description']);
      });
      this.enumTranslateBehavior.next(this.enumsMap);
    });
  }

}
</code></pre>
","15285775","","15285775","","2021-02-25 20:40:56","2021-02-25 20:40:56","Anulgar - Need the result of the request before view HTML content when start app or refresh","<angular><typescript><rxjs><rxjs6>","0","2","","","","CC BY-SA 4.0"
"66397753","1","66397968","","2021-02-27 10:22:30","","1","57","<p>I would like to make two sequentially calls (if the first one is completed, call the second one):</p>
<p>My Code is like:</p>
<pre><code>        myApiClient
        .firstApiCall()
        .pipe(take(1),
            concatMap (firstResult =&gt; {
            doSomethingWithResponse(firstResult);
            return myApiClient.secondApiCall();
        }), take(1))
        .subscribe(secondResult =&gt; {
            doSomethingWithResponse(firstResult);
        }, error =&gt; {
            catchSecondApiCallError(error);
        });
</code></pre>
<p>First question: is that the right way to make sequential calls?
Second question: How could I catch the error for the first Call?</p>
","6510020","","6510020","","2021-02-27 10:34:57","2021-02-27 10:48:06","Rxjs make sequential calls using concatMap","<javascript><angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"66415607","1","","","2021-03-01 01:37:26","","2","127","<p>Using Data/Action Streams via RxJS, I want to return/pass an error if a user inputs an invalid bay number. My code currently will return a bay object if it matches the number that the user inputs, <strong>BUT I can't figure out how to throw an error if the user inputs an invalid bay number that doesn't exist in my list of bays</strong></p>
<ol>
<li>In order for me to share data amongst multiple components/pages, I've done most of my stuff in the BayService class:</li>
</ol>
<pre><code>  private baysUrl = 'api/bays';

  bays$ = this.http.get&lt;Bay[]&gt;(this.baysUrl)
    .pipe(
      tap(data =&gt; console.log('Bays: ', JSON.stringify(data))),
      catchError(this.handleError)
    );

  /*--------------------------------------------------------------*/
  // Grab A Single Bay
  private baySelectedSubject = new BehaviorSubject&lt;number&gt;(0);
  baySelectedAction$ = this.baySelectedSubject.asObservable();

  selectedBay$ = combineLatest([
    this.bays$,
    this.baySelectedAction$
  ])
    .pipe(
      map(([bays, selectedBayNumber]) =&gt;
        bays.find(bay =&gt; bay.bayCode === selectedBayNumber)
      ),
    );

  selectedBayChanged(selectedBayNumber: number): void {
    this.baySelectedSubject.next(selectedBayNumber);
  }
</code></pre>
<ol start=""2"">
<li>I created an Action stream by making a BehaviorSubject. Then I created a method to emit a value onto my Action stream. I then call this method in the <code>bay.page.ts</code> where I pass the input parameter and then emit it to my Data stream.</li>
<li>I then combine my data stream and my action stream and then return a single bay object that matches the value from my action Stream.</li>
<li><strong>ISSUE</strong>: SO, I can already emit the value from a users input into my observable and return the bay object based on the number like so:</li>
</ol>
<pre><code>onSubmit() {
     this.bayDoesNotExistError = false;
      this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value);
      this.navCtrl.navigateForward([`/results/`]);
      this.bayForm.reset();
    }
</code></pre>
<p>, but <strong>HOW</strong> do I handle an Invalid number? For example, How, when a user presses the submit button after typing in a number, check if it's invalid against my observable, and then return something back to my component to display on the UI? Currently, I client-side check what the user types and then display an error, But I need to actually check if the input value actually exists in my Observable&lt;bay[]&gt; objects and if it doesn't, return an error or something back to my bay.page.ts file to display in my HTML.</p>
<p>Sorry If I didn't explain this very well as I am trying to figure out how to word it.</p>
<p>Here's my BayService:
<a href=""https://i.stack.imgur.com/SVrUn.png"" rel=""nofollow noreferrer"">BayService.ts</a></p>
<p>Here's my Bay.page.ts: <a href=""https://i.stack.imgur.com/u9gnZ.png"" rel=""nofollow noreferrer"">Bay.page.ts</a></p>
","11569843","","11569843","","2021-03-01 20:12:13","2021-03-02 05:05:17","Check if object in array of objects exists against user input in RxJS HTTP Request","<angular><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","2","","","","CC BY-SA 4.0"
"66420730","1","66420809","","2021-03-01 10:51:26","","0","31","<p>Hi I just recently discovered the power of forkjoins for APIs and trying to use it speed up load times. As the title says seeking help on best practice to run a forkjoin after a forkjoin.</p>
<p>I have a forkjoin which grabs some data for 2 x APIs. Based on the data is grabbed I need to run a 2nd forkjoin for an additional 2 x APIs.</p>
<p>In the first forkjoin for a given id I grab a form's data and UX style data.</p>
<pre><code>const form = this.apiService.getForm(id);
const style = this.apiService.getFormStructure(id);
</code></pre>
<p>In the 2nd forkjoin I want to pass the photoIds found in the form data to 2 x APIS:</p>
<pre><code>this.apiService.getPhotoUrls(photoIds)
this.apiService.getPhotoHistory(photoIds)
</code></pre>
<p>Here is what I have so far:</p>
<pre><code>let formId: string = '1';
const form = this.apiService.getForm(id);
const style = this.apiService.getFormStructure(id);


forkJoin([form, style])
.subscribe(
 (data:Object[]) =&gt; {
   // handle result
   let formData = data[1];
   let formStyle = data[2];
   let photoIds:number[] = formData.photoIds;
   //***What is the best to pass the photo Ids to run the next 2 APIS??****//
 }
);
</code></pre>
<p>Thanks so much for the help in advance!</p>
","4376500","","","","","2021-03-01 10:56:15","Angular - Forkjoin after forkjoin","<angular><rxjs6><fork-join>","1","0","","","","CC BY-SA 4.0"
"66432993","1","66433187","","2021-03-02 03:40:41","","0","180","<p>I just want to apologize for my lack of understanding of RxJS and Observables. I posted a question earlier but it was very poorly worded and I know it wasn't understandable, so after a day I think I can explain my issue better.</p>
<ol>
<li>The objective of my code is to grab user input, pass it as an action stream to my data stream, compare the input to my array of bays, if it exists, return that single bay. If it doesn't exist <strong>(This is where I'm struggling)</strong> return an observable that I can call back in my <code>bay.page.ts</code> and check to see if its <code>true</code> or <code>false</code>. If it's <code>false</code> <strong>[Show client side error]</strong>.
If it's <code>true</code>, navigate forward to the results page.</li>
<li>My <code>bay-service.ts</code> class contains my Data &amp; Actions streams:</li>
</ol>
<pre><code>export class BayServiceService {
  private baysUrl = 'api/bays';

  bays$ = this.http.get&lt;Bay[]&gt;(this.baysUrl)
    .pipe(
      tap(data =&gt; console.log('Bays: ', JSON.stringify(data))),
      catchError(this.handleError)
    );

  /*--------------------------------------------------------------*/
  // Grab A Single Bay
  private baySelectedSubject = new BehaviorSubject&lt;number&gt;(0);
  baySelectedAction$ = this.baySelectedSubject.asObservable();

  invalidBay = new BehaviorSubject&lt;boolean&gt;(false);

  selectedBay$ = combineLatest([
    this.bays$,
    this.baySelectedAction$
  ])
    .pipe(
      map(([bays, selectedBayNumber]) =&gt; {
        if (!bays.find(bay =&gt; bay.bayCode === selectedBayNumber)){
          this.invalidBay.next(false);
        } else {
          this.invalidBay.next(true);
          return bays.find(bay =&gt; bay.bayCode === selectedBayNumber);
        }
      }),
      );

  selectedBayChanged(selectedBayNumber: number): void {
    this.baySelectedSubject.next(selectedBayNumber);
  }
</code></pre>
<p>^ In the above code I use a declarative RxJS approach <code>selectedBay$</code> in which I combine my <code>bay$</code> data stream, and my <code>baySelectedAction$</code> Action Stream (Which contains the user input). I then map them and then compare the user input <code>selectedBayNumber</code> to a single bay number.</p>
<p><strong>ISSUE:</strong> I am trying to use the Observable -&gt; <code>invalidBay = new BehaviorSubject&lt;boolean&gt;(false);</code> that I created back in my <code>bay-service.ts</code> and check it's result: If it's true, navigate forward. If it's false, show a client side error that it doesn't exist. <strong>However</strong>, If the user enters a valid bay number, I try to change that Observable to <code>true</code> by doing <code>this.invalidBay.next(true);</code> BUT, the observable won't update it's value? The BehaviorObservable stays it's default value of 'false'. So the code is partially working, but not quite.</p>
<ol start=""3"">
<li>This is my <code>onSubmit</code> method in my <code>bay-page.ts</code> where I handle the user input for my action stream. I passed the user input into a method (which is in my <code>bay-service.ts</code> class). Depending on their input, I try to subscribe to the Observable that is &quot;supposedly updated&quot; and go from there. But the Observable is not being updated. Please help.</li>
</ol>
<pre class=""lang-js prettyprint-override""><code>onSubmit() {
    this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value);
    this.subscription = this.bayService.invalidBay.subscribe(value =&gt; {
        if (value) {
            this.navCtrl.navigateForward([`/results/`]);
        } else {
            this.bayDoesNotExistError = true;
            this.selectedBay = this.bayForm.get('bayStart').value;
            this.vibration.vibrate(500);
            console.log('Vibrating for 3 second...')
        }
    })
}
</code></pre>
<p>Why is the Observable not having it's value updated? Please, my mind hurts and I don't know what else to do.</p>
","11569843","","446519","","2021-03-02 08:00:27","2021-03-02 08:00:27","BehaviorSubject .next() is not emitting updated value","<angular><typescript><rxjs><rxjs6><rxjs-observables>","1","1","","","","CC BY-SA 4.0"
"66469172","1","","","2021-03-04 05:34:38","","0","23","<p>I have an rxjs that pass an id, and I need to call an api, the api will return some data and I need to process that data regards to the projectId that wasa available before the switchMap.</p>
<p>if I map it to <code>{projectId, api: this.http.get('/api/projects/'+projectId)}</code> will not work like switchmap.</p>
<pre class=""lang-js prettyprint-override""><code>selectedProject$.pipe(
    switchMap(projectId=&gt; this.http.get('/api/projects/'+projectId)), 
    map(data=&gt; this.createChart(
                    projectId, /* I need the project id that was available before the switchMap */
                        data))
)
</code></pre>
<p>I know I can set <code>tap(projectId=&gt; this.selectedProjectId=projectId)</code> and use it later, but I want to know a way to handle it with rxjs</p>
","2326139","","","","","2021-03-04 06:27:21","how to carry forward a value that was available before switchmap?","<rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"66481840","1","66483123","","2021-03-04 19:34:41","","0","70","<p>First off - I'm new to Observables.  Coming from Python.</p>
<p>I am trying to acheive:</p>
<ul>
<li>Every 500 ms call a function to return shapes from a chart
<ul>
<li>shapes are returned in an array</li>
<li>I only want a filtered subset &quot;horizontal_lines&quot;</li>
</ul>
</li>
<li>Output &quot;horizontal_lines&quot; via an observable</li>
</ul>
<p>The code below is functional - except it doesn't repeat.  I can't figure out timer, delay, or interval with RXJS 6.</p>
<pre><code>
// In this example the chart has 3 horizontal lines at 5,10 and 17 &quot;prices&quot;
// Desired output is 5 -- 10 -- 17
// When 4th line is added at 20 &quot;price&quot; expected output would be
// 5 -- 10 -- 17 -- 20


const test$ = new Observable&lt;number&gt;(observer =&gt; {
      chart
      .activeChart()
      .getAllShapes()
      .forEach((shape) =&gt; {
        if (shape.name == 'horizontal_line') {
          chart
            .activeChart()
            .getShapeById(shape.id)
            .getPoints()
            .forEach((point) =&gt; {
              observer.next(+point.price.toFixed(4));
            });
        }
      })

    }).pipe(
      delay(500),
      repeat()
</code></pre>
","2342450","","5535245","","2021-03-05 12:04:21","2021-03-05 12:04:21","RXJS Observables - Run a repeating function every 500ms and output results to an observable stream","<angular><typescript><rxjs><observable><rxjs6>","4","2","","","","CC BY-SA 4.0"
"66554068","1","66562801","","2021-03-09 20:09:54","","0","48","<p><strong>OBJECTIVE:</strong> I want to <strong>GET</strong> a single object and/or a range of objects from my backend service by passing in user inputs as HTTP params using RxJS.
For Example, I am using declarative RxJS and so I have two Subjects (Action streams) to grab the input from the user when they hit Submit. I want to pass those Subjects values, <strong>as HTTP params</strong>, into my http request in order to get either the specified bay object, or a range of bays.
The first Subject/UserInput will always be mandatory, whereas the second Subject/UserInput will be optional. So if someone enters 4 for the first input, and then nothing for the second input. The backend will accept both inputs as 4 and 'null' because nothing was put in. If that's the case, return the bay that has a bay Number of 4. If there is a second input like 6, return a range of bays from 4 -&gt; 6, if they exist.</p>
<p><strong>The Issue:</strong> How do I pass those two Subjects as http params using declarative RxJS?</p>
<p>Here are my two subjects and their method, as well as my attempt at the HTTP request in my <code>bay-service.ts</code> file.</p>
<pre><code>  private bayStartSelectedSubject = new Subject&lt;number&gt;();
  baySelectedAction$ = this.bayStartSelectedSubject.asObservable();

  private bayEndSelectedSubject = new Subject&lt;number&gt;();
  bayEndSelectedAction$ = this.bayEndSelectedSubject.asObservable();

  selectedBayChanged(selectedBayStartNumber: number, selectedBayEndNumber?: number): void {
    this.bayStartSelectedSubject.next(selectedBayStartNumber);
    this.bayEndSelectedSubject.next(selectedBayEndNumber);
  }

  private HandlingUnitResponseUrlSecondary = 'http://localhost:8080/sbtemplate/readBayInventory';


bayOrBays$ = combineLatest([
    this.baySelectedAction$,
    this.bayEndSelectedAction$
  ])
    .pipe(
      map(([bayStart, bayEnd]) =&gt; {
        mergeMap(() =&gt; this.http.get&lt;HuResponse&gt;(`${this.HandlingUnitResponseUrlSecondary}/COS/${bayStart}/${bayEnd}`))
      })
    );
</code></pre>
<p>Here is where I grab the user inputs in my <code>bay-page.ts</code> file, and call their method to emit the user inputs value:</p>
<pre><code>onSubmit() {
    this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value, this.bayForm.get('bayEnd').value);
    if(!this.invalidBay) {
      this.bayDoesNotExistError = true;
      this.selectedBay = this.bayForm.get('bayStart').value;
      this.vibration.vibrate(500);
      console.log('Vibrating for 3 second...')
    } else {
      this.navCtrl.navigateForward([`/results/`]);
    }
</code></pre>
<p>I know the code doesn't look great, but I can't find any information on this. Thanks for the help!</p>
<p><strong>Also</strong> Here is the backend API that I am trying to hit:</p>
<pre><code>@RequestMapping(value=&quot;/readBayInventory/{centerId}/{beginBayId}/{endBayId}&quot;, method = GET)
    public ResponseEntity&lt;HUResponse&gt; readBayInventory(@PathVariable String centerId, @PathVariable int beginBayId, @PathVariable(required = false) int endBayId) {
</code></pre>
","11569843","","11569843","","2021-03-09 20:43:46","2021-03-10 10:24:55","How to pass two Subjects/Action streams as HTTP Params in a GET request to return a single object/Array of objects in Angular using RxJS?","<angular><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","6","","","","CC BY-SA 4.0"
"66587780","1","","","2021-03-11 17:45:40","","0","48","<p>I have an angular ionic app with graphql. I Updated from angular 8 to 9 to 10 to 11. The migrations were successful and my app does transpile.</p>
<p>But if I try to execute the following request via apollo the subsribe method is not called but the web request return with a 200. I can see it inside the browser and can see the log of my application server. I do not know why this piece of code is not executed.</p>
<pre><code>     this.apollo.mutate({
                mutation: gql`
                    mutation Test {
                        test
                    }
                `
            }).subscribe(({data}) =&gt; {
                console.log('got data', data);
            });
</code></pre>
<p>These are my dependency imports inside the file that tries to call the mutation:</p>
<pre><code>import {Component} from '@angular/core';

import {Platform} from '@ionic/angular';
import {SplashScreen} from '@ionic-native/splash-screen/ngx';
import {StatusBar} from '@ionic-native/status-bar/ngx';
import {UserService} from &quot;./services/user.service&quot;;
import {TranslateService} from &quot;@ngx-translate/core&quot;;
import {environment} from '../environments/environment';
import {ImageService} from './services/image.service';
import {NgEventBus} from 'ng-event-bus';
import {Events} from './events/events';
import {User} from './entities/user.entity';
import {Apollo, gql} from 'apollo-angular';

</code></pre>
<p>This are my dependencies inside the project. I have already checked that my node_modules only contain these dependencies with deleting the folder and run npm install. If I create a new project everythin works fine and as expected.</p>
<pre><code> &quot;dependencies&quot;: {
    &quot;@angular-devkit/architect&quot;: &quot;^0.1102.3&quot;,
    &quot;@angular-devkit/core&quot;: &quot;^11.2.3&quot;,
    &quot;@angular/common&quot;: &quot;^11.2.5&quot;,
    &quot;@angular/core&quot;: &quot;^11.2.5&quot;,
    &quot;@angular/forms&quot;: &quot;^11.2.5&quot;,
    &quot;@angular/localize&quot;: &quot;^11.2.5&quot;,
    &quot;@angular/platform-browser&quot;: &quot;^11.2.5&quot;,
    &quot;@angular/platform-browser-dynamic&quot;: &quot;^11.2.5&quot;,
    &quot;@angular/router&quot;: &quot;^11.2.5&quot;,
    &quot;@apollo/client&quot;: &quot;^3.3.11&quot;,
    &quot;@capacitor/core&quot;: &quot;2.4.7&quot;,
    &quot;@ionic-native/core&quot;: &quot;^5.31.1&quot;,
    &quot;@ionic-native/splash-screen&quot;: &quot;^5.31.1&quot;,
    &quot;@ionic-native/status-bar&quot;: &quot;^5.31.1&quot;,
    &quot;@ionic/angular&quot;: &quot;^5.6.0&quot;,
    &quot;@ngx-translate/core&quot;: &quot;^13.0.0&quot;,
    &quot;@ngx-translate/http-loader&quot;: &quot;^6.0.0&quot;,
    &quot;apollo-angular&quot;: &quot;^2.4.0&quot;,
    &quot;graphql&quot;: &quot;^15.0.0&quot;,
    &quot;ng-event-bus&quot;: &quot;^2.0.0&quot;,
    &quot;postcss&quot;: &quot;^8.2.8&quot;,
    &quot;rxjs&quot;: &quot;~6.6.6&quot;,
    &quot;tslib&quot;: &quot;^2.0.0&quot;,
    &quot;zone.js&quot;: &quot;~0.11.3&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@angular-devkit/build-angular&quot;: &quot;^0.1102.3&quot;,
    &quot;@angular/cli&quot;: &quot;^11.2.4&quot;,
    &quot;@angular/compiler&quot;: &quot;^11.2.5&quot;,
    &quot;@angular/compiler-cli&quot;: &quot;^11.2.5&quot;,
    &quot;@angular/language-service&quot;: &quot;^11.2.5&quot;,
    &quot;@capacitor/cli&quot;: &quot;2.4.7&quot;,
    &quot;@graphql-codegen/typescript-apollo-angular&quot;: &quot;^2.3.1&quot;,
    &quot;@ionic/angular-toolkit&quot;: &quot;^3.1.0&quot;,
    &quot;@types/jasmine&quot;: &quot;~3.6.6&quot;,
    &quot;@types/jasminewd2&quot;: &quot;~2.0.8&quot;,
    &quot;@types/node&quot;: &quot;^14.14.33&quot;,
    &quot;codelyzer&quot;: &quot;^6.0.1&quot;,
    &quot;jasmine-core&quot;: &quot;~3.6.0&quot;,
    &quot;jasmine-spec-reporter&quot;: &quot;~6.0.0&quot;,
    &quot;karma&quot;: &quot;~6.1.2&quot;,
    &quot;karma-chrome-launcher&quot;: &quot;~3.1.0&quot;,
    &quot;karma-coverage-istanbul-reporter&quot;: &quot;~3.0.3&quot;,
    &quot;karma-jasmine&quot;: &quot;~4.0.1&quot;,
    &quot;karma-jasmine-html-reporter&quot;: &quot;^1.5.4&quot;,
    &quot;protractor&quot;: &quot;~7.0.0&quot;,
    &quot;ts-node&quot;: &quot;~9.1.1&quot;,
    &quot;tslint&quot;: &quot;~6.1.0&quot;,
    &quot;typescript&quot;: &quot;~4.1.5&quot;
  }
</code></pre>
<p>What am I missing?</p>
","4262710","","","","","2021-03-11 17:45:40","Angular: Subscribe is not called after successful web request","<angular><typescript><ionic-framework><graphql><rxjs6>","0","5","","","","CC BY-SA 4.0"
"66612519","1","66614374","","2021-03-13 10:42:52","","1","108","<pre><code>message$ = new Subject();

method(type) {
    return this.message$.pipe(
        filter((element) =&gt; element.type === type),
        scan((acc, val) =&gt; [...acc, val], [])
    )
}

method.subscribe()
</code></pre>
<p>I would like reset my stream in part of scan action from another method.</p>
<pre><code> reset() {
   // reset logic
}
</code></pre>
<p>If I try to reset message with message$.next() it still doesn't reset scun, but makes the reset value part of the stream.</p>
<p>How could I can to do this?</p>
","15253045","","15253045","","2021-03-13 12:30:35","2021-03-13 15:34:08","How can I reset a scan operator or stream?","<javascript><angular><rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"66633711","1","66638793","","2021-03-15 07:13:43","","1","121","<p>I've following interfaces and <code>Observable&lt;Machine[]&gt;</code>, what I want to achive is group by Machine <code>symbol</code> property in  <code>Observable&lt;Machine[]&gt;</code> and return mapped observable <code>Observable&lt;Order[]&gt;</code>.</p>
<pre><code>export interface Machine {
    symbol: string;
    price: number;
    amount: number;
    id: number;
}

export interface Order {
    symbol: string;
    machines: OrderMachine[];
}

export interface OrderMachine {
    price: number;
    amount: number;
    id: number;
}
</code></pre>
<p>I've tried to use RxJS gropBy operator but it seems it return grouped array one by one.</p>
<pre><code>machines: Machine[] = [
        { amount: 1,  id: 1, symbol: &quot;A&quot;, price: 1 },
        { amount: 1,  id: 2, symbol: &quot;A&quot;, price: 2 }
    ];


of(machines).pipe(
        takeUntil(this.unsubscribe),
        mergeMap(res =&gt; res),
        groupBy(m =&gt; m.symbol),
        mergeMap(group =&gt; zip(of(group.key), group.pipe(toArray()))),
        map(x =&gt; { // here I have probably wrong model [string, Machine[]]
            const orderMachines = x[1].map(y =&gt; { return &lt;OrderMachine&gt;{price: y.price, amount: y.amount, id: y.id }})
            return &lt;Order&gt;{ symbol: x[0], machines: orderMachines }  })
        );
</code></pre>
<p>as in result I have <code>Observable&lt;Order&gt;</code> istead of<code>Observable&lt;Order[]&gt;</code>.</p>
<p>expected result model:</p>
<pre><code>orders: Order[] = [
        {   
            symbol: &quot;A&quot;, 
            machines: [
                { amount: 1, price: 1, id: 1 },
                { amount: 1, price: 2, id: 2 }
            ]
        }
    ];
</code></pre>
","5953169","","5953169","","2021-03-15 11:02:08","2021-03-17 12:47:55","RxJS group by field and return new observable","<rxjs><rxjs5><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"66646173","1","66646935","","2021-03-15 21:53:11","","0","41","<p>I'm using declarative RxJS to return a response object from my back-end service. I am able to grab the data in my <code>bay-page.ts</code> file and display it in my html. However, I want the data to be displayed in my <code>results-page.ts</code> file. I grab the user inputs using Subjects and pass them in a method in my <code>bay-page.ts</code> file, that will then fire off the HTTP request.</p>
<p><strong>But, how do I grab those results and display them in my <code>results-page.html</code> file?</strong></p>
<p><code>bay-service.ts</code> file:</p>
<pre><code>private bayStartSelectedSubject = new Subject&lt;number&gt;();
  bayStartSelectedAction$ = this.bayStartSelectedSubject.asObservable();

  private bayEndSelectedSubject = new Subject&lt;number&gt;();
  bayEndSelectedAction$ = this.bayEndSelectedSubject.asObservable();


  selectedBayChanged(selectedBayStartNumber: number, selectedBayEndNumber?: number): void {
    this.bayStartSelectedSubject.next(selectedBayStartNumber);
    this.bayEndSelectedSubject.next(selectedBayEndNumber);
  }

  grabHuResponsePOST$ = combineLatest([
    this.bayStartSelectedAction$,
    this.bayEndSelectedAction$
  ])
    .pipe(
      switchMap(([bayStart, bayEnd]) =&gt; {
        if (bayEnd == null || bayEnd &lt;= 0) {
          bayEnd = bayStart;
        }
        let huRequest: HuRequest = {
          &quot;centerId&quot;: &quot;COS&quot;,
          &quot;beginBayId&quot;: bayStart,
          &quot;endBayId&quot;: bayEnd
        }
        const headers = new HttpHeaders({
          'Content-Type': 'application/json'
        });
        let options = {
          headers: headers
        }
        // this.invalidBay.next(true);
        return this.httpClient.post&lt;HuResponse&gt;(this.HandlingUnitResponseUrl, huRequest, options);
      }),
      tap(showDataPlease =&gt; console.log('Bays: ', JSON.stringify(showDataPlease))),
    );
</code></pre>
<p><code>bay-page.ts</code> file:</p>
<pre><code>ngOnInit() {
    this.bayForm = new FormGroup({
      'bayStart': new FormControl(null, [Validators.required]),
      'bayEnd': new FormControl(null, [Validators.required])
    });
    this.bayService.invalidBay$.subscribe(
      value =&gt; {
        console.log(value);
        this.invalidBay = value;
      }
    );
    this.bayService.grabHuResponsePOST$.subscribe(p =&gt; {

    });
  }

  onSubmit() {
    this.bayService.selectedBayChanged(this.bayForm.get('bayStart').value, this.bayForm.get('bayEnd').value);
    this.navCtrl.navigateForward([`/results/`]);
  }
</code></pre>
<p><code>results-page.ts</code> file:</p>
<pre><code>bayOrBays$ = this.bayService.grabHuResponsePOST$
    .pipe(
      map(response =&gt; response.bays),
      catchError(err =&gt; {
        this.errorMessageSubject.next(err);
        return EMPTY;
      }),
      tap(showDataPlease =&gt; console.log('Bays: ', JSON.stringify(showDataPlease)))
    );
</code></pre>
<p><code>results-page.html</code> file:</p>
<pre><code>&lt;ion-card *ngFor=&quot;let bay of bayOrBays$ | async; index as i&quot;
                    class=&quot;ion-no-margin&quot;&gt;
            &lt;ion-card-header&gt;
              &lt;ion-card-title&gt;Bay {{ bay.bayCode }}&lt;/ion-card-title&gt;
              &lt;ion-card-subtitle&gt;{{ bay.shipments.length }} Shipments&lt;/ion-card-subtitle&gt;
            &lt;/ion-card-header&gt;
          &lt;/ion-card&gt;
</code></pre>
<p>I am obviously missing something with a subscription because this doesn't work in my <code>results-page.ts</code> file, but it DOES work, if I put it in my <code>bay-page.ts</code> file.</p>
","11569843","","","","","2021-03-15 23:12:10","Using declarative RxJS, is there a way to pass Observable data to child component from parent component?","<angular><rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","7","","","","CC BY-SA 4.0"
"66700678","1","66700736","","2021-03-18 23:46:50","","0","25","<p>I've been struggling for a few hours, I am trying to grasp more advanced concepts, I thought I could use a <code>reduce</code> operator for this, but I'd like to resort to another opinion.</p>
<p>The following code loops manually through a returned array of items, inside a tap, I've used <code>of</code> just to simulate what the observable would emit.</p>
<p>What I'd like to achieve is to remap each object inside <code>arrayItems</code> to have an additional property, and the end result to be an array of objects.</p>
<p>My objective here is to ditch the tap, as I feel there are more efficient ways...</p>
<pre><code>        of([{ foo: 'bar' }, { foo: 'baz' }])
            .pipe(
                tap((arrayItems) =&gt; {
                    const arr = [];

                    arrayItems.forEach((item) =&gt; {
                        arr.push({
                            ...item,
                            extraProperty: {}
                        });
                    });

                    return of(arr);
                })
            )
            .subscribe();
</code></pre>
<p>If anyone can give me a pointer, I'll be very grateful!</p>
","1219331","","","","","2021-03-19 03:03:53","RXJS - Transforming an array of items, with operators","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"66705407","1","66706435","","2021-03-19 09:15:46","","1","45","<p>I would like to implement gap / delay between every interval call,
i have tried below but it seems not working.</p>
<pre><code>  pollOnInterval(threshold = 4000): Observable&lt;any&gt; {
    let thresholdValue = threshold;
    const increaseBy = 2000;
    const maxCount = 10;
    return interval(thresholdValue).pipe(take(maxCount)).pipe(delay(increaseBy)).pipe(map(() =&gt; {
      thresholdValue = thresholdValue + increaseBy;
      console.log((new Date).toLocaleTimeString());
    }));
  }
</code></pre>
<p><strong>output</strong><br />
2:34:21 PM<br />
2:34:25 PM<br />
2:34:29 PM<br />
2:34:33 PM<br />
2:34:37 PM<br />
2:34:41 PM<br />
2:34:45 PM<br />
2:34:49 PM<br />
2:34:53 PM<br />
2:34:57 PM</p>
<p><strong>Edit -1</strong> I have tried debounce and debouceTime, It didn't work too,
Stackbliz link: <a href=""https://stackblitz.com/edit/angular-ivy-tinm4r?file=src%2Fapp%2Fapp.component.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-ivy-tinm4r?file=src%2Fapp%2Fapp.component.ts</a></p>
<p><strong>Edit - 2</strong> I need in below way<br />
2:34:21 PM<br />
2:34:27 PM<br />
2:34:35 PM</p>
","1432240","","1432240","","2021-03-19 09:47:52","2021-03-19 10:28:48","How to put custom gap between interval for polling in Rxjs angular?","<angular><rxjs><rxjs5><rxjs6>","1","3","","","","CC BY-SA 4.0"
"66723484","1","","","2021-03-20 15:45:30","","0","44","<p>Following test case, will return the data correctly but JEST show as failed. The test is written using <code>TestScheduler</code></p>
<p>Jest Result</p>
<pre><code>    expect(received).toEqual(expected) // deep equality

    - Expected
    + Received

    - Array [
    -   Object {
    -     &quot;frame&quot;: 3,
    -     &quot;notification&quot;: Notification {
    -       &quot;error&quot;: undefined,
    -       &quot;hasValue&quot;: true,
    -       &quot;kind&quot;: &quot;N&quot;,
    -       &quot;value&quot;: Object {
    -         &quot;type&quot;: &quot;INITIALIZED&quot;,
    -       },
    -     },
    -   },
    - ]
    + Array []
</code></pre>
<p>Code</p>
<pre><code>    
import { ofType } from 'redux-observable';
import { mergeMap, map, tap } from 'rxjs/operators';
import { of, from } from 'rxjs';
import { TestScheduler } from 'rxjs/testing';


describe('routechange epic', () =&gt; {

    const testScheduler = new TestScheduler((actual, expected) =&gt; {
        expect(actual).toEqual(expected);
    });

    it('check apollo', () =&gt; {
        const dependencies = {
            apolloClient: {
                mutate: ({ mutation, variables }: { mutation: any, variables: any }) =&gt;
                    Promise.resolve({
                        data: { param: 'testA' }
                    })
            },
        };
        const initializeOrg = (action$, state$, { apolloClient }) =&gt;
            action$
                .pipe(
                    ofType('START'),
                    tap(act =&gt; console.log('---AAA', act)),
                    mergeMap(action =&gt;
                        from(
                            apolloClient.mutate({
                                mutation: `something`,
                                variables: {
                                    orgId: (action as any).params || ''
                                }
                            })
                        )
                            .pipe(
                                tap(x =&gt; console.log('----x', x)),
                                map(response =&gt; ({
                                    type: 'INITIALIZED',
                                    response,
                                }))
                            )
                    )
                );



        testScheduler.run(({ hot, cold, expectObservable }) =&gt; {
            const action$ = hot('-a', {
                a: { type: 'START', params: 'SomethingA' }
            });
            const state$ = null;

            const output$ = initializeOrg(action$, state$, dependencies);

            expectObservable(output$).toBe('---a', {
                a: {
                    type: 'INITIALIZED'
                }
            })
        });

    });
});
</code></pre>
","1595858","","","","","2021-03-21 13:51:41","RxJs with Jest case fails but the `tap` output shows correctly","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"66758601","1","","","2021-03-23 07:02:03","","0","109","<p>I have some observables that use time based operators like delay, bufferTime, etc. while waiting for real-time events and have recorded these events and would like to run the code against the recorded data instead of against the live data.</p>
<p>My current thought is that it might be possible to write a custom scheduler that is tick-based with an internal clock that's driven by the recorded events' timestamps so I can just loop over the events and the time-based observables will emit bases on that internal clock. Then I can test my software against a longer period of time without having to wait for that time to actually pass.</p>
<p>I have tried to fiddle around with schedulers but wasn't able to figure it out so far.. Is this something that can be achieved at all?</p>
<p>The code runs on nodejs, so there are no browser limitations (if there are any) that I have to take into account.</p>
<p><strong>EDIT</strong>:
The ticks have their own timestamps. The observables currently use <code>scheduler.now</code> when they need the current time, which should be in sync with the current tick's time (default scheduler being used is the asyncScheduler in the real time version).</p>
<ul>
<li><p>The software will perform some actions, depending on the incoming events, that will cause it to do a request (which I'd like to mock with cold observables that emit after a random, reasonable delay).</p>
</li>
<li><p>The requests are going to be rate limited, so it's essential that the software does not do anything while the internal loading state is true when the next tick is scheduled (unless the time of the tick advances the time enough so that's more than the request's delay)</p>
</li>
<li><p>TestScheduler is not an option as it only works with marbles (as far as I can tell)</p>
</li>
<li><p>Conventional rxjs operators to create a tick queue is not what I'm looking for (I already have that), what I think I need is a scheduler with some kind of virtual time concept (based on the ticks' timestamps) so I can loop through the queue without having to wait any actual time until I can proceed to the next tick. I'm not too familiar with the VirtualTimeScheduler, but from what I've read so far, I'd first have to create a task queue and then run it (when calling the scheduler's <code>flush</code> method). Creating the task queue is the issue here, because it'd need to be dynamic, dependent on the input data (used for the ticks) and the resulting behavior of the requests and the rate limiting</p>
</li>
</ul>
","1319140","","1319140","","2021-03-23 10:47:30","2021-03-23 10:47:30","RXJS: Scheduler with custom time/clock based on array with timestamps","<node.js><rxjs><scheduler><rxjs6>","0","3","","","","CC BY-SA 4.0"
"66830418","1","","","2021-03-27 10:43:15","","0","44","<p>I'm a beginner in angular. I created a method in a service in which I verify the existing of a user in my json file.But, I got this error :</p>
<p><code>Argument of type 'OperatorFunction&lt;any[], any[]&gt;' is not assignable to parameter of type 'OperatorFunction&lt;Object, any[]&gt;'. The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead? Type 'Object' is missing the following properties from type 'any[]': length, pop, push, concat, and 26 more.ts(2345)</code></p>
<p>custom-validation.service.ts</p>
<pre><code>validateUserNameNotTaken(control: AbstractControl){
return this.checkUsernameNotTaken(control.value).pipe(
  map(res=&gt; {
    return res ? null :{usernameTaken : true};
  })
);
}

checkUsernameNotTaken(username: string): Observable&lt;boolean&gt; {
return this.http.get(&quot;assets/fakedb.json&quot;).pipe( map((usernameList: Array&lt;any&gt;) =&gt;  usernameList.filter(user =&gt; user.username === username) ),
  map(users =&gt; !users.length)
);
}
</code></pre>
","4672898","","","","","2021-03-27 10:43:15","Argument of type 'OperatorFunction<any[], any[]>' is not assignable to parameter of type 'OperatorFunction<Object, any[]>'","<rxjs6><angular11>","0","0","","","","CC BY-SA 4.0"
"66859818","1","","","2021-03-29 18:43:27","","0","23","<p>I use angular/fire valueChanges() get a document</p>
<pre><code>const countries: Observable&lt;any&gt; = this.AngularFireStorage
      .doc('country/country')
      .valueChanges()
</code></pre>
<p>if add pipe(tap(x =&gt; console.log(x)). It will log</p>
<pre><code>{ jp: {id: jp}, us: {id: us}}
</code></pre>
<p>what I want is add pipe(tap(x =&gt; console.log(x)) and get</p>
<pre><code>{id: jp}
{id: us}
</code></pre>
<p>How to convert countries: Observable&lt;any&gt; to countries: Observable&lt;any[]&gt;</p>
","11826296","","","","","2021-03-29 21:02:08","rxjs 6 observable<any> to observable<any[]>","<angular><rxjs><angularfire><rxjs6>","2","0","","","","CC BY-SA 4.0"
"66896536","1","66903638","","2021-03-31 23:25:32","","0","46","<p>I am trying to setup a poller using expand but the behavior is not what I want</p>
<p><a href=""https://stackblitz.com/edit/rxjs-finalize-unsubscribe-6xy2yb?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-finalize-unsubscribe-6xy2yb?file=index.ts</a></p>
<p>checkExistence produces a random boolean - With the expand, I expect a recursive delayed call of the same checkExistence function producing random booleans every 5 seconds (after one initial call).</p>
<p>I also expect the stop to kick in 30seconds and stop the polling and 5 seconds later resume the random boolean stream. Any pointers will help.</p>
<p>Instead I get the same boolean value getting printed; also after the start is triggered, it produces batches of booleans together.</p>
","2789284","","","","","2021-04-01 11:25:29","Polling using expand in rxjs gives an unexpected result","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators>","1","0","","","","CC BY-SA 4.0"
"66907044","1","","","2021-04-01 15:07:44","","0","38","<p>I have a merged stream of observables,</p>
<p><code>const nextClickHandler$ = merge(doA$, doB$, doC$)</code>,</p>
<p><code>do A$/B$/C$</code> are observables which makes HTTPRequests or performs some sideeffects, they operate on some mutually exclusive conditions, where either doA$/doB$/doC$ are active and perform the network calls / side-effects.</p>
<p>The use-case is, on the click of the next button, do either A/B/C, I am facing an issue on how to subscribe to this merged observable, if I subscribe to it before-click of next, i.e.</p>
<pre><code>ngOnInit(){
    this.nextClickHandler$.subscribe()
}
</code></pre>
<p>This will be eagerly evaluating those mutually exclusive conditions and executing, without even clicking next,</p>
<p>I tried subscribing on click of goForward:</p>
<pre><code> goForward(): void {
        if (this.getCurrentStep() == 1) {
            if (this.validateForm()) {\
                //performs side-effects for either A$/B$/C$
                this.nextClickHandler$.subscribe();  
            }
            return;
        }
</code></pre>
<p>But now, when I am on the Step I again, it doesnt wait for the click of the next, since it is a long-living subscription, it just eagerly executes the behaviour, which is not what I want, I want them to be lazy-executed only when clicking next, I tried <code>take(1)</code> but that does not fix the issue, How can I achieve this?</p>
","14795040","","","","","2021-06-25 13:17:50","How to lazy evaluate merged observable, i.e. on click of button when using merge() (RxJs v6)?","<angular><typescript><rxjs><observable><rxjs6>","2","3","","","","CC BY-SA 4.0"
"66924910","1","66955214","","2021-04-02 20:31:18","","0","61","<p>I updated my project from ng 9 to ng 11, locally everything works fine but when I deploy my code to the server and try to login, I am getting Xh.Subject is not a constructor as an error.
I looked here for an answer, and found needed to replace 'rxjs/subject' with rx/js, which I did in all components that had that reference, and deployed, but still getting the same error.
Does anyone know what else could be causing this error in angular?</p>
","6457590","","","","","2021-04-05 15:11:14","Xh.Subject is not a constructor Angular 11","<angular><rxjs6>","1","1","","","","CC BY-SA 4.0"
"66934340","1","66940822","","2021-04-03 18:01:10","","0","145","<p>I'm creating a login epic and dispatching multiple actions, the multiple actions are dispatched fine within 'CatchError' but produces an error &quot;Actions must be plain objects. Use custom middleware for async actions.&quot; when dispatching the actions within the observable in the 'else' block.</p>
<pre><code>export const loginUserEpic = action$ =&gt;
action$.pipe(
    ofType(LOGIN_USER),
    switchMap(({ payload: { email, password } }) =&gt; {
      const body = {
        email: email,
        password: password
      };

  return from(axios.post(`${process.env.REACT_APP_BACKEND}/api/auth/login`, body, config)).pipe(
    map(response =&gt; {
      if (response.data.user.is_active) {
        return { type: &quot;LOGIN_SUCCESS&quot;, payload: response.data };
      } else {
        return of(
          { type: &quot;USER_LOADING&quot; },
          { type: &quot;TOGGLE_MODAL&quot; },
          updateModalData(modalTypes.EMAIL_SENT, &quot;&quot;)
        );
      }
    }),
    catchError(err =&gt;
      of({ type: &quot;LOGIN_FAIL&quot; }, createAlert(alertTypes.RED_ALERT, err.data, err.status))
    )
  );
}));
</code></pre>
","14790871","","14790871","","2021-04-04 08:50:45","2021-04-04 11:32:57","Dispatch multiple actions within RxJS + Redux + Axios","<reactjs><react-redux><rxjs><rxjs6><redux-observable>","1","4","0","","","CC BY-SA 4.0"
"66937341","1","66937597","","2021-04-04 01:44:54","","0","64","<p>I have a simple registration form made with Angular 11.2.7 and Angular Material. Here's the <a href=""https://stackblitz.com/edit/angular-yzwcrs?file=src/app/form-field-prefix-suffix-example.ts"" rel=""nofollow noreferrer"">stackblitz</a>.</p>
<p>I made changing the password fields visibility to last 3 sec and then their state changes back to &quot;password&quot;. So when user clicks on an &quot;eye&quot; in any of the password controls, the password text shows in clear text and then changes back to dots in 3 sec.</p>
<p>But the problem this state change triggers the whole form validation and all that are invalid gets &quot;invalid&quot; look (get red). Can anyone please tell me why?</p>
<p>Also, I had to use multicasting for my Observables which I might not done right. I'm not sure.</p>
","2896495","","","","","2021-04-04 03:15:00","angular reactive forms - changing input type triggers forms validation","<angular><rxjs><angular-material><rxjs6>","1","0","","","","CC BY-SA 4.0"
"67056763","1","","","2021-04-12 10:26:32","","0","76","<p>I would like to execute code when the observable complete. In my code, i execute this:</p>
<pre class=""lang-js prettyprint-override""><code>  compact(): Observable&lt;FileManifest&gt; {
    return this.loadIndex().pipe(
      mergeMap((index) =&gt; index.walk()),
      map((entry) =&gt; entry.manifest),
      notUndefined(),
      writeAllMessages(this.newPath, ProtoFileManifest),
      finalize(async () =&gt; {
        await Promise.all([
          promises.rm(this.journalPath, { force: true }),
          promises.rm(this.manifestPath, { force: true }),
        ]);
        await promises.rename(this.newPath, this.manifestPath);
      }),
    );
  }
</code></pre>
<p>The problem is that the finalize method is made for synchronous code. When i execute asynchronous code like above, the code will be executed independently from the subscribe.</p>
<p>I would like this will be execute when disposing resource of the observable but i want that when i subscribe, i always receive the event.</p>
<p>How can i put asynchronous code in the finalize method ?</p>
<p>Thanks
Ulrich</p>
","6541226","","","","","2021-04-13 04:40:51","How can i execute asynchronous code when an RxJS observable complete?","<rxjs><rxjs6>","1","2","","","","CC BY-SA 4.0"
"67118974","1","67120069","","2021-04-16 04:09:35","","1","75","<p>I have two observable data streams. One retrieves an account, one gets permissions.</p>
<p>What I need to do is check if the current user has the role of admin, or has the role of external and the current account does not have a flag set. But how to do that with rxjs is eluding me.</p>
<p>Here is a stripped down test case to show what I'm trying to do, but because all of the data isn't there when it runs (either the account is null, or the permissions haven't been loaded yet), it errors out.</p>
<p>How can I make this work?</p>
<p>I'm using rxjs6.</p>
<pre class=""lang-js prettyprint-override""><code>export class ViewComponent implements OnInit {
    private account: AdminUser;
    private permissions: Permissions;

    constructor(private _service: AdminUserService,
                private _permissions: PermissionsService,
                private _activatedRoute: ActivatedRoute) {
    }

    canEdit(): boolean {
        let isAdmin = this.permissions.hasRole('Admin');
        return isAdmin || (this._permissions.hasRole('External') &amp;&amp; !this.account.isActiveDirectory);
    }

    ngOnInit() {
        this._permissions
            .getPermissions()
            .subscribe(p =&gt; this.permissions = p);

        this._activatedRoute.params.subscribe(
            params =&gt; {
                    this._service.get(params.id)
                        .pipe(map(account =&gt; this.account = account))
                        .subscribe();
            });
    }
}
</code></pre>
","70235","","","","","2021-04-16 06:49:23","rxjs Observable mixed with pre-resolved data","<angular><rxjs><rxjs6><rxjs-pipeable-operators>","2","3","1","","","CC BY-SA 4.0"
"67139504","1","67159341","","2021-04-17 14:52:23","","3","159","<p>Considering I have the following code:</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let Rx = window['rxjs'];
const { of,
    queueScheduler,
    asapScheduler,
    asyncScheduler,
    animationFrameScheduler
} = Rx;
const { observeOn, tap } = Rx.operators;
console.clear();


let source$ = of(1, 2, 3, asapScheduler).pipe(
    tap((v) =&gt; {
        console.log('tap ', v);
    }),
)

source$.subscribe((v) =&gt; {
    console.log('Value ', v);
    Promise.resolve().then(() =&gt; {
        console.log('Microtask value ', v);
    });
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.2.1/rxjs.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<p>Which I use asapScheduler operator.</p>
<p>As per the documentation,</p>
<p>asap will wait for the current synchronously executing code to end and then it will try to execute the given task as fast as possible.</p>
<p>What's the execution order of the above code? How do they work? I would not have expected that the tap3 to print at the last</p>
<p>Below are the output,</p>
<pre><code>tap  1
Value  1  
tap  2    // here why did this not print Microtask value 1 and Microtask value 2 after printing tap1 and value1?
Value  2
Microtask value  1
Microtask value  2
tap  3
Value  3
Microtask value  3
</code></pre>
","4646531","","4646531","","2021-04-18 18:23:22","2021-04-19 09:25:57","Order of execution with rxjs asapscheduler","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators><rxjs-marbles>","2","0","","","","CC BY-SA 4.0"
"67492689","1","","","2021-05-11 18:46:35","","0","54","<p>I havent been able to make it work properly and will appreciate if someone can point out problem and issues with what I am attempting. I am not sure if issue is with chaining of observables or something else.</p>
<p><strong>Description</strong>:</p>
<ol>
<li>Post a file to server that immediately issues an id for this request</li>
<li>Subsequently check whether processing is completed for that id by polling</li>
<li>When processing is completed, access results from server using same id</li>
</ol>
<p><strong>Issues</strong>:
I see that below solution keeps on posting file instead of posting once and then arbitrarily either will escape or get results. Needless to say that I am doing something wrong.</p>
<p><strong>Attempted solution</strong> (Snippets are schematic here, so please ignore syntax etc):</p>
<ol>
<li>Main observable calls <em>Post</em> method and then calls <em>poll</em> method using id that it recieves from server</li>
</ol>
<pre><code>    this.postData(inputFormData).pipe(
          map(res =&gt; {
            console.log(res.message);
            return res.message
          }),
          catchError(
            err =&gt; {
              console.log(err.message);
              this.errorSubject.next(err.message);
              return throwError(err.message);
            }
          ),
          delay(5000),
          concatMap((id) =&gt; this.pollData(id))
        )

</code></pre>
<p>and <em>post</em> method implementation is trivial</p>
<pre><code>  postData(dataForm: any){
    let headers = this.headers;
    headers.set('Content-Type', 'multipart/form-data');
    return this.httpClient.post&lt;MessageInterface&gt;(this.endPoint, dataForm, {headers: headers})
  }
</code></pre>
<ol start=""2"">
<li><em>PollData</em> observable runs at regular interval of 5sec and checks server if status is completed. If status is completed, then it call a <em>Get</em> method and retrieves result from server</li>
</ol>
<pre><code>      pollData(id: string){
        return timer(0, 5000)
        .pipe(
          switchMap( () =&gt; {
            console.log(id);
            return this.checkStatus(id)
          }),
          map(res =&gt; res.message),
          filter(status =&gt; status === 'completed'),
          take(1),
          timeout(100000),
          concatMap(() =&gt; this.getData(id)),
          catchError(err =&gt; throwError(err))
        )
      }
</code></pre>
<p><em>checkStatus</em> is trivial</p>
<pre><code>  checkStatus(id: string){
    console.log(id);
    return this.httpClient.get&lt;MessageInterface&gt;(this.endPointMain + `/status/${id}`, {headers: this.headers})
  }
</code></pre>
<p>3 <em>Get</em> data method is trivial and uses id to fetch</p>
<pre><code>  getData(id: string){
    return this.httpClient.get(this.endPointMain + `/results/${id}`, {headers: this.headers, observe: 'response', responseType: 'blob'})
  }
</code></pre>
","5870471","","5870471","","2021-05-11 19:06:25","2021-05-11 19:06:25","RxJs polling job - is the chaining correct?","<rxjs><rxjs6><rxjs-observables>","0","3","","","","CC BY-SA 4.0"
"67554958","1","","","2021-05-16 09:24:21","","0","17","<p>Let's say I want to have:</p>
<ul>
<li>an observable of numbers <code>numbers$</code>;</li>
<li>a subject <code>addNumber$</code>;</li>
<li>a subject <code>removeNumber$</code>;</li>
</ul>
<p>I want to create <code>numbers$</code> which works like this:</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th></th>
<th><code>numbers$.subscribe()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>addNumber$.next(10)</code></td>
<td><code>[10]</code></td>
</tr>
<tr>
<td><code>addNumber$.next(20)</code></td>
<td><code>[10, 20]</code></td>
</tr>
<tr>
<td><code>removeNumber$.next(10)</code></td>
<td><code>[20]</code></td>
</tr>
<tr>
<td><code>addNumber$.next(30)</code></td>
<td><code>[20, 30]</code></td>
</tr>
<tr>
<td><code>addNumber$.next(40)</code></td>
<td><code>[20, 30, 40]</code></td>
</tr>
</tbody>
</table>
</div>
<p>Any ideas? Is it possible to avoid backing field for storing array of numbers?</p>
","3574762","","","","","2021-05-16 09:24:21","RxJS6 Observable of array with add/remove subjects","<rxjs6>","0","4","1","","","CC BY-SA 4.0"
"67589852","1","","","2021-05-18 15:58:03","","1","27","<p><strong>ngOnInit</strong> function I have defined in the <code>app.component.ts</code> as.<br></p>
<pre><code>async ngOnInit(){    
    await this.api.GetSwapi()
    await this.api.mySubject.subscribe(data =&gt; console.log); //Not getting data in console log
    await this.api.mySubject.subscribe((data: any) =&gt; console.log); //Not getting data in console log
    console.log('---------------------123123123-----------------------');//working
    await this.api.GetSwapi2().subscribe(j =&gt; console.log(j)); //Getting undefined two times
    await this.api.testSubject.subscribe(data =&gt; console.log); //Not getting data in console log
}
</code></pre>
<p>Here is my <code>api.service.ts</code>.<br></p>
<pre><code>export class ApiService {  
  constructor(private http: HttpClient) { }

  mySubject = new Subject();
  testSubject = new Subject&lt;string&gt;();

  GetSwapi(){ //FUNCTION 1
    this.http.get&lt;any&gt;('https://swapi.dev/api/people/')    
    .subscribe(data =&gt; {
        console.log(data.results);
        this.mySubject.next(data.result);        
    });
  }

  GetSwapi2(): Observable&lt;any&gt; { //FUNCTION 2
    this.http.get&lt;any&gt;('https://swapi.dev/api/people/')
    .subscribe(data =&gt; {        
        this.mySubject.next(data.result);        
    });
    this.testSubject.next('woooow');
    return this.mySubject.asObservable();
  }
}
</code></pre>
<p>Only this show <strong>undefined</strong> two times <code>await this.api.GetSwapi2().subscribe(j =&gt; console.log(j));</code><br>
others cannot see the data in <code>console.log</code>
I'm just trying to get data in my <code>app.component.ts</code>.</p>
","10668235","","","","","2021-05-18 18:43:22","Angular Observable returns Subscriber instead of JSON and string shows undefined and no result","<angular><typescript><rxjs><rxjs6><angular12>","1","1","","","","CC BY-SA 4.0"
"67605936","1","","","2021-05-19 15:08:26","","0","78","<p>I am trying to convert from an observable of an array:</p>
<pre class=""lang-js prettyprint-override""><code>of([1, 2, 3]);
</code></pre>
<p>Into an array of observables:</p>
<pre class=""lang-js prettyprint-override""><code>[ of(1), of(2), of(3) ]
</code></pre>
<p>But I am out of ideas. I have tried the following:</p>
<pre class=""lang-js prettyprint-override""><code>of([1, 2, 3]).pipe(map((elements: number[]) =&gt; elements.map(element =&gt; of(element)))
</code></pre>
<p>But this gives me something like this, with an outer observable that I do not desire.</p>
<pre class=""lang-js prettyprint-override""><code>of([ of(1), of(2), of(3) ])
</code></pre>
<p>As I want to join the result with other arrays, it is not convenient for me to just subscribe to the outer observable in order to get the array... I think I need an opposite operator of <code>concatAll</code>. Any ideas?</p>
","11474948","","","","","2021-06-24 18:41:40","Convert observable of array into array of observables","<javascript><rxjs><rxjs6>","3","1","","","","CC BY-SA 4.0"
"67719112","1","","","2021-05-27 09:10:27","","0","36","<p>I am following this <a href=""https://stackoverflow.com/questions/60611949/how-can-i-get-use-accesstoken-in-authinterceptor-class-in-angular-8"">this</a> to add AWS access token in angular HTTP interceptor, But the code is going in an infinite loop and I am getting <code>net::ERR_INSUFFICIENT_RESOURCES</code> error.</p>
<p>The console.log of token value showing single characters.</p>
<p>Thank you in advance</p>
<p>Here is the code</p>
<p>service.ts</p>
<pre><code> getAccessToken(): Observable&lt;string&gt; {
    return from(Auth.currentSession()).pipe(
      switchMap(session =&gt; from(session.getAccessToken().getJwtToken()))
    );
  }
</code></pre>
<p>interceptor.ts</p>
<pre><code>/* eslint-disable no-param-reassign */
import { Injectable } from '@angular/core';
import {
  HttpEvent,
  HttpInterceptor,
  HttpHandler,
  HttpRequest,
} from '@angular/common/http';
import { Observable } from 'rxjs';
import { UserService } from 'app/user.service';

import { switchMap } from 'rxjs/operators';

@Injectable()
export class TokenInterceptor implements HttpInterceptor {
  constructor(public userService: UserService) {}

  intercept(
    req: HttpRequest&lt;any&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    return this.userService.getAccessToken().pipe(
      switchMap(jwtToken =&gt; {
        console.log(jwtToken);
        // clone the request to add the new header.
        req = req.clone({
          headers: req.headers.set('Authorization', `Bearer ${jwtToken}`),
        });
        if (!req.headers.has('Content-Type')) {
          req = req.clone({
            headers: req.headers.set('Content-Type', 'application/json'),
          });
        }
        return next.handle(req);
      })
    );
  }
}
</code></pre>
","7628381","","","","","2021-05-27 09:47:01","Angular 9 http Interceptor get Aws accesstoken","<angular><rxjs><angular8><aws-amplify><rxjs6>","1","0","","","","CC BY-SA 4.0"
"67792990","1","","","2021-06-01 16:53:39","","0","40","<p>I've been unable to bind to a webapi call in Angular12/Typescript.</p>
<p>The browser displays this error:
ERROR Error: Cannot find a differ supporting object '[object Object]' of type 'object'. NgFor only supports binding to Iterables such as Arrays.</p>
<p>Data is successfully being returned from the api call. I'm not sure what I'm missing here?</p>
<p><strong>Component</strong></p>
<pre><code>@Component({
  selector: 'app-system-of-record-search', 
  templateUrl: './system-of-record-search.component.html',
  styleUrls: ['./system-of-record-search.component.scss']

})
export class SystemOfRecordSearchComponent implements OnInit {
  model?: SystemOfRecord[];

  constructor(
    private configApi: ConfigApi
  ) { }
  ngOnInit(): void { 
    this.configApi.searchSystemOfRecord().subscribe(
      (data: SystemOfRecord[]) =&gt; {
        this.model = data;
      }
    );
}
</code></pre>
<p><strong>HTML</strong></p>
<pre><code>&lt;div&gt;
    &lt;div *ngIf=&quot;model&quot;&gt;
        &lt;select id=&quot;selSystemOfRecord&quot; class=&quot;form-control&quot;&gt;
            &lt;option *ngFor=&quot;let item of model&quot; [ngValue]=&quot;item.systemOfRecordId&quot;&gt;{{item.name}}&lt;/option&gt;
        &lt;/select&gt;
    &lt;/div&gt;  
&lt;/div&gt;
</code></pre>
<p><strong>Api Provider</strong>:</p>
<pre><code>  searchSystemOfRecord(): Observable&lt;SystemOfRecord[]&gt; {
    const url = `${this.domain}/api/systemofrecord/search`;
    return this.http.post&lt;SystemOfRecord[]&gt;(url, {}, { responseType: 'json' });
  }
</code></pre>
","16097313","","","","","2021-06-01 16:53:39","Angular 12 not binding to values from webapi: returns NgFor only supports binding to Iterables such as Arrays","<angular><observable><rxjs6><angular12>","0","5","","","","CC BY-SA 4.0"
"68030396","1","68031973","","2021-06-18 06:32:10","","2","59","<p>I have an observable stream which emits numbers, I want another stream that emits all 1's that are not closely followed by a 2 (within say 200ms), so for example from this source stream:</p>
<p>(every character is 100ms)</p>
<p><code>1...12...112...11121...</code></p>
<p>The result should be:</p>
<p><code>..1.......1.....11...1.</code></p>
<p>How would I do that using <code>rxjs@^6.6.7</code>?</p>
","235648","","","","","2021-06-18 08:46:54","How to emit 1's not closely followed by a 2","<rxjs><rxjs6>","2","2","","","","CC BY-SA 4.0"
"68137878","1","68137903","","2021-06-25 23:13:02","","0","37","<p>I get this error:</p>
<pre><code>Argument of type 'UnaryFunction&lt;Observable&lt;number&gt;, Observable&lt;any&gt;&gt;' is not assignable to parameter of type 'OperatorFunction&lt;{ x: number; y: number; }, any&gt;'
</code></pre>
<p>on the line:</p>
<pre><code>  this.Map.moveMap$
            .pipe(
                filter((v) =&gt; v.x !== 0 || v.y !== 0),
                this.requestTextLayerPipe(),
            )
            .subscribe();
</code></pre>
<p>Where <code>requestTextLayerPipe</code> is custom pipe:</p>
<pre><code>private requestTextLayerPipe() {
    return pipe(
        filter((currentScale: number) =&gt; currentScale &lt;= this.scaleLimitTextLayer.max || currentScale &gt;= this.scaleLimitTextLayer.min),
        map(() =&gt; this.getTextLayersId()),
        filter((dispar: string[]) =&gt; dispar.length &gt; 0),
        map((dispar: string[]) =&gt; this.getTextLayerProps(dispar)),
        switchMap((props: RequestTextLayerProps) =&gt;
            this.Map.httpClient
                .get(this.buildUrlRequestTextLayer(props), {
                    observe: 'body',
                    responseType: 'blob',
                })
                .pipe(
                    map((response) =&gt; {
                        return { props, response };
                    }),
                    catchError((error) =&gt; of(error)),
                ),
        ),
    );
}
</code></pre>
<p>Why do I get this error and how to fit it? As I got, I should return observable in filter to <code>requestTextLayerPipe</code>.</p>
","15937537","","","","","2021-06-25 23:17:06","Why custom pipe has error after filter rxjs?","<angular><rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"68174823","1","","","2021-06-29 08:07:02","","2","71","<p>A simple question regarding intervals in RxJS - I have made a carousel where slides change every minute and there is a detail that dissatisfies me. When the slide is switched manually by user to next or previous - interval will still change the slide automatically but in <em>whatever time there's left till interval fires off the new value</em>, so it disregards anything what the user did. How can I make interval know if the user changed the slide, and only from user action count a minute and then change slide automatically. Other times interval should work automatically as regular.</p>
<p>Will be happy to hear ideas, thanks!!!</p>
<p>Here's what I got:</p>
<pre><code>  source = interval(10000);

  ngOnInit(): void {
    this.source.subscribe(() =&gt; this.slide('forward'));
  }

  slide(option): void {
    switch (option) {
      case 'forward':
        this.currentSlide === this.SLIDES.length - 1 ?
          this.currentSlide = DEFAULT_SLIDE : this.currentSlide++;
        break;
      case 'back':
        this.currentSlide === DEFAULT_SLIDE ?
          this.currentSlide = this.SLIDES.length - 1 : this.currentSlide--;
        break;
    }
  }
</code></pre>
<p>Template:</p>
<pre><code>&lt;div class=&quot;sliderNav&quot;&gt;
    &lt;mat-icon (click)=&quot;slide('back')&quot;&gt;keyboard_arrow_up&lt;/mat-icon&gt;
    &lt;p&gt;{{currentSlide + 1}}/{{SLIDES.length}}&lt;/p&gt;
    &lt;mat-icon (click)=&quot;slide('forward')&quot;&gt;keyboard_arrow_down&lt;/mat-icon&gt;
&lt;/div&gt;
</code></pre>
","13898926","","","","","2021-06-29 15:08:13","Reset rxjs interval on click in Angular","<javascript><angular><typescript><rxjs><rxjs6>","2","0","0","","","CC BY-SA 4.0"
"68198889","1","68205569","","2021-06-30 17:01:51","","0","55","<p>I have an stream changes$ that emits data:</p>
<pre><code>interface Data {
  id: number,
  prop: string
}
</code></pre>
<p>This stream is switched by another that makes http request.</p>
<p>In the end I subscribe to response:</p>
<pre><code>.subscribe((response =&gt;apply() );
</code></pre>
<p>How dont call apply() method if before getting response from last request a new data were emitted to initial stream?</p>
<p>Because despite http request was sent the data is outdated, cause source stream changes$ emits a new data.</p>
","15361861","","7790376","","2021-06-30 17:20:57","2021-07-01 06:53:20","How to skip subscribe result?","<angular><rxjs><rxjs6>","1","2","2","","","CC BY-SA 4.0"
"68207157","1","","","2021-07-01 08:49:44","","0","33","<p>my IDE (intelliJ) tells me that the zip function is deprecated.</p>
<p>Would you have a solution?</p>
<pre class=""lang-js prettyprint-override""><code>zip(
  action$.pipe(successFetch(&quot;a&quot;, &quot;list&quot;)),
  action$.pipe(successFetch(&quot;b&quot;, &quot;list&quot;)),
  action$.pipe(successFetch(&quot;c&quot;, &quot;list&quot;))
)
</code></pre>
<p>its full use is as follows</p>
<pre class=""lang-js prettyprint-override""><code>action$.pipe(
    zip(
      action$.pipe(successFetch(&quot;a&quot;, &quot;list&quot;)),
      action$.pipe(successFetch(&quot;b&quot;, &quot;list&quot;)),
      action$.pipe(successFetch(&quot;c&quot;, &quot;list&quot;))
    ),
    withLatestFrom(state$),
    mergeMap(([, state]) =&gt; {
      return of(...);
    }),
    startWith(
       fetchAction(&quot;a&quot;,&quot;list&quot;),
       fetchAction(&quot;b&quot;,&quot;list&quot;),
       fetchAction(&quot;c&quot;,&quot;list&quot;)
   )
  );
</code></pre>
<p>Thank you in advance</p>
","14783402","","","","","2021-07-01 08:55:21","rxjs v6 zip deprecated","<rxjs><rxjs6>","1","0","","","","CC BY-SA 4.0"
"68449531","1","","","2021-07-20 04:25:23","","0","28","<p>I am implementing the multipart upload set of APIs from the AWS S3 SDK to handle large file uploads. According to the SDK documentation, the multipart upload needs to be explicitly closed after all part have been uploaded. This closure API call - <strong>completeMultipartUpload</strong>, requires a map of the chunks which is a mapping of the &quot;Etag&quot; field returned by uploadPart API and the part number. Because the parts order needs to be mapped by the code - I tried to use concat to make sure the next part is only uploaded when the current one is completed. However, even with concat, all the individual parts are being uploaded at the same time and they are returning at different times. This is not helping in identifying the part numbers.</p>
<p>Code is as below - I am constructing an array of Observables for the uploadParts and the trying to concat them. Using RxJs v6.6.3 and AWS SDK version v2 (SDK v3 lib-storage has an issue with browser exec otherwise that would shorten the code).</p>
<p>Why is concat not working here, is it an issue with the handling of an array of observables?</p>
<pre><code>  const FILE_CHUNK_SIZE = 5 * 1024 * 1024;
  s3SessionToken$ // API call that returns token for S3 upload
  .pipe(
    // CREATE MULTIPART UPLOAD
    concatMap((tokenVal) =&gt; {
      // Create S3 Bucket Object
      s3Obj = new S3({
        accessKeyId: tokenVal.accessKeyId,
        secretAccessKey: tokenVal.secretAccessKeyId,
        sessionToken: tokenVal.sessionToken,
      });
      const s3createMultipartUploadParams: S3.CreateMultipartUploadRequest = {
        Bucket: bucketName,
        Key: filePath + file.name,
        ContentType: file.type,
      };

      // Begin Multipart Upload
      return from(
        s3Obj.createMultipartUpload(s3createMultipartUploadParams).promise()
      );
    }),
    // START UPLOADING INDIVIDUAL PARTS
    concatMap(
      (createMultipartUploadOutput: S3.CreateMultipartUploadOutput) =&gt; {
        multipartUploadId = createMultipartUploadOutput.UploadId;

        numParts = Math.ceil(file.size / FILE_CHUNK_SIZE);
        console.log('numParts', numParts);

        const uploadPartsObservables: Observable&lt;
          S3.UploadPartOutput
        &gt;[] = [];
        for (let i = 0; i &lt; numParts; i++) {
          const start = i * FILE_CHUNK_SIZE;
          const end = (i + 1) * FILE_CHUNK_SIZE;
          const blob =
            i &lt; numParts ? file.slice(start, end) : file.slice(start);

          const uploadPartParams: S3.UploadPartRequest = {
            Body: blob,
            Bucket: environment.AWS_BUCKET,
            Key: createMultipartUploadOutput.Key,
            PartNumber: i + 1,
            UploadId: createMultipartUploadOutput.UploadId,
          };

          uploadPartsObservables.push(
            from(
              s3Obj
                .uploadPart(uploadPartParams)
                .promise()
            )
          );
        }

        return concat(...uploadPartsObservables). // All the uploadPart calls start at the same time
        pipe(
          map((uploadPartResult: S3.UploadPartOutput, index: number) =&gt; { // the Index here seems to reflect the order of the response received not the request order
            const PartTagMapObj: S3.Part = {
              ETag: uploadPartResult.ETag,
              PartNumber: index + 1,
            };

            return PartTagMapObj;
          }),
          catchError((err) =&gt; {
            console.log('error in upload of file : ', err);
            const abortParams: S3.AbortMultipartUploadRequest = {
              Bucket: bucketName,
              Key: filePath + file.name,
              UploadId: multipartUploadId,
            };
            return this.abortMultipartUpload(s3Obj, abortParams);
          }),
          toArray()
        );
      }
    ),
    retry(3), // Needed for createMultipartUpload, which fails on first try sometimes
    concatMap((ETagMap: S3.Parts) =&gt; {
      console.log('err', ETagMap);

      const s3CompleteMultipartUploadParams: S3.CompleteMultipartUploadRequest = {
        Bucket: bucketName,
        Key: filePath + file.name,
        UploadId: multipartUploadId,
        MultipartUpload: {
          Parts: ETagMap,
        },
      };
      return from(
        s3Obj
          .completeMultipartUpload(s3CompleteMultipartUploadParams)
          .promise()
      );
    })
  )
</code></pre>
","12031418","","","","","2021-07-20 04:25:23","Angular 11 - RxJs concat for AWS S3 Multipart File Upload does not wait for request to complete","<angular><amazon-s3><rxjs><rxjs6><aws-sdk-js>","0","0","","","","CC BY-SA 4.0"
"68482552","1","","","2021-07-22 09:37:06","","1","22","<p>Is there something like flatTap in RxJS? If no, why? Would it be &quot;bad practice&quot;?</p>
<p>Suppose you want to tap something and automatically subscribe (an) inner observable(s) - similar as with flatMap -  but you want to keep the same object for further piping. Then I see myself sometimes do something like this:</p>
<pre><code>outerObservable.pipe(
  flatMap(v =&gt; {
    return createInnerObservables(v).pipe(
      toArray(),
      map(() =&gt; v),
    );
  }),
  map(v =&gt; do something with v),
)...
</code></pre>
<p>With a flatTap operator this could simplify to:</p>
<pre><code>outerObservable.pipe(
  flatTap(v =&gt; createInnerObservables(v)),
  map(v =&gt; do something with v),
)...
</code></pre>
","15567795","","","","","2021-07-22 14:32:10","Is there something like flatTap in RxJS","<rxjs><rxjs6><rxjs-pipeable-operators>","1","3","","","","CC BY-SA 4.0"
"68547828","1","","","2021-07-27 15:35:44","","0","62","<p>I need to do a query to 2 separate endpoints to provide the objects needed for my component.</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>No</th>
<th>Endpoint</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>/registry/colors</code></td>
<td><code>{&quot;colors&quot;:[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;orange&quot;]}</code></td>
</tr>
<tr>
<td>2</td>
<td><code>/color/{colorName}</code></td>
<td><code>{&quot;name&quot;:&quot;red&quot;, &quot;details&quot;:[&quot;detail1&quot;,&quot;detail2&quot;, &quot;detail3&quot;]}</code></td>
</tr>
</tbody>
</table>
</div>
<p>For each color in the colors array, I need to call the color details endpoint and collect all of those color details into an array of Colors.</p>
<pre class=""lang-js prettyprint-override""><code>getColors(): Observable&lt;Color[]&gt; {
  return this.http.get&lt;ColorRegistry&gt;(this.registryUrl).pipe(
    map((registry:ColorRegistry) =&gt; registry.colors.concatMap((colorName: string) =&gt; {
      return this.http.get&lt;Color&gt;(this.colorUrl+&quot;/&quot;+colorName);
    }))
  )
}
</code></pre>
<p>I would like the above method to return the following:</p>
<pre class=""lang-js prettyprint-override""><code>[
 {&quot;name&quot;:&quot;red&quot;, &quot;details&quot;:[&quot;detail1&quot;,&quot;detail2&quot;, &quot;detail3&quot;]},
 {&quot;name&quot;:&quot;green&quot;, &quot;details&quot;:[&quot;detail1&quot;,&quot;detail2&quot;, &quot;detail3&quot;]},
 {&quot;name&quot;:&quot;blue&quot;, &quot;details&quot;:[&quot;detail1&quot;,&quot;detail2&quot;, &quot;detail3&quot;]},
 {&quot;name&quot;:&quot;orange&quot;, &quot;details&quot;:[&quot;detail1&quot;,&quot;detail2&quot;, &quot;detail3&quot;]}
]
</code></pre>
<p>Obviously I'm going about this the wrong way, I'm looking for the correct way to do the nested requests with observables.</p>
","1329764","","6513921","","2021-07-27 15:45:49","2021-07-27 20:22:44","Angular 9 service nested http requests","<angular><rxjs><rxjs6>","2","0","","","","CC BY-SA 4.0"
"68679054","1","","","2021-08-06 09:10:31","","0","47","<p>First of all thank you for your time.</p>
<p>I would like to get a nudge into the right direction regarding making my own custom Rxjs operator that results into the same as shareReplay() except when I want it to update.</p>
<p>Basically we have a session storage variable which sets the users organization AND a JWT token that contains the organization of the user (Token is single source of truth).
Based upon that organization we have API data that is just set in stone for the session. Only if the user changes organization we would like to refresh that data and make a new call. shareReplay() is perfect to use, except I don't know how I can get my own logic to check if I need to refresh. (As in, if JWTToken === sessionstorage.getItem('organization')).</p>
<p>Currently I have something like this, but at the moment I am not experienced enough with Rxjs to do it properly, any help is appreciated! Btw, If you have a better approach, thats fine too. I just thought it would be easy to reuse the operator.</p>
<ul>
<li>Rxjs version 6.5.5</li>
<li>Angular version 12.1.0</li>
</ul>
<pre><code>/**
 * Replay this when organization is the same
 * @returns
 */
export function replayWhenSameOrganization&lt;T&gt;() {
  return function (source: Observable&lt;T&gt;) {
    if (this.token.organization === sessionStorage.getItem('organization')) {
      return source;
    } else {
      return new Observable&lt;T&gt;((subscriber) =&gt; {
        source.subscribe({
          next(value) {
            subscriber.next(value);
          },
          error(error) {
            subscriber.error(error);
          },
          complete() {
            subscriber.complete();
          },
        });
      });
    }
  };
}

</code></pre>
<p>Currently shareReplay would be nice as I can rewrite a legacy application that is using subscribe in subscribe every component again for the same data, resulting in stepping through the router through 7 components, and 7 times its calling the same URL with the same response, I think it has been done to fight the refresh issue. shareReplay resolves this as it will send the last received value if there is any and will send a request if there is none. My issue is that I need to set a condition on when I actually want to get fresh server data even if I have a value already. ( In the case of the user switching organizations without refreshing the app ). I know using Ngrx might be a solution as you can send an action to reset the store, except the team is not there yet.</p>
<p><strong>Legacy</strong></p>
<p>APISERVICE</p>
<pre><code>GetConfig() {
  return this.http.get('apiurl/config');
}

</code></pre>
<pre><code>ngOnInit(): void {
   this.apiService.GetConfig().subscribe(config =&gt; {
     this.apiService.GetComponentData(config.id).subscribe( 
        componentdata =&gt; { 
          this.componentdata = componentdata;
        }
     );
   })
}
</code></pre>
<p><strong>My refactor idea</strong></p>
<p>I would like to use the async pipe in the HTML files and rewrite some stuff as I think it will improve readability and makes the front-end code more testable as you can mock Observable values.</p>
<p>APISERVICE</p>
<pre><code>GetConfig(): Observable&lt;IConfig&gt; {
  return this.http.get('apiurl/config').pipe(
    tap(config =&gt; this.config = config),
    shareReplay()
  )
}
</code></pre>
<pre><code>$componentData: Observable&lt;ComponentData&gt; = this.getComponentData();

ngOnInit(): void {}

getComponentData(): Observable&lt;ComponentData&gt; {
  return this.apiService.$config.pipe(
       mergeMap(config =&gt; 
            this.apiService.GetComponentDataByConfig(config)
       )
   )
}

</code></pre>
","11792347","","11792347","","2021-08-06 14:19:37","2021-08-06 14:19:37","Angular Rxjs: Write custom operator to replace shareReplay() with my own business logic","<angular><rxjs><rxjs6><rxjs-observables>","0","4","","","","CC BY-SA 4.0"
"68725299","1","68726614","","2021-08-10 10:40:54","","3","45","<p>I have the following code:</p>
<pre class=""lang-js prettyprint-override""><code>const fetchBook = (bookId: number) =&gt; {
    const title = 'Book' + bookId;
    console.log('fetch book:', title)
    // mimic http request
    return timer(200).pipe(mapTo({ bookId, title }));
}

const bookId$ = new Subject&lt;number&gt;();

const book$ = bookId$.pipe(
    mergeMap(bookId =&gt; fetchBook(bookId))
);

book$.subscribe(book =&gt; console.log('subscriber1: ', book.title))
book$.subscribe(book =&gt; console.log('subscriber2: ', book.title))

bookId$.next(1);
</code></pre>
<p>console output:</p>
<pre><code>fetch book: Book1
fetch book: Book1 &lt;--- called second time
subscriber1:  Book1
subscriber2:  Book1
</code></pre>
<p>What is the best practice to prevent multiple fetches in RxJS?</p>
<p><strong>Upd:</strong> I don't use Angular</p>
<p><strong>Upd2:</strong> The problem is caused by multiple subscribers</p>
","5171110","","5171110","","2021-08-10 12:05:20","2021-08-10 12:12:00","How to prevent multiple fetch calling in RxJS?","<rxjs><rxjs6><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68728725","1","68729261","","2021-08-10 14:32:39","","3","47","<p>I have a code that fetches book by its id</p>
<pre class=""lang-js prettyprint-override""><code>const fetchBook = (bookId: number) =&gt; {
    const title = 'Book' + bookId;
    // mimic http request
    return timer(200).pipe(mapTo({ bookId, title }));
}

const bookId$ = new Subject&lt;number&gt;();

const book$ = bookId$.pipe(
    switchMap(bookId =&gt; fetchBook(bookId)),
    shareReplay(1)
);

book$.subscribe(book =&gt; console.log('book title: ', book.title))

bookId$.next(1);
</code></pre>
<p>I have an API method that patches values and returns the updated object:</p>
<pre class=""lang-js prettyprint-override""><code>const patchBook = (bookId: number, newTitle: string) =&gt; {
    return timer(200).pipe(mapTo({ bookId, title: newTitle }));
}
</code></pre>
<p>What should I do to get <code>book$</code> to emit the new value after I call <code>patchBook(1, 'New Book Title')</code>?</p>
<p>I can declare <code>book$</code> as <code>Subject</code> explicitly and update it manually. But it will be imperative, not reactive approach.</p>
<p><strong>Upd:</strong> The patch is called as a result of user action at any time (or never)</p>
<p><strong>Upd2:</strong> Actually <code>book$</code> can be also changed on server side and my real code looks like this:</p>
<pre><code>const book$ = combineLatest([bookId$, currentBookChangedServerSignal$]).pipe...
</code></pre>
","5171110","","5171110","","2021-08-10 15:34:42","2021-08-16 19:11:10","What is the best way to patch fetched objects in RxJS?","<rxjs><rxjs6><rxjs-observables>","2","0","","","","CC BY-SA 4.0"
"68738483","1","68746729","","2021-08-11 08:26:31","","2","27","<p>I created an Observable Alert in AG Grid (using Adaptable) which is correctly firing when an order is stale for 2 minutes.
But I only see the Alert in the Toolbar and not as a popup notification in the grid like happens in this demo: <a href=""https://demo.adaptabletools.com/alertsmessages/aggridobservablealertdemo"" rel=""nofollow noreferrer"">https://demo.adaptabletools.com/alertsmessages/aggridobservablealertdemo</a></p>
<p>The Expression for the Alert is</p>
<pre><code>GRID_CHANGE( [order_tick] ), TIMEFRAME('2m') ) 
</code></pre>
<p>What am I doing wrong?</p>
","11857476","","","","","2021-08-11 17:51:00","How can I make an Alert appear in the screen using AG Grid and Adaptable/","<ag-grid><rxjs5><rxjs6><ag-grid-react><rxjs-observables>","1","0","","","","CC BY-SA 4.0"
"68739199","1","","","2021-08-11 09:14:49","","4","209","<p>I have a code to fetch book and library card associated with it:</p>
<pre class=""lang-js prettyprint-override""><code>// mimic http requests
const fetchBook = (bookId: number) =&gt; {
    const title = 'Book' + bookId;
    return timer(200).pipe(mapTo({ bookId, title }));
}
const fetchLibraryCard = (bookId: number) =&gt; {
    const borrowerName = 'Borrower of Book' + bookId;
    return timer(300).pipe(mapTo({ borrowerName }));
}

const bookId$ = new Subject&lt;number&gt;();

const book$ = bookId$.pipe(
    switchMap(bookId =&gt; fetchBook(bookId)),
    shareReplay(1)
);

// e.g. 'Refresh library card' button
const libraryCardUpdater$ = new BehaviorSubject&lt;void&gt;(undefined);

const libraryCard$ = combineLatest([bookId$, libraryCardUpdater$]).pipe(
    switchMap(([bookId]) =&gt; fetchLibraryCard(bookId)),
    shareReplay(1)
);

combineLatest([book$, libraryCard$]).subscribe(([book, libraryCard]) =&gt; {
    console.log('book:', book.title, '| borrower:', libraryCard.borrowerName)
})

bookId$.next(1);
setTimeout(() =&gt; bookId$.next(2), 500);
setTimeout(() =&gt; libraryCardUpdater$.next(), 1000);
setTimeout(() =&gt; bookId$.next(3), 1500);
</code></pre>
<p>The problem that I get inconsistent state in subscriber:</p>
<pre><code>book: Book1 | borrower: Borrower of Book1  &lt;-- OK
book: Book2 | borrower: Borrower of Book1  &lt;-- Not OK
book: Book2 | borrower: Borrower of Book2  &lt;-- OK
book: Book2 | borrower: Borrower of Book2  &lt;-- OK, but redundant
book: Book3 | borrower: Borrower of Book2  &lt;-- Not OK
book: Book3 | borrower: Borrower of Book3  &lt;-- OK
</code></pre>
<p>I think about something like pushing <code>undefined</code> to <code>libraryCard$</code> at the same moment when <code>bookId$</code> is changed.</p>
<p>But how to do that in a reactive manner?</p>
<p><strong>Update:</strong></p>
<p>Library card should be always consistent with fetched book (or be <code>undefined</code> at loading time). <code>bookId$</code> can be changed by user action at any time. Also library card can be updated at any time manually by user (<code>libraryCardUpdater$</code>). <code>libraryCardUpdater$</code> emitting should re-fetch card, but shouldn't re-fetch book</p>
<p><strong>Update2:</strong>
I just realized that library card can be fetched sequentially after book. It is acceptable, although not perfect solution for end-user.</p>
","5171110","","5171110","","2021-08-18 08:55:43","2021-08-20 06:49:06","How to wait for a consistent state in RxJS?","<rxjs><rxjs6><rxjs-observables>","6","2","","","","CC BY-SA 4.0"
"68759920","1","68782275","","2021-08-12 15:05:09","","1","63","<p>I have a chat application that consists of multiple components (e.g. one components holds a group list, another one contains messages, etc.), and when one component is opened another one must be closed.</p>
<p>So here is a service that I'm using to provide a webSocket connection:</p>
<pre><code>@Injectable()
export class ChatConnectionService {

  private _connection: Subject&lt;any&gt;;

  constructor(private window: WindowAbstract) { }

  public closeConnection(): void {
    this.connection.complete();
  }

  public send(msg: ChatRequest): void {
    this.connection.next(msg);
  }

  public messages(): Subject&lt;any&gt; {
    return this.connection;
  }

  private get connection(): Subject&lt;any&gt; {
    if (!this._connection || this._connection.closed) {
      this._connection = webSocket(`https/myapp/chat`);
    }

    return this._connection;
  }
}
</code></pre>
<p>And here is a usage example in <code>some.component.ts</code>:</p>
<pre><code>  private messages$: Subscription;

  ngOnInit(): void {
    this.messages$ = this.chatConnectionService.messages()
      .subscribe(m =&gt; this.handleInboundMessage(m));
  }

  ngOnDestroy() {
    this.messages$.unsubscribe();
  }
</code></pre>
<p>Now the problem is that when I switch between components, once it gets unsubscribed when an old component being destroyed, a new subscription does not seem to be working, it does not send or received messages and does not produce any error as well.</p>
<p>But when I remove unsubscribe line it starts working, but keeps receiving messages using the old subscription as well, which is not what I really want.</p>
<p>So summarizing it all - I need to maintain one connection but having a possibility for multiple components to subscribe and unsubscribe as needed, is it possible to accomplish it with RxJs? Or what am I doing wrong? Any suggestion will be appreciated, thanks!</p>
","6089515","","","","","2021-08-14 10:41:27","RxJs: how to maintain one WebSocket connection across multiple components?","<angular><websocket><rxjs><rxjs6>","2","8","","","","CC BY-SA 4.0"
"68813250","1","","","2021-08-17 07:27:24","","0","62","<p>I have an options object which is a BehaviorSubject</p>
<pre><code>options: new BehaviorSubject&lt;Record&lt;string, Options&gt;&gt;({}),
</code></pre>
<p>I currently subscribe to changes using one of my services</p>
<pre><code>this.storeService.state.options.subscribe((options) =&gt; {
  this.options = options;
});
</code></pre>
<p>I have a method that removes a key/value pair inside the options object. <code>REMOVE_CATALOG_ITEM_OPTIONS</code></p>
<pre><code>export type RemoveCatalogItemOptionsAction = {
  type: typeof REMOVE_CATALOG_ITEM_OPTIONS;
  payload: string;
};

export type MyState = {
  options: Observable&lt;Record&lt;string, Options&gt;&gt;;
};

export type MyInitialState = {
  options: Record&lt;string, Options&gt;;
};

export class StoreService implements StoreServiceInterface&lt;MyState, MyAction&gt; {
  constructor(private store: Store&lt;AppState&gt;, initialState?: Partial&lt;MyInitialState&gt;) {
    if (initialState) this.initialiseState(initialState);
  }
 
  get state() {
    return {
      options: this._state.options.asObservable(),
    };
  }

  private _state = {
    options: new BehaviorSubject&lt;Record&lt;string, Options&gt;&gt;({}),
  }

  public update(actions: Array&lt;MyAction&gt;) {
    actions.forEach((action: MyAction) =&gt; {
     switch (action.type) {
        case REMOVE_OPTIONS: {
          const entities = this._state.options.getValue();
          const optionId = action.payload;

          const { [optionId]: _removedEntity, ...newEntities } = entities;

          this._state.options.next(newEntities);

          break;
        }
      }
    }
  }


  private initialiseState(state: Partial&lt;MyInitialState&gt;) {
    if (state.options) this._state.options.next(state.options);
  }
}
</code></pre>
<p>the key/value pair is successfully removed but the changes aren't updated in the service that's subscribing to its changes.</p>
<p>Why isn't it triggering the <code>.subscribe</code> call when I updated the state?</p>
<p><strong>edit</strong>(adding the service consuming StoreService):</p>
<pre><code>export class TableService implements ITableService {
  private options: Record&lt;string, options&gt; = {};

  constructor(
    private storeService: StoreService&lt;MyState, MyAction&gt;,
    private offerId: Id,
  ) {
    this.storeService.state.options.subscribe((options) =&gt; {
      this.options = options;
    });
  }

  public removeOptions(optionsId: string): void {
    return this.storeService.update([
      {
        type: REMOVE_OPTIONS,
        payload: optionsId,
      },
    ]);
  }

}
</code></pre>
<p>edit - other solution that's working for me is:</p>
<pre><code>    case REMOVE_OPTIONS: {
      const entities = this._state.options.getValue();
      const optionId = action.payload;

      const { [optionId]: _removedEntity, ...newEntities } = entities;

      this._state.optionId.next({
        ...newEntities,
        [optionId]: {} as Option,
      });
      break;
     }
</code></pre>
<p>as long as I don't remove the key/value pair completely, it emits a new value in the stream. I don't understand why that works though and my original solution doesn't</p>
","5871609","","5871609","","2021-08-17 10:18:02","2021-08-17 10:18:02","Observable BehaviorSubject does not trigger subscribe changes on removing key value pair","<javascript><rxjs><rxjs6><rxjs-observables>","0","13","","","","CC BY-SA 4.0"
"68854479","1","","","2021-08-19 20:59:30","","2","33","<p>error I am getting in console when running an 'ng serve':</p>
<pre><code>module.js:550
    throw err;
    ^

Error: Cannot find module 'rxjs-compat/Observable'
    at Function.Module._resolveFilename (module.js:548:15)
    at Function.Module._load (module.js:475:25)
    at Module.require (module.js:597:17)
    at require (internal/module.js:11:18)
    at Object.&lt;anonymous&gt; (C:\Users\[USR]\source\repos\[ProprietaryApp]\web\node_modules\rxjs\Observable.js:6:10)
    at Module._compile (module.js:653:30)
    at Object.Module._extensions..js (module.js:664:10)
    at Module.load (module.js:566:32)
    at tryModuleLoad (module.js:506:12)
    at Function.Module._load (module.js:498:3)
</code></pre>
<p>Problem:  All of my code is updated and using the new reference locations.  Here is an example:</p>
<pre><code>import { Subject } from 'rxjs';
</code></pre>
<p>I did a search in VSCode of all places that use 'rxjs-compat/Observable' and I found that every single one of them is in node_modules\rxjs or a subfolder of node_modules\rxjs.</p>
<p><a href=""https://i.stack.imgur.com/izwrS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/izwrS.png"" alt=""RXjsLocations"" /></a></p>
<p>does RXjs V6 <strong>require</strong>  the compat file?  I dont want to use it.  The compat file is supposed to be a <strong>temporary</strong> fix.</p>
","12216384","","","","","2021-09-04 19:18:38","getting ""Cannot find module 'rxjs-compat/Observable'"" but only code requiring it is RXjs itself","<node.js><angular><npm><rxjs><rxjs6>","1","1","","","","CC BY-SA 4.0"
"68988041","1","","","2021-08-30 17:21:16","","2","33","<p>I have my auth function using rxjs epics:</p>
<pre><code>export const authWithEmailPasswordEpic = action$ =&gt;
action$.pipe(
    filter(authUser.match),
    switchMap(({payload}) =&gt;
        defer(() =&gt;
            from(firebaseEmailPasswordAuth(payload)).pipe(
                mergeMap(() =&gt; of(clearAlertState(), stopLoading())),
                catchError(err =&gt;
                    of(clearState(), createAlert({
                        status: err.code,
                        alertType: RED_ALERT,
                        alertTitle: err.message
                    })),
                )
            )
        )
    )
);
</code></pre>
<p>If the users credentials are incorrect, I am dispatching an alert, but then I also want to remove the alert after 5 seconds or so. Therefore, I believe I'd need to emit two actions to achieve this, with the second one being:</p>
<p><code>of(toggleAlert()).pipe(delay(5000)))</code></p>
<p>How would I achieve this or is there a better way to do so?</p>
","14790871","","","","","2021-08-31 16:05:24","Emit multiple actions within catchError - Redux Observable","<reactjs><rxjs><rxjs6><redux-observable>","2","0","","","","CC BY-SA 4.0"
"69186856","1","","","2021-09-15 03:43:04","","0","28","<p>I have below existing nested subscriptions  (angular 6 project ) of streams but it depends upon the first observables response wherein it loads action from the store and then fires two subscriptions from store.</p>
<pre><code>this.store.pipe(select(getOrganizationDetails),
         takeWhile(() =&gt; this.componentActive))
         .subscribe(resOrganization =&gt; {
            if (resOrganization) {
                 this.organization = resOrganization;
                this.store.dispatch(new mangeIconsActions.LoadIcons(this.organization.id));
                this.store.pipe(select(fromManageIcons.getContentIcons),takeWhile(()=&gt;this.componentActive)).subscribe(contentIcons=&gt;{
                    this.contentIcons=contentIcons;
                });
                 //loading module Icons
                this.store.pipe(select(fromManageIcons.getModuleIcons),takeWhile(()=&gt;this.componentActive)).subscribe(moduleIcons=&gt;{
                if(moduleIcons) {
               // Trending IconURl
                const trendingIconData=moduleIcons.find(moduleIcon=&gt;moduleIcon.moduleName ==='Trending');
                if(Object.keys(trendingIconData).length &gt; 0  &amp;&amp; (trendingIconData.customModuleIconUrl !='' || trendingIconData.customModuleIconUrl !=null )) {
                    this.trendingIconUrl =trendingIconData.customModuleIconUrl;
                 }
                }
                });



             }
</code></pre>
<p>I did it as below wherein first I am using switchMap and tap to load action and then fire inner subscription using forkJoin but it is not working and not giving any response.</p>
<pre><code> this.store.pipe(select(getOrganizationDetails),takeWhile(()=&gt;this.componentActive)).pipe(
            tap(res=&gt;this.store.dispatch(new mangeIconsActions.LoadIcons(res.id))),
            switchMap(res=&gt;
                forkJoin(
                this.store.pipe(select(fromManageIcons.getContentIcons),takeWhile(()=&gt;this.componentActive)),
                this.store.pipe(select(fromManageIcons.getModuleIcons),takeWhile(()=&gt;this.componentActive))
            )))
            .subscribe(([contentIcons,moduleIcons])=&gt;{
                    alert(JSON.stringify(contentIcons));
                    alert(JSON.stringify(moduleIcons));
            })
</code></pre>
<p>Can anyone help me what is wrong here.</p>
","5769212","","5769212","","2021-09-15 05:09:37","2021-09-15 05:09:37","rxjs operators for combine response","<angular><rxjs6>","1","0","","","","CC BY-SA 4.0"
"69216908","1","69219296","","2021-09-17 01:52:30","","0","20","<p>My useage of <code>mergeMap</code> seems to reduce the boolean stream down to one value, because</p>
<pre><code>&lt;button [disabled]=&quot;!(canRequestPricing$ | async)&quot;
</code></pre>
<p><code>canRequestPricing$ | async</code> should be true, but if the first emission is false, it is false.</p>
<pre><code>public canRequestPricing$ = new BehaviorSubject&lt;boolean&gt;(false);


public ngOnInit(): void {
    this.canRequestPricingSubscription = this.canRequestPricing$.pipe(
        mergeMap(() =&gt; this.mappedItem.canRequestPricing()),
        take(1),
        mergeMap((canRequestPricingFromApi) =&gt; {
            const can = this.canRequestPricing() &amp;&amp; canRequestPricingFromApi;
            return of(can);
        })).subscribe();
}
</code></pre>
<p>since the emitter initialises with false, the <code>(canRequestPricing$ | async)</code> amounts to false. When I initialise it with <code>true</code> then <code>(canRequestPricing$ | async)</code> amounts to true.</p>
<p><code>const can = this.canRequestPricing() &amp;&amp; canRequestPricingFromApi;</code> always is true which is correct, and I just need the initialsed <code>false</code> of <code>public canRequestPricing$ = new BehaviorSubject&lt;boolean&gt;(false);</code> to not effect the final value.</p>
<p>I want the behaviour to be that <code>(canRequestPricing$ | async)</code> amounts to whatever the last emission was. How do I get that behaviour?</p>
","3935156","","","","","2021-09-17 07:21:24","Angular async pipe reduces stream value rather than displays latest emission","<angular><rxjs6><angular-pipe>","1","0","","","","CC BY-SA 4.0"