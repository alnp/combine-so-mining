Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"56500268","1","56500394","","2019-06-07 19:31:45","","2","124","<p><strong>Situation:</strong><br>
I've encountered a use case for the rxjs <code>Observable</code> system, where I may need to add <code>pipe</code>d commands to a <code>Subscription</code> after it has been started.</p>

<p>In my case, the application I'm working on has to passively listen to a push notification system.  A number of messages can be pushed out over this system, which my system needs to respond to.  <em>However</em>, there's a foreseeable case where a dynamically-loaded view that will be implemented in the future will need to add a listener to the push notification system.</p>

<p><strong>Question:</strong><br>
Given that my app is in a state where my <code>Subscription</code> already exists, can I add an additional pipe after <code>.subscribe(() =&gt; {})</code> has been invoked?</p>

<pre><code>// this.something is an Observable&lt;any&gt;, for discussion purposes.
const subscription = this.something.subscribe(() =&gt; { // commands });

this.something.pipe(
  map((something) =&gt; {
    // ...Commands that I want to add to the subscription...
  })
);
</code></pre>

<p>...And if I do that, then what happens, if anything?</p>

<p><strong>Solution:</strong><br>
The two answers by @user2216584 and @SerejaBogolubov both had an aspect of the answer to this question.</p>

<p>My high-level push notification listener service needed to to do two things:</p>

<ol>
<li>Hold onto the subscription, and  </li>
<li>Be able to draw from a list of listeners.</li>
</ol>

<p>The complication is that each listener needs to be listening for a different message.  Put differently, if I receive a message on <code>foo_DEV</code>, the app needs to do something different than if the push notification system pushes a message on <code>bar_DEV</code>.</p>

<p>So, here's what I came up with:</p>

<pre><code>export interface PushNotificationListener {
  name: string,
  onMessageReceived: (msg: PushNotificationMessage) =&gt; any,
  messageSubject$: Subject&lt;PushNotificationMessage&gt;
}

export class PushNotificationListenerService {
  private connection$: Observable&lt;PushNotificationConnection&gt;;
  private subscription$: Subscription;

  private listeners: PushNotificationListener[] = [];

  constructor(
    private connectionManager: PushNotificationConnectionManager
  ) {
  }

  connect() {
    // Step 1 - Open the socket connection!
    this.connection$ = this.connectionManager.connect(
      // The arguments for setting up the websocket are unimportant here.
      // The underlying implementation is similarly unimportant.
    );
  } 

  setListener(
    name: string,
    onMessageReceived: (msg: PushNotificationMessage) =&gt; any
  ) {
    // Step 3...or maybe 2...(shrug)...
    // Set listeners that the subscription to the high-order connection
    // will employ.
    const newListener: PushNotificationListener = {
      name: name,
      onMessageReceived: onMessageReceived,
      messageSubject$: null
    };

    this.listeners.push(newListener);
  }

  listen() {
    // Step 2 - Listen for changes to the high-order connection observable.
    this.subscription$ = this.connection$
      .subscribe((connection: PushNotificationConnection) =&gt; {
        console.info('Push notification connection established');

        for (let listener of this.listeners) {
         listener.messageSubject$ = connection.subscribe(listener.name);
         listener.messageSubject$.subscribe((message: PushNotificationMessage) =&gt; {
           listener.onMessageReceived(message);
         }
        }
      },
      (error: any) =&gt; {
        console.warn('Push notification connection error', error);
      }
  }
}
</code></pre>

<p>I discovered through careful study of the internal code that comprises the core of my push notification system, that we've already got a higher-order <code>Observable</code>.  The websocket code creates an observable (<code>connectionManager.connect()</code>), that needs to be cached in the service, and subscribed to.  As that code is specific to where I work, I can say no more about it.</p>

<p>However, caching the listeners is important too!  The <code>subscribe</code> call in <code>.listen()</code> just iterates through all the attached listeners any time that the connection changes state, so I can extemporaneously add listeners through <code>.addListener()</code>, and because of how rxjs' <code>Observable</code> system inherently works, <em>AND</em> the fact that I'm working from an in-scope list of listeners, I have a system whereby I can dynamically set listeners, even if <code>.connect()</code> is called before any listeners are configured.</p>

<p>This code probably can still benefit from redesign/refactoring, but I have something that works, which is the important first step of any good coding.  Thank you all!</p>
","1404206","","1404206","","2019-06-10 14:52:08","2019-06-10 14:52:08","Adding pipes after subscribing to a push notification service","<typescript><rxjs><rxjs-pipeable-operators><rxjs-subscriptions>","2","0","","","","CC BY-SA 4.0"
"56578177","1","","","2019-06-13 10:09:29","","0","66","<p>I am trying to subscribe multiple times to my own backend. While my code is fetching the data, something seems not to work right. By executing the following code everything is showed as it should be, except of the sequence. So my accounts are getting fetched in the correct sequence but my transactions are sometimes in the wrong order.</p>

<p>My code:</p>

<pre><code> for(var i = 0; i &lt; this.userlength; i++) {

              //fetch transactions data of the account with index ""countul"" to our local storage
              this.getAccounts(this.as.getUserId(), countul)
              .pipe(map(accountData =&gt; {
                  return {
                    accounts2: accountData.accounts.map(account =&gt; {
                      return {
                        productDescription: account.productDescription,
                        balance: account.currentBalance,
                        iban: account.iban
                      };
                  })
                };
              })
              //If an error at requesting data from external bank occurs, delete every token 
              )
              .subscribe(transformedTransactionData =&gt; {

                this.accounts[countul] = transformedTransactionData.accounts2;


                      for(var j = 0; j &lt; this.accounts[countul].length; j++) {

                          //Printing some things to the console for testing purpose
                          console.log(""countacc: ""+countacc);
                          console.log(this.accounts[countul][countacc].iban);

                          //fetch transactions data of the useraccount with index ""countul"" and subaccount with index ""countacc"" to our local storage
                          (this.getTransactions(this.transactionsPerPage, this.currentPage, this.accounts[countul][countacc].iban, countul, this.as.getUserId()))
                          .pipe(map(transactionData =&gt; {
                              return {
                                transactions2: transactionData.transactions.map(transaction =&gt; {
                                  return {
                                    date: transaction.bookingDate,
                                    receiver: transaction.counterPartyName,
                                    amount: transaction.amount,
                                    mandateReference: transaction.mandateReference,
                                    id: transaction.paymentIdentification,
                                    purpose: transaction.paymentReference
                                  };
                                })
                            };
                          }))
                          .subscribe(transformedTransactionData =&gt; {

                            this.transactions[countacc2] = transformedTransactionData.transactions2;

                            //Stop loading spinner
                            this.isLoading = false;

                            setTimeout(() =&gt; {}, 2000);
                            console.log(""Transactions of account "" +countacc2 + "": ""+JSON.stringify(this.transactions[countacc2]));
                            console.log(""Transactions of account "" +countacc2 + "": ""+JSON.stringify(this.transactions[countacc2]));
                            countacc2++;

                          }), error =&gt; {
                            console.log('There was an error getting data');
                            return Observable.throw(error);
                          };

                           //Go to the possible subaccount                            
                          countacc++;

                        }
                        //Go to the next bankaccount
                        countul++;

                      }), error =&gt; {
                        console.log('There was an error getting data');
                        return Observable.throw(error);
                      };    
            }  
      }
</code></pre>

<p>methods ""getTransaction"" and ""getAccounts"":</p>

<pre><code>//Get account data of bankaccount with index (if there are more than one bank account integrated)
 getAccounts(userid: string, index: number) {

  //DataSchema for the http request
  const data = {userid, index};

  //Making a HTTP Request to our Backend with sending out userid and the index of the bankaccount we want
  return this.http.post&lt;{message: string; accounts: any}&gt;(this.apiUrl + ""/get"", data);

  } 


//Get transaction data of account with index of chosen bankaccount and the iban (if there is a subaccount)
getTransactions(transactionsPerPage: number, currentPage: number, iban: string, index:number, userid: string) {

  //Making a HTTP Request to our Backend with sending out iban of account, index of bakaccount and our userid
  return this.http.post&lt;{transactions: any}&gt;(this.apiUrl + ""/transactions"", {iban, index, userid});

}
</code></pre>

<p>So sometimes it looks like this:</p>

<p><strong>Account 1</strong> - ""first name"" ""second name"" 
--Transactions of <strong>account 2</strong>--</p>

<p><strong>Account 2</strong> - ""first name"" ""second name"" 
--Transactions of <strong>account 1</strong>--</p>

<p>I have to notice, that sometimes it is shown in the correct sequence.</p>

<p>May anyone help me to fix my code?</p>
","11631321","","","","","2019-06-13 10:27:24","How can i fix the nested subscription to work sequential?","<node.js><angular><rxjs><rxjs-pipeable-operators><rxjs-subscriptions>","1","4","","","","CC BY-SA 4.0"
"56702200","1","","","2019-06-21 11:04:10","","4","5455","<p>There are many ways to handle multiple subscriptions efficiently in a component, I have 2 ways here and wanted to know which is more efficient and why??</p>
<h1>Method 1: Using Array</h1>
<p>Step 1: creating Array</p>
<pre><code>private subscriptionArray: Subscription[];
</code></pre>
<p>Step 2: Adding subscriptions to the array</p>
<pre><code>this.subscriptionArray.push(this._storeManagementHttp.createStore(newStore).subscribe(resp =&gt; {
  this._toast.success('New store created');
}));
</code></pre>
<p>Step 3: iterating each subscription and unsubscribing</p>
<pre><code>this.subscriptionArray.forEach(subs =&gt; subs.unsubscribe());
</code></pre>
<h1>Method 2</h1>
<p>Step 1: creating a new subscription</p>
<pre><code>private subscriptions = new Subscription();
</code></pre>
<p>Step 2: Adding subscriptions</p>
<pre><code>this.subscriptions.add(this._storeManagementHttp.createStore(newStore).subscribe(resp =&gt; {
  this._toast.success('New store created');
  this._router.navigate(['/store-management']);
}));
</code></pre>
<p>Step3: Clearing subscription</p>
<pre><code>this.subscriptions.unsubscribe();
</code></pre>
","6715606","","6715606","","2020-12-15 13:15:24","2020-12-15 13:15:24","Angular better way to clear subscriptions","<angular><rxjs><observable><rxjs-subscriptions><rxjs-observables>","4","3","2","","","CC BY-SA 4.0"
"57493327","1","","","2019-08-14 10:56:14","","0","77","<p>I have an angular v7 application where i am using Rxjs subject. Following is the partial code. I am using the subscription with multiple methods. But only the last subscription is working and not the others.</p>

<pre><code>this.userSelectionChangeSubscription = this.userSelectionChangeSubject
    .pipe(debounceTime(environment.saveDebounceTime))
    .subscribe((saveCallback) =&gt; {
        this.reloadColumns();
        saveCallback();
    }); 

//on change of a dropdown 
onPremiumBasisChanged(premiumBasis: number[]): void {
    this.onUserSelectionChanged(() =&gt; this.saveMethodParameters());
}   

onDevelopmentMethodsChanged(developmentMethods: number[]): void {
    this.initialData.selectedDevelopmentMethods = developmentMethods;
    this.onUserSelectionChanged(() =&gt; this.saveMethodParameters());
}       

onUserSelectionChanged(saveCallback: () =&gt; void): void {
    this.userSelectionChangeSubject.next(saveCallback);
}   

private saveMethodParameters() {

// actual save code goes here

}
</code></pre>

<p>What is the correct approach?</p>

<p>Thanks</p>
","4717427","","","","","2019-08-14 10:56:14","Rxjs subject with multiple observers with debounce subscribe only the last one","<angular><rxjs><rxjs-subscriptions>","0","4","","","","CC BY-SA 4.0"
"57516681","1","57516754","","2019-08-15 21:54:50","","0","28","<p>I have a function which returns an object. Instead of returning the object synchronously, can I have it returned inside an observable which can be later resolved using callbacks (similar to an http call). </p>

<p><strong>Caller Function:</strong></p>

<pre><code>getResource() {
  this.someService.getData().subscribe((data) =&gt; { 
      this.playWithData(data);
    }, (error) {                                   
         console.log(error); 
    });
}
</code></pre>

<p><strong>Called Fn</strong> </p>

<pre><code>getData() {
  return data; //required to return observable/subscriber object
}
</code></pre>

<p>can you let know if this is possible and how to create and return an observable just like how http call would return one ?</p>
","4049008","","5383945","","2019-08-15 22:09:09","2019-08-15 22:13:36","wrapper observable event on top of http call","<angular><rxjs><angular-httpclient><rxjs-observables><rxjs-subscriptions>","1","0","","","","CC BY-SA 4.0"
"57710283","1","57710396","","2019-08-29 12:30:56","","1","226","<p>I'm trying to stop my component template from flashing both conditional statements when the condition changes after the component is initialized.</p>

<p>My application receive a token and according to it's validity it displays the necessary content in the template. The problem is that the token is send to an API and until it responds the component is already initialized thus taking the default boolean value. In case the token is valid the the boolean is true thus the template showing both conditional statements for a second and then hiding the else statement.</p>

<pre class=""lang-js prettyprint-override""><code>// template.html
&lt;ng-container *ngIf=""isTokenValid; else tokenIsInvalid""&gt;
  Token is valid content...
&lt;/ng-container&gt;
&lt;ng-template #tokenIsInvalid&gt;
  Token is invalid content...
&lt;/ng-template&gt;


// component.ts
...
isTokenValid: boolean = false; // Initialized to false by default
...
ngOnInit(){
  // Subscribe to the auth service to validate the provided token
  this.authService.validateToken(token).subscribe((res: any) =&gt; {
    if (res.success) { // If the API call was successful
      this.isTokenValid = true; // The token is valid so we change the boolean
      ...
    }
  });
}
</code></pre>

<p>The desired result is the component template to wait until the API call is done and then display the correct content according to the final boolean value.</p>
","5726536","","","","","2019-08-29 12:37:36","Angular: How to prevent component template from flashing both conditional statements?","<javascript><angular><angular-ng-if><angular8><rxjs-subscriptions>","1","1","","","","CC BY-SA 4.0"
"57960917","1","57961601","","2019-09-16 16:23:19","","1","393","<p>I hope this makes sense.
I have decided to change the way some of my services are working simply because it was becoming a bit cumbersome to subscribe to responses and handle creates, updates and deletes in different views. So I decided to make a generic service like this:</p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';

import { environment } from '@environments/environment';
import { Resource } from '../models/resource';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject } from 'rxjs';

@Injectable({
    providedIn: 'root',
})
export class DataService&lt;T extends Resource&gt; {
    items: BehaviorSubject&lt;T[]&gt;;

    constructor(private endpoint: string, private http: HttpClient, private toastr: ToastrService) {
        this.items = new BehaviorSubject&lt;T[]&gt;([]);
    }

    initialize(feedId: number) {
        return this.http.get&lt;T[]&gt;(`${environment.apiUrl}/feeds/${feedId}/${this.endpoint}`).pipe(
            map(response =&gt; {
                console.log(this.endpoint, response);
                this.items.next(response);
                return response;
            }),
        );
    }

    get(id: number) {
        return this.http.get&lt;T&gt;(`${environment.apiUrl}/${this.endpoint}/${id}`);
    }

    create(filter: T) {
        return this.http.post&lt;T&gt;(`${environment.apiUrl}/${this.endpoint}`, filter).pipe(
            map((response: any) =&gt; {
                const message = response.message;
                const item = response.model;

                let items = this.items.value;
                items.push(item);

                this.emit(items, message);

                return response.model;
            }),
        );
    }

    update(filter: T) {
        return this.http.put&lt;T&gt;(`${environment.apiUrl}/${this.endpoint}`, filter).pipe(
            map((response: any) =&gt; {
                const message = response.message;
                const item = response.model;

                let items = this.items.value;
                this.remove(items, filter.id);
                items.push(item);

                this.emit(items, message);

                return response.model;
            }),
        );
    }

    delete(id: number) {
        return this.http.delete&lt;string&gt;(`${environment.apiUrl}/${this.endpoint}/${id}`).pipe(
            map((response: any) =&gt; {
                let items = this.items.value;
                items.forEach((item, i) =&gt; {
                    if (item.id !== id) return;
                    items.splice(i, 1);
                });

                this.emit(items, response);

                return response;
            }),
        );
    }

    private remove(items: T[], id: number) {
        items.forEach((item, i) =&gt; {
            if (item.id !== id) return;
            items.splice(i, 1);
        });
    }

    private emit(items: T[], message: string) {
        this.items.next(items);
        this.toastr.success(message);
    }
}
</code></pre>

<p>The idea behind this service is that the <strong>initialize</strong> method is called only once, when it has been called, you can see that it maps the response to the <strong>items</strong> array within the service itself. Then when a create, update or delete is performed, it is that array that is changed.</p>

<p>That would (in theory) allow any component to subscribe to the <strong>items</strong> array to get updated with any changes.</p>

<p>So, I have a few services that ""extend"" this service, for example:</p>

<pre><code>import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';

import { Filter } from '@models';
import { DataService } from './data.service';
import { ToastrService } from 'ngx-toastr';

@Injectable({
    providedIn: 'root',
})
export class FilterService extends DataService&lt;Filter&gt; {
    constructor(httpClient: HttpClient, toastr: ToastrService) {
        super('filters', httpClient, toastr);
    }
}
</code></pre>

<p>So far, so good. So, my question is: Do I have to call the <strong>initialize</strong> method and invoke a subscription?</p>

<p>For example, currently I have this component:</p>

<pre><code>import { Component, OnInit, Input } from '@angular/core';
import { first } from 'rxjs/operators';

import { FilterService } from '@services';
import { NgAnimateScrollService } from 'ng-animate-scroll';

@Component({
    selector: 'app-feed-filters',
    templateUrl: './filters.component.html',
    styleUrls: ['./filters.component.scss'],
})
export class FiltersComponent implements OnInit {
    @Input() feedId: number;
    displayForm: boolean;

    constructor(private animateScrollService: NgAnimateScrollService, private filterService: FilterService) {}

    ngOnInit() {
        this.initialize();
    }

    navigateToForm() {
        this.displayForm = true;
        this.animateScrollService.scrollToElement('filterSave');
    }

    private initialize(): void {
        this.filterService
            .initialize(this.feedId)
            .pipe(first())
            .subscribe(() =&gt; {});
    }
}
</code></pre>

<p>As you can see with the private method, I <code>pipe</code>, then <code>first</code> and then <code>subscribe</code> which is what I would do if I want to get the results from there. In my ""child"" component, I have this:</p>

<pre><code>import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';
import { first } from 'rxjs/operators';

import { Filter } from '@models';
import { NgbModal } from '@ng-bootstrap/ng-bootstrap';
import { ConfirmationDialogComponent } from '@core';
import { FilterService } from '@services';
import { FiltersSaveComponent } from './filters-save.component';

@Component({
    selector: 'app-filters',
    templateUrl: './filters.component.html',
    styleUrls: ['./filters.component.scss'],
})
export class FiltersComponent implements OnInit {
    filters: Filter[];

    constructor(private modalService: NgbModal, private filterService: FilterService) {}

    ngOnInit() {
        this.filterService.items.subscribe(filters =&gt; (this.filters = filters));
    }

    openModal(id: number) {
        const modalRef = this.modalService.open(ConfirmationDialogComponent);
        modalRef.componentInstance.message = 'Deleting a filter is irreversible. Do you wish to continue?';
        modalRef.result.then(
            () =&gt; {
                this.filterService.delete(id);
            },
            () =&gt; {
                // Do nothing
            },
        );
    }

    openSaveForm(filter: Filter) {
        const modalRef = this.modalService.open(FiltersSaveComponent);
        modalRef.componentInstance.feedId = filter.feedId;
        modalRef.componentInstance.filterId = filter.id;
        modalRef.componentInstance.modal = true;
    }
}
</code></pre>

<p>As you can see, I subscribe to the <strong>items</strong> array from the <strong>filterService</strong>.
So, in my parent controller, I figure I don't actually need the subscription, but if I remove it it doesn't work.</p>

<p>I thought I would be able to do something like:</p>

<pre><code>private initialize(): void {
    this.filterService.initialize(this.feedId);
}
</code></pre>

<p>instead of </p>

<pre><code>private initialize(): void {
    this.filterService
        .initialize(this.feedId)
        .pipe(first())
        .subscribe(() =&gt; {
            // I don't need this
        });
}
</code></pre>

<p>Am I doing something wrong, or is this just the way I have to do it?
I hope I explained myself :)</p>
","1303170","","","","","2019-09-16 17:18:24","Angular 8 do I need to subscribe to a request if I don't care about the response","<angular><rxjs><rxjs-subscriptions>","1","0","2","","","CC BY-SA 4.0"
"58578053","1","58578187","","2019-10-27 09:20:27","","2","973","<p>I'm trying to perform 3 async actions (observables), one inside the other.
1. The first observable is the response of a modal dialog eventEmiter - the rest of the flow is depended on its response (let say that the modal return boolean emiter concerning to: ""Do you want to delete the item"").
2. The second observable is the update (delete) action
3. The third is fetching back the new data after the deletion.</p>

<p>I'm using rxjs- and try to figure out how to do it without subscribe in a subscribe.
See my code: </p>

<pre><code>subscriptions : Subscription[] = [];

openDeleteDialog(data : any)
{
    const modalRef : NgbModalRef = this.modalService.open(ConfirmationDialogComponent); //Modal  dialoge reference
    this.subscriptions.push(modalRef.componentInstance.passResult.subscribe( 
    (result =&gt;//This is the response from the modal dialog
      {
        if (result)
        {
          let updateApi : UpdateApi = new UpdateApi(data);
          this.srv.updateData(updateApi).pipe( //This is the update operation
            tap(() =&gt;
            { 
              this.srv.getData(); //This is the fetch data operation
            }
            )

          ).subscribe();
        }
      }
    )
    ));
} 
</code></pre>
","6721134","","","","","2019-10-27 22:21:47","how to subscribe in a conditional subscription result","<angular><rxjs><rxjs-subscriptions>","3","0","","","","CC BY-SA 4.0"
"58896088","1","","","2019-11-16 23:13:34","","0","484","<p>I am attempting to use a CanDeactivate guard to detect when a user navigates away from the component. The purpose is to #1 check if the current user owns the 'Is Being Edited' lock on the record, and #2 if so, call an observable to update the database.</p>

<p>The code I have is partially working, but there is a race condition where the lock isn't always released, probably because the subscription to <code>this.updateIsBeingEdited$(false)</code> doesn't always complete by the time the next return statement is called. So I know this isn't implemented correctly.</p>

<p>How can I make it such that the <code>this.updateIsBeingEdited$</code> observable completes before the canDeactivate returns a value?</p>

<p>The return value should always be true, because the component should always deactivate, it just need to make sure <code>this.updateIsBeingEdited$.subscribe()</code> is done before deactivation completes.</p>

<p><strong>COMPONENT</strong></p>

<pre><code>  canDeactivate(): Observable&lt;boolean&gt; | boolean {

    // Check if Is Being Edited must be removed
    if (this.mustReleaseIsBeingEdited()) {
      this.removeIsBeingEditedSub = this.updateIsBeingEdited$(false).subscribe(result =&gt; {
        // QUESTION: How to wait until this is complete before allowing component to deactivate?
        return true;
      }, err =&gt; { console.error(err); }, () =&gt; { });

      // Always allow deactivation
      return true;
    } else {
      return true;
    }

  }

  private updateIsBeingEdited$(isBeingEdited): Observable&lt;boolean&gt; {

    const editedObj = {
      _id: this.record._id,
      IsBeingEdited: isBeingEdited,
      EditedBy: this.accessLevelService.getUserId()
    }

    return this.httpService!.postData$(
      `records/_id/${editedObj._id}/IsBeingEdited/`,
      editedObj
    );

  }
</code></pre>

<p><strong>GUARD</strong></p>

<pre><code>export interface ComponentCanDeactivate {
  canDeactivate: () =&gt; boolean | Observable&lt;boolean&gt;;
}
/**
 * Guard to notify client that user has navigated away from route
 * Implemented in component for managing record locks only
 */
@Injectable({
  providedIn: 'root'
})
export class RecordLocksGuard implements CanDeactivate&lt;ComponentCanDeactivate&gt; {
  canDeactivate(component: ComponentCanDeactivate): boolean | Observable&lt;boolean&gt; {
    if (!component) {
      return true;
    }
    component.canDeactivate();
    // Always allow component to deactivate
    return true;
  }
}
</code></pre>
","2183592","","","","","2019-11-17 17:29:08","Angular8 RXJS CanDeactivate wait for result of observable before deactivation","<angular><rxjs><rxjs-observables><rxjs-subscriptions><candeactivate>","1","1","","","","CC BY-SA 4.0"
"60111358","1","","","2020-02-07 10:16:44","","1","2076","<pre><code>@Component({
  selector: 'note-consultant',
  template: '&lt;div&gt;
    &lt;div&gt;{{patientInformation}}&lt;/div&gt;
    &lt;textarea #textElemRef&gt;&lt;/textarea&gt;
    &lt;button (click)=""onSave()""&gt;Done&lt;/button&gt;
    &lt;/div&gt;'
})
export class NoteConsultantComponent implements OnInit, AfterViewInit { 
    recentResponse:any;
    patientInformation:any;
    @ViewChild('textElemRef') textElemRef: ElementRef;

    ngAfterViewInit(): void {
    fromEvent(this.textElemRef.nativeElement, 'keyup').pipe(
      map((event: any) =&gt; {
        return event.target.value;
      })
      ,debounceTime(1000)
    ).subscribe((text: string) =&gt; {

      let request = this.buildRequestItem(text);
        this.patientService.saveProblemNotes(request).subscribe((resp: any) =&gt; {
            if (resp.error) {
              console.log(resp.error);
              return;
            }

            //update response in temp variable...
            this.recentResponse = resp.problemText;
            }
        });
    }
    onSave() {
       if (this.recentResponse != null) {    
       //when clicking save button update DOM
       this.patientInformation = this.recentResponse;
     }

      //Reset temp variable
      this.recentResponse = null;
    }
}
</code></pre>

<p>I have a scenario when the user types text I have to hit API and save the typed data. As it will be inefficient to hit API for every keystroke. so I have used 'fromEvent' RxJs operator to debounce for a second.</p>

<p>The thing is that I can't update HTML(because I have simplified the HTML here but in my project its a collapsible panel, it will cause few HTML elements to disappear which I don't want) as I type data So that's the reason I store the response in a temporary variable 'recentResponse' and upon clicking Save button I update HTML.</p>

<p>But the problem here is if user types very fast and clicks Save button, it takes few seconds until Subscribe is finished, until then 'recentResponse' is undefined thus 'patientInformation' never gets updates(so does HTML).</p>

<p>How can I wait until Subscribe is finished inside onSave()? I need to wait until 'recentResponse' has some response.</p>
","3496596","","","","","2020-02-07 10:34:37","Angular RxJS - Need to Wait until Subscribe has finished in other method","<angular><typescript><rxjs><observable><rxjs-subscriptions>","2","2","","","","CC BY-SA 4.0"
"60296906","1","","","2020-02-19 09:26:35","","0","244","<p>I am developing page which can display job details of a job, for this purpose I am using NGRX store to dispatch actions and subscribing to it to display the data like below</p>

<pre><code>this.store.dispatch(new LoadJobDetails(jobIdsObject));
this.subs.add(
    this.store.pipe(select(state =&gt; state.chatbotStoreData.jobDetailsObject)).subscribe(
      (data) =&gt; {
          if(data) {
            this.jobDetails = data;
            this.getJobHomeSteps();
          }
      }
    )
);

getJobHomeSteps() {
this.store.dispatch(new LoadJobStepsDetails(this.jobId));
this.subs.add(
    this.store.pipe(select(state =&gt; state.chatbotStoreData.jobHomeStepsDetailsObject)).subscribe(
      (data) =&gt; {
          if(data) {
            this.jobStepsDetails = data;
          }
      }
    )
);
}


</code></pre>

<p>and in ngondestroy I am unsubscribing to all the subscriptions like below,</p>

<pre><code>ngOnDestroy(){
this.subs.unsubscribe();
}
</code></pre>

<p>This is working fine, but I have sidenav menu with list of jobs, on click of each job, job details page update with clicked job details. Here, on click of each job, intial subscription is happening many times and dispatch API's are calling multiple times because I can't able to unsubscribe previous job subscriptions. </p>

<p>How can I unsubscribe to all the subscriptions in that particular component on params change, or else any other way I can solve this problem. Any help would be appreciated, thanks!!! </p>
","5678296","","","","","2020-02-19 10:59:26","How to unsubscribe to all the subscriptions on param change in angular","<angular><rxjs><angular8><rxjs-subscriptions>","1","5","","","","CC BY-SA 4.0"
"61589968","1","","","2020-05-04 10:21:18","","1","81","<p>I would like to transform below code snippet:</p>

<pre><code> this.dataUserSubscription = this.store$.pipe(select(selectUser)).subscribe(
            user =&gt; {
                this.store$.pipe(select(selectUserData, {user}), take(1))
                    .subscribe(userData =&gt; {
                        if (userData === null) {
                            this.store$.pipe(select(selectUserManagement, {user}), take(1)).subscribe(
                                userManagement =&gt; {
                                    this.store$.dispatch(saveUserDataToStore({
                                        user,
                                        userManagement
                                    }));
                                });
                        }
                    });
</code></pre>

<p>by avoid nested subscription. All examples, which I found, is per two subscriptions.</p>

<pre><code> this.dataUserSubscription = this.store$.pipe(select(selectUser),
    switchMap(user =&gt; this.store$.pipe(select(selectUserData, {user}))))
    .subscription(userData =&gt; {
        // logic
    })
</code></pre>

<p>But it is no proper solution for my example of code. 
Why is the proper step for fixing multiple nested subscriptions?</p>
","10239144","","7389970","","2020-05-04 11:19:00","2020-05-04 13:48:55","RXJS avoid nested multiple subscriptions","<angular><typescript><rxjs><rxjs-subscriptions>","1","4","","","","CC BY-SA 4.0"
"62762270","1","","","2020-07-06 18:29:05","","0","435","<p>I've read that normally you don't have to unsubscribe from <code>Router</code> or <code>ActivatedRoute</code> explicitly because:</p>
<blockquote>
<p>The ActivatedRoute and its observables are insulated from the Router
itself. The Router destroys a routed component when it is no longer
needed and the injected ActivatedRoute dies with it.</p>
</blockquote>
<p>source: <a href=""https://stackoverflow.com/questions/41138081/do-i-have-to-unsubscribe-from-activatedroute-e-g-params-observables"">Do I have to unsubscribe from ActivatedRoute (e.g. params) observables?</a></p>
<p>However I am calling <code>subscribe()</code> on <code>ActivatedRoute.firstChild.paramMap</code> repeatedly in the parent component <code>app.component</code>. This component is only destroyed when the user navigates away from the web application or closes the website so i'm worried that those <code>paramMap</code> subscriptions might remain active the entire time.</p>
<p>The subscription calls are made within a <code>Router.events</code> subscription and it looks like this:</p>
<pre><code>this.routerSubscription = this.router.events
  .pipe(
    tap((event) =&gt; { 
      switch (true) {
        case event instanceof NavigationStart: { 
          setTimeout(() =&gt; this.showChildComponentLoading = true);
          break;
        }

        case event instanceof NavigationEnd:{
          this.activatedRoute.firstChild.paramMap.subscribe(paramMap =&gt; {
          if(paramMap.has('mode')){
              let newWebAppMode:string = paramMap.get('mode');
              if(this.dataStoreService.isValidWebAppMode(newWebAppMode) &amp;&amp; newWebAppMode !== this.dataStoreService.currentAppMode)
                  this.saveToLocalStorage.next([DataType.WEB_APP_MODE, newWebAppMode]); 
          }
        });
//other code
</code></pre>
<p>Every time someone navigates to another component/page <code>activatedRoute.firstChild.paramMap</code> is subscribed to again. I have to do this inside the router subscription and only when the event is an instance of <code>NavigationEnd</code> because before that the url parameters are not yet available.</p>
<p>My question is, what happens to those subscriptions? Do they unsubscribe automatically or do i need to unsubscribe each new one manually? If the latter is the case, how can i do that effectively?</p>
<p>Some of you may advice me to use <code>activatedRoute.firstChild.snapshot.paramMap.myParameter</code> because then i don't have to subscribe to anything. However, <code>snapshot</code> does not work when the url parameter changes while the same component is reused. So i can't use that.</p>
<p>Thank you</p>
","6351733","","","","","2020-07-06 21:30:36","Should i unsubscribe from ActivatedRoute when calling subscribe method within a Router subscription?","<angular><angular-activatedroute><rxjs-subscriptions>","2","1","","","","CC BY-SA 4.0"
"63175376","1","63177622","","2020-07-30 14:30:50","","0","195","<p>I've spent several hours trying to sort this issue out and I cannot find an answer that fits my case.</p>
<h2>Issue</h2>
<p>I want to display in a DataTable data composed using two API calls. Those calls are performed in a service and the data is then emitted as subject. The component subscribed to the subject then displays the data in a datatable.</p>
<p>The problem is that the datable doesn't show up and I have an error: <code>TypeError: Cannot read property 'aDataSort' of undefined</code>. This problem didn't happen when my data source came from a single API call and I suspect my concern is that the datatable is trying to instantiate itself before the data is loaded. I can fix the issue with an <code>*ngFor</code> by I have other kinds of bug, and I'd rather not do it like this.</p>
<hr />
<blockquote>
<p>In short, my question is: <strong>What am I doing wrong?</strong></p>
</blockquote>
<hr />
<h2>Code</h2>
<p>Here is a simplified version of my code</p>
<p><code>api.service.ts</code></p>
<pre class=""lang-js prettyprint-override""><code>import {Subject, Subscription} from 'rxjs';
import {HttpClient} from '@angular/common/http';
...

export class APIService implements OnDestroy {
  // first data to be retrieved
  private data1: data1Structure;
  data1Subject = new Subject&lt;data1Structure&gt;();
  data1Subscription: Subscription;

  // second data to be retrieved
  private data2: data2Structure[];
  data2Subject = new Subject&lt;data2Structure[]&gt;();

  constructor(private http: HttpClient) {}

  emitData1Subject(){
    this.data1Subject.next(this.data1);
  }

  getData1() {
    this.http
      .get(`${this.baseURL}data1.json`)
      .subscribe(
        (response) =&gt; {
          this.data1Source = response;
          this.emitData1Subject();
        },
        (error) =&gt; { console.log(error); }
      );
  }

  emitData2Subject(){
    this.data2Subject.next(this.data2.slice());
  }

  getData2(){
    this.data1Subject.subscribe((data) =&gt; {
      this.data1 = data;
      this.http
        .get(`${this.baseURL}data2.json`)
        .subscribe(
          (response) =&gt; {
            // Combine the two datasets
            this.data2 = this.formatData2(response);
            this.emitData2Subject();
          },
          (error) =&gt; { console.log(error); }
        );
    });
  }
  ...
}
</code></pre>
<p><code>datatable.component.ts</code></p>
<pre class=""lang-js prettyprint-override""><code>import {ApiService} from '../../../services/api.service';
...

export class DatatableComponent implements OnInit, OnDestroy {

  data2Subscription: Subscription;
  colSettings = [
    {title: '#', data: 'Hid', width: '5%', visible: false},
    {title: 'Date', data: 'date', width: '45%'},
    {title: 'Title', data: 'title', width: '50%'}
  ];
  dtTrigger: Subject&lt;boolean&gt; = new Subject();
  dtOptions: DataTables.Settings;

  constructor(private apiService: ApiService) {
    // first API call
    this.apiService.getData1();
  }

  ngOnInit(): void {
    // second API call
    this.apiService.getData2();
    this.data2Subscription = this.apiService.data2Subject.subscribe(
      (data2) =&gt; {
        this.dtOptions = this.dataTable.getTableSettings(data2, this.colSettings);
        this.dtTrigger.next();
      },
      (error) =&gt; { console.log(error); }
    );
  }

  getTableSettings(records, colSettings: DataTables.ColumnSettings[]): DataTables.Settings {
    return {
      data: records,
      columns: colSettings,
      pagingType: 'full_numbers',
      pageLength: 50,
      deferRender: true,
      dom: 'lBfrtip'
    };
  }
}
</code></pre>
<p><code>datatable.component.html</code></p>
<pre class=""lang-html prettyprint-override""><code>&lt;table id=&quot;data2&quot; datatable [dtOptions]=&quot;dtOptions&quot; [dtTrigger]=&quot;dtWTrigger&quot; class=&quot;row-border hover&quot;&gt;&lt;/table&gt;
</code></pre>
<h3>Environment</h3>
<pre><code>Angular version: 9.1.1
Datatables version: 9.0.2
Chrome / Mac OS Catalina 10.15.5
</code></pre>
<p>I hope my question isn't too confusing, I really can't figure out what to do to fix this problem...</p>
<p>Thank you very much for your help!</p>
<p><em><strong>Edit</strong></em>: fix indentation</p>
","11208548","","11208548","","2020-07-30 14:38:04","2020-07-30 16:38:09","Angular / DataTables: TypeError: Cannot read property 'aDataSort' of undefined with 2 API calls","<angular><datatable><rxjs><angular-datatables><rxjs-subscriptions>","1","0","","","","CC BY-SA 4.0"
"63271014","1","","","2020-08-05 18:02:30","","0","26","<p>Hello I'm currently facing a problem with subscriptions when I navigate to another component of the app.
The way I handle the subscriptions is on an array.</p>
<pre><code>private _subscriptions: Subscription[] = [];
</code></pre>
<p>and every time I have to subscribe, I push the subscription to this array.</p>
<pre><code>this._subscriptions.push(
  this._headerService.rightIconClicked
    .subscribe(() =&gt; this._logout())
);
</code></pre>
<p>on my ngOnDestroy method, I loop through this array and unsubscribe from every subscription.</p>
<pre><code>if (this._subscriptions) {
  this._subscriptions.forEach((sub: Subscription) =&gt; {
    sub.unsubscribe();
  });
}
</code></pre>
<p>To navigate, I'm using <code>navigate()</code> method from angular router.</p>
<pre><code>private _logout() {
  this._router.navigate(['/login'])
}
</code></pre>
<p>And the error I get is the following:
<a href=""https://i.stack.imgur.com/THZoZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/THZoZ.png"" alt=""enter image description here"" /></a></p>
<p>Something to take in account is that on my ngOnDestroy() method, before unsubscribing, I have a console.log() to show that I'm there. And that is not even displayed.
Thanks in advance.</p>
","6749313","","","","","2020-08-05 18:15:54","ObjectUnsuscribedError when navigating to other components - Angular","<angular><rxjs><rxjs-subscriptions>","0","3","","","","CC BY-SA 4.0"
"65782626","1","65792865","","2021-01-18 22:00:25","","4","300","<p>I am having a use case where I need to limit the number of outgoing http requests. Yes, I do have rate limiter on the server-side but a limit on the number of active http requests is also need on the front end too.For that reason I am attempting to implement a sliding window protocol where at any single time I will only have n active requests.</p>
<p>This approach using Rxjs works fine in general, see here:
<a href=""https://jsbin.com/pacicubeci/1/edit?js,console,output"" rel=""nofollow noreferrer"">https://jsbin.com/pacicubeci/1/edit?js,console,output</a></p>
<p>but I am not clear how to use the same logic with http interceptors. My attempt below fails at compile time with the following error:</p>
<p><em>Type 'Subscription' is missing the following properties from type 'Observable&lt;HttpEvent&gt;': _isScalar, source, operator, lift, and 114 more.(2740)</em></p>
<p>With that, how can I return an observable and maintain a queue at the http interceptor at the same time?Is my approach flawed? Can I use http interceptors to http rate limit at all?</p>
<pre><code>@Injectable()
export class I1 implements HttpInterceptor {
  intercept(
    req: HttpRequest&lt;any&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    const modified = req.clone({ setHeaders: { &quot;Custom-Header-1&quot;: &quot;1&quot; } });

    return next
      .handle(req)
      .do((ev: HttpEvent&lt;any&gt;) =&gt; {
        if (ev instanceof HttpResponse) {
          console.log(ev);
        }
      })
      .pipe(
        bufferTime(1000, null, 1),
        filter(buffer =&gt; buffer.length &gt; 0),
        concatMap(buffer =&gt; of(buffer).pipe(delay(1000)))
      )
      .subscribe(console.log);
      }
    }
</code></pre>
<p><a href=""https://stackblitz.com/edit/angular-interceptors-npqkjp?file=app/interceptors.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/angular-interceptors-npqkjp?file=app/interceptors.ts</a></p>
","445762","","445762","","2021-01-18 22:34:09","2021-01-19 13:52:22","Angular - http interceptors - http rate limiter - sliding window","<angular><rxjs><angular-http-interceptors><sliding-window><rxjs-subscriptions>","2","4","","","","CC BY-SA 4.0"
"67710382","1","67712162","","2021-05-26 18:02:06","","1","70","<p>I have the TS code</p>
<pre><code>getItems().subscribe(val=&gt;{
this.items=val;
})
</code></pre>
<p>which works fine.  When I console.log(this.items) I get</p>
<pre><code>&quot;array:0{size:XL,quantity:1}&quot;
</code></pre>
<p>Buuut.
Amazingly, something I've never dealt with before in angular,
when I run the code in the html template of</p>
<pre><code>&lt;div *ngFor=&quot;let item of items&quot;&gt;
{{item.size}}
&lt;/div
</code></pre>
<p>items =[{size:'XL',quantity:4}]
I get ABSOLUTELY NOTHING.  This is really bizzarre because I've written hundreds of these statements and have never had this issue before.  Please help me.</p>
<p><strong>Solved:</strong></p>
<p>What I've figured out is that calling getItems() with a subject, where the getItems method returns a subject &quot;asobservable&quot; can ONLY be done in the same component, directly after the subject is populated.  Populating a subject prior to page change seems to still allow the data to be transferred enough to log in console, but not to be usable by the greater application.</p>
<p>So therefore doing</p>
<pre><code>updateItems(items);
getItemsUpdated().subscribe(val=&gt;{
this.items=val
})
</code></pre>
<p>where there is a subject and</p>
<pre><code>updateItems(items:items){
this.subject.next(items)
}
getItemsUpdated(){
return this.subject.asObservable()
}
</code></pre>
<p>would Work, but only when called directly next to each other in the same component.<br />
Since in this case I was updating the subject, switching pages, and then calling the subject, I was experiencing a weird sort of subject limbo where the console was still able to record the value passed to the subject, but it was not being resolved fully by the receiving component, and therefore was not functioning with the *ngFor.</p>
<p><strong>Correct Flow</strong></p>
<pre><code>updateItems(items);
----------&gt;Navigate to next page--------&gt;
getItemsUpdated().subscribe(val=&gt;{
this.items=val
})
</code></pre>
<p>where there is a <strong>behavior</strong>Subject and</p>
<pre><code>updateItems(items:items){
this.behaviorSubject.next(items)
}

getItemsUpdated(){
return this.behaviorSubject.asObservable()
}
</code></pre>
<p>For this case, using a BehaviorSubject instead of Subject allowed the data to be process &quot;on time&quot; correctly and work with the app.
Thanks everybody for your input!</p>
","15073998","","15073998","","2021-05-26 21:03:51","2021-05-26 21:03:51","*ngFor simply not working with array of Objects","<javascript><angular><ngfor><rxjs-subscriptions>","2","6","","","","CC BY-SA 4.0"
"69088937","1","","","2021-09-07 13:15:48","","0","55","<p>I'm creating a directive that formats a date based on the user's timezone. The user has the option to update their timezone via a settings dropdown on the page. Therefore, the directive is subscribing to timezone updates and updating on change.</p>
<pre><code>ngOnInit() {
    this.timezoneUpdatedSubscription = this.commonService.timezoneUpdated.subscribe(() =&gt; {
        this.el.nativeElement.innerHTML = moment(this.localDate).tz(this.commonService.usersTimezone).format(this.format);
    })
}

ngOnDestroy() {
    if (this.timezoneUpdatedSubscription) {
        this.timezoneUpdatedSubscription.unsubscribe();
    }
}
</code></pre>
<p>The possible issue is that this directive might be used a large number of times on a page, likely 50 times but possibly 200+ times at times. This means there could be 200+ subscriptions at a time.</p>
<p>Would this cause a performance issue with a large number of elements being updated at once? I couldn't see any documentation to suggest either way.</p>
","909446","","909446","","2021-09-07 14:08:52","2021-09-07 14:08:52","Angular/RxJS: Max number of subscriptions?","<angular><rxjs><rxjs-subscriptions>","1","3","","","","CC BY-SA 4.0"