Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"51926745","1","51926887","","2018-08-20 08:26:10","","1","284","<p>On a completely fresh install of <code>ng new myapp</code> (cli version 1.6.8, Angular 5.2.0, rxjs 5.5.6), I installed rxjs marbles.</p>

<p>I am having problem running the very basic test for some configuration reasons.
Can any one tell me what went wrong?</p>

<pre><code>import { TestBed, async } from '@angular/core/testing';
import { marbles } from 'rxjs-marbles/jasmine';
import { map } from 'rxjs/operators';
import { AppComponent } from './app.component';

describe('AppComponent', () =&gt; {
  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      declarations: [
        AppComponent,
      ],
    }).compileComponents();
  }));

  it('should see mapped values', marbles(m =&gt; {
    const values = { a: 1, b: 2, c: 3, x: 2, y: 4, z: 6 };

    const source = m.cold('--a---b---c-|', values);
    const expected = m.cold('--x---y---z-|', values);
    const result = source.pipe(map(x =&gt; x * 2));
    m.expect(result).toBeObservable(expected);
  }));
});
</code></pre>

<p>Console errors:</p>

<pre><code>ERROR in ./node_modules/rxjs-marbles/esm5/marbles.js
Module not found: Error: Can't resolve 'rxjs/testing' in '/Users/armo/Code/rxjsmarbles/node_modules/rxjs-marbles/esm5'
 @ ./node_modules/rxjs-marbles/esm5/marbles.js 9:0-45
 @ ./node_modules/rxjs-marbles/esm5/jasmine/index.js
 @ ./src/app/app.component.spec.ts
 @ ./src \.spec\.ts$
 @ ./src/test.ts

ERROR in ./node_modules/rxjs-marbles/esm5/context-deprecated.js
Module not found: Error: Can't resolve 'rxjs/testing' in '/Users/armo/Code/rxjsmarbles/node_modules/rxjs-marbles/esm5'
 @ ./node_modules/rxjs-marbles/esm5/context-deprecated.js 10:0-45
 @ ./node_modules/rxjs-marbles/esm5/marbles.js
 @ ./node_modules/rxjs-marbles/esm5/jasmine/index.js
 @ ./src/app/app.component.spec.ts
 @ ./src \.spec\.ts$
 @ ./src/test.ts

ERROR in ./node_modules/rxjs-marbles/esm5/context-run.js
Module not found: Error: Can't resolve 'rxjs/testing' in '/Users/armo/Code/rxjsmarbles/node_modules/rxjs-marbles/esm5'
 @ ./node_modules/rxjs-marbles/esm5/context-run.js 1:0-45
 @ ./node_modules/rxjs-marbles/esm5/marbles.js
 @ ./node_modules/rxjs-marbles/esm5/jasmine/index.js
 @ ./src/app/app.component.spec.ts
 @ ./src \.spec\.ts$
 @ ./src/test.ts
ERROR in node_modules/rxjs-marbles/context.d.ts(1,22): error TS2305: Module '""/Users/armo/Code/rxjsmarbles/node_modules/rxjs/Rx""' has no exported member 'SchedulerLike'.
node_modules/rxjs-marbles/context.d.ts(2,31): error TS2307: Cannot find module 'rxjs/testing'.
node_modules/rxjs-marbles/types.d.ts(2,31): error TS2307: Cannot find module 'rxjs/testing'.
</code></pre>
","776686","","776686","","2018-08-20 08:41:02","2018-08-20 08:42:18","Cannot run the simplest rxjs-marbles tests","<rxjs><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"52805700","1","","","2018-10-14 18:16:21","","2","1716","<p>What is the difference between:</p>

<pre><code>expectObservable(e1.merge(e2)).toBe(expected);
</code></pre>

<p>and </p>

<pre><code>expect(e1.merge(e2)).toBeObservable(expected);
</code></pre>

<p>syntax?</p>

<p>Is it matter of a testing library or just a flavor?</p>
","4420532","","","","","2019-10-17 01:45:01","RxJS Marble testing: expectObservable vs toBeObservable","<unit-testing><jasmine><jasmine-marbles><rxjs-marbles>","2","0","1","","","CC BY-SA 4.0"
"53239173","1","54430521","","2018-11-10 12:56:33","","0","269","<p>I use <a href=""https://github.com/cartant/rxjs-marbles"" rel=""nofollow noreferrer"">rxjs-marbles</a> for testing observables in my Angular 7 app. But it looks like <code>m.expect</code> is not recognized by <a href=""https://jasmine.github.io"" rel=""nofollow noreferrer"">jasmine</a> as expectation.</p>

<p>I have following test:</p>

<pre><code>it('should see expectations', marbles(m =&gt; {
  const source: Observable&lt;Message&gt; = m.hot('^a--b--c');
  m.expect(source).toBeObservable('-a--b--c');
}));
</code></pre>

<p>When I run it I get error in console:</p>

<pre><code>ERROR: 'Spec 'FeatureFlagsService should see expectations' has no expectations.'
</code></pre>

<p>Also in browser output my test is prefixed with:</p>

<p><code>SPEC HAS NO EXPECTATIONS should see expectations
</code></p>

<p>Adding <code>expect(true).toBe(true);</code> fixes the issue but this is not really way I want to go.</p>

<p>How to register <code>m.expect</code> as a expectation for jasmine?</p>
","691345","","","","","2019-01-29 22:21:50","rxjs-marbles testing has no expectations","<angular><rxjs><angular-test><jasmine-marbles><rxjs-marbles>","1","2","","","","CC BY-SA 4.0"
"53770717","1","53773312","","2018-12-13 22:02:55","","5","1672","<p>I'm trying to do a pretty simple test in Angular with RxJs Observables, but I'm coming up short.  This is what I'm basically trying to test:</p>

<pre><code>// We're inside some Angular component here...
let testMe = 0;

function somethingOrOther(): void {

    this.someService.methodReturningObservable()
      .subscribe(
          (nextValue: number): void =&gt; {
              testMe += nextValue;
          }
      ) 
}
</code></pre>

<p>How do I test that <code>testMe</code> gets updated properly when the observable behind <code>methodReturningObservable</code> emits a value?</p>

<p>I attempted it with this:</p>

<pre><code>it(`works 'cuz I want it to`, fakeAsync(() =&gt; {
    spyOn(this.someService, 'methodReturningObservable').and.returnValue(cold('a', {a: 10}));

    tick();

    expect(component.testMe).toBe(10);
}));
</code></pre>

<p>So, <code>tick()</code> doesn't seem to do anything here.  Nothing gets my <code>cold</code> value to ever emit on my spy.  </p>

<p>I tried <code>getTestScheduler.flush()</code> instead as shown at <a href=""https://netbasal.com/testing-observables-in-angular-a2dbbfaf5329"" rel=""nofollow noreferrer"">https://netbasal.com/testing-observables-in-angular-a2dbbfaf5329</a> under the marbles section.</p>

<p>Can I use marbles like this to emit a value on an observable?  This was very easy in AngularJS by just triggering a digest, but I can't seem to get Anguar to let me in the next callback for an observable.</p>
","725752","","725752","","2018-12-13 22:25:48","2018-12-14 05:25:41","Test observable 'next' callback in RxJs and Angular","<angular><rxjs><jasmine-marbles><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"53818451","1","","","2018-12-17 15:40:08","","0","173","<p>I have a method that takes an observable as an input and switches to new observable. Alternatively, I could use map instead of switchMap. How can this be tested using marbles?</p>

<pre><code>mapFirstToStr(ob: Observable&lt;boolean&gt;): Observable&lt;string&gt; {
   return ob.pipe(
       first(),
       switchMap(val =&gt; of(val ? 'A' : 'B'))
   );
}
</code></pre>

<p>This doesn't work:</p>

<pre><code>const source = cold('a', { a: true });
const expected = cold('b', { b: 'B' });
expect(mapFirstToStr(source)).toBeObservable(expected);
</code></pre>

<p>I get the following error:</p>

<blockquote>
  <p>Expected value to equal:
       [{""frame"": 0, ""notification"": {""error"": undefined, ""hasValue"": true, > ""kind"": ""N"", ""value"": ""B""}}]</p>
  
  <p>Received:
       [{""frame"": 0, ""notification"": {""error"": undefined, ""hasValue"": true, > ""kind"": ""N"", ""value"": ""B""}}, {""frame"": 0, ""notification"": {""error"": > undefined, ""hasValue"": false, ""kind"": ""C"", ""value"": undefined}}]</p>
</blockquote>
","303257","","","","","2019-08-29 21:19:46","Test observable mapping using marbles","<typescript><observable><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"54149462","1","57547581","","2019-01-11 15:28:24","","2","824","<p>I have this Rxjs testing code. It fail deliberately, because i want to show you the failing log. Which i found hard to understand, or at least i cannot read it fluently.</p>

<p>Someone can explain me what means : <code>$[i].frame = i' to equals i''</code> ?</p>

<pre><code>import { delay } from 'rxjs/operators';
import { TestScheduler } from 'rxjs/testing';

describe('Rxjs Testing', () =&gt; {

  let s: TestScheduler;

  beforeEach(() =&gt; {
    s = new TestScheduler((actual, expected) =&gt; {
      expect(actual).toEqual(expected);
    });
  });

  it('should not work', () =&gt; {
    s.run(m =&gt; {
      const source = s.createColdObservable('-x-y-z|');
      const expected = '-x-y-z|'; // correct expected value is '---x-y-z|'

      const destination = source.pipe(delay(2));
      m.expectObservable(destination).toBe(expected);
    });
  });
});
</code></pre>

<p><a href=""https://i.stack.imgur.com/5yTaz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5yTaz.png"" alt=""enter image description here""></a></p>
","8325761","","","","","2019-08-18 19:07:40","RxJs marble testing : Assertion fail log hard to understand","<testing><rxjs><rxjs6><rxjs-marbles>","1","2","2","","","CC BY-SA 4.0"
"54423862","1","65857864","","2019-01-29 15:00:46","","4","2220","<p>I want to test an effect that works as follows:</p>

<ol>
<li>Effect starts if LoadEntriesSucces action was dispatched</li>
<li>It waits for 5 seconds</li>
<li>After 5 seconds passes http request is send</li>
<li>When response arrives, new action is dispatched (depending, whether response was succes or error).</li>
</ol>

<p>Effect's code looks like this:</p>

<pre><code>  @Effect()
  continuePollingEntries$ = this.actions$.pipe(
    ofType(SubnetBrowserApiActions.SubnetBrowserApiActionTypes.LoadEntriesSucces),
    delay(5000),
    switchMap(() =&gt; {
      return this.subnetBrowserService.getSubnetEntries().pipe(
        map((entries) =&gt; {
          return new SubnetBrowserApiActions.LoadEntriesSucces({ entries });
        }),
        catchError((error) =&gt; {
          return of(new SubnetBrowserApiActions.LoadEntriesFailure({ error }));
        }),
      );
    }),
  );
</code></pre>

<p>What I want to test is whether an effect is dispatched after 5 seconds:</p>

<pre><code>it('should dispatch action after 5 seconds', () =&gt; {
  const entries: SubnetEntry[] = [{
    type: 'type',
    userText: 'userText',
    ipAddress: '0.0.0.0'
  }];

  const action = new SubnetBrowserApiActions.LoadEntriesSucces({entries});
  const completion = new SubnetBrowserApiActions.LoadEntriesSucces({entries});

  actions$ = hot('-a', { a: action });
  const response = cold('-a', {a: entries});
  const expected = cold('- 5s b ', { b: completion });

  subnetBrowserService.getSubnetEntries = () =&gt; (response);

  expect(effects.continuePollingEntries$).toBeObservable(expected);
});
</code></pre>

<p>However this test does not work for me. Output from test looks like this:</p>

<pre><code>Expected $.length = 0 to equal 3.
Expected $[0] = undefined to equal Object({ frame: 20, notification: Notification({ kind: 'N', value: undefined, error: undefined, hasValue: true }) }).
Expected $[1] = undefined to equal Object({ frame: 30, notification: Notification({ kind: 'N', value: undefined, error: undefined, hasValue: true }) }).
Expected $[2] = undefined to equal Object({ frame: 50, notification: Notification({ kind: 'N', value: LoadEntriesSucces({ payload: Object({ entries: [ Object({ type: 'type', userText: 'userText', ipAddress: '0.0.0.0' }) ] }), type: '[Subnet Browser API] Load Entries Succes' }), error: undefined, hasValue: true }) }).
</code></pre>

<p>What should I do to make this test work?</p>
","4524996","","","","","2021-01-23 10:37:12","Testing NGRX effect with delay","<rxjs><ngrx><ngrx-effects><jasmine-marbles><rxjs-marbles>","4","3","","","","CC BY-SA 4.0"
"55397709","1","","","2019-03-28 12:30:29","","0","29","<p>I have the following in an Epic:</p>

<pre><code>mergeMap(result =&gt; concat(
  of(fetchDone(result)),
  of(dispatchActions(payload))
))
</code></pre>

<p>And actions:</p>

<pre><code>const fetchDone = result =&gt; ({ type: ""FETCH_DONE"", payload: result });

function dispatchActions(payload) {
  return dispatch =&gt; {
     dispatch(doStuff(payload));
     ...
  };
}
</code></pre>

<p>The issue is in my test using marbles, I need to be able to check for the anonymous function because <code>dispatchActions</code> is seen as anonymous. How do I do that?</p>

<pre><code>const values = {
  ...
  b: { type: ""FETCH_DONE"", payload: expected },
  c: NEEDS TO BE ANONYMOUS
};

...
const output$ = fetchApi(action$, state$);

// This fails due to the anonymous function
expectObservable(output$).toBe('---(bc)--', values);
</code></pre>
","5686855","","","","","2019-03-28 15:23:16","How do I check for anonymous functions?","<redux-observable><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"56481183","1","","","2019-06-06 15:55:35","","0","76","<p><em>EDIT</em></p>

<p>I boiled down the problem. The following code yields an error in tests, but works as expected in the browser (see <a href=""https://github.com/prumand/jest-marbles-merge-map"" rel=""nofollow noreferrer"">https://github.com/prumand/jest-marbles-merge-map</a> and <a href=""https://github.com/ReactiveX/rxjs/issues/4837"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/issues/4837</a>)</p>

<ul>
<li>tests: returns a WE_FINISH</li>
<li>browser (expected): MY_NEW_ERROR</li>
</ul>

<pre class=""lang-js prettyprint-override""><code> // code
export default function basicMergeMapObs(
    action$: Observable&lt;Action&gt;
) : Observable&lt;any&gt; {
    return action$.pipe(
        filter((val: Action) =&gt; {
            throw new Error('We stop here')
        }),
        map((val: Action) =&gt; ({
            type: 'WE_FINISH',
        })),
        catchError(() =&gt; of({
            type: 'MY_NEW_ERROR',
        }))
    )
}

// test
it('should yield an MY_ERROR', () =&gt; {
    const source = of({
        type: 'TEST',
        status: 'NEW'
    })

    getScheduler().run(helpers =&gt; {
        const { expectObservable, cold } = helpers
        expectObservable(
            basicMergeMapObs(
                source
            )
        ).toBe(
            '(t|)',
            {
                t: { type: 'MY_NEW_ERROR' }
            }
        )
    })
})

function getScheduler() {
    return new TestScheduler((actual, expected) =&gt; {
        expect(actual).toMatchObject(expected);
    });
}
</code></pre>

<p><strong>UPDATE 19.06.2019</strong></p>

<p>I added cartants example from the given github issue, which works fine. Still my example fails. No idea why. IMO it should always throw an error.</p>

<p>And yet another update, the tests don't fail on linux, but only on my windows machine</p>

<p><strong>UPDATE 02.07.2019</strong>
:O seemed to be a issue with endpoint-security solution we use ...</p>
","1136340","","1136340","","2019-07-02 06:10:02","2019-07-02 06:10:02","Marble-Testing doesn't use filter operator","<rxjs><jestjs><redux-observable><ts-jest><rxjs-marbles>","0","3","","","","CC BY-SA 4.0"
"56496767","1","","","2019-06-07 14:58:30","","2","98","<p>I have to write Unit Test for this effect that is calling the service every 1 sec when it went in error.
I need to test for example that after 3 times of calling a service, I'll receive a good response.</p>

<p>I tried some way to test but without any result.</p>

<p>This is the effect that I have to test:</p>

<pre class=""lang-js prettyprint-override""><code>@Effect()
  updateEffect$ = this.actions$.pipe(
    ofType(featureActions.ActionTypes.UPDATE_PRODUCT),
    switchMap((action: UpdateProduct) =&gt;
      this.productService.getProducts().pipe(
        retryWhen((attempts) =&gt; attempts.pipe(delay(1000))),
        map((productsResponse: Products) =&gt;
          productsResponse
            ? new featureActions.LoadProductSuccess(productsResponse)
            : new featureActions.LoadProductError(productsResponse)
        )
      )
    )
  );
</code></pre>

<p>This is the unit test that I did just to see the success scenario.
What I want to test is the reload logic</p>

<pre class=""lang-js prettyprint-override""><code> it('should return UpdateProduct if service response success ', () =&gt; {
    const action = new UpdateProduct('123456');
    const completion = new LoadProductSuccess(productsResponseMock);

    actions$ = hot('-a-', { a: action });
    const response = cold('-b', { b: productsResponseMock });
    const expected = cold('--c', { c: completion });

    productService.getProducts.and.returnValue(response);
    expect(effects.updateEffect$).toBeObservable(expected);
  });
</code></pre>
","8539571","","2611237","","2019-06-07 16:33:44","2019-06-07 16:33:44","How to write unit test for effect that after n times return a valid response?","<angular><integration-testing><rxjs6><jasmine-marbles><rxjs-marbles>","1","1","","","","CC BY-SA 4.0"
"57406445","1","","","2019-08-08 06:31:27","","1","540","<p>I have a SocketService. This class is responsible for socket connection and messaging with a server. I've written some code to make my client able to reconnect on connection loss. It should make 3 attempts with 5 sec delay between them and if no success redirect to login page.</p>

<p>After that I've written a test but I cannot make it work even close to what happening.</p>

<p>I'm trying to simulate 2 errors on <code>send</code> and one successful message. What should result in 3 reconnect attempts and the last successful one.</p>

<p>Here is my test <a href=""https://stackblitz.com/edit/jasmine-marbles-testing-jdvcnm?file=src/test.spec.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/jasmine-marbles-testing-jdvcnm?file=src/test.spec.ts</a> </p>

<p>I expect a marble diagram to be something near <code>-# 5s # 5s (a|)</code> (in test there is another diagram since I tried different ones).</p>
","8144405","","","","","2019-09-11 07:01:59","RxJs marble testing retryWhen","<testing><rxjs><jasmine><rxjs-marbles>","1","0","1","","","CC BY-SA 4.0"
"57668948","1","","","2019-08-27 06:41:30","","4","273","<p>I would like to test a GraphQL subscription in Angular that</p>

<ol>
<li>Make a query</li>
<li>Attach a subscription to the query by using <code>subscribeToMore</code></li>
<li>Mock the query result by using flush on its operation in and validate the result</li>
<li>Mock the subscription result by using flush on its operation and validate the result</li>
</ol>

<p>I succeed to make a good test by following the <a href=""https://www.apollographql.com/docs/angular/guides/testing/"" rel=""nofollow noreferrer"">Apollo documentation about client testing</a>:</p>

<pre><code>const ENTITY_QUERY = gql`
  query EntityList {
    entityList {
      id
      content
    }
  }
`;

const ENTITY_SUBSCRIPTION = gql`
  subscription OnNameChanged {
    nameChanged {
      id
      name
    }
  }
`;

describe('Test Subscription', () =&gt; {
  let backend: ApolloTestingController;
  let apollo: Apollo;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [ApolloTestingModule],
      providers: [
        {
          provide: APOLLO_TESTING_CACHE,
          useValue: new InMemoryCache({ addTypename: true })
        }
      ]
    });
    backend = TestBed.get(ApolloTestingController);
    apollo = TestBed.get(Apollo);
  });

  it('should subscribe and return updated entity', done =&gt; {

    const queryRef: QueryRef&lt;any&gt; = apollo.watchQuery({ query: ENTITY_QUERY });

    queryRef.subscribeToMore({
      document: ENTITY_SUBSCRIPTION,
      updateQuery: (entityList, { subscriptionData }) =&gt; ({
        entityList: entityList.map(entity =&gt; {
          // update name of corresponding entity in cache
          return entity.id === subscriptionData.data.nameChanged.id
            ? {
                ...entity,
                name: subscriptionData.data.nameChanged.name
              }
            : entity;
        })
      })
    });

    const queryResult = [{ id: '1', name: 'John' }, { id: '2', name: 'Andrew' }];
    const subscriptionResult = { id: '1', name: 'Marc' };

    const expectedEntitiesWhenQuery = queryResult;
    const expectedEntitiesAfterSubscriptionUpdate = [subscriptionResult, { id: '2', name: 'Andrew' }];

    let firstQueryTick = true;

    // the subscription should be done before the flush in other case the operation backends would not be available
    queryRef.valueChanges.subscribe(result =&gt; {
      try {
        if (firstQueryTick) {

          // first test the query result returns the expected
          expect(result).toEqual(expectedEntitiesWhenQuery);

          firstQueryTick = false;

        } else {

          // then, when the subscription return a new name, test that the result is modified
          expect(result).toEqual(expectedEntitiesAfterSubscriptionUpdate);

          done();
        }
      } catch (error) {
        fail(error);
      }
    });

    // retrieves the query operation backend
    const backendSubscription = backend.expectOne('OnNameChanged');

    // retrieves the subscription operation backend
    const backendQuery = backend.expectOne('EntityList');

    // Mock by flushing data to query
    backendQuery.flush({ data: { entityList: queryResult } });

    // Then Mock by flushing data to subscription
    backendSubscription.flush({ data: { nameChanged: subscriptionResult } });
  });

  afterEach(() =&gt; {
    backend.verify();
  });
});
</code></pre>

<p>But as you can see, the validation of the results in the <code>subscribe</code> part isn't really clean with the <code>firstQueryTick</code> variable... just imagine if I want to test 10 results...</p>

<p>So I tried to replace this part by using the <a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/testing/marble-testing.md"" rel=""nofollow noreferrer"">rxjs marble testing</a>:</p>

<pre><code>import { APOLLO_TESTING_CACHE, ApolloTestingController, ApolloTestingModule } from 'apollo-angular/testing';
import { InMemoryCache } from 'apollo-cache-inmemory';
import { TestBed } from '@angular/core/testing';
import { Apollo, QueryRef } from 'apollo-angular';
import gql from 'graphql-tag';
import { TestScheduler } from 'rxjs/testing';

const ENTITY_QUERY = gql`
  query EntityList {
    entityList {
      id
      content
    }
  }
`;

const ENTITY_SUBSCRIPTION = gql`
  subscription OnNameChanged {
    nameChanged {
      id
      name
    }
  }
`;

describe('Test Subscription', () =&gt; {
  let backend: ApolloTestingController;
  let apollo: Apollo;
  let scheduler: TestScheduler;

  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [ApolloTestingModule],
      providers: [
        {
          provide: APOLLO_TESTING_CACHE,
          useValue: new InMemoryCache({ addTypename: true })
        }
      ]
    });

    backend = TestBed.get(ApolloTestingController);
    apollo = TestBed.get(Apollo);

    scheduler = new TestScheduler((actual, expected) =&gt; {
      expect(actual).toEqual(expected);
    });
  });

  it('should subscribe and return updated entity', done =&gt; {
    const queryRef: QueryRef&lt;any&gt; = apollo.watchQuery({ query: ENTITY_QUERY });
    queryRef.subscribeToMore({
      document: ENTITY_SUBSCRIPTION,
      updateQuery: (entityList, { subscriptionData }) =&gt; ({
        entityList: entityList.map(entity =&gt; {
          // update name of corresponding entity in cache
          return entity.id === subscriptionData.data.nameChanged.id
            ? {
                ...entity,
                name: subscriptionData.data.nameChanged.name
              }
            : entity;
        })
      })
    });

    const queryResult = [{ id: '1', name: 'John' }, { id: '2', name: 'Andrew' }];
    const subscriptionResult = { id: '1', name: 'Marc' };


    /////////////////////////////NEW PART

    scheduler.run(({ expectObservable }) =&gt; {
      // the source is the query observable
      const source$ = queryRef.valueChanges;

      const expectedMarble = 'x-y|';
      const expectedValues = { x: queryResult, y: [subscriptionResult, { id: '2', name: 'Andrew' }] };

      // this is subscribing and validating at the same time so it is not possible to do something between the subscription and the flush of values from rxjs
      expectObservable(source$).toBe(expectedMarble, expectedValues);
    });

    /////////////////////////////

    // this will not be called because the test is already failing with expectObservable, if we put this part before, it will fail because the subscription is not already done...
    const backendSubscription = backend.expectOne('OnNameChanged');
    const backendQuery = backend.expectOne('EntityList');

    backendQuery.flush({ data: { entityList: queryResult } });
    backendSubscription.flush({ data: { nameChanged: subscriptionResult } });
  });

  afterEach(() =&gt; {
    backend.verify();
  });
});

</code></pre>

<p>After multiple tries, I cannot make it works because the <code>expectObservable</code> is doing the <code>subscribe</code> + the <code>validation</code> at the ""same time"" and I need to:</p>

<ul>
<li>FIRST subscribe to the query</li>
<li>THEN get the operations backend object to be able to flush data</li>
<li>THEN validate results</li>
</ul>

<p><strong>Is it possible to make an action between the <code>subscribe</code> and the <code>validation</code> using rxjs testing marbles ?</strong></p>
","3201609","","","","","2019-08-27 06:41:30","How to use rxjs marbles testing with graphQL Apollo Testing Controller in Angular","<angular><rxjs><graphql><apollo><rxjs-marbles>","0","0","","","","CC BY-SA 4.0"
"57826181","1","","","2019-09-06 17:13:22","","1","382","<p>I am returning from the Observable an object. One of its properties is a function.<br>
After assigning even empty function and emitting the object the <code>toBeObservable</code> expectation fails because of non-deep match.</p>

<p>I'm using <code>rxjs-marbles/jest</code> for testing. Here's sample test case:</p>

<pre class=""lang-js prettyprint-override""><code>it('...', marbles(m =&gt; {
  const source = m.cold('(a|)');
  const expected = m.cold('(b|)', { b: {
    label: 'A',
    action: () =&gt; { }
  } });

  const destination = source.pipe(
    map(() =&gt; ({
      label: 'A',
      action: () =&gt; { }
    }))
  );
  m.expect(destination).toBeObservable(expected);
}));
</code></pre>

<p>The result is as follows:</p>

<pre class=""lang-sh prettyprint-override""><code>expect(received).toEqual(expected) // deep equality

Expected: [{""frame"": 0, ""notification"": {""error"": undefined, ""hasValue"": true, ""kind"": ""N"", ""value"": {""action"": [Function action], ""label"": ""A""}}}, {""frame"": 0, ""notification"": {""error"": undefined, ""hasValue"": false, ""kind"": ""C"", ""value"": undefined}}]
Received: serializes to the same string
</code></pre>

<p>The only thing I need to check is whether the <code>action</code> is defined in object. Is it possible?</p>
","1889534","","2071697","","2019-09-06 17:51:19","2019-09-09 07:39:28","RxJS marble testing objects with functions","<javascript><typescript><jestjs><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"57998667","1","57999425","","2019-09-18 18:16:09","","2","112","<p>I am reading over the marbles testing documentation for Rxjs 6, and found this part under the ""Examples"" section for ""Marble Syntax""</p>

<p><a href=""https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/testing/marble-testing.md#examples"" rel=""nofollow noreferrer"">https://github.com/ReactiveX/rxjs/blob/master/docs_app/content/guide/testing/marble-testing.md#examples</a></p>

<p>Here is the example for my question:</p>

<blockquote>
  <p>'--(abc)-|': on frame 2 emit a, b, and c, then on frame 8 complete</p>
</blockquote>

<p>Why does it say frame 8 for complete?</p>

<p>I count only 5 frames in total for the above string. The string <code>(abc)</code> should only count as a single frame. It's then followed by another frame <code>-</code> then a complete <code>|</code>.</p>

<pre><code>--(abc)-|
11  1  11 = sum(5)
</code></pre>

<p>So I don't understand why it's frame 8, but when I run the above in a unit test with marbles it outputs that it completed on frame 8.</p>

<p>So where are the 3 extra frames coming from?</p>
","1031569","","","","","2019-09-18 19:22:21","Why does rxjs 6 marbles documentation say ""--(abc)-|"" completes on frame 8?","<javascript><rxjs><jasmine><jestjs><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"58079027","1","58080248","","2019-09-24 11:13:06","","0","441","<p>I don't understand why <code>.getValue()</code> returns the default value of the Observable and not the last value emitted. When testing the Observable, it correctly returns the emitted value.</p>

<pre class=""lang-js prettyprint-override""><code>class TestA {
  readonly aSource: BehaviorSubject&lt;number&gt; = new BehaviorSubject(null);

  getA(): number {
    return this.aSource.getValue();
  }

  promise(): void {
    Promise.reject()
      .catch(() =&gt; {
        this.aSource.next(2);

        console.log(this.getA()); // Outputs: 2
      });
  }
}

describe('TestA', () =&gt; {
  it('promise', () =&gt; {
    const a = new TestA();
    a.promise();

    // Test 1 OK
    expect(a.aSource.asObservable()).toBeObservable(hot('a', {a: 2}));

    // Test 2 FAIL (returns null)
    expect(a.aSource.getValue()).toEqual(2);

    // Test 3 FAIL (returns null)
    expect(a.getA()).toEqual(2);
  });
});
</code></pre>

<p>To clarify, the <code>getValue()</code> method works fine outsude tests, it only fails while testing with Jest.</p>

<p>Thanks!</p>
","418310","","2071697","","2019-09-24 11:18:56","2019-09-24 12:22:17","RxJS BehaviorSubject getValue inconsistency after value emitted (while testing in Jest)","<typescript><rxjs><jestjs><rxjs-marbles>","3","1","1","","","CC BY-SA 4.0"
"58388868","1","58401653","","2019-10-15 06:56:49","","0","286","<p>I'm adding unit testing to my angular/rxjs project, and I'm using the <code>marble test</code> solution. And since I'm using the newer version of rxjs, so I used the build-in ""TestScheduler"" module.  <br></p>

<p>I'm following this post: <a href=""https://brianflove.com/2018/06/28/ngrx-testing-effects/"" rel=""nofollow noreferrer"">https://brianflove.com/2018/06/28/ngrx-testing-effects/</a>, And it gave an example as following: </p>

<pre><code>export class UserEffects {
  @Effect()
  addUser: Observable&lt;Action&gt; = this.actions$
    .ofType&lt;AddUser&gt;(UserActionTypes.AddUser)
    .pipe(
      map(action =&gt; action.payload),
      exhaustMap(payload =&gt; this.userService.addUser(payload.user)),
      map(user =&gt; new AddUserSuccess({ user })),
      catchError(error =&gt; of(new AddUserFail({ error })))
    );

  constructor(private actions$: Actions, private userService: UserService) {}

}
</code></pre>

<p>and the unit test is below:</p>

<pre><code>describe('addUser', () =&gt; {
    it('should return an AddUserSuccess action, with the user, on success', () =&gt; {
    const user = generateUser();
    const action = new AddUser({ user });
    const outcome = new AddUserSuccess({ user });

    actions.stream = hot('-a', { a: action });
    const response = cold('-a|', { a: user });
    const expected = cold('--b', { b: outcome });
    userService.addUser = jest.fn(() =&gt; response);

    expect(effects.addUser).toBeObservable(expected);
  });
});
</code></pre>

<p>I  can understand the logic(marble string) here expect one confusing point: </p>

<pre><code>cold('--b', { b: outcome })
</code></pre>

<p>why not <code>--b|</code>? Since the response observable has a completion event <code>|</code> in  <code>cold('-a|', { a: user });</code>. </p>

<p>Btw, in this post, it will third-party library, but I use native <code>TestScheduler</code> and have the same result. </p>
","4128453","","","","","2019-10-15 19:43:28","RxJS testing: marble test confusing case","<rxjs><jasmine-marbles><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"58557974","1","58559448","","2019-10-25 11:48:43","","0","256","<p>I need to write marble test for my custom operator used in this <code>loadEpic</code> epic - this helps me to avoid problems that action <code>INITIALiZE</code> sometimes is dispatched to late and i getting <code>LOAD_FAILURE</code>:</p>

<pre><code>loadEpic: Epic&lt;ExamManagementAction, ExamManagementAction, RootState&gt; = (
    action$,
    state$
  ) =&gt;
    action$.pipe(
      filter(isActionOf(load)),
      waitFor(state$),
      switchMap(() =&gt;
        this.load(state$).pipe(
          map(loadSuccess),
          catchError(error =&gt; of(loadFailure({ error })))
        )
      )
    );
</code></pre>

<p>and this is how i wrote my <code>waitFor</code> operator which works fine:</p>

<pre><code>const waitFor = &lt;T&gt;(
  state$: Observable&lt;RootState&gt;
): OperatorFunction&lt;T, T&gt; =&gt; source$ =&gt;
  source$.pipe(
    switchMap(value =&gt;
      state$.pipe(
        filter(state =&gt; state.navigation.initialized),
        take(1),
        mapTo(value)
      )
    )
  );
</code></pre>

<p>can you help me to write this test with <code>rxjs-marbles/jest</code> or any similar approach? many thanks!</p>
","12273606","","12273606","","2019-10-29 10:01:59","2019-10-29 11:04:49","How to write marble test for this custom RxJS operator used in redux-observalbe Epic","<rxjs><jestjs><reactive-programming><redux-observable><rxjs-marbles>","1","1","","","","CC BY-SA 4.0"
"58627130","1","","","2019-10-30 14:03:40","","1","612","<p>So I am trying to test the HTML based on if an observable emits certain values. I have the inital setup of the service to have an observable emit the correct value but when I go to create another test to test if what happens if I pass wrong data I am unable to change the value the observable emits. I feel like its something small that I am missing could someone take a look and let me know what I am doing wrong?</p>

<p>Here is the spec file</p>

<pre><code>describe('AlertsComponent', () =&gt; {
  let component: AlertsComponent;
  let fixture: ComponentFixture&lt;AlertsComponent&gt;;
  let alertService: any;

  let testAlertGood: Alert = {
    type: AlertType.Success,
    title: 'Test title',
    message: 'Test message',
    forceAction: false
  };

  let testAlertBad: String = 'bad alert';

  let testAlertNoTitle: Alert = {
    type: AlertType.Success,
    title: null,
    message: 'Test message',
    forceAction: false
  };

  beforeEach(async(() =&gt; {
    alertService = jasmine.createSpy('AlertService');
    alertService.alert$ = cold('a', { a: testAlertGood });

    TestBed.configureTestingModule({
      declarations: [ AlertsComponent ],
      schemas: [ NO_ERRORS_SCHEMA ],
      providers: [
        {
          provide: Router,
          useClass: class { navigate = jasmine.createSpy('navigate'); }
        },
        {
          provide: AlertService,
          useValue: alertService
        }
      ]
    })
    .compileComponents();
  }));

  beforeEach(() =&gt; {
    fixture = TestBed.createComponent(AlertsComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  fit('should create', () =&gt; {
    expect(component).toBeTruthy();
  });

  it('should display an alert if the alert$ observable has an Alert value', async () =&gt; {
    fixture.detectChanges();
    getTestScheduler().flush();
    fixture.detectChanges();

    const alertElements = fixture.debugElement.queryAll(By.css('.alert-container'));
    const alertIconContainer = fixture.debugElement.query(By.css('.icon-container'));
    const alertIconClass = fixture.debugElement.query(By.css('#alert-icon'));
    const alertTitle = fixture.debugElement.query(By.css('.title'));
    const alertBody = fixture.debugElement.query(By.css('.body'));

    expect(alertElements.length).toBe(1);
    expect(alertIconContainer.nativeElement.getAttribute('class')).toContain('bg-success');
    expect(alertIconClass.nativeElement.getAttribute('class')).toContain('fa-check-circle');
    expect(alertTitle.nativeElement.innerText).toContain('Test title');
    expect(alertBody.nativeElement.innerText).toContain('Test message');
  });

  it('should hide the title p tag if the Alert.title is null', async () =&gt; {
    alertService.alert$ = cold('a', { a: testAlertNoTitle });

    fixture.detectChanges();
    getTestScheduler().flush();
    fixture.detectChanges();

    const alertTitle = fixture.debugElement.query(By.css('.title'));
    expect(alertTitle).toBeNull();
  });
});
</code></pre>

<p>So basically at the top of the files I have the three versions of values that I need to test when the observable emits and I am only able to test the first one. the <code>should display an alert if the alert$</code> test passes just fine but its the last one <code>should hide the title...</code> that is failing because it does not seem to be changing the observable when I do <code>alertService.alert$ = cold('a', { a: testAlertNoTitle });</code></p>
","1760836","","","","","2021-03-11 11:38:10","Jasmine using marbles to test multiple observable values","<angular><jasmine><karma-jasmine><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"59463528","1","59532294","","2019-12-24 03:32:04","","4","2067","<p>In my angular project, I have a service, which is used for state management to share some data between components as following:</p>

<pre><code>@Injectable({ providedIn: ""root""})
export class NameStateService {

    private _filteredNames$: Subject&lt;Name[]&gt; = new Subject();
    private _filteredNamesObs$: Observable&lt;Name[]&gt;;

    constructor() {
        this._filteredNamesObs$ = this._filteredNames$.asObservable();
    }

    public updateFilteredNames(val: Name[]): void {
        this._filteredNames$.next(val);
    }

    public get filteredNames$(): Observable&lt;BillingAccount[]&gt; {
        return this._filteredNamesObs$;
    }
}
</code></pre>

<p>the state management is based on subject and observable, which is typical usage in rxjs world. </p>

<p>And For the unit test for this service, I want to use the marble testing features suppored by <code>rxjs/testing</code> module. The solution goes as following:</p>

<pre><code>describe(""Name state service "", () =&gt; {
    let nameStateService: NameStateService;
    let scheduler: TestScheduler;

    beforeEach(() =&gt; {
        TestBed.configureTestingModule({
            providers: [
                NameStateService
            ]
        });
        nameStateService = TestBed.get(NameStateService);
        scheduler = new TestScheduler((actual, expected) =&gt; expect(actual).toEqual(expected));
    });

    it(""should be created"", () =&gt; {
        expect(nameStateService).toBeTruthy();
    });

    it(""should return a valid names observables"", () =&gt; {
        scheduler.run(({ cold, hot, expectObservable }) =&gt; {
            const mockNames: Name[] = [{
                title: ""title1"",
                group: ""group1""
            }]; 
            nameStateService.updateFilteredNames(mockNames);
            expectObservable(nameStateService.filteredNames$).toBe(""-b"", {b: mockNames});
        });
    });
})
</code></pre>

<p>But the second unit test failed with the error: <code>Error: Expected $.length = 0 to equal 1.</code> So it means that <code>nameStateService.filteredNames$</code>, this observable has no values in its stream. <br></p>

<p>What is the issue here? </p>
","4128453","","","","","2019-12-31 08:13:46","Angular Unit Test: how to use marble testing (rxjs/testing) to test this state management service","<angular><unit-testing><rxjs><jasmine-marbles><rxjs-marbles>","1","1","1","","","CC BY-SA 4.0"
"60039709","1","","","2020-02-03 12:56:45","","3","636","<p>I am trying to figure out how to structure a jest unit test for the following:</p>

<p>I have a bunch of existing observables and subjects I want to test in a project.  So I have started off with what I would assume to be a simple test case using RXjs marbles inside jest:</p>

<pre><code>      const testScheduler = new TestScheduler((actual, expected) =&gt; {
        expect(actual).toEqual(expected);
      });

      testScheduler.run(({cold, expectObservable}) =&gt; {
        const inputSubject = new Subject();
        const outputSubject = new Subject();
        inputSubject.pipe(map(val =&gt; val * 2)).subscribe(outputSubject);

        cold('a|', {a:1}).subscribe(inputSubject);

        expectObservable(outputSubject).toBe('a|', {a:2});
      });
    }

</code></pre>

<p>While this test does run, it fails.  I am having trouble understanding the output from the test run.  I would like to know if I am doing something wrong, or if I am misunderstanding things in general incorrectly.  Or perhaps just some explanation of the output would be helpful.</p>

<pre><code>    - Expected
    + Received

    @@ -1,16 +1,7 @@
      Array [
        Object {
    -     ""frame"": 0,
    -     ""notification"": Notification {
    -       ""error"": undefined,
    -       ""hasValue"": true,
    -       ""kind"": ""N"",
    -       ""value"": 2,
    -     },
    -   },
    -   Object {
          ""frame"": 1,
          ""notification"": Notification {
            ""error"": undefined,
            ""hasValue"": false,
            ""kind"": ""C"",

...... the code ......

      at TestScheduler.assertDeepEqual (common/chat/newMessages/ratifiedSendMessages/twilioRatifiedSendMessages.unit.test.js:27:24)
      at node_modules/rxjs/src/internal/testing/TestScheduler.ts:159:14
          at Array.filter (&lt;anonymous&gt;)
      at TestScheduler.Object.&lt;anonymous&gt;.TestScheduler.flush (node_modules/rxjs/src/internal/testing/TestScheduler.ts:157:39)
      at TestScheduler.run (node_modules/rxjs/src/internal/testing/TestScheduler.ts:392:12)
      at Object.&lt;anonymous&gt; (common/chat/newMessages/ratifiedSendMessages/twilioRatifiedSendMessages.unit.test.js:30:21)
</code></pre>
","2765977","","2071697","","2020-02-03 12:59:04","2020-02-03 12:59:58","Jest RXjs6 Marbles, how to test existing observable","<jestjs><rxjs6><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"60876385","1","61871144","","2020-03-26 21:26:31","","1","588","<p>I am using Angular and have been writing Unit tests for a while using jasmine-marbles. This is a scenario I can't seem to figure out. How would I test the <code>determineNextSteps$</code>? I am open to other solutions for testing this as well besides using jasmine-marbles.</p>
<p>Example:</p>
<pre class=""lang-js prettyprint-override""><code>export class Service {
  private person$: Observable&lt;any&gt; = this.store.pipe(
    select(fromStore.selectPersonState),
    map(({ person }) =&gt; person)
  );

  private parentSetsState$: Observable&lt;any&gt; = this.store.pipe(
    select(fromStore.selectParentState)
  );

  private childSet$: Observable&lt;any&gt; = this.parentSetsState$.pipe(
    map(({ parentSets }) =&gt;
      parentSets.find(set =&gt; set.name === 'FooBar')
    )
  );

  determineNextSteps$: Observable&lt;any&gt; = this.childSet$.pipe(
    tap(set =&gt;
      this.store.dispatch(
        fromStore.determineStep({
          set: set
        })
      )
    ),
    pairwise(),
    concatMap(pairedSet =&gt;
      this.person$.pipe(
        first(),
        map(person =&gt;
          !pairedSet[0].complete &amp;&amp; pairedSet[1].complete
            ? this.router.navigate(['/home', 'profile', person.id, 'next-steps'])
            : pairedSet
        )
      )
    )
  );

  constructor(private store: Store&lt;any&gt;, private router: Router) {
  }
}
</code></pre>
<p>Current attempt:</p>
<pre class=""lang-js prettyprint-override""><code>interface StoreState extends MockStoreState {}
describe('Service', () =&gt; {
  let service: Service;
  let mockStore: MockStore&lt;fromStore.State&gt;;
  let router: Router;
  let mockPersonStateSelector: MemoizedSelector&lt;fromStore.State, fromPersonReducer.PersonState&gt;;
  let mockRegistrationSetsStateSelector: MemoizedSelector&lt;
    fromStore.State,
    fromSetsReducer.SetsState
  &gt;;
  const initialState: StoreState = { ...mockStoreInitialState };
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      providers: [
        Service,
        { provide: Router, useValue: { navigate: jest.fn() } },
        provideMockStore({ initialState })
      ]
    });
    mockStore = TestBed.get(Store);
    router = TestBed.get(Router);
    mockPersonStateSelector = mockStore.overrideSelector(fromStore.selectPersonState, {
      ...fromPersonReducer.initialState
    });
    mockSetsStateSelector = mockStore.overrideSelector(fromProfileStore.selectSetsState, {
      ...fromSetsReducer.initialState
    });
    service = TestBed.get(Service);
    spyOn(mockStore, 'dispatch');
  });

  it('should be created', () =&gt; {
    expect(service).toBeTruthy();
  });

  describe('determineNextSteps$', () =&gt; {
    describe('when the set completes after a previous incompletion', () =&gt; {
      it('navigates the user to their next-steps', () =&gt; {
        mockPersonStateSelector.setResult({ ...fromPersonReducer.initialState, person: { id: '1' } as any });
        service['childSet$'] = cold('(ab)', {
          a: { name: 'foobar', complete: false },
          b: { name: 'foobar', complete: true }
        });
        expect(service.determineNextSteps$).toBeObservable(cold(''));
        expect(router.navigate).toHaveBeenCalledWith(['/home', 'profile', '1', 'next-steps']);
      });
    });
  });
});

</code></pre>
","4823979","","6059235","","2020-08-24 20:55:15","2020-08-24 20:55:15","Angular - testing Observable with Pairwise operator","<angular><testing><rxjs><jasmine-marbles><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"61274166","1","","","2020-04-17 14:35:23","","8","518","<p>Angular Component</p>

<pre class=""lang-ts prettyprint-override""><code>public setupObservables() {
  this.formFieldChanged$ = this.formField
    .valueChanges
    .pipe(
        debounceTime(100),
        distinctUntilChanged((a, b) =&gt; a === b),
    )
}
</code></pre>

<p>Jasmine Test</p>

<pre class=""lang-ts prettyprint-override""><code>import { of } from 'rxjs';
import { marbles } from 'rxjs-marbles/jasmine';  
...

it('should update value on debounced formField change', marbles(m =&gt; {
  const values = { a: ""1"", b: ""2"", c: ""3"" };

  const fakeInputs = m.cold('a 200ms b 50ms c', values);
  const expected = m.cold('100ms a 250ms c', values);

  // works on stackblitz but otherwise gives TS2540 compiler error
  // cannot assign to a read-only property
  component.formField.valueChanges = fakeInputs; 
  component.setupObservables();

  m.expect(component.formFieldChanged$).toBeObservable(expected);
}));
</code></pre>

<p><a href=""https://stackblitz.com/edit/angular-reactive-forms-marble-tests?embed=1&amp;file=src/app/app.component.spec.ts"" rel=""noreferrer"">stackblitz.com example</a></p>

<p>The intent is to use marble tests to test <code>Observable</code> code in context with Angular reactive forms.</p>

<ul>
<li>Does this approach make sense?</li>
<li>How to best mock the <code>valueChanges</code> of a <code>FormField</code> object?</li>
<li>Is there a better way to structure these kind of tests?</li>
</ul>
","769137","","769137","","2020-04-21 14:43:39","2021-06-24 09:06:35","Test Angular Reactive Forms using RxJS Marbles","<angular><rxjs><jasmine><rxjs-marbles>","2","6","6","","","CC BY-SA 4.0"
"61337404","1","61357679","","2020-04-21 06:41:30","","1","20","<p>I have created this function because for all the requests my application sends out using <code>http.post</code>, this is how different parts handle the response. So rather than duplicating the code, I thought to create a function. I want to simulate error handling and thought to use <code>marbel testing</code>. Though I can see that the test case <code>emits</code> an error message, the test still fails. What am I doing wrong</p>

<pre><code>private editAnswerSubject: Subject&lt;Result&gt;;
subscribeToReturnedObservable(observable:Observable&lt;any&gt;, subject:Subject&lt;Result&gt;) {
    observable.subscribe((res) =&gt; {
        const ev = &lt;HttpEvent&lt;any&gt;&gt;(res);
        if (ev.type === HttpEventType.Response) {
          const isResponseStructureOK: boolean = this.helper.validateServerResponseStructure(ev.body);
          if (isResponseStructureOK) {
            const response: ServerResponseAPI = ev.body;
            subject.next(new Result(response.result, response['additional-info']));

          } else {
            subject.next(new Result(messages.error, messages.invalidStructureOfResponse));
          }
        }
      },
      (error: ServerResponseAPI) =&gt; { //THIS IS THE CODE I WANT TO TEST
        const errorMessage: string = this.helper.userFriendlyErrorMessage(error);
        subject.next(new Result(messages.error, errorMessage));    
      },
      () =&gt; { // observable complete
      });
  }

  editAnswer(answer: Answer): any {
    const observable = this.bs.editAnswer(answer)
    this.subscribeToReturnedObservable(observable,this.editAnswerSubject);
  }
</code></pre>

<p>The test I have written so far is</p>

<pre><code>fit('should call next for the subject if the response from the server is error', () =&gt; {
      const questionService:QuestionManagementService = TestBed.get(QuestionManagementService);
      const serverErrorResponse = {
        result: ""error"",
        ['additional-info']: ""reason for error"",
        ['http-status']: ""304"",
        ['http-status-text']: ""not found""
      };
      const testScheduler = new TestScheduler((actual,expected)=&gt;{
        expect(actual).toEqual(expected);
      });
      spyOn(questionService['editQuestionSubject'],'next');
      testScheduler.run(helpers=&gt;{
        const { cold, expectObservable, expectSubscriptions } = helpers;
        const expectedMarble = '#|';//error
        const expectedIngridients = {a:serverErrorResponse};
        const observable = cold(expectedMarble,{},serverErrorResponse);

        questionService.subscribeToReturnedObservable(observable,questionService['editQuestionSubject']);
        const expectedResult = new Result(messages.error, 'Error code: 304. not found. error: reason for error');
        expect(questionService['editQuestionSubject'].next).toHaveBeenCalledWith(expectedResult);
      });
</code></pre>

<p>But it get error <code>Expected spy next to have been called with [ Result({ result: 'error', additionalInfo: 'Error code: 304. not found. error: reason for error' }) ] but it was never called.</code></p>

<p>I can see in the code trace that error value was received.</p>

<pre><code>subscribeToReturnedObservable called
got error from the Observable:  {result: ""error"", additional-info: ""reason for error"", http-status: ""304"", http-status-text: ""not found""}
</code></pre>
","6703783","","","","","2020-04-22 05:08:40","unable to write a test case with marbel testing","<rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"61730747","1","61733372","","2020-05-11 13:21:28","","3","427","<p>Given the following class:</p>

<pre><code>import { BehaviorSubject } from 'rxjs';
import { map } from 'rxjs/operators';

export class ObjectStateContainer&lt;T&gt; {
    private currentStateSubject = new BehaviorSubject&lt;T&gt;(undefined);
    private $currentState = this.currentStateSubject.asObservable();

    public $isDirty = this.$currentState.pipe(map(t =&gt; t !== this.t));

    constructor(public t: T) {
        this.update(t);
    }

    undoChanges() {
        this.currentStateSubject.next(this.t);
    }

    update(t: T) {
        this.currentStateSubject.next(t);
    }
}
</code></pre>

<p>I would like to write some tests validating that <code>$isDirty</code> contains the value I would expect after performing various function invocations. Specifically I would like to test creating a variable, updating it and then undoing changes and validate the value of <code>$isDirty</code> for each stage. Currently, I've seen two way of testing observables and I can't figure out how to do this test with either of them. I would like the test to do the following:</p>

<ol>
<li>Create a new <code>ObjectStateContainer</code>.

<ul>
<li>Assert that <code>$isDirty</code> is false.</li>
</ul></li>
<li>Invoke update on the <code>ObjectStateContainer</code>.

<ul>
<li>Assert that <code>$isDirty</code> is true.</li>
</ul></li>
<li>Invoke undoChanges on the <code>ObjectStateContainer</code>.

<ul>
<li>Assert that <code>$isDirty</code> is false.</li>
</ul></li>
</ol>

<hr>

<pre><code>import { ObjectStateContainer } from './object-state-container';
import { TestScheduler } from 'rxjs/testing';

class TestObject {
}

describe('ObjectStateContainer', () =&gt; {
    let scheduler: TestScheduler;

    beforeEach(() =&gt;
        scheduler = new TestScheduler((actual, expected) =&gt;
        {
            expect(actual).toEqual(expected);
        })
    );

    /*
        SAME TEST AS ONE BELOW
        This is a non-marble test example.
    */
    it('should be constructed with isDirty as false', done =&gt; {
        const objectStateContainer = new ObjectStateContainer(new TestObject());
        objectStateContainer.update(new TestObject());
        objectStateContainer.undoChanges();

        /*
            - If done isn't called then the test method will finish immediately without waiting for the asserts inside the subscribe.
            - Using done though, it gets called after the first value in the stream and doesn't wait for the other two values to be emitted.
            - Also, since the subscribe is being done here after update and undoChanges, the two previous values will already be gone from the stream. The BehaviorSubject backing the observable will retain the last value emitted to the stream which would be false here.
            I can't figure out how to test the whole chain of emitted values.
        */
        objectStateContainer
            .$isDirty
            .subscribe(isDirty =&gt; {
                expect(isDirty).toBe(false);
                expect(isDirty).toBe(true);
                expect(isDirty).toBe(false);
                done();
            });
    });

    /*
        SAME TEST AS ONE ABOVE
        This is a 'marble' test example.
    */
    it('should be constructed with isDirty as false', () =&gt; {
        scheduler.run(({ expectObservable }) =&gt; {
            const objectStateContainer = new ObjectStateContainer(new TestObject());
            objectStateContainer.update(new TestObject());
            objectStateContainer.undoChanges();

         /*
            - This will fail with some error message about expected length was 3 but got a length of one. This seemingly is happening because the only value emitted after the 'subscribe' being performed by the framework is the one that gets replayed from the BehaviorSubject which would be the one from undoChanges. The other two have already been discarded.
            - Since the subscribe is being done here after update and undoChanges, the two previous values will already be gone from the stream. The BehaviorSubject backing the observable will retain the last value emitted to the stream which would be false here.
            I can't figure out how to test the whole chain of emitted values.
        */
            const expectedMarble = 'abc';
            const expectedIsDirty = { a: false, b: true, c: false };
            expectObservable(objectStateContainer.$isDirty).toBe(expectedMarble, expectedIsDirty);
        });
});
});
</code></pre>
","1874522","","1874522","","2020-05-11 18:20:18","2020-05-11 18:20:18","RxJs test for multiple values from the stream","<rxjs><rxjs-marbles>","1","2","0","","","CC BY-SA 4.0"
"61760475","1","","","2020-05-12 19:37:28","","2","384","<p>I am using EMPTY from rxjs in order to handle the catchError, What is the correct value for expected in order to pass the fail scenario.</p>

<pre><code>import { Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { EMPTY } from 'rxjs';
import { map, mergeMap, catchError } from 'rxjs/operators';
import { MoviesService } from './movies.service';

@Injectable()
export class MovieEffects {

  loadMovies$ = createEffect(() =&gt; this.actions$.pipe(
    ofType('[Movies Page] Load Movies'),
    mergeMap(() =&gt; this.moviesService.getAll()
      .pipe(
        map(movies =&gt; ({ type: '[Movies API] Movies Loaded Success', payload: movies })),
        catchError(() =&gt; EMPTY)
      ))
    )
  );

  constructor(
    private actions$: Actions,
    private moviesService: MoviesService
  ) {}
}


</code></pre>

<pre><code>// unit test

it('should return a empty observable', () =&gt; {
   this.moviesServiceSpy.and.return(throwError('Error in service'));

   action$ = hot('a', a: { loadMovies() });

   const expected = cold('|');

   expect(loadMovies$).toBeObservable(expected);

})
</code></pre>
","1399262","","","","","2021-04-17 21:57:49","How to test with the marble approach when the returm is a EMPTY observable in effect?","<javascript><jasmine><rxjs5><ngrx-effects><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"62672230","1","62712652","","2020-07-01 07:59:03","","0","212","<p>I'm new to javascript testing, and I can't find clear examples to learn how to test these kinds of methods. I clearly need some help here please!</p>
<p>Here are the two methods I'm trying to test :</p>
<pre><code>public _getSearch(search: Search): Observable &lt; any[] &gt; {
    const timeOptions: DateCriteria = this._getTimeStartEnd(search);
    const searchField: string = this._decodeHexIfNecessary(search.searchField.trim());

    return this.store.pipe(
            select(getFilterById(search.filterId)),
            flatMap((filter: Filter) =&gt; {

                const indicators = [{
                        'criterias': this.filterService.getActiveCriterias(filter)
                    }
                ];
                search.lastSearch = new TransactionRequest(
                        search.offset, search.pageSize, timeOptions.begin, timeOptions.end,
                        indicators, search.sortData, searchField);

                const request = JSON.stringify(search.lastSearch);
                return this.rest.post(search.urls.get, request, true);
            }));
}

public _countTotalSearch(search: Search): Observable &lt; number &gt; {
    const timeOptions: DateCriteria = this._getTimeStartEnd(search);

    return this.store.pipe(
        select(getFilterById(search.filterId)),
        first(),
        concatMap((filter: Filter) =&gt; {
            const indicators = [{
                    'criterias': this.filterService.getActiveCriterias(filter)
                }
            ];
            const request = new TransactionRequest(
                    0, 0, timeOptions.begin, timeOptions.end,
                    indicators, null, search.searchField.trim());

            return this.rest.post(search.urls.count, JSON.stringify(request), true);
        }));
}
</code></pre>
<p>I initiated my spec.ts as follows :</p>
<pre><code>    describe('SearchService', () =&gt; {
  let searchService: SearchService;
  let store: MockStore;
  let itemsRestService: ItemsRestService;
  let restService: RestService;
  let scheduler: TestScheduler;
  let filterService: FilterService;

  const filterForSelector = TestModelFactory.generateFilter();
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({
      imports: [
        TranslateModule.forRoot(),
        HttpClientTestingModule
      ],
      providers: [
        SearchService,
        RestService,
        ItemsRestService,
        ReturnCodeRestService,
        {
          provide: FilterService,
          useValue: {}
        },
        {
          provide: DataMapperService,
          useValue: {}
        },
        provideMockStore({
          selectors: [
            {
              selector: 'getFilterById',
              value: filterForSelector
            }
          ]
        })
      ]
    });

    searchService = TestBed.inject(SearchService);
    itemsRestService = TestBed.inject(ItemsRestService);
    restService = TestBed.inject(RestService);
    filterService = TestBed.inject(FilterService);
    scheduler = new TestScheduler(((actual, expected) =&gt; {
      expect(actual).toEqual(expected);
    }));
    store = TestBed.inject(MockStore);
  });
});
</code></pre>
<p>I tried a lot of things, like subscribing, or marbles... But I can't make it work.
I'd like to check the result (observableFromApi) and to check the post request as well :</p>
<pre><code>  describe('getSearch', () =&gt; {
it('should select filters in store and call api', done =&gt; {
  // init vars
  const dateCriteria = new DateCriteria(faker.date.recent().getTime(), faker.date.recent().getTime());
  const resultFromApi = faker.random.word() as any;
  const observableFromApi = of(resultFromApi);
  const search = TestModelFactory.generateSearch();

  // spy
  spyOn(restService, 'post');
  spyOn(searchService, '_getTimeStartEnd');

  // mocks
  filterService.getActiveCriterias = jest.fn(() =&gt; faker.random.word() as any);
  searchService._getTimeStartEnd = jest.fn(() =&gt; dateCriteria);
  restService.post = jest.fn(() =&gt; observableFromApi);

  // call and expect
  expect(searchService._getSearch(search)).toEqual(observableFromApi);
  expect(restService.post).toHaveBeenCalledWith(search.urls.get, '', true);
});
  });
</code></pre>
<p>Can you help me please?</p>
<p>EDIT :</p>
<p>This way it starts to work, but I have an error :</p>
<pre><code>  describe('getSearch', () =&gt; {
it('should select filters in store and call api', done =&gt; {
  // init vars
  const dateCriteria = new DateCriteria(faker.date.recent().getTime(), faker.date.recent().getTime());
  const resultFromApi = faker.random.word() as any;
  const observableFromApi = of(resultFromApi);
  const search = TestModelFactory.generateSearch();

  // spy
  spyOn(restService, 'post');
  spyOn(searchService, '_getTimeStartEnd');

  // mocks
  filterService.getActiveCriterias = jest.fn(() =&gt; faker.random.word() as any);
  searchService._getTimeStartEnd = jest.fn(() =&gt; dateCriteria);
  // const expectedObservable = cold('a|', {a : observableFromApi});
  // restService.post = jest.fn(() =&gt; expectedObservable);

  restService.post = jest.fn(() =&gt; observableFromApi);

  searchService._getSearch(search).subscribe(res =&gt; {
    done();
    expect(res).toBe(observableFromApi);
    expect(restService.post).toHaveBeenCalledWith(search.urls.get, '', true);
  });
});
  });
</code></pre>
<p>Here is the error, I think the selector is not mocked properly, the flatMap is not called, I added a tap before the selector and it was called.</p>
<pre><code>  console.error
    Error: Uncaught [TypeError: Cannot read property 'ids' of undefined]
</code></pre>
<p>EDIT 2 :</p>
<p>I have the following error when I try to mock my selector :</p>
<p><a href=""https://i.stack.imgur.com/C6FDn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/C6FDn.png"" alt=""enter image description here"" /></a></p>
<p>This is how I declared the selector, what is wrong here please ?</p>
<pre><code>export const getFilterById = (id) =&gt; createSelector(selectAll, (allItems: Filter[]) =&gt; {
  if (allItems) {
    return allItems.find((item: Filter) =&gt; {
      return item.id === id;
    });
  } else {
    return null;
  }
});
</code></pre>
","3693945","","2071697","","2020-07-02 16:17:27","2020-07-03 09:38:30","How to test complex ngrx/rxjs service with jest and optionally with marbles","<angular><rxjs><jestjs><ngrx><rxjs-marbles>","1","4","","","","CC BY-SA 4.0"
"63705728","1","","","2020-09-02 12:40:01","","0","30","<p>I have loadUserCacheRequestEffect$ effect</p>
<pre><code>loadUserCacheRequestEffect$ = createEffect(() =&gt;
  this.actions$.pipe(
    ofType(ActionTypes.USER_SESSION_CACHE_REQUEST),
    switchMap(() =&gt; this.taskCacheKeyService.getCacheUserSessionData()
    .pipe(
        switchMap((sessionData: TaskCacheKey) =&gt; [
          ActionTypes.USER_SESSION_CACHE_SUCCESS({ sessionData }),
          ActionTypes.TASK_DETAILS_REQUEST({
            taskId: sessionData.taskId,
            templateNumber: sessionData.templateId
          })
        ]),
        catchError((err) =&gt; {
          return of(ActionTypes.USER_SESSION_CACHE_FAILURE({error: err.error.detail}));
        })
      ))
    )
  );
</code></pre>
<p>I have write unit test for success case that is working</p>
<pre><code>it('loadUserCacheRequestEffect should return USER_SESSION_CACHE_SUCCESS and TASK_DETAILS_REQUEST actions', () =&gt; {
    actions$ = hot('a', { a: fromActions.USER_SESSION_CACHE_REQUEST() });
    const expected = cold('(bc)', {
      b: fromActions.USER_SESSION_CACHE_SUCCESS({
        sessionData: userSessionDataMock
      }),
      c: fromActions.TASK_DETAILS_REQUEST({
        taskId: userSessionDataMock.taskId,
        templateNumber: userSessionDataMock.templateId
      })
    });
    expect(effects.loadUserCacheRequestEffect$).toBeObservable(expected);
  });
</code></pre>
<p>I would like to write unit test when effect fail and return ActionTypes.USER_SESSION_CACHE_FAILURE({error: err.error.detail})</p>
","1885421","","","","","2020-09-03 05:21:12","How to write unit test for effect when it fails in angular","<angular><unit-testing><rxjs-marbles>","2","0","","","","CC BY-SA 4.0"
"64224321","1","","","2020-10-06 10:51:58","","1","93","<p>The given class has a method which returns a cached stream but that stream can be triggered by another private hot stream which makes the cached stream emits a new value.</p>
<p>The class</p>
<pre><code>export class SomeClass {
  private cache: Observable&lt;number&gt;;
  private trigger$ = new Subject();
  private multiply = 1;

  constructor(private num: number) {}

  getNumber(): Observable&lt;number&gt; {
    return (
      this.cache ||
      (this.cache = concat(of(void 0), this.trigger$).pipe(
        switchMap(() =&gt; of(this.num * this.multiply++)),
        shareReplay(1)
      ))
    );
  }

  trigger(): void {
    this.trigger$.next();
  }
}
</code></pre>
<p>Example: <a href=""https://stackblitz.com/edit/rxjs-gpyc46?file=index.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-gpyc46?file=index.ts</a></p>
<p>What is the way to test it?
This try is failed</p>
<pre><code>it(&quot;trigger updates&quot;, () =&gt; {
  testScheduler.run(({ expectObservable }) =&gt; {
    const num$ = someClass.getNumber();
    expectObservable(num$).toBe(&quot;a&quot;, { a: 3 });
    someClass.trigger();
    expectObservable(num$).toBe(&quot;a&quot;, { a: 6 });
    someClass.trigger();
    expectObservable(num$).toBe(&quot;a&quot;, { a: 9 });
  });
});
</code></pre>
<p>Example: <a href=""https://stackblitz.com/edit/rxjs-test-tricky-flow?file=src%2Fsome-class.spec.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-test-tricky-flow?file=src%2Fsome-class.spec.ts</a></p>
<p>UPD: so the problem here that seems it is not possible to mock the <code>trigger$</code> property.</p>
<p>It would look like this</p>
<pre><code>it(&quot;trigger updates&quot;, () =&gt; {
  testScheduler.run(({ hot, expectObservable }) =&gt; {
    spyOnProperty(someClass, 'trigger$', 'get').and.returnValue(hot('^--b--c'));
    const num$ = someClass.getNumber();
    expectObservable(num$).toBe(&quot;a--b--c&quot;, { a: 3, b: 6, c: 9 });
  });
});
</code></pre>
<p>But the <code>trigger$</code> property must be changed this way</p>
<pre><code>  get trigger$() {
    return new Subject();
  }
</code></pre>
<p>Example: <a href=""https://stackblitz.com/edit/rxjs-test-tricky-flow-x2arxf?file=src%2Fsome-class.ts"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/rxjs-test-tricky-flow-x2arxf?file=src%2Fsome-class.ts</a></p>
","2331113","","2331113","","2020-10-06 12:39:44","2020-10-06 12:39:44","How to test concatenate streams in rxjs","<testing><rxjs><rxjs-marbles>","0","0","","","","CC BY-SA 4.0"
"64258427","1","","","2020-10-08 08:14:21","","0","130","<p>Using RXJS's <code>TestScheduler</code>, is there a nice way to marble-test an event-like observable that emits <code>undefined</code> values?</p>
<p>I am using TypeScript, so type circumvention / monkey-patching is not desirable.</p>
<pre class=""lang-js prettyprint-override""><code>testScheduler.schedule(() =&gt; valueEmittingWork(), 20);
testScheduler.schedule(() =&gt; valueEmittingWork(), 40);

testScheduler.run(rx =&gt; {
    rx.expectObservable(myObservable).toBe(`20ms ??? 19ms ???`);
    // Above uses the new time progression syntax. What do I put instead of ???
});
</code></pre>
","499206","","","","","2020-10-08 08:21:19","How do I marble-test an observable of void values?","<unit-testing><rxjs><rxjs-marbles>","1","0","","","","CC BY-SA 4.0"
"64304069","1","","","2020-10-11 12:34:50","","0","34","<p>I am trying to learn rx marbles for unit tests. I have problem to test value of behaviorsubject inside subscribe block. There is problem with subject cars$ as well.</p>
<pre><code>  private readonly carsSubject = new Subject();
  readonly cars$ = this.carsSubject.asObservable();
  private readonly carsLoadingSubject = new BehaviorSubject&lt;boolean&gt;(false);
  readonly carsLoading$ = this.carsLoadingSubject.asObservable();

  constructor(private carsBackendService: CarsBackendService) { }

  public loadCars(carsPayload: Car): void {
    this.carsLoadingSubject.next(true);
    this.carsBackendService.getCars(carsPayload)
      .subscribe(
      cars =&gt; {
        this.carsSubject.next(cars);
        this.carsLoadingSubject.next(false);
      }, err =&gt; {
        console.log('Error while getting cars', err);
        this.carsLoadingSubject.next(false);
        }
      );
  }
</code></pre>
<p>I have written following test for this code block:</p>
<pre><code>  it('should carsLoading$ return true when loadCars started and false after loded', () =&gt; {
    scheduler.run(({ expectObservable, flush }) =&gt; {
      service.loadCars(mockCarPayload);
      flush();
      expectObservable(service.carsLoading$).toBe('a-b-c', {a: false, b: true, c: false });
    });
  });
</code></pre>
<p>The problem is that I receive errror that expected length of emitted items from carsLoading$ should 1, but I expect 3 and value is always false. How should I test it?</p>
","12975589","","","","","2020-10-11 12:34:50","How to test emit from subject inside subscribe block?","<angular><unit-testing><rxjs><jasmine><rxjs-marbles>","0","0","","","","CC BY-SA 4.0"
"65358762","1","","","2020-12-18 14:27:36","","0","29","<p>I am looking to write marbles tests for method which return following observable. I want to make sure that proper methods with proper values are passed through the chain.</p>
<pre><code>  effectGenerator = (myObservable$: Observable&lt;any&gt;) =&gt; {
    return myObservable$.pipe(
      switchMap(myObservableValue =&gt;
       myService.makeHttpCall(myObservableValue).pipe(
          tap({
            next: () =&gt; {
              method1(myObservableValue);
              method2(myObservableValue + x)
            },
            error: error =&gt; hendleError(error)
          })
        )
      )
    );
  };
</code></pre>
<p>I would like to assert:</p>
<ul>
<li>If <strong>myService</strong> where called by proper method and with proper value</li>
<li>If on success <strong>method1</strong> and <strong>method2</strong> where called with proper value</li>
<li>If on <strong>mySerivce</strong> thorw error it was properly handled by my <strong>handleError</strong> method.</li>
</ul>
","6787953","","","","","2020-12-18 14:27:36","Assert whether proper methods were called on success and on error of my observable with marbles testing","<unit-testing><testing><rxjs><rxjs-marbles>","0","0","","","","CC BY-SA 4.0"
"65643749","1","65655470","","2021-01-09 14:25:19","","0","33","<p>I have written the following effect in my Angular app which uses <code>rxjs</code>. On <code>MyActions.myAction</code>, I receive an object containing a property <code>ids</code> - an array of ids - and for each id I want to send an HTTP request via <code>this.myApiService.getResource</code>, which returns an <code>Observable&lt;Resource&gt;</code>. I want then to collect all results in an array, and dispatch another action passing the array.</p>
<pre><code>  public loadResources$: Observable&lt;MyAction&gt; = this.actions$.pipe(
    ofType(MyActions.myAction),
    switchMap(({ ids }) =&gt; from(ids).pipe(
      mergeMap(id =&gt; this.myApiService.getResource(id)),
      toArray()
    )),
    map(resources) =&gt; MyActions.resourcesLoaded({ resources } )),
  );
</code></pre>
<p>The code above does the job, but I wonder whether I should avoid nesting two flows of reactive operators, and whether there is a better way to write that.</p>
<p>The reason I wonder that is that I am having problems writing a test for it. I wrote the test below but I cannot make it pass.</p>
<pre><code> it('should dispatch an resourcesLoaded action with the resources', () =&gt; {
      const ids = ['5f7c723832758b859bd8f866'];
      const resources = [{} as Resource];

      const values = {
        l: MyActions.loadResources({ ids }),
        t: ids[0],
        o: MyActions.resourcesLoaded({ resources })
      };

      actions =         hot('--l------------', values);
      const get$ =     cold('  -------t-----', values);
      const expected = cold('---------o-----', values);

      myApiService.getResource.withArgs(ids[0]).returns(get$);

      expect(myEffects.loadResources$).toBeObservable(expected);
    });
</code></pre>
<p>The error I get is:</p>
<pre><code>     Expected $.length = 0 to equal 1.
Expected $[0] = undefined to equal Object({ frame: 50, notification: Notification({ kind: 'N', value: { ....
Error: Expected $.length = 0 to equal 1.
Expected $[0] = undefined to equal Object({ frame: 50, notification: Notification({ kind: 'N', value: { ....
    at &lt;Jasmine&gt;
    at compare (http://localhost:9876/Users/jacopolanzoni/Documents/Development/myProject/node_modules/jasmine-marbles/index.js:91:1)
    at &lt;Jasmine&gt;
</code></pre>
","976992","","976992","","2021-01-10 12:37:45","2021-01-10 16:17:47","Should we avoid nested rxjs operators? One case which I cannot test","<rxjs><rxjs-pipeable-operators><jasmine-marbles><rxjs-marbles><marble-diagram>","2","6","","","","CC BY-SA 4.0"
"65671378","1","65683715","","2021-01-11 17:04:53","","0","52","<p>I have an NGRX effect that - depending on the state - emits an action with a delay or it emits nothing.
I want to write a test, covering both situations.</p>
<p>This is the effect:</p>
<pre><code>myEffect$ = createEffect(() =&gt;
  this.actions$.pipe(
    ofType(MyAction),
    filter(state =&gt; state.foo === false),
    delay(4000),
    map(state =&gt; myOtherAction())
  )
);
</code></pre>
<p>The test for the situation where it <strong>should emit</strong> the otherAction with the delay works fine:</p>
<pre><code>describe('emit my action', () =&gt; {
   const action = MyAction();

   it('should return a stream with myOtherAction', () =&gt; {
      const scheduler = getTestScheduler();
      scheduler.run(helpers =&gt; {
        // build the observable with the action
        actions = hot('-a', { a: action });

        // define what is the expected outcome of the effect
        const expected = {
           b: MyOtherAction()
        };
        helpers.expectObservable(effects.myEffect$).toBe('- 4000ms b', expected);
      });
   });
});
</code></pre>
<p>But I have no clue how to test the other state, where it should <strong>NOT emit</strong> another action (the stream has zero length):</p>
<pre><code>   it('should return an empty stream', () =&gt; {
      store.setState({
        myFeature: {
           foo: true
        }
      });
      // ???
   });
</code></pre>
<p>Please help :)</p>
","13110632","","","","","2021-01-12 12:12:02","Testing NGRX effect that emits action with delay OR does not emit anything","<jasmine><ngrx-effects><jasmine-marbles><rxjs-marbles><ngrx-test>","2","0","","","","CC BY-SA 4.0"
"65977164","1","","","2021-01-31 08:38:38","","0","36","<p>Here is the problem I try to solve using Reactive programming (with RxPy):</p>
<p>I have a stream of MIDI events (live piano performance) each corresponding to a key pressed or released. For a given note, the first event is &quot;pressed&quot;, and the following is always &quot;released&quot;. Of course, any key may be pressed before the release of another.</p>
<p>I'd like to transform this stream of events and only keep the &quot;release&quot; event with the elasped time between &quot;press&quot; and &quot;release&quot;.</p>
<p>Thus, I figured out that RX would be a perfect candidate to achieve that, and I aim to do the following :</p>
<p><a href=""https://i.stack.imgur.com/7MXKG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7MXKG.png"" alt=""enter image description here"" /></a></p>
<p>For simplicity sake, I did not mention the alternance of &quot;press&quot; and &quot;release&quot; attributes, neither the duration information which should be added into the resulting stream.</p>
<p>My first bet was to use <code>group_by()</code> operator, which leads to this :</p>
<p><a href=""https://i.stack.imgur.com/L5dQa.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/L5dQa.png"" alt=""enter image description here"" /></a></p>
<p>So far, my code looks like this :</p>
<pre><code>import rx
from rx.operators import filter, group_by

def is_note_message(event):
    return event['type']==9  // MIDI &quot;Note On&quot; event

def is_note_pressed(event):
    return event['velocity']&gt;0

def is_note_released(event):
    return event['velocity']==0

(...)

note_obs = midi_events.pipe(
    filter( is_note_message ),
    group_by( lambda evt: evt['note'])
)

</code></pre>
<p>The issue is that I would like to only group 2 events of a given note (the &quot;press&quot; and the &quot;release&quot;), thus I wanted to go further by using <code>group_by_until()</code> for that. Note that I made two assumptions here, that may not be true :</p>
<ul>
<li>I think that doing so will later make to process of dealing with duration compute easier.</li>
<li>I think that <code>group_by_until()</code> is able to &quot;stop&quot; the grouping based on some events property.</li>
</ul>
<p><a href=""https://i.stack.imgur.com/Qdgau.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Qdgau.png"" alt=""enter image description here"" /></a></p>
<p>Here is where I'm stuck :</p>
<ul>
<li>I can't find the correct syntax for <code>group_by_until()</code> to stop grouping iff <code>is_note_released()</code> is true</li>
<li>I'm not sure how to process each grouped events to compute the duration, and then merge (with <code>flat_map()</code> ?) them (but that may be for another question)</li>
</ul>
","1620937","","1620937","","2021-01-31 08:49:54","2021-01-31 08:49:54","How to use RxPy group_by_until() operator?","<reactive-programming><rx-py><rxjs-marbles>","0","0","","","","CC BY-SA 4.0"
"67139504","1","67159341","","2021-04-17 14:52:23","","3","153","<p>Considering I have the following code:</p>
<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let Rx = window['rxjs'];
const { of,
    queueScheduler,
    asapScheduler,
    asyncScheduler,
    animationFrameScheduler
} = Rx;
const { observeOn, tap } = Rx.operators;
console.clear();


let source$ = of(1, 2, 3, asapScheduler).pipe(
    tap((v) =&gt; {
        console.log('tap ', v);
    }),
)

source$.subscribe((v) =&gt; {
    console.log('Value ', v);
    Promise.resolve().then(() =&gt; {
        console.log('Microtask value ', v);
    });
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/rxjs/6.2.1/rxjs.umd.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
<p>Which I use asapScheduler operator.</p>
<p>As per the documentation,</p>
<p>asap will wait for the current synchronously executing code to end and then it will try to execute the given task as fast as possible.</p>
<p>What's the execution order of the above code? How do they work? I would not have expected that the tap3 to print at the last</p>
<p>Below are the output,</p>
<pre><code>tap  1
Value  1  
tap  2    // here why did this not print Microtask value 1 and Microtask value 2 after printing tap1 and value1?
Value  2
Microtask value  1
Microtask value  2
tap  3
Value  3
Microtask value  3
</code></pre>
","4646531","","4646531","","2021-04-18 18:23:22","2021-04-19 09:25:57","Order of execution with rxjs asapscheduler","<rxjs><rxjs6><rxjs-observables><rxjs-pipeable-operators><rxjs-marbles>","2","0","","","","CC BY-SA 4.0"
"67230987","1","67278674","","2021-04-23 13:38:23","","1","52","<p>I am testing the following redux-observable epic:</p>
<pre class=""lang-js prettyprint-override""><code>export const loginEpic: Epic&lt;LoginActionTypes&gt; = (action$, state$, { ajax }) =&gt; action$.pipe(
  filter(isOfType(LOGIN)),
  mergeMap(action =&gt; login(action.payload.credentials, ajax).pipe(
    map(ajaxResponseObject =&gt; ajaxResponseObject.response as User),
    map(user =&gt; loginSuccess(user)),
    catchError((ajaxResponseObject: AjaxResponse) =&gt; of(loginFail(ajaxResponseObject.response as NodeJS.ErrnoException)))
  ))
);
</code></pre>
<p>I have written two similar tests to verify that loginSuccess and loginFail are working: (I've excluded some mock actions):</p>
<p>loginSuccess</p>
<pre class=""lang-js prettyprint-override""><code>      const actionInput$ = hot('-a', actionValues);
      const action$ = new ActionsObservable(actionInput$);

      const state$ = new StateObservable(new BehaviorSubject(null), null);

      const responseInput$ = cold('--a', responseValue);
      const dependencies = { ajax: () =&gt; responseInput$ };

      const output$ = loginEpic(action$, state$, dependencies);
      expectObservable(output$).toBe('---b', actionValues);

</code></pre>
<p>loginFail</p>
<pre class=""lang-js prettyprint-override""><code>      const actionInput$ = hot('-a', actionValues);
      const action$ = new ActionsObservable(actionInput$);

      const state$ = new StateObservable(new BehaviorSubject(null), null);

      const responseInput$ = cold('--#', undefined, mockResponse);
      const dependencies = { ajax: () =&gt; responseInput$ };

      const output$ = loginEpic(action$, state$, dependencies);
      expectObservable(output$).toBe('------b', actionValues);
</code></pre>
<p>They are both working, however, the testing framework says that it is expecting 3 additional frames than the previous test. I don't understand why. I am hoping someone can explain it to me.</p>
","7470746","","7470746","","2021-04-23 14:12:41","2021-04-27 07:28:06","Why are there 3 additional frames when marble testing Observables that error out?","<typescript><unit-testing><rxjs><redux-observable><rxjs-marbles>","1","2","","","","CC BY-SA 4.0"
"67292326","1","","","2021-04-28 00:43:52","","1","14","<p>I'm trying to write a test for an object that has both reactive elements and non-nonreactive elements. I cannot figure out how to write the marble diagrams so the test is legible.</p>
<p>In the test below, I have an object I'm testing that both stores a value and publishes it to a subject. I want to write the test so I can emit some values, stop virtual time, and check some assertions. Then, I want to resume virtual time. So, I think I want to use <code>flush</code>.</p>
<p>The test below succeeds, but it's not legible: The marble diagrams for <code>source2</code> and <code>expected2</code> don't line up with each other, so I can't really &quot;see&quot; that the test is written correctly. And if I define <code>source2</code> above the first call to <code>expectObservable</code>, then the second call to <code>expectObservable</code> never sees any values.</p>
<pre class=""lang-js prettyprint-override""><code>class StoresLatestValue {
  constructor() {
    this.subject = new Subject();
  }
  emit(value) {
    this.latest = value;
    this.subject.next(value);
  }
}

test(&quot;StoresLatestValue works&quot;, () =&gt; {
  new TestScheduler((actual, expected) =&gt; expect(actual).toEqual(expected)).run(
    (helpers) =&gt; {
      const { flush, hot, expectObservable } = helpers;
      const obj = new StoresLatestValue();

      // First half of the test
      const source1 = hot(&quot;a-b-c&quot;);
      const expected1 = &quot;  a-b-c&quot;;
      source1.subscribe((val) =&gt; obj.emit(val));
      expectObservable(obj.subject).toBe(expected1);
      flush();

      // Check that the latest value is what we expect
      expect(obj.latest).toBe(&quot;c&quot;);

      // These next two marble diagrams work, but since they don't line up,
      // it's hard to know that the test is written correctly
      const source2 = hot(&quot;d-e--&quot;);
      const expected2 = &quot;  ----d-e--&quot;;
      source2.subscribe((val) =&gt; obj.emit(val));
      expectObservable(obj.subject).toBe(expected2);
      flush();

      // Check that the latest value is what we expect
      expect(obj.latest).toBe(&quot;e&quot;);
    }
  );
});
</code></pre>
<p>I've tried adding the subscription operator <code>^</code> to <code>source</code>, but it doesn't seem to help. I also tried using a cold observable, but I still can't write the marbles so everything lines up nicely:</p>
<pre class=""lang-js prettyprint-override""><code>// Making the second observable cold works, but still doesn't line up
const source1 = hot(&quot; a-b-c&quot;);
const expected1 = &quot;   a-b-c&quot;;
const source2 = cold(&quot;  -d-e--&quot;);
const expected2 = &quot;   -----d-e--&quot;;

// Making them both cold doesn't seem to work at all, nothing is observed
// by the second expectObservable
const source1 = cold(&quot;a-b-c&quot;);
const expected1 = &quot;   a-b-c&quot;;
const source2 = cold(&quot;-----d-e--&quot;);
const expected2 = &quot;   -----d-e--&quot;;
</code></pre>
<p>Is there a way to write this test so it <strong>looks</strong> correct?</p>
","19818","","","","","2021-04-28 00:43:52","How to pause and resume virtual time when using marble testing with rxjs?","<javascript><rxjs><automated-tests><rxjs-marbles>","0","0","","","","CC BY-SA 4.0"