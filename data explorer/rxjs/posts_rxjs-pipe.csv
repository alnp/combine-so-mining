Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"48030197","1","","","2017-12-30 01:44:03","","152","154949","<p>Pipes are filters for transforming data (formats) in the template.</p>

<p>I came across the <code>pipe()</code> function as below. What does this <code>pipe()</code> function exactly mean in this case? </p>

<pre><code>return this.http.get&lt;Hero&gt;(url)
  .pipe(
    tap(_ =&gt; this.log(`fetched hero id=${id}`)),
    catchError(this.handleError&lt;Hero&gt;(`getHero id=${id}`))
);
</code></pre>
","4001625","","591656","","2020-02-20 04:23:43","2020-02-20 04:25:26","What is pipe() function in Angular","<angular><rxjs><angular-pipe><rxjs-pipe>","5","2","30","","","CC BY-SA 4.0"
"63545822","1","63546523","","2020-08-23 10:20:21","","1","680","<p>I have a service that is responsible to execute a httpClient.get every x seconds, using a timer.
I need this timer to start running whenever the service is up, so the <strong>timer</strong> is defined in the <strong>service</strong> <strong>constructor</strong>. According to my understanding, the subscription should be registered in the timer scope as seen below (I don't want to change it if there's no need, unless it is incorrect).</p>
<p>The all system is working fine as long as there are no errors\exceptions\error 500 exception from the backend server.
Now, I need 2 things:</p>
<ol>
<li>I would like to <strong>catchError</strong> whenever there is a problem in the backend server.</li>
<li>I would like the observer to keep running according to the timer times (to the next tick), even if there is an exception.
My final result should be reaching the popUpAlert in the component whenever there is exception
See my code - this the webapi controller:</li>
</ol>
<pre class=""lang-cs prettyprint-override""><code>public IActionResult getSomeErrorAsTest()
{
    try
    {
        throw new Exception(&quot;Serer error&quot;);
    }
    catch(Exception ex)
    {
        return StatusCode(StatusCodes.Status500InternalServerError, new List&lt;string&gt;());
        //throw ex;
    }
}
</code></pre>
<p>This is the service (assume that the data changes in every get request - no need to implement if it really do):</p>
<pre><code>export class MyService
{
    MyDataSubject = new Subject&lt;any[]&gt;();
    MyDataChanged :Observable&gt;any[]&gt; = this.MyDataSubject.asObservable();
    
    subscribe :Subscription;
    constructor(private httpClient : HttpClient)
    {
        this.subscribe = timer(0, 30000).pipe(
        switchMap(()=&gt;
            this.getData())).subscribe();
    }
    getData()
    {
        return this.httpClient.get&lt;any[]&gt;(&lt;controller url&gt;)
        .pipe(
            tap(res =&gt;
            {
                this.MyDataSubject.next(res);
            }),
            catchError(error =&gt;
                {
                    debugger;//I would expect to catch the debugger here, but nothing happens
                    return throwError(error);
                })
            )
    }
}   
</code></pre>
<p>The consumer component:</p>
<pre><code>export class MyComponent (private mySrv : MyService)
{
    getMyData()
    {
        let sub =this.mySrv.MyDataChanged.subscribe(result =&gt; doSomething(),
                                                    error=&gt; popUpAlert());
    }
}
</code></pre>
","6721134","","6721134","","2020-08-23 10:32:46","2021-06-24 21:44:14","How to continue catchError in timer (rxjs)","<angular><timer><rxjs><rxjs-observables><rxjs-pipe>","1","3","","","","CC BY-SA 4.0"
"66155699","1","66164527","","2021-02-11 13:29:05","","0","430","<p>I'm trying to automatize a process of updating some data in the backend of my program.
I'm using my Angular frontend, where I created a function only the master user can access and that should make him login in every administration (tenant), where it will download some objects with some wrong data inside, ask from a google service the right data and update the data in the backend, and do all this operations for each tenant.</p>
<p>I thougt of writing each of this operations as an observable and using concat to do everything in order, but before even finishing getting the right data, which I do inside a tap, it alredy tries to login in the next tenant, so when it actually has the right data he wont be able to upload them to the backend since it will refuse them as from the wrong tenant.</p>
<p>I think this problem is caused by the long operations needed in the tap (and there are some stuff I'll need to do that will require even more time),.</p>
<p>This is my code snippet (without unrelated stuff):</p>
<pre><code>const obsList = [] as Observable&lt;any&gt;[];
this.assignedTenants.forEach(tenant =&gt; {
  const obsList2 = [] as Observable&lt;any&gt;[];
  obsList.push(this.authenticationService.login(new Credentials(usr, psw), tenant.id));
  obsList.push(this.structureService.getStructuresWithWrongAltitude()
    .pipe(tap(structuresReceived =&gt; {
      obsList2 = [] as Observable&lt;any&gt;[];
      if (structuresReceived != null &amp;&amp; structuresReceived.length &gt; 0) {
        structuresReceived.forEach(s =&gt; {
          this.getElevation(new google.maps.LatLng(s.centro.coordinates[0], s.centro.coordinates[1]))
            .then(a =&gt; {
              s.centroAltitudine = a;
              this.obsList2.push(this.structureService.putStructure(s));
            })
            .catch();
        });
      }
  })));
  obsList.push(forkJoin(obsList2)
    .pipe(tap(() =&gt; this.storageService.logout())));
});
concat(...obsList).subscribe();
</code></pre>
<p>As you can see the this code should create and execute 3 observables for each tenant, the first one used to login, the second one to get the wrong data, get the right data and prepare for the third, which will update the data.
As I said, usually when entering the tap from the second observable, the getStructuresWithWrongAltitude one, I can alredy see by using logs that it tries to login to other tenants.</p>
<p>My theory is that as soon as it gets the wrong data it tries to execute the third observable, which is still void, and go to the next tenant, but I dont know how to fix this.</p>
<p>I would need a way for the second observable to not emit until the tap is completed, or another way to prevent the concat to go on before other operations have finished</p>
<p>Thank you for your help</p>
<p>EDIT:</p>
<p>I was able to fix this by making the getElevation (which returns a promise) to an observable list, which would in turn create a new observable list to save the data.</p>
<p>As I said before I need to do something very similar, with the difference that this time the tap will actually have to do a lot of calculations that will take a long time, so I wont be able to use the same fix, as such my question remains: can I make the concat wait until the tap is finished?</p>
<p>EDIT 2 for clarification</p>
<p>As I said in my last edit, that specific example got solved by converting the stuff inside the tap into other observables, but I have almost the same problem with another function</p>
<p>this function needs to find files inside a folder, before uploading them</p>
<pre><code>const folderInput = this.folderInput.nativeElement;
folderInput.onchange = () =&gt; {
  this.filesUploaded = folderInput.files;
  const obsList = [] as any[];

  this.assignedTenants.forEach(tenant =&gt; {
    const obsList2 = [] as Observable&lt;any&gt;[];

    obsList.push(this.authenticationService.login(new Credentials(usr, psw), tenant.id));

    obsList.push(this.fileService.getAll()
      .pipe(
        tap(filesReceived =&gt; {
          if (filesReceived != null &amp;&amp; filesReceived.length &gt; 0) {
            console.log('upload picture: received list of files to update');

            let i = filesReceived?.length;
            filesReceived?.forEach(f =&gt; {
              const pathReceived = (f.originalFilename as string).substr(1).split('\\');

              let found = false;
              let index = -1;
              
              // searching the file in the folder
              //...
              
              if (found) {
                console.log('found a file');
                const selectedFile = this.filesUploaded[index];
                const formData = new FormData();
                formData.append('file', selectedFile, selectedFile.name);
                obsList2.push(this.fileService.updateFile(formData, f.id));
              }
              i--;
            });
            console.log('upload picture: updated obsList2');
            obsList.push(forkJoin(obsList2).subscribe(() =&gt; {
              console.log('upload picture: uploaded pictures');
              this.storageService.logout();
            }));
          }
      }))
    );
  });

  this.loadingIndicatorService.loading$.next(true);
  let counter = obsList.length;
  concat(...obsList).subscribe(() =&gt; {
    counter--;
    console.log('upload pictures: remaining phases: ' + counter);
    if (counter &lt;= 0) {
      this.loadingIndicatorService.loading$.next(false);
  }
});
};
folderInput.click();
</code></pre>
","14762821","","14762821","","2021-02-11 15:37:10","2021-02-12 16:34:48","Angular Rxjs: Have concat wait for a very long tap","<rxjs><concatenation><rxjs-observables><rxjs-pipeable-operators><rxjs-pipe>","2","4","","","","CC BY-SA 4.0"