Id,PostTypeId,AcceptedAnswerId,ParentId,CreationDate,DeletionDate,Score,ViewCount,Body,OwnerUserId,OwnerDisplayName,LastEditorUserId,LastEditorDisplayName,LastEditDate,LastActivityDate,Title,Tags,AnswerCount,CommentCount,FavoriteCount,ClosedDate,CommunityOwnedDate,ContentLicense
"56462348","1","","","2019-06-05 14:15:51","","7","1752","<p>I'm inspecting <a href=""https://developer.apple.com/documentation/combine"" rel=""noreferrer"">Combine</a>, a new framework by Apple. I created a playground, ran it in macOS Mojave 10.14.5 and Xcode 11.0 beta (11M336w).</p>

<p>Here is my code:
</p>

<pre><code>import Combine

struct Article: Identifiable {

    var id: Int
    var title: String
}

final class Data: BindableObject {

    let didChange = PassthroughSubject&lt;Data, Never&gt;()

    var showFavouriteOnly = false {
        didSet {
            didChange.send(self)
        }
    }
    var articles: [Article] = [.init(id: 1, title: ""WWDC 2018""),
                               .init(id: 2, title: ""WWDC 2019"")] {
        didSet {
            didChange.send(self)
        }
    }
}
</code></pre>

<p>But it fails with log:</p>

<blockquote>
  <p>error: Couldn't lookup symbols:
    Combine.PassthroughSubject.send(A) -> ()</p>
</blockquote>

<p>What am I doing wrong?</p>
","3514372","","","","","2020-11-11 14:13:53","Combine in Playgrounds","<swift><swift-playground><combine>","2","5","1","","","CC BY-SA 4.0"
"56496643","1","","","2019-06-07 14:52:04","","2","846","<p>I constructed a BindableObject tied to my custom view. </p>

<p>I wanna update the array of items in this class </p>

<pre><code>    // in my vm:

    class ViewModel {
        func fetched() {
            listView.listData.items = viewModel.listItems
        }
    }



    final class ListData: BindableObject {

        var didChange = PassthroughSubject&lt;ListData, Never&gt;()

        var items: [ListItem] = [] {
            didSet {
                didChange.send(self)
            }
        }
    }
</code></pre>

<p>I have a viewModel where I do my fetching because I would like to not have to inject a service into this ListData class. This is because I don't wan't it do any fetching I wanna keep that in my view model.</p>

<p>But when I try to update the ListData.Items in my VM I get this error:
    Reading EnvironmentObject outside View.body: file</p>

<p>Are you only allowed to update this variable inside the body of this new view class? In that case are you suppose to do all your network stuff inside a BindableObject?</p>

<p>Haven't found any documentation on the best practice of this yet.</p>
","3418097","","","","","2019-06-07 14:52:04","Reading EnvironmentObject<T> outside View.body","<swift><swiftui><combine>","0","4","2","","","CC BY-SA 4.0"
"56505189","1","56505224","","2019-06-08 09:40:36","","3","1604","<p>I'm trying to use the new <strong>Combine</strong> framework with the <strong>Notification Center</strong> as Apple explained in this video:
<a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""nofollow noreferrer"">https://developer.apple.com/videos/play/wwdc2019/721/</a></p>

<p>You can find it in the slide 21.</p>

<p>It seems that my project does not read the Combine framework apis.</p>

<pre><code>import Combine
import Foundation

let trickNamePublisher = NotificationCenter.default.publisher(for: .newTrickDownloaded)
</code></pre>

<p>And i'm getting this error:</p>

<p><strong>Value of type 'NotificationCenter' has no member 'publisher'</strong></p>
","6747915","","6747915","","2019-06-08 09:47:15","2019-06-18 23:46:44","iOS Swift: Value of type 'NotificationCenter' has no member 'publisher'","<ios><swift><combine>","2","0","1","","","CC BY-SA 4.0"
"56522258","1","56522391","","2019-06-10 07:31:14","","9","3609","<p>I watched the WWDC 2019 session ""Combine in Practice"" (<a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""noreferrer"">https://developer.apple.com/videos/play/wwdc2019/721/</a>).</p>

<p>In the video they used the following syntax to create a publisher:</p>

<pre class=""lang-swift prettyprint-override""><code>@Published var someName: String = """"
</code></pre>

<p>They did this so that <code>someName</code> becomes a publisher. However, Xcode doesn't like this syntax and gives me an error:</p>

<blockquote>
  <p>Unknown attribute 'Published</p>
</blockquote>

<p>I have no idea why. I'm using the Xcode 11 beta on macOS Catalina.</p>

<p>Any ideas?</p>
","3134192","","1045055","","2019-06-10 08:32:22","2019-06-25 20:07:24","IOS 13 Combine Framework - @Published not working (""Unknown attribute 'Published'"")","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"56529189","1","","","2019-06-10 15:22:48","","15","4627","<p>I've been playing around with SwiftUI and Combine and feel like there is probably a way to get a hold of the existing @State properties in a view and create a new one.</p>

<p>For example, I have a password creation View which holds a password and a passwordConfirm field for the user. I want to take those two @State properties and derive a new @State that I can use in my view that asserts if the input is valid. So for simplicity: not empty and equal.</p>

<p>The Apple docs say <a href=""https://developer.apple.com/documentation/swiftui/binding/3264174-publisher"" rel=""noreferrer"">there is a publisher</a> on a binding, though I can't appear to get ahold of it.</p>

<p>This is some non-functioning pseudo code:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct CreatePasswordView : View {
    @State var password = """"
    @State var confirmation = """"
    lazy var valid = {
        return self.$password.publisher()
            .combineLatest(self.$confirmation)
            .map { $0 != """" &amp;&amp; $0 == $1 }
    }

    var body: some View {
        SecureField($password, placeholder: Text(""password""))

        SecureField($confirmation, placeholder: Text(""confirm password""))

        NavigationButton(destination: NextView()) { Text(""Done"") }
            .disabled(!valid)
    }
}
</code></pre>

<p>Anyone found. the appropriate way of going about this / if it's possible?</p>

<p>UPDATE Beta 2:</p>

<p>As of beta 2 publisher is available so the first half of this code now works. The second half of using the resulting publisher within the View I've still not figured out (<code>disabled(!valid)</code>).</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct CreatePasswordView : View {
    @State var password = """"
    @State var confirmation = """"

    lazy var valid = {
        Publishers.CombineLatest(
            password.publisher(),
            confirmation.publisher(),
            transform: { String($0) != """" &amp;&amp; $0 == $1 }
        )
    }()

    var body: some View {
        SecureField($password, placeholder: Text(""password""))

        SecureField($confirmation, placeholder: Text(""confirm password""))

        NavigationButton(destination: NextView()) { Text(""Done"") }
            .disabled(!valid)
    }
}
</code></pre>

<p>Thanks.</p>
","1560414","","1560414","","2019-06-19 07:34:54","2021-06-16 19:27:18","Deriving binding from existing SwiftUI @States","<swift><swiftui><combine>","2","2","2","","","CC BY-SA 4.0"
"56548040","1","56548508","","2019-06-11 16:24:45","","4","1352","<p>I've been trying to follow the 'Introducing SwiftUI - Building Your First App' WWDC 19 video. No sample code is provided for this talk but I've been creating it as the presenter goes along. When trying to create a store though I get an  error that 'Cannot invoke 'send' with no arguments' from the line: </p>

<pre><code>didSet { didChange.send() }
</code></pre>

<p>I'm new to programming and struggling to troubleshoot. </p>

<pre><code>import SwiftUI
import Combine

class ReferenceStore : BindableObject {
    var references: [Reference] {
        didSet { didChange.send() }
    }

    init(references: [Reference] = []) {
        self.references = references
    }

    var didChange = PassthroughSubject&lt;Void, Never&gt;()
}
</code></pre>

<p>I'm using Xcode 11 beta and MacOS Catalina if it helps.</p>
","11632288","","","","","2019-07-25 19:21:49","How to fix ""Cannot invoke 'send' with no arguments"" in Swift 5.1","<swift><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"56551108","1","56551175","","2019-06-11 20:14:06","","7","2699","<p>I am using Combine and SwiftUI to do some async stuff, the point is that I don't know how to receive the response from the asynchronous operation in the main thread. The <a href=""https://developer.apple.com/documentation/combine/publisher/3204743-receive"" rel=""noreferrer"">apple doc</a> says that it can be used the RunLoop.main, but currently in Swift 5.0 it isn't a Scheduler. So any ideas about this?</p>

<p>I have tried to use as per apple doc, but no luck.</p>

<pre class=""lang-swift prettyprint-override""><code>anyPublisher
    .receiveOn(on: RunLoop.main)
</code></pre>
","4536762","","","","","2019-06-17 18:55:19","How to change thread using combine Publisher?","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"56551131","1","56551323","","2019-06-11 20:16:04","","53","20679","<p><a href=""https://developer.apple.com/tutorials/swiftui/handling-user-input"" rel=""noreferrer"">This tutorial by Apple about SwiftUI</a> uses a dollar sign to bind data, and I‘m having trouble finding more information about this data binding in SwiftUI.</p>

<pre><code>Toggle(isOn: $showFavoritesOnly) {
</code></pre>

<blockquote>
  <p>You use the $ prefix to access a binding to a state variable, or one of its properties.</p>
</blockquote>

<p>Is this some sort of <code>inout</code> type parameter? That uses the ampersand to pass it on.</p>
","1009013","","1265393","","2022-04-15 19:48:03","2022-04-15 19:48:03","What does the dollar sign do in Swift / SwiftUI?","<swift><swiftui><combine>","2","1","5","","","CC BY-SA 4.0"
"56552993","1","56612756","","2019-06-11 23:51:15","","4","1519","<p>I was experimenting with SwiftUI and came across a problem while implementing the data model for one of my List. My plan was to create a protocol <code>CardProtocol</code> as the data protocol for the elements of my lists and then have a CoreData implementation of the protocol as well as a dummy one for unit testing and Canvas use. If you are using a data collection in SwiftUI <code>List</code> the single elements need to conform to the <code>Identifiable</code> protocol.  </p>

<p>The code looks like this:</p>

<pre><code>import SwiftUI
import Combine


final class CardsModel: BindableObject {
    var cards: [CardProtocol] = []
    let didChange = PassthroughSubject&lt;CardsModel, Never&gt;()
}

protocol CardProtocol: Identifiable {
    var id: Int { get set }
    var firstName: String? { get set }
    var lastName: String? { get set }
    var email: String? { get set }
    var phone: String? { get set }
}
</code></pre>

<p>This will not even compile as the <code>Identifiable</code> protocol has 2 associated types which needs to be specified if the protocol is to be used for a variable definition.</p>

<pre><code>/// A type that can be compared for identity equality.
public protocol Identifiable {

    /// A type of unique identifier that can be compared for equality.
    associatedtype ID : Hashable

    /// A unique identifier that can be compared for equality.
    var id: Self.ID { get }

    /// The type of value identified by `id`.
    associatedtype IdentifiedValue = Self

    /// The value identified by `id`.
    ///
    /// By default this returns `self`.
    var identifiedValue: Self.IdentifiedValue { get }
}
</code></pre>

<p>The exact error being <code>error: protocol 'CardProtocol' can only be used as a generic constraint because it has Self or associated type requirements</code>.
Now <code>ID</code> is not an issue and can be fixed, but <code>IdentifiedValue</code> it's by nature different in the CoreData and the dummy implementation.</p>

<p>The only reasonable solution that I found was to remove compliance to <code>Identifiable</code> from the protocol and reintroduce it later in the View using <code>cardsModel.cards.identified(by: \.id)</code>. Is there any better way out of this, that let me keep the Identifiable compliance at protocol level?</p>
","2028375","","2028375","","2019-06-15 16:30:27","2019-06-15 17:44:22","Indentifiable Protocol extension for SwiftUI list data","<ios><swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"56570134","1","","","2019-06-12 20:46:52","","6","6144","<p>As I port some Objective-C code to Swift, I'm trying to better understand the new <code>Combine</code> framework and how I can use it to re-create a common design pattern. </p>

<p>In this case, the design pattern is a single object (Manager, Service, etc) that any number of ""clients"" can register with as a delegate to receive callbacks. It's a basic 1:Many pattern using delegates. </p>

<p><code>Combine</code> looks ideal for this, but the sample code is a bit thin. Below is a working example but I'm not sure if it's correct or being used as intended. In particular, I'm curious about reference cycles between the objects. </p>

<pre><code>class Service {

  let tweets = PassthroughSubject&lt;String, Never&gt;()

  func start() {
    // Simulate the need send to send updates.
    DispatchQueue.global(qos: .utility).async {
      while true {
        self.sendTweet()
        usleep(100000)
      }
    }
  }

  func sendTweet() {
    tweets.send(""Message \(Date().timeIntervalSince1970)"")
  }
}

class Client : Subscriber {
  typealias Input = String
  typealias Failure = Never

  let service:Service
  var subscription:Subscription?

  init(service:Service) {
    self.service = service

   // Is this a retain cycle?
   // Is this thread-safe? 
    self.service.tweets.subscribe(self) 
  }

  func receive(subscription: Subscription) {
    print(""Received subscription: \(subscription)"")

    self.subscription = subscription
    self.subscription?.request(.unlimited)
  }

  func receive(_ input: String) -&gt; Subscribers.Demand {
    print(""Received tweet: \(input)"")
    return .unlimited
  }

  func receive(completion: Subscribers.Completion&lt;Never&gt;) {
    print(""Received completion"")
  }
}

// Dependency injection is used a lot throughout the 
// application in a similar fashion to this:

let service = Service()
let client = Client(service:service)

// In the real world, the service is started when
// the application is launched and clients come-and-go.

service.start()
</code></pre>

<hr>

<p>Output is: </p>

<pre><code>Received subscription: PassthroughSubject
Received tweet: Message 1560371698.300811
Received tweet: Message 1560371698.4087949
Received tweet: Message 1560371698.578027
...
</code></pre>

<p>Is this even remotely close to how <code>Combine</code> was intended to be used? </p>
","48321","","310175","","2019-06-20 18:27:44","2020-08-18 11:50:45","Skeleton Example for Swift Combine Publisher-Subscriber","<swift><publish-subscribe><swift5><combine>","2","3","4","","","CC BY-SA 4.0"
"56571316","1","56691371","","2019-06-12 22:54:27","","4","1760","<p>In Apple's WWDC videos on <code>Swift Combine</code>, they always use <code>NSNotificationCenter</code> as the publisher of messages. However, a <code>Publisher</code> does not appear to have any ability to actually send a message on demand. That functionality appears to be in <code>Subject</code>.</p>

<p>Am I correct in assuming that a <code>Subject</code> must therefor be the root object of any chain of <code>Publishers</code>? Apple provides two built-in subjects called: <code>CurrentValueSubject</code> and <code>PassthroughSubject</code>.</p>

<p>But I assume I can write my own <code>Subject</code> using the appropriate protocols? </p>
","48321","","310175","","2019-06-20 18:27:31","2019-06-20 18:27:31","In Swift Combine, is the ""root"" object always a Subject?","<swift><swift5><combine>","1","0","2","","","CC BY-SA 4.0"
"56579501","1","56689905","","2019-06-13 11:31:52","","15","9339","<p>In Apple's 2019 WWDC video <code>Swift Combine in Practice</code>, they demonstrate using a <code>debounce</code> publisher to slow down the rate of messages. </p>

<pre><code>return $username
  .debounce(for: 0.5, scheduler: RunLoop.main)
  .removeDuplicates()
  .eraseToAnyPublisher()
</code></pre>

<p>However, anytime I attempt to use it in a similar fashion, I get the following error: </p>

<blockquote>
  <p>Cannot invoke 'debounce' with an argument list of type '(for: Double, scheduler: RunLoop)'</p>
</blockquote>

<p>The <code>debounce()</code> signature is: </p>

<pre><code>public func debounce&lt;S&gt;(for dueTime: S.SchedulerTimeType.Stride, 
                          scheduler: S,
                            options: S.SchedulerOptions? = nil) -&gt; 
                                    Publishers.Debounce&lt;Self, S&gt; where S : Scheduler
</code></pre>

<p><code>SchedulerTimeType.Stride</code> appears to be initializable with a numeric but it's not working for me or my inexperience with Swift Generics is on display. </p>

<p>What is the correct way to call this? </p>

<p><strong>Edit</strong></p>

<p>Duplicate of <a href=""https://stackoverflow.com/questions/56564967"">this question...</a></p>

<p>Searching for generic words like ""Combine"" is, for now, rather challenging... </p>

<p><em>macOS 10.15, Xcode 11</em></p>
","48321","","310175","","2019-06-20 18:27:22","2019-06-23 01:44:35","What is the correct syntax for using Publishers.debounce() in Swift Combine?","<swift><swift5><combine>","1","1","1","","","CC BY-SA 4.0"
"56601592","1","56601729","","2019-06-14 15:51:56","","2","2395","<p>For an class in <code>SwiftUI</code> to conform to <code>BindableObject</code>, it has to have a Publisher, usually <code>didChange</code>, which in all of the SwiftUI documentation and videos I've seen so far, is a <code>PassthroughSubject</code>.</p>

<p>For example, if you have a class called <code>TestObject</code>, <code>didChange</code> might equal <code>PassthroughSubject&lt;TestObject, Never&gt;()</code>. I understand that the first type is the type of the data that the <code>PassthroughSubject</code> passes on, but what is <code>Never</code>? What is its purpose and are there any scenarios where the second type is not <code>Never</code>?</p>
","5140471","","","","","2019-10-14 09:39:13","What is Never in PassthroughSubject?","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"56611057","1","","","2019-06-15 14:03:15","","2","1162","<p>I can see that <code>Subject.eraseToAnySubject()</code> returns the concrete <code>Subject</code> type <code>AnySubject</code>. I'm assuming this is using a type eraser pattern.  </p>

<p>However, the apple docs provide almost no details: <a href=""https://developer.apple.com/documentation/combine/passthroughsubject/3241547-erasetoanysubject"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/combine/passthroughsubject/3241547-erasetoanysubject</a></p>

<p>Can anyone explain how this works and where it should be used?  </p>

<p>Also, would it be possible to use the <code>some</code> keyword to avoid using <code>AnySubject</code>?</p>
","834333","","","","","2019-06-20 18:51:15","Can anyone explain Swift Combine's Subject.eraseToAnySubject() method and where it should be used?","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"56613622","1","","","2019-06-15 19:37:26","","9","3141","<p>SwiftUI has implicit animations with <code>.animate()</code>, and explicit ones using <code>.withAnimation()</code>. However, I can't figure out how to animate an image change:</p>

<pre><code>struct ImageViewWidget : View {
  @ObjectBinding var imageLoader: ImageLoader

  init(imageURL: URL) {
    imageLoader = ImageLoader(imageURL: imageURL)
  }

  var body: some View {
    Image(uiImage:
      (imageLoader.data.count == 0) ? UIImage(named: ""logo-old"")! :  UIImage(data: imageLoader.data)!)
        .resizable()
        .cornerRadius(5)
        .frame(width: 120, height:120)
  }
}
</code></pre>

<p>This <code>Image</code>'s <code>uiImage</code> argument is passed the <code>old-logo</code> (placeholder) if there's no data in <code>imageLoader</code> (a <code>BindableObject</code>), and replaces it with the correct one once that's asynchronously loaded:</p>

<pre><code>class ImageLoader : BindableObject {
  let didChange = PassthroughSubject&lt;Data, Never&gt;()

  var data = Data() {
    didSet {
      didChange.send(data)
    }
  }

  init(imageURL: URL) {
    print(""Image loader being initted!"")
    let url = imageURL

    URLSession.shared.dataTask(with: url) { (data, _, _) in
      guard let data = data else { return }
      DispatchQueue.main.async {
        self.data = data
      }
      }.resume()

  }
}
</code></pre>

<p>How can I animate this change, the moment where <code>data.count</code> stops being <code>0</code>, and we have the image? say I want a fade out-in animation..</p>
","5013234","","5013234","","2019-06-15 21:59:11","2020-07-02 08:15:40","SwiftUI: animate changes that depend on @ObjectBinding","<swiftui><combine>","2","4","3","","","CC BY-SA 4.0"
"56622860","1","56638991","","2019-06-16 21:48:41","","1","898","<p><strong>This issue would ideally be deleted because it is related to obsolete beta version of Xcode only.</strong></p>
<p>[WWDC Video 721 Combine in Practice][1] seems to indicate that RunLoop.main should be a valid scheduler to use in Combine with <code>delay</code> or <code>debounce</code> but I'm seeing compile errors with Xcode claiming that RunLoop doesn't conform to scheduler. Am I doing something wrong or is this just an issue with the first beta of Xcode.</p>
<pre><code>ContentView.swift:95:77: error: argument type 'RunLoop' does not conform to expected type 'Scheduler'
        return delayPublisher.debounce(for: .seconds(5), scheduler: RunLoop.main).eraseToAnyPublisher()
</code></pre>
<p>I've raised FB6160439.</p>
<p>[1]: <a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""nofollow noreferrer"">https://developer.apple.com/videos/play/wwdc2019/721/</a> (slides 79, 80, 211).</p>
","1476206","","1476206","","2021-06-21 13:38:00","2021-06-21 13:38:00","What should the scheduler be for delay and debounce in Combine? (Xcode 11 beta 1 only)","<swift><xcode><combine>","1","1","1","","","CC BY-SA 4.0"
"56657106","1","56657168","","2019-06-18 21:11:36","","2","3017","<p>I'd like to handle a series of network calls in my app. Each call is asynchronous and <code>flatMap()</code> seems like the right call. However, <code>flatMap</code> processes all arguments at the same time and I need the calls to be sequential -- the next network call starts only after the previous one is finished. I looked up an RxSwift <a href=""https://stackoverflow.com/questions/47906030/rxswift-how-to-chain-observables-sequentially"">answer</a> but it requires <code>concatMap</code> operator that Combine does not have. Here is rough outline of what I'm trying to do, but <code>flatMap</code> fires all <code>myCalls</code> at the same time.</p>

<pre><code>Publishers.Sequence(sequence: urls)
  .flatMap { url in
    Publishers.Future&lt;Result, Error&gt; { callback in 
        myCall { data, error in 
            if let data = data {
                callback(.success(data))
            } else if let error = error {
                callback(.failure(error))
            }
        }
    }
  }
</code></pre>
","2981130","","1000551","","2019-12-07 10:02:20","2019-12-07 10:02:20","How to schedule a synchronous sequence of asynchronous calls in Combine?","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"56677669","1","56826472","","2019-06-20 00:56:43","","0","1383","<p>I’m trying to change to the main thread in the downstream with <code>.receive(on: DispatchQueue.main)</code> but then I don’t receive inputs when using either <code>.subscribe(:)</code> or <code>.sink(receiveValue:)</code>. If I don’t change threads I do receive the proper inputs. </p>

<p><strong>Publisher</strong></p>

<pre class=""lang-swift prettyprint-override""><code>extension URLSessionWebSocketTask {
  struct ReceivePublisher: Publisher {
    typealias Output = Message
    typealias Failure = Error

    let task: URLSessionWebSocketTask

    func receive&lt;S&gt;(subscriber: S) where S: Subscriber, Output == S.Input, Failure == S.Failure {
      task.receive { result in
        switch result {
        case .success(let message): _ = subscriber.receive(message)
        case .failure(let error): subscriber.receive(completion: .failure(error))
        }
      }
    }
  }
}

extension URLSessionWebSocketTask {
  func receivePublisher() -&gt; ReceivePublisher {
    ReceivePublisher(task: self)
  }
}
</code></pre>

<p><strong>Subscriber</strong></p>

<pre class=""lang-swift prettyprint-override""><code>extension ViewModel: Subscriber {
  typealias Input = URLSessionWebSocketTask.Message
  typealias Failure = Error

  func receive(subscription: Subscription) {}

  func receive(_ input: URLSessionWebSocketTask.Message) -&gt; Subscribers.Demand {
    // Handle input here.
    // When using `.receive(on:)` this method is not called when should be.
    return .unlimited
  }

  func receive(completion: Subscribers.Completion&lt;Error&gt;) {}
}
</code></pre>

<p><strong>Subscribe</strong></p>

<pre class=""lang-swift prettyprint-override""><code>socketTask.receivePublisher()
      .receive(on: DispatchQueue.main)
      .subscribe(viewModel)
socketTask.resume()
</code></pre>
","3058601","","3058601","","2019-06-20 04:26:03","2019-07-19 20:25:48","Not receiving inputs when using `.receive(on: DispatchQueue.main)`","<ios><swift><combine>","1","6","","","","CC BY-SA 4.0"
"56686026","1","56747738","","2019-06-20 12:28:47","","29","5789","<p>From within a property wrapper in Swift, can you someone refer back to the instance of the class or struck that owns the property being wrapped? Using <code>self</code> doesn't obviously work, nor does <code>super</code>. </p>

<p>I tried to pass in <code>self</code> to the property wrapper's <code>init()</code> but that doesn't work either because <code>self</code> on <code>Configuration</code> is not yet defined when <code>@propertywrapper</code> is evaluated.</p>

<p>My use case is in a class for managing a large number of settings or configurations. If any property is changed, I just want to notify interested parties that <em>something</em> changed. They don't really need to know which value just, so use something like <code>KVO</code> or a <code>Publisher</code> for each property isn't really necessary.</p>

<p>A property wrapper looks ideal, but I can't figure out how to pass in some sort of reference to the owning instance that the wrapper can call back to.</p>

<p>References: </p>

<p><a href=""https://github.com/DougGregor/swift-evolution/blob/property-wrappers/proposals/0258-property-wrappers.md"" rel=""noreferrer"">SE-0258</a></p>

<pre><code>enum PropertyIdentifier {
  case backgroundColor
  case textColor
}

@propertyWrapper
struct Recorded&lt;T&gt; {
  let identifier:PropertyIdentifier
  var _value: T

  init(_ identifier:PropertyIdentifier, defaultValue: T) {
    self.identifier = identifier
    self._value = defaultValue
  }

  var value: T {
    get {  _value }
    set {
      _value = newValue

      // How to callback to Configuration.propertyWasSet()?
      //
      // [self/super/...].propertyWasSet(identifier)
    }
  }
}

struct Configuration {

  @Recorded(.backgroundColor, defaultValue:NSColor.white)
  var backgroundColor:NSColor

  @Recorded(.textColor, defaultValue:NSColor.black)
  var textColor:NSColor

  func propertyWasSet(_ identifier:PropertyIdentifier) {
    // Do something...
  }
}
</code></pre>
","48321","","1033581","","2019-06-25 06:22:05","2020-06-04 12:53:19","Can a Swift Property Wrapper reference the owner of the property its wrapping?","<swift><swift5><combine>","4","6","4","","","CC BY-SA 4.0"
"56717392","1","56717393","","2019-06-22 16:54:27","","5","3726","<p>In WWDC 2019 video 721, the basis of the main example starts like this:</p>

<pre><code>let trickNamePublisher = NotificationCenter.default.publisher(for: .newTrickDownloaded)
    .map { notification in
        return notification.userInfo?[""data""] as! Data
    }
</code></pre>

<p>That seems inadvisable. What happens if there's no <code>userInfo</code>, or it contains no <code>""data""</code> key, or it isn't a Data? We'll force-unwrap <code>nil</code> and crash. What's the best practice here?</p>
","341994","","341994","","2019-06-22 18:14:42","2019-06-22 18:14:42","Avoiding forced unwrapping in Swift Combine framework","<swift><option-type><ios13><combine>","1","6","","","","CC BY-SA 4.0"
"56724566","1","56911058","","2019-06-23 13:55:17","","48","9252","<p>When using new Combine framework you can specify the scheduler on which to receive elements from the publisher.</p>

<p>Is there a big difference between <code>RunLoop.main</code> and <code>DispatchQueue.main</code> in this case when assigning publisher to UI element? The first one returns the run loop of the main thread and the second queue associated with the main thread. </p>
","4386014","","","","","2022-02-21 17:17:03","RunLoop vs DispatchQueue as Scheduler","<swift><grand-central-dispatch><nsrunloop><combine>","5","0","19","","","CC BY-SA 4.0"
"56727451","1","56796398","","2019-06-23 20:21:37","","3","1847","<p>I was playing with Combine framework lately and was wondering if it is possible to create some smart extension to get text changes as Publisher.</p>

<p>Let's say I've got two UITextFields:</p>

<pre><code>firstTextField.textPub.sink {
    self.viewModel.first = $0
}

secondTextField.textPub.sink {
    self.viewModel.second = $0
}
</code></pre>

<p>where first and second variable is just `@Published var first/second: String = """"</p>

<pre><code>extension UITextField {
    var textPub: AnyPublisher&lt;String, Never&gt; {
        return NotificationCenter.default
            .publisher(for: UITextField.textDidChangeNotification)
            .map {
                guard let textField = $0.object as? UITextField else { return """" }
                return textField.text ?? """"
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>This doesn't work because I'm using shared instance of NotificationCenter so when I make any change to any of textFields it will propagate new value to both <code>sink</code> closures. Do you think is there any way to achieve something similar to <code>rx.text</code> available in RxSwift? I was thinking about using <code>addTarget</code> with closure but it would require using associated objects from Objective-C.</p>
","4386014","","","","","2020-03-08 15:58:36","Multiple UITextFields and textDidChangeNotification notification","<swift><uikit><combine>","2","0","","","","CC BY-SA 4.0"
"56731802","1","","","2019-06-24 07:34:08","","1","358","<p>""PassthroughSubject"" seems to be thread-unsafe. Please see the code below, I'm sending 100 values concurrently to a subscriber which only request <code>.max(5)</code>. Subscriber should only get 5 values I think, but it actually got more. Is this a bug or limitation?</p>

<pre class=""lang-swift prettyprint-override""><code>// Xcode11 beta2

var count = 0
let q = DispatchQueue(label: UUID().uuidString)
let g = DispatchGroup()

let subject = PassthroughSubject&lt;Int, Never&gt;()
let subscriber = AnySubscriber&lt;Int, Never&gt;(receiveSubscription: { (s) in
    s.request(.max(5))
}, receiveValue: { v in
    q.sync {
        count += 1
    }
    return .none
}, receiveCompletion: { c in
})
subject.subscribe(subscriber)

for i in 0..&lt;100 {
    DispatchQueue.global().async(group: g) {
        subject.send(i)
    }
}

g.wait()
print(""receive"", count)  // expected 5, but got more(7, 9...)
</code></pre>
","","user6683350","","user6683350","2019-06-24 07:55:30","2022-07-14 18:22:49","""PassthroughSubject"" seems to be thread-unsafe, is this a bug or limitation?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"56735382","1","58117295","","2019-06-24 11:14:40","","12","11745","<p>I'm trying to execute an action every time a <code>textField</code>'s value is changed.</p>

<pre><code>@Published var value: String = """"

var body: some View {            
     $value.sink { (val) in
        print(val)
     }
     return TextField($value)       
}
</code></pre>

<p>But I get below error.</p>

<blockquote>
  <p>Cannot convert value of type 'Published' to expected argument type 'Binding'</p>
</blockquote>
","10208552","","25122","","2019-06-24 21:44:09","2022-08-22 08:38:10","How to observe a TextField value with SwiftUI and Combine?","<ios><swiftui><combine>","6","0","2","","","CC BY-SA 4.0"
"56758110","1","","","2019-06-25 16:07:27","","2","260","<p>Swift 5, the ""Exclusive Access to Memory"" enforcement is now on by default for release builds as mentioned in this Swift.org blog post: </p>

<p><a href=""https://swift.org/blog/swift-5-exclusivity/"" rel=""nofollow noreferrer"">Swift 5 Exclusivity Enforcement</a></p>

<p>I understand the reasoning behind this feature, but with the new <code>Combine</code> framework I feel as if some very normal design patterns are now going to break and I'm curious how best to work around them. </p>

<p>With <code>Combine</code> it's natural for parts of your code to react to changes in a model such that they might need to read from the very property that the model has just changed. But they can no longer do that because it will trigger a memory exception as you attempt to read a value that is currently being set. </p>

<p>Consider the following example: </p>

<pre><code>struct PasswordProposal {
  let passwordPublisher = CurrentValueSubject&lt;String, Never&gt;(""1234"")
  let confirmPasswordPublisher = CurrentValueSubject&lt;String, Never&gt;(""1234"")

  var password:String {
    get { passwordPublisher.value }
    set { passwordPublisher.value = newValue }
  }

  var confirmPassword:String {
    get { confirmPasswordPublisher.value }
    set { confirmPasswordPublisher.value = newValue }
  }

  var isPasswordValid:Bool {
    password == confirmPassword &amp;&amp; !password.isEmpty
  }
}

class Coordinator {
  var proposal:PasswordProposal
  var subscription:Cancellable?

  init() {
    self.proposal = PasswordProposal()
    self.subscription = self.proposal.passwordPublisher.sink { [weak self] _ in
      print(self?.proposal.isPasswordValid ?? """")
    }
  }

  // Simulate changing the password to trigger the publisher.
  func changePassword() {
    proposal.password = ""7890""
  }
}

// --------------------------------

var vc = Coordinator()
vc.changePassword()
</code></pre>

<p>As soon as <code>changePassword()</code> is called, the mutual exclusivity enforcement will throw an exception because the property <code>password</code> will attempt to be read from while it's currently being written to. </p>

<p>Note that if you change this example to use a separate backing storage property instead of the <code>CurrentValueSubject</code> it causes the same exception. </p>

<p>However, if you change <code>PasswordProposal</code> from being a <code>struct</code> to a <code>class</code>, then the exception is no longer thrown. </p>

<p>When I consider how I might use <code>Combine</code> in an existing codebase, as well as in <code>SwiftUI</code>, I see this type of pattern coming up in a lot of places. In the old delegate model, it's quite common for a delegate to query the sending object from within a delegate callback. In Swift 5, I now have to be very careful that none of those callbacks potentially read from the property that initiated the notification. </p>

<p>Have others come across this and, if so, how have you addressed it? Apple has routinely suggested that we should be using <code>structs</code> where it makes sense but perhaps an object that has published properties is one of those areas where it doesn't? </p>
","48321","","","","","2019-06-26 12:12:24","Dealing with Swift 5 Exclusivity Enforcement when using Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"56762294","1","","","2019-06-25 21:32:23","","5","1590","<p>Most examples of showing <code>Alert</code> refer to some kind of <code>@State</code> being used as a binding that controls the <em>presented/hidden</em> state of the alert view.</p>
<p>As an example <code>showingAlert</code> (<a href=""https://www.hackingwithswift.com/quick-start/swiftui/how-to-show-an-alert"" rel=""nofollow noreferrer"">source</a>):</p>
<pre><code>struct ContentView : View {
    @State var showingAlert = false
    
    var body: some View {
        Button(action: {
            self.showingAlert = true
        }) {
            Text(&quot;Show Alert&quot;)
        }
        .alert(isPresented: $showingAlert) {
            Alert(
                title: Text(&quot;Important message&quot;),
                message: Text(&quot;Wear sunscreen&quot;),
                dismissButton: .default(Text(&quot;Got it!&quot;))
            )
        }
    }
}
</code></pre>
<p>It's a good solution when the alert is triggered from the UI layer - as in the example:</p>
<pre><code>Button(action: {
    self.showingAlert = true
}
</code></pre>
<p><strong>But what if we want to trigger it from the controller/viewmodel layer with a specific message?</strong> As an example, we make a network call - the <code>URLSession</code>’s <code>Publisher</code> can send <code>Data</code> or an <code>Error</code> that we want to push to the user as a message in the <code>Alert</code>.</p>
<p><code>@State</code> is designed to be managed from the view's <code>body</code>, so it seems that we should rather use an <code>@ObjectBinding</code> in this case. It seems that we also need some <code>message</code>, so we can reference it in the <code>body</code>:</p>
<pre><code>Alert(
    title: Text(&quot;Important message&quot;),
    message: Text(objectBinding.message)
)
</code></pre>
<p>The <code>showingAlert</code> would be a bit redundant here as we may define <code>message</code> as <code>String?</code> and create a binding for <code>presentation</code>:</p>
<pre><code>Binding&lt;Bool&gt;(
    getValue: { objectBinding.message != nil },
    setValue: { if !$0 { objectBinding.message = nil } }
)

</code></pre>
<p>It's a doable approach and it works, but two things are making me a bit anxious:</p>
<ol>
<li>The fact that <code>message</code> is managed by two abstractions</li>
<li>The information and management of the <em>presented/hidden</em> state of the alert leaked into controller/viewmodel/object binding. It'd be nice to keep the <em>presented/hidden</em> state privately in the view.</li>
<li>The fact that message is kept in the controller/viewmodel/object binding until it gets kind of &quot;consumed&quot; by the view (the binding).</li>
</ol>
<p><strong>Can it be done better?</strong></p>
","1041469","","1041469","","2020-07-05 11:04:05","2020-07-05 11:04:05","How to bind presentation of SwiftUI.Alert when triggered outside of the View?","<ios><swift><swiftui><ios13><combine>","1","3","","","","CC BY-SA 4.0"
"56765437","1","","","2019-06-26 04:56:45","","2","957","<p>I need to use picker and toggle and based on toggle value picker value needs to be changed.</p>

<p>I have tried to implement it but it shows toggle inside picker but I can't change picker value based on the toggle.</p>

<p>Here's what I have tried so far:</p>

<pre><code>    Picker(selection: $bluetooth.type, label: BluetoothContainer()){
            Toggle(isOn: self.$bluetooth.isBluetoothOn) {
            Text(""Bluetooth"")
        }

     }
</code></pre>
","10873771","","9284423","","2019-06-26 06:52:39","2019-06-27 04:39:23","How to use toggle inside picker in swiftui and also change picker value based on toggle","<ios><swift><swiftui><swift5><combine>","1","0","1","","","CC BY-SA 4.0"
"56773951","1","56774251","","2019-06-26 13:26:01","","14","3978","<p>i'm implementing a little app with new iOS framework SwiftUI. I'm using <code>@EnvironmentObject</code> to bind my data to view. All works, but the Canvas crash and not show nothing. Why?</p>

<pre><code>struct CompetitionsListSwiftUIView : View {

    @EnvironmentObject var competitionsViewModel: CompetitionsViewModel

    var body: some View {
        List(self.competitionsViewModel.competitions.identified(by: \.id)) { competition in
                CompetitionCellSwiftUIView(competition: competition)
            }
    }
}

#if DEBUG
struct CompetitionsListSwiftUIView_Previews : PreviewProvider {
    static var previews: some View {
        CompetitionsListSwiftUIView()
    }
}
#endif
</code></pre>

<p>The error message of the Canvas is this:</p>

<pre><code>Error Domain=render service Code=12 ""Rendering service was interrupted"" UserInfo={NSLocalizedDescription=Rendering service was interrupted}
</code></pre>
","6761616","","","","","2019-06-26 13:40:11","Crash on Canvas SwiftUI","<ios><swift><swiftui><combine>","1","0","3","","","CC BY-SA 4.0"
"56782078","1","56786412","","2019-06-26 23:22:22","","38","32432","<p>Using Apple's new Combine framework I want to make multiple requests from each element in a list. Then I want a single result from a reduction of all the the responses. Basically I want to go from list of publishers to a single publisher that holds a list of responses.</p>

<p>I've tried making a list of publishers, but I don't know how to reduce that list into a single publisher. And I've tried making a publisher containing a list but I can't flat map a list of publishers.</p>

<p>Please look at the ""createIngredients"" function </p>

<pre><code>func createIngredient(ingredient: Ingredient) -&gt; AnyPublisher&lt;CreateIngredientMutation.Data, Error&gt; {
    return apollo.performPub(mutation: CreateIngredientMutation(name: ingredient.name, optionalProduct: ingredient.productId, quantity: ingredient.quantity, unit: ingredient.unit))
            .eraseToAnyPublisher()
}

func createIngredients(ingredients: [Ingredient]) -&gt; AnyPublisher&lt;[CreateIngredientMutation.Data], Error&gt; {
    // first attempt
    let results = ingredients
            .map(createIngredient)
    // results = [AnyPublisher&lt;CreateIngredientMutation.Data, Error&gt;]

    // second attempt
    return Publishers.Just(ingredients)
            .eraseToAnyPublisher()
            .flatMap { (list: [Ingredient]) -&gt; Publisher&lt;[CreateIngredientMutation.Data], Error&gt; in
                return list.map(createIngredient) // [AnyPublisher&lt;CreateIngredientMutation.Data, Error&gt;]
            }
}
</code></pre>

<p>I'm not sure how to take an array of publishers and convert that to a publisher containing an array.</p>

<p>Result value of type '[AnyPublisher]' does not conform to closure result type 'Publisher'</p>
","10178157","","614065","","2020-01-31 11:10:06","2021-12-17 11:29:34","Swift Combine: How to create a single publisher from a list of publishers?","<swift><combine>","4","2","7","","","CC BY-SA 4.0"
"56823604","1","56826204","","2019-06-30 08:57:20","","1","2138","<p>I've got to two String publishers and one computed property which returns AnyPublisher. Logic is quite simple but I would like to know if there is any way to propagate initial value. I think it should be somehow possible since publishers have initial values.</p>

<p>In VC I'm assigning new values to Publishers from ViewModel (from textField).</p>

<pre><code>firstTextField.addTarget(self, action: #selector(firstTextFieldDidChange(_:)), for: .editingChanged)
secondTextField.addTarget(self, action: #selector(secondTextFieldDidChange(_:)), for: .editingChanged)

@objc private func firstTextFieldDidChange(_ textField: UITextField) {
 viewModel.firstPublisher = textField.text ?? """"
}
@objc private func secondTextFieldDidChange(_ textField: UITextField) {
 viewModel.secondPublisher = textField.text ?? """"
}
</code></pre>

<p>And then I'm assigning Publisher (combineLatest) to my button:</p>

<pre><code>_ = viewModel.validatedText
   .receive(on: RunLoop.main)
   .assign(to: \.isEnabled, on: button)
</code></pre>

<p>In VM I've got two Publishers:</p>

<pre><code>@Published var firstPublisher: String = """"
@Published var secondPublisher: String = """"
</code></pre>

<p>and CombineLatest:</p>

<pre><code>var validatedText: AnyPublisher&lt;Bool, Never&gt; {
    return Publishers.CombineLatest($firstPublisher, $secondPublisher) {
        return !($0.isEmpty || $1.isEmpty)
        }.eraseToAnyPublisher()
}
</code></pre>

<p>validatedText only starts publishing new values when I start typing in both text fields. I tried assigning some new values in init of VM for example (to first and second Publisher) but it also didn't work. Is there any way to do it or I will have to set initial state of button (disable it) without using combine?</p>
","4386014","","","","","2019-06-30 16:08:46","Triggering CombineLatest to propagate initial value in Combine","<swift><reactive-programming><combinelatest><combine>","1","0","","","","CC BY-SA 4.0"
"56827808","1","","","2019-06-30 20:22:36","","22","11240","<p>I'm trying to figure out the best way to build <strong>a simple settings screen bound to UserDefaults</strong>.</p>

<p>Basically, I have a Toggle and I want:</p>

<ul>
<li>the value a UserDefault to be saved any time this Toggle is changed (the UserDefault should be the source of truth)</li>
<li>the Toggle to always show the value of the UserDefault</li>
</ul>

<p><a href=""https://i.stack.imgur.com/uBDzp.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/uBDzp.png"" alt=""Settings screen with Toggle""></a></p>

<p>I have watched many of the SwiftUI WWDC sessions, but I'm still not sure exactly how I should set everything up with the different tools that are available within Combine and SwiftUI. My current thinking is that I should be using a BindableObject so I can use hat to encapsulate a number of different settings.</p>

<p>I think I am close, because it almost works as expected, but the behavior is inconsistent.</p>

<p>When I build and run this on a device, I open it and turn on the Toggle, then if I scroll the view up and down a little the switch toggles back off (as if it's not actually saving the value in UserDefaults).</p>

<p>However, if I turn on the switch, leave the app, and then come back later it is still on, like it remembered the setting.</p>

<p>Any suggestions? I'm posting this in hopes it will help other people who are new to SwiftUI and Combine, as I couldn't find any similar questions around this topic.</p>

<pre><code>import SwiftUI
import Combine

struct ContentView : View {

    @ObjectBinding var settingsStore = SettingsStore()

    var body: some View {
        NavigationView {
            Form {
                Toggle(isOn: $settingsStore.settingActivated) {
                    Text(""Setting Activated"")
                }
            }
        }.navigationBarTitle(Text(""Settings""))
    }
}

class SettingsStore: BindableObject {

    var didChange = NotificationCenter.default.publisher(for: .settingsUpdated).receive(on: RunLoop.main)

    var settingActivated: Bool {
        get {
            UserDefaults.settingActivated
        }
        set {
            UserDefaults.settingActivated = newValue
        }
    }
}

extension UserDefaults {

    private static var defaults: UserDefaults? {
        return UserDefaults.standard
    }

    private struct Keys {
        static let settingActivated = ""SettingActivated""
    }

    static var settingActivated: Bool {
        get {
            return defaults?.value(forKey: Keys.settingActivated) as? Bool ?? false
        }
        set {
            defaults?.setValue(newValue, forKey: Keys.settingActivated)
        }
    }
}

extension Notification.Name {
    public static let settingsUpdated = Notification.Name(""SettingsUpdated"")
}
</code></pre>
","241163","","","","","2022-01-19 13:30:22","UserDefaults Binding with Toggle in SwiftUI","<ios><swiftui><combine>","8","1","3","","","CC BY-SA 4.0"
"56841842","1","56842343","","2019-07-01 20:08:49","","1","6609","<p>I tried creating a list of custom classes in SwiftUI, but keep having problems with the UI updates. I made my class conform to <code>BindableObject</code> and it calls the <code>didChange.send()</code> function correctly when a property changes, but the change doesn't seem to get passed through to the array, as the view does not update, when I change a property of my custom class in the array.</p>

<p>Here is a basic example of what I mean:</p>

<pre class=""lang-swift prettyprint-override""><code>class Media: BindableObject, Identifiable {
    typealias PublisherType = PassthroughSubject&lt;Void, Never&gt;
    var didChange = PublisherType()

    var id: Int {
        didSet {
            didChange.send()
        }
    }
    var name: String {
        didSet {
            print(""Name changed from \(oldValue) to \(self.name)"")
            didChange.send()
        }
    }

    init(id: Int, name: String) {
        self.id = id
        self.name = name
    }
}

struct ContentView : View {
    @State private var media = [
        Media(id: 0, name: ""Name 0""),
        Media(id: 1, name: ""Name 1""),
        Media(id: 2, name: ""Name 2""),
        Media(id: 3, name: ""Name 3""),
    ]

    var body: some View {
        VStack {
            List(media) { media in
                Text(media.name)
            }
            HStack {
                Button(action: {
                    self.media.first!.name = ""Name \(Int.random(in: 100...199))""
                }) {
                    Text(""Change"")
                }
                Button(action: {
                    self.media.append(Media(id: 4, name: ""Name 4""))
                }) {
                    Text(""Add"")
                }
            }
        }
    }
}
</code></pre>

<p>When pressing the ""Change"" button, it just changes the name of the first media object in the array, which does not result in a re-rendering of the view. When I press the ""Add"" button, he adds an object to the array, therefore re-rendering the UI and also displaying the changed name of the first object (from pressing ""Change"").</p>

<p>Now my question is, if there is a way to link the publisher of <code>Media</code> to the publisher of <code>Array&lt;Media&gt;</code>, so that when the <code>Media</code> Publisher fires, the <code>Array&lt;Media&gt;</code> Publisher fires too and therefore causes the view to re-render.</p>

<p>When I move the <code>Text(media.name)</code> in a separate view (which holds the media as a <code>@State</code> property, it works as intended, as the subview itself request the re-render.</p>

<p>But assuming I don't want to use a custom view but just a simple <code>Text</code> view, is there any way to make this happen?</p>
","3426509","","","","","2019-11-14 03:37:46","Create a List with an array of custom classes in SwiftUI","<swift><list><swiftui><combine>","1","0","2","","","CC BY-SA 4.0"
"56871714","1","56890158","","2019-07-03 13:52:18","","4","1716","<p>I've got a strange crash in <strong>SwiftUI / Xcode 11 beta 3</strong> with code like the one below (I've kept only the bare minimum to show the behavior):</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

final class AppData: BindableObject  {
    let didChange = PassthroughSubject&lt;AppData, Never&gt;()

    init() { }
}

struct ContentView : View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: DetailView() ) {
                Text(""link"")
            }
        }
    }
}

struct DetailView : View {
    @EnvironmentObject var appData: AppData
//  @ObjectBinding var appData = AppData() -&gt; Works 

    var body: some View {
        List {
            Text(""A"")
            Text(""B"")
            Text(""C"")
        }
    }
}

</code></pre>

<p>The <code>BindableObject</code> is injected in <code>SceneDelegate.swift</code> like this:</p>

<pre class=""lang-swift prettyprint-override""><code>....
        // Use a UIHostingController as window root view controller
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: ContentView()
                                           .environmentObject(AppData()))
            self.window = window
            window.makeKeyAndVisible()
        }
....
</code></pre>

<p>When following the <code>NavigationLink</code> it crashes with </p>

<p><code>Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</code></p>

<p>If I remove the <code>List</code> view from the detail view it works OK. The same if I use <code>@ObjectBinding</code> instead (like in the commented line in my code).</p>

<p>The same code used to work in previous betas. </p>
","554203","","1033581","","2019-07-05 02:04:26","2019-07-05 02:04:26","Xcode 11 beta 3 crashing when using NavigationLink, @EnvironmentObject and List together","<swiftui><xcode11><combine>","2","3","1","","","CC BY-SA 4.0"
"56874689","1","56875265","","2019-07-03 16:41:26","","4","2649","<p>I would like to wrap a simple callback so that it would be able to be used as a Combine <code>Publisher</code>. Specifically the <a href=""https://developer.apple.com/documentation/coredata/nspersistentcontainer/1640568-loadpersistentstores"" rel=""nofollow noreferrer"">NSPersistentContainer.loadPersistentStore</a> callback so I can publish when the container is ready to go.</p>

<pre class=""lang-swift prettyprint-override""><code>func createPersistentContainer(name: String) -&gt; AnyPublisher&lt;NSPersistentContainer, Error&gt; {
  // What goes here?
  // Happy path: send output NSPersistentContainer; send completion.
  // Not happy path: send failure Error; send completion.
}
</code></pre>

<p>For instance, what would the internals of a function, <code>createPersistentContainer</code> given above, look like to enable me to do something like this in my <code>AppDelegate</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>final class AppDelegate: UIResponder, UIApplicationDelegate {

  let container = createPersistentContainer(name: ""DeadlyBattery"")
    .assertNoFailure()
    .eraseToAnyPublisher()

  // ...

}
</code></pre>

<p>Mostly this boils down to, how do you wrap a callback in a <code>Publisher</code>?</p>
","247730","","","","","2020-07-28 14:05:30","Make a Publisher from a callback","<swift><combine>","3","0","","","","CC BY-SA 4.0"
"56879734","1","57453172","","2019-07-04 01:56:23","","12","4547","<p>I want to use a <code>@State</code> variable both for the UI and for computing a value.</p>

<p>For example, let's say I have a <code>TextField</code> bound to <code>@State var userInputURL: String = ""https://""</code>. How would I take that <code>userInputURL</code> and connect it to a publisher so I can <code>map</code> it into a <code>URL</code>.</p>

<p>Pseudo code:</p>

<pre class=""lang-swift prettyprint-override""><code>$userInputURL.publisher()
      .compactMap({ URL(string: $0) })
      .flatMap({ URLSession(configuration: .ephemeral).dataTaskPublisher(for: $0).assertNoFailure() })
      .eraseToAnyPublisher()
</code></pre>
","247730","","228600","","2019-07-31 12:35:46","2022-06-26 15:58:58","Convert a @State into a Publisher","<swift><swiftui><combine>","4","0","3","","","CC BY-SA 4.0"
"56892346","1","56895248","","2019-07-04 17:34:44","","3","654","<p>When launching my app on an iPad running the iOS 13 beta 2 build I receive a SIGABRT. This build works fine on the simulator</p>

<p><code>dyld: Symbol not found: _$s7Combine6FutureCyxq_GAA9PublisherAAMc</code>
<code>Expected in: /System/Library/Frameworks/Combine.framework/Combine</code></p>

<p>I thought maybe it was a linking problem, but Combine does not appear in the list of libraries available to link.</p>

<p>Does anyone have a work around or am I sunk until the next beta?</p>

<hr>

<p>Here is my code snippet:</p>

<pre><code>class ViewController: UIViewController {

    var future: AnyPublisher&lt;String, Error&gt;?

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        future = ViewController.makeNumberString(50)
        future?.sink { result in
            print(""FUTURE DONE: \(result)"")
        }
    }

    static func makeNumberString(_ number: Int) -&gt; AnyPublisher&lt;String, Error&gt; {
        return Combine.Future&lt;Int, Error&gt; { complete in
            DispatchQueue.global(qos: .userInitiated).async {
                complete(.success(number))
            }
        }
        .map { number in
            return ""\(number)""
        }
        .eraseToAnyPublisher()
    }
}
</code></pre>
","5171701","","1000551","","2019-12-07 10:01:50","2019-12-07 10:01:50","iOS 13 Public Beta 2 - Combine.Future ""dyld: Symbol not found""","<ios><swift><beta><combine>","2","2","","","","CC BY-SA 4.0"
"56893835","1","","","2019-07-04 20:14:46","","1","1713","<p>I currently have a publisher with the type of <code>AnyPublisher&lt;[MyClass], Error&gt;</code> to which I'm attempting to attach a subscriber and capture the resulting <code>AnyCancelable</code>. Xcode's autocomplete says I should be able to do this, but when the code is actually entered, I encounter a compiler error saying that the returned type isn't <code>AnyCancelable</code>, but <code>()</code></p>

<p>Here's an example of my code:</p>

<pre><code>let networkController = NetworkController()
let viewState = MyViewState()

let publisher: AnyPublisher&lt;[MyClass], Error&gt; = networkController.createPublisher()
let cancelable: AnyCancellable = publisher.subscribe(viewState)
Cannot convert value of type '()' to specified type 'AnyCancellable'
</code></pre>

<p>My goal here is to wrap an existing async function, which could be called numerous times, in the Combine Framework, so that I can have a nice way of having the request get canceled when it's reassigned, like so:</p>

<pre><code>... self.cancelable = cancelable
</code></pre>
","4686915","","4686915","","2019-07-05 16:56:07","2019-07-05 17:10:19","Subscribe returning Void instead of AnyCancelable","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"56910228","1","57473649","","2019-07-05 23:52:57","","5","8324","<p>I am trying to replicate the ""Wizard School Signup""-example which was given in the WWDC 2019 session ""Combine in Practice"" <a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""noreferrer"">https://developer.apple.com/videos/play/wwdc2019/721/</a> starting at 22:50 using SwiftUI (as opposed to UIKit, which was used during the session).</p>

<p>I have created all the publishers from the example: validatedEMail, validatedPassword and validatedCredentials. While validatedEMail and validatedPassword work just fine, validatedCredentials, which consumes both publishers using CombineLatest, never fires</p>

<pre class=""lang-swift prettyprint-override""><code>//
//  RegistrationView.swift
//
//  Created by Lars Sonchocky-Helldorf on 04.07.19.
//  Copyright © 2019 Lars Sonchocky-Helldorf. All rights reserved.
//

import SwiftUI
import Combine

struct RegistrationView : View {
    @ObjectBinding var registrationModel = RegistrationModel()

    @State private var showAlert = false
    @State private var alertTitle: String = """"
    @State private var alertMessage: String = """"

    @State private var registrationButtonDisabled = true

    @State private var validatedEMail: String = """"
    @State private var validatedPassword: String = """"

    var body: some View {
        Form {
            Section {
                TextField(""Enter your EMail"", text: $registrationModel.eMail)
                SecureField(""Enter a Password"", text: $registrationModel.password)
                SecureField(""Enter the Password again"", text: $registrationModel.passwordRepeat)
                Button(action: registrationButtonAction) {
                    Text(""Create Account"")
                }
                .disabled($registrationButtonDisabled.value)
                    .presentation($showAlert) {
                        Alert(title: Text(""\(alertTitle)""), message: Text(""\(alertMessage)""))
                }
                .onReceive(self.registrationModel.validatedCredentials) { newValidatedCredentials in
                    self.registrationButtonDisabled = (newValidatedCredentials == nil)
                }
            }

            Section {
                Text(""Validated EMail: \(validatedEMail)"")
                    .onReceive(self.registrationModel.validatedEMail) { newValidatedEMail in
                        self.validatedEMail = newValidatedEMail != nil ? newValidatedEMail! : ""EMail invalid""
                }
                Text(""Validated Password: \(validatedPassword)"")
                    .onReceive(self.registrationModel.validatedPassword) { newValidatedPassword in
                        self.validatedPassword = newValidatedPassword != nil ? newValidatedPassword! : ""Passwords to short or don't matchst""
                }
            }
        }
        .navigationBarTitle(Text(""Sign Up""))
    }

    func registrationButtonAction() {
        let trimmedEMail: String = self.registrationModel.eMail.trimmingCharacters(in: .whitespaces)

        if (trimmedEMail != """" &amp;&amp; self.registrationModel.password != """") {
            NetworkManager.sharedInstance.registerUser(NetworkManager.RegisterRequest(uid: trimmedEMail, password: self.registrationModel.password)) { (status) in
                if status == 200 {
                    self.showAlert = true
                    self.alertTitle = NSLocalizedString(""Registration successful"", comment: """")
                    self.alertMessage = NSLocalizedString(""please verify your email and login"", comment: """")
                } else if status == 400 {
                    self.showAlert = true
                    self.alertTitle = NSLocalizedString(""Registration Error"", comment: """")
                    self.alertMessage = NSLocalizedString(""already registered"", comment: """")
                } else {
                    self.showAlert = true
                    self.alertTitle = NSLocalizedString(""Registration Error"", comment: """")
                    self.alertMessage = NSLocalizedString(""network or app error"", comment: """")
                }
            }
        } else {
            self.showAlert = true
            self.alertTitle = NSLocalizedString(""Registration Error"", comment: """")
            self.alertMessage = NSLocalizedString(""username / password empty"", comment: """")
        }
    }
}

class RegistrationModel : BindableObject {
    @Published var eMail: String = """"
    @Published var password: String = """"
    @Published var passwordRepeat: String = """"

    public var didChange = PassthroughSubject&lt;Void, Never&gt;()

    var validatedEMail: AnyPublisher&lt;String?, Never&gt; {
        return $eMail
            .debounce(for: 0.5, scheduler: RunLoop.main)
            .removeDuplicates()
            .flatMap { username in
                return Future { promise in
                    self.usernameAvailable(username) { available in
                        promise(.success(available ? username : nil))
                    }
                }
        }
        .eraseToAnyPublisher()
    }

    var validatedPassword: AnyPublisher&lt;String?, Never&gt; {
        return Publishers.CombineLatest($password, $passwordRepeat)
            .debounce(for: 0.5, scheduler: RunLoop.main)
            .map { password, passwordRepeat in
                guard password == passwordRepeat, password.count &gt; 5 else { return nil }
                return password
        }
        .eraseToAnyPublisher()
    }

    var validatedCredentials: AnyPublisher&lt;(String, String)?, Never&gt; {
        return Publishers.CombineLatest(validatedEMail, validatedPassword)
            .map { validatedEMail, validatedPassword in
                guard let eMail = validatedEMail, let password = validatedPassword else { return nil }
                return (eMail, password)
        }
        .eraseToAnyPublisher()
    }


    func usernameAvailable(_ username: String, completion: (Bool) -&gt; Void) {
        let isValidEMailAddress: Bool = NSPredicate(format:""SELF MATCHES %@"", ""[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"").evaluate(with: username)

        completion(isValidEMailAddress)
    }
}

#if DEBUG
struct RegistrationView_Previews : PreviewProvider {
    static var previews: some View {
        RegistrationView()
    }
}
#endif
</code></pre>

<p>I expected the form button to get enabled when a valid username (valid E-Mail-address) and two matching passwords with the right length are provided. The two Publishers responsible for those two tasks work, I can see the validatedEMail and the validatedPassword in the user interface in the two Texts which I added for debugging purposes.</p>

<p>Just the third Publisher (also compare to the code shown in the Video from above at 32:20) never fires. I did set breakpoints in those Publishers, in the validatedPassword Publisher at line:</p>

<pre class=""lang-swift prettyprint-override""><code>guard password == passwordRepeat, password.count &gt; 5 else { return nil }
</code></pre>

<p>which stopped there just fine but a similar breakpoint in the validatedCredentials Publisher at line:</p>

<pre class=""lang-swift prettyprint-override""><code>guard let eMail = validatedEMail, let password = validatedPassword else { return nil }
</code></pre>

<p>was never reached.</p>

<p>What did I do wrong?</p>

<p><strong>Edit:</strong></p>

<p>In order to make the above code run under Xcode-beta 11.0 beta 4 <code>didChange</code> needs to be replaced with <code>willChange</code></p>
","2960387","","2960387","","2019-07-23 09:23:53","2019-09-02 09:35:52","Swift Combine: subsequent Publisher that consumes other Publishers (using CombineLatest) doesn't ""fire""","<swift><swiftui><ios13><combine>","3","0","3","","","CC BY-SA 4.0"
"56918286","1","","","2019-07-06 23:22:27","","4","2770","<p>Struggling with some combine problems I came across the ""Working with Multiple Subscribers"" section in <a href=""https://developer.apple.com/documentation/combine/publisher"" rel=""noreferrer"">https://developer.apple.com/documentation/combine/publisher</a> :</p>

<pre class=""lang-swift prettyprint-override""><code>func multicast&lt;S&gt;(() -&gt; S) -&gt; Publishers.Multicast&lt;Self, S&gt;

func multicast&lt;S&gt;(subject: S) -&gt; Publishers.Multicast&lt;Self, S&gt;
</code></pre>

<p>However, when I tried to confirm my assumption that multicast would be needed when sending to multiple subscribers, I found out this is not necessary when trying on this playground code (modified from <a href=""https://github.com/AvdLee/CombineSwiftPlayground/blob/master/Combine.playground/Pages/Combining%20Publishers.xcplaygroundpage/Contents.swift"" rel=""noreferrer"">https://github.com/AvdLee/CombineSwiftPlayground/blob/master/Combine.playground/Pages/Combining%20Publishers.xcplaygroundpage/Contents.swift</a> ) (run on 10.14.5 in Xcode Version 11.0 beta 3 (11M362v)):</p>

<pre class=""lang-swift prettyprint-override""><code>enum FormError: Error { }

let usernamePublisher = PassthroughSubject&lt;String, FormError&gt;()
let passwordPublisher = PassthroughSubject&lt;String, FormError&gt;()

let validatedCredentials = Publishers.CombineLatest(usernamePublisher, passwordPublisher)
    .map { (username, password) -&gt; (String, String) in
        return (username, password)
    }
    .map { (username, password) -&gt; Bool in
        !username.isEmpty &amp;&amp; !password.isEmpty &amp;&amp; password.count &gt; 12
    }
    .eraseToAnyPublisher()

let firstSubscriber = validatedCredentials.sink { (valid) in
    print(""First Subscriber: CombineLatest: Are the credentials valid: \(valid)"")
}

let secondSubscriber = validatedCredentials.sink { (valid) in
    print(""Second Subscriber: CombineLatest: Are the credentials valid: \(valid)"")
}

// Nothing will be printed yet as `CombineLatest` requires both publishers to have send at least one value.
usernamePublisher.send(""avanderlee"")
passwordPublisher.send(""weakpass"")
passwordPublisher.send(""verystrongpassword"")
</code></pre>

<p>This prints:</p>

<pre><code>First Subscriber: CombineLatest: Are the credentials valid: false
Second Subscriber: CombineLatest: Are the credentials valid: false
First Subscriber: CombineLatest: Are the credentials valid: true
Second Subscriber: CombineLatest: Are the credentials valid: true
</code></pre>

<p>so it seems that no multicast is needed to address multiple subscribers. Or I am wrong? </p>

<p>So, what are those multicast functions for and how would I use them? Some example code would be nice.</p>

<p>Thanks,</p>

<p>Lars</p>
","2960387","","","","","2019-12-17 02:25:08","Swift Combine: What are those multicast functions for and how do I use them?","<swift><ios13><combine><macos-catalina>","2","0","1","","","CC BY-SA 4.0"
"56927197","1","","","2019-07-08 00:50:00","","7","2117","<p>I am building a simple settings screen.</p>

<p>When then first setting is activated, the Speed Control appears. When it's turned off, the Speed Control disappears.</p>

<p>Based on what I know about SwiftUI, this should automatically animate based on the code below, but instead it just appears and disappears.</p>

<p>How can I make this animation nicer with SwiftUI, so it slides down from the cell above it, like in <a href=""https://developer.apple.com/videos/play/wwdc2019/216/"" rel=""noreferrer"">this presentation</a> at 53:00?</p>

<p><a href=""https://i.stack.imgur.com/7qYJJ.gif"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/7qYJJ.gif"" alt=""GIF of setting animation""></a></p>

<pre><code>import SwiftUI
import Combine

struct ContentView : View {

    @ObjectBinding var settingsStore: SettingsStore

    var body: some View {
        NavigationView {
            Form {
                Toggle(isOn: $settingsStore.settingActivated.animation(.basic(duration: 3, curve: .easeInOut))) {
                    Text(""Setting Activated"")
                }
                if settingsStore.settingActivated {
                    VStack(alignment: .leading) {
                        Text(""Speed Control"")
                        HStack {
                            Image(systemName: ""tortoise"")
                            Slider(value: .constant(10), from: 0, through: 50, by: 1)
                            Image(systemName: ""hare"")
                        }
                    }.transition(.opacity)
                }
            }.navigationBarTitle(Text(""Settings""))
        }
    }
}

class SettingsStore: BindableObject {

    let didChange = PassthroughSubject&lt;Void, Never&gt;()

    var settingActivated: Bool = UserDefaults.settingActivated {
        didSet {

            UserDefaults.settingActivated = settingActivated

            didChange.send()
        }
    }
}

extension UserDefaults {

    private struct Keys {
        static let settingActivated = ""SettingActivated""
    }

    static var settingActivated: Bool {
        get {
            return UserDefaults.standard.bool(forKey: Keys.settingActivated)
        }
        set {
            UserDefaults.standard.set(newValue, forKey: Keys.settingActivated)
        }
    }
}
</code></pre>
","241163","","","","","2019-07-08 00:50:00","Animation on Toggle Change with SwiftUI","<ios><swiftui><combine>","0","2","2","","","CC BY-SA 4.0"
"56937872","1","","","2019-07-08 15:11:02","","1","1115","<p>When I tried to use SwiftUI &amp; Combine to download image asynchrously, it works fine. Then, I try to implement this into a dynamic list, and I found out there is only one row(the last row) will be show correctly, images in other cells are missing. I have trace the code with breakpoints and I'm sure the image download process is success in others, but only the last row will trigger the @ObjectBinding to update image. Please check my sample code and let me know if there's any wrong. Thanks!</p>

<pre class=""lang-swift prettyprint-override""><code>struct UserView: View {
    var name: String
    @ObjectBinding var loader: ImageLoader

    init(name: String, loader: ImageLoader) {
        self.name = name
        self.loader = loader
    }

    var body: some View {
        HStack {
            Image(uiImage: loader.image ?? UIImage())
                .onAppear {
                    self.loader.load()
            }
            Text(""\(name)"")
        }
    }
}

struct User {
    let name: String
    let imageUrl: String
}

struct ContentView : View {
    @State var users: [User] = []
    var body: some View {
        NavigationView {
            List(users.identified(by: \.name)) { user in
                UserView(name: user.name, loader: ImageLoader(with: user.imageUrl))
            }
            .navigationBarTitle(Text(""Users""))
            .navigationBarItems(trailing:
                Button(action: {
                    self.didTapAddButton()
                }, label: {
                    Text(""+"").font(.system(size: 36.0))
                }))
        }
    }

    func didTapAddButton() {
        fetchUser()
    }

    func fetchUser() {
        API.fetchData { (user) in
            self.users.append(user)
        }
    }
}

class ImageLoader: BindableObject {

    let didChange = PassthroughSubject&lt;UIImage?, Never&gt;()

    var urlString: String
    var task: URLSessionDataTask?
    var image: UIImage? = UIImage(named: ""user"") {
        didSet {
            didChange.send(image)
        }
    }

    init(with urlString: String) {
        print(""init a new loader"")
        self.urlString = urlString
    }

    func load() {
        let url = URL(string: urlString)!
        let task = URLSession.shared.dataTask(with: url) { (data, _, error) in
            if error == nil {
                DispatchQueue.main.async {
                    self.image = UIImage(data: data!)
                }
            }
        }
        task.resume()
        self.task = task
    }

    func cancel() {
        if let task = task {
            task.cancel()
        }
    }
}

class API {
    static func fetchData(completion: @escaping (User) -&gt; Void) {
        let request = URLRequest(url: URL(string: ""https://randomuser.me/api/"")!)
        let task = URLSession.shared.dataTask(with: request) { (data, _, error) in
            guard error == nil else { return }

            do {
                let json = try JSONSerialization.jsonObject(with: data!, options: []) as? [String: Any]
                guard
                    let results = json![""results""] as? [[String: Any]],
                    let nameDict = results.first![""name""] as? [String: String],
                    let pictureDict = results.first![""picture""] as? [String: String]
                    else { return }

                let name = ""\(nameDict[""last""]!) \(nameDict[""first""]!)""
                let imageUrl = pictureDict[""thumbnail""]
                let user = User(name: name, imageUrl: imageUrl!)
                DispatchQueue.main.async {
                    completion(user)
                }
            } catch let error {
                print(error.localizedDescription)
            }
        }
        task.resume()
    }
}

</code></pre>

<p>every images should be downloaded successfully no matter how many items in the list.</p>
","7820992","","7820992","","2019-07-08 15:17:14","2019-07-10 14:49:59","SwiftUI and Combine not working smoothly when downloading image asynchrously","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"56947312","1","57173681","","2019-07-09 07:23:45","","5","1408","<p>With the arrival of combine framework, is there a need to use operation queues anymore. For example, apple uses operation queues almost all over the place in WWDC app. So if we use SwiftUI with combine(asynchronous programming), will there be a need to use Operation Queues?</p>
","3972195","","","","","2019-07-24 00:37:54","Using operation queues with combine framework","<nsoperationqueue><swiftui><combine>","1","2","2","2020-10-31 11:39:40","","CC BY-SA 4.0"
"56958539","1","56959721","","2019-07-09 18:20:48","","3","2740","<p>I'm working on rewriting my Hacker News reader to use Combine more heavily. I'm have two functions which both return an <code>AnyPublisher</code>, one of them get's the ids of a bunch of HN stories from the server and the other one fetches a story by it's id. I'm not sure how I could loop over the results of <code>fetchStoryIds</code>, run <code>fetchStory</code> with the id and end up with an array of <code>Story</code> objects with Combine.</p>

<pre><code>import Combine
import Foundation

struct HackerNewsService {
    private var session = URLSession(configuration: .default)
    static private var baseURL = ""https://hacker-news.firebaseio.com/v0""

    private func fetchStoryIds(feed: FeedType) -&gt; AnyPublisher&lt;[Int], Error&gt; {
       let url = URL(string: ""\(HackerNewsService.baseURL)/\(feed.rawValue.lowercased())stories.json"")!

        return session.dataTaskPublisher(for: url)
            .retry(1)
            .map { $0.data }
            .decode(type: [Int].self, decoder: JSONDecoder())
            .eraseToAnyPublisher()
    }

    private func fetchStory(id: Int) -&gt; AnyPublisher&lt;Story, Error&gt; {
        let url = URL(string: ""\(HackerNewsService.baseURL)/item/\(id).json"")!

        return session.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: Story.self, decoder: JSONDecoder())
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>Before I started the rewrite, I used this code to loop over the ids and get the stories.</p>

<pre><code>func fetchStories(feed: FeedType, completionHandler: @escaping ([Story]?, Error?) -&gt; Void) {
        fetchStoryIds(feed: feed) { (ids, error) in
            guard error == nil else {
                completionHandler(nil, error)
                return
            }

            guard let ids = ids else {
                completionHandler(nil, error)
                return
            }

            let dispatchGroup = DispatchGroup()

            var stories = [Story]()

            for id in ids {
                dispatchGroup.enter()

                self.fetchStory(id: id) { (story, error) in
                    guard error == nil else {
                        dispatchGroup.leave()
                        return
                    }

                    guard let story = story else {
                        dispatchGroup.leave()
                        return
                    }

                    stories.append(story)

                    dispatchGroup.leave()
                }
            }

            dispatchGroup.notify(queue: .main) {
                completionHandler(stories, nil)
            }
        }
    }
}
</code></pre>
","","user7885981","1226963","","2019-07-09 18:21:41","2019-07-09 20:00:58","How can I loop over the output of a publisher with Combine?","<swift><combine>","1","6","","","","CC BY-SA 4.0"
"56980589","1","","","2019-07-11 01:42:07","","3","1660","<p>I've got a PassthroughSubject that send 30 integers followed by a finish message. </p>

<p>Upon receiving these numbers from the subject, I spawn off a future that sleeps for one second, and completes with the input number * 2.</p>

<p>I use .receiveOn to make sure the futures run concurrently, but this means the finish message also propagates concurrently through the chain
and ends the sink before all futures are finished. </p>

<p>Any RxSwift/Combine wizards out there know how I can make it so the reception of the finish message is delayed by the futures completing?</p>

<p>Here is a playground that implements the described behavior:</p>

<pre><code>import Foundation
import Combine
import PlaygroundSupport

/// Setting up the playground
PlaygroundPage.current.needsIndefiniteExecution = true

/// Injects numbers 0-30 into combine message stream, and then sends a finish.
func publishNumbers(to subject: PassthroughSubject&lt;Int, Error&gt;) {
    (0..&lt;30).forEach {
        subject.send($0)
    }
    subject.send(completion: .finished)
}
/// Delays for one secont, and completes the future by doubling the input.
func delayAndDoubleNumber(_ int: Int) -&gt; Future&lt;Int, Error&gt; {
    return Future&lt;Int, Error&gt; { complete in
        sleep(1)
        complete(.success(int * 2))
    }
}

// Properties involved in Combine processing chain.
let numbersSubject = PassthroughSubject&lt;Int, Error&gt;()
let processingQueue = DispatchQueue.global(qos: .userInitiated)


// Combine processing chain
numbersSubject
    .receive(on: processingQueue) //Comment this line to observe that all futures finish, and are collected before the finish message kills the sink.
    .flatMap { number in
        return delayAndDoubleNumber(number)
    }
    .collect(4)
    .sink(receiveCompletion: { completion in
        print(""Complete: \(completion)"")
    }, receiveValue: { value in
        print(""Received Value: \(value)"")
    })

publishNumbers(to: numbersSubject)

</code></pre>
","5171701","","","","","2019-07-11 22:30:37","How can I prevent a PassthroughSubject from killing a .sink before concurrent upstream futures finish?","<swift><ios13><combine>","2","0","","","","CC BY-SA 4.0"
"56998702","1","57022803","","2019-07-12 00:02:20","","5","4030","<p>I'd like to create a repeat functionality that creates a loop in my code using Combine. I noticed that Combine does not have a repeat publisher via this great repo: <a href=""https://github.com/freak4pc/rxswift-to-combine-cheatsheet"" rel=""noreferrer"">https://github.com/freak4pc/rxswift-to-combine-cheatsheet</a>. Heres the code that I wrote that works to repeat 2 states. How do I reduce this to something more readable or create my own repeat function?</p>

<pre><code>toggleShouldDisplay = Just&lt;Void&gt;(())
  .delay(for: 2, scheduler:RunLoop.main)
  .map({ _ in
    self.shouldDisplay = true
    self.didChange.send(())
  })
  .delay(for: 2, scheduler: RunLoop.main)
  .map({ _ in
    self.shouldDisplay = false
    self.didChange.send(())
  })
  .setFailureType(to: NSError.self)
  .tryMap({ _ in
    throw NSError()
  })
  .retry(.max) // I might hit Int.max if I reduce the delays
  .sink(receiveValue: { _ in
    //Left empty
  })
</code></pre>
","283460","","","","","2019-07-18 11:57:47","Swift Combine .repeat","<swift><reactive-programming><combine>","2","0","","","","CC BY-SA 4.0"
"57008251","1","57010239","","2019-07-12 13:44:45","","0","1077","<p>Description: </p>

<p>I have a model that has the following hierarchy:</p>

<ul>
<li><strong>Recipe</strong>   </li>
<li>...steps (an array)</li>
<li>...<strong>currentStep</strong></li>
<li>......<strong>parameters (an array)</strong></li>
<li>.........minimum</li>
<li>.........maximum</li>
<li>.........default</li>
<li>.........<strong>current</strong></li>
</ul>

<p>The model works well. I can add steps, parameters, and set the current step to an <code>@EnvironmentObject</code> called <code>recipe</code>. </p>

<p>I've created a sample project <a href=""https://github.com/justdfd/ListBug"" rel=""nofollow noreferrer"">here</a> with I two lists of steps and parameters, along with three buttons to add a single step among three hard-coded ones, each containing an array of 0, 1, or 3 parameters.</p>

<p>The top list is the step rows, each being a button to populate the bottom list. The bottom list is the parameter list, each containing a label and a slider in a <code>VStack</code>.</p>

<p>All works fine, except when i am (a) binding the slider to my model <strong>and</strong> (b) the list contains more sliders (row) than the current step now has. I get an <code>index out of range error</code>. </p>

<p>If I bind the slider value to a local variable, it all works. Here's the relevant code:</p>

<pre><code>class Recipe: BindableObject {
    var didChange = PassthroughSubject&lt;Void, Never&gt;()
    var currentStep = Step() {
        didSet {
            didChange.send(())
        }
    }
}

struct Parameter: Identifiable {
    var id:Int = 0
    var name = """"
    var minimum:Float = 0
    var maximum:Float = 100
    var `default`:Float = 30
    var current:Float = 30
}

struct StepRow: View {
    @EnvironmentObject var recipe: Recipe
    var step: Step!

    init(step: Step) {
        self.step = step
    }
    var body: some View {
        Button(action: {
            self.setCurrentStep()
        }) {
            HStack {
                Text(step.name).font(Font.body.weight(.bold))
            }.frame(height: 50)
        }
    }
    func setCurrentStep() {
        recipe.currentStep = step
    }
}
struct ParameterRow: View {
    @EnvironmentObject var recipe: Recipe
    @State var sliderValue:Float = 30
    var parameter: Parameter!

    init(parameter: Parameter) {
        self.parameter = parameter
    }

    var body: some View {
        VStack {
            Text(parameter.name)
            Slider(

                // This works, swap these two lines to duplicate the index out of range error by:
                // - Adding step 1, step 2, step 3, and finally step 4
                // - Tapping each step in the step list in order, the first three will work but the last one won't

                //value: $recipe.currentStep.parameters[parameter.id].current,
                value: self.$sliderValue,

                from: parameter.minimum,
                through: parameter.maximum,
                by: 1.0
            )
        }
    }
}
struct ContentView : View {
    @EnvironmentObject var recipe: Recipe
    var body: some View {
        VStack {
            List {
                ForEach(recipe.steps) { step in
                    StepRow(step: step)
                }
            }
            List {
                ForEach(recipe.currentStep.parameters) { parameter in
                    ParameterRow(parameter: parameter)
                }
            }
        }
    }
}
</code></pre>

<p>Again, a working example of this is project <a href=""https://github.com/justdfd/ListBug"" rel=""nofollow noreferrer"">here</a>.</p>
","","user7014451","","user7014451","2019-07-12 16:56:05","2019-07-12 17:16:22","Index out of range when binding a Slider value to a nested array in EnvironmentObject","<swiftui><combine>","1","7","1","","","CC BY-SA 4.0"
"57010544","1","","","2019-07-12 16:07:24","","4","6714","<p>iOS13's Combine streams of publishers don't appear to be flowing after operator using schedulers.</p>

<p>Here's my code:</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

struct MyPublisher: Publisher {
    typealias Output = Int
    typealias Failure = Error

    func receive&lt;S&gt;(subscriber: S) where S : Subscriber,
        Failure == S.Failure,
        Output == S.Input {
            subscriber.receive(1)
            print(""called 1"")
            subscriber.receive(2)
            print(""called 2"")
            subscriber.receive(completion: .finished)
            print(""called finish"")
    }
}

MyPublisher()
//    .receive(on: RunLoop.main) // If this line removed, it will be fine.
//    .throttle(for: .milliseconds(1000), scheduler: RunLoop.main, latest: false)) // If this line removed, it will be fine.
//    .debounce(for: .milliseconds(1000), scheduler: RunLoop.main)) // If this line removed, it will be fine.
//    .delay(for: .milliseconds(1000), scheduler: DispatchQueue.main)) // If this line removed, it will be fine.
    .print()
    .sink(receiveCompletion: { completion in
        switch completion {
        case .finished:
            print(""finished"")
        case .failure(let error):
            print(""error:\(error)"")
        }
    }, receiveValue: { num in
        print(""\(num)"")
    })
</code></pre>

<p>I expected output to be</p>

<pre><code>1
2
finished
</code></pre>

<p>but the actual output is nothing.</p>

<p>If I don't use <code>receive</code> or <code>throttle</code> or <code>debounce</code> or <code>delay</code>. The output will be fine.</p>

<p>Is it a bug or something wrong with my code?</p>

<p>I tried with Playground (Xcode 11 beta3).</p>
","5658829","","","","","2021-01-07 22:31:45","iOS13's Combine streams don't flow after operator using schedulers","<swift><ios13><combine>","2","0","","","","CC BY-SA 4.0"
"57029093","1","","","2019-07-14 16:15:08","","1","2434","<p>I have a data manager that encapsulates a collection of objects. I want to listen to changes in that manager, as well as changes in collection objects. I came up with the solution using <code>PassthroughSubject</code> and <code>sink</code>, but I am pretty new to Combine and wondering is it correct and is there a better way to do that.</p>

<pre><code>import Combine

class Item {
  var data = false {
    didSet {
      self.subject.send()
    }
  }
  let subject = PassthroughSubject&lt;Void, Never&gt;()

}

class DataManager {
  private(set) var items = [Item]() {
    didSet {
      self.subject.send()
    }
  }
  let subject = PassthroughSubject&lt;Void, Never&gt;()

  func addItem(_ item: Item) {
    self.items.append(item)
    item.subject.sink { [weak self] in
      self?.subject.send()
    }
  }
}

var item = Item()
var manager = DataManager()
manager.subject.sink {
  print(""Received Update"")
}
manager.addItem(item) // Received Update
item.data = false // Received Update
item.data = true // Received Update    
</code></pre>
","2894363","","2894363","","2019-07-15 14:36:25","2019-09-30 07:58:38","Combine: Listen to internal collection changes","<ios><swift><swiftui><combine>","2","1","1","","","CC BY-SA 4.0"
"57031248","1","57141857","","2019-07-14 21:23:53","","3","1362","<p>I'm currently playing with Combine and SwiftUI and have built a prototype app using the MVVM pattern. The app utilises a timer and the state of the button controlling this is bound (inelegantly) to the view model utilising a PassThroughSubject.</p>

<p>When the button is pressed, this should toggle the value of a state variable; the value of this is passed to the view model's subject (using .send) which should send a single event per button press. However, there appears to be recursion or something equally weird going on as multiple events are sent to the subject and a runtime crash results without the UI ever being updated.</p>

<p>It's all a bit puzzling and I'm not sure if this is a bug in Combine or I've missed something. Any pointers would be much appreciated. Code below - I know it's messy ;-) I've trimmed it down to what appears to be relevant but let me know if you need more.</p>

<p>View:</p>

<pre><code>struct ControlPanelView : View {
    @State private var isTimerRunning = false
    @ObjectBinding var viewModel: ControlPanelViewModel

    var body: some View {
        HStack {
            Text(""Case ID"") // replace with binding to viewmode

            Spacer()
            Text(""00:00:00"") // repalce with binding to viewmodel

            Button(action: {
                self.isTimerRunning.toggle()
                self.viewModel.apply(.isTimerRunning(self.isTimerRunning))
                print(""Button press"")
            }) {
                isTimerRunning ? Image(systemName: ""stop"") : Image(systemName: ""play"")
            }

        }
//            .onAppear(perform: { self.viewModel.apply(.isTimerRunning(self.isTimerRunning)) })
            .font(.title)
            .padding(EdgeInsets(top: 0, leading: 32, bottom: 0, trailing: 32))
    }
}
</code></pre>

<p>Viewmodel:</p>

<pre><code>final class ControlPanelViewModel: BindableObject, UnidirectionalDataType {

    typealias InputType = Input
    typealias OutputType = Output

    private let didChangeSubject = PassthroughSubject&lt;Void, Never&gt;()
    private var cancellables: [AnyCancellable] = []

    let didChange: AnyPublisher&lt;Void, Never&gt;

    // MARK:- Input
...
    private let isTimerRunningSubject = PassthroughSubject&lt;Bool, Never&gt;()
....


    enum Input {
...
        case isTimerRunning(Bool)
...
    }
    func apply(_ input: Input) {
        switch input {
...
        case .isTimerRunning(let state): isTimerRunningSubject.send(state)
...
        }
    }

    // MARK:- Output
    struct Output {
        var isTimerRunning = false
        var elapsedTime = TimeInterval(0)
        var concernId = """"
    }
    private(set) var output = Output() {
        didSet { didChangeSubject.send() }
    }

    // MARK:- Lifecycle
    init(timerService: TimerService = TimerService()) { 
        self.timerService = timerService

        didChange = didChangeSubject.eraseToAnyPublisher()

        bindInput()
        bindOutput()
    }

    private func bindInput() {
        utilities.debugSubject(subject: isTimerRunningSubject)

        let timerToggleStream = isTimerRunningSubject
            .subscribe(isTimerRunningSubject)

...

        cancellables += [
            timerToggleStream,
            elapsedTimeStream,
            concernIdStream
        ]
    }

    private func bindOutput() {
        let timerToggleStream = isTimerRunningSubject
            .assign(to: \.output.isTimerRunning, on: self)
...
        cancellables += [
            timerToggleStream,
            elapsedTimeStream,
            idStream
        ]

    }

}
</code></pre>
","2733214","","","","","2019-07-22 08:25:35","Unexpected events emitted by Swift Combine PassThroughSubject","<swift><swiftui><combine>","2","3","0","","","CC BY-SA 4.0"
"57054916","1","57055111","","2019-07-16 10:11:35","","1","3306","<p>I'm testing the Combine framework and using BindableObject as a notification hub for passing data among several views in a SwiftUI ContentView.</p>

<p>One of the views is a table. I click on a row and the value is detected in the print checkpoint, so the bindableobject receives the update.</p>

<p>Problem is, the new string is not broadcasted to the receiving end on the ContentView. </p>

<p>I'm new to this.</p>

<p>View controller with a table view .swift (broadcaster):</p>

<pre><code>import SwiftUI
import Combine

final public class NewestString: BindableObject {

    public var didChange = PassthroughSubject&lt;NewestString, Never&gt;()

    var newstring: String {
        didSet {
            didChange.send(self)
            print(""Newstring: \(newstring)"") //&lt;-- Change detected
        }
    }

    init(newstring: String) {
        self.newstring = newstring
    }

    public func update() {
        didChange.send(self)
        print(""--Newstring: \(newstring)"")

    }

}



final class AViewController: UIViewController {

    @IBOutlet weak var someTableView: UITableView!
    var returnData = NewestString(newstring:""--"")

    override func viewDidLoad() {
        super.viewDidLoad()

    }

}

/// [.....] More extensions here

extension AViewController: UITableViewDelegate {

    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
        let completion = someResults[indexPath.row]

    //// [......] More code here

        self.returnData.newstring = ""Test string"" //&lt;--- change caused 
        }
    }
}

</code></pre>

<p>Main content View (broadcast destination):</p>

<pre><code>import SwiftUI
import Combine

struct PrimaryButton: View {
    var title: String = ""DefaultTitle""
    var body: some View {
        Button(action: { print(""tapped"") }) {
            Text(title)
        }
   }

}


struct MyMiniView: View {
    @State var aTitle: String = ""InitialView""
    var body: some View {
        VStack{
            PrimaryButton(title: aTitle)
            }
    }
}


struct ContentView: View {

    @State private var selection = 0
    @ObjectBinding var desiredString: NewestString = NewestString(newstring: ""Elegir destino"") // &lt;-- Expected receiver

    var body: some View {

        TabbedView(selection: $selection){

            ZStack() {

                MyMiniView(aTitle: self.desiredString.newstring ?? ""--"")
               // expected end use of the change, that never happens
[...]
}

struct AView: UIViewControllerRepresentable {

    typealias UIViewControllerType = AViewController


    func makeUIViewController(context: UIViewControllerRepresentableContext&lt;AView&gt;) -&gt; AViewController {


        return UIStoryboard(name: ""MyStoryboard"", bundle: nil).instantiateViewController(identifier: String(describing: AViewController.self)) as! AViewController

    }

    func updateUIViewController(_ uiViewController: AViewController, context: UIViewControllerRepresentableContext&lt;AView&gt;) {
        //
    }


</code></pre>

<p>It compiles, runs and prints the change, but no update happens to the MyMiniView's PrimaryButton.</p>
","11780343","","11780343","","2019-07-16 13:50:13","2019-07-17 09:03:15","SwiftUI ObjectBinding won't receive didchange update from bindable object using combine","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"57100026","1","57113930","","2019-07-18 17:42:17","","2","1714","<p>I have a service file which gets and sends data to a backend. Is it possible to push push data from the service to a View and let the UI get the changes(not like a global var) like with a @State.</p>

<p>@EnviornmentObject isn't working read only
Global vars are not working because the don't inform the UI</p>

<pre><code>import SwiftUI
import SocketIO
import Combine

let manager = SocketManager(socketURL: URL(string: ""http://localhost:30000/ios"")!, config: [.log(true), .compress])
let socket = manager.defaultSocket

class Socket: BindableObject {
    let didChange = PassthroughSubject&lt;Socket,Never&gt;()
    var sliderValue: Float = 6 {
        willSet {
            print(newValue)
            didChange.send(self)
        }
    }
    static let sharedInstance = Socket()
    init() {

        socket.on(clientEvent: .connect) {data, ack in
            print(""socket connected"")
            self.sliderValue = 8 
        }

    }


    func establishConnection() {
        socket.connect()
    }

    func closeConnection() {
        socket.disconnect()
    }
}
</code></pre>

<p>HomeView:</p>

<pre><code>import SwiftUI

struct HomeView : View {
    @EnvironmentObject var socketData: Socket

    var body: some View {
        VStack {
            Text(""Hello World"")
            Slider(value: $socketData.sliderValue, from: 0.0, through: 10.0)
            Text(String(socketData.sliderValue))
        }
    }
}
</code></pre>
","9381064","","9381064","","2019-07-19 05:13:55","2019-07-31 16:36:22","Is it possible to have a Service in SwiftUI and push data to a View and update the UI?","<swift><service><websocket><swiftui><combine>","2","6","1","","","CC BY-SA 4.0"
"57105699","1","57105830","","2019-07-19 04:48:05","","8","2161","<p>The new Xcode 11 beta 4 has removed <code>Publishers.Once</code> struct from the Combine framework. What is the alternative?</p>

<p><code>Just</code> seems the likely candidate, however, it cannot be used for returning a publisher in methods with return type <code>AnyPublisher&lt;Bool, Error&gt;</code> as the associated <code>Failure</code> type for <code>Just</code> <a href=""https://developer.apple.com/documentation/combine/just/failure"" rel=""noreferrer"">is <code>Never</code>.</a></p>

<p>For example in the following method, I could return a <code>Publishers.Once</code> since the associated <code>Failure</code> type wasn't <code>Never</code>.</p>

<pre><code>func startSignIn() -&gt; AnyPublisher&lt;Void, Error&gt; {
    if authentication.provider == .apple { 
        let request = ASAuthorizationAppleIDProvider().createRequest()
        request.requestedScopes = [.email, .fullName]

        let controller = ASAuthorizationController(authorizationRequests: [request])
        controller.delegate = self
        controller.performRequests()

        return Publishers.Once(()).eraseToAnyPublisher()
    } else {
        return SignInManager.service.startSignIn(auth: authentication)
            .map { (auth) -&gt; Void in
                self.authentication = auth
        }.eraseToAnyPublisher()
    }
}
</code></pre>

<p>But now when I change it back to <code>Just</code> I get a compile error complaining that <code>Just</code> cannot be returned since the method should return a publisher with an associated <code>Failure</code> type.</p>

<pre><code>func startSignIn() -&gt; AnyPublisher&lt;Void, Error&gt; {
    if authentication.provider == .apple { 
        let request = ASAuthorizationAppleIDProvider().createRequest()
        request.requestedScopes = [.email, .fullName]

        let controller = ASAuthorizationController(authorizationRequests: [request])
        controller.delegate = self
        controller.performRequests()

        return Just(()).eraseToAnyPublisher() //Error Here
    } else {
        return SignInManager.service.startSignIn(auth: authentication)
            .map { (auth) -&gt; Void in
                self.authentication = auth
        }.eraseToAnyPublisher()
    }
}
</code></pre>

<p>Isn't there any alternative to <code>Publishers.Once</code> which can also have associated failure types? </p>
","2603900","","2603900","","2019-07-19 04:53:08","2019-11-09 04:29:59","What’s the alternative for 'Publishers.Once'?","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"57127878","1","57128303","","2019-07-20 19:23:17","","11","6037","<p>I have a simple master/detail interface where the detail view modifies an item in an array. Using the below, the model is updated properly, but SwiftUI doesn't refresh the View to reflect the change.</p>

<p>Model:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ProduceItem: Identifiable {
    let id = UUID()
    let name: String
    var inventory: Int
}

final class ItemStore: BindableObject {
    var willChange = PassthroughSubject&lt;Void, Never&gt;()

    var items: [ProduceItem] { willSet { willChange.send() } }

    init(_ items: [ProduceItem]) {
        self.items = items
    }
}
</code></pre>

<p>Master view that displays a list of ProduceItems (an ItemStore is inserted into the environment in the SceneDelegate):</p>

<pre class=""lang-swift prettyprint-override""><code>struct ItemList: View {
    @EnvironmentObject var itemStore: ItemStore

    var body: some View {
        NavigationView {
            List(itemStore.items.indices) { index in
                NavigationLink(destination: ItemDetail(item: self.$itemStore.items[index])) {
                    VStack(alignment: .leading) {
                        Text(self.itemStore.items[index].name)
                        Text(""\(self.itemStore.items[index].inventory)"")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .navigationBarTitle(""Items"")
        }
    }
}
</code></pre>

<p>Detail view that lets you change the inventory value of an item:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ItemDetail: View {
    @Binding var item: ProduceItem

    var body: some View {
        NavigationView {
            Stepper(value: $item.inventory) {
                Text(""Inventory is \(item.inventory)"")
            }
            .padding()
            .navigationBarTitle(item.name)
        }
    }
}
</code></pre>

<p>Tapping on the stepper in the ItemDetail view modifies the item in the store, but the text of the stepper doesn't change. Navigating back to the list confirms the model has been changed. Also, I confirmed that the store calls <code>willChange.send()</code> to its publisher. I would assume that the <code>send()</code> call updates the ItemStore in the environment and the detail view's <code>@Binding</code> property should be notified of the change and refresh the display (but it doesn't).</p>

<p>I tried changing ItemDetail's item property to use <code>@State</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>@State var item: ProduceItem = ProduceItem(name: ""Plums"", inventory: 7)
</code></pre>

<p>In this case, the model is item is updated when using the stepper and the view is refreshed, displaying the updated inventory. Can anyone explain why using the <code>@Binding</code> property doesn't refresh the interface, but a local <code>@State</code> property does?</p>
","3791229","","2598316","","2019-07-20 20:57:38","2019-07-20 20:57:38","SwiftUI @Binding doesn't refresh View","<swiftui><combine>","1","3","3","","","CC BY-SA 4.0"
"57133806","1","57134190","","2019-07-21 13:49:35","","6","9340","<p>I have a <code>SwiftUI</code> native Watch app I Am working on. I have a <code>Combine</code> based class that allows me to store `\userDefaults, one of which is a simple toggle.</p>

<pre><code>import SwiftUI  
import Foundation  
import Combine  


class MeetingSetup: BindableObject {  

    let willChange = PassthroughSubject&lt;Void, Never&gt;()  

    var twitterEnabled: Bool = false {  
        didSet {  
            willChange.send()  
        }  
    }  

    init() {  
        let prefs:UserDefaults = UserDefaults(suiteName: ""group.com.appname"")!  
        twitterEnabled = prefs.bool(forKey: ""keyTwitterEnabledBool"")  
    }  
} 
</code></pre>

<p>In the <code>SwiftUI</code> I am getting the error messages that <code>Bool</code> is not convertible to <code>Binding&lt;Bool&gt;</code></p>

<pre><code>import SwiftUI  
import Combine  

struct SetupView : View {  

    @ObjectBinding var meetingSetup: MeetingSetup = delegate.meetingSetup  

    var body: some View {  

                HStack{  
                    Toggle(isOn: self.meetingSetup.twitterEnabled){  // &lt;== 'Bool' in not convertible to 'Binding&lt;Bool&gt;'  
                        Text(""Twitter"")  
                    }  
    }  
} 
</code></pre>

<p>I don't understand why this is getting the message since the code is <code>@ObjectBinding</code>, should it not be <code>Binding&lt;Bool&gt;</code> by definition?  If not how do I address this correctly??</p>
","373749","","10151808","","2019-07-21 17:15:59","2019-07-21 17:15:59","'Bool' is not convertible to 'Binding<Bool>' in SwiftUI","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"57140530","1","57141285","","2019-07-22 06:51:33","","13","13409","<p>as the title suggests, I'm trying to pass data from one child view (A), to another child view (B) through the parent view (P).</p>

<p>The parent view looks like this:</p>

<pre><code>@State var rectFrame: CGRect = .zero 

var body: some View {
    childViewA(rectFrame: $rectFrame)
    childViewB()
}
</code></pre>

<p>where <code>childViewA</code> obtains a <code>CGRect</code> that <code>childViewB</code> needs.</p>

<p><code>childViewA</code> looks like this:</p>

<pre><code>@Binding var rectFrame: CGRect

var body: some View {
    // Very long code where rectFrame is obtained and printed to console correctly
}
</code></pre>

<p>How do I pass <code>rectFrame</code> to <code>childViewB</code>? Everything I've tried so far returns <code>CGRect.zero</code> in <code>childViewB</code> despite printing the correct values in both the <code>parentView</code> and <code>childViewA</code>.</p>

<p>In order to try and pass the value to <code>childViewB</code>, I've rewritten <code>parentView</code> like this:</p>

<pre><code>@State var rectFrame: CGRect = .zero 

var body: some View {
    childViewA(rectFrame: $rectFrame)
    childViewB(rectFrame: $rectFrame.value)
}
</code></pre>

<p>with <code>childViewB</code> having the following structure:</p>

<pre><code>var rectFrame: CGRect = CGRect.zero

var body: some View {

}
</code></pre>

<p>But that just prints <code>CGRect.zero</code> every time.</p>

<p>I've recently tried <code>@ObjectBinding</code> but I've struggled with it, so if anyone could help me out with this specific example, I'd be very grateful.</p>

<pre><code>class SourceRectBindings: BindableObject {
    let willChange = PassthroughSubject&lt;Void, Never&gt;()

    var sourceRect: CGRect = .zero {
        willSet {
            willChange.send()
        }
    }
}
</code></pre>
","4283749","","4283749","","2019-07-22 07:04:28","2021-09-23 20:26:03","How do I pass data from a child view to a parent view to another child view in SwiftUI?","<swiftui><combine>","4","4","8","","","CC BY-SA 4.0"
"57152031","1","57152088","","2019-07-22 18:44:44","","0","143","<p>I have a class that fetches the user's current location, and I want to be able to pass the most-recently fetched <code>CLLocation</code> or an <code>Error</code> to a <code>SwiftUI</code> <code>View</code>.</p>

<p>Below is the class that is responsible for location-fetching:</p>

<pre class=""lang-swift prettyprint-override""><code>class LocationProvider: NSObject, BindableObject, CLLocationManagerDelegate {

    // MARK: - BindableObject

    var willChange = PassthroughSubject&lt;CLLocation, Error&gt;()

    // MARK: - CLLocationManagerDelegate

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        willChange.send(location)
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        willChange.send(completion: .failure(.unknown))
    }

}
</code></pre>

<p>I get the following compilation error: <code>Type 'LocationProvider' does not conform to protocol 'BindableObject'</code> when I use <code>Error</code> as the failure type. However, if I change <code>Error</code> to <code>Never</code>, then the file compiles successfully.</p>

<p>What do I need to change so that I can pass a <code>CLLocation</code> or an <code>Error</code>?</p>
","3720634","","1000551","","2019-12-07 10:01:12","2019-12-07 10:01:12","Apple Combine's PassthroughSubject not Compiling","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"57153221","1","57172058","","2019-07-22 20:22:30","","14","7531","<p>I use an OAuth framework which creates authenticated requests asynchronously like so:</p>

<pre><code>OAuthSession.current.makeAuthenticatedRequest(request: myURLRequest) { (result: Result&lt;URLRequest, OAuthError&gt;) in
            switch result {
            case .success(let request):
                URLSession.shared.dataTask(with: request) { (data, response, error) in
                    // ...
                }
             // ...
             }
        }
</code></pre>

<p>I am trying to make my OAuth framework use Combine, so I know have a Publisher version of the <code>makeAuthenticatedRequest</code> method i.e.:</p>

<pre><code>public func makeAuthenticatedRequest(request: URLRequest) -&gt; AnyPublisher&lt;URLRequest, OAuthError&gt;
</code></pre>

<p>I am trying to use this to replace the call site above like so:</p>

<pre><code>OAuthSession.current.makeAuthenticatedRequestPublisher(request)
    .tryMap(URLSession.shared.dataTaskPublisher(for:))
    .tryMap { (data, _) in data } // Problem is here
    .decode(type: A.self, decoder: decoder)
</code></pre>

<p>As noted above, the problem is on turning the result of the publisher into a new publisher. How can I go about doing this?</p>
","801860","","","","","2019-07-23 20:54:10","Combine turn one Publisher into another","<ios><swift><combine>","1","0","5","","","CC BY-SA 4.0"
"57168609","1","57365773","","2019-07-23 16:32:00","","5","5246","<p>I am new to Swift and even more so to SwiftUI. I started to create a little basic project. I use Github API to fetch repositories list. </p>

<p>So I created a ""Search Bar"" like since SwiftUI doesn't have a SearchBar component. I would like to perform the fetch operation everytime my Textfield content is changed. </p>

<p>I don't want the fetch method to be called too often. I decided to debounce it. I'm facing a problem, I don't find/understand example. </p>

<p>I tried to implement a debounce solution but it doesn't work, my application just crash. </p>

<p>Here's my BindableObject</p>

<pre><code>import SwiftUI
import Combine

class ReposStore: BindableObject {

    private var service: GithubService

    let didChange = PassthroughSubject&lt;Void, Never&gt;()

    @Published var searchText: String = """"

    var repos: [Repository] = [] {
        didSet {
            didChange.send()
        }
    }

    var error: String = """" {
        didSet {
            didChange.send()
        }
    }

    var test: String = """" {
        didSet {
            didChange.send()
        }
    }

    private var cancellable: AnyCancellable? = nil

    init(service: GithubService) {
        self.service = service


        cancellable = AnyCancellable($searchText
            .removeDuplicates()
            .debounce(for: 2, scheduler: DispatchQueue.main)
            .flatMap { self.fetch(matching: $0) }
            .assign(to: \.test, on: self)
        )
    }

    func fetch(matching query: String = """") {
        print(""### QUERY \(query)"")
        self.service.getUserRepositories(matching: query) { [weak self] result in
            DispatchQueue.main.async {
                print(""### RESULT HERE \(result)"")
                switch result {
                case .success(let repos): self?.repos = repos
                case .failure(let error): self?.error = error.localizedDescription
                }
            }
        }
    }
}
</code></pre>

<p>And this is my View</p>

<pre><code>import SwiftUI

struct RepositoryList : View {
    @EnvironmentObject var repoStore: ReposStore
    @State private var userName: String = """"

    var body: some View {

        VStack {
            NavigationView {
                VStack(spacing: 0) {

                    HStack {
                        Image(systemName: ""magnifyingglass"").background(Color.blue).padding(.leading, 10.0)
                        TextField($repoStore.repoUser, placeholder: Text(""Search"")).background(Color.red)
                            .padding(.vertical, 4.0)
                            .padding(.trailing, 10.0)
                    }
                    .border(Color.secondary, width: 1, cornerRadius: 5)
                        .padding()

                    List {
                        ForEach(self.repoStore.repos) { repository in
                            NavigationLink(
                                destination: RepositoryDetail(repository: repository).environmentObject(self.repoStore)
                            ) {
                                RepositoryRow(repository: repository)
                            }
                        }

                    }.navigationBarTitle(Text(""Repositories""))
                }
            }
        }
    }
</code></pre>

<p>I tried to use a Timer and schedule and action every 8 seconds but this method cause my application to crash. </p>

<p>More, I don't really know if it's a good practice to declare a function with ""@objc"" annotation ... </p>

<p>Could someone help me to implement a correct way to debounce a method inside a BindableObject ? </p>

<p>Thank you in advance :)</p>
","7215553","","7215553","","2019-07-24 16:17:24","2019-08-05 20:34:57","Debounce method call from BindableObject in SwiftUI","<swift><swiftui><combine>","1","6","4","","","CC BY-SA 4.0"
"57168931","1","","","2019-07-23 16:53:06","","19","7139","<p>Our application supports iOS 11 and higher. In iOS 13 we use <code>SwiftUI</code> + <code>Combine</code></p>

<p>we wrap import of <code>SwiftUI</code> or <code>Combine</code> framework with correspondent check <code>#if canImport(SwiftUI)</code> or <code>#if canImport(Combine)</code>. If we run our app from Xcode 11 under iOS 12 we have error <code>dyld: Library not loaded: /System/Library/Frameworks/Combine.framework/Combine</code></p>

<p>We fixed same issue for SwiftUI by linking it optionally.</p>

<p><a href=""https://i.stack.imgur.com/h9dFA.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/h9dFA.png"" alt=""enter image description here""></a></p>

<p>But we can't make same for Combine as it can not be even selected for linking</p>

<p><a href=""https://i.stack.imgur.com/3Omze.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/3Omze.png"" alt=""enter image description here""></a></p>
","2035054","","2035054","","2019-07-24 13:07:20","2020-02-12 23:19:09","Optional linking for Swift Combine.framework in Xcode 11","<swiftui><xcode11><ios13><combine>","4","3","3","","","CC BY-SA 4.0"
"57199922","1","57201744","","2019-07-25 10:33:46","","23","19368","<p>I've been watching the <a href=""https://developer.apple.com/videos/play/wwdc2019/226/"" rel=""noreferrer"">Data Flow Through SwiftUI WWDC talk</a>. They have a slide with a sample code where they use a Timer publisher that gets connected to a SwiftUI View, and updates the UI with the time.</p>

<p>I'm working on some code where I want to do the exact same thing, but can't figure out how this <code>PodcastPlayer.currentTimePublisher</code> is implemented, and then hooked to the UI struct. I have also watched all the videos about Combine.</p>

<p>How can I achieve this?</p>

<p>The sample code:</p>

<pre><code>struct PlayerView : View {
  let episode: Episode
  @State private var isPlaying: Bool = true
  @State private var currentTime: TimeInterval = 0.0

  var body: some View {
    VStack { // ...
      Text(""\(playhead, formatter: currentTimeFormatter)"")
    }
    .onReceive(PodcastPlayer.currentTimePublisher) { newCurrentTime in
      self.currentTime = newCurrentTime
    }
  }
}
</code></pre>
","901034","","13302","","2019-07-28 07:02:34","2022-04-16 11:07:45","Create a Timer Publisher using Swift Combine","<swift><swiftui><publisher><combine>","5","0","8","","","CC BY-SA 4.0"
"57222005","1","","","2019-07-26 14:22:01","","2","536","<p>I am trying to use Combine to update a colour when my red, green or blue variables change. The examples I have looked at use sink() and that seems appropriate for me but eraseToAnySubscriber is MIA and I can't find an alternate. </p>

<p>What seems to work is to use an assign() to a computed variable but that seems like a bit of a hack.</p>

<pre class=""lang-swift prettyprint-override""><code>
init() {
        redCancellable = red.hasChanged.receive(on: RunLoop.main).assign(to: \.rgbUpdated, on: self)
    }
</code></pre>

<p>Is there any way to save the value returned by sink()?</p>
","5432972","","100297","","2019-07-27 02:22:50","2019-07-27 19:00:05","Swift Combine: Alternatives too eraseToAnySubscriber?","<swift><subscriber><combine>","1","0","","","","CC BY-SA 4.0"
"57236625","1","","","2019-07-27 22:49:10","","2","134","<p><strong>Environment:</strong> Xcode Version 11.0 beta 4 (11M374r)
<p>
I'm unable to share the 'environment' with a second view.</p>

<p><p>
I've instantiate the environment BindableObject in the SceneDelegate:</p>

<p><p>
SceneDelegate.swift:
<a href=""https://i.stack.imgur.com/PeT1K.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PeT1K.png"" alt=""enter image description here""></a></p>

<p><p>
I'm using @EnvironmentObject in both the base (ContentView) and the detail view.<br>
<p>
The environment has already been set up in the SceneDelegate so it should be available to all views.
<p>
The ContentView does see the environment. <br/>
But DetailView blows up:
<a href=""https://i.stack.imgur.com/ESZTG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ESZTG.png"" alt=""enter image description here""></a></p>

<p><p>
Here's the complete code:</p>

<pre><code>import Combine
import SwiftUI

struct UserInfo {
    var name: String
    var message: String
    init(name: String, msg: String) {
        self.name = name; self.message = msg
    }
}

// A BindableObject is always a class; NOT a struct.
class UserSettings: BindableObject {
    let willChange = PassthroughSubject&lt;Void, Never&gt;()
    var userInfo = UserInfo(name: ""Ric"", msg: ""Mother had a feeling, I might be too appealing."") {
        didSet {
            willChange.send()
        }
    }
}

// =====================================================================================================

struct DetailView: View {
    @Binding var dismissFlag: Bool
    @EnvironmentObject var settings: UserSettings  // ...&lt;error source&gt;

    var body: some View {
        VStack {
            Spacer()
            Button(action: dismiss) {
                Text(""Dismiss"")
                    .foregroundColor(.white)
            }
            .padding()
            .background(Color.green)
            .cornerRadius(10)
            .shadow(radius: 10)

            Text(""Hello"")
            Spacer()
        }
    }

    private func dismiss() {
        settings.userInfo.message = ""Rubber baby buggy bumpers.""
        dismissFlag = false
    }
}

// ---------------------------------------------------------------------------
// Base View:

struct ContentView: View {
    @State var shown = false
    @EnvironmentObject var settings: UserSettings

    var body: some View {
        VStack {
            Spacer()
            Button(action: {
                self.settings.userInfo.name = ""Troglodyte""
                self.settings.userInfo.message = ""Top Secret""
                self.shown.toggle()
            }) {
                Text(""Present"")
                    .foregroundColor(.white)
            }.sheet(isPresented: $shown) { DetailView(dismissFlag: self.$shown) }
                .padding()
                .background(Color.red)
                .cornerRadius(10)
                .shadow(radius: 10)
            Text(self.settings.userInfo.message)
            Spacer()
        }
    }
}

// =====================================================================================================

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#endif
</code></pre>

<p><p>
What am I missing? <br/>
What am I doing wrong?</p>

<p><p>
<hr/>
Revision per suggestion:</p>

<pre><code>import SwiftUI
import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    var window: UIWindow?
    var userSettings = UserSettings()

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

        // Use a UIHostingController as window root view controller
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: ContentView().environmentObject(userSettings))
            self.window = window
            window.makeKeyAndVisible()
        }
    }
}
</code></pre>

<p>His the runtime-error message after modifying the SceneDelegate:</p>

<p><p>
<a href=""https://i.stack.imgur.com/y9eV8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/y9eV8.png"" alt=""enter image description here""></a>
<p>
<hr/>
Here's a clue:
<a href=""https://i.stack.imgur.com/XfYTF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XfYTF.png"" alt=""enter image description here""></a></p>
","715747","","715747","","2019-07-28 19:54:15","2019-07-28 20:55:28","Unable to share environment between Views","<swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"57270850","1","57272955","","2019-07-30 11:42:30","","17","10335","<p>In the following code ""Test"" should be printed in the console when the Button is pressed, but it's not. The event is not send through the publisher.
Any idea what happened with PassthroughSubject in Xcode 11 Beta 5 ?
(in Xcode 11 Beta 4 it works well)</p>

<pre><code>var body: some View {  

    let publisher = PassthroughSubject&lt;String, Never&gt;()

    publisher.sink { (str) in  
        print(str)  
    }  
    return Button(""OK"") {  
        publisher.send(""Test"")  
    }  
}
</code></pre>

<p>P.S. I know there are other ways to print a string when a button is pressed, I just wanna show a simple send-receive example</p>
","10208552","","7786555","","2019-07-30 12:55:12","2019-11-09 09:37:52",".send() and .sink() do not seem to work anymore for PassthroughSubject in Xcode 11 Beta 5","<swiftui><combine>","2","0","6","","","CC BY-SA 4.0"
"57275156","1","57325015","","2019-07-30 15:25:36","","3","623","<p>I had a <code>@Published</code> variable to indicate my user state in one of my repository classes.</p>

<pre class=""lang-swift prettyprint-override""><code>@Published public var state: UserState = .initial
</code></pre>

<p>In testing, I used <code>sink</code> to easily observe the changes and fullfill the expectation my test was waiting for.</p>

<p>The original test code looked like this:</p>

<pre class=""lang-swift prettyprint-override""><code>sub = Authentication.shared.$state.receive(on: DispatchQueue.main).sink(receiveValue: { state in
    expectation.fulfill()
})
Authentication.shared.login(with: Credentials(email: ""gujci@gmail.com"", password: ""asdasd""))
</code></pre>

<p>Which resulted in a compiler error like the following <code>Abort trap: 6</code></p>

<pre><code>Global is external, but doesn't have external or weak linkage!
i64* @""$s14TestRepository14AuthenticationC6_state33_B23F0E9C543FDF10733C02EF2F1E18CCLL7Combine9PublishedVyAA9UserStateOGvpWvd""
&lt;unknown&gt;:0: error: fatal error encountered during compilation; please file a bug report with your project and the crash log
&lt;unknown&gt;:0: note: Broken module found, compilation aborted!
Stack dump:
...
</code></pre>

<p>The project where this occurs is in a separate swift package than the application.</p>

<p>When I have tried to use it from the application (no from tests) the result was the same. Also, I have tried other publishers eg. <code>Just</code> and <code>Future</code> returning from the network calls, all of them worked fine with <code>sink</code>.</p>

<p>I had this issue since beta 4, but never tried in previous ones, might be present in those as well. I have noticed there were huge changes for Combine between beta 4 and 5, yet, the error persists.</p>

<p>Has anybody managed to use the <code>sink</code> function on a <code>@Published</code> variable from an external library without such errors?</p>

<p>If I have misinterpreted something, please correct me, for now I have to assume, the problem is at Apple's end.</p>
","3308103","","","","","2019-08-02 10:50:13","Xcode 11 beta 5 Abort trap: 6 error when calling sink on @Published variable","<swift><beta><xcode11><combine>","1","0","1","","","CC BY-SA 4.0"
"57289462","1","57300762","","2019-07-31 11:13:31","","3","4500","<p>So, I want to have a <code>Text</code> that changes its content based on the contents of my CoreData Model. To do that I used a computed property in Xcode beta 4 but it doesn't seem to work anymore. Either that's a bug or there is some other issue I don't see?</p>

<p>The problem I have exactly is that my View (and the computed property) don't seem to get updated when <code>self.objectWillChange.send()</code> is called in my store.</p>

<p>I also tried to 'export' my var into the store and get it from there, with the same result...</p>

<hr>

<p><strong>EDIT:</strong>
I just tried the same with another class and it didn't work with just <code>objectWillChange.send()</code> but only with <code>@Published</code> however, even that stopped working if the class inherited from NSObject...</p>

<hr>

<p>I just found out: with </p>

<pre class=""lang-swift prettyprint-override""><code>struct Today: View {
    @EnvironmentObject var myStore: DateStore
    var hasPlans: Bool {
        guard let plans = myStore.getPlans() else { return false }
        return plans.isEmpty
    }

    var body: some View{
        VStack{
            Text(hasPlans ? ""I have plans"":""I have time today"")
            Button(action: {
                self.myStore.addPlans(for: Date())
            }) {
                Text(""I have plans"")
            }
    }
}

class DateStore: NSObject, ObservableObject, NSFetchedResultsControllerDelegate {
    private var fetchedResultsController: NSFetchedResultsController&lt;DateStore&gt;
    //...
    public func addPlans(for date: Date){
        //{...}
        if let day = self.dates.first(where: { $0.date == date}){
            day.plans += 1
            saveChanges()
        }else{
            self.create(date: dayDate)
        }
    }

    func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
        self.objectWillChange.send()
    }
}


</code></pre>

<p>That's a very simplified version of my problem and I know that my DataModel works because the values change and <code>self.objectWillChange.send()</code> is called, but my View isn't updated for some reason....</p>
","9506784","","9506784","","2019-07-31 12:16:48","2019-08-01 01:49:17","Computed (NSObject) Properties in SwiftUI don't update the view","<swift><core-data><swiftui><computed-properties><combine>","3","5","1","","","CC BY-SA 4.0"
"57300961","1","","","2019-08-01 02:05:15","","2","1130","<p>I want to create a scrollable list of 3D models(here: default ship model of Xcode which you can find in a <strong>Game</strong> project of Xcode).</p>

<p>For that I've created 3 <em>View</em> structures:</p>

<ul>
<li>one for viewing the 3D model (called <em>ScenekitView</em>)</li>
<li>one for a CardView (called <em>MyCardView</em>)</li>
<li>one for the scrollable list of 3D models(called MyCardsListView)</li>
</ul>

<p>Here are the Structures:</p>

<p><strong>ScenekitView</strong>
(btw I added the <em>art.scnassets</em> folder of Xcode's default <em>Game</em> project to my <em>Single View App</em> project)</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import SceneKit

struct ScenekitView : UIViewRepresentable {
    @Binding var yRotation : Float
    let scene = SCNScene(named: ""art.scnassets/ship.scn"")!

    func makeUIView(context: Context) -&gt; SCNView {
        // create and add a camera to the scene
        let cameraNode = SCNNode()
        cameraNode.camera = SCNCamera()
        scene.rootNode.addChildNode(cameraNode)
        // place the camera
        cameraNode.position = SCNVector3(x: 0, y: 0, z: 15)
        // create and add a light to the scene
        let lightNode = SCNNode()
        lightNode.light = SCNLight()
        lightNode.light!.type = .omni
        lightNode.position = SCNVector3(x: 0, y: 10, z: 10)
        scene.rootNode.addChildNode(lightNode)
        // create and add an ambient light to the scene
        let ambientLightNode = SCNNode()
        ambientLightNode.light = SCNLight()
        ambientLightNode.light!.type = .ambient
        ambientLightNode.light!.color = UIColor.darkGray
        scene.rootNode.addChildNode(ambientLightNode)
        // retrieve the ship node
        let ship = scene.rootNode.childNode(withName: ""ship"", recursively: true)!
        // animate the 3d object
        ship.eulerAngles = SCNVector3(x: 0, y: self.yRotation * Float((Double.pi)/180.0) , z: 0)
        // retrieve the SCNView
        let scnView = SCNView()
        return scnView
    }

    func updateUIView(_ scnView: SCNView, context: Context) {
        scnView.scene = scene
        // allows the user to manipulate the camera
        scnView.allowsCameraControl = true
        // show statistics such as fps and timing information
        scnView.showsStatistics = true
        // configure the view
        scnView.backgroundColor = UIColor.black
    }
}

#if DEBUG
struct ScenekitView_Previews : PreviewProvider {
    static var previews: some View {
        ScenekitView(yRotation: .constant(0))
    }
}
#endif
</code></pre>

<p><strong>MyCardView</strong></p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct MyCardView : View {
    @Binding var yRotation: Float

    var body: some View {
        VStack(spacing: 0) {
            ZStack {
                Rectangle()
                    .foregroundColor(.black)
                    .opacity(0.8)
                    .frame(width:250, height: 70)
                Text( ""Ship \( self.yRotation )"" )
                    .foregroundColor(.white)
                    .font(.title)
                    .fontWeight(.bold)
            }
            ScenekitView(yRotation: self.$yRotation )
                .frame(width: 250, height: 250)
        }
        .cornerRadius(35)
        .frame(width: 250,height: 320)
    }
}

#if DEBUG
struct MyCardView_Previews : PreviewProvider {
    static var previews: some View {
        MyCardView(yRotation: .constant(90))
    }
}
#endif
</code></pre>

<p><strong>MyCardsListView</strong></p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct MyCardsListView: View {
    @State var yRotation: Float = 0
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack {
                ForEach(0...2) { number in
                    GeometryReader { geometry in
                        MyCardView(yRotation: self.$yRotation )
                        .rotation3DEffect(Angle(degrees: Double(geometry.frame(in: .global).minX) / -20), axis: (x: 0, y: 10, z: 0))
                    }
                    .padding()
                    .frame(width: 250, height: 350)
                }
            }
        }
    }
}

#if DEBUG
struct Product3DView_Previews: PreviewProvider {
    static var previews: some View {
        MyCardsListView()
    }
}
#endif
</code></pre>

<p>In <em>MyCardsListView</em> I'm getting each Card's minimum X position using <code>GeometryReader</code></p>

<p><strong>My goal is:</strong></p>

<p>while I'm scrolling the <em>Cards</em> in <em>MyCardsListView</em>, every ship model should rotate with respect to <strong>its Card's</strong> minimum X position (all of them shouldn't rotate with same rotation angle at the same time)</p>

<p>(I know I might made lots of mistakes in using Bindings, States and etc, Sorry about that)</p>
","11687567","","11687567","","2019-08-01 15:30:03","2019-08-01 18:33:34","SwiftUI + Scenekit + Combine + GeometryReader ==> Scrollable List of 3D Models + Rotation of 3D Models By Scrolling the List","<scenekit><swiftui><combine>","1","4","4","","","CC BY-SA 4.0"
"57302033","1","57302695","","2019-08-01 04:57:12","","13","7533","<p>I am trying to make individually moveable objects. I am able to successfully do it for one object but once I place it into an array, the objects are not able to move anymore.</p>

<p>Model: </p>

<pre><code>class SocialStore: ObservableObject {
    @Published var socials : [Social]

    init(socials: [Social]){
        self.socials = socials
    }
}

class Social : ObservableObject{
    var id: Int
    var imageName: String
    var companyName: String
    @Published var pos: CGPoint

    init(id: Int, imageName: String, companyName: String, pos: CGPoint) {
        self.id = id
        self.imageName = imageName
        self.companyName = companyName
        self.pos = pos
    }

    var dragGesture : some Gesture {
        DragGesture()
            .onChanged { value in
                self.pos = value.location
                print(self.pos)
        }
    }
}
</code></pre>

<p>Multiple image (images not following drag): </p>

<pre><code>struct ContentView : View {
    @ObservedObject var socialObject: SocialStore = SocialStore(socials: testData)

    @ObservedObject var images: Social = testData[2]

    var body: some View {
        VStack {
            ForEach(socialObject.socials, id: \.id) { social in
                Image(social.imageName)
                    .position(social.pos)
                    .gesture(social.dragGesture)
            }
        }
    }
}
</code></pre>

<p>Single image (image follow gesture):</p>

<pre><code>struct ContentView : View {
    @ObservedObject var socialObject: SocialStore = SocialStore(socials: testData)

    @ObservedObject var images: Social = testData[2]

    var body: some View {
        VStack {
            Image(images.imageName)
                .position(images.pos)
                .gesture(images.dragGesture)
        }
    }
}
</code></pre>

<p>I expect the individual items to be able to move freely . I see that the coordinates are updating but the position of each image is not.</p>
","10200990","","","","","2019-09-24 09:19:52","Published works for single object but not for array of objects","<xcode><swiftui><xcode11><combine>","4","0","6","","","CC BY-SA 4.0"
"57348512","1","57349279","","2019-08-04 16:52:23","","7","6283","<p>I am currently doing a project using SwiftUI and Combine. I'm on Xcode11 Beta 5. I would like to fetch my Github repositories, display them and then be able to bookmark some of them.</p>

<p>I'm able to fetch them and display them. I'm using Combine with @Published property wrapper to update my views. To now, everything worked as expected. </p>

<p>So I moved on to the next step, bookmarking repositories. I would like to use Realm to persist these repositories.</p>

<p>My problem is that, I have an Observable class which have a <strong>@Published</strong> array of Repository. Repository is a decodable class. In my Repository class I have a simple class property <strong>isFavorite</strong> set to false for now. </p>

<p>In my repositories list, when I click on a repository to see details, I would like to have the possibility to bookmark it. So I retrieve its index by its id from my array of Repository and set its property <strong>isFavorite</strong> to true. But my view doesn't update. I mean I have a conditional rendering and it's stuck to false. </p>

<p>Here's my code :</p>

<pre><code>import SwiftUI
import Combine

struct RepositoryList : View {
    @ObservedObject var store: Store

    func move(from source: IndexSet, to destination: Int) {
        store.repositories.swapAt(source.first!, destination)
    }

    @State private var isTapped = false
    @State private var bgColor = Color.white

    var body: some View {
        NavigationView {
            VStack {
                List {
                    Section(header: Text(""\(String(store.repositories.count)) repositories"")) {
                        ForEach(store.repositories) { repository in
                            NavigationLink(destination: RepositoryDetail(store: self.store, repository: repository)) {
                                RepositoryRow(repository: repository)
                            }.padding(.vertical, 8.0)
                        }.onDelete { index in
                            self.store.repositories.remove(at: index.first!)
                        }.onMove(perform: move)
                    }
                }
            }
        }.navigationBarTitle(""Github user"").navigationBarItems(trailing: EditButton())
    }
}

struct RepositoryDetail : View {
    @ObservedObject var store: Store
    var repository: Repository

    var repoIndex: Int {
        let repoIndex = store.repositories.firstIndex(where: {$0.id == repository.id})!
        print(""### IS FAVORITE \(String(store.repositories[repoIndex].isFavorite))"")
        return repoIndex
    }

    var body: some View {
        VStack(alignment: .leading) {
            Text(String(store.repositories[repoIndex].isFavorite))
            Button(action: { self.store.repositories[self.repoIndex].isFavorite.toggle() }) {
                if (self.store.repositories[self.repoIndex].isFavorite) {
                    Image(systemName: ""star.fill"").foregroundColor(Color.yellow)
                } else {
                    Image(systemName: ""star"").foregroundColor(Color.gray)
                }
            }
        }.navigationBarTitle(Text(repository.name), displayMode: .inline)
    }
}

class Store: ObservableObject {
    private var cancellable: AnyCancellable? = nil
    @Published var repositories: [Repository] = []

    init () {
        var urlComponents = URLComponents(string: ""https://api.github.com/users/Hurobaki/repos"")!
        var request = URLRequest(url: urlComponents.url!)
        request.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")

        cancellable = URLSession.shared.send(request: request)
            .decode(type: [Repository].self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                print(""### .sink() received the completion"", String(describing: completion))
                switch completion {
                case .finished:
                    break
                case .failure(_):
                   print(""### ERROR"")
                }
            }, receiveValue: { repositories in
                self.repositories = repositories
            })

    }
}

class Repository: Decodable, Identifiable {
    var id: Int = 0
    var name: String = """"
    var desc: String? = nil

    var isFavorite = false

    private enum CodingKeys: String, CodingKey {
        case id, name
        case desc = ""description""
    }
}
</code></pre>

<p>I don't know why my Button component never display <code>Image(systemName: ""star.fill"").foregroundColor(Color.yellow)</code> When I print <strong>isFavorite</strong> property its value changes from true to false and vice versa but my view doesn't update.</p>

<p>I did the tutorial from Apple Developer where they do exactly the same thing, so I don't know why I have this error, what am I missing ?  </p>

<p>Some help would be really appreciated and / or reviews on my code :) </p>

<p>Thank you</p>

<p>PS: In order not to post an even longer code I have uploaded it on Pastebin
<a href=""https://pastebin.com/zjDwQSGq"" rel=""noreferrer"">https://pastebin.com/zjDwQSGq</a></p>
","7215553","","7215553","","2019-08-04 17:06:48","2022-04-17 16:07:54","Swift Combine - @Published property Array","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"57360838","1","57366566","","2019-08-05 14:38:39","","12","2753","<p>I found this question <a href=""https://stackoverflow.com/questions/56699418/swiftui-putting-multiple-bindableobjects-into-environment/56699552#56699552"">SwiftUI: Putting multiple BindableObjects into Envionment</a></p>

<p>the answer said environmentObject(ObservableObject) returns modified view, therefore I can make call chain for multiple environmentObject.</p>

<p>like</p>

<pre class=""lang-swift prettyprint-override""><code>let rootView = ContentView()
     .environmentObject(firstBindable)
     .environmentObject(secondBindable)
</code></pre>

<p>and I wonder what is result if firstBindable and secondBindable are same type. how <code>.environmentObject()</code> knows what is exect value which is a programmer intended to set between <code>firstBindable</code> and <code>secondBindable</code>.</p>

<p>so I tested this</p>

<ol>
<li>I made an ObservableObject class</li>
</ol>

<pre class=""lang-swift prettyprint-override""><code>final class TempStr: ObservableObject {
    @Published var tmpStr = ""temp""

    init(initStr: String) {
        tmpStr = initStr
    }
}
</code></pre>

<ol start=""2"">
<li>made call chain of environmentObject from sceneDelegate</li>
</ol>

<pre><code>window.rootViewController
  = UIHostingController(rootView:
      TestView()
        .environmentObject(TempStr(initStr: ""1st"")) 
        .environmentObject(TempStr(initStr: ""2nd""))
</code></pre>

<ol start=""3"">
<li>and used values from View</li>
</ol>

<pre><code>struct TestView: View {
  @EnvironmentObject var tmp1: TempStr
  @EnvironmentObject var tmp2: TempStr

   var body: some View {
      Text(tmp1.tmpStr + "" "" + tmp2.tmpStr)
   }
}
</code></pre>

<ol start=""4"">
<li>result was '1st 1st'</li>
</ol>

<p>And if my code calls one .environmentObject() like</p>

<pre><code>TestView().environmentObject(TempStr(initStr: ""1st"")) 
</code></pre>

<p>both tmp1 and tmp2 from TestView have same value <code>TempStr(initStr: ""1st"")</code>. it looks like <code>.environmentObject()</code> call sets all values of same type.</p>

<p><br></p>

<p>Actually, I knew that it couldn't work but I just tried it for using this question.</p>

<p>I wonder what is correct way of achieving my goal.</p>

<p>Thanks</p>
","2889247","","","","","2019-08-05 21:59:08","How to set multiple EnvironmentObjects which are same type","<observable><publish><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"57399838","1","57455621","","2019-08-07 17:50:49","","8","1919","<p>I'm trying to wrap my head around Combine.</p>

<p>Here's a method I want to translate into Combine, so that it would return AnyPublisher.</p>

<pre class=""lang-swift prettyprint-override""><code>func getToken(completion: @escaping (Result&lt;String, Error&gt;) -&gt; Void) {
    dispatchQueue.async {
        do {
            if let localEncryptedToken = try self.readTokenFromKeychain() {
                let decryptedToken = try self.tokenCryptoHelper.decrypt(encryptedToken: localEncryptedToken)
                DispatchQueue.main.async {
                    completion(.success(decryptedToken))
                }
            } else {
                self.fetchToken(completion: completion)
            }
        } catch {
            DispatchQueue.main.async {
                completion(.failure(error))
            }
        }
    }
}
</code></pre>

<p>The whole thing executes on a separate dispatch queue because reading from Keychain and decryption can be slow.</p>

<p>My first attempt to embrace Combine</p>

<pre class=""lang-swift prettyprint-override""><code>func getToken() -&gt; AnyPublisher&lt;String, Error&gt; {
    do {
        if let localEncryptedToken = try readTokenFromKeychain() {
            let decryptedToken = try tokenCryptoHelper.decrypt(encryptedToken: localEncryptedToken)
            return Result.success(decryptedToken).publisher.eraseToAnyPublisher()
        } else {
            return fetchToken() // also rewritten to return AnyPublisher&lt;String, Error&gt;
        }
    } catch {
        return Result.failure(error).publisher.eraseToAnyPublisher()
    }
}
</code></pre>

<p>But how would I move reading from Keychain and decryption onto separate queue? It probably should look something like</p>

<pre><code>func getToken() -&gt; AnyPublisher&lt;String, Error&gt; {
    return Future&lt;String, Error&gt; { promise in
        self.dispatchQueue.async {
            do {
                if let localEncryptedToken = try self.readTokenFromKeychain() {
                    let decryptedToken = try self.tokenCryptoHelper.decrypt(encryptedToken: localEncryptedToken)
                    promise(.success(decryptedToken))
                } else {
                    // should I fetchToken().sink here?
                }
            } catch {
                promise(.failure(error))
            }
        }    
    }.eraseToAnyPublisher()
}
</code></pre>

<p>How would I return a publisher from my private method call? (see comment in code)</p>

<p>Are there any prettier solutions?</p>
","4933617","","4933617","","2019-08-07 20:08:16","2019-08-12 04:25:11","Translating async method into Combine","<swift><combine>","2","1","2","","","CC BY-SA 4.0"
"57424157","1","57424336","","2019-08-09 05:55:26","","17","13282","<p>I built a <code>LoadingView</code> with SwiftUI for showing some loading stuff in my app while I'm fetching remote data from an API. I am on Xcode Version 11.0 beta 5.</p>

<p>This is the <code>LoadingView</code>:</p>

<pre><code>struct LoadingView&lt;Content&gt;: View where Content: View {

    @Binding var isShowing: Bool
    var content: () -&gt; Content

    var body: some View {

        GeometryReader { geometry in

            ZStack(alignment: .center) {

                self.content()
                    .disabled(self.isShowing)
                    .blur(radius: self.isShowing ? 3 : 0)

                VStack {
                    Text(""Loading..."")
                    ActivityIndicator(isAnimating: .constant(true), style: .large)
                }
                .frame(width: geometry.size.width / 2,
                       height: geometry.size.height / 5)
                    .background(Color.white)
                    .foregroundColor(Color.primary)
                    .cornerRadius(5)
                    .opacity(self.isShowing ? 1 : 0)
            }
        }
    }
}
</code></pre>

<p>This is my DataStore. It is declared as <code>ObservableObject</code> and has more than one <code>@Published</code> property. Also it does some remote fetching from an API:</p>

<pre><code>class CharacterStore: ObservableObject {

    @Published private(set) var isLoading = false


    // Fetches some stuff from a remote api
    func fetch() {

        self.isLoading = true

        myService.getCharacters { (result) in
            DispatchQueue.main.async {
                self.isLoading = false
            }
        }
    }
}
</code></pre>

<p>And finally this is the View I want to show my <code>LoadingView</code> with the content of <code>ContentView</code> in it. Of course I am setting the <code>@EnvironmentObject</code> before showing this view.</p>

<pre><code>struct ContentView: View {

    @EnvironmentObject var charStore: CharacterStore

    var body: some View {

        LoadingView(isShowing: self.$charStore.isLoading) { // Here I get the error

            // Show some Content here
            Text("""")
        }
    }
}
</code></pre>

<p>The problem is that I want to bind <code>self.$charStore.isLoading</code> to <code>LoadingView</code>. In this line i get the following error:</p>

<blockquote>
  <p>Generic parameter 'Subject' could not be inferred</p>
</blockquote>

<p>I tried in several ways but none of these things work. Btw: If I use a <code>@State</code> property in <code>ContentView</code> it just works fine like this:</p>

<pre><code>struct ContentView: View {

    @EnvironmentObject var charStore: CharacterStore

    @State var loads: Bool = false

    var body: some View {

        LoadingView(isShowing: self.$loads) { // Here I get no error

            // Show some Content here
            Text("""")
        }
    }
}
</code></pre>

<p>Am I missing a thing? If you need further informations let me know i can provide more content if needed.</p>

<p>Thanks for the help!</p>
","5650076","","","","","2019-08-09 11:30:47","SwiftUI: Generic parameter 'Subject' could not be inferred","<swift><swiftui><swift5><combine>","2","0","4","","","CC BY-SA 4.0"
"57446192","1","57451252","","2019-08-10 22:45:46","","1","808","<p>Just getting to grips with Combine and have come across an issue where I need to call a method in my class when it receives a value from a <code>Publisher</code>, in this case a <code>Notification</code> from <code>NotificationCenter</code>...</p>

<p>Here's the subscription...</p>

<pre><code>let subscribe = NotificationCenter.default.publisher(for: Notification.Name(rawValue: ""LocalTalkNotificationReceivedData""), object: nil)
    .map( {
        ($0.object as! Data)
    } )
    .sink(receiveValue: {
        self.interpretIncoming(data: $0)
    })
</code></pre>

<p>What I get told by the compiler is <code>Use of unresolved identifier 'self'</code>.
It's late, I'm kinda tired, anyone got an idea?
Xcode 11 beta 5 on Catalina beta 5 btw...</p>

<p>Complete file:</p>

<pre><code>import Foundation
import Combine
import SwiftUI

public class MessageData: ObservableObject, Identifiable {
public var peerData: [Peer] = [Peer]()
public var messageData: [Message] = [Message]()
public var objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
let subscribe = NotificationCenter.default.publisher(for: Notification.Name(rawValue: ""LocalTalkNotificationReceivedData""), object: nil)
    .map( {
        ($0.object as! Data)
    } )
    .sink(receiveValue: {
        self.interpretIncoming(data: $0)
    })

init() {
    self.setupDummyData()
}

private func setupDummyData() {
    self.peerData = self.load(""peerData.json"")
    self.messageData = self.load(""messageData.json"")
}

func addMessage(message: String, sender: MessageSource, name: String) {
    let newMessage = Message(id: Date().hashValue,
                             content: message,
                             source: sender,
                             correspondent: name)
    self.messageData.append(newMessage)
    self.objectWillChange.send()
}

func load&lt;T: Decodable&gt;(_ filename: String, as type: T.Type = T.self) -&gt; T {
    let data: Data

    guard let file = Bundle.main.url(forResource: filename, withExtension: nil)
        else {
            fatalError(""Couldn't find \(filename) in main bundle."")
    }

    do {
        data = try Data(contentsOf: file)
    } catch {
        fatalError(""Couldn't load \(filename) from main bundle:\n\(error)"")
    }

    do {
        let decoder = JSONDecoder()
        return try decoder.decode(T.self, from: data)
    } catch {
        fatalError(""Couldn't parse \(filename) as \(T.self):\n\(error)"")
    }
}

func interpretIncoming(data sent: Data) {
    do {
        let receivedTransmission = try NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(sent) as! [String: Any]
        self.addMessage(message: receivedTransmission[""messagePayload""] as! String,
                        sender: .them,
                        name: receivedTransmission[""messageSender""] as! String)
    } catch {
        print(""FAILED DECODING THING"")
    }
}
</code></pre>

<p>}</p>
","417085","","417085","","2019-08-10 23:01:46","2019-08-11 15:24:11","How to reference self in a Subscriber in Combine in Swift","<swift><nsnotificationcenter><publisher><subscriber><combine>","2","2","","","","CC BY-SA 4.0"
"57455076","1","57463089","","2019-08-12 02:33:48","","6","3760","<p>I want to get data from REST API and in order to do that, I need to first get an array of IDs - 1st call. After that, I need to do an API call using each ID. I don't want to use completionHandlers but Combine. I started with dataTaskPublishers but I am not sure how can I chain them to work properly 🤔</p>

<p>Here is my code so far:</p>

<pre class=""lang-swift prettyprint-override""><code>   private func getIDs(for type: DataType) -&gt; AnyPublisher&lt;[ID], Error&gt; {
        guard let url = URL(string: ""url"")
            else { fatalError(""Wrong URL"") }

        return session.dataTaskPublisher(for: url)
            .receive(on: RunLoop.main)
            .map { $0.data }
            .decode(type: [ID].self, decoder: decoder)
            .eraseToAnyPublisher()
    }

    private func getData(with id: ID) -&gt; AnyPublisher&lt;MyData, Error&gt; {
        guard let url = URL(string: ""url_with_id"")
            else { fatalError(""Wrong URL"") }
        return session.dataTaskPublisher(for: url)
            .receive(on: RunLoop.main)
            .map { $0.data }
            .decode(type: MyData.self, decoder: decoder)
            .eraseToAnyPublisher()
    }
</code></pre>

<p>I am not really sure how can I connect them to get something that is assignable to my state variable - array of MyData.</p>
","7482031","","","","","2020-04-13 22:05:44","How to chain multiple API calls using dataTaskPublisher?","<ios><swift><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"57478134","1","57479187","","2019-08-13 12:52:14","","15","8760","<p>I'm trying to learn Combine with SwiftUI and I'm struggling how to update my view (from UIKit) with <code>ObservableObject</code> (previously <code>BindableObject</code>). The issue is that, obviously, method <code>updateUIView</code> will not fire once the <code>@Published</code> object sends the notification it was changed.</p>

<pre><code>class DataSource: ObservableObject {
    @Published var locationCoordinates = [CLLocationCoordinate2D]()
    var value: Int = 0

    init() {
        Timer.scheduledTimer(withTimeInterval: 3, repeats: true) { timer in
            self.value += 1
            self.locationCoordinates.append(CLLocationCoordinate2D(latitude: 52, longitude: 16+0.1*Double(self.value)))
        }
    }
}

struct MyView: UIViewRepresentable {
    @ObservedObject var dataSource = DataSource()

    func makeUIView(context: Context) -&gt; MKMapView {
        MKMapView(frame: .zero)
    }

    func updateUIView(_ view: MKMapView, context: Context) {
        let newestCoordinate = dataSource.locationCoordinates.last ?? CLLocationCoordinate2D(latitude: 52, longitude: 16)
        let annotation = MKPointAnnotation()
        annotation.coordinate = newestCoordinate
        annotation.title = ""Test #\(dataSource.value)""
        view.addAnnotation(annotation)
    }
}
</code></pre>

<p>How to bind that <code>locationCoordinates</code> array to the view in such a way, that a new point is in fact added each time it refreshes?</p>
","849616","","","","","2021-11-27 12:34:04","How to update UIViewRepresentable with ObservableObject","<swift><uikit><mapkit><swiftui><combine>","3","1","","","","CC BY-SA 4.0"
"57481380","1","57598143","","2019-08-13 15:53:51","","0","175","<p>I am trying to run a simple project with the following:</p>

<p><code>@Published var currentPlacemark: CLPlacemark? = nil</code></p>

<ul>
<li>XCode11 Beta5(11M382q)</li>
<li>iOS13(17A5556d)</li>
</ul>

<p>Getting the following error:
<code>dyld: Symbol not found: _$s7Combine9PublishedV9PublisherCyx_GAadAM</code></p>

<p>Anyone else encountered this?</p>

<p>Code example:</p>

<pre><code>import SwiftUI
import Combine

class MyFoo {
  @Published var bar: String = """"
}

struct ContentView: View {
    var body: some View {
        Text(""Hello World"")
    }
}

#if DEBUG
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        let foo = MyFoo()
      foo.bar = ""asas""
        let barSink = foo.$bar
            .sink() {
                print(""bar value: \($0)"")
        }
        return ContentView()
    }
}
#endif
</code></pre>
","8323518","","1000551","","2019-12-07 10:01:02","2019-12-07 10:01:02","Combine @Published could not be found - Xcode11 Beta 5(11M382q)","<ios><swift><xcode><ios13><combine>","1","9","","","","CC BY-SA 4.0"
"57513437","1","57598001","","2019-08-15 17:05:58","","0","287","<p>I'm using Xcode 11 Beta 5 (11M382q), and iphone x with iOS 13 beta 6 and I am having this runtime error when trying to use Combine:</p>

<blockquote>
  <p>dyld: Symbol not found: _$s7Combine9PublishedV9PublisherCyx_GAadAMc</p>
</blockquote>

<p>I have a Core class that is an <code>ObservableObject</code></p>

<pre><code>import SwiftUI
import Combine

open class Core: ObservableObject {
    @Published public var userId = """"

    public var isUserValid: AnyPublisher&lt;Bool, Never&gt; {
    return $userId.debounce(for: 0.5, scheduler: RunLoop.main).removeDuplicates().map { (user: String) in
      return user.isEmpty
    }.eraseToAnyPublisher()
  }
}
</code></pre>

<p>And a simple view</p>

<pre><code>import SwiftUI
import Combine

struct LoginView: View {
    @EnvironmentObject var core: Core
    @State var isLoading: Bool = false
    @State var submitButtonEnabled: Bool = false

    var body: some View {
        VStack {
            VStack(alignment: .center) {
                Image(""logo"")
                    .frame(minWidth: Constants.logoWidth, minHeight: Constants.logoHeight, alignment: .center)
                    .padding(.top, Constants.logoTopPadding)
                    .animation(.default)
                    .scaledToFit()
             }
        }

        CircularButton(isLoading: $isLoading, image: Constants.submitButtonArrowImageName) {
            // Button Action
        }
        .padding(.top, Constants.submitButtonTopPadding)
        .disabled($submitButtonEnabled.value)
        .onReceive(self.core.isUserValid) { value in
          self.submitButtonEnabled = value
        }
    }
}
</code></pre>

<p>What's wrong with my code? I Just want a MVVM architecture using reactive programming to disable or enable a button.</p>
","4687709","","13302","","2019-08-19 13:20:49","2019-08-21 19:20:33","Runtime error using Combine: dyld: Symbol not found: _$s7Combine9PublishedV9PublisherCyx_GAadAMc","<swift><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"57517320","1","","","2019-08-15 23:24:28","","22","7909","<p>When using @Published property wrapper following current SwiftUI syntax, it seems very hard to define a protocol that includes a property with @Published, or I definitely need help :)</p>

<p>As I'm implementing dependency injection between a View and it's ViewModel, I need to define a ViewModelProtocol so to inject mock data to preview easily.</p>

<p>This is what I first tried, </p>

<pre><code>protocol PersonViewModelProtocol {
    @Published var person: Person
}
</code></pre>

<p>I get ""Property 'person' declared inside a protocol cannot have a wrapper"".</p>

<p>Then I tried this,</p>

<pre><code>protocol PersonViewModelProtocol {
    var $person: Published
}
</code></pre>

<p>Obviously didn't work because '$' is reserved.</p>

<p>I'm hoping a way to put a protocol between View and it's ViewModel and also leveraging the elegant @Published syntax. Thanks a lot.</p>
","1596810","","1596810","","2019-08-18 22:27:41","2022-05-07 14:06:53","How to define a protocol to include a property with @Published property wrapper","<protocols><swiftui><combine>","9","2","8","","","CC BY-SA 4.0"
"57527036","1","57527346","","2019-08-16 15:09:25","","-2","626","<p>Can someone please break this code example down for me? <code>zip</code> and <code>reduce</code> makes some sense, but what's going on with <code>combine:</code> is confusing me. Any help would be greatly appreciated.</p>

<pre><code>let a = [5, 6, 7]
let b = [3, 6, 10]

let pointsAlice = zip(a, b).reduce(0, combine: { $0 + ($1.0 &gt; $1.1 ? 1 : 0) } )
let pointsBob = zip(b, a).reduce(0, combine: { $0 + ($1.0 &gt; $1.1 ? 1 : 0) } )

print(""\(pointsAlice) \(pointsBob)"") // 1 1
</code></pre>
","8729720","","1630618","","2019-08-16 15:12:46","2019-08-16 16:23:51","Explanation of zip, reduce and combine in Swift","<swift><zip><reduce><combine>","1","0","","","","CC BY-SA 4.0"
"57543855","1","57597385","","2019-08-18 10:55:08","","34","12005","<p>I have such code</p>

<pre><code>func request(request: URLRequest) -&gt; AnyPublisher&lt;Data, Error&gt; {
    return Just(request)
        .flatMap { request in
            RequestManager.request(request) // returns AnyPublisher&lt;Data, Error&gt;
    }
    .eraseToAnyPublisher()
}
</code></pre>

<p>and I'm getting compile error:</p>

<blockquote>
  <p>Instance method flatMap(maxPublishers:_:) requires the types
  Just.Failure (aka Never) and Error be equivalent</p>
</blockquote>

<p>And it's clear, because <code>Just</code> has <code>Never</code> as <code>Failure</code> and <code>.flatMap</code> requires  <code>Error</code> as <code>Failure</code>, so <code>Never</code> != <code>Error</code></p>

<p>I see 2 approaches:</p>

<ul>
<li><p>using <em>right</em> Publisher, instead of <code>Just</code>, but I didn't find good candidate for this.</p></li>
<li><p>using some operator like <code>.mapError</code>, <code>.mapError { $0 as Error }</code>, but I'm not sure that it's great idea.</p></li>
</ul>

<p>Any ideas how to handle it?</p>

<p><strong>UPDATE:</strong></p>

<p>it makes more sense to use</p>

<pre><code>.setFailureType(to: Error.self)
</code></pre>

<p>or </p>

<pre><code>.mapError { $0 as Error }
</code></pre>
","3785970","","3785970","","2019-08-22 08:06:12","2020-09-22 18:06:51","Using Just with flatMap produce Failure mismatch. Combine","<swift><combine>","3","0","3","","","CC BY-SA 4.0"
"57564070","1","57568597","","2019-08-19 21:17:39","","1","202","<p>I have some <code>TextField(s)</code> with “.text” values that are supposed to be populated by a method called within “<strong>init()</strong>” (can be moved) that asynchronously calls a completion handler with a <code>struct</code> of data from the network.</p>

<p>The thing is... the user can also <strong>begin typing into them manually</strong> in the meantime and the completion callback <strong>shouldn’t overwrite the manually edited values</strong>.</p>

<p>I’m not sure how to:</p>

<ol>
<li>Update the values of the <code>@State String</code> variables to replace the existing values only if they haven’t been modified by the user yet... while <strong>also</strong> having them be mutable by the end-user.</li>
<li>Update N number of the <code>@State</code> values from the same request at once. One request is used to pull <strong>all</strong> of the data in, so mapping into a single value while having it be mutable as noted above is a head scratcher at the moment.</li>
</ol>

<p>It seems like a job for Combine, just not sure where to start yet.</p>
","963901","","","","","2019-08-20 07:25:33","Asynchronously populate/pre-fill multiple, user mutable `@State` values when using SwiftUI?","<swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"57582568","1","58357504","","2019-08-20 23:09:54","","1","1915","<p>In a operator chain like this you used to be able to return Publishers.Just(defaultValue) but it is deprecated and I can't find a way to do this functionality anymore. What is the new way to return a defaultValue?</p>

<pre><code> $query
    .throttle(for: 0.5, scheduler: DispatchQueue.main, latest: true)
    .removeDuplicates()
    .map { query -&gt; AnyPublisher&lt;[Repo], Never&gt; in
       guard query.count &gt;= 3 else {
          return Publishers.Just([])
                   .eraseToAnyPublisher()
          }
          return API().search(with: query)
               .retry(3)
               .eraseToAnyPublisher()
          }
</code></pre>
","2066353","","","","","2019-10-12 19:00:37","iOS combine Publishers.Just deprecated","<swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"57585359","1","57585649","","2019-08-21 06:06:10","","3","1122","<p>I'm attempting to dismiss a modal after its intended action is completed, but I have no idea how this can be currently done in SwiftUI. This modal is triggered by a <code>@State</code> value change. Would it be possible to change this value by observing a notification of sorts?</p>

<p>Desired actions: Root -> Initial Modal -> Presents Children -> Dismiss modal from any child</p>

<p>Below is what I've tried</p>

<p>Error: <strong>Escaping closure captures mutating 'self' parameter</strong></p>

<pre><code>struct AContentView: View {
    @State var pageSaveInProgress: Bool = false

    init(pages: [Page] = []) { 
    // Observe change to notify of completed action
        NotificationCenter.default.publisher(for: .didCompletePageSave).sink { (pageSaveInProgress) in
            self.pageSaveInProgress = false
        }
    }

    var body: some View {
        VStack {
        //ETC
            .sheet(isPresented: $pageSaveInProgress) {
                    ModalWithChildren()
            }
        }
    }
}
</code></pre>

<p>ModalWithChildren test action</p>

<pre><code>
Button(action: {
    NotificationCenter.default.post(
        name: .didCompletePageSave, object: nil)}, 
        label: { Text(""Close"") })
</code></pre>
","5222077","","5540925","","2020-02-14 16:40:53","2020-02-14 16:40:53","SwiftUI : Dismiss modal from child view","<ios><swift><uiview><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"57617476","1","","","2019-08-22 21:54:46","","5","8721","<p>I'm new to SwiftUI and understand that I may need to implement EnvironmentObject in some way, but I'm not sure how in this case.</p>

<p>This is the <code>Trade</code> class</p>

<pre><code>class Trade {
    var teamsSelected: [Team]

    init(teamsSelected: [Team]) {
        self.teamsSelected = teamsSelected
    }
}
</code></pre>

<p>This is the child view. It has an instance <code>trade</code> from the <code>Trade</code> class. There is a button that appends 1 to array <code>teamsSelected</code>.</p>

<pre><code>struct TeamRow: View {
    var trade: Trade

    var body: some View {
        Button(action: {
            self.trade.teamsSelected.append(1)
        }) {
            Text(""Button"")
        }
    }
}
</code></pre>

<p>This is the parent view. As you can see, I pass <code>trade</code> into the child view <code>TeamRow</code>. I want <code>trade</code> to be in sync with <code>trade</code> in <code>TeamRow</code> so that I can then pass <code>trade.teamsSelected</code> to <code>TradeView</code>.</p>

<pre><code>struct TeamSelectView: View {
    var trade = Trade(teamsSelected: [])

    var body: some View {
        NavigationView{
            VStack{
                NavigationLink(destination: TradeView(teamsSelected: trade.teamsSelected)) {
                   Text(""Trade"")
                }

                List {
                    ForEach(teams) { team in
                        TeamRow(trade: self.trade)
                    }
                }
            }
        }
    }
}
</code></pre>
","8372265","","","","","2020-10-08 05:54:40","How do I access data from a child view as the parent view at any time in SwiftUI?","<swiftui><combine>","3","0","2","","","CC BY-SA 4.0"
"57632126","1","57632350","","2019-08-23 19:38:33","","1","2370","<p>I was looking for an example for a DataStore in SwiftUI and found this example.</p>

<pre><code>import SwiftUI
import Combine

class MyDatabase: ObservableObject {
    let didChange = PassthroughSubject&lt;MyDatabase, Never&gt;()

    var contacts: [Contact] = [
        Contact(id: 1, name: ""Anna""), Contact(id: 2, name: ""Beto""),
        Contact(id: 3, name: ""Jack""), Contact(id: 4, name: ""Sam"")
    ] {
        didSet {
            didChange.send(self)
        }
    }

    struct Contact: Identifiable{
        var id: Int
        var name: String
    }
}

struct ContactsList: View {
    @EnvironmentObject private var database: MyDatabase

    var body: some View {
        NavigationView {
            List($database.contacts) { contact in
                NavigationLink(destination: ContactDetail(contact: contact)) {
                    Text(verbatim: contact.value.name)
                    //here Error 1: Types of expression....
                }
            }
            .navigationBarTitle(Text(""Contacts""))
        }
    }
}

struct ContactDetail: View {
    @Binding var contact: MyDatabase.Contact

    var body: some View {
        VStack {
            TextField($contact[\.name])
                .textFieldStyle(.roundedBorder)
                .font(.title)
                .padding()
            //here Error 2: Types of expression....
            Spacer()
        }
        .navigationBarTitle(Text(""Edit""), displayMode: .inline)
    }
}

</code></pre>

<p>However, after testing it, I got the below error multiple times:</p>

<blockquote>
  <p>Type of expression is ambiguous without more context</p>
</blockquote>

<p>I also tried following tutorial for the same solution <a href=""https://mecid.github.io/2019/07/03/managing-data-flow-in-swiftui/"" rel=""nofollow noreferrer"">https://mecid.github.io/2019/07/03/managing-data-flow-in-swiftui/</a>
but I got the same errors.
Did anything changes regarding the Bindings in the latest beta?
Im running Beta 6</p>
","","user9804767","1181535","","2019-08-23 20:02:38","2019-08-23 20:17:39","SwiftUI: Type of expression is ambiguous without more context, When passing ObservableObject between Views","<ios><swiftui><combine>","1","1","","2019-08-24 11:09:16","","CC BY-SA 4.0"
"57638220","1","57639858","","2019-08-24 13:04:28","","4","412","<h1>Info</h1>

<p>My app is crashing on Apple Watches running watchOS 4 &amp; 5. Some new features (ie <code>Combine</code>), depend on watchOS 6, and the use of these methods are explicitly marked with </p>

<pre><code>@available(watchOSApplicationExtension 6.0.0, *)
</code></pre>

<p>The application was created with Xcode 9/10 (I forget exactly which), and targets watchOS 4. Now when it's built with Xcode 11, and has files which depend on Combine, it crashes on a watchOS 5 Apple Watch.</p>

<p>The error is </p>

<pre><code>dyld: Library not loaded: /System/Library/Frameworks/Combine.framework/Combine
  Referenced from: /private/var/containers/Bundle/Application/7A361FAB-EBE7-483D-BFD7-E915F15B5B14/Chirp WatchKit App.app/PlugIns/Chirp WatchKit Extension.appex/Chirp WatchKit Extension
  Reason: image not found
</code></pre>

<p>Clearly, <code>Combine</code>, isn't playing nicely. </p>

<p>Also, it will not launch in a watchOS 5 simulator, and the error is slightly more telling:</p>

<pre><code>dyld: Library not loaded: /System/Library/Frameworks/Combine.framework/Combine
  Referenced from: /Users/willbishop/Library/Developer/CoreSimulator/Devices/C6F36860-E70A-45E6-AC3B-E54DBCEA7C7A/data/Containers/Bundle/Application/1B2EC7C4-731F-4EC1-B23F-09A0B49CD055/Chirp WatchKit App.app/PlugIns/Chirp WatchKit Extension.appex/Chirp WatchKit Extension
  Reason: no suitable image found.  Did find:
    /System/Library/Frameworks/Combine.framework/Combine: mach-o, but wrong architecture
</code></pre>

<h1>What I've Tried:</h1>

<ul>
<li><p>I thought it may be as I had watchOS 6 dependent code, mixed alongside watchOS 5 files. However, after moving the code into seperate files, the issue persists.</p></li>
<li><p>Cleaning the project</p></li>
<li><p>Removing <code>Derived Data/</code></p></li>
</ul>

<p>Despite that, no luck. I assume it's a build setting somewhere, but I wouldn't have the faintest clue of which one.</p>
","7102356","","1000551","","2019-12-07 10:00:49","2019-12-07 10:00:49","No suitable image for Combine found on watchOS 5.2 crash","<swift><xcode><clang><watchos><combine>","1","0","","","","CC BY-SA 4.0"
"57690243","1","59043496","","2019-08-28 10:24:22","","12","8234","<p>What is the role of AnyPublisher in Combine, and why in many examples, including in<a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""noreferrer"">WWDC Combine In practice, 27:40</a> they return AnyPublisher, using <code>.eraseToAnyPublisher</code>, and not just return a Publisher?</p>

<p>The <a href=""https://developer.apple.com/documentation/combine/anypublisher"" rel=""noreferrer"">Apple Documents</a> says </p>

<blockquote>
  <p>Use AnyPublisher to wrap a publisher whose type has details you don’t want to expose to subscribers or other publishers.</p>
</blockquote>

<p>But can anyone give an example of where it can be useful?</p>
","6276472","","","","","2020-10-28 22:07:05","Publisher vs AnyPublisher in Combine","<swift><combine>","2","1","2","","","CC BY-SA 4.0"
"57736028","1","57743808","","2019-08-31 07:24:24","","7","6530","<p>In Xcode 11 beta 5 or 6 my existing code that relied on <code>URLSession.DataTaskPublisher</code> stopped working. It seems like <code>DataTaskPublisher</code> is never publishing any values but I can't work out why.</p>

<p>I've tried with <code>.sink</code> and <code>.handleEvents</code> as subscribers. I've tested .sink with a <code>Just</code> publisher and confirmed it receives a value there.</p>

<p>I've also tried both giving the <code>DataTaskPublisher</code> a <code>URL</code> and giving it a <code>URLRequest</code>. I've tried a request to an API including an authorization header, as well as basic requests to google.com and apple.com. I've tried using <code>URLSession.shared</code> and creating a new instance of <code>URLSession</code>. I've also tried with and without <code>map</code> and <code>decode</code> operators.</p>

<p>I've used <code>XCTest</code> expectations to confirm that the test times out every single time, even if I give it a 4-minute timeout.</p>

<p>I just made a new example project and replicated the problem with the following code in the root view controller:</p>

<pre class=""lang-swift prettyprint-override""><code>override func viewDidLoad() {
        super.viewDidLoad()

        print(""view did load"")

        URLSession.shared.dataTaskPublisher(for: URL(string: ""http://apple.com"")!)
            .handleEvents(receiveSubscription: { (sub) in
                print(sub)
            }, receiveOutput: { (response) in
                print(response)
            }, receiveCompletion: { (completion) in
                print(completion)
            }, receiveCancel: {
                print(""cancel"")
            }, receiveRequest: { (demand) in
                print(demand)
            })
    }
</code></pre>

<p>The project prints ""view did load"" but nothing else ever prints. Any ideas about where I'm going wrong here? Thanks!</p>
","4451268","","","","","2019-10-22 00:32:56","Why doesn't URLSession.DataTaskPublisher ever publish values?","<swift><xcode11><combine>","1","2","1","","","CC BY-SA 4.0"
"57760772","1","57760803","","2019-09-02 17:22:56","","4","4437","<p>Seems like Combine (shipped with Xcode 11 beta 7) lacks a <a href=""http://reactivex.io/documentation/operators/distinct.html"" rel=""nofollow noreferrer""><code>distinct</code></a> operator? </p>

<p>Can anyone help me build one? :) </p>
","1311272","","","","","2019-09-25 02:21:36","Swift Combine: no `distinct` operator?","<ios><swift><swiftui><xcode11><combine>","2","0","","","","CC BY-SA 4.0"
"57766270","1","57779331","","2019-09-03 06:43:09","","3","1104","<p>I want my app to periodically fetch new records and stores them in Core Data. I have a label on my UI that should display the number of elements for a particular record and I want that number to be updated as more records are added into the database. As an exercise, I want to use Combine to accomplish it.</p>

<p>I'm able to display the number of elements in the database when the app launches, but the number doesn't get updated when new data enters into the database (I verified that new data was being added by implementing a button that would manual refresh the UI).</p>

<p>Here's the code that displays the correct number of elements on launch but doesn't update when new records are added:</p>

<pre class=""lang-swift prettyprint-override""><code>let replayRecordFetchRequest: NSFetchRequest&lt;ReplayRecord&gt; = ReplayRecord.fetchRequest()

_ = try? persistentContainer.viewContext.fetch(replayRecordFetchRequest).publisher.count().map { String(format: Constants.Strings.playsText, $0) }.assign(to: \.text, on: self.playsLabel)
</code></pre>

<p>Here's a code snippet from the WWDC 2019 Session 230 talk that I adapted but this doesn't work at all (the subscriber is never fired):</p>

<pre class=""lang-swift prettyprint-override""><code>let replayRecordFetchRequest: NSFetchRequest&lt;ReplayRecord&gt; = ReplayRecord.fetchRequest()

if let replayRecords = try? replayRecordFetchRequest.execute() {
    _ = replayRecords.publisher.count().map { String(format: Constants.Strings.playsText, $0) }.assign(to: \.text, on: self.playsLabel)
}
</code></pre>
","5481276","","","","","2019-09-03 22:13:59","How to use Combine to assign the number of elements returned from a Core Data fetch request?","<swift><core-data><combine>","1","0","2","","","CC BY-SA 4.0"
"57768427","1","59740480","","2019-09-03 09:06:04","","11","8537","<p>I'm trying to achieve something similar to scenario presented below (create URL, request to server, decode json, error on every step wrapped in custom <code>NetworkError</code> enum):</p>

<pre class=""lang-swift prettyprint-override""><code>enum NetworkError: Error {
    case badUrl
    case noData
    case request(underlyingError: Error)
    case unableToDecode(underlyingError: Error)
}

//...
    func searchRepos(with query: String, success: @escaping (ReposList) -&gt; Void, failure: @escaping (NetworkError) -&gt; Void) {
        guard let url = URL(string: searchUrl + query) else {
            failure(.badUrl)
            return
        }

        session.dataTask(with: url) { data, response, error in
            guard let data = data else {
                failure(.noData)
                return
            }

            if let error = error {
                failure(.request(underlyingError: error))
                return
            }

            do {
                let repos = try JSONDecoder().decode(ReposList.self, from: data)

                DispatchQueue.main.async {
                    success(repos)
                }
            } catch {
                failure(.unableToDecode(underlyingError: error))
            }
        }.resume()
    }
</code></pre>

<p>My solution in Combine works:</p>

<pre class=""lang-swift prettyprint-override""><code>    func searchRepos(with query: String) -&gt; AnyPublisher&lt;ReposList, NetworkError&gt; {
        guard let url = URL(string: searchUrl + query) else {
            return Fail(error: .badUrl).eraseToAnyPublisher()
        }

        return session.dataTaskPublisher(for: url)
            .mapError { NetworkError.request(underlyingError: $0) }
            .map { $0.data }
            .decode(type: ReposList.self, decoder: JSONDecoder())
            .mapError { $0 as? NetworkError ?? .unableToDecode(underlyingError: $0) }
            .subscribe(on: DispatchQueue.global())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
</code></pre>

<p>but I really don't like this line</p>

<pre><code>.mapError { $0 as? NetworkError ?? .unableToDecode(underlyingError: $0) }
</code></pre>

<p>My questions:</p>

<ol>
<li>Is there better way to map errors (and replace line above) using chaining in Combine? </li>
<li>Is there any way to include first <code>guard let</code> with <code>Fail(error:)</code> in chain?</li>
</ol>
","2369731","","2369731","","2019-09-03 11:47:45","2020-01-14 23:07:13","Swift Combine chaining .mapError()","<swift><combine>","2","0","5","","","CC BY-SA 4.0"
"57794057","1","","","2019-09-04 18:33:52","","3","3924","<p>I'm building a basic notes app where the main page of my app should display a list of the user's notes. A note is represented with the Note class, a Core Data-generated class. (My ultimate goal is a notes app that syncs with CloudKit via NSPersistentCloudKitContainer.)</p>

<p>So far, when a user loads the app, the List displays the correct notes data. However, when I attempt to create a new note by tapping my <code>newNoteButton</code>, the array of Notes changes, but my UI doesn't change. I have to reload the app to see the new note. What could I be doing wrong? Sorry for the messy code below:</p>

<p><strong>NoteList.swift</strong></p>

<pre class=""lang-swift prettyprint-override""><code>struct NoteList: View {

  @EnvironmentObject var userNotes: UserNotes

  var newNoteButton: some View {
    Button(action: {
      self.userNotes.createNewNote()
      self.userNotes.objectWillChange.send()
    }) {
      Image(systemName: ""plus"")
        .imageScale(.large)
        .accessibility(label: Text(""New Note""))
    }
  }

  var body: some View {
    NavigationView {
      List {
        ForEach(self.userNotes.notes) { note in
          NavigationLink(destination: NoteDetail(note: self.$userNotes.notes[self.userNotes.notes.firstIndex(of: note)!])) {
            Text(note.unsecuredContent!)
          }
        }
      }
      .navigationBarTitle(Text(""Notes""), displayMode: .inline)
      .navigationBarItems(trailing: newNoteButton)
    }
  }

}
</code></pre>

<p><strong>UserNotes.swift</strong></p>

<pre class=""lang-swift prettyprint-override""><code>class UserNotes: NSObject, ObservableObject {

  @Published var notes: [Note] = []

  var managedObjectContext: NSManagedObjectContext? = nil

  var fetchedResultsController: NSFetchedResultsController&lt;Note&gt; {
    if _fetchedResultsController != nil {
      return _fetchedResultsController!
    }

    let fetchRequest: NSFetchRequest&lt;Note&gt; = Note.fetchRequest()

    // Set the batch size to a suitable number.
    fetchRequest.fetchBatchSize = 20

    // Edit the sort key as appropriate.
    let sortDescriptor = NSSortDescriptor(key: ""unsecuredContent"", ascending: false)

    fetchRequest.sortDescriptors = [sortDescriptor]

    // Edit the section name key path and cache name if appropriate.
    // nil for section name key path means ""no sections"".
    let aFetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest,
                                                               managedObjectContext: self.managedObjectContext!,
                                                               sectionNameKeyPath: nil, cacheName: ""Master"")
    aFetchedResultsController.delegate = self
    _fetchedResultsController = aFetchedResultsController

    do {
      try _fetchedResultsController!.performFetch()
    } catch {
      // Replace this implementation with code to handle the error appropriately.
      // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
      let nserror = error as NSError
      fatalError(""Unresolved error \(nserror), \(nserror.userInfo)"")
    }

    return _fetchedResultsController!
  }
  var _fetchedResultsController: NSFetchedResultsController&lt;Note&gt;? = nil

  override init() {
    super.init()
    managedObjectContext = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext
    notes = fetchedResultsController.sections![0].objects as! [Note]
  }

  func createNewNote() {
    let newNote = Note(context: managedObjectContext!)

    // If appropriate, configure the new managed object.
    newNote.unsecuredContent = ""New CloudKit note""

    // Save the context.
    do {
      try managedObjectContext!.save()
    } catch {
      // Replace this implementation with code to handle the error appropriately.
      // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
      let nserror = error as NSError
      fatalError(""Unresolved error \(nserror), \(nserror.userInfo)"")
    }
  }

}

extension UserNotes: NSFetchedResultsControllerDelegate {

  func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
    notes = controller.sections![0].objects as! [Note]
  }

}
</code></pre>

<p><strong>Note.swift (generated by Core Data)</strong></p>

<pre class=""lang-swift prettyprint-override""><code>//  This file was automatically generated and should not be edited.
//

import Foundation
import CoreData

@objc(Note)
public class Note: NSManagedObject {

}
</code></pre>

<p><strong>Note.swift (extension)</strong></p>

<pre class=""lang-swift prettyprint-override""><code>extension Note: Identifiable {}
</code></pre>
","2852849","","","","","2020-06-02 15:55:42","My SwiftUI List won't update when my @Published array of NSManagedObjects changes","<swiftui><combine>","2","2","2","","","CC BY-SA 4.0"
"57796877","1","57806993","","2019-09-04 23:59:19","","7","7998","<p>Before this question gets marked as duplicate of <a href=""https://stackoverflow.com/questions/57199922/create-a-timer-publisher-using-swift-combine"">this other question</a>, I am trying to understand how the publisher works as it behaves in a way I do not expect.</p>

<p>Using the same example as the answer from the question previously stated:
</p>

<pre><code>// Let's define the view model with my view...
import Combine
import SwiftUI

class TimerViewModel: ObservableObject {
  private let cancellable: AnyCancellable?

  let intervalPublisher = Timer.TimerPublisher(
                            interval: 1.0, 
                            runLoop: .main, 
                            mode: .default)

  init() {
    self.cancellable = timerPublisher.connect() as? AnyCancellable
  }

  deinit {
    self.cancellable?.cancel()
  }
}

struct Clock : View {
  @EnvironmentObject var viewModel: TimerViewModel
  @State private var currentTime: String = ""Initial""


  var body: some View {
    VStack {
      Text(currentTime)
    }
    .onReceive(timer.intervalPublisher) { newTime in
      self.currentTime = String(describing: newTime)
    }
  }
}
</code></pre>

<p>At this stage, all I wanted to do is my view model to publish the value directly. I don't want to have to declare the view will be receiving these sorts of values.</p>

<p>Ideally, I want to turn my publisher into a published properly... I though that the following code would work:</p>

<pre class=""lang-swift prettyprint-override""><code>// Let's define the view model with my view...
import Combine
import SwiftUI

class TimerViewModel: ObservableObject {
  private let cancellable: AnyCancellable?
  private let assignCancellable: AnyCancellable?

  let intervalPublisher = Timer.TimerPublisher(
                            interval: 1.0, 
                            runLoop: .main, 
                            mode: .default)
 @Published var tick: String = ""0:0:0""

  init() {
    cancellable = intervalPublisher.connect() as? AnyCancellable

    assignCancellable = intervalPublisher
                              .map { new in String(describing: new) }
                              .assign(to: \TimerViewModel.tick, on: self)
  }

  deinit {
    cancellable?.cancel()
    assignCancellable?.cancel()
  }
}

struct Clock : View {
  @EnvironmentObject var viewModel: TimerViewModel
  @State private var currentTime: String = ""Initial""


  var body: some View {
    VStack {
      Text(currentTime)
      Text(viewModel.tick) // why doesn't this work?
    }
    .onReceive(timer.intervalPublisher) { newTime in
      self.currentTime = String(describing: newTime)
    }
  }
}
</code></pre>

<p>What am I doing wrong for my <code>assign</code>?</p>

<p>Why isn't triggering?</p>

<p><em>Edit: the environment object was set on the <code>SceneDelegate</code> once the Clock view was created. The code excluded is attached below:</em></p>

<pre class=""lang-swift prettyprint-override""><code>    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).

        // Create the SwiftUI view that provides the window contents.
        let view = Clock().environmentObject(TimerViewModel())

        // Use a UIHostingController as window root view controller.
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: view)
            self.window = window
            window.makeKeyAndVisible()
        }
    }
</code></pre>
","332948","","332948","","2019-09-05 12:03:56","2021-04-11 20:43:38","Swift Combine: Using timer publisher in an observable object","<swift><xcode><swiftui><xcode11><combine>","3","4","3","","","CC BY-SA 4.0"
"57808811","1","57831518","","2019-09-05 15:35:32","","5","6285","<p>I have a content view and I want to track dynamically the height.</p>

<p>I have implemented this solution but i encounter this Exception :</p>

<blockquote>
  <p>Fatal error: Accessing State outside View.body: file</p>
</blockquote>

<p>What can i do to have keyboardHeight dynamic which can update my UI </p>

<pre><code>struct ContentView: View {

    @State var keyboardHeight: CGFloat = 0
    var cancellables: Set&lt;AnyCancellable&gt; = []

    init() {
        NotificationCenter.default.publisher(for: UIResponder.keyboardWillChangeFrameNotification)
        .merge(with: NotificationCenter.default.publisher(for: UIResponder.keyboardWillHideNotification))
        .compactMap({ notification in
          guard let keyboardFrameValue: NSValue = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue else { return nil }
          let keyboardFrame = keyboardFrameValue.cgRectValue
          if keyboardFrame.origin.y == UIScreen.main.bounds.height {
            return 0
          } else {
            return keyboardFrame.height - (UIApplication.shared.windows.first?.safeAreaInsets.bottom ?? 0)
          }
        })
        .assign(to: \.keyboardHeight, on: self)
        .store(in: &amp;cancellables)
    }

    var body: some View {
        VStack{
            ZStack(alignment: Alignment.bottom) {
                List {
                    Text(""Default text"").foregroundColor(Color.red)
                }
                TextField(""Placeholder"", text: .constant(""""))
                    .frame(minHeight: 30)
                    .cornerRadius(8.0)
                    .padding(10)
                    .background(Color.blue)
            }
            Spacer()
                .frame(height: keyboardHeight)
        }
    }
}
</code></pre>
","2611161","","1226963","","2019-09-05 15:37:50","2019-09-07 07:11:18","Accessing state variable in SwiftUI View outside the body","<swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"57814264","1","57820808","","2019-09-06 00:13:33","","3","4551","<p>I load endpoints from a RESTful server from which some are multipage. They are denoted by an 'x-pages' field in the header response. I want to create a publisher that will return all of the objects from all of pages as a single array.</p>

<p>There is a compilation error on the last return statement.</p>

<pre><code>Cannot convert return expression of type 'AnyPublisher&lt;AnyPublisher&lt;[T], LoadingError&gt;, LoadingError&gt;\' to return type 'AnyPublisher&lt;[T], LoadingError&gt;'
</code></pre>

<p>How do I fix this ""embedded"" publisher?</p>

<pre><code>import Combine
import Foundation

enum LoadingError: Error {
    case url(URLError)
    case decode(Error)
    case couldNotDetermieLastPageNumber(URL)
}

func multipageDataTaskPublishter&lt;T&gt;(for endpoint: Endpoint) -&gt; AnyPublisher&lt;[T], LoadingError&gt; where T: Decodable {
    assert(endpoint.page == 1)
    let publisher = URLSession.shared.dataTaskPublisher(for: endpoint.url)
        .retry(1)
        .mapError { LoadingError.url($0) }
        .map { (arg) -&gt; AnyPublisher&lt;[T], LoadingError&gt; in
            let (_, response) = arg
            guard
                let header = response as? HTTPURLResponse,
                let xpages = header.value(forHTTPHeaderField: ""x-pages""),
                let lastPage = Int(xpages)
            else {
                return Fail(error: LoadingError.couldNotDetermieLastPageNumber(endpoint.url))
                    .eraseToAnyPublisher()
            }

            let publishers = (1...lastPage).map { page -&gt; AnyPublisher&lt;[T], LoadingError&gt; in
                let next = endpoint.for(page: page)
                return URLSession.shared.dataTaskPublisher(for: next.url)
                    .retry(1)
                    .mapError { LoadingError.url($0) }
                    .map { $0.data }
                    .decode(type: [T].self, decoder: JSONDecoder())
                    .mapError { LoadingError.decode($0) }
                    .eraseToAnyPublisher()
            }
            return Publishers.Sequence(sequence: publishers)
                .flatMap { $0 }
                .reduce([], +)
                .eraseToAnyPublisher()
        }
    return publisher.eraseToAnyPublisher()
}
</code></pre>

<p>I could add a Sink immediately after the guard to read the lastPage value when the multipage publisher is created. Then with the <code>let publishers = ...</code> section lifted out of map up one level, my Publishers.Sequence return value would be correct. But this seems wrong on many levels; split execution, not composable.</p>

<p>Additionally I realize that my implementation loads the first page twice. Splitting the pipeline and merging Data payloads later would be better and I want to get to that solution but I need to wrap my head around this problem first. If this is a hopeless cause, then so be it and any idiomatic Combine solution will be accepted.</p>
","2256008","","2890168","","2019-09-14 08:39:10","2019-09-14 08:39:10","How Can I Flatten An AnyPublisher<AnyPublisher<>>?","<swift><combine>","1","1","1","","","CC BY-SA 4.0"
"57826430","1","","","2019-09-06 17:36:30","","28","24859","<p>I've been experimenting with the MVVM model that's used in <code>SwiftUI</code> and there are some things I don't quite get yet.</p>

<p><code>SwiftUI</code> uses <code>@ObservableObject</code>/<code>@ObservedObject</code> to detect changes in a view model that trigger a recalculation of the <code>body</code> property to update the view.</p>

<p>In the MVVM model, that's the communication between the view and the view model. What I don't quite understand is how the model and the view model communicate.</p>

<p>When the model changes, how is the view model supposed to know that? I thought about manually using the new <code>Combine</code> framework to create publishers inside the model that the view model can subscribe to.</p>

<p>However, I created a simple example that makes this approach pretty tedious, I think. There's a model called <code>Game</code> that holds an array of <code>Game.Character</code> objects. A character has a <code>strength</code> property that can change.</p>

<p>So what if a view model changes that <code>strength</code> property of a character? To detect that change, the model would have to subscribe to every single character that the game has (among possibly many other things). Isn't that a little too much? Or is it normal to have many publishers and subscribers?</p>

<p>Or is my example not properly following MVVM? Should my view model not have the actual model <code>game</code> as property? If so, what would be a better way?</p>

<pre class=""lang-swift prettyprint-override""><code>// My Model
class Game {

  class Character {
    let name: String
    var strength: Int
    init(name: String, strength: Int) {
      self.name = name
      self.strength = strength
    }
  }

  var characters: [Character]

  init(characters: [Character]) {
    self.characters = characters
  }
}

// ...

// My view model
class ViewModel: ObservableObject {
  let objectWillChange = PassthroughSubject&lt;ViewModel, Never&gt;()
  let game: Game

  init(game: Game) {
    self.game = game
  }

  public func changeCharacter() {
     self.game.characters[0].strength += 20
  }
}

// Now I create a demo instance of the model Game.
let bob = Game.Character(name: ""Bob"", strength: 10)
let alice = Game.Character(name: ""Alice"", strength: 42)
let game = Game(characters: [bob, alice])

// ..

// Then for one of my views, I initialize its view model like this:
MyView(viewModel: ViewModel(game: game))

// When I now make changes to a character, e.g. by calling the ViewModel's method ""changeCharacter()"", how do I trigger the view (and every other active view that displays the character) to redraw?
</code></pre>

<p>I hope it's clear what I mean. It's difficult to explain because it is confusing</p>

<p>Thanks!</p>
","3134192","","","","","2020-01-01 05:39:58","SwiftUI and MVVM - Communication between model and view model","<swift><swiftui><combine>","4","2","13","","","CC BY-SA 4.0"
"57833890","1","57835011","","2019-09-07 12:55:25","","2","1129","<p>I have an object which I want to send throughout multiple listeners/subscribers, so I was checking out Combine and I saw 2 different kind of publishers, namely <code>NotificationCenter.Publisher</code> and <code>PassThroughSubject</code>. I am confused why anyone would use a <code>NotificationCenter.Publisher</code> over <code>PassThroughSubject</code>. </p>

<p>I came up with the code below, demonstrating both ways. To summarize:</p>

<ul>
<li><code>NotificationCenter.Publisher</code> needs to have a <code>Notification.Name</code> static property</li>
<li>Isn't really that typesafe (since I can post a different kind of object for the same <code>Notification.Name</code>/different publisher for the same <code>Notification.Name</code>)</li>
<li>Posting a new value needs to be done on <code>NotificationCenter.default</code> (not the publisher itself)</li>
<li>An explicit downcast to the used type in the <code>map</code> closure</li>
</ul>

<p>In what scenarios someone will use <code>NotificationCenter.Publisher</code> over <code>PassThroughSubject</code>? </p>

<pre><code>import UIKit
import Combine

let passThroughSubjectPublisher = PassthroughSubject&lt;String, Never&gt;()
let notificationCenterPublisher = NotificationCenter.default.publisher(for: .name).map { $0.object as! String }

extension Notification.Name {
    static let name = Notification.Name(rawValue: ""someName"")
}


class PassThroughSubjectPublisherSubscriber {
    init() {
        passThroughSubjectPublisher.sink { (_) in
            // Process
        }
    }
}

class NotificationCenterPublisherSubscriber {
    init() {
        notificationCenterPublisher.sink { (_) in
            // Process
        }
    }
}

class PassThroughSubjectPublisherSinker {
    init() {
        passThroughSubjectPublisher.send(""Henlo!"")
    }
}

class NotificationCenterPublisherSinker {
    init() {
        NotificationCenter.default.post(name: .name, object: ""Henlo!"")
    }
}
</code></pre>
","7715250","","","","","2019-09-09 17:34:46","NotificationCenter.Publisher VS PassThroughSubject","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"57836235","1","","","2019-09-07 18:01:13","","4","5087","<p>I understand that the change of the @State variable notifies the @Binding that the state has changed but what then causes the updateUIView() method to be called? There is obviously some hidden connection between the @Binding and the call, but how does that work?</p>

<pre><code>//  Experiment_Map_View.swift

import SwiftUI
import MapKit

struct Experiment_Map_View: UIViewRepresentable {
    @Binding var test: Bool

    func updateUIView(_ uiView: MKMapView, context: Context) {
        print(""updateUIView"")
        print(test)
    }

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }

    final class Coordinator: NSObject, MKMapViewDelegate {
        var control: Experiment_Map_View

        init(_ control: Experiment_Map_View) {
            print(""init -----------------"")
            self.control = control
        }

    }

    func makeUIView(context: Context) -&gt; MKMapView {
         print(""makeUIView"")
        let map = MKMapView()
        map.delegate = context.coordinator
        return map
    }
}

struct MyRootView: View {
    @State var test: Bool = true

    var body: some View {
        ZStack {
            Experiment_Map_View(test: $test)
            VStack {
                Spacer()
                Button(""Next"") {
                    print(""Next"")
                    self.test.toggle()
                }
            }
        }
    }

}

struct Experiment_Map_View_Previews: PreviewProvider {
    static var previews: some View {
        MyRootView()
    }
}
</code></pre>
","2924513","","","","","2019-09-07 22:51:40","What causes updateUIView() to be called in this code?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"57836518","1","","","2019-09-07 18:40:10","","6","1500","<p>I'm wondering if there is a way to implement reconnection mechanism with new Apple framework Combine and use of URLSession publisher</p>

<ul>
<li>tried to find some examples in WWDC 2019</li>
<li>tried to play with <code>waitsForConnectivity</code> with no luck (it even not calling delegate on custom session)</li>
<li>tried <code>URLSession.background</code> but it crashed during publishing. </li>
</ul>

<p>I'm also not understanding how do we track progress in this way<br>
Does anyone already tried to do smth like this?</p>

<p>upd: <br>
It seems like <code>waitsForConnectivity</code> <a href=""https://developer.apple.com/documentation/ios_ipados_release_notes/ios_ipados_13_beta_8_release_notes"" rel=""nofollow noreferrer"">is not working</a> in Xcode 11 Beta</p>

<p>upd2:<br>
Xcode 11 GM - <code>waitsForConnectivity</code> is working but <strong>ONLY</strong> on device. Use default session, set the flag and implement session delegate. Method <code>task is waiting for connectivity</code> will be invoked no matter if u r using init task with callback or without. </p>

<pre><code>public class DriverService: NSObject, ObservableObject {

    public var decoder = JSONDecoder()
    public private(set) var isOnline = CurrentValueSubject&lt;Bool, Never&gt;(true)

    private var subs = Set&lt;AnyCancellable&gt;()
    private var base: URLComponents
    private  lazy var session: URLSession = {
        let config = URLSessionConfiguration.default
        config.waitsForConnectivity = true
        return URLSession(configuration: config, delegate: self, delegateQueue: nil)
    }()

    public init(host: String, port: Int) {

        base = URLComponents()
        base.scheme = ""http""
        base.host = host
        base.port = port

        super.init()

//      Simulate online/offline state
//
//        let pub = Timer.publish(every: 3.0, on: .current, in: .default)
//        pub.sink { _ in
//            let rnd = Int.random(in: 0...1)
//            self.isOnline.send(rnd == 1)
//        }.store(in: &amp;subs)
//        pub.connect()
    }

    public func publisher&lt;T&gt;(for driverRequest: Request&lt;T&gt;) -&gt; AnyPublisher&lt;T, Error&gt; {

        var components = base
        components.path = driverRequest.path

        var request = URLRequest(url: components.url!)
        request.httpMethod = driverRequest.method

        return Future&lt;(data: Data, response: URLResponse), Error&gt; { (complete) in
            let task = self.session.dataTask(with: request) { (data, response, error) in
                if let err = error {
                    complete(.failure(err))
                } else {
                    complete(.success((data!, response!)))
                }
                self.isOnline.send(true)
            }
            task.resume()
        }
        .map({ $0.data })
        .decode(type: T.self, decoder: decoder)
        .eraseToAnyPublisher()
    }
}

extension DriverService: URLSessionTaskDelegate {

    public func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask) {
        self.isOnline.send(false)
    }

}
</code></pre>
","3613463","","1000551","","2019-12-07 10:00:09","2020-05-08 07:50:28","Implementing reconnection with URLSession publisher and Combine","<swift><combine>","2","0","3","","","CC BY-SA 4.0"
"57836990","1","57837054","","2019-09-07 19:48:36","","6","5038","<p>How do I build a dynamic list with @Binding-driven controls without having to reference the array manually? It seems obvious but using List or ForEach to iterate through the array give all sorts of strange errors.</p>

<pre><code>struct OrderItem : Identifiable {
    let id = UUID()
    var label : String
    var value : Bool = false
}

struct ContentView: View {
    @State var items = [OrderItem(label: ""Shirts""),
                        OrderItem(label: ""Pants""),
                        OrderItem(label: ""Socks"")]
    var body: some View {
        NavigationView {
            Form {
                Section {
                    List {
                        Toggle(items[0].label, isOn: $items[0].value)
                        Toggle(items[1].label, isOn: $items[1].value)
                        Toggle(items[2].label, isOn: $items[2].value)
                    }
                }
            }.navigationBarTitle(""Clothing"")
        }
    }
}
</code></pre>

<p>This doesn't work:</p>

<pre><code>            ...
                Section {
                    List($items, id: \.id) { item in
                        Toggle(item.label, isOn: item.value)
                    }
                }
            ...
</code></pre>

<blockquote>
  <p>Type '_' has no member 'id'</p>
</blockquote>

<p>Nor does:</p>

<pre><code>            ...
                Section {
                    List($items) { item in
                        Toggle(item.label, isOn: item.value)
                    }
                }
            ...
</code></pre>

<blockquote>
  <p>Generic parameter 'SelectionValue' could not be inferred</p>
</blockquote>
","1696358","","","","","2021-06-08 17:43:01","SwiftUI dynamic List with @Binding controls","<swiftui><combine><swiftui-list>","2","1","","","","CC BY-SA 4.0"
"57842609","1","","","2019-09-08 13:58:18","","29","14734","<p>In RxSwift it's pretty easy to bind a <code>Driver</code> or an <code>Observable</code> in a <code>View Model</code> to some observer in a <code>ViewController</code> (i.e. a <code>UILabel</code>).</p>

<p>I usually prefer to build a pipeline, with observables <strong>created from other observables</strong>, instead of ""imperatively"" pushing values, say via a <code>PublishSubject</code>).</p>

<p>Let's use this example: <strong>update a <code>UILabel</code> after fetching some data from the network</strong></p>

<hr>

<h2>RxSwift + RxCocoa example</h2>

<pre class=""lang-swift prettyprint-override""><code>final class RxViewModel {
    private var dataObservable: Observable&lt;Data&gt;

    let stringDriver: Driver&lt;String&gt;

    init() {
        let request = URLRequest(url: URL(string:""https://www.google.com"")!)

        self.dataObservable = URLSession.shared
            .rx.data(request: request).asObservable()

        self.stringDriver = dataObservable
            .asDriver(onErrorJustReturn: Data())
            .map { _ in return ""Network data received!"" }
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>final class RxViewController: UIViewController {
    private let disposeBag = DisposeBag()
    let rxViewModel = RxViewModel()

    @IBOutlet weak var rxLabel: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()

        rxViewModel.stringDriver.drive(rxLabel.rx.text).disposed(by: disposeBag)
    }
}
</code></pre>

<hr>

<h2>Combine + UIKit example</h2>

<p>In a UIKit-based project it seems like you can keep the same pattern:</p>

<ul>
<li>view model exposes publishers</li>
<li>view controller binds its UI elements to those publishers</li>
</ul>

<pre class=""lang-swift prettyprint-override""><code>final class CombineViewModel: ObservableObject {
    private var dataPublisher: AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt;
    var stringPublisher: AnyPublisher&lt;String, Never&gt;

    init() {
        self.dataPublisher = URLSession.shared
            .dataTaskPublisher(for: URL(string: ""https://www.google.it"")!)
            .eraseToAnyPublisher()

        self.stringPublisher = dataPublisher
            .map { (_, _) in return ""Network data received!"" }
            .replaceError(with: ""Oh no, error!"")
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>final class CombineViewController: UIViewController {
    private var cancellableBag = Set&lt;AnyCancellable&gt;()
    let combineViewModel = CombineViewModel()

    @IBOutlet weak var label: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()

        combineViewModel.stringPublisher
            .flatMap { Just($0) }
            .assign(to: \.text, on: self.label)
            .store(in: &amp;cancellableBag)
    }
}
</code></pre>

<hr>

<h2>What about SwiftUI?</h2>

<p>SwiftUI relies on property wrappers like <code>@Published</code> and protocols like <code>ObservableObject</code>, <code>ObservedObject</code> to automagically take care of bindings (As of <em>Xcode 11b7</em>).</p>

<p>Since (AFAIK) property wrappers cannot be ""created on the fly"", there's no way you can re-create the example above using to the same pattern.
The following <strong>does not compile</strong></p>

<pre class=""lang-swift prettyprint-override""><code>final class WrongViewModel: ObservableObject {
    private var dataPublisher: AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt;
    @Published var stringValue: String

    init() {
        self.dataPublisher = URLSession.shared
            .dataTaskPublisher(for: URL(string: ""https://www.google.it"")!)
            .eraseToAnyPublisher()

        self.stringValue = dataPublisher.map { ... }. ??? &lt;--- WRONG!
    }
}
</code></pre>

<p>The closest I could come up with is <strong>subscribing in your view model (UGH!)</strong> and <strong>imperatively update your property</strong>, which does not feel right and reactive at all.</p>

<pre class=""lang-swift prettyprint-override""><code>final class SwiftUIViewModel: ObservableObject {
    private var cancellableBag = Set&lt;AnyCancellable&gt;()
    private var dataPublisher: AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt;

    @Published var stringValue: String = """"

    init() {
        self.dataPublisher = URLSession.shared
            .dataTaskPublisher(for: URL(string: ""https://www.google.it"")!)
            .eraseToAnyPublisher()

        dataPublisher
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: {_ in }) { (_, _) in
            self.stringValue = ""Network data received!""
        }.store(in: &amp;cancellableBag)
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    @ObservedObject var viewModel = SwiftUIViewModel()

    var body: some View {
        Text(viewModel.stringValue)
    }
}
</code></pre>

<p>Is the ""old way of doing bindings"" to be forgotten and replaced, in this new <strong>UIViewController-less</strong> world?</p>
","184899","","","","","2022-08-01 11:50:10","Best data-binding practice in Combine + SwiftUI?","<ios><swift><swiftui><rx-swift><combine>","5","3","4","","","CC BY-SA 4.0"
"57878111","1","57884978","","2019-09-10 20:56:59","","2","3502","<p>I have an app in which it shows me data from an API. I made a service that gets the data, where URL(string = """") is the url of the API:</p>

<pre><code>class Webservice {

    func getAllMatches(completion: @escaping ([Matches.Matchs]?) -&gt; ()) {

        guard let url = URL(string: ""API"")
            else {
                fatalError(""URL is not correct!"")
        }
        URLSession.shared.dataTask(with: url) { data, _, _ in

            let matchs = try! JSONDecoder().decode([Matches.Matchs].self, from: data!)
            DispatchQueue.main.async {
                completion(matchs)
            }
        }.resume()
    }

}
</code></pre>

<p>Then I made a ViewModel in which the API fields were set:</p>

<pre><code>class MatchListViewModel: ObservableObject {

    @Published var matches = [MatchViewModel]()


    init() {
        fetchMatch()


    }

    func fetchMatch() {

        Webservice().getAllMatches { matches in

            if let matches = matches {
                self.matches = matches.map(MatchViewModel.init)
            }
        }
    }

}


class MatchViewModel {

    let id = UUID()

    var match: Matches.Matchs

    init(match: (Matches.Matchs)) {
        self.match = match
    }


    var championship: String {
        return self.match.championship.name
    }

    var local_Name: String {
        return self.match.local.name
    }

    var local_Image: String  {
        return self.match.local.image
    }

    var local_goals: Double {
        return self.match.local_goals
    }

    var local_penalty_goals: Double {
        return self.match.local_penalty_goals
    }
    var stadium_Name: String {
        return self.match.stadium.name
    }

}
</code></pre>

<p>In the API, there is a field that shows an image, which is contained in a URL, I leave an example:</p>

<pre><code>""local"":{  
     ""slug"":""nombre"",
     ""name"":""nombre"",
     ""short_name"":""nombre"",
     ""image"":""https://s3.amazonaws.com/funx-futbol/dashboard/ad.png""
 },
</code></pre>

<p>My question is: How can I display that image via that URL? The API query works, as it brings me the information I require, but I need to show me the image through that link, which I have not achieved.</p>

<p>Thanks for reading!</p>

<p><a href=""https://i.stack.imgur.com/Tc1Md.png"" rel=""nofollow noreferrer"">error</a></p>
","9397255","","7948372","","2021-02-26 10:46:56","2021-02-26 10:46:56","How can I display an image by an API URL? Swift","<swift><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"57887433","1","","","2019-09-11 10:46:08","","2","605","<p>So I have a <code>ParentView</code>, which has a <code>NavigationLink</code>, leading to a <code>UIViewControllerRepresentable</code>-conforming <code>PageViewController</code>.</p>

<p>Now that <code>ParentView</code> also has some subscription on some publisher. Whenever that one is fired, not only will the <code>ParentView</code> redraw all its content (which it should), it will also re-initialize the (already presenting) <code>PageViewController</code>.</p>

<p>That leads to stuttering/glitching, because the <code>PageViewController</code> is already presenting and using the controllers that are continually being resetted.</p>

<p>Below is the <code>ParentView</code> and  <code>PageViewController</code> (without the Coordinator stuff), both is pretty vanilla. The commented guard line is a hack I tried to prevent it from updating if displayed already. It helps but it's still stuttering on every swipe.</p>

<p>So the question is: How can we prevent the updating of a presented ViewController-wrapped-View when its presenting View is redrawn?</p>

<pre><code>struct ParentView: View {

    @Binding var something: Bool

    var body: some View {
        NavigationLink(destination: PageViewController(controllers: controllers)) {
            Text(""Push me"")
        }
    }
}
</code></pre>

<pre><code>final class PageViewController: UIViewControllerRepresentable {

    var controllers: [UIViewController]
    private var currentPage = 0

    init(controllers: [UIViewController]) {
        self.controllers = controllers
    }

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }

    func makeUIViewController(context: Context) -&gt; UIPageViewController {
        let pageViewController = UIPageViewController(
            transitionStyle: .scroll,
            navigationOrientation: .horizontal)
        pageViewController.dataSource = context.coordinator
        pageViewController.delegate = context.coordinator

        return pageViewController
    }

    func updateUIViewController(_ pageViewController: UIPageViewController, context: Context) {
        // I tried this: guard pageViewController.viewControllers!.isEmpty else { return }
        pageViewController.setViewControllers(
            [controllers[currentPage]], direction: .forward, animated: true)
    }
}
</code></pre>
","3740470","","3740470","","2019-09-11 14:38:34","2019-11-12 19:23:36","SwiftUI: NavigationLink's Destination initialized whenever its parent is redrawn","<swiftui><combine><navigationlink>","1","6","2","","","CC BY-SA 4.0"
"57930789","1","57930874","","2019-09-13 22:00:30","","3","961","<p>I'm having trouble getting the most simple implementation of the Combine pattern to work, subscribing to a UITextField textDidChangeNotification.</p>

<pre><code>import UIKit
import Combine

class ViewController: UIViewController {

    let textField = UITextField()

    override func viewDidLoad() {
        super.viewDidLoad()

        view.addSubview(textField)
        textField.frame = CGRect(x: 100, y: 0, width: view.frame.width, height: 100)
        textField.placeholder = ""Search""

        let sub = NotificationCenter.default.publisher(for: UITextField.textDidChangeNotification, object: textField)
            .sink { (notification) in
                print(""123"")
        }
    }

}

</code></pre>

<p>I must be missing something super simple, but this basic pattern is exactly copied from the Documentation and other tutorials.</p>

<p>Thanks for the help.</p>
","9267909","","","","","2021-06-29 19:36:14","Simple Swift Combine subscribing to textDidChangeNotification","<swift><frp><combine>","1","0","","","","CC BY-SA 4.0"
"57938603","1","","","2019-09-14 19:26:06","","5","1397","<p>I have this publisher and subscribers (example code):</p>

<pre><code>import Combine

let publisher = PassthroughSubject&lt;ComplexStructOrClass, Never&gt;()
let sub1 = publisher.sink { (someString) in
    // Async work...
}

let sub2 = publisher.sink { (someString) in
    // Async work, but it has to wait until sub1 has finished his work
}
</code></pre>

<p>So the <code>publisher</code> constant has 2 subscribers. When I use the method <code>send</code> on the <code>publisher</code> constant, it should send the value first to <code>sub1</code> and <strong>after</strong> <code>sub1</code> finished processing (with a callback or something like that), <code>publisher</code> should and notify <code>sub2</code>. </p>

<p>So in the comments its stated that Combine is made for this. What publisher do I need to use? A PassthroughSubject may be the wrong decision.</p>

<p><strong>Usecase</strong></p>

<p>I need to publish values throughout the lifetime of my app to a dynamic number of subscribers, for a few different publishers (I hope I can make a protocol). So a subscriber can be added and removed from a publisher at any given time. A subscriber look as follows:</p>

<ul>
<li>It has a <code>NSPersistentContainer</code></li>
<li><p>A callback should be made by the publisher when a new value has arrived. That process looks like: </p>

<ol>
<li>the publisher will create a backgroundContext of the container of the subscriber, because it knows a subscriber has a container</li>
<li>the publisher sends the context along with the new published value to the subscriber</li>
<li>the publisher waits until it receives a callback of the subscriber. The subscriber shouldn't save the context, but the publisher must hold a reference to the context. The subscriber gives a callback of an enum, which has a ok case and some error cases. </li>
<li>When a subscriber gives a callback with an error enum case, the publisher must rollback the contexts it created for each subscriber. </li>
<li>When a subscriber gives a callback with the ok case, the publisher repeats step 1 till 5 for every subscriber</li>
<li>This step will only be reached when no subscriber gave a error enum case or there are no subscribers. The publisher will save all the contexts created by the subscribers.</li>
</ol></li>
</ul>

<p><strong>Current code, no Combine</strong>
This is some code without using <code>Combine</code>:</p>

<pre><code>// My publisher
protocol NotiPublisher {

    // Type of message to send
    associatedtype Notification

    // List of subscribers for this publisher
    static var listeners: Set&lt;AnyNotiPublisher&lt;Notification&gt;&gt; { get set }
}

// My subscriber
protocol NotificationListener: Hashable {
    associatedtype NotificationType

    var container: NSPersistentContainer { get }
    // Identifier used to find this subscriber in the list of 'listeners' in the publisher
    var identifier: Int32 { get }
    var notify: ((_ notification: NotificationType, _ context: NSManagedObjectContext, @escaping CompletionHandlerAck) -&gt; ()) { get }
}

// Type erased version of the NotificationListener and some convience methods here, can add them if desired

// In a extension of NotiPublisher, this method is here
static func notify(queue: DispatchQueue, notification: Notification, completionHander: @escaping CompletionHandlerAck) throws {
    let dispatchGroup = DispatchGroup()
    var completionBlocks = [SomeCompletionHandler]()
    var contexts = [NSManagedObjectContext]()
    var didLoop = false

    for listener in listeners {
        if didLoop {
            dispatchGroup.wait()
        } else {
            didLoop = true
        }

        dispatchGroup.enter()

        listener.container.performBackgroundTask { (context) in
            contexts.append(context)

            listener.notify(notification, context, { (completion) in                    
                completionBlocks.append(completion)

                dispatchGroup.leave()
            })
        }
    }

    dispatchGroup.notify(queue: queue) {
        let err = completion.first(where: { element in
            // Check if an error has occured
        })

        if err == nil {
            for context in contexts {
                context.performAndWait {
                    try! context.save()
                }
            }
        }

        completionHander(err ?? .ok(true))
    }
}
</code></pre>

<p>This is pretty complex code, I am wondering if I can make use of the power of Combine to make this code more readable.</p>
","7715250","","7715250","","2019-09-16 11:06:55","2019-11-22 17:30:04","Create a Publisher that notifies subscribers one by one, waiting for eachother","<swift><combine>","2","5","0","","","CC BY-SA 4.0"
"57938881","1","57939476","","2019-09-14 20:06:03","","2","2636","<p>say I have an array of <code>Person</code> structs like this:</p>

<pre class=""lang-swift prettyprint-override""><code>struct Person {
    var name: String
}

var persons = [Person(name: ""A""), Person(name: ""B""), Person(name: ""C"")]

let publisher = CurrentValueSubject&lt;[Person], Never&gt;(persons)

// subscribe to changes to the array
let subscription: AnyCancellable = publisher.sink { (persons) in
    print(""The array has changed"")
}

var currentPersons = publisher.value
currentPersons[0].name = ""Changed""
publisher.send(currentPersons)
</code></pre>

<p>This works. It publishes every time anything in the array changes or if something is deleted or added.</p>

<p>But what if I wanted to additionally be able to subscribe to only one element in the array? Can I do that? I simply can't figure it out.</p>
","3134192","","","","","2019-09-14 21:42:46","Swift Combine Framework - How to properly observe an array?","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"57953112","1","","","2019-09-16 08:33:32","","23","8895","<p>Normally we can use <code>didSet</code> in swift to monitor the updates of a variable. But it didn't work for a <code>@Binding</code> variable. For example, I have the following code:</p>

<pre><code>@Binding var text {
   didSet {
       ......
   }
}
</code></pre>

<p>But the <code>didSet</code> is never been called.Any idea? Thanks.</p>
","118562","","","","","2022-06-11 20:49:37","didSet for a @Binding var in Swift","<swift><swiftui><combine>","3","4","2","","","CC BY-SA 4.0"
"57954754","1","","","2019-09-16 10:17:28","","0","120","<p>I am writing a program that need to attach/detach event handlers from event source dynamically.
This happens many times, and I don't want any message loss or duplication by attach/detach.</p>

<p>But it seems I am doing something wrong here to detach Combine subscribers.</p>

<pre><code>import Foundation
import Combine

let a = PassthroughSubject&lt;String,Never&gt;()
var b = a
    .buffer(size: .max, prefetch: .byRequest, whenFull: .customError({ fatalError() }))
    .receive(on: DispatchQueue.main)
    .sink(receiveValue: { print($0) })
a.send(""AAA"")
b.cancel()
a.send(""BBB"")
b = a
    .buffer(size: .max, prefetch: .byRequest, whenFull: .customError({ fatalError() }))
    .receive(on: DispatchQueue.main)
    .sink(receiveValue: { print($0) })
a.send(""CCC"")
RunLoop.main.run()
</code></pre>

<p>This prints this.</p>

<pre><code>AAA
BBB
CCC
CCC
</code></pre>

<p><code>CCC</code> is duplicated and <code>BBB</code> is unexpected. It seesms cancelling <code>b</code> doesn't detach it from its source <code>a</code>. It seems I am doing these things completely wrong.</p>

<p>What is proper way to attach/detach subscribers from subject? In this case, I want to attach/detach <code>b</code> from <code>a</code> dynamically.</p>

<ul>
<li>Xcode 11 GM.</li>
</ul>
","246776","","","","","2019-09-16 10:17:28","How to detach subscrber from a subject in Combine?","<swift><combine>","0","4","","","","CC BY-SA 4.0"
"57954846","1","","","2019-09-16 10:22:37","","0","262","<p>I have list of cities</p>

<pre><code>struct CityListView: View {

    @ObservedObject private(set) var citiesViewModel: CitiesViewModel

    var body: some View {
        LoadingView(isShowing: .constant(citiesViewModel.cities?.isEmpty ?? false)) {
            NavigationView {
                List(self.citiesViewModel.cities ?? []) { city in
                    NavigationLink(destination: DetailView(cityName: city.name,
                                                                    detailCityModel: DetailCityModel(cityId: city.id))) {
                                                                        Text(city.name)
                    }
                }
                .navigationBarTitle(Text(""Cities""), displayMode: .large)
            }
        }
    }
}
</code></pre>

<p>and when I'm scrolling the list, the DetailCityModel inits and download data from API. How to  downloading (or init DetailCityModel) on DetailView's appearance, not for showing item with NAvigationLink to DetailView?</p>
","5833351","","","","","2019-09-16 18:10:13","SwiftUI with ObservableObject - List having NavigationLink to details downloading it on scroll NOT on appear","<api><download><swiftui><ios13><combine>","1","0","","","","CC BY-SA 4.0"
"57980476","1","59972188","","2019-09-17 18:58:36","","27","7712","<p>I don't quite understand how to properly store subscribers inside a class so that they persist but don't prevent the object from being deinitialized. Here's an example where the object won't deinit:</p>

<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Combine

class Test {
    public var name: String = """"

    private var disposeBag: Set&lt;AnyCancellable&gt; = Set()

    deinit {
        print(""deinit"")
    }

    init(publisher: CurrentValueSubject&lt;String, Never&gt;) {
        publisher.assign(to: \.name, on: self).store(in: &amp;disposeBag)
    }
}

let publisher = CurrentValueSubject&lt;String, Never&gt;(""Test"")

var test: Test? = Test(publisher: publisher)
test = nil

</code></pre>

<p>When I replace the <code>assign</code> with a <code>sink</code> (in which I properly declare <code>[weak self]</code>) it actually does deinit properly (probably because the <code>assign</code> accesses <code>self</code> in a way that causes problems).</p>

<p>How can I prevent strong reference cycles when using <code>.assign</code> for instance?</p>

<p>Thanks</p>
","3134192","","","","","2022-09-14 16:04:51","How to prevent strong reference cycles when using Apple's new Combine framework (.assign is causing problems)","<swift><combine>","6","1","4","","","CC BY-SA 4.0"
"57982334","1","57987236","","2019-09-17 21:33:09","","2","497","<p>I'm trying to write a URL Validator in Swift w/ Combine and having a SwiftUI view subscribe to it. It seems to work fine in the simulator but crashes on my dev phone (running 13.1).</p>

<p>Scenario... User types into a UITextField which is connected to the urlString var in the view model. When that changes I clean the string, create a URL, and then do a HEAD test with URLSession. This all works in the sim, but on tap of the text field on the device it crashes the app and I'm not getting any good stack traces. Any ideas?</p>

<pre class=""lang-swift prettyprint-override""><code>static func testURLPublisher(string: String) -&gt; AnyPublisher&lt;URL?, Never&gt; {

        let validatedURL = try? validateURL(string: string)

        guard let urlToCheck = validatedURL else {
            return Just(nil).eraseToAnyPublisher()
        }

        var request = URLRequest(url: urlToCheck)
        request.httpMethod = ""HEAD""

        let publisher = URLSession.shared.dataTaskPublisher(for: request)
            .handleEvents(receiveSubscription: { _ in
                networkActivityPublisher.send(true)
            }, receiveCompletion: { _ in
                networkActivityPublisher.send(false)
            }, receiveCancel: {
                networkActivityPublisher.send(false)
            })
            .tryMap { data, response -&gt; URL? in
                // URL Responded - Check Status Code
                guard let urlResponse = response as? HTTPURLResponse, ((urlResponse.statusCode &gt;= 200 &amp;&amp; urlResponse.statusCode &lt; 400) || urlResponse.statusCode == 405) else {
                        throw URLValidatorError.serverError(""Could not find the a servr at: \(urlToCheck)"")
                }
                        return urlResponse.url?.absoluteURL
            }
        .catch { err in
            return Just(nil)
        }
        .eraseToAnyPublisher()
        return publisher
    }
</code></pre>

<p>The view that is using it looks like this...</p>

<pre class=""lang-swift prettyprint-override""><code>class NewSiteViewModel: ObservableObject {

    @Published var validatedURL: URL?

    //@Published var secretKey: String?
    @Published var urlString: String = """"

    @Published var isValidURL: Bool = false

    private var cancellable = Set&lt;AnyCancellable&gt;()

    init() {
        $urlString
        .dropFirst(1)
            .throttle(for: 0.5, scheduler: DispatchQueue(label: ""Validator""), latest: true)
            .removeDuplicates()
            .compactMap { string -&gt; AnyPublisher&lt;URL?, Never&gt; in
                return URL.testURLPublisher(string: string)
            }
            .switchToLatest()
            .receive(on: RunLoop.main)
            .sink { recievedURL in
                guard let url = recievedURL else {
                    self.validatedURL = nil
                    self.isValidURL = false
                    return
                }
                self.validatedURL = url
                self.isValidURL = true

            }
            .store(in: &amp;cancellable)
    }
}

</code></pre>
","6109747","","","","","2019-09-18 21:32:58","URL Verification Publisher","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"58012913","1","58014049","","2019-09-19 14:08:13","","4","3045","<pre><code>    struct Flashcard : View {
      @State var frontText = newArray[randomNum].kana
      @State var backText = newArray[randomNum].romaji

      var body: some View {
        let zstack = ZStack {
          Frontside(kanatext: frontText)
            .background(Color.yellow)
            .rotation3DEffect(.degrees(self.showResults ? 180.0 : 0.0), axis: (x: 0.0, y: 1.0, z: 0.0))
            .zIndex(self.showResults ? 0 : 1)
            .frame(width: 300, alignment: .center)
            .cornerRadius(25)
         }
      }

public struct Frontside: View
{
    @State public var kanatext: String = """"

    public var body: some View
    {
        Text(self.kanatext)
            .font(.title)
            .fontWeight(.black)
            .padding(32)
    }
}
</code></pre>

<p>In my code snippet above, when I update the @State var frontText, I'm expecting my view to refresh and display the frontText. But for some reason  it won't show the new frontText when it is used in my Frontside struct. If I just print Text(frontText) in my view, it will always refresh as the variable changes. What am I missing for it to refresh properly whenever frontText is updated? Thanks. </p>
","58521","","7948372","","2021-02-26 10:46:32","2021-02-26 10:46:32","View not updating after @state variable changes","<swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"58039894","1","","","2019-09-21 11:35:30","","2","161","<p>I have a <code>UITableView</code> that can go into edit mode by calling this method:</p>

<pre class=""lang-swift prettyprint-override""><code>tableView.setEditing(!tableView.isEditing, animated: true)
</code></pre>

<p>Now I want to observe the editing state of the tableView to update the text of a bar button item:</p>

<pre class=""lang-swift prettyprint-override""><code>tableView.publisher(for: \.isEditing).sink { [weak self] (isEditing) in
    self?.navigationItem.rightBarButtonItem?.title = isEditing ? ""Done"" : ""Edit""
}.store(in: &amp;disposeBag)
</code></pre>

<p>However, the publisher doesn't react to the changes to <code>tableView.isEditing</code>. Any idea why? It does fire upon initialization of <code>tableView</code>.</p>
","3134192","","","","","2019-09-21 11:35:30","Combine - UITableView.isEditing property publisher doesn't trigger when value changed","<ios><swift><uitableview><combine>","0","0","","","","CC BY-SA 4.0"
"58047126","1","","","2019-09-22 07:46:52","","4","1451","<p>I'm learning <code>Swift</code>´s <code>Combine</code> by making an app, trying to solve real world use cases. </p>

<p>A common case, I'm performing a request, and the auth token expired. I would like to refresh the token if the request fails with a 401.</p>

<p>Something like: </p>

<pre><code>fetchData()
   .flatMap { data, response
      if response.statusCode == 401 {
         refreshToken()
            .fetchData()
      } else {
         Just(data)
      }
   }
   .keepDoingThings()

</code></pre>

<p>Keep in mind this is just pseudo code.</p>

<p>I have tried a few things indeed, but it's a mess. :) </p>

<p>How can this be done?</p>

<p>Thank you!</p>
","919445","","919445","","2019-09-24 06:26:39","2019-09-28 04:31:21","How to retry a request after performing authentication?","<swift><combine>","2","1","1","","","CC BY-SA 4.0"
"58064859","1","58153405","","2019-09-23 14:40:48","","0","579","<p>Apple says:</p>

<blockquote>
  <p>Combine also provides a built-in publisher for any
  property that’s compliant with Key-Value Observing.</p>
</blockquote>

<p>So, I have an instance of UITextView inside of a view controller view which should emit a signal via publisher when a user taps a keyboard but it doesn't happens. Below a snipet of code which explains my way of subscribing to a publisher</p>

<pre><code>class MyViewController : UIViewController {

    var t = UITextView(frame: .init(x: 0, y: 0, width: 100, height: 20))


    override func viewDidLoad() {
    super.viewDidLoad()

        t.publisher(for: \UITextView.text)
            .receive(on: RunLoop.main)
            .sink { (str) in
                print(str)
        }

        view.addSubview(t)
    }
}
</code></pre>
","1180728","","1000551","","2019-12-07 09:59:40","2019-12-07 09:59:40","UITextView publisher doesn't publish a signal when a user taps a keyboard","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"58067075","1","58070916","","2019-09-23 17:01:51","","22","26470","<p>I am getting the above error and couldn't figure out how to solve it. I have an array of objects that contain a boolean value, and need to show a toggle for each of these boolean.</p>

<p>Below is the code.</p>

<pre><code>class Item: Identifiable {
    var id: String
    var label: String
    var isOn: Bool
}

class Service: ObservableObject {
    var didChange = PassthroughSubject&lt;Void, Never&gt;()

    var items: [Item] {
        didSet {
            didChange.send(())
        }
    }
}

struct MyView: View {
    @ObservedObject var service: Service

    var body: some View {
        List {
            ForEach(service.items, id: \.self) { (item: Binding&lt;Item&gt;) in
                Section(header: Text(item.label)) {  // Error: Initializer 'init(_:)' requires that 'Binding&lt;String&gt;' conform to 'StringProtocol'
                    Toggle(isOn: item.isOn) {
                        Text(""isOn"")
                    }
                }
            }
        }
        .listStyle(GroupedListStyle())
    }
}
</code></pre>
","1366265","","","","","2019-09-24 14:45:49","Error: Initializer 'init(_:)' requires that 'Binding<String>' conform to 'StringProtocol'","<swift><swiftui><combine>","1","0","2","","","CC BY-SA 4.0"
"58068446","1","","","2019-09-23 18:47:46","","13","3215","<p>I have a Core Data model with an entity generated into class <code>Task</code>. I am trying to get the Combine publisher <code>objectWillChange</code> from the <code>NSManagedObject</code> to send (automatically, without manual work), but it won't. The task entity has a <code>name</code> attribute.</p>

<pre class=""lang-swift prettyprint-override""><code>let task = Task(context: container.viewContext)

let taskSubscription = task.objectWillChange.sink(receiveValue: { _ in
    print(""Task changed"")
})

task.name = ""Foo""              // WILL NOT trigger
</code></pre>

<p>If I call send manually, the subscription will work:</p>

<pre class=""lang-swift prettyprint-override""><code>task.objectWillChange.send()   // Will trigger
</code></pre>

<p>If I replace this with a simple <code>ObservableObject</code>, it will work as expected:</p>

<pre class=""lang-swift prettyprint-override""><code>class DummyTask: ObservableObject {
    @Published var name: String?
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>let dummy = DummyTask()
let dummySubscription = dummy.objectWillChange.sink(receiveValue: { _ in
    print(""Dummy changed"")
})

dummy.name = ""Foo""              // Will trigger
dummy.objectWillChange.send()   // Will trigger
</code></pre>

<p>Is NSManagedObject bugged? How should I observe the general entity object for changes? How should I get SwiftUI to see them?</p>

<p>This is using Xcode 11.0 and iOS 13.</p>
","3213985","","4183269","","2019-10-24 04:15:36","2022-08-12 14:02:29","NSManagedObject changes do not trigger objectWillChange","<swift><core-data><swiftui><combine>","3","6","7","","","CC BY-SA 4.0"
"58069967","1","58070552","","2019-09-23 20:44:49","","3","2343","<p>I want to create <code>MyViewModel</code> which gets data from network and then updates the arrray of results. <code>MyView</code> should subscribe to the <code>$model.results</code> and show <code>List</code> filled with the results.</p>

<p>Unfortunately I get an error about ""Type of expression is ambiguous without more context"".</p>

<p>How to properly use <code>ForEach</code> for this case?</p>

<pre><code>import SwiftUI
import Combine

class MyViewModel: ObservableObject {
    @Published var results: [String] = []

    init() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.results = [""Hello"", ""World"", ""!!!""]
        }
    }
}

struct MyView: View {
    @ObservedObject var model: MyViewModel

    var body: some View {
        VStack {
            List {
                ForEach($model.results) { text in
                    Text(text)
                 // ^--- Type of expression is ambiguous without more context
                }
            }
        }
    }
}

struct MyView_Previews: PreviewProvider {
    static var previews: some View {
        MyView(model: MyViewModel())
    }
}
</code></pre>

<p>P.S. If I replace the model with <code>@State var results: [String]</code> all works fine, but I need have separate <code>class MyViewModel: ObservableObject</code> for my purposes</p>
","1062636","","1062636","","2019-09-23 20:52:14","2019-09-24 12:45:46","How to bind an array and List if the array is a member of ObservableObject?","<swift><swiftui><combine><swiftui-list>","1","0","1","","","CC BY-SA 4.0"
"58082208","1","58083118","","2019-09-24 14:10:37","","5","1768","<p>We have the practice of using safe subscript when accessing any element in a collection. Below is the extension we have.</p>

<pre><code>extension Collection {
    subscript(safe index: Index) -&gt; Element? {
        return indices.contains(index) ? self[index] : nil
    }
}
</code></pre>

<p>But when I try to use this with a binding object, it gives me an error saying</p>

<blockquote>
  <p>Extraneous argument label 'safe:' in subscript</p>
</blockquote>

<p>Below is the problematic code</p>

<pre><code>struct MyView: View {
    @ObservedObject var service: service

    var body: some View {
        List {
            ForEach(service.items.indices) { index in
                Toggle(isOn: self.$service.items[safe: index]?.isOn ?? false) {  // Error: Extraneous argument label 'safe:' in subscript
                    Text(""isOn"")
                }
            }
        }
    }
}
</code></pre>
","1366265","","1366265","","2019-09-24 15:11:26","2019-09-24 15:11:26","SwiftUI: Safe subscript for binding array","<swift><swiftui><combine>","2","3","1","","","CC BY-SA 4.0"
"58087559","1","58160320","","2019-09-24 20:17:39","","4","6091","<p>Hi I was just wondering is it possible to create a generic class confirming to ObservableObject protocol which can be used by more then one ContentViews.</p>

<p>If i can do that then I will be able make my ContentView and Model class completely generic and reusable.</p>

<p>An example of what i would like to achieve:</p>

<pre><code>protocol ContentViewModelType: ObservableObject {
    var propertyToInitialiseView: [String] { get }
}

struct ContentView: View {
    @ObservedObject var viewModel: some ViewModel

    var body: some View {
        Text(""Hello World"")
    }
}
</code></pre>

<p>If I can do that any class can implement ContentViewModelType and become a model for ContentView which makes it generic and reusable. For example</p>

<pre><code>class ViewModel: ObservableObject {
    var objectWillChange = PassthroughSubject&lt;ViewModel, Never&gt;()
}
</code></pre>

<p>But when i try to initialise ContentView that xcode gives me a type error.</p>

<p><a href=""https://i.stack.imgur.com/jzyPC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jzyPC.png"" alt=""enter image description here""></a></p>

<p>I thought the whole point of introducing some keyword was so that we can use protocol as type for those protocols that have associated type as a requirement and hence this should work. But it gives an error.</p>

<p>If anyone has any references or knowledge about this problem that they could share or possibly a solution for this it would be great.</p>

<p>Thanks in advance.</p>
","2506972","","","","","2019-09-30 00:56:04","Can I create a generic ObservableObject class which can be used by multiple ContentViews?","<ios><swift><swiftui><xcode11><combine>","3","3","1","","","CC BY-SA 4.0"
"58103186","1","58104451","","2019-09-25 16:52:16","","24","29616","<p>In my SwiftUI app, I need to get data from ObservedObject each time the value change. I understood that we could do that with .onReceive? I don't understand well the documentation of Apple about it. I don't know how I can do this.</p>
<p>My code:</p>
<pre><code>import SwiftUI
import CoreLocation

struct Compass: View {
  
  @StateObject var location = LocationManager()
  @State private var angle: CGFloat = 0
  
  var body: some View {
    VStack {
      Image(&quot;arrow&quot;)
        .resizable()
        .aspectRatio(contentMode: .fit)
        .frame(width: 300, height: 300)
        .modifier(RotationEffect(angle: -CGFloat(self.angle.degreesToRadians)))
        .onReceive(location, perform: {
          withAnimation(.easeInOut(duration: 1.0)) {
            self.angle = self.location.heading
          }
        })
      
      Text(String(self.location.heading.degreesToRadians))
        .font(.system(size: 20))
        .fontWeight(.light)
        .padding(.top, 15)
    }
  }
}

struct RotationEffect: GeometryEffect {
  var angle: CGFloat

  var animatableData: CGFloat {
    get { angle }
    set { angle = newValue }
  }

  func effectValue(size: CGSize) -&gt; ProjectionTransform {
    return ProjectionTransform(
      CGAffineTransform(translationX: -150, y: -150)
        .concatenating(CGAffineTransform(rotationAngle: angle))
        .concatenating(CGAffineTransform(translationX: 150, y: 150))
    )
  }
}
</code></pre>
<p>In my LocationManager class, I have a heading Published variable, this is the variable I want check.</p>
<p>I need to get data each time the value of heading change to create an animation when my arrow move. For some raisons I need to use CGAffineTransform.</p>
","7037428","","259521","","2020-12-28 16:30:21","2022-09-13 20:00:29","How can I get data from ObservedObject with onReceive in SwiftUI?","<swift><swiftui><combine>","4","0","5","","","CC BY-SA 4.0"
"58149396","1","","","2019-09-28 18:58:42","","2","408","<p>I'm looking at an example of using SwiftUI with Combine: <a href=""https://www.raywenderlich.com/4161005-mvvm-with-combine-tutorial-for-ios"" rel=""nofollow noreferrer"">MVVM with Combine Tutorial for iOS</a> at raywenderlich.com. A ViewModel implementation is given like this:</p>

<pre><code>class WeeklyWeatherViewModel: ObservableObject, Identifiable {
  // 2
  @Published var city: String = """"

  // 3
  @Published var dataSource: [DailyWeatherRowViewModel] = []

  private let weatherFetcher: WeatherFetchable

  // 4
  private var disposables = Set&lt;AnyCancellable&gt;()

  init(weatherFetcher: WeatherFetchable) {
    self.weatherFetcher = weatherFetcher
  }
}
</code></pre>

<p>So, this makes some sense to me. In a view observing the model, an instance of the ViewModel is declared as an <code>ObservedObject</code> like this:</p>

<pre><code>@ObservedObject var viewModel: WeeklyWeatherViewModel
</code></pre>

<p>And then it's possible to make use of the <code>@Published</code> properties in the model in the <code>body</code> definition of the View like this:</p>

<pre><code>TextField(""e.g. Cupertino"", text: $viewModel.city)
</code></pre>

<p>In <code>WeeklyWeatherViewModel</code> Combine is used to take the <code>city</code> text, make a request on it, and turn this in to <code>[DailyWeatherRowViewModel]</code>. Up to here, everything is rosey and makes sense.</p>

<p>Where I become confused is that quite a lot of code is then used to:</p>

<ul>
<li>Trigger a fetch when <code>city</code> is changed.</li>
<li>Keep hold of the <code>AnyCancellable</code> that's looking up weather data.</li>
<li>Copy the output of the weather look up in to <code>dataSource</code> by a <code>sink</code> on the weather fetch Publisher`</li>
</ul>

<p>It looks like this:</p>

<pre><code>  // More in WeeklyWeatherViewModel
init(
  weatherFetcher: WeatherFetchable,
  scheduler: DispatchQueue = DispatchQueue(label: ""WeatherViewModel"")
) {
  self.weatherFetcher = weatherFetcher

  _ = $city
    .dropFirst(1)
    .debounce(for: .seconds(0.5), scheduler: scheduler)
    .sink(receiveValue: fetchWeather(forCity:))
}

func fetchWeather(forCity city: String) {
  weatherFetcher.weeklyWeatherForecast(forCity: city)
    .map { response in
      response.list.map(DailyWeatherRowViewModel.init)
    }
    .map(Array.removeDuplicates)
    .receive(on: DispatchQueue.main)
    .sink(
      receiveCompletion: { [weak self] value in
        guard let self = self else { return }
        switch value {
        case .failure:
          self.dataSource = []
        case .finished:
          break
        }
      },
      receiveValue: { [weak self] forecast in
        guard let self = self else { return }
        self.dataSource = forecast
    })
   .store(in: &amp;disposables)
}
</code></pre>

<p>If I look in Combine for the definition of the <code>@Published</code> propertyWrapper, it seems like all does is provide <code>projectedValue</code> which is a <code>Publisher</code>, which makes it seem like it ought to be possible for <code>WeeklyWeatherViewModel</code> to simply provide the <code>Publisher</code> fetching weather data and for the view to make use of this directly. I don't see why the copying in to a <code>dataSource</code> is necessary.</p>

<p>Basically, what I'm expecting is there to be a way for SwiftUI to directly make use of a Publisher, and for me to be able to put that publisher externally from a View implementation so that I can inject it. But I've no idea what it is.</p>

<p>If this doesn't seem to make any sense, that figures, as I'm confused. Please let me know and I'll see if I can refine my explanation. Thanks!</p>
","2547229","","2547229","","2019-09-29 05:46:13","2020-01-06 15:25:25","Simpler ViewModel implementation","<swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"58159101","1","58163243","","2019-09-29 20:51:37","","1","2675","<p>I am trying to leverage SwiftUI and Combine to store user defaults for my application. Looking at suggestions in a few other posts, I have updated my code as you see below.  However, I am now getting the error of ""Referencing instance method 'send()' on 'Subject' requires the types 'Setup' and 'Void' be equivalent"".  It has been suggested that I change ""Setup"" to void in the PassthroughSubject, however this then gives a hard crash in the app at startup - "" Fatal error: No observable object of type Setup.Type found.""</p>

<p>I am at a bit of loss... any pointers would be welcomed.</p>

<pre><code>    ==============  DataStoreClass ============

import SwiftUI
import Foundation
import Combine

class Setup: ObservableObject {

    private var notificationSubscription: AnyCancellable?

    let objectWillChange = PassthroughSubject&lt;Setup,Never&gt;()

    @UserDefault(key: ""keyValueBool"", defaultValue: false)
    var somevalueBool: Bool {
        didSet{
            objectWillChange.send()  // &lt;====== Referencing instance method 'send()' on 'Subject' requires the types 'Setup' and 'Void' be equivalent
        }
    }
    init() {

        notificationSubscription = NotificationCenter.default.publisher(for: UserDefaults.didChangeNotification).sink { _ in
                   self.objectWillChange.send()
        }
    }
}


============= property wrapper ===========
import Foundation

@propertyWrapper
struct UserDefault&lt;T&gt; {
    let key: String
    let defaultValue: T

    var wrappedValue: T {
        get {
            UserDefaults(suiteName: ""group.com.my.app"")!.value(forKey: key) as? T ?? defaultValue
        } set {
            UserDefaults(suiteName: ""group.com.my.app"")!.set(newValue, forKey: key)
        }
    }
}
</code></pre>
","373749","","","","","2019-09-30 07:23:16","Referencing instance method requires equivalency (SWIFT)","<swift><swiftui><combine>","3","1","1","","","CC BY-SA 4.0"
"58178825","1","","","2019-10-01 05:57:58","","3","1390","<p>I'm looking to implement a generic validation/vetoing loop in SwiftUI - the sort of thing that should be pretty straightforward to do with a ""single source of truth"" framework</p>

<p>In short I want to: </p>

<ul>
<li>Have a generic control (lets say for instance a <code>TextField</code>)</li>
<li>Apply a validation/veto on the update of that control (for instance, a user types text)</li>
<li>Propagate the intended change into a validator, updating a <code>Binding</code> source object somewhere (ideally, an <code>@State</code> member inside the <code>View</code>) </li>
<li>Feeding that value back into the control for display</li>
</ul>

<p>It seems that for all the ""single source of truth"" talk Apple is kind of lying - injecting a validation stage into this chain seems difficult, especially without breaking encapsulation of the view</p>

<p>Note that I don't really want to solve <em>this</em> problem in particular - I'm looking for a pattern to implement (ie: replace the <code>String</code> and <code>TextField</code> with <code>Bool</code> and <code>Toggle</code> for example)</p>

<p>The following code shows my best attempt at doing the above loop</p>

<pre><code>class ValidatedValue&lt;T&gt;: ObservableObject {

    let objectWillChange = ObservableObjectPublisher()

    var validator: (T, T)-&gt;T

    var value: T {
        get {
            _value
        }
        set {
            _value = validator(_value, newValue)
            objectWillChange.send()
        }
    }

    /// Backing value for the observable
    var _value: T

    init(_ value: T, validator: @escaping (T, T)-&gt;T) {
        self._value = value
        self.validator = validator
    }
}

struct MustHaveDTextField: View {

    @ObservedObject var editingValue: ValidatedValue&lt;String&gt;

    public var body: some View {
        return TextField(
            ""Must have a d"",
            text: $editingValue.value
    }
}
</code></pre>

<p>With the validated value defined well outside the scope of the <code>View</code></p>

<pre><code>ValidatedValue(
    ""oddity has a d"",
    validator: { current, new in
        if new.contains(""d"") {
            return new
        }
        else {
            return current
        }
    }
)
</code></pre>

<p>This <em>kind of</em> works as it will prevent you from modifying the string input if it contains no ""d""s. However; </p>

<ul>
<li>The cursor state still moves on the text control past the point of validation</li>
<li>It exposes what should be entirely internal state and requires passing that down from parents or via the <code>EnvironmentObject</code> (if you are doing this with <code>List</code>s of things...ow) </li>
</ul>

<p>Either I'm missing something key, or I'm taking the wrong approach, or what Apple says is not what Apple does. </p>

<p>Modifying internal state during the loop like what is done <a href=""https://gist.github.com/darrarski/065520cc7095a7e0e33e72373feab3ac"" rel=""nofollow noreferrer"">here</a> or <a href=""https://gist.github.com/darrarski/b500960c857b403bfff25228b12aadef"" rel=""nofollow noreferrer"">here</a> is not good - they modify state inside the view loop which XCode flags as <code>undefined behaviour</code>. <a href=""https://stackoverflow.com/a/56477309/3886090"">This one</a> also has a similar solution but again suffers from needing to put the validation logic <em>outside</em> the view - IMHO it should be self-contained. </p>
","3886090","","3886090","","2019-10-01 06:04:25","2020-02-26 17:27:32","SwiftUI validation and vetoing for user input","<validation><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"58187541","1","58214122","","2019-10-01 14:58:06","","6","5941","<p>I have an AppState that can be observed:</p>

<pre><code>class AppState: ObservableObject {

    private init() {}
    static let shared = AppState()

    @Published fileprivate(set) var isLoggedIn = false

}
</code></pre>

<p>A View Model should decide which view to show based on the state (<code>isLoggedIn</code>):</p>

<pre class=""lang-swift prettyprint-override""><code>class HostViewModel: ObservableObject, Identifiable {

    enum DisplayableContent {
        case welcome
        case navigationWrapper
    }

    @Published var containedView: DisplayableContent = AppState.shared.isLoggedIn ? .navigationWrapper : .welcome

}
</code></pre>

<p>In the end a <code>HostView</code> observes the <code>containedView</code> property and displays the correct view based on it.</p>

<p>My problem is that <code>isLoggedIn</code> is not being observed with the code above and I can't seem to figure out a way to do it. I'm quite sure that there is a simple way, but after 4 hours of trial &amp; error I hope the community here can help me out.</p>
","6333824","","6333824","","2019-10-03 07:16:44","2020-07-20 16:47:40","Updating a @Published variable based on changes in an observed variable","<swift><combine>","4","3","3","","","CC BY-SA 4.0"
"58203531","1","61086087","","2019-10-02 14:24:38","","70","32987","<p>In imperative Swift, it is common to use computed properties to provide convenient access to data without duplicating state. </p>

<p>Let's say I have this class made for imperative MVC use:</p>

<pre class=""lang-swift prettyprint-override""><code>class ImperativeUserManager {
    private(set) var currentUser: User? {
        didSet {
            if oldValue != currentUser {
                NotificationCenter.default.post(name: NSNotification.Name(""userStateDidChange""), object: nil)
                // Observers that receive this notification might then check either currentUser or userIsLoggedIn for the latest state
            }
        }
    }

    var userIsLoggedIn: Bool {
        currentUser != nil
    }

    // ...
}
</code></pre>

<p>If I want to create a reactive equivalent with Combine, e.g. for use with SwiftUI, I can easily add <code>@Published</code> to stored properties to generate <code>Publisher</code>s, but not for computed properties. </p>

<pre class=""lang-swift prettyprint-override""><code>    @Published var userIsLoggedIn: Bool { // Error: Property wrapper cannot be applied to a computed property
        currentUser != nil
    }
</code></pre>

<p>There are various workarounds I could think of. I could make my computed property stored instead and keep it updated. </p>

<p>Option 1: Using a property observer:</p>

<pre class=""lang-swift prettyprint-override""><code>class ReactiveUserManager1: ObservableObject {
    @Published private(set) var currentUser: User? {
        didSet {
            userIsLoggedIn = currentUser != nil
        }
    }

    @Published private(set) var userIsLoggedIn: Bool = false

    // ...
}
</code></pre>

<p>Option 2: Using a <code>Subscriber</code> in my own class:</p>

<pre class=""lang-swift prettyprint-override""><code>class ReactiveUserManager2: ObservableObject {
    @Published private(set) var currentUser: User?
    @Published private(set) var userIsLoggedIn: Bool = false

    private var subscribers = Set&lt;AnyCancellable&gt;()

    init() {
        $currentUser
            .map { $0 != nil }
            .assign(to: \.userIsLoggedIn, on: self)
            .store(in: &amp;subscribers)
    }

    // ...
}
</code></pre>

<p>However, these workarounds are not as elegant as computed properties. They duplicate state and they do not update both properties simultaneously. </p>

<p>What would be a proper equivalent to adding a <code>Publisher</code> to a computed property in Combine?</p>
","5468365","","","","","2022-08-10 11:24:10","An equivalent to computed properties using @Published in Swift Combine?","<ios><swift><swiftui><reactive><combine>","7","5","14","","","CC BY-SA 4.0"
"58214863","1","","","2019-10-03 08:06:34","","1","1066","<p>Hi guys i have the following data model for registering a user in my app:</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine
import SwiftExtensions

class RegisterData {

    @Published var firstName: String = """"
    @Published var middleName: String = """"
    @Published var lastName: String = """"
    @Published var email: String = """"
    @Published var postcode: String = """"
    @Published var termsAggreed: Bool = false
    @Published var receiveNews: Bool = false
}

extension RegisterData: Publisher {

    typealias Output = Bool

    typealias Failure = Never

    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, RegisterData.Failure == S.Failure, RegisterData.Output == S.Input {

        // works only if debounce transform is removed or moved after all combineLatest transforms
        let publisher = $firstName
            .combineLatest($middleName, $lastName) { !$0.isEmpty &amp;&amp; !$1.isEmpty &amp;&amp; !$2.isEmpty }
            .combineLatest($postcode, $email) { $0 &amp;&amp; !$1.isEmpty &amp;&amp; $2.isValidEmail }
            .debounce(for: .seconds(0.5), scheduler: RunLoop.main) // try to debounce only texts, but not working
            .combineLatest($receiveNews, $termsAggreed) { $0 &amp;&amp; $1 &amp;&amp; $2 }
            .removeDuplicates()
            .eraseToAnyPublisher()

        publisher.receive(subscriber: subscriber)
    }
}

</code></pre>

<p>I have a view controller with a couple of <code>UITextField</code>s and two <code>UISwitch</code>es that populates an instance of this <code>RegisterData</code> class</p>

<p>I want to 'debounce' only the change of the properties that store Strings because they will be populated by the user from the text fields, but the way i am applying these transformations in <code>func receive&lt;S&gt;(subscriber:)</code> to come up with the <code>Publisher</code> that i need, makes it so that it does not send any new values. If i comment out the <code>.debounce</code> transformation it sends updates. If i put the <code>.debounce</code> transformation before <code>.removeDuplicates()</code> it sends updates, however it 'debounces' the booleans too.</p>

<h2>How can i achieve debounce only for the <code>String</code>s ?</h2>

<p>I tried debouncing each one of them individually (lets say one of them holds potential username, that has to be checked on server if it is free, so i want to debounce the API call only on it) but it didn't work</p>

<p>Thanks in advance!</p>
","7013945","","","","","2020-06-29 07:39:11","Debounce operator breaks publisher in Combine","<swift><reactive-programming><combine>","1","1","","","","CC BY-SA 4.0"
"58226604","1","58242311","","2019-10-03 20:41:42","","6","2885","<p>I follow a pattern in my Rx code, I usually have an Observable trigger which I flatMap to create another Observable for a network request. A simplified example:</p>

<pre><code>enum ViewModelError: Error {
  case bang
}

enum DataTaskError: Error {
  case bang
}

func viewModel(trigger: Observable&lt;Void&gt;,
               dataTask: Observable&lt;Result&lt;SomeType, DataTaskError&gt;&gt;) -&gt; Observable&lt;Result&lt;AnotherType, ViewModelError&gt;&gt; {
  let apiResponse = trigger
    .flatMap { dataTask }
}
</code></pre>

<p>The Combine equivalent I'm having some trouble with. I could use a Result as the Output type and use Never as the Failure type but that feels like a misuse of the API.</p>

<pre><code>func viewModel(trigger: AnyPublisher&lt;Void, Never&gt;,
               dataTask: AnyPublisher&lt;SomeType, DataTaskError&gt;) -&gt; AnyPublisher&lt;AnotherType, ViewModelError&gt; {
  let apiResponse = trigger
    .flatMap { dataTask }
}
</code></pre>

<p>I get a compilation error:</p>

<pre><code>Instance method 'flatMap(maxPublishers:_:)' requires the types 'Never' and 'DataTaskError' be equivalent
</code></pre>

<p>I could use mapError and cast both of the errors to Error, but I need a DataTaskError to be able to create my ViewModelError.</p>

<p>This feels like it shouldn't be so difficult, and it seems like a fairly common use case. I'm likely just misunderstanding some fundamentals, a point in the right direction would be greatly appreciated.</p>
","5165429","","","","","2019-11-07 23:56:49","How to flatMap two Publishers with different Failure types in Combine","<ios><swift><frp><combine>","1","4","1","","","CC BY-SA 4.0"
"58227096","1","58234908","","2019-10-03 21:26:04","","17","8917","<p>Is there a way to transform a given <code>AnyPublisher&lt;AnyType, SomeError&gt;</code> to <code>AnyPublisher&lt;AnyType, Never&gt;</code>?</p>
","5165429","","","","","2020-02-22 18:08:17","Set a given Publishers Failure type to Never in Combine","<ios><swift><frp><combine>","2","0","1","","","CC BY-SA 4.0"
"58228777","1","58229375","","2019-10-04 01:29:50","","5","1306","<p>I'm creating a new watchOS app using SwiftUI and Combine trying to use a MVVM architecture, but when my viewModel changes, I can't seem to get a Text view to update in my View.</p>

<p>I'm using watchOS 6, SwiftUI and Combine. I am using @ObservedObject and @Published when I believe they should be used, but changes aren't reflected like I would expect.</p>

<pre><code>// Simple ContentView that will push the next view on the navigation stack
struct ContentView: View {
    var body: some View {
        NavigationLink(destination: NewView()) {
            Text(""Click Here"")
        }
    }
}

struct NewView: View {
    @ObservedObject var viewModel: ViewModel

    init() {
        viewModel = ViewModel()
    }

    var body: some View {
        // This value never updates
        Text(viewModel.str)
    }
}

class ViewModel: NSObject, ObservableObject {
    @Published var str = """"
    var count = 0

    override init() {
        super.init()

        // Just something that will cause a property to update in the viewModel
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.count += 1
            self?.str = ""\(String(describing: self?.count))""

            print(""Updated count: \(String(describing: self?.count))"")
        }
    }
}
</code></pre>

<p><code>Text(viewModel.str)</code> never updates, even though the viewModel is incrementing a new value ever 1.0s. I have tried <code>objectWillChange.send()</code> when the property updates, but nothing works. </p>

<p>Am I doing something completely wrong?</p>
","589019","","","","","2019-10-04 04:13:46","Why won't my SwiftUI Text view update when viewModel changes using Combine?","<watchkit><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"58236540","1","","","2019-10-04 12:35:03","","1","396","<p>I create a framework and I want to support early adopters of Combine and SwiftUI for some of my providers without dropping prior iOS version support. I like declarative style and I often use observable classes/structures for variable states that could be used by a developer. How to add Combine's support without dropping iOS10+ support and without coding two different classes?</p>

<p>I planned to add <code>#if canImport(Combine)</code> extension to such classes so iOS13 users could use it in a native way without writing custom stores. So they could just call <code>.sink</code> or <code>.assign</code> for example and they will receive updates.</p>

<p>I don't know what protocol to adopt. I thought that store is a <code>Publisher</code>, but <code>Publisher</code> can't use <code>.send</code> method when something changes and I don't know how to notify <code>Subscriber</code> so.</p>

<pre><code>public class SomeDataProvider&lt;T&gt; {
    private var didChangeHandler: ((T?) -&gt; Void)?

    public var value: T? {
        didSet {
            didChangeHandler?(value)
        }
    }
    public func didChange(handler: @escaping ((T?) -&gt; Void)) {
        self.didChangeHandler = handler
    }

    public init() {}
}
</code></pre>

<p>The best approach also is to emulate at least <code>.sink</code> (most usable) for prior versions of iOS, so we don't use two separate methods or different iOS versions.</p>
","4532985","","4532985","","2019-10-04 12:40:19","2019-10-05 03:55:14","How to add Combine compatibility to custom classes with older iOS support?","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"58251478","1","58278910","","2019-10-05 19:07:03","","8","6933","<p>I am trying to decode the downloaded JSON into a structure with the following code.</p>

<pre class=""lang-swift prettyprint-override""><code>static func request(url: URL) -&gt; AnyPublisher&lt;SomeDecodableStruct, Error&gt; {
    return URLSession.shared.dataTaskPublisher(for: url)
        .map { $0.data }
        .decode(type: SomeDecodableStruct.self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
}
</code></pre>

<p>However, if processing fails, I would like you to return information on whether the request processing failed or the decoding processing failed.
Therefore, I defined the <code>FailureReason</code> enum that conforms to the <code>Error</code> protocol as follows.</p>

<pre class=""lang-swift prettyprint-override""><code>enum FailureReason : Error {
    case sessionFailed(error: URLError)
    case decodingFailed
}

static func request(url: URL) -&gt; AnyPublisher&lt;SomeDecodableStruct, FailureReason&gt; {
    // ???
}
</code></pre>

<p>How do I define a <code>request(url:)</code> that satisfies this <code>FailureReason</code>?</p>
","12169817","","","","","2019-10-08 01:00:48","What is the best way to handle errors in Combine?","<swift><swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"58251867","1","","","2019-10-05 19:59:17","","3","6598","<p>I need to download files using provided links from the backend. To download files the asynchronous API is used that returns Progress() object. The problem is that FlatMap cannot map from <code>Publisher&lt;[Link], Error&gt;</code> to <code>Publisher&lt;[File], Error&gt;</code>. Another problem I want to solve is getting rid of cancellable and somehow transform Progress info filePath once the Progress.fractionCompleted is equal to 1.0.</p>

<p>For now I have tried to use <code>map</code> function. See the code form the Playground:</p>

<pre><code>import UIKit
import Combine

var progress = Progress()
extension ProgressUserInfoKey {
    public static var destinationURL = ProgressUserInfoKey(""destinationURL"")
}

func download(from urlRequest: URLRequest, to destinationURL: URL) -&gt; AnyPublisher&lt;Progress, Error&gt; {
    return Future&lt;Progress, Error&gt; { promise in
        progress = Progress(totalUnitCount: 1)
        progress.setUserInfoObject(destinationURL.absoluteString,
                                   forKey: ProgressUserInfoKey.destinationURL)
        promise(.success(progress))
        // Simulate async API
        DispatchQueue.main.async {
            progress.completedUnitCount = 1
        }
    }.eraseToAnyPublisher()
}

struct Link: Decodable {
    let url: String
}

func getLinks() -&gt; AnyPublisher&lt;[Link], Error&gt; {
    return URLSession.shared.dataTaskPublisher(for: URL(string: ""https://backend.com"")!)
        .map { $0.data }
        .decode(type: [Link].self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
}

struct File {
    let url: URL
    let size: UInt32
}

private func destinationUrl(_ fromUrl: String?) -&gt; URL {
    guard let path = fromUrl else {
        return URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(UUID().uuidString)
    }
    return URL(fileURLWithPath: path)
}

/// 2) How to get rid of this state and transoft Progress into filePath directly (using matp(transform: ? )
var cancellableSet = Set&lt;AnyCancellable&gt;()

func getFiles() -&gt; AnyPublisher&lt;[File], Error&gt; {
    getLinks()
        .flatMap { (links) -&gt; AnyPublisher&lt;[File], Error&gt; in
            let sequence = Sequence&lt;[AnyPublisher&lt;File, Error&gt;], Error&gt;(sequence: links.map {
                download(from: URLRequest(url: $0), to: destinationUrl(UUID().uuidString))
                .sink { progress in
                    progress.publisher(for: \.fractionCompleted).sink { progressValue in
                        if progressValue == 1.0 {
                            let filePath: String = progress.userInfo[ProgressUserInfoKey.destinationURL] as? String ?? """"
/// 1) How to return publisher here
                            ///return Publisher(File(url: URL(string: filePath)!, size: 0))
                        }
                    }
                    .store(in: &amp;cancellableSet)
                }
                .store(in: &amp;cancellableSet)
            } )
            return sequence.flatMap { $0 }.collect().eraseToAnyPublisher()
    }
}
</code></pre>

<p>I am expecting that the code compiles successfully and the function <code>getFiles</code> returns <code>AnyPublisher&lt;[File], Error&gt;</code>.</p>

<p>Currently the error code am getting is the following:</p>

<pre><code>Cannot convert return expression of type 'Publishers.FlatMap&lt;AnyPublisher&lt;[File], Error&gt;, AnyPublisher&lt;[Link], Error&gt;&gt;' to return type 'AnyPublisher&lt;[File], Error&gt;'
</code></pre>
","6305934","","","","","2019-12-30 10:29:57","Swift Combine. How to transform publisher values","<swift><combine>","1","1","1","","","CC BY-SA 4.0"
"58255099","1","","","2019-10-06 07:21:09","","1","105","<p>I'd like to handle changed <code>@Published someVar</code> only after a specified interval elapses between events. How can I get <code>self</code> of <code>SomeClass</code> inside <code>propertyWrapper</code>?</p>

<pre class=""lang-swift prettyprint-override""><code>private var cancellableSet: Set&lt;AnyCancellable&gt; = []

extension Published where Value: Equatable {
    init&lt;S&gt;(
        wrappedValue defaultValue: Value,
        for dueTime: S.SchedulerTimeType.Stride,
        scheduler: S,
        sink: @escaping (Value) -&gt; () ) where S: Scheduler {
        self.init(initialValue: defaultValue)

        projectedValue
            .debounce(for: dueTime, scheduler: scheduler)
            .removeDuplicates()
            .sink(receiveValue: sink)
            .store(in: &amp;cancellableSet)

    }
}

class SomeClass {
    @Published(
        for: 0.5,
        scheduler: RunLoop.main,
        sink: { val in
            // how to get self of SomeClass
            print(self.someVar2) //Error: Value of type '(SomeClass) -&gt; () -&gt; SomeClass' has no member 'someVar2'
        })
    var someVar = """"
    var someVar2 = """"
}

</code></pre>
","4067700","","4067700","","2019-10-06 16:55:24","2019-10-08 09:12:52","How to get self of parent in @propertyWrapper?","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"58260429","1","58260784","","2019-10-06 19:07:45","","0","632","<p>I am working on a SwiftUI screen that updates multiple values in the UserDefaults, to allow the app to persist basic settings.  I am trying to use Combine and SwiftUI, as this is a native WatchOS app.</p>

<p>The basic View is giving me an error that I believe has to do with the propertyWrapper for UserDefaults, but as I have never worked with propertyWrappers (or Combine for that matter) I am un able to figure out how to fix this. </p>

<p>here's the property wrapper:</p>

<pre><code>import Foundation

@propertyWrapper
struct UserDefault&lt;T&gt; {
    let key: String
    let defaultValue: T

    init(_ key: String, defaultValue: T) {
        self.key = key
        self.defaultValue = defaultValue
    }

    var wrappedValue: T {
        get {
            UserDefaults(suiteName: ""group.com.my.app"")!.value(forKey: key) as? T ?? defaultValue
        } set {
            UserDefaults(suiteName: ""group.com.my.app"")!.set(newValue, forKey: key)
        }
    }
}
</code></pre>

<p>As you can see it wraps all the Key Pairs for the UserDefaults.</p>

<p>My class is similarly very simple, consisting of two bools and a double</p>

<pre><code>import SwiftUI
import Foundation
import Combine

class Setup: ObservableObject {

    private var notificationSubscription: AnyCancellable?

    let objectWillChange = PassthroughSubject&lt;Setup,Never&gt;()

    @UserDefault(""keyOpt1Enabled"", defaultValue: false)
    var opt1Enabled: Bool {
        willSet{
            objectWillChange.send(self)
        }
    }

    @UserDefault(""keyOpt2Enabled"", defaultValue: false)
    var opt2Enabled: Bool {
        willSet{
            objectWillChange.send(self)
        }
    }

    @UserDefault(""keyValueDouble"", defaultValue: Double(0.00))
    var someValueDouble: Double {
        willSet{
            objectWillChange.send(self)
        }

    }
    init() {

        notificationSubscription = NotificationCenter.default.publisher(for: UserDefaults.didChangeNotification).sink { _ in
                   self.objectWillChange.send(self)
        }
    }
}
</code></pre>

<p>The problem is that in SwiftUI I am using a TextField to allow for entering and updating the double value</p>

<pre><code>
    @ObservedObject var setup: Setup = Setup()

    private var currencyFormatter: NumberFormatter = {
        let f = NumberFormatter()
        f.numberStyle = .currency
        return f
    }()


    var body: some View {
        ScrollView{
            HStack{
                TextField(self.$setup.someValueDouble,
                          formatter: currencyFormatter,
                          placeholder: ""0.00"",
                          onEditingChanged: {_ in
                            print(""editing changed"")
                          },
                          onCommit: {
                            print(""updated"")
                            }
                )
            }

            HStack{
                Button(action: {
                    self.setup.opt1Enabled = false
                    self.setup.opt2Enabled = true
                } ) {
                    Text(verbatim: ""Opt 1"")
                        .font(Font.system(size: 16, design: Font.Design.rounded))
                }
                .background(setup.opt1Enabled ? Color.blue : Color.gray)
                .disabled(self.setup.opt1Enabled)
                .cornerRadius(5)

                Button(action: {
                    self.setup.opt1Enabled = true
                    self.setup.opt2Enabled = false
                }) {
                    Text(verbatim: ""Opt 2"")
                }
                .background(setup.opt2Enabled ? Color.blue : Color.gray)
                .disabled(self.setup.opt2Enabled)
            }
        }
    }
}
</code></pre>

<p>The TextField then gives the message that the Generic parameter 'Label' could not be inferred. Xcode offers to ""Fix"" this but the end results is TextField which is obviously incomplete, but the only view in this whole program is ""ContentView"" which is invalid.</p>
","373749","","","","","2019-10-06 19:58:34","Cannot invoke initializer for type 'TextField<_>' with propertyWrapper of UseDefaults","<properties><wrapper><swiftui><combine>","1","0","2","","","CC BY-SA 4.0"
"58267817","1","","","2019-10-07 10:33:45","","2","526","<p>I have a custom UIKit control that has a custom event. Does anybody know how to expose this event to SwiftUI using the Combine framework?</p>

<p>I can render the control using Combine's UIViewRepresentable but cannot find a way to expose the custom events or the values changed by internal UIKit events to SwiftUI.</p>

<p>Here is a concrete example of this problem:</p>

<p>I am using this custom UIKit slider control (because it support multiple knobs/ values):</p>

<p><a href=""https://github.com/yonat/MultiSlider"" rel=""nofollow noreferrer"">https://github.com/yonat/MultiSlider</a></p>

<p>It has a sliderChanged event which updates the current value. 
How do I expose this value to SwiftUI using Combine?</p>

<p>I cannot simply pass in a @ObservedObject because UIViewRepresentable does not allow this. I also cannot update a @Binding variable from the event handler because the UIKit event handlers are marked with  @objc  and it does not like it.</p>

<p>It appears to be a very common use case. I expected Apple to have a standard solution for this. However, I simply cannot find one that actually works for these types of scenarios. What am I missing here?</p>
","139393","","","","","2019-10-07 17:40:50","Exposing custom custom UIKit events from custom UIKit controls to SwiftUI","<event-handling><uikit><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"58289023","1","58289157","","2019-10-08 14:58:46","","4","536","<p>I tried to make a timer on SwiftUI, which worked just fine:</p>

<pre><code>import SwiftUI
import Combine    
struct ContentView: View {
let currentTimePublisher  = Timer.TimerPublisher(interval: 1.0, runLoop: .main, mode: .default)
    .autoconnect()

@State private var currentTime = Date()
var body: some View {

    VStack{
        Text(""Time is:"")
        Text(""\(currentTime)"")
        }.onReceive(currentTimePublisher) { (date) in
            self.currentTime = date
        }
    }
}
</code></pre>

<p>However, I tried to put the VStack in anything scrollable, be List, or ScrollView, I was not updating when I was scrolling the screen. It worked just fine when I didn't scroll.</p>

<p>I also put the TimerPublisher on the main thread as you can see, but that didn't change anything.</p>

<p>How can I make the SwiftUI update the time while I'm scrolling/interacting?</p>
","6276472","","77567","","2019-10-08 16:11:17","2019-10-08 16:11:17","Timer.TimerPublisher doesn’t fire while scrolling","<ios><swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"58297176","1","58297743","","2019-10-09 04:42:15","","30","7168","<p>I'm building an app using SwiftUI and would like a way to convert a <code>Binding&lt;Value?&gt;</code> to a <code>Binding&lt;Value</code>>.</p>

<p>In my app I have an <code>AvatarView</code> which knows how to render an image for a particular user.</p>

<pre class=""lang-swift prettyprint-override""><code>struct AvatarView: View {
  @Binding var userData: UserData

  ...
}
</code></pre>

<p>My app holds a <code>ContentView</code> that owns two bindings: a dictionary of users by id, and the id of the user whose avatar we should be showing.</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
  @State var userById: Dictionary&lt;Int, UserData&gt;
  @State var activeUserId: Int

  var body: some View {
    AvatarView(userData: $userById[activeUserId])
  }
}
</code></pre>

<p>Problem: the above code doesn't combine because <code>$userById[activeUserId]</code> is of type <code>Binding&lt;UserData?&gt;</code> and <code>AvatarView</code> takes in a <code>Binding&lt;UserData&gt;</code>.</p>

<p>Things I tried...</p>

<ul>
<li><p><code>$userById[activeUserId]!</code> doesn't work because it's trying to unwrap a <code>Binding&lt;UserData?&gt;</code>. You can only unwrap an <code>Optional</code>, not a <code>Binding&lt;Optional&gt;</code>.</p></li>
<li><p><code>$(userById[activeUserId]!)</code> doesn't work for reasons that I don't yet understand, but I think something about <code>$</code> is resolved at compile time so you can't seem to prefix arbitrary expressions with <code>$</code>.</p></li>
</ul>
","1026198","","1026198","","2019-10-09 05:12:20","2019-10-09 09:03:12","How can I unwrap an optional value inside a binding in Swift?","<ios><swift><swiftui><combine>","1","2","9","","","CC BY-SA 4.0"
"58312043","1","","","2019-10-09 20:46:05","","3","629","<p>I'm using RxSwift with something like the following</p>

<pre><code>extension Reactive where Base: UIViewController {

    public var showError: Binder&lt;Error&gt; {
        return Binder(self.base) { element, error in
            let alertVC = // create UIAlertController with error
            element.present(alertVC, animated: true)
        }
    }
</code></pre>

<p>What's the best way to build something like this with Swift Combine?</p>
","27404","","1000551","","2019-12-07 09:59:32","2019-12-07 09:59:32","Swift Combine: how to create custom sink?","<swift><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"58331932","1","58391367","","2019-10-10 22:31:11","","0","1320","<p>I’m trying to learn Swift, SwiftUI, and Combine and am new to iOS in general. Eventually I want to have a list that you can search, filter, and sort.</p>

<p>So far I have filtering working when I use <code>onEditingChanged</code> within the TextField but that requires hitting enter. I just can’t figure out how to trigger <code>activePeople</code> to update when the TextField <code>filterText</code>  changes so that the <code>activePeople</code> list filters <em>while</em> you type.</p>

<p>I’ve gotten a version to work when I filter the list within a ForEach in the view (see commented out code) but eventually the filtering and sorting will get more complicated and it seems to make more sense to have it outside of that view. Let me know if this is not the right approach for whatever reason.</p>

<p>Here’s the code so far:</p>

<pre><code>import Combine
import SwiftUI

class Model: ObservableObject {
    @Published var filterText: String = “”
    @Published var activePeople: [Person] = []

    private var allPeople : [Person] = [
        Person( id: 1000, name: “Alexa” ),
        Person( id: 1001, name: “Anaïs” ),
        Person( id: 1002, name: “Earl” ),
        Person( id: 1003, name: “Elba” ),
        Person( id: 1004, name: ""Emil” ),
        Person( id: 1005, name: “Janeth” ),
        Person( id: 1006, name: “Joselyn” ),
        Person( id: 1007, name: “Lupita” ),
        Person( id: 1008, name: “Mellie” ),
        Person( id: 1009, name: “Vanita” ),
    ]

    init() {
        activePeople = allPeople
    }

    func filterList() {
        if ( filterText == “” ) {
            activePeople = allPeople
        } else {
            activePeople = allPeople.filter( { $0.name.localizedStandardContains( filterText ) } )
        }
    }

}

struct Person: Identifiable {
    var id: Int
    var name: String
}

</code></pre>

<pre><code>import SwiftUI

struct ContentView: View {
    @EnvironmentObject private var model: Model

    var body: some View {
        VStack {
            Form {
                Section {
                    TextField(“Filter Text”, text: $model.filterText, onEditingChanged: {_ in self.model.filterList()}
                    )
                }
                Section {
                    Text( ""Filtered by: \(model.filterText)” )
                    ForEach( model.activePeople ) { person in
//                        if ( self.model.filterText == “” || person.name.localizedStandardContains( self.model.filterText )) {
                            Text( person.name )
//                        }
                    }
                }
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .environmentObject(Model())
    }

}

</code></pre>
","12197617","","","","","2019-10-15 09:23:52","How do you have a TextField value change trigger an update to another piece of data in SwiftUI?","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"58353161","1","58408210","","2019-10-12 10:25:47","","3","2174","<p>I'm having a problem of updates in my application.
I can't understand very well what is going on with the data flow between the subviews.</p>

<h2>This is my current structure</h2>

<ul>
<li><p><strong>ViewModel</strong>: ObsebsrvableObject</p></li>
<li><p><strong>MainView</strong> with ObservedObject (viewModel)</p>

<ul>
<li><strong>ChildView</strong> with a list from MainView observed object (just the list is passed as a normal array - not bindable)

<ul>
<li><strong>NephewView</strong> with the list passed to the childView, still as a normal array</li>
</ul></li>
</ul></li>
</ul>

<h2>What is happening:</h2>

<p>Every time I modify the list, the MainView updates triggering a new rebuild of ChildView, but the NephewView does not update</p>

<h2>What I would like to have:</h2>

<p>I would like to update the Main, the Child and the NephewView views every time the observedObject get an update</p>

<h2>Problem:</h2>

<p>I can't understand why if the Child View rebuild, the nephew doesn't.</p>

<h2>Example Code</h2>

<pre><code>class ViewModel: ObservableObject {

    let userData = UserData.shared

    var canceller: AnyCancellable?

    @Published var items: [Items]


    init() {
      items = []
      canceller = userData.objectWillChange
        .throttle(for: 5, scheduler: RunLoop.main, latest: true)
        .sink(receiveCompletion: { data  in
            DispatchQueue.main.async { [weak self] in
                guard let self = self else { return }
                self.items = data.items
            }
        },
        receiveValue: { _ in
            DispatchQueue.main.async { [weak self] in
                guard let self = self else { return }
                self.items = data.items
            }
        })
   }
 }

struct MainView: View {

  @ObservedObject var model = ViewModel()


  var body: some View {
      ChildView(items: model.items)
  }
}

struct ChildView: View {

  let items: [Items]


  var body: some View {
      NephewView(items: items)
  }
}

struct NephewView: View {

  let items: [Items]

  var body: some View {
      List...
  }
}
</code></pre>

<p>The sink works properly, it's just the UI part that does not get updates.
Maybe the way I'm updating the publisher is wrong?</p>
","6747915","","6747915","","2019-10-12 11:41:35","2019-10-16 07:42:41","iOS SwiftUI: Data Flow Flow in Subviews @ObservedObject","<ios><swift><swiftui><combine>","1","3","1","","","CC BY-SA 4.0"
"58353555","1","","","2019-10-12 11:16:35","","0","47","<p>It's a bug confused me for all day, I make a demo for my case, all is just a list and a detail.</p>

<p><strong>Room.swift</strong></p>

<pre><code>struct Room: Identifiable {

    var id: Int
    var name: String
}
</code></pre>

<p><strong>RoomListModel.swift</strong></p>

<pre><code>class RoomListModel: ObservableObject {
    @Published var rooms: [Room] = [
        Room(id: 1, name: ""Room A""),
        Room(id: 2, name: ""Room B""),
        Room(id: 3, name: ""Room C""),
    ]
}
</code></pre>

<p><strong>RoomList.swift</strong></p>

<pre><code>struct RoomList: View {

    @ObservedObject var model = RoomListModel()

    var body: some View {

        NavigationView {
            List {
                ForEach(model.rooms.indices) { index in
                    RoomRow(room: self.$model.rooms[index])
                }
            }
            .listStyle( GroupedListStyle() )
        }
    }
}
</code></pre>

<p><strong>RoomRow.swift</strong></p>

<pre><code>struct RoomRow: View {

    @Binding var room: Room

    init(room: Binding&lt;Room&gt;) {
        print(""initing RoomRow: "" + room.name.wrappedValue)
        self._room = room
    }

    var body: some View {
        NavigationLink(
            destination: RoomDetail(room: $room)
        ) {
            Text(room.name)
        }
    }
}
</code></pre>

<p><strong>RoomDetail.swift</strong></p>

<pre><code>struct RoomDetail: View {

    @Binding var room: Room

    init(room: Binding&lt;Room&gt;) {
        print(""initing RoomDetail: "" + room.name.wrappedValue)
        self._room = room
    }

    var body: some View {
        Text(room.name)
    }
}
</code></pre>

<p>For convenience, I add print in init.</p>

<p>When List load, all the RoomRow and RoomDetail are inited, that is OK.</p>

<pre><code>initing RoomRow: Room A
initing RoomDetail: Room A
initing RoomRow: Room B
initing RoomDetail: Room B
initing RoomRow: Room C
</code></pre>

<p>But when I trigger to one of RowDetail, all the RoomDetails is inited again, But I just go to one, not all of them, <strong>WHY</strong> all the RoomDetails are inited, and <strong>AGAIN</strong>?</p>

<pre><code>initing RoomDetail: Room C
initing RoomDetail: Room A
initing RoomDetail: Room B
</code></pre>

<p>I don't know why, but found one solution, I removed all @Binding property, and It's OK, but <strong>WHY</strong> <code>@Binding</code> will cause unreleated init?</p>
","5563533","","","","","2019-10-12 11:16:35","Why @Binding Property causes not releated init every time?","<swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"58364345","1","59198850","","2019-10-13 14:10:08","","1","1704","<p>In RxSwift we can check if a <code>*Subject</code> has any observer, using <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Subjects/PublishSubject.swift#L24-L29"" rel=""nofollow noreferrer""><code>hasObserver</code></a>, how can I do this in Combine on e.g. a <code>PassthroughSubject</code>?</p>
","1311272","","","","","2019-12-05 15:54:56","Swift Combine: Check if Subject has observer?","<swift><rx-swift><combine>","2","0","","","","CC BY-SA 4.0"
"58364436","1","58368290","","2019-10-13 14:20:30","","3","1835","<p>How can I convert a publisher of array a certain element, to just a publisher of said element (but with more events)?</p>

<p>e.g. how can I convert</p>

<p><code>AnyPublisher&lt;[Int], Never&gt;</code> to <code>AnyPublisher&lt;Int, Never&gt;</code>?</p>

<p>I think maybe what RxSwift offers with its <a href=""https://github.com/ReactiveX/RxSwift/blob/c6c0c540109678b96639c25e9c0ebe4a6d7a69a9/RxSwift/Observables/Sequence.swift#L34-L36"" rel=""nofollow noreferrer""><code>from</code> operator</a> is similar to what I want to do.</p>

<p>I guess I want the inverse of Combine <a href=""https://developer.apple.com/documentation/combine/publisher/3204692-collect"" rel=""nofollow noreferrer""><code>collect</code></a>?</p>
","1311272","","1311272","","2019-10-13 14:27:33","2021-03-19 09:56:19","Swift Combine: How can I convert `AnyPublisher<[Foo], *>` to `AnyPublisher<Foo, *>`?","<swift><rx-swift><combine>","2","0","1","","","CC BY-SA 4.0"
"58371877","1","","","2019-10-14 07:24:36","","0","249","<p>I'm trying to build an iOS app, that has minimum target set to iOS 10. 
In my app, I have a piece a code that uses new Combine framework (for iOS 13+).</p>

<p>When I archive the app, Xcode tell me <code>error: no such module 'Combine'</code></p>

<p>Is it not possible to use Combine if our target is set to less that iOS 13?</p>
","3228215","","","","","2019-10-14 09:45:58","Archive project using combine","<swift><xcode><combine>","1","1","","","","CC BY-SA 4.0"
"58383895","1","61035663","","2019-10-14 20:49:36","","12","4973","<p>I have some code that is built using RxSwift, and I'm playing around with converting it to use Apple's Combine framework.</p>

<p>One pattern which is very common is the use of <code>Observable.create</code> for one-shot observables (usually network requests). Something like this:</p>

<pre><code>func loadWidgets() -&gt; Observable&lt;[Widget]&gt; {
  return Observable.create { observer in
    // start the request when someone subscribes
    let loadTask = WidgetLoader.request(""allWidgets"", completion: { widgets in
      // publish result on success
      observer.onNext(widgets)
      observer.onComplete()
    }, error: { error in
      // publish error on failure
      observer.onError()
    })
    // allow cancellation
    return Disposable {
      loadTask.cancel()
    }
  }
}
</code></pre>

<p>I'm trying to map that across to Combine and I haven't been able to quite figure it out. The closest I've been able to get is using Future for something like this:</p>

<pre><code>func loadWidgets() -&gt; AnyPublisher&lt;[Widget], Error&gt; {
  return Future&lt;[Widget], Error&gt; { resolve in
    // start the request when someone subscribes
    let loadTask = WidgetLoader.request(""allWidgets"", completion: { widgets in
      // publish result on success
      resolve(.success(widgets))
    }, error: { error in
      // publish error on failure
      resolve(.failure(error))
    })
    // allow cancellation ???
  }
}
</code></pre>

<p>As you can see, it does most of it, but there's no ability to cancel.
Secondarily, future doesn't allow multiple results.</p>

<p>Is there any way to do something like the Rx <code>Observable.create</code> pattern which allows cancellation and optionally multiple results?</p>
","234","","","","","2022-09-16 02:30:31","Swift Combine alternative to Rx Observable.create","<swift><combine>","4","0","4","","","CC BY-SA 4.0"
"58403338","1","58983628","","2019-10-15 22:23:48","","22","5273","<p>I would like to use Combine's <a href=""https://developer.apple.com/documentation/combine/published"" rel=""noreferrer""><code>@Published</code></a> attribute to respond to changes in a property, but it seems that it signals before the change to the property has taken place, like a <code>willSet</code> observer. The following code:</p>

<pre><code>import Combine

class A {
    @Published var foo = false
}

let a = A()
let fooSink = a.$foo.dropFirst().sink { _ in // `dropFirst()` is to ignore the initial value
    print(""foo is now \(a.foo)"")
}

a.foo = true
</code></pre>

<p>outputs:</p>

<blockquote>
  <p>foo is now false</p>
</blockquote>

<p>I'd like the sink to run after the property has changed like a <code>didSet</code> observer so that <code>foo</code> would be true at that point. Is there an alternative publisher that signals then, or a way of making <code>@Published</code> work like that?</p>
","98286","","","","","2022-07-06 09:15:22","Is there an alternative to Combine's @Published that signals a value change after it has taken place instead of before?","<swift><combine>","5","0","5","","","CC BY-SA 4.0"
"58406287","1","58406402","","2019-10-16 05:28:47","","88","19291","<p>I have a SwiftUI view that takes in an EnvironmentObject called <code>appModel</code>. It then reads the value <code>appModel.submodel.count</code> in its <code>body</code> method. I expect this to bind my view to the property <code>count</code> on <code>submodel</code> so that it re-renders when the property updates, but this does not seem to happen.</p>

<p>Is this a bug? And if not, what is the idiomatic way to have views bind to nested properties of environment objects in SwiftUI?</p>

<p>Specifically, my model looks like this...</p>

<pre><code>class Submodel: ObservableObject {
  @Published var count = 0
}

class AppModel: ObservableObject {
  @Published var submodel: Submodel = Submodel()
}
</code></pre>

<p>And my view looks like this...</p>

<pre><code>struct ContentView: View {
  @EnvironmentObject var appModel: AppModel

  var body: some View {
    Text(""Count: \(appModel.submodel.count)"")
      .onTapGesture {
        self.appModel.submodel.count += 1
      }
  }
}
</code></pre>

<p>When I run the app and click on the label, the <code>count</code> property does increase but the label does not update.</p>

<p>I can fix this by passing in <code>appModel.submodel</code> as a property to <code>ContentView</code>, but I'd like to avoid doing so if possible.</p>
","1026198","","","","","2022-06-25 19:05:02","How to tell SwiftUI views to bind to nested ObservableObjects","<ios><swift><swiftui><combine>","14","2","28","","","CC BY-SA 4.0"
"58428623","1","58431723","","2019-10-17 08:54:07","","1","819","<p>I've tried the example from the <a href=""https://developer.apple.com/documentation/combine/observableobject#3374830"" rel=""nofollow noreferrer"">ObservableObject documentation</a>.</p>

<pre class=""lang-swift prettyprint-override""><code>class Contact: ObservableObject {
    @Published var name: String = ""me""
    @Published var age: Int = 7
}
</code></pre>

<p>When I make a Swift Playground with the code:</p>

<pre class=""lang-swift prettyprint-override""><code>let c = Contact()
c.objectWillChange.sink { print(""This prints"") }
c.age += 1
</code></pre>

<p><code>objectWillChange</code> triggers and the line prints.</p>

<p>So far so good.</p>

<p>I now make a View in SwiftUI:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    @ObservedObject var contact = Contact
    ...
</code></pre>

<p>I create this View in the AppDelegate, and do:</p>

<pre class=""lang-swift prettyprint-override""><code>   contentView.contact.objectWillChange.sink { print(""This doesn't print."") }
</code></pre>

<p>I've connected the contact to various controls, and changing any fields updates all the controls. Doing <code>onReceive(contact.objectWillChange)</code> also works fine. But not connecting to it in the AppDelegate. I've tried logging <code>deinit()</code> to make sure we're talking about the same object. I've tried using <code>ImmediateScheduler</code>. No dice. Why is this not working?</p>
","163983","","","","","2019-10-17 11:36:25","SwiftUI: Why doesn't ObservedObject work in AppDelegate?","<swift><macos><swiftui><appkit><combine>","1","4","","","","CC BY-SA 4.0"
"58436556","1","","","2019-10-17 15:57:17","","1","96","<p>I have a sample test project at <a href=""https://github.com/EricG-Personal/grdb_test.git"" rel=""nofollow noreferrer"">https://github.com/EricG-Personal/grdb_test.git</a></p>

<p>In ContentView.swift, I currently have one list that shows all of the items in the Database.</p>

<p>Below that, I would like another list that shows all of the unique 'names' from the test table.</p>

<p>I am getting lost in the details between GRBD, Combine, and SwiftUI and am not sure what the code would look like to provide the second list with the data it needs from the database while using GRDBCombine.</p>
","198301","","","","","2019-10-17 15:57:17","Using GRDBCombine to obtain unique items and display them in a list with SwiftUI","<swift><swiftui><combine><grdb><grdbcombine>","0","0","","","","CC BY-SA 4.0"
"58437861","1","58440744","","2019-10-17 17:27:11","","14","4376","<p>I have two classes nested in another class, which is an observable object in a SwiftUI view. Even though properties in the nested classes are declared as @Published, their values (when they change) do not update in the main view.</p>

<p>A similar question has been asked here, and I could use it to get it to work for one of the two subclasses, but not both.</p>

<p><a href=""https://stackoverflow.com/questions/58406287/how-to-tell-swiftui-views-to-bind-to-nested-observableobjects"">How to tell SwiftUI views to bind to nested ObservableObjects</a></p>

<p>This is the model:</p>

<pre><code>class Submodel1: ObservableObject {
  @Published var count = 0
}

class Submodel2: ObservableObject {
  @Published var count = 0
}

class Model: ObservableObject {
  @Published var submodel1: Submodel1 = Submodel1()
  @Published var submodel2: Submodel2 = Submodel2()
}
</code></pre>

<p>And this is the main view:</p>

<pre><code>struct ContentView: View {
  @ObservedObject var model: Model = Model()

  var body: some View {
    VStack {
      Text(""Count: \(model.submodel1.count)"")
        .onTapGesture {
          self.model.submodel1.count += 1
        }
      Text(""Count: \(model.submodel2.count)"")
        .onTapGesture {
          self.model.submodel2.count += 1
        }
    }
  }
}
</code></pre>

<p>Adding this to the model class (see previous Stackoverflow question) works for updating on submodel1 changes, but not both:</p>

<pre><code>  var anyCancellable: AnyCancellable? = nil
  init() {
      anyCancellable = submodel1.objectWillChange.sink { (_) in
          self.objectWillChange.send()
      }
   }
</code></pre>

<p>What I'm looking for is some way to pass on changes of both the submodel1 and submodel2 to my view.</p>
","12234199","","","","","2019-10-17 21:17:32","How to tell SwiftUI views to bind to more than one nested ObservableObject","<ios><swift><swiftui><combine>","1","1","7","","","CC BY-SA 4.0"
"58440494","1","","","2019-10-17 20:44:51","","1","833","<p>I've been trying to replicate <code>flatMapLatest</code> from RxSwift in Combine, I've read in a few places that the solution is to use <code>.map(...).switchToLatest</code></p>

<p>I'm finding some differences between the two, and I'm not sure if it's my implementation/understanding which is the problem.</p>

<p>In RxSwift if the upstream observable emits a stop event (completed or error) then the downstream observables created in the <code>flatMapLatest</code> closure will continue to emit events until they themselves emit a stop event:</p>

<pre><code>let disposeBag = DisposeBag()

func flatMapLatestDemo() {
    let mockTrigger = PublishSubject&lt;Void&gt;()
    let mockDataTask = PublishSubject&lt;Void&gt;()

    mockTrigger
        .flatMapLatest { mockDataTask }
        .subscribe(onNext: { print(""RECEIVED VALUE"") })
        .disposed(by: disposeBag)

    mockTrigger.onNext(())
    mockTrigger.onCompleted()

    mockDataTask.onNext(()) // -&gt; ""RECEIVED VALUE"" is printed
}
</code></pre>

<p>This same setup in Combine doesn't behave the same way:</p>

<pre><code>var cancellables = Set&lt;AnyCancellable&gt;()

func switchToLatestDemo() {
    let mockTrigger = PassthroughSubject&lt;Void, Never&gt;()
    let mockDataTask = PassthroughSubject&lt;Void, Never&gt;()

    mockTrigger
        .map { mockDataTask }
        .switchToLatest()
        .sink { print(""RECEIVED VALUE"") }
        .store(in: &amp;cancellables)

    mockTrigger.send(())
    mockTrigger.send(completion: .finished)

    mockDataTask.send(()) // -&gt; Nothing is printed, if I uncomment the finished event above then ""RECEIVED VALUE"" is printed
}
</code></pre>

<p>Is this intentional? If so, how do we replicate the behaviour of <code>flatMapLatest</code> in Combine?</p>

<p>If it's not intentional, file a radar I guess?</p>
","5165429","","","","","2019-10-19 11:41:14","switchToLatest in Combine doesn't behave as expected","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"58442827","1","58454328","","2019-10-18 01:40:54","","6","8873","<p>I have created a custom text field and I'd like to take advantage of Combine. In order to be notified whenever text changes in my text field, I currently use a custom modifier. It works well, but I want this code could inside my CustomTextField struct. </p>

<p>My CustomTextField struct conforms to UIViewRepresentable. Inside this struct, there is a NSObject class called Coordinator and it conforms to UITextFieldDelegate. </p>

<p>I'm already using other UITextField delegate methods, but couldn't find one that does exactly what I already do with my custom modifier. Some methods are close, but don't quite behave the way I want them to. Anyway, I feel it would be best to put this new custom textFieldDidChange method in the Coordinator class. </p>

<p><strong>Here is my custom modifier</strong></p>

<pre><code>private let textFieldDidChange = NotificationCenter.default
    .publisher(for: UITextField.textDidChangeNotification)
    .map { $0.object as! UITextField}


struct CustomModifer: ViewModifier {

     func body(content: Content) -&gt; some View {
         content
             .tag(1)
             .onReceive(textFieldDidChange) { data in

                //do something

             }
    }
}
</code></pre>

<p>My CustomTextField is used in a SwiftUI view, with my custom modifier attached to it. I’m able to do things when ever there are changes to the text field. The modifier is also using Combine. It works great, but I don't want this functionality to be in the form of a modifier. I want to use it in my Coordinator class, along with my UITextFieldDelegate methods.</p>

<p><strong>This is my CustomTextField</strong></p>

<pre><code>struct CustomTextField: UIViewRepresentable {

    var isFirstResponder: Bool = false
    @EnvironmentObject var authenticationViewModel: AuthenticationViewModel

    func makeCoordinator() -&gt; Coordinator {
        return Coordinator(authenticationViewModel: self._authenticationViewModel)
    }

    class Coordinator: NSObject, UITextFieldDelegate {

        var didBecomeFirstResponder = false
        @EnvironmentObject var authenticationViewModel: AuthenticationViewModel

        init(authenticationViewModel: EnvironmentObject&lt;AuthenticationViewModel&gt;)
        {
            self._authenticationViewModel = authenticationViewModel
        }

        // Limit the amount of characters that can be typed in the field
        func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool {

            let currentText = textField.text ?? """"
            guard let stringRange = Range(range, in: currentText) else { return false }
            let updatedText = currentText.replacingCharacters(in: stringRange, with: string)
            return updatedText.count &lt;= 14
        }

        /* I want to put my textFieldDidChange method right here */

        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * */


        func textFieldDidEndEditing(_ textField: UITextField) {

            textField.resignFirstResponder()
            textField.endEditing(true)
        }

    }

    func makeUIView(context: Context) -&gt; UITextField {

        let textField = UITextField()
        textField.delegate = context.coordinator
        textField.placeholder = context.coordinator.authenticationViewModel.placeholder
        textField.font = .systemFont(ofSize: 33, weight: .bold)
        textField.keyboardType = .numberPad

        return textField
    }

    func updateUIView(_ uiView: UITextField, context: Context) {

        let textField = uiView
        textField.text = self.authenticationViewModel.text
    }
}

struct CustomTextField_Previews: PreviewProvider {

    static var previews: some View {
        CustomTextField()
            .previewLayout(.fixed(width: 270, height: 55))
            .previewDisplayName(""Custom Textfield"")
            .previewDevice(.none)
    }
}
</code></pre>

<p>I've been watching videos about Combine and I'd like to start utilising it in a new app I'm building. I really think it's the right thing to use in this situation, but still not quite sure how to pull this off. I'd really appreciate an example.</p>

<p><strong>To summarise:</strong></p>

<p>I want to add a function called textFieldDidChange to my Coordinator class, and it should be triggered every time there is a change to my text field. It must utilise Combine.</p>

<p>Thanks in advance</p>
","439688","","439688","","2019-10-18 17:34:33","2020-05-22 14:08:05","How can I use Combine to track UITextField changes in a UIViewRepresentable class?","<swift><uitextfield><swiftui><uitextfielddelegate><combine>","3","4","6","","","CC BY-SA 4.0"
"58448055","1","58448734","","2019-10-18 09:36:33","","0","475","<p>I would like to assign a result form a notification center publisher to the variable <code>alert</code>. The Error that I get is:</p>

<pre><code>Cannot use instance member 'alerts' within property initializer; property initializers run before 'self' is available
</code></pre>

<p>Could Someone help me out here?</p>

<pre><code>import Foundation
import SwiftUI
import Combine

final class PublicAlerts: ObservableObject{

    init () {
        fetchAlerts()
    }

    var alerts = [String](){
        didSet {
            didChange.send(self)
        }
    }

    private func fetchPublicAssets(){
        backEndService().fetchAlerts()
    }

    let publicAssetsPublisher = NotificationCenter.default.publisher(for: .kPublicAlertsNotification)
        .map { notification in
            return notification.userInfo?[""alerts""] as! Array&lt;String&gt;
        }.sink {result in
            alerts = result
        }

    let didChange = PassthroughSubject&lt;PublicAlerts, Never&gt;()
}
</code></pre>

<p>Later I will use <code>alerts</code> this in SwiftUI as a List </p>
","4129110","","","","","2019-10-18 10:14:17","How to assign sink result to variable","<swift><swiftui><nsnotificationcenter><combine>","1","0","","","","CC BY-SA 4.0"
"58452003","1","","","2019-10-18 13:34:55","","0","2943","<p>In RxSwift, a flatMap operator can easily return a non-completing Observable. Let's say we have this (contrived and silly) Observable chain:</p>

<pre><code>let repo = DataRepository()

Observable
    .just(Int.random(in: 0 ..&lt; 1000))
    .flatMap { num -&gt; Observable&lt;String&gt; in
        if num == 42 {
            return .never()
        }

        return repo
            .fetchData()
            .filter { $0.statusCode == 200 }
            .map { $0.data.title }
    }
</code></pre>

<p>With Combine, the closest I can get is something like this (haven't tried to compile, but you get the idea):</p>

<pre><code>Just(Int.random(in: 0 ..&lt; 1000))
    .flatMap { num -&gt; AnyPublisher&lt;String, Never&gt; in
        if num == 42 {
            return Empty&lt;String, Never&gt;(completeImmediately: false).eraseToAnyPublisher()
        }

        return repo
            .fetchData()
            .filter { $0.statusCode == 200 }
            .map { $0.data.title }
            .eraseToAnyPublisher()
    }
</code></pre>

<p>I'm okay-ish with this solution, but I see two problems that I would like to avoid:</p>

<p>1) The Combine solution is somewhat more verbose to achieve the same thing.</p>

<p>2) I have to call <code>eraseToAnyPublisher()</code> on both returned Publishers, else the return types don't match. I believe calling <code>eraseToAnyPublisher()</code> prevents Swift from applying some internal optimizations (I can't find the article I read about this optimization anymore; the information is scarce around this)</p>

<p>Does anyone have a better approach to handling this example scenario?</p>
","6900003","","","","","2019-10-18 21:26:06","Never return in a Flatmap with Swift's Combine","<swift><rx-swift><combine>","1","2","","","","CC BY-SA 4.0"
"58462153","1","","","2019-10-19 09:13:50","","1","477","<p>I'm trying to get a better understanding of how to use Combine and want to use it to load cached content in the small example below.</p>

<p>Basically my problem is trying to achieve 2b in the below pseudo code.</p>

<blockquote>
  <p>Step 1: Go to cache and check for cached content<br>
  Step 2a: If nothing in the cache -> Fetch stuff from the api client -> Cache content -> Return fetched content publisher<br>
  Step 2b: If cached content -> Return cached content publisher</p>
</blockquote>

<p>The code below works, but of course produce the warning <code>⚠️ Will never be executed</code> on <code>fatalError()</code> since <code>Just</code> can never produce an error.</p>

<p>This was just the best solution I could come up with to make the compiler happy.<br>
What Combine-functionality should be used in this case?</p>

<pre><code>public func trainStationsPublisher() -&gt; AnyPublisher&lt;[TrainStation], Error&gt; {
    // Create cache publisher
    let cachePublisher = loadTrainStationsFromCache()

    // Create publisher to fetch train stations from API client (map to new object) and update cache.
    let apiPublisher = apiClient.trainStationsPublisher()
        .map { $0.compactMap(TrainStation.init) }
        .handleEvents(receiveOutput: { (trainStations) in
            self.cachedTrainStations = trainStations
        })

    // Check the cache and return the result if it exists, otherwise fetch data from the api client.
    return cachePublisher
        .append(apiPublisher)
        .first()
        .eraseToAnyPublisher()
}

public func loadTrainStationsFromCache() -&gt; AnyPublisher&lt;[TrainStation], Error&gt; {
    return Deferred&lt;AnyPublisher&lt;[TrainStation], Error&gt;&gt; { () -&gt; AnyPublisher&lt;[TrainStation], Error&gt; in
        if let stations = self.cachedTrainStations {

            // This is the best I've managed to come up with.
            // Just mapping a non-existent error in order to get the desired return type. 
            // Note: fatalError() will never ever be executed since Just(stations) will never fail.
            // How am I suppose to return the cached stations in a publisher?

            return Just(stations).mapError { _ -&gt; Error in
                fatalError()
            }
            .eraseToAnyPublisher()
        } else {
            return Empty&lt;[TrainStation], Error&gt;().eraseToAnyPublisher()
        }
    }.eraseToAnyPublisher()
}
</code></pre>
","1075405","","1075405","","2019-10-19 09:31:33","2019-10-19 09:31:33","How to load cached content using Combine?","<ios><swift><combine>","0","2","","","","CC BY-SA 4.0"
"58493262","1","58494465","","2019-10-21 19:54:46","","1","932","<p>Is there a way to use Combine to Encode an object to <code>urlRequest.httpBody</code> or return the error from decoding as AnyPublisher with a certain error type.</p>

<p>I'm unable to get this to work and there seems to be no code examples for encoding objects using combine. Having to force cast the encoding error to be AnyPublisher doesn't seem right / is unsafe.</p>

<p>Thanks</p>

<pre><code>func create(object: ExampleObject, token: Token) -&gt; AnyPublisher&lt;ExampleObject, API.Error&gt; {

    let url = API.EndPoint.players.url
    var urlRequest = URLRequest(url: url)
    urlRequest.httpMethod = ""POST""
    urlRequest.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")
    urlRequest.addValue(""Bearer \(token)"", forHTTPHeaderField: ""Authorization"")
    do {
        // is there a safe combine way to encode this
        urlRequest.httpBody = try JSONEncoder().encode(object)
    } catch {
        // Is there a better way to handle this
        return error as! AnyPublisher&lt;ExampleObject, API.Error&gt;
    }

    return session
        .dataTaskPublisher(for: urlRequest)
        .map(\.data)
        .decode(type: ExampleObject.self, decoder: JSONDecoder())
        .mapError { error in
            switch error {
            case is URLError:
                return API.Error.addressUnreachable
            default:
                return API.Error.invalidResponse
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
","6049579","","","","","2019-10-21 21:38:51","Using Combine to encode object to httpBody in URLRequest","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"58498567","1","58728403","","2019-10-22 06:51:16","","1","259","<p>I tried to make a generic method that takes in a <code>TopLevelEncoder</code> and a <code>TopLevelDecoder</code> in order to make it injectable (eg. <code>JSONEncoder</code> in production code and <code>CustomEncoder</code> for testing). Since both of the protocols have associated types I have constraint their type rather than just doing <code>encoder: TopLevelEncoder = JSONEncoder()</code>. I came up with this method:</p>

<pre><code>func test&lt;Encoder, Decoder&gt;(
    encoder: Encoder = JSONEncoder(),
    decoder: Decoder = JSONDecoder()
) where Encoder: TopLevelEncoder, Decoder: TopLevelDecoder {
    //encode and decode
}
</code></pre>

<p>The compiler gives me following error message: <code>Default argument value of type 'JSONEncoder' cannot be converted to type 'Encoder'</code>. I don't understand how it can not be converted to type <code>Encoder</code> since <code>JSONEncoder</code> inherits from <code>TopLevelEncoder</code>.</p>

<p>I might be misunderstanding how generics and <code>associatedType</code> work but I can't wrap my head around this error message either. Could someone help me out?</p>

<p>I have seen other approaches for this problem like creating a new protocol like <code>AnyEncoder</code> and extend <code>JSONEncoder</code> with it. But in my opinion it would just be cleaner to use the existing protocol. Also my method requires a <code>TopLevelDecoder</code> since I am using the <code>URLSessions</code>s <code>.dataTaskPublisher</code> (<code>.decode(...)</code>).</p>
","5410199","","","","","2019-11-06 11:26:26","Default argument value of type 'JSONEncoder' cannot be converted to type 'Encoder' (TopLevelEncoder)","<swift><generics><dependency-injection><combine>","1","3","","","","CC BY-SA 4.0"
"58514673","1","60512197","","2019-10-23 02:34:34","","4","491","<p>When I pass a property which is declared as <code>@Published</code> to a generic function, I get an error referring to the published value. It's fine anywhere else where I use the variable, just not when passing into the generic function. </p>

<p>Error:</p>

<pre><code>error: cannot convert value 'user' of type 'User?' to expected type 'Published&lt;User?&gt;.Publisher?', use wrapper instead
</code></pre>

<p>Here's the playground code:</p>

<pre class=""lang-swift prettyprint-override""><code>struct User {}

class Test {
    @Published var user: User?
}

func normalFunc(_ argument: User?) -&gt; User? {
    return argument
}

func genericFunc&lt;T&gt;(_ argument: T?) -&gt; T? {
    return argument
}

let test = Test()
normalFunc(test.user) // Ok
genericFunc(test.user) // Error
</code></pre>

<p>The best I have been able to do is wrap the value in parenthesis, like so:</p>

<pre><code>genericFunc((test.user)) // Ok!
</code></pre>
","359532","","359532","","2020-03-03 17:02:05","2020-03-03 17:02:41","How to access the wrapped value of a @Published property when passing to generic function","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"58525674","1","58548503","","2019-10-23 14:54:48","","1","648","<p>i'm try to learn SwiftUI, i'm try to update my list automatically once I insert the value.
but i'm getting a big issue! my list not update when I use a sheet or a navigation view to insert data, it only work if I load data from my contentView.</p>

<p>(and I don't understand why, the class DataManager is ObservableObject and more over it work perfectly if I load data with 3 textfield in the content view)</p>

<p>here below my project:
I have a Data Model</p>

<pre><code>
import Foundation
import Combine

class DataModel: Codable, Identifiable {
    var id: UUID = UUID()
    var airportName : String
    var metar : String
    var taf : String

init(airportName: String, metar: String, taf: String) {
    self.airportName = airportName
    self.metar = metar
    self.taf = taf
}
}
</code></pre>

<p>I have a DataManager </p>

<pre><code>import SwiftUI
import Combine

class DataManager: ObservableObject {
    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()


    var storage : [DataModel] = [] {
        willSet {
            objectWillChange.send()
        }
    }
    typealias Storage = [DataModel]

    var filePath : String = """"

    init() { caricaDati() }

    func caricaDati() {
        // creiamo il percorso al file
        filePath = cartellaDocuments() + ""test.plist""

        // usiamo NSFileManager per sapere se esiste un file a quel percorso
        if FileManager.default.fileExists(atPath: filePath) {

            // se c'è de-archiviamo il file di testo nell'array
            // serve il blocco do try catch
            do {
                // proviamo a caricare il file dal percorso creato in precedenza
                let data = try Data(contentsOf: URL(fileURLWithPath: filePath))
                // creiamo il decoder
                let decoder = PropertyListDecoder()
                // proviamo a decodificare il file nell'array
                storage = try decoder.decode(Storage.self, from: data)
            } catch {
                // se non ce la fa scriviamo in console l'errore
                debugPrint(error.localizedDescription)
            }

        }
    }

    func salva() {
        objectWillChange.send()
        let encoder = PropertyListEncoder()
        encoder.outputFormat = .xml // impostiamo l'output corretto
        // serve il blocco do try catch
        do {
            // proviamo a codificare l'array
            let data = try encoder.encode(storage)
            // proviamo a salvare l'array codificato nel file
            try data.write(to: URL(fileURLWithPath: filePath))
        } catch {
            // se non ce la fa scriviamo in console l'errore
            debugPrint(error.localizedDescription)
        }
    }

    func newData (nomeApt: String, metar: String, taf: String) {
        let newadd = DataModel(airportName: nomeApt, metar: metar, taf: taf)
        objectWillChange.send()
        storage.append(newadd)
        objectWillChange.send()
        salva()
    }

    func cartellaDocuments() -&gt; String {
        let paths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)
        //print(paths[0])
        return paths[0]
    }
}
</code></pre>

<p>as you can see Datamanager is ObservableObject! and I have a simple function (newData) to add the value to the array storage.</p>

<p>now my problem is :
if I add data via 3 textfield in the ContentView() my List update automatically with no issue at all</p>

<pre><code>import SwiftUI

struct ContentView: View {
    @ObservedObject var dm : DataManager
    @State var isAddPresented : Bool = false
    @State var nomeApt : String = """"
    @State var metar : String = """"
    @State var taf : String = """"

    var body: some View {

        VStack {
            Button(action: {
                           self.dm.newData(nomeApt: self.nomeApt, metar: self.metar, taf: self.taf)

                       }) {
                           Text(""Add from below"")
                       }
            TextField(""name apt"", text: $nomeApt)
            TextField(""name apt"", text: $metar)
            TextField(""name apt"", text: $taf)

            Button(action: {
                self.isAddPresented = true
            }) {
                Text(""open view to add"")
            }.sheet(isPresented: $isAddPresented) {
                Add(dm: DataManager(), dismissFlag: self.$isAddPresented)
            }
            List(dm.storage) { item in
                HStack {
                    Text(item.airportName)
                    Text(item.metar)
                    Text(item.taf)
                }
            }

        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(dm: DataManager())
    }
}

</code></pre>

<p>but if I use a sheet to add the same data, using the same function the List not update immediately!</p>

<p>here my second view:</p>

<pre><code>import SwiftUI

struct Add: View {
   @ObservedObject var dm : DataManager
    @State var nomeApt : String = """"
    @State var metar : String = """"
    @State var taf : String = """"
    @Binding var dismissFlag: Bool

    var body: some View {
        VStack {
            Spacer()
            TextField(""name apt"", text: $nomeApt)
            TextField(""name apt"", text: $metar)
            TextField(""name apt"", text: $taf)
            Button(action: {
                self.dm.newData(nomeApt: self.nomeApt, metar: self.metar, taf: self.taf)
                self.dismissFlag = false
            }) {
                Text(""Aggiungi"")
            }
            Spacer()
        }
    }
}

struct Add_Previews: PreviewProvider {
    static var previews: some View {
        Add(dm: DataManager(), dismissFlag: bindBool())
    }
}

func bindBool() -&gt; Binding&lt;Bool&gt; {
    var boolVariable : Bool = true
    let boolVariableBinding : Binding&lt;Bool&gt; = Binding(get: { boolVariable },
                                                      set: { boolVariable = $0 })
    return boolVariableBinding
}
</code></pre>

<p>what I totally don't understand is, why if I load the data from the content view my list update automatically, but if I use a navigation view of a sheet view this not work.</p>

<p>thanks in advance for the help</p>
","9962676","","","","","2019-10-24 20:08:49","ObservedObject List Update","<arrays><swift><xcode><observable><combine>","1","0","","","","CC BY-SA 4.0"
"58530722","1","58531613","","2019-10-23 20:41:42","","4","2414","<p>I hope I'm wrong, but I have not been able to find a SwiftUI equivalent to an editable
UITextView. So, I built one using UIViewRepresentable. Populating both a SwiftUI Text
and my own view with the ObservableObject works - but updates made in my view are
not propagated to the ObservableObject. I must be missing something important with
the Binding concept. Any guidance would be appreciated.</p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {

    @ObservedObject var myOText: MyOText

    var body: some View {
        ScrollView {
            VStack {
                Text(""This is a bound Text View"")
                    .padding(.top, 10)
                    .font(.headline)

                Text(myOText.inTheCourse)
                    .lineLimit(3)
                    .padding()

                Text(""This is a multi-line UITextView wrapper:"")
                    .font(.headline)

                MultilineTextView(myOText: myOText)
                    .frame(height: 100)
                    .padding()

                Spacer()
            }
        }
    }
}

struct MultilineTextView: UIViewRepresentable {

    @ObservedObject var myOText: MyOText

    func makeUIView(context: Context) -&gt; UITextView {
        let view = UITextView()
        view.isScrollEnabled = true
        view.isEditable = true
        view.isUserInteractionEnabled = true
        view.textAlignment = .center
        view.font = UIFont(name: ""Times New Roman"", size: 20)
        return view
    }

    func updateUIView(_ uiView: UITextView, context: Context) {
        uiView.text = myOText.inTheCourse
    }
}

class MyOText: ObservableObject {
    @Published var inTheCourse: String = ""When in the Course of human events, it becomes necessary for one people to dissolve the political bands which have connected them ...""
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(myOText: MyOText())
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/YfFMS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YfFMS.png"" alt=""enter image description here""></a> 
Xcode Version 11.2 beta 2 (11B44), iOS 13.</p>
","2698617","","","","","2019-10-23 22:13:43","SwiftUI Wrapper for UITextView not updating ObservedObject","<xcode><swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"58559908","1","58584005","","2019-10-25 13:53:25","","14","10013","<p>I've seen how to transition to Combine using a Publisher from some <code>NotificationCenter</code> code, but have not seen how to do it for something like:</p>

<pre><code>        NotificationCenter.default.addObserver(
        self,
        selector: #selector(notCombine),
        name: NSNotification.Name(rawValue: ""notCombine""),
        object: nil
    )
</code></pre>

<p>I've seen that this is available as a Publisher, but I <strong>don't have a <code>selector</code></strong> and am not sure what to do for it:</p>

<pre><code>        NotificationCenter.default.publisher(
        for: Notification.Name(rawValue: ""notCombine"")
    )
</code></pre>

<p>Does anyone know? Thanks!</p>
","4205674","","","","","2019-10-29 18:07:26","Combine: Going from Notification Center addObserver with selector to Notification publisher","<swift><combine>","2","0","7","","","CC BY-SA 4.0"
"58563942","1","","","2019-10-25 18:32:33","","2","1030","<p>I have the following function to perform an URL request:</p>

<pre class=""lang-swift prettyprint-override""><code>final class ServiceManagerImpl: ServiceManager, ObservableObject {
    private let session = URLSession.shared

    func performRequest&lt;T&gt;(_ request: T) -&gt; AnyPublisher&lt;String?, APIError&gt; where T : Request {
        session.dataTaskPublisher(for: self.urlRequest(request))
            .tryMap { data, response in
                try self.validateResponse(response)
                return String(data: data, encoding: .utf8)
            }
            .mapError { error in
                return self.transformError(error)
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>Having these 2 following functions, I can now call the desired requests from corresponded <em>ViewModel</em>:</p>

<pre class=""lang-swift prettyprint-override""><code>final class AuditServiceImpl: AuditService {
    private let serviceManager: ServiceManager = ServiceManagerImpl()

    func emptyAction() -&gt; AnyPublisher&lt;String?, APIError&gt; {
        let request = AuditRequest(act: """", nonce: String.randomNumberGenerator)
        return serviceManager.performRequest(request)
    }

    func burbleAction(offset: Int) -&gt; AnyPublisher&lt;String?, APIError&gt; {
        let request = AuditRequest(act: ""burble"", nonce: String.randomNumberGenerator, offset: offset)
        return serviceManager.performRequest(request)
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>final class AuditViewModel: ObservableObject {
    @Published var auditLog: String = """"
    private let auditService: AuditService = AuditServiceImpl()

    init() {
        let timer = Timer(timeInterval: 5, repeats: true) { _ in
            self.getBurbles()
        }
        RunLoop.main.add(timer, forMode: .common)
    }

    func getBurbles() {
        auditService.emptyAction()
            .flatMap { [unowned self] offset -&gt; AnyPublisher&lt;String?, APIError&gt; in
                let currentOffset = Int(offset?.unwrapped ?? """") ?? 0
                return self.auditService.burbleAction(offset: currentOffset)
            }
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { [unowned self] completion in
                print(completion)
            }, receiveValue: { [weak self] burbles in
                self?.auditLog = burbles!
            })
            .store(in: &amp;cancellableSet)
    }
}
</code></pre>

<p>Everything is fine when I use <code>self.getBurbles()</code> for the first time. However, for the next calls, <code>print(completion)</code> shows <code>finished</code>, and the code doesn't perform <code>self?.auditLog = burbles!</code></p>

<p>I don't know how can I loop over the <code>getBurbles()</code> function and get the response at different intervals.</p>

<p><strong>Edit</strong></p>

<p>The whole process in a nutshell:</p>

<ul>
<li>I call <code>getBurbles()</code> from class initializer</li>
<li><code>getBurbles()</code> calls 2 nested functions: <code>emptyAction()</code> and <code>burbleAction(offset: Int)</code></li>
<li>Those 2 functions generate different requests and call <code>performRequest&lt;T&gt;(_ request: T)</code></li>
<li>Finally, I set the response into <code>auditLog</code> variable and show it on the <em>SwiftUI</em> layer</li>
</ul>
","7264553","","7264553","","2019-10-25 19:02:46","2019-10-26 00:21:18","Loop over Publisher Combine framework","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"58564495","1","","","2019-10-25 19:16:54","","6","3766","<p>I am attempting to parse JSON using the new Combine framework. However, every attempt I make comes back with a cancelled error. When I use the exact same url without combine it works fine. </p>

<p><strong>The bottom function works fine, the top one gives me an error no matter what I do.</strong> </p>

<pre class=""lang-swift prettyprint-override""><code>static func performNetworkRequestUsingCombine(url urlWithQuery:URL){
        //let decoder = JSONDecoder()
        let publisher = URLSession.shared.dataTaskPublisher(for: urlWithQuery)
            .map({$0.data})

        .eraseToAnyPublisher()
            .sink(receiveCompletion: { (status) in
                switch status {
                    case .failure(let incomingError):
                        print(incomingError.localizedDescription)
                    case .finished:
                    break
                }
            }) { (data) in
                let dataString = String(data: data, encoding: .utf8)
                print(dataString!)
        }
        publisher.cancel()
    }

static func performNetworkRequest(url urlWithQuery: URL, dataValue : @escaping (WeatherObject)-&gt;Void){

        let decoder = JSONDecoder()
        let task = URLSession.shared.dataTask(with: urlWithQuery) { (data, response, error) in

            if error != nil {
                print(error!.localizedDescription)
                return
            }
            if let data = data {
                do {
                    let weatherData = try decoder.decode(WeatherObject.self, from: data)
                    dataValue(weatherData)
                } catch let localError {
                    print(localError.localizedDescription)
                }
            }
        }
        task.resume()
    }

}
</code></pre>

<p>I expect to receive my JSON data printed in the terminal but instead I receive the following error:</p>

<p>2019-10-25 14:59:34.452071-0400 Clima[2127:98883] Task &lt;663D6D3A-48B8-49E6-9103-AA1D89513D84>.&lt;1> finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled"" UserInfo={NSErrorFailingURLStringKey=<a href=""https://api.openweathermap.org/data/2.5/weather?lon=-122.4&amp;APPID=29ecd35ff6b9e63498cb8fb479ba6ca0&amp;units=imperial&amp;lat=37.8"" rel=""noreferrer"">https://api.openweathermap.org/data/2.5/weather?lon=-122.4&amp;APPID=29ecd35ff6b9e63498cb8fb479ba6ca0&amp;units=imperial&amp;lat=37.8</a>, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=<a href=""https://api.openweathermap.org/data/2.5/weather?lon=-122.4&amp;APPID=29ecd35ff6b9e63498cb8fb479ba6ca0&amp;units=imperial&amp;lat=37.8"" rel=""noreferrer"">https://api.openweathermap.org/data/2.5/weather?lon=-122.4&amp;APPID=29ecd35ff6b9e63498cb8fb479ba6ca0&amp;units=imperial&amp;lat=37.8</a>}</p>
","12247487","","","","","2020-08-18 01:54:56","How to resolve - Combine Error | Error Domain=NSURLErrorDomain Code=-999 ""cancelled""","<ios><swift><xcode><urlsession><combine>","1","0","","","","CC BY-SA 4.0"
"58565086","1","58567001","","2019-10-25 20:06:53","","0","910","<p>I am trying to display results of a realmdb query in a SwiftUI list but have trouble when deleting database objects. </p>

<p>I am trying to use something like this: </p>

<pre><code>final class DBData: ObservableObject{

let didChange = PassthroughSubject&lt;DBData, Never&gt;()

private var notificationTokens: [NotificationToken] = []
var events = try! Realm().objects(ADMEvent.self)
@Published var events: [ADMEvent] = []
init() {
    // Observe changes in the underlying model
    self.notificationTokens.append(posts.observe { _ in
        self.events = Array(self.posts)
        self.didChange.send(self)
    })
}
}
</code></pre>

<p>Which works if I display items In a list but the moment I use realm.deleteAll() the app crashes because it looks like Swift UI's list implementation is trying to diff the list, accessing the now invalidated realm db objects. </p>

<p>There are like 3 or 4 similar questions on stack overflow but they are all out of date in one way or another, or work but still have this issue when it comes to deletion. </p>

<p>Thanks!</p>
","582141","","","","","2020-04-24 21:20:33","How can I properly map RealmDB Results objects to SwiftUI Lists?","<swift><swiftui><combine><swiftui-list><realm-database>","2","0","1","","","CC BY-SA 4.0"
"58572631","1","58575017","","2019-10-26 16:29:38","","4","977","<p>I am trying to wrap my head around SwiftUI and Combine. I want to keep some text in the UI up-to-date with a value. In this case, it's the battery level of the device, for example.</p>

<p>Here is my code. First of all, it seems like this is quite a bit of code to achieve what I want to do, so I'm wondering if I may be able to do without some of it. Also, this code used to run over the summer, but now it crashes, probably due to changes in SwiftUI and Combine.</p>

<p>How can this be fixed to work with the current version of SwiftUI and Combine? And, is it possible to cut back on the amount of code here to do the same thing?</p>

<pre><code>import SwiftUI
import Combine

class ViewModel: ObservableObject {

    var willChange = PassthroughSubject&lt;Void, Never&gt;()

    var batteryLevelPublisher = UIDevice.current
        .publisher(for: \.batteryLevel)
        .receive(on: RunLoop.main)

    lazy var batteryLevelSubscriber = Subscribers.Assign(object: self,
                                                         keyPath: \.batteryLevel)

    var batteryLevel: Float = UIDevice.current.batteryLevel {
        didSet {
            willChange.send()
        }
    }

    init() {
        batteryLevelPublisher.subscribe(batteryLevelSubscriber)
    }
}

struct ContentView: View {

    @ObservedObject var viewModel = ViewModel()

    var body: some View {
        Text(""\(Int(round(viewModel.batteryLevel * 100)))%"")
    }
}
</code></pre>
","241163","","","","","2019-11-27 21:28:24","What is the most concise way to display a changing value with Combine and SwiftUI?","<ios><swift><swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"58588286","1","58593154","","2019-10-28 09:16:39","","2","787","<p>I have a simple TextField for telephone input, and want to format it each time it being changed. </p>

<p>I'm using PhoneNumberKit and it works fine, but i do not understand how to call formatting func after the value in textField have changed.</p>

<p>Telephone Formatting function. </p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import PhoneNumberKit
import Combine

func formatTelephone(telephone : String) -&gt; String
    {

        do {
            let phoneNumber =  PartialFormatter().formatPartial(telephone)

            print(phoneNumber)
            return phoneNumber
        }
        catch {
            print(""Generic parser error"")

        }
    }
</code></pre>

<p>It does something like this:</p>

<pre><code>formatTelephone(""79152140700"") -&gt; ""7 (915) 214 08-00"" 
formatTelephone(""791521"") -&gt; ""7 (915) 21"" 
</code></pre>

<p>and i have a TextField like that</p>

<pre><code>TextField(""915 214 07 00"" , text: $telephoneManager.telephone)
</code></pre>

<p>After each input of a digit the whole textfield label needs to be formatted by a func and show user's input in a better way.</p>
","11911126","","","","","2019-10-28 14:51:22","How to format TextField input string by function?","<ios><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"58603932","1","59030337","","2019-10-29 08:46:46","","8","9089","<p>How would you detect a change of value of a Datepicker while using SwiftUI and Combine?
I need to invoke a method whenever the datepicker wheel is moved, to update a Text and a Slider.</p>

<p>I have looked for specific methods to identify the value change (using UIKit it was possible to associate an action to an event), but apparently I haven't found anything useful in the documentation (I've tried the onTapGesture methods, but that's not what I want, since it forces the user to tap the picker to update the other views, whereas I would like to have an automatic update whenever the user moves the wheel).</p>

<pre><code>import SwiftUI

struct ContentView: View {

    private var calendar = Calendar.current

    @State private var date = Date()
    @State private var weekOfYear = Double(Calendar.current.component(.weekOfYear, from: Date()) )
    @State private var lastWeekOfThisYear = 53.0
    @State private var weekDay: String = { () -&gt; String in 
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = ""EEEE""
        let weekDay = dateFormatter.string(from: Date())
        return weekDay
    }()

    var body: some View {

        VStack {

            // Date Picker
            DatePicker(selection: $date, displayedComponents: .date, label:{ Text(""Please enter a date"") }
            )
            .labelsHidden()
            .datePickerStyle(WheelDatePickerStyle())
            .onTapGesture {
                self.updateWeekAndDayFromDate()
            }

            // Week number and day
            Text(""Week \(Int(weekOfYear.rounded()))"")
            Text(""\(weekDay)"")

            // Slider
            Slider(value: $weekOfYear, in: 1...lastWeekOfThisYear, onEditingChanged: { _ in
                    self.updateDateFromWeek()
                })
            }

    }

    func updateWeekAndDayFromDate() {
        // To do
    }

    func updateDateFromWeek() {
        // To do
    }

    func setToday() {
        // To do
    }

    func getWeekDay(_ date: Date) -&gt; String {
        //To do
    }
}
</code></pre>

<p>I guess this could be solved using Combine (observableobject, published, sink, etc.), but I'm not experienced yet with Combine, therefore I'd like to ask for some help... any ideas? :)</p>

<p>Thanks a lot!</p>
","7304357","","7304357","","2019-10-29 09:21:44","2022-08-23 07:15:01","How to detect a value change of a Datepicker using SwiftUI and Combine?","<events><datepicker><swiftui><combine><valuechangelistener>","4","2","2","","","CC BY-SA 4.0"
"58625016","1","","","2019-10-30 12:05:05","","4","1224","<p>I'm developing an iOS app using swiftUI and Combine framework and also MVVM.
I'm want to handle the login API request in a separate class called LoginService, which is used in the LoginViewModel.
Now I want to know how should I publish and observe the attributes between view and ViewModel.
I mean ViewModel is an ObservableObject and is being observed in the View, But since I'm handling the network request in a Service class how should LoginService notify LoginViewModel and LoginView that the data is received and the View should be updated?</p>

<pre><code>import Foundation
import Combine

class LoginViewModel: ObservableObject {

    @Published var user = UserModel()

    @Published var LoginStatus: Bool = false

    @Published var LoginMessage: String = """"

    var service = LoginService()

    func Login(With email: String, And password: String) -&gt; Bool {
        service.validateLogin(email: email, password: password)
        return false
    }
}

</code></pre>

<p>This is the Code for LoginViewModel.
How should LoginService change the values for LoginStatus, LoginMessage and user when data is received from the server to notify the View?
I'm saying this because as far as I know you can Observe the ObservableObjects only in the View(SwiftUI).</p>
","8783668","","8783668","","2019-10-30 12:22:17","2020-01-01 07:20:42","how to publish the data of a network request using Combine framework and SwiftUI","<networking><swiftui><urlsession><combine>","2","0","","","","CC BY-SA 4.0"
"58630233","1","58630312","","2019-10-30 16:50:33","","2","268","<p>I am trying to change the view when the user login, which is when the <strong>isAuthenticated</strong> is updated in the <strong>Authentication</strong> class, but it never gets the new value, I am not sure if I am understanding everything correctly.</p>

<p><strong>Authentication</strong></p>

<pre><code>class Authentication: ObservableObject{

    @Published var email: String = """"
    @Published var password: String = """"
    @Published var isAuthenticated : Bool = false

    func login(){
        AppDelegate._bc.authenticateEmailPassword(email,
                                                  password: password,
                                                  forceCreate: false,
                                                  completionBlock: onAuthenticate,
                                                  errorCompletionBlock: onAuthenticateFailed,
                                                  cbObject: nil)
    }

    func onAuthenticate(serviceName:String?, serviceOperation:String?, jsonData:String?, cbObject: NSObject?) {

        /............./

        UserDefaults.standard.set(true, forKey: ""HasAuthenticated"")
        self.isAuthenticated.toggle()
        print(""Login DONE!"")
    }
}
</code></pre>

<p>Everything is okay till now, the user gets authenticated, it prints ""Login DONE!"" and it updates the <strong>isAuthenticated</strong> value to true.</p>

<p>But in the <strong>AuthView</strong> it does not receive the new value</p>

<p><strong>AuthView</strong></p>

<pre><code>struct AuthView: View {

    @ObservedObject var auth = Authentication()

    var body: some View {
        NavigationView{
            VStack{
                /............./

                LoginView()

                NavigationLink(destination: ProfileView(), isActive: $auth.isAuthenticated) {
                    Text("""")
                }
            }
        }
    }
}
</code></pre>

<p>And here where I call the <strong>login</strong> function</p>

<p><strong>LoginView</strong></p>

<pre><code>struct LoginView: View{

    @ObservedObject var auth = Authentication()

    var body: some View {
        VStack(){
            Button(action: {
                self.auth.login()
            }) {
                LoginButtonContent(state: ""Login"")
            }
        }
    }
}
</code></pre>
","8738893","","","","","2019-10-30 16:55:34","Getting the updated value from @ObservedObject in SwiftUI","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"58635048","1","","","2019-10-30 23:37:51","","8","2484","<p>I have a <code>UIViewControllerRepresentable</code> struct that is subscribed to an <code>ObservableObject</code>, like this:</p>
<pre><code>struct ViewControllerWrapper: UIViewControllerRepresentable {
    @ObservedObject var chartVM = ChartViewModel()
    
    typealias UIViewControllerType = ViewController
    
    func makeUIViewController(context: Context) -&gt; ViewController {
        let lineChartView = LineChartView()
        let vc = ViewController(lineChartView: lineChartView)
        return vc
    }

    func updateUIViewController(_ uiViewController: ViewController, context: Context) {
        uiViewController.metrics = chartVM.metrics
        uiViewController.setChartValues()
    }
}
</code></pre>
<p>I would like that, when the <code>ObservedObject</code> changes, either <code>updateUIViewController</code> is called, or another function that updates the view controller's <code>metrics</code> array and calls its <code>setChartValues()</code> method.</p>
<p>Is there a way I can do that? I can't find one.</p>
<p>I can always do it as we used to using only UIKit, but it would be much better to do it using that MVVM pattern.</p>
<p>Help would be much appreciated, thanks!</p>
","10282246","","15959847","","2022-08-04 02:44:16","2022-08-04 02:44:16","In a UIViewControllerRepresentable, how can I pass an ObservedObject's value to the view controller and update it every time the value changes?","<ios><swift><swiftui><combine><observableobject>","1","0","","","","CC BY-SA 4.0"
"58643094","1","63524550","","2019-10-31 12:10:16","","54","15824","<p>In a SwiftUI <code>View</code> i have a <code>List</code> based on <code>@FetchRequest</code> showing data of a <code>Primary</code> entity and the via relationship connected <code>Secondary</code> entity.
The <code>View</code> and its <code>List</code> is updated correctly, when I add a new <code>Primary</code> entity with a new related secondary entity.</p>

<p>The problem is, when I update the connected <code>Secondary</code> item in a detail view, the database gets updated, but the changes are not reflected in the <code>Primary</code> List.
Obviously, the <code>@FetchRequest</code> does not get triggered by the changes in another View.</p>

<p>When I add a new item in the primary view thereafter, the previously changed item gets finally updated.</p>

<p>As a workaround, i additionally update an attribute of the <code>Primary</code> entity in the detail view and the changes propagate correctly to the <code>Primary</code> View.</p>

<p>My question is:
How can I force an update on all related <code>@FetchRequests</code> in SwiftUI Core Data?
Especially, when I have no direct access to the related entities/<code>@Fetchrequests</code>?</p>

<p><a href=""https://i.stack.imgur.com/XKkJl.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/XKkJl.png"" alt=""Data Structure""></a></p>

<pre><code>import SwiftUI

extension Primary: Identifiable {}

// Primary View

struct PrimaryListView: View {
    @Environment(\.managedObjectContext) var context

    @FetchRequest(
        entity: Primary.entity(),
        sortDescriptors: [NSSortDescriptor(key: ""primaryName"", ascending: true)]
    )
    var fetchedResults: FetchedResults&lt;Primary&gt;

    var body: some View {
        List {
            ForEach(fetchedResults) { primary in
                NavigationLink(destination: SecondaryView(primary: primary)) {
                VStack(alignment: .leading) {
                    Text(""\(primary.primaryName ?? ""nil"")"")
                    Text(""\(primary.secondary?.secondaryName ?? ""nil"")"").font(.footnote).foregroundColor(.secondary)
                }
                }
            }
        }
        .navigationBarTitle(""Primary List"")
        .navigationBarItems(trailing:
            Button(action: {self.addNewPrimary()} ) {
                Image(systemName: ""plus"")
            }
        )
    }

    private func addNewPrimary() {
        let newPrimary = Primary(context: context)
        newPrimary.primaryName = ""Primary created at \(Date())""
        let newSecondary = Secondary(context: context)
        newSecondary.secondaryName = ""Secondary built at \(Date())""
        newPrimary.secondary = newSecondary
        try? context.save()
    }
}

struct PrimaryListView_Previews: PreviewProvider {
    static var previews: some View {
        let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext

        return NavigationView {
            PrimaryListView().environment(\.managedObjectContext, context)
        }
    }
}

// Detail View

struct SecondaryView: View {
    @Environment(\.presentationMode) var presentationMode

    var primary: Primary

    @State private var newSecondaryName = """"

    var body: some View {
        VStack {
            TextField(""Secondary name:"", text: $newSecondaryName)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding()
                .onAppear {self.newSecondaryName = self.primary.secondary?.secondaryName ?? ""no name""}
            Button(action: {self.saveChanges()}) {
                Text(""Save"")
            }
            .padding()
        }
    }

    private func saveChanges() {
        primary.secondary?.secondaryName = newSecondaryName

        // TODO: ❌ workaround to trigger update on primary @FetchRequest
        primary.managedObjectContext.refresh(primary, mergeChanges: true)
        // primary.primaryName = primary.primaryName

        try? primary.managedObjectContext?.save()
        presentationMode.wrappedValue.dismiss()
    }
}
</code></pre>
","6104836","","12450141","","2020-01-31 11:22:59","2022-08-23 07:09:16","How to update @FetchRequest, when a related Entity changes in SwiftUI?","<core-data><swiftui><combine>","6","3","25","","","CC BY-SA 4.0"
"58647265","1","58651543","","2019-10-31 16:06:22","","3","1658","<p>I want an Combine operator similar to RxSwift's <a href=""https://github.com/ReactiveX/RxSwift/blob/master/RxSwift/Observables/Take.swift#L19-L28"" rel=""nofollow noreferrer""><code>take(_ n: Int)</code></a>, I written this and it seems to be working:</p>

<h1><code>first(_ n)</code> implementation</h1>

<pre class=""lang-swift prettyprint-override""><code>public extension Publisher where Failure == Never {
    /// Publishes the first `n` elements of a stream, then finishes.
    func first(_ numberOfElements: Int) -&gt; AnyPublisher&lt;Output, Failure&gt; {
        collect(numberOfElements)   // ""Buffer""
            .first()                // ""release and complete (finish)""

             // Publisher&lt;[Output]&gt; -&gt; Publisher&lt;Output&gt;
            .map { $0.publisher }.switchToLatest()  
            .eraseToAnyPublisher()
    }
}
</code></pre>

<h1>Alternative solution?</h1>

<p>Or can you come up with an alternative solution which is even better?</p>

<p>The <code>take</code> (but I named it <code>first</code>, to mirror the Combine native operator <a href=""https://developer.apple.com/documentation/combine/publisher/3204710-first"" rel=""nofollow noreferrer""><code>first</code></a> - <em>""Publishes the first element of a stream, then finishes.""</em>) operator is really convenient when writing tests, where I want a Publisher to finish after just <code>n</code> elements.</p>
","1311272","","1311272","","2019-10-31 17:58:48","2019-10-31 21:46:57","Swift Combine: `first(_ n: Int)` equivalent to RxSwift `take(_ n: Int)`?","<ios><swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"58667963","1","","","2019-11-02 03:19:45","","2","1595","<p>I'd like some help understanding why my publishers aren't emitting elements through the combineLatest operator. I have a publisher that emits video frames, and another publisher that consumes these video frames and extracts faces from these frames. I'm now trying to combine the original video frames and the transformed output into one using combineLatest (I am using some custom publishers to extract video frames and transform the frames):</p>

<pre><code>let videoPublisher = VideoPublisher //Custom Publisher that outputs CVImageBuffers
.share()

let faceDetectionPublisher = videoPublisher
.detectFaces() // Custom Publisher/subscriber that takes in video frames and outputs an array of VNFaceObservations

let featurePublisher = videoPublisher.combineLatest(faceDetectionPublisher)
.sink(receiveCompletion:{_ in
                print(""done"")
            }, receiveValue: { (video, faces) in
                print(""video"", video)
                print(""faces"", faces)
            })
</code></pre>

<p>I'm not getting any activity out of combineLatest, however. After some debugging, I think the issue is that all the videoFrames from videoPublisher are published before any can successfully flow through faceDetectionPublisher. If I attach print statements to the end of the videoPublisher and faceDetectionPublisher, I can see output from the former but none from the latter. I've read up on combine and other techniques such as multicasting, but haven't figured out a working solution. I'd love any combine expertise or guidance on how to better understand the framework!</p>
","12310779","","","","","2019-11-02 11:38:31","Swift Combine: One publisher consumes another, how to get both streams back out","<swift><publisher><combine><combinelatest>","1","3","","","","CC BY-SA 4.0"
"58672761","1","71093025","","2019-11-02 16:00:03","","3","6030","<p>Using iOS13.2, Swift-5.1.2, Xcode-11.2, I try the following:</p>

<p>I want to use a TextField. The user shall only be able to enter x-amount of characters into the TextField.</p>

<p>My code looks as follows:</p>

<pre><code>import Combine
import SwiftUI

class Entry: ObservableObject {

  @Published var entry = """" {
    didSet {
        entry = String(entry.prefix(6)) // trying to limit to 6 characters
    }
  }
}
</code></pre>

<p>And in the above code, there is already the exception line. </p>

<p>I can see that the <code>didSet{...}</code> is wrong (since we end up in an endless loop setting/didSetting again and again)...</p>

<p><strong>What is a better way to limit a TextField to x-amount of characters ?</strong></p>

<p>Here is the rest of the code:</p>

<pre><code>struct NumberView: View {
    var body: some View {

        Group {
            HStack {
                Spacer()
                NumberIcon(number: 1)
                NumberIcon(number: 2)
                NumberIcon(number: 3)
                NumberIcon(number: 4)
                NumberIcon(number: 5)
                NumberIcon(number: 6)
                Spacer()
            }
         }
    }
}
</code></pre>

<pre><code>struct NumberIcon: View {
    @ObservedObject private var entry = Entry()
    var number: Int = 0
    var body: some View {
        TextField("" "", text: $entry.entry, onEditingChanged: { editing in
            print(editing)
            print(self.$entry)
        })
            .padding()
            .foregroundColor(Color.black)
            .background(Color.green)
            .font(.largeTitle)
            .lineLimit(1)
            .cornerRadius(16.0)
            .clipped()
            .keyboardType(.numberPad)
    }
}

struct NumberView_Previews: PreviewProvider {
    static var previews: some View {
        NumberView()
    }
}
</code></pre>

<p>I know that there are UIKit wrapper possibilities to use the good-old <code>shouldChangeCharactersIn</code> delegate methods form UITextFieldDelegate - but I would like to implement the character limitation purely with SwiftUI (no UIKit code). How can I do that ?</p>
","3826232","","","","","2022-02-12 15:04:31","Limit TextField to x amount of characters using SwiftUI","<swift><textfield><swiftui><combine>","4","0","1","","","CC BY-SA 4.0"
"58675046","1","58708381","","2019-11-02 20:33:15","","4","2966","<p>I have a publisher which takes a network call and returns an array of IDs. I now need to call another network call for each ID to get all my data. And I want the final publisher to have the resulting object.</p>

<p>First network result:</p>

<pre><code>""user"": {
   ""id"": 0,
   ""items"": [1, 2, 3, 4, 5]
}
</code></pre>

<p>Final object:</p>

<pre><code>struct User {
    let id: Int
    let items: [Item]
    ... other fields ...
}
struct Item {
    let id: Int
    ... other fields ...
}
</code></pre>

<p>Handling multiple network calls:</p>

<pre><code>userPublisher.flatMap { user in
    let itemIDs = user.items
    return Future&lt;[Item], Never&gt;() { fulfill in
        ... OperationQueue of network requests ...
    }
}
</code></pre>

<p>I would like to perform the network requests in parallel, since they are not dependent on each other. I'm not sure if Future is right here, but I'd imagine I would then have code to do a
DispatchGroup or OperationQueue and fulfill when they're all done. Is there more of a Combine way of doing this?</p>

<p>Doe Combine have a concept of splitting one stream into many parallel streams and joining the streams together?</p>
","359532","","","","","2020-05-17 16:10:43","How to process an array of task asynchronously with swift combine","<swift><combine>","1","0","3","","","CC BY-SA 4.0"
"58675235","1","","","2019-11-02 20:57:09","","26","21436","<p>Given the following code:</p>

<pre><code>    enum MyError: Error {
        case someError
    }

    myButton.publisher(for: .touchUpInside).tryMap({ _ in
        if Bool.random() {
            throw MyError.someError
        } else {
            return ""we're in the else case""
        }
    })
        .replaceError(with: ""replaced Error"")
        .sink(receiveCompletion: { (completed) in
            print(completed)
        }, receiveValue: { (sadf) in
            print(sadf)
        }).store(in: &amp;cancellables)
</code></pre>

<p>Whenever I tap the button, I get <code>we're in the else case</code> until <code>Bool.random()</code> is true - now an error is thrown. I tried different things, but I couldn't achieve to catch/replace/ignore the error and just continue after tapping the button.</p>

<p>In the code example I would love to have e.g. the following output</p>

<pre><code>we're in the else case
we're in the else case
replaced Error
we're in the else case
...
</code></pre>

<p>instead I get <code>finished</code> after the <code>replaced error</code> and no events are emitted.</p>

<p><strong>Edit</strong>
Given a publisher with <code>AnyPublisher&lt;String, Error&gt;</code>, how can I transform it to a <code>AnyPublisher&lt;String, Never&gt;</code> without completing when an error occurs, i.e. ignore errors emitted by the original publisher?</p>
","27404","","27404","","2019-11-12 20:59:47","2020-11-25 13:45:47","Combine: how to replace/catch an error without completing the original publisher?","<ios><swift><combine>","7","13","7","","","CC BY-SA 4.0"
"58675933","1","","","2019-11-02 22:44:48","","3","5974","<p>I'm playing around a tad with Combine and SwiftUI for a little pet project of mine, learning as I go.</p>

<p>Here's the <code>LoginModel</code> at it current state:</p>

<pre><code>public class LoginModel: ObservableObject {
    @Published var domain: String = """"
    @Published var email: String = """"
    @Published var password: String = """"
    @Published var isValid: Bool = false
    public var didChange = PassthroughSubject&lt;Void, Never&gt;()

    var credentialsValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
        Publishers.CombineLatest($email, $password)
            .receive(on: RunLoop.main)
            .map { (email, password) in
                let emailValid = String.emailValid(emailString: email) // String extension function
                let passwordValid = password.count &gt; 5
                return emailValid &amp;&amp; passwordValid
        }
        .breakpointOnError()
        .eraseToAnyPublisher()
    }

    init() {
        // This works just fine
        _ = credentialsValidPublisher.sink { isValid in
            self.isValid = isValid
        }

        // However this does not work at all
        _ = domain
            .publisher
            .receive(on: RunLoop.main)
            .sink { value in
                print(value)
        }
    }
}
</code></pre>

<p>Now from my current understanding is that a <code>@Published var foo: String</code> already has a <code>Publisher</code> attached to it. And that one should be able to use this directly to subscribe to its changes.</p>

<p>Changing <code>credentialsValidPublisher</code> variable over to this works too:</p>

<pre><code>var credentialsValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
    Publishers.CombineLatest3($domain, $email, $password)
        .receive(on: RunLoop.main)
        .map { (domain, email, password) in
            let domainValid = URL.isValidURL(urlString: domain)
            let emailValid = String.emailValid(emailString: email)
            let passwordValid = password.count &gt; 5
            return domainValid &amp;&amp; emailValid &amp;&amp; passwordValid
    }
    .breakpointOnError()
    .eraseToAnyPublisher()
}
</code></pre>

<p>But this is not what I want. In my case I need a special <code>Publisher</code> in order to map a valid URL string over to a network request and then ping the server at hand to see if the provided server is responding.</p>

<p>Also this model is then connected to a SwiftUI view with a bunch of SwiftUI TextFields.
Any help to point me in the right direction will be highly appreciated.</p>
","2536476","","","","","2019-11-03 02:38:04","SwiftUI/Combine - Subscribing to the latest value of a single Publisher","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"58676249","1","58713969","","2019-11-02 23:43:33","","25","9129","<p>So I'm digging into combine and this question came up.</p>

<p>Is there any real difference between using <code>CurrentValueSubject</code> (and setting its value using <code>currentValueSubject.value</code>) or using a <code>@Published var</code> and accessing its publisher with a <code>$</code>? I mean I know one returns a <code>Subject</code> instead of a <code>Publisher</code>, but the only real difference I could find is that <code>CurrentValueSubject</code> is way more useful because you can declare it on a protocol.</p>

<p>I really don't understand how <code>@Published</code> can be useful if we can just use <code>PassthroughSubject</code>, am I missing something here? 
<strong>Mind you, this is using UIKit</strong>, it may have other uses for SwiftUI.</p>

<p>Thank you.</p>
","2126207","","5175709","","2022-04-17 13:55:10","2022-05-25 13:07:16","Difference between CurrentValueSubject and @Published","<ios><swift><combine><currentvaluesubject><property-wrapper-published>","5","0","3","","","CC BY-SA 4.0"
"58694448","1","59338381","","2019-11-04 13:29:20","","3","1390","<p>I'm writing a project in Combine and SwiftUI with backward compatibility for iOS 12/11 with RxSwift, RxCocoa and UIKit. My project is based on a lot of protocols, associated types and generics. When I'm running the project on iOS 13 it works fine but on iOS 12 the app suddenly crash.</p>

<p>I'm trying a Redux architecture with some changes. I have reducers, actions (as enums), stores and store providers (a store provider is intended to instantiate two stores: rxstore  and a combinestore . (i know it's not the best way to do that but I would like to understand why the bug occurs). </p>

<p>Also I have a so called <code>ReduxArchiver</code> and a <code>ReduxArchiverElement</code>. This one (<code>ReduxArchiver</code>) is like a listener or a delegate intended to handle and save redux store changes. (also I know it's not the best solution). When a store have a new state the <code>ReduxArchiver</code> handle the change, modify data as needed and decide to save or not the state on disk. Archiver is also intended to load app states from disk when a store is instantiated.</p>

<p>The error is <code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x10)</code> and appears when I'm instantiating an object of <code>ReduxArchiver</code> type. It happens because of the instantiation of <code>ReduxArchiverElement&lt;T: Codable&gt;</code> array (see the code below or here: <a href=""https://github.com/mariusjcb/CrossReduxSOA"" rel=""nofollow noreferrer"">https://github.com/mariusjcb/CrossReduxSOA</a> )</p>

<p>Sometimes it appears in console:</p>

<pre><code>libMobileGestalt MobileGestalt.c:890: MGIsDeviceOneOfType is not supported
 on this platform.
</code></pre>

<p>I don't know if it's my fault or just a swift bug because of too many associated types/generics in the project.</p>

<p>I have both combine and swiftui linked as weak frameworks so there is no problem with missing SwiftUI/Combine.</p>

<p>Also my frameworks and libraries are embedded in target settings as <code>Embed &amp; Sign</code>.</p>

<p>The actual error:</p>

<pre><code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x10)
</code></pre>

<p>When I'm doing po $arg1:</p>

<pre><code>// On #0    0x0000000108f6a93f in swift_getWitnessTable ():
(lldb) po $arg1
&lt;nil&gt;

// On #16   0x0000000108f6b308 in swift_getAssociatedTypeWitness ():
(lldb) po $arg1
error: Couldn't materialize: couldn't read the value of register rdi
error: errored out in DoExecute, couldn't PrepareToExecuteJITExpression
</code></pre>

<p>When I'm examinating the $rdi:</p>

<pre><code>//Xcode: 11.2
(lldb) register read
General Purpose Registers:
       rbx = 0x000000010ff7bdb8  libswiftCore.dylib`InitialAllocationPool + 4304
       rbp = 0x00007ffee39a3990
       rsp = 0x00007ffee39a3960
       r12 = 0x000000010cc69448  Models`protocol requirements base descriptor for Redux.Reducer
       r13 = 0x00000000000000ff
       r14 = 0x000000010cc69478  Models`associated type descriptor for StateType
       r15 = 0x000000010d1ba718  type metadata for Reducers.ExampleReducer
       rip = 0x000000010fea2308  libswiftCore.dylib`swift_getAssociatedTypeWitness + 152
13 registers were unavailable.

//Xcode 11.1
(lldb) register read --all 
General Purpose Registers:
       rax = 0x0000000000000000
       rbx = 0x0000000105d1db74  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Identifiable in Models + 16
       rcx = 0x0000000000000000
       rdx = 0x0000000000030000
       rdi = 0x0000000000000000
       rsi = 0x0000000105d1db78  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Identifiable in Models + 20
       rbp = 0x00007ffeea8fa960
       rsp = 0x00007ffeea8fa8d0
        r8 = 0x0000000000000000
        r9 = 0x0000000105d1db50  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Encodable in Models + 20
       r10 = 0x0000000108fc10a4  libswiftCore.dylib`method descriptor for Swift.Encodable.encode(to: Swift.Encoder) throws -&gt; ()
       r11 = 0x0000000000000001
       r12 = 0x0000000105d9c3b0  Models`__unnamed_24
       r13 = 0x0000000000000000
       r14 = 0x0000000105d1db74  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Identifiable in Models + 16
       r15 = 0x0000000105d1db64  Models`protocol conformance descriptor for Models.ExampleModel : Swift.Identifiable in Models
       rip = 0x0000000108f6a93f  libswiftCore.dylib`swift_getWitnessTable + 447
    rflags = 0x0000000000000247
        cs = 0x000000000000002b
        fs = 0x0000000000000000
</code></pre>

<p>Instantiation of the object:</p>

<pre><code>// In AppDelegate (as property):
// ...

let state = ExampleStoreBuilder.build()

// The Build Method from ExampleStoreBuilder

let archiveListeners = [GenericReduxArchiverLogger(""example_archiver"")]
        var listeners: [ReduceStoreOutputDelegate] = [GenericReduxStoreLogger(""example_logger"")]
ERROR&gt;&gt; let defaultStoreArchiver = ExampleArchiver&lt;ExampleRxStore&gt;(outputDelegates: archiveListeners) &lt;&lt;&lt;&lt; Error: EXC_BAD_ACCESS

        listeners.append(defaultStoreArchiver)
        listeners.append(contentsOf: archiveListeners)
        if #available(iOS 13.0, *) {
            listeners.append(ExampleArchiver&lt;ExampleCombineStore&gt;(outputDelegates: archiveListeners))
        }

        let reducer = ExampleReduceBuilder.build()
        let initialState = defaultStoreArchiver.statesHistory.last?.state ?? .emptyState
        return ReduxState&lt;ExampleStoreProvider&lt;ExampleReducer&gt;&gt;(initialState,
                                                              reducedBy: reducer,
                                                              outputDelegates: listeners)
</code></pre>

<p>The EXC_BAD_ACCESS from let defaultStoreArchiver is located in ExampleArchiver on the line: </p>

<pre><code>public var statesHistory = [ReduxArchiveElement&lt;StoreType.ReducerType.StateType&gt;]()
</code></pre>

<p>ReduxArchiverElement is defined as:</p>

<pre><code>public struct ReduxArchiveElement&lt;T: Codable&gt;: Codable {
    public let date: Date
    public let state: T

    public init(date: Date, state: T) {
        self.date = date
        self.state = state
    }
}
</code></pre>

<p>finally the StoreType and Reducer are defined as:</p>

<pre><code>// ReduceStoreInitializable protocol
public protocol ReduceStoreInitializable {
    associatedtype ReducerType: Reducer
...


// Store:
public protocol ReduceStore: class, ReduceStoreInitializable {
    var reducer: ReducerType! { get set }
...

// Reducer:
public protocol Reducer: class {
    associatedtype ActionType
    associatedtype ItemType: Codable
    associatedtype StateType: Codable
    associatedtype ErrorType: Error
</code></pre>

<p>About the actual error the stack looks like:</p>

<pre><code>Thread 1 Queue : com.apple.main-thread (serial)

* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x10)
    frame #0: 0x00000001063746e4 libswiftCore.dylib`swift_getWitnessTable + 392
    frame #1: 0x0000000105802e38 Models`lazy protocol witness table accessor for type ExampleModel and conformance ExampleModel at &lt;compiler-generated&gt;:0
    frame #2: 0x0000000105802cf4 Models`instantiation function for generic protocol witness table for ExampleModel at &lt;compiler-generated&gt;:0
    frame #3: 0x0000000106374c08 libswiftCore.dylib`swift_getWitnessTable + 1708
    frame #4: 0x0000000106385ee8 libswiftCore.dylib`swift::TargetProtocolConformanceDescriptor&lt;swift::InProcess&gt;::getWitnessTable(swift::TargetMetadata&lt;swift::InProcess&gt; const*) const + 496
    frame #5: 0x0000000105112fd8 ExampleApp-SwiftUI`swift::swift50override_conformsToProtocol(swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolDescriptor&lt;swift::InProcess&gt; const*, swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (*)(swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolDescriptor&lt;swift::InProcess&gt; const*)) + 60
    frame #6: 0x00000001063607fc libswiftCore.dylib`swift::_conformsToProtocol(swift::OpaqueValue const*, swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolDescriptorRef&lt;swift::InProcess&gt;, swift::TargetWitnessTable&lt;swift::InProcess&gt; const**) + 44
    frame #7: 0x00000001063863b0 libswiftCore.dylib`swift::_checkGenericRequirements(llvm::ArrayRef&lt;swift::TargetGenericRequirementDescriptor&lt;swift::InProcess&gt; &gt;, std::__1::vector&lt;void const*, std::__1::allocator&lt;void const*&gt; &gt;&amp;, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 1160
    frame #8: 0x0000000106383410 libswiftCore.dylib`(anonymous namespace)::DecodedMetadataBuilder::createBoundGenericType(swift::TargetContextDescriptor&lt;swift::InProcess&gt; const*, llvm::ArrayRef&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const*&gt;, swift::TargetMetadata&lt;swift::InProcess&gt; const*) const + 576
    frame #9: 0x0000000106382ac4 libswiftCore.dylib`swift::Demangle::TypeDecoder&lt;(anonymous namespace)::DecodedMetadataBuilder&gt;::decodeMangledType(swift::Demangle::Node* const&amp;) + 2832
    frame #10: 0x0000000106382100 libswiftCore.dylib`swift::Demangle::TypeDecoder&lt;(anonymous namespace)::DecodedMetadataBuilder&gt;::decodeMangledType(swift::Demangle::Node* const&amp;) + 332
    frame #11: 0x00000001063819e8 libswiftCore.dylib`swift_getTypeByMangledNodeImpl(swift::MetadataRequest, swift::Demangle::Demangler&amp;, swift::Demangle::Node*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 460
    frame #12: 0x00000001063817a8 libswiftCore.dylib`swift::swift_getTypeByMangledNode(swift::MetadataRequest, swift::Demangle::Demangler&amp;, swift::Demangle::Node*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 520
    frame #13: 0x0000000106381d18 libswiftCore.dylib`swift_getTypeByMangledNameImpl(swift::MetadataRequest, llvm::StringRef, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 648
    frame #14: 0x0000000106380110 libswiftCore.dylib`swift::swift_getTypeByMangledName(swift::MetadataRequest, llvm::StringRef, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 520
    frame #15: 0x0000000106376a6c libswiftCore.dylib`swift_getAssociatedTypeWitnessSlowImpl(swift::MetadataRequest, swift::TargetWitnessTable&lt;swift::InProcess&gt;*, swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*) + 492
    frame #16: 0x0000000106375018 libswiftCore.dylib`swift_getAssociatedTypeWitness + 176
    frame #17: 0x00000001056df53c Stores`ExampleArchiver.init(storeLocation=nil, outputDelegates=1 value, self=0x00000001c0463840) at ExampleArchiver.swift:18:85
    frame #18: 0x00000001056df38c Stores`ExampleArchiver.__allocating_init(storeLocation:outputDelegates:) at ExampleArchiver.swift:0
    frame #19: 0x00000001056ebc48 Stores`static ExampleStoreBuilder.build(self=Stores.ExampleStoreBuilder) at ExampleStoreBuilder.swift:23:64
    frame #20: 0x0000000105000d20 ExampleApp-SwiftUI`AppDelegate.init() at AppDelegate.swift:17:36
    frame #21: 0x0000000105000e28 ExampleApp-SwiftUI`@objc AppDelegate.init() at &lt;compiler-generated&gt;:0
    frame #22: 0x000000018e4a8a00 UIKit`_UIApplicationMainPreparations + 1688
    frame #23: 0x000000018e39d724 UIKit`UIApplicationMain + 184
    frame #24: 0x0000000105001404 ExampleApp-SwiftUI`main at AppDelegate.swift:14:7
  * frame #25: 0x0000000183e11fc0 libdyld.dylib`start + 4

</code></pre>

<p>for #16 0x0000000106375018 in swift_getAssociatedTypeWitness () the actual assembly looks like:</p>

<pre><code>libswiftCore.dylib`swift_getAssociatedTypeWitness:
    0x106374f68 &lt;+0&gt;:   stp    x24, x23, [sp, #-0x40]!
    0x106374f6c &lt;+4&gt;:   stp    x22, x21, [sp, #0x10]
    0x106374f70 &lt;+8&gt;:   stp    x20, x19, [sp, #0x20]
    0x106374f74 &lt;+12&gt;:  stp    x29, x30, [sp, #0x30]
    0x106374f78 &lt;+16&gt;:  add    x29, sp, #0x30            ; =0x30 
    0x106374f7c &lt;+20&gt;:  mov    x23, x0
    0x106374f80 &lt;+24&gt;:  sub    x8, x4, x3
    0x106374f84 &lt;+28&gt;:  lsr    x8, x8, #3
    0x106374f88 &lt;+32&gt;:  ldr    x0, [x1, w8, uxtw #3]
    0x106374f8c &lt;+36&gt;:  tbnz   w0, #0x0, 0x106374fa8     ; &lt;+64&gt;
    0x106374f90 &lt;+40&gt;:  mov    x1, #0x0
    0x106374f94 &lt;+44&gt;:  ldp    x29, x30, [sp, #0x30]
    0x106374f98 &lt;+48&gt;:  ldp    x20, x19, [sp, #0x20]
    0x106374f9c &lt;+52&gt;:  ldp    x22, x21, [sp, #0x10]
    0x106374fa0 &lt;+56&gt;:  ldp    x24, x23, [sp], #0x40
    0x106374fa4 &lt;+60&gt;:  ret    
    0x106374fa8 &lt;+64&gt;:  mov    x19, x4
    0x106374fac &lt;+68&gt;:  mov    x20, x3
    0x106374fb0 &lt;+72&gt;:  mov    x21, x2
    0x106374fb4 &lt;+76&gt;:  mov    x22, x1
    0x106374fb8 &lt;+80&gt;:  adr    x0, #0xcd130              ; swift_getAssociatedTypeWitnessSlow::Predicate
    0x106374fbc &lt;+84&gt;:  nop    
    0x106374fc0 &lt;+88&gt;:  adr    x1, #0x3690               ; swift_getAssociatedTypeWitnessSlow::$_8::__invoke(void*)
    0x106374fc4 &lt;+92&gt;:  nop    
    0x106374fc8 &lt;+96&gt;:  mov    x2, #0x0
    0x106374fcc &lt;+100&gt;: bl     0x106385ad4               ; swift_once
    0x106374fd0 &lt;+104&gt;: nop    
    0x106374fd4 &lt;+108&gt;: ldr    x8, #0xcd10c              ; swift_getAssociatedTypeWitnessSlow::Override
    0x106374fd8 &lt;+112&gt;: cbz    x8, 0x106375000           ; &lt;+152&gt;
    0x106374fdc &lt;+116&gt;: adr    x5, #0x18a4               ; swift_getAssociatedTypeWitnessSlowImpl(swift::MetadataRequest, swift::TargetWitnessTable&lt;swift::InProcess&gt;*, swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*)
    0x106374fe0 &lt;+120&gt;: nop    
    0x106374fe4 &lt;+124&gt;: mov    x0, x23
    0x106374fe8 &lt;+128&gt;: mov    x1, x22
    0x106374fec &lt;+132&gt;: mov    x2, x21
    0x106374ff0 &lt;+136&gt;: mov    x3, x20
    0x106374ff4 &lt;+140&gt;: mov    x4, x19
    0x106374ff8 &lt;+144&gt;: blr    x8
    0x106374ffc &lt;+148&gt;: b      0x106374f94               ; &lt;+44&gt;
    0x106375000 &lt;+152&gt;: mov    x0, x23
    0x106375004 &lt;+156&gt;: mov    x1, x22
    0x106375008 &lt;+160&gt;: mov    x2, x21
    0x10637500c &lt;+164&gt;: mov    x3, x20
    0x106375010 &lt;+168&gt;: mov    x4, x19
    0x106375014 &lt;+172&gt;: bl     0x106376880               ; swift_getAssociatedTypeWitnessSlowImpl(swift::MetadataRequest, swift::TargetWitnessTable&lt;swift::InProcess&gt;*, swift::TargetMetadata&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*, swift::TargetProtocolRequirement&lt;swift::InProcess&gt; const*)
-&gt;  0x106375018 &lt;+176&gt;: b      0x106374f94               ; &lt;+44&gt;    &lt;&lt;&lt; Thread 1: EXC_BAD_ACCESS (code=1, address=0x10)
</code></pre>

<p>also for #0 0x00000001063746e4 in swift_getWitnessTable () the asm looks like:</p>

<pre><code>    0x106374660 &lt;+260&gt;:  adr    x26, #0xb57a0             ; AllocationPool
    0x106374664 &lt;+264&gt;:  nop    
    0x106374668 &lt;+268&gt;:  str    x21, [sp, #0x30]
    0x10637466c &lt;+272&gt;:  ldar   x24, [x28]
    0x106374670 &lt;+276&gt;:  cbnz   x24, 0x1063747c8          ; &lt;+620&gt;
    0x106374674 &lt;+280&gt;:  b      0x106374688               ; &lt;+300&gt;
    0x106374678 &lt;+284&gt;:  add    x8, x24, #0x8             ; =0x8 
    0x10637467c &lt;+288&gt;:  csel   x28, x24, x8, lo
    0x106374680 &lt;+292&gt;:  ldar   x24, [x28]
    0x106374684 &lt;+296&gt;:  cbnz   x24, 0x1063747c8          ; &lt;+620&gt;
    0x106374688 &lt;+300&gt;:  cbnz   x23, 0x1063747b0          ; &lt;+596&gt;
    0x10637468c &lt;+304&gt;:  ldrsw  x9, [x20]
    0x106374690 &lt;+308&gt;:  cbz    w9, 0x1063746a8           ; &lt;+332&gt;
    0x106374694 &lt;+312&gt;:  and    x8, x9, #0xfffffffffffffffe
    0x106374698 &lt;+316&gt;:  add    x8, x8, x20
    0x10637469c &lt;+320&gt;:  tbz    w9, #0x0, 0x1063746ac     ; &lt;+336&gt;
    0x1063746a0 &lt;+324&gt;:  ldr    x8, [x8]
    0x1063746a4 &lt;+328&gt;:  b      0x1063746ac               ; &lt;+336&gt;
    0x1063746a8 &lt;+332&gt;:  mov    x8, #0x0
    0x1063746ac &lt;+336&gt;:  ldr    w12, [x20, #0xc]
    0x1063746b0 &lt;+340&gt;:  ubfx   x9, x12, #6, #1
    0x1063746b4 &lt;+344&gt;:  add    x10, x21, x9, lsl #2
    0x1063746b8 &lt;+348&gt;:  ubfx   x11, x12, #8, #8
    0x1063746bc &lt;+352&gt;:  madd   x9, x11, x14, x10
    0x1063746c0 &lt;+356&gt;:  ubfx   x13, x12, #16, #1
    0x1063746c4 &lt;+360&gt;:  add    x9, x9, x13, lsl #2
    0x1063746c8 &lt;+364&gt;:  tbnz   w12, #0x10, 0x1063746d4   ; &lt;+376&gt;
    0x1063746cc &lt;+368&gt;:  mov    x10, #0x0
    0x1063746d0 &lt;+372&gt;:  b      0x1063746dc               ; &lt;+384&gt;
    0x1063746d4 &lt;+376&gt;:  mul    x11, x11, x14
    0x1063746d8 &lt;+380&gt;:  ldr    w10, [x10, x11]
    0x1063746dc &lt;+384&gt;:  add    x9, x9, x10, lsl #3
    0x1063746e0 &lt;+388&gt;:  ldrh   w9, [x9, #0x2]
-&gt;  0x1063746e4 &lt;+392&gt;:  ldr    w8, [x8, #0x10]   &lt;&lt;&lt; ERROR; I don't understand this line... :(
</code></pre>
","4222398","","4222398","","2019-11-05 21:14:57","2020-02-04 20:05:50","iOS 12 error swift_getAssociatedTypeWitnessSlowImpl EXC_BAD_ACCESS in assembly code","<ios><swift><uikit><swiftui><combine>","2","2","1","","","CC BY-SA 4.0"
"58701826","1","58702685","","2019-11-04 22:12:13","","22","6111","<p>With SwiftUI (Xcode 11.1), I've got some Views set up with 2-way bindings (using <strong>@Binding</strong>).  Two-way updating works great.</p>

<p>However, how can I instantiate the view from the PreviewProvider?</p>

<p>For example:</p>

<pre><code>struct AddProjectView: View {

    @Binding public var showModal: Bool

    var body: some View {

        return VStack {
            Text(""Add Project View"")
            Button(""Dismiss"") {
                self.showModal = false
            }
        }
    }
}
</code></pre>

<p>I can't do this, because ""true"" is not a Binding:</p>

<pre><code>struct AddProjectView_Previews: PreviewProvider {
    static var previews: some View {
        AddProjectView(showModal: true)
    }
}
</code></pre>

<p>And I can't do this because ""<em>Property wrappers are not yet supported on local properties</em>"":</p>

<pre><code>struct AddProjectView_Previews: PreviewProvider {
    static var previews: some View {
        @Binding var show = true
        return AddProjectView(showModal: $show)
    }
}
</code></pre>

<p>How do we do this?</p>

<p>Thanks!!</p>
","4044855","","","","","2019-12-27 15:11:51","SwiftUI How to instantiate PreviewProvider when View requires @Binding in initializer","<xcode><swiftui><combine>","3","0","4","","","CC BY-SA 4.0"
"58709220","1","","","2019-11-05 10:20:20","","16","4973","<p>I'd like all publishers to execute unless explicitly cancelled. I don't mind <code>AnyCancellable</code> going out of scope, however based on docs it automatically calls <code>cancel</code> on <code>deinit</code> which is undesired.</p>

<p>I've tried to use a cancellable bag, but <code>AnyCancelable</code> kept piling up even after the publisher fired a completion. </p>

<p>Should I manage the bag manually? I had impression that <code>store(in: inout Set)</code> was meant to be used for convenience of managing the cancellable instances, however all it does is push <code>AnyCancellable</code> into a set.</p>

<pre><code>var cancelableSet = Set&lt;AnyCancellable&gt;()

func work(value: Int) -&gt; AnyCancellable {
    return Just(value)
        .delay(for: .seconds(1), scheduler: DispatchQueue.global(qos: .default))
        .map { $0 + 1 }
        .sink(receiveValue: { (value) in
            print(""Got value: \(value)"")
        })
}

work(value: 1337).store(in: &amp;cancelableSet)

DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(5)) {
    print(""\(cancelableSet)"")
}
</code></pre>

<p>What I came up with so far, which works fine but makes me wonder if something is missing in the Combine framework or it was not meant to be used in such fashion:</p>

<pre><code>class DisposeBag {
    private let lock = NSLock()
    private var cancellableSet = Set&lt;AnyCancellable&gt;()

    func store(_ cancellable: AnyCancellable) {
        print(""Store cancellable: \(cancellable)"")

        lock.lock()
        cancellableSet.insert(cancellable)
        lock.unlock()
    }

    func drop(_ cancellable: AnyCancellable) {
        print(""Drop cancellable: \(cancellable)"")

        lock.lock()
        cancellableSet.remove(cancellable)
        lock.unlock()
    }
}

extension Publisher {

    @discardableResult func autoDisposableSink(disposeBag: DisposeBag, receiveCompletion: @escaping ((Subscribers.Completion&lt;Self.Failure&gt;) -&gt; Void), receiveValue: @escaping ((Self.Output) -&gt; Void)) -&gt; AnyCancellable {
        var sharedCancellable: AnyCancellable?

        let disposeSubscriber = {
            if let sharedCancellable = sharedCancellable {
                disposeBag.drop(sharedCancellable)
            }
        }

        let cancellable = handleEvents(receiveCancel: {
            disposeSubscriber()
        }).sink(receiveCompletion: { (completion) in
            receiveCompletion(completion)

            disposeSubscriber()
        }, receiveValue: receiveValue)

        sharedCancellable = cancellable
        disposeBag.store(cancellable)

        return cancellable
    }

}
</code></pre>
","351305","","351305","","2019-12-16 10:11:19","2019-12-16 10:11:19","How to properly manage a collection of `AnyCancellable`","<swift><combine>","1","8","4","","","CC BY-SA 4.0"
"58718134","1","","","2019-11-05 19:26:38","","1","2222","<p>Using Apple's Combine I would like to append a publisher <code>bar</code> after a first publisher <code>foo</code> has finished (ok to constrain <code>Failure</code> to <code>Never</code>). Basically I want <a href=""http://reactivex.io/RxJava/javadoc/io/reactivex/Completable.html#andThen-io.reactivex.ObservableSource-"" rel=""nofollow noreferrer"">RxJava's <code>andThen</code></a>.</p>

<p>I have something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>let foo: AnyPublisher&lt;Fruit, Never&gt; = /* actual publisher irrelevant */

let bar: AnyPublisher&lt;Fruit, Never&gt; = /* actual publisher irrelevant */

// A want to do concatenate `bar` to start producing elements
// only after `foo` has `finished`, and let's say I only care about the
// first element of `foo`.
let fooThenBar = foo.first()
    .ignoreOutput()
    .append(bar) // Compilation error: `Cannot convert value of type 'AnyPublisher&lt;Fruit, Never&gt;' to expected argument type 'Publishers.IgnoreOutput&lt;Upstream&gt;.Output' (aka 'Never')`
</code></pre>

<p>I've come up with a solution, I think it works, but it looks very ugly/overly complicated.</p>

<pre class=""lang-swift prettyprint-override""><code>let fooThenBar = foo.first()
    .ignoreOutput()
    .flatMap { _ in Empty&lt;Fruit, Never&gt;() }
    .append(bar) 
</code></pre>

<p>I'm I missing something here?</p>

<h1>Edit</h1>

<p>Added a nicer version of my initial proposal as an answer below. Big thanks to @RobNapier!</p>
","1311272","","1311272","","2019-11-06 16:27:33","2021-05-12 18:08:47","Swift Combine: `append` which does not require output to be equal?","<ios><swift><combine>","3","6","","","","CC BY-SA 4.0"
"58726165","1","58726243","","2019-11-06 08:46:19","","1","932","<p>I have this simple MapView and I have an ObservedObject datasource to update but is not work.</p>

<p>This is the content view:</p>

<pre><code>struct ContentView: View {
    @ObservedObject var trackingOnMapViewModel = TrackingOnMapViewModel()

    var body: some View {
        ZStack {
            MapView(selectedRegion: $trackingOnMapViewModel.selectedRegion)
                .edgesIgnoringSafeArea(.vertical)
            VStack {
                Spacer()
                Button(action: {
                    self.trackingOnMapViewModel.selectNextRegion()
                }) {
                    Text(""Next"")
                        .padding()
                }
            }
        }
    }
}
</code></pre>

<p>This is a simple mapview:</p>

<pre><code>struct MapView: UIViewRepresentable {
    @Binding var selectedRegion: MKCoordinateRegion

    func makeUIView(context: Context) -&gt; MKMapView {
        print(""MapView - makeUIView"")
        let map = MKMapView()
        return map
    }

    func updateUIView(_ mapView: MKMapView, context: Context) {
        print(""MapView - updateUIView"")
        mapView.setRegion(selectedRegion, animated: true)
    }
}
</code></pre>

<p>And this is the datasource:</p>

<pre><code>class TrackingOnMapViewModel: ObservableObject {

    var regions: [MKCoordinateRegion] = [
        MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 10.0, longitude: 10.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
        MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 20.0, longitude: 20.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
        MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 30.0, longitude: 30.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
        MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 40.0, longitude: 40.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0))
    ]

    var selectedRegion: MKCoordinateRegion = MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 0.0, longitude: 0.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0))

    var currentIndex = 0


    func selectNextRegion() {
        print(""TrackingOnMapViewModel - selectNextLandmark"")
        currentIndex = currentIndex &lt; regions.count-1 ? currentIndex + 1 : 0
        self.selectedRegion = regions[currentIndex]
        print(""selectedRegion - \(selectedRegion)"")
    }
}
</code></pre>

<p>In this case the map is not updated.</p>

<p>If I put the logic to the ContentView without the ObservedObject like this:</p>

<pre><code>struct ContentView: View {
//    @ObservedObject var trackingOnMapViewModel = TrackingOnMapViewModel()

@State var regions: [MKCoordinateRegion] = [
    MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 10.0, longitude: 10.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
    MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 20.0, longitude: 20.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
    MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 30.0, longitude: 30.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)),
    MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 40.0, longitude: 40.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0))
]

@State var selectedRegion: MKCoordinateRegion = MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: 0.0, longitude: 0.0), span: MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0))

@State var currentIndex = 0

var body: some View {
    ZStack {
        MapView(selectedRegion: $selectedRegion)
            .edgesIgnoringSafeArea(.vertical)
        VStack {
            Spacer()
            Button(action: {
                self.selectNextRegion()
            }) {
                Text(""Next"")
                    .padding()
            }
        }
    }
}

private func selectNextRegion() {
    print(""ContentView - selectNextLandmark"")
    currentIndex = currentIndex &lt; regions.count-1 ? currentIndex + 1 : 0
    self.selectedRegion = regions[currentIndex]
}
</code></pre>

<p>}</p>

<p>then the map is updating.</p>

<p>Could you help me with this?</p>
","2645599","","","","","2019-11-06 08:51:48","How to update UIViewRepresentable map through Binding and ObservedObject","<binding><mapkit><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"58740178","1","","","2019-11-07 00:09:27","","1","87","<p>Preface: this is a design question about reactive programming. It's intended to be language agnostic, so it's all psuedo-codey. I suspect whatever the right answer is, would be equally applicable between Rx/ReactiveCocoa/Combine.</p>

<p>I see 3 different ways in which I can design an object to observed. Each one surely has pros/cons, but it's not entirely clear to be what they are.</p>

<ol>
<li><p>Your object could have a <code>didChange: Publisher&lt;()&gt;</code> property. When you subscribe, you receive notificaitons about when your pubished object changes, but you don't actually learn anything about the changes, or the new value of the model object. This is simple enough to fix with a <code>map</code>:</p>

<pre><code>class Point: BindableObject {
    var x, y: Int
    var didChange: Publisher&lt;()&gt; { ... }
}
let object: Point = ...
let streamOfPoints = object.didChange //  Publisher&lt;()&gt;
                            .map { _ in object }  // Publisher&lt;Point&gt;
</code></pre>

<p>You simply get the values of the object for yourself, by accessing the object directly by some other reference, at the time you get notified that it changes. If you need to access a stream of <code>x</code> or <code>y</code> values, those are also just one <code>map</code> call away.</p>

<p>However, this seems like it have some issues.</p>

<ol>
<li>It's an extra step</li>
<li>It requires you to have access to the original object, so passing the publisher around isn't enough. You have to pass around a <code>(Point, Publisher&lt;Point&gt;)</code> pair, which seems cumbersome.</li>
<li><p>It might have correctness issues. For example, any delay between the time the <code>didChange</code> event was fired, and you access the object, isn't it possible that you'll read a newer value of the object than that which was present when the change was fired off?</p>

<p>This approach is my least favorite, but interestingly, this is the approach Apple takes in its Combine framework, with the <code>BindableObject</code> protocol. I suspect it might have to do with some sort of performance gain, from not having to pipe around the object in situations when it might not be wanted. Is that the case?</p></li>
</ol></li>
<li><p>The most obvious approach is to stream the object itself. <code>var didChange: Publisher&lt;Point&gt; { /* a publisher that emits self over time */ }</code>. This seems to achieve the same as apporach #1, whilst solving the 3 issues I listed. I don't see any value that approach #1 offers over this.</p></li>
<li><p>You could make publishers for each of the fields of the object:</p>

<pre><code>class Point: BindableObject {
    let x = PublishSubject&lt;Int&gt;
    let y = PublishSubject&lt;Int&gt;
}
</code></pre>

<p>This is more granular, so people could subsribe themselves to only those fields which they care about. I don't know how heavy-weight subscriptions are, but there could be some performance wins by subscribing more specifically to only those things which you care about. It's a bit of a contrived example here, because it's hard to think of a case in which it's desireable to know only the x values or y values of a point. But the principle is still generally applicable.</p>

<p>Accessing xs and ys is also possible using one of the first 2 approaches, by mapping the stream to xs and deduplicating (<code>.map { $0.x }.distinct</code>). But this is calling a lot more mapping closures than a direct subscription like this, which could have performance implications.</p>

<p>This approach could also be combined with approach 1 or 2, to add a <code>var didChange</code> property of type <code>Publisher&lt;()&gt;</code> or <code>Publisher&lt;Point&gt;</code>, for when you need to observe the entire point object.</p>

<p>This used to cause a lot of API bloat. In Rx, either:</p>

<ol>
<li>Either you could have <code>x: Value&lt;Int&gt;</code>, and use <code>x.value</code> all over the place to access the current value</li>
<li><p>Or, you have <code>var xObservable: Value&lt;Int&gt;</code> and <code>var x: Int { xObservable.value }</code>, but this adds a lot of API bloat.</p>

<p>Luckily, these two issues are solved by property wrappers, by basically implementing the latter design, but without needing to explictly add all the computed properties (they're generated for you).</p></li>
</ol></li>
</ol>

<p>Can you please give some guidance on which pattern to use? I suspect that's one of those things that's ""obvious with experience"", but I'm just not there yet when it comes to reactive programming. Thanks!</p>
","3141234","","","","","2019-11-08 07:58:22","Designing observable objects","<swift><reactive-programming><rx-swift><reactive-cocoa><combine>","1","0","","","","CC BY-SA 4.0"
"58754458","1","58754640","","2019-11-07 17:51:10","","0","887","<p>RxJava has a <a href=""http://reactivex.io/documentation/operators/takeuntil.html"" rel=""nofollow noreferrer""><code>takeUntil</code></a> operator, documentation describes it as:</p>

<blockquote>
  <p>discard any items emitted by an Observable after a second Observable emits an item or terminates</p>
</blockquote>

<p>The last part is what I want to achieve using <code>Combine</code>. But I haven't found any equivalent operator. The only similar operator I find is <a href=""https://developer.apple.com/documentation/combine/publisher/3235804-prefix"" rel=""nofollow noreferrer""><code>prefix: untilOutputFrom</code></a>, documentation:</p>

<blockquote>
  <p>Republishes elements until another publisher emits an element.</p>
</blockquote>

<p>So given:</p>

<pre class=""lang-swift prettyprint-override""><code>fooPublisher.prefix(untilOutputFrom: barPublisher)
</code></pre>

<p>Does not act like I want it, because it only finishes when <code>barPublisher</code> emits an element. But I would like some operator finishing when <code>barPublisher</code> completes.</p>

<p>Did I miss something here? Does the operator I want actually exist under some other name?</p>
","1311272","","","","","2019-11-07 18:03:51","Swift Combine: `prefix(untilCompletionFrom)`?","<ios><swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"58792747","1","","","2019-11-10 20:43:20","","4","3580","<p>What is the best approach to implement reactive programming for a button action event?</p>

<p>Regarding the guides and samples, I found only examples with <strong>SwiftUI</strong> <code>@State</code>.</p>

<p>I mean something like this:</p>

<pre><code>@State var isVisible = false

....

Button(action: {
    self.isVisible.toggle()
} 

....

if isVisible {
    Text(""texty text"")
}
</code></pre>

<p>But what if I want to execute a background task?
The obvious approach is just call <code>viewModel?.pleaseDoAction()</code> inside <code>Button.action(</code>, and create a custom Subject which is triggered inside <code>pleaseDoAction()</code>:</p>

<pre><code>final class ViewModel {
    func pleaseDoAction() {
        mySubject.send(""some"")
    }
}
</code></pre>

<p>But is this a correct architecture approach for <strong>SwiftUI + Combine</strong>?
In brief, button action should be a Publisher but this doesn't.</p>
","1979882","","","","","2020-08-22 15:51:46","Button action with Combine framework","<swift><swiftui><combine>","2","2","3","","","CC BY-SA 4.0"
"58808184","1","","","2019-11-11 20:22:16","","0","266","<p>I'm using the GoogleSignIn framework in <code>AppDelegate</code> of my SwiftUI app.</p>

<pre><code>func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error?) {

      if let error = error {
        print(error.localizedDescription)
        return
      }

      guard let authentication = user.authentication else { return }
      let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken,
                                                        accessToken: authentication.accessToken)
        Auth.auth().signIn(with: credential){ (res, err) in
            if err != nil {
                print((err?.localizedDescription)!)
                return
            }
            else{
                print(""User:"" + (res?.user.email)!)
                // where I've tried toggling isPresentingSignIn
            }
        }
    }
</code></pre>

<p>The sign in is initiated from a <code>SignInView</code> sheet that is presented over my <code>Home</code> view before the user signs in for the first time. I want to dismiss <code>SignInView</code> once the sign in completes without error.</p>

<pre><code>struct Home: View {

    @State var isPresentingSignIn = true

    var body: some View {
        VStack {
            Text(""This Is The Home View"") 
        }.sheet(isPresented: $isPresentingSignIn, content: {
            SignInView()
        })
    }
}
</code></pre>

<p>The sign in is working great, but I don't know how to dismiss my SignInView once authentication is successful. I've tried toggling <code>isPresentingSignIn</code> from the sign in function in <code>AppDelegate</code> but it doesn't seem like I have access to <code>isPresentingSignIn</code> outside of the body of <code>Home</code>.</p>

<p>How can I dismiss <code>SignInView</code> after a successful authentication?</p>
","6035021","","6035021","","2019-11-11 20:44:48","2019-11-11 23:46:39","How to toggle a @State variable from App Delegate for the GoogleSignIn framework?","<ios><swift><swiftui><google-signin><combine>","1","0","","","","CC BY-SA 4.0"
"58810262","1","","","2019-11-12 00:09:13","","0","1328","<p>Before with </p>

<p><code>URLSession.shared.dataTask(for request: URLRequest) { data, error, response in ... }</code></p>

<p>The <code>data</code> field as well as the others could be nil. Now with Combine's </p>

<pre><code>URLSession.shared.dataTaskPublisher(for: urlRequest)
</code></pre>

<p>The (data, response) tuple is no longer of optional types. I realize that means that we must have it as a URLError that we can catch in the <code>sink(receiveCompletion: { ... }</code>, but how can I differentiate between no data and any other error?</p>
","3338275","","","","","2019-11-19 03:46:19","If dataTaskPublisher has non-nil data, what is the error type then?","<ios><swift><networking><combine>","2","0","","","","CC BY-SA 4.0"
"58810366","1","58860756","","2019-11-12 00:24:57","","3","4985","<p>I have a progress bar and a text field, both are updated depending on each other's input:</p>

<pre><code>class ViewModel: ObservableObject {
    @Published var progressBarValue: Double {
        didSet {
            textFieldValue = String(progressBarValue)
        }
    }
    @Published var textFieldValue: String {
        didSet {
            progressBarValue = Double(progressBarValue)
        }
    }
}
</code></pre>

<p>Since updating one updates the other, I end up having an infinite recursion in my code.</p>

<p>Is there a way to workaround this with Combine or plain swift code?</p>
","646960","","","","","2019-11-14 15:49:28","Two-way binding in Swift Combine","<swift><two-way-binding><combine>","2","1","","","","CC BY-SA 4.0"
"58814755","1","58898411","","2019-11-12 08:31:36","","15","5693","<p>I created a function that returns a custom Publisher in Swift Combine using the code below:</p>

<pre class=""lang-swift prettyprint-override""><code>func customPubliher() -&gt; AnyPublisher&lt;Bool, Never&gt; {
    return Future&lt;Bool, Never&gt; { promise in
        promise(.success(true))
    }.eraseToAnyPublisher()
}
</code></pre>

<p>Then I subscribed to this publisher using the following code:</p>

<pre class=""lang-swift prettyprint-override""><code>customPublisher()
    .subscribe(on: DispatchQueue.global())
    .map { _ in
        print(Thread.isMainThread)
    }
    .sink(receiveCompletion: { _ in }, receiveValue: { value in
        // Do something with the value received
    }).store(in: &amp;disposables)
</code></pre>

<p>But even though I added the line <code>.subscribe(on: DispatchQueue.global())</code> when I do the subscription, the code is <strong>not</strong> executed in a different queue (the <code>print</code> in the <code>.map</code> outputs true).</p>

<p>However, if I replace my custom publisher for one of built-in Combine publishers, for example <code>Just()</code> (see below), the same code is executed fine on a different queue:</p>

<pre class=""lang-swift prettyprint-override""><code>Just(true)
    .subscribe(on: DispatchQueue.global())
    .map { _ in
        print(Thread.isMainThread)
    }
    .sink(receiveCompletion: { _ in }, receiveValue: { value in
        // Do something with the value received
    }).store(in: &amp;disposables)
</code></pre>

<p>The <code>.map</code> on the code above outputs false.</p>

<p>What am I doing wrong when I use my custom publisher? I want it to run on a different queue, exactly like the <code>Just()</code> publisher does.</p>
","856979","","856979","","2019-11-12 11:09:51","2022-08-23 08:48:00","Make custom Publisher run on a different DispatchQueue on Swift Combine","<ios><swift><combine>","1","1","2","","","CC BY-SA 4.0"
"58845896","1","","","2019-11-13 21:28:26","","8","2133","<p>A Core Data model with entity <code>Node</code> having <code>name</code>, <code>createdAt</code>, to-many relationship <code>children</code> and to-one relationship <code>parent</code> (both optional). Using CodeGen Class Definition.</p>

<p>Using a <code>@FetchRequest</code> with a predicate of <code>parent == nil</code>, it's possible to grab the root nodes and subsequently walk the tree using the relationships.</p>

<p>Root nodes CRUD refreshes the view fine, but any modifications to child nodes don't display until restart although changes are saved in Core Data.</p>

<p>Simplest possible example in the code below illustrates the problem with child node deletion. The deletion works in Core Data but the view does not refresh if the deletion is on a child. The view refresh works fine if on a root node.</p>

<p>I'm new to Swift, so my apologies if this is a rather elementary question, but how can the view be refreshed upon changes to the child nodes?</p>

<pre><code>import SwiftUI
import CoreData

extension Node {

    class func count() -&gt; Int {
        let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext
        let fetchRequest: NSFetchRequest&lt;Node&gt; = Node.fetchRequest()

        do {
            let count = try context.count(for: fetchRequest)
            print(""found nodes: \(count)"")
            return count
        } catch let error as NSError {
            fatalError(""Unresolved error \(error), \(error.userInfo)"")
        }
    }
}

struct ContentView: View {

    @Environment(\.managedObjectContext) var managedObjectContext

    @FetchRequest(entity: Node.entity(), sortDescriptors: [NSSortDescriptor(keyPath: \Node.createdAt, ascending: true)], predicate: NSPredicate(format: ""parent == nil""))
    var nodes: FetchedResults&lt;Node&gt;

    var body: some View {

        NavigationView {
            List {
                NodeWalkerView(nodes: Array(nodes.map { $0 as Node })  )
            }
            .navigationBarItems(trailing: EditButton())
        }
        .onAppear(perform: { self.loadData() } )

    }
    func loadData() {
        if Node.count() == 0 {
            for i in 0...3 {
                let node = Node(context: self.managedObjectContext)
                node.name = ""Node \(i)""
                for j in 0...2 {
                    let child = Node(context: self.managedObjectContext)
                    child.name = ""Child \(i).\(j)""
                    node.addToChildren(child)
                    for k in 0...2 {
                        let subchild = Node(context: self.managedObjectContext)
                        subchild.name = ""Subchild \(i).\(j).\(k)""
                        child.addToChildren(subchild)
                    }
                }
            }
            do {
                try self.managedObjectContext.save()
            } catch {
                print(error)
            }
        }
    }
}

struct NodeWalkerView: View {

    @Environment(\.managedObjectContext) var managedObjectContext

    var nodes: [Node]

    var body: some View {

        ForEach( self.nodes, id: \.self ) { node in
            NodeListWalkerCellView(node: node)
        }
        .onDelete { (indexSet) in
            let nodeToDelete = self.nodes[indexSet.first!]
            self.managedObjectContext.delete(nodeToDelete)
            do {
                try self.managedObjectContext.save()
            } catch {
                print(error)
            }
        }
    }
}

struct NodeListWalkerCellView: View {

    @ObservedObject var node: Node

    var body: some View {

        Section {
            Text(""\(node.name ?? """")"")
            if node.children!.count &gt; 0 {
                NodeWalkerView(nodes: node.children?.allObjects as! [Node] )
                .padding(.leading, 30)
            }
        }
    }
}
</code></pre>

<p>EDIT:</p>

<p>A trivial but unsatisfying solution is to make <code>NodeListWakerCellView</code> retrieve the children using another <code>@FetchRequest</code> but this feels wrong since the object is already available. Why run another query? But perhaps this is currently the only way to attach the publishing features?</p>

<p>I am wondering if there's another way to use a <code>Combine</code> publisher directly to the children, perhaps within the <code>.map</code>?</p>

<pre><code>struct NodeListWalkerCellView: View {

    @ObservedObject var node: Node

    @FetchRequest var children: FetchedResults&lt;Node&gt;

    init( node: Node ) {
        self.node = node
        self._children = FetchRequest(
            entity: Node.entity(),
            sortDescriptors: [NSSortDescriptor(keyPath: \Node.createdAt, ascending: false)],
            predicate: NSPredicate(format: ""%K == %@"", #keyPath(Node.parent), node)
        )
    }

    var body: some View {

        Section {
            Text(""\(node.name ?? """")"")
            if node.children!.count &gt; 0 {

                NodeWalkerView(nodes: children.map({ $0 as Node }) )

                .padding(.leading, 30)
            }
        }
    }
}
</code></pre>
","12369268","","12369268","","2019-11-14 09:01:17","2022-02-02 18:15:47","SwiftUI @FetchRequest Core Data Changes to Relationships Don't Refresh","<swift><core-data><swiftui><combine>","1","13","2","","","CC BY-SA 4.0"
"58881050","1","58881214","","2019-11-15 16:24:30","","2","599","<p>I am using UserDefaults and Combine in SwiftUI. </p>

<p><strong>My UserDefault.swift file:</strong></p>

<pre><code>import SwiftUI

struct UserDefault&lt;T&gt; {
    let key: String
    let defaultValue:T

    var wrappedValue:T {
        get {
            return UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
        } set {
            UserDefaults.standard.set(newValue, forKey: key)
        }
    }
}
</code></pre>

<p>When using this struct in the following class as follows:</p>

<p><strong>DataStore.swift file:</strong></p>

<pre><code>import SwiftUI
import Combine

final class DataStore : ObservableObject { //(1)
    let didChange = PassthroughSubject&lt;DataStore, Never&gt;()

    @UserDefault(key: ""firstLaunch"", defaultValue: true) //(2)
    var firstLaunch:Bool{
        didSet{
            didChange.send(self)
        }
    }
}
</code></pre>

<p>In the above code, I am getting 2 errors:</p>

<p><strong>(1):Class 'DataStore' has no initializers</strong></p>

<p><strong>(2):Generic struct 'UserDefault' cannot be used as an attribute</strong></p>

<p>I think there is a change or depreciation in swift 5.1, but I am unable to find it.  </p>
","10537037","","1226963","","2019-11-15 16:26:24","2019-11-15 16:35:53","Error Using property Wrapper in class swift 5.1","<swift><swiftui><swift5><combine>","2","2","","","","CC BY-SA 4.0"
"58889764","1","58890084","","2019-11-16 10:30:58","","1","194","<p>I tried to follow the code snippet of WWDC 2019's <a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""nofollow noreferrer"">Combine in Practice</a> talk (starting at minute 26:00) or see <a href=""https://devstreaming-cdn.apple.com/videos/wwdc/2019/721ga0kflgr4ypfx/721/721_combine_in_practice.pdf?dl=1"" rel=""nofollow noreferrer"">slides</a> 179 ff. but it won't compile and looking at the API some parts don't make sense to me (e.g., calling <code>CombineLatest.init(A, B)</code> with a third argument of type <code>closure</code>. I tried to adapt the examples so they compile.</p>

<h1>Question Part 1/2: Can someone help me out and let me know if I am misunderstanding the WWDC 2019 code snippets?</h1>

<h2>First code snippet (slide 179)</h2>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: CombineLatest&lt;Published&lt;String&gt;, Published&lt;String&gt;, String?&gt; {
    return CombineLatest($password, $passwordAgain) { password, passwordAgain in
        guard password == passwordAgain, password.count &gt; 8 else { return nil }
        return password
    }
}
</code></pre>

<p>I can only get this snippet to at least return me the <code>Publisher from</code>CombineLatest`</p>

<ul>
<li>adding the <code>Publishers</code> enum to the namespace of <code>CombineLatest</code></li>
<li>removing the trailing closure</li>
<li>adding <code>.Publisher</code> to <code>Published&lt;String&gt;</code></li>
</ul>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt; {
    return Publishers.CombineLatest($password, $passwordAgain)
}
</code></pre>

<h3>Second code snippet (slide 185)</h3>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: Map&lt;CombineLatest&lt;Published&lt;String&gt;, Published&lt;String&gt;, String?&gt;&gt; {
    return CombineLatest($password, $passwordAgain) { password, passwordAgain in
        guard password == passwordAgain, password.count &gt; 8 else { return nil }
        return password
    }
    .map { $0 == ""password1"" ? nil : $0 }
}
</code></pre>

<p>I can get this snippet to compile when:</p>

<ul>
<li>doing all of the steps listed for the first snippet</li>
<li>Adding <code>Publishers.</code> in front of <code>Map</code></li>
<li>moving the <code>&lt;&gt;</code> to the correct position</li>
<li>returning <code>Publishers.Map</code> explicitly and by using the correct parameter <code>upstream:</code></li>
</ul>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: Publishers.Map&lt;Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt;, String?&gt; {
        return Publishers.Map(upstream: Publishers.CombineLatest($password, $passwordAgain)) { password, passwordAgain in
            guard password == passwordAgain, password.count &gt; 8 else { return nil }
            return password
    }
</code></pre>

<p>or when including the <code>.map {}</code> from the slide:</p>

<ul>
<li>by wrapping the var type in another <code>Publishers.Map&lt;..., String?&gt;</code></li>
</ul>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"
var validatedPassword: Publishers.Map&lt;Publishers.Map&lt;Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt;, String?&gt;, String?&gt; {
        return Publishers.Map(upstream: Publishers.CombineLatest($password, $passwordAgain)) { password, passwordAgain in
            guard password == passwordAgain, password.count &gt; 8 else { return nil }
            return password
    }
    .map { $0 == ""password1"" ? nil : $0 }
}
</code></pre>

<h1>Question Part 2/2: What would be the swifty way to do this? e.g, by using something like this (which does not compile):</h1>

<pre><code>@Published var password: String = """"
@Published var passwordAgain: String = """"

var validatedPassword: AnyPublisher&lt;String?, Never&gt; {
    return Just($password)
        .combineLatest($passwordAgain) { password, passwordAgain in
            guard password == passwordAgain, password.count &gt; 8 else { return nil }
            return password
    }
    .map{ $0 == ""password1"" ? nil : $0 }
    .eraseToAnyPublisher()
}
</code></pre>
","3209393","","3209393","","2019-11-16 11:11:55","2019-11-16 11:40:05","Mistake in WWDC 2019 ""Combine in Practice"" Code example for CombineLatest?","<swift><generics><swiftui><combine><combinelatest>","1","0","","","","CC BY-SA 4.0"
"58917729","1","58919279","","2019-11-18 15:18:52","","1","204","<p>How do I figure out the flatMap, reduce, etc. to turn this into an array of ProductRep?</p>

<p>I'm currently getting <code>Cannot convert value of type 'Publishers.Map&lt;URLSession.DataTaskPublisher, [StoreService.ProductRep]?&gt;' to closure result type 'StoreService.ProductRep'</code> - because I don't really understand how to turn a <code>Publishers.Map</code> into the actual thing. 
This is intended to be part of a larger network of publishers and subscribers using map/flatMap.</p>

<pre><code>let mapResult: [ProductRep] = parsePageURIs(firstPage, jsonDict)
            .map { pageUri in self.importProductsPublisher(pageUri, urlSession: urlSession, firstPage: false) }
            .map { publisher in publisher.map {(productsData, productsResponse) in
                    return self.handleImportProductsResponse(data: productsData, response: productsResponse, category: category, urlSession: urlSession)
                }
        }
func importProductsPublisher(_ uri: String, urlSession: URLSession, firstPage: Bool) -&gt; URLSession.DataTaskPublisher { /* Start the network query */ }
func handleImportProductsResponse(data: Data, response: URLResponse, category: CategoryRep, urlSession: URLSession) -&gt; [ProductRep]? { /* Handle the result of the network query and parse into an array of items (ProductRep) */ }
</code></pre>
","79252","","","","","2019-11-18 16:55:26","Convert '[Publishers.Map<URLSession.DataTaskPublisher, [ProductRep]?>]' to [ProductRep]","<swift><functional-programming><combine>","1","0","","","","CC BY-SA 4.0"
"58923530","1","","","2019-11-18 21:59:30","","3","4205","<p>I am trying to show a view after fetching some data on my view model (where the data can be optional because the view model only fetches it on request).</p>

<p>Why is the following not possible / how should I go about it? </p>

<pre><code>@Binding var someViewModel: SomeViewModel?

var body: some View {
    if let viewModel = self.someViewModel {
        return filledView(with: viewModel)
    }
    return emptyView()
}
</code></pre>

<p>The part not working here is an <code>if let</code> in the Swift UI view builder. </p>

<p>One solution would be to have a separate Bool that fires when data is loaded, or even an enum to identify when data is in and when it's not, but then the view code is full of optional value checking which isn't ideal.</p>

<p>E.g. I want to avoid doing something like:</p>

<pre><code>Image(systemName: someViewModel?.icon.symbol() ?? ""plus_sign"")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 60, height: 60)
                    .foregroundColor(Color.red)
                    .padding()
</code></pre>

<p>Any help would be greatly appreciated.</p>
","372990","","","","","2019-11-18 22:27:40","Is there a way in SwiftUI to return a different view based on an optional binding having a value?","<swift><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"58925897","1","","","2019-11-19 02:45:19","","0","205","<p>I'm reading data from Firestore and parsing it to a custom model <code>Thought</code></p>

<p>For each document in my Firestore collection I append a new <code>Thought</code> object to a <code>@Published var thoughts</code>.</p>

<pre><code>struct Thought: Identifiable {

    public var id: String?
    public var name: String
    public var thought: String
    public var color: String
}

class Observer: ObservableObject {

    @Published var thoughts = [Thought]()

    init(){
        let db = Firestore.firestore()

        db.collection(""thoughts"")
        .addSnapshotListener { querySnapshot, error in
            guard let documents = querySnapshot?.documents else {
                print(""Error fetching documents: \(error!)"")
                return
            }

            for document in documents {

                var thoughtModel = Thought(id: """", name: """", thought: """", color: """")

                thoughtModel.name = document.data()[""name""] as! String
                thoughtModel.thought = document.data()[""thought""] as! String
                thoughtModel.color = document.data()[""color""] as! String

                self.thoughts.append(thoughtModel)
            }
            print(self.thoughts) //PRINTS 4 DIFFERENT THOUGHT OBJECTS
        }
    }
}

struct ThoughtsView: View {

    @ObservedObject var observer = Observer()

    var body: some View {
        VStack {
            List {
                ForEach(self.observer.thoughts) { thought in

                    ThoughtCard(color: thought.color,
                                thought: thought.thought,
                                name: thought.name)
                    //HERE I GET THE SAME CARD 4 TIMES INSTEAD OF 4 DIFFERENT CARDS
                }
            }
        }
    }
}
</code></pre>

<p>When I print <code>thoughts</code> I'm seeing all 4 documents that are currently in my Firestore database. However, when I try iterating through <code>thoughts</code> in my list I just the same <code>Thought</code> object 4 times instead of 4 different <code>Thought</code> objects.</p>

<p>I think the problem lies within the <code>List</code> and how I'm iterating through <code>self.observer.thoughts</code>, but I'm not sure what I'm doing wrong. How do I populate the list with the 4 objects in <code>self.observer.thoughts</code>?</p>
","6035021","","","","","2019-11-19 03:09:32","Why is my SwiftUI List populating with the same item 4 times instead of all 4 items?","<ios><swift><google-cloud-firestore><combine><swiftui-list>","1","0","","","","CC BY-SA 4.0"
"58926143","1","58927372","","2019-11-19 03:22:10","","2","280","<p>I'm reading data from Firestore using <code>.addSnapshotListener</code> and parsing it to a custom model <code>Thought</code></p>

<p>For each document in my Firestore collection I append a new <code>Thought</code> object to a <code>@Published var thoughts</code> and iterate through <code>thoughts</code> in a <code>List</code>.</p>

<pre><code>struct Thought: Identifiable {

    public var id: String?
    public var name: String
    public var thought: String
    public var color: String
}

class Observer: ObservableObject {

    @Published var thoughts = [Thought]()

    init(){

        self.thoughts.removeAll()

        let db = Firestore.firestore()

        db.collection(""thoughts"")
        .addSnapshotListener { querySnapshot, error in
            guard let documents = querySnapshot?.documents else {
                print(""Error fetching documents: \(error!)"")
                return
            }

            for document in documents {

                var thoughtModel = Thought(id: """", name: """", thought: """", color: """")

                thoughtModel.name = document.data()[""name""] as! String
                thoughtModel.thought = document.data()[""thought""] as! String
                thoughtModel.color = document.data()[""color""] as! String

                self.thoughts.append(thoughtModel)
            }
        }
    }
}

struct ThoughtsView: View {

    @ObservedObject var observer = Observer()

    var body: some View {
        VStack {
            List {
                ForEach(self.observer.thoughts, id: \.name) { thought in

                    ThoughtCard(color: thought.color,
                                thought: thought.thought,
                                name: thought.name)
                }
            }
        }
    }
}
</code></pre>

<p>When I make changes or add a document in my Firestore collection all objects are appended to my <code>List</code> instead of my <code>List</code> just being updated like I expect. In other words, if I have 3 items in my <code>List</code>, and I change a value in one of the Firestore documents I end up with 6 items in my <code>List</code> consisting of the original 3, and a duplicate of the original 3 (modified).</p>

<p>How do I properly update my <code>List</code>?</p>
","6035021","","","","","2019-11-19 05:43:17","Why is my SwiftUI List appending all objects again instead of updating existing objects?","<swift><google-cloud-firestore><swiftui><combine><swiftui-list>","1","1","","","","CC BY-SA 4.0"
"58937678","1","58977297","","2019-11-19 15:36:18","","2","1555","<p>My apologies if this is not the right question to ask, as I am completely new to SwiftUI and iOS programming in general.  The question indicates what I want to do, and the error I'm getting I believe is a red herring because of the SwiftUI compiler.  It's likely that I am taking the incorrect approach to solving this problem altogether.</p>

<p>I am using XCode Version 11.2.1 (11B500)</p>

<p>View utilizing the ObservedObject:</p>

<pre class=""lang-swift prettyprint-override""><code>struct Results: View {
    var jobId: String
    @ObservedObject var jobDetailService: JobDetailService

    init(jobId: String) {
        self.jobId = jobId
        jobDetailService = JobDetailService(jobId: jobId)
    }

    var body: some View {
        //... view code here
    }

}
</code></pre>

<p>And it is within this view that I am getting the error (at the ZStack line) ""Generic parameter 'C0' could not be inferred"".  When I comment out the <code>NavigationLink</code> block, the error goes away.  Further, when the <code>Results</code> view does not depend on the <code>jobId</code> parameter (and we construct <code>JobDetailService</code> inline with <code>@ObservedObject var jobDetailService = JobDetailService()</code>, this all works.  However, I need to be able to pass the <code>jobId</code> parameter to the <code>JobDetailService</code> in order to make the network call to fetch and publish the data.</p>

<pre class=""lang-swift prettyprint-override""><code>struct JobList: View {
    @ObservedObject var jobListService = JobListService()

    var body: some View {
        NavigationView {
            List(jobListService.jobs) {job in
                ZStack {
                    JobCard(name: job.fullName, date: job.lastUpdated)
                    NavigationLink(destination: Results(jobId: job.jobId)) {
                        EmptyView()
                    }
                }
            }
        }
     }
 }

</code></pre>
","4215892","","4215892","","2019-11-19 15:48:29","2019-11-21 14:30:25","How to initialize an ObservedObject from a view created with a NavigationLink?","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"58942207","1","58942349","","2019-11-19 20:20:08","","5","2191","<p>I've got a view with two text fields and a save button. How can I possibly change my button's state depending on the contents of the text fields (I'd like to enable the button only in case all text fields are not empty)? Here's my current code:</p>

<pre><code>// The variables associated with text fields
@State var name: String = """"
@State var type: String = """"

// I'd like to associate this variable with
// my button's disabled / enabled state,
// but the function responsible for it doesn't accept bindings
@State var canSave: Bool = false

var body: some View {
    Form {
        TextField(""Name"", text: $name)
        TextField(""Type"", text: $type)

        Button(action: {
            // ...
        }, label: {
            Text(""Save"")
        })
            .disabled(!canSave) // no bindings allowed here; what to use indead?
    }
}
</code></pre>

<p>I have an idea that I should use <code>combineLatest</code> from the newest Combine framework. But whatever I try to google leads me to RxSwift-related topics and not actual Combine implementation.</p>
","9850339","","9850339","","2019-11-20 10:13:24","2019-11-20 10:13:24","SwiftUI: Enable save button only when the inputs are not empty","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"58945482","1","","","2019-11-20 01:51:24","","2","1099","<p>I am confused why this following code does not work.</p>

<pre><code>
dateTextField.publisher(for: \.text)
    .sink(receiveCompletion: { completion  in
        print(""completion"", completion)
    }, receiveValue: { value in
        print(""value"", value ?? """")
    }).store(in: &amp;subscriptions)


</code></pre>

<p>I just receive the first event, of an empty text. My guess is because UITextField's text property is not KVO-compliant. But, why does the subscription receive the first value?</p>
","7969193","","","","","2020-09-01 11:23:18","Is there a way of getting a UITextField's text updates in a declarative way?","<ios><swift><combine>","3","0","","","","CC BY-SA 4.0"
"58945952","1","58983929","","2019-11-20 02:57:22","","0","468","<p>The following pipeline:</p>

<pre><code>enum MyError: Error {
  case oops
}
let cancel = Fail&lt;Int, Error&gt;(error: MyError.oops)
  .print(""1&gt;"")
  .print(""2&gt;"")
  .sink(receiveCompletion: { status in
    print(""status&gt;"", status)
  }) { value in
    print(""value&gt;"", value)
}

</code></pre>

<p>Outputs:</p>

<pre><code>1&gt;: receive subscription: (Empty)
2&gt;: receive subscription: (Print)
2&gt;: request unlimited
1&gt;: request unlimited
1&gt;: receive error: (oops)
2&gt;: receive error: (oops)
status&gt; failure(__lldb_expr_126.MyError.oops)
</code></pre>

<h3>The problem</h3>

<p>However, if I insert a <code>receive(on:)</code> operator into the previous pipeline:</p>

<pre><code>enum MyError: Error {
  case oops
}
let cancel = Fail&lt;Int, Error&gt;(error: MyError.oops)
  .print(""1&gt;"")
  .receive(on: RunLoop.main)
  .print(""2&gt;"")
  .sink(receiveCompletion: { status in
    print(""status&gt;"", status)
  }) { value in
    print(""value&gt;"", value)
}
</code></pre>

<p>the output is:</p>

<pre><code>1&gt;: receive subscription: (Empty)
1&gt;: receive error: (oops)
</code></pre>

<p>The <code>receive</code> operator seems to short-circuit the pipeline. I haven't seen it happen for other publishers, just when I use a <code>Fail</code> or <code>PassthroughSubject</code> publisher.</p>

<p><strong>Is this expected behavior? If so, what's the reason for it?</strong></p>

<hr>

<h3>Workaround</h3>

<p>Here's an example of creating a failing publisher that works with the <code>receive(on:)</code> publisher:</p>

<pre><code>struct FooModel: Codable {
  let title: String
}

func failPublisher() -&gt; AnyPublisher&lt;FooModel, Error&gt; {
  return Just(Data(base64Encoded: """")!)
    .decode(type: FooModel.self, decoder: JSONDecoder())
    .eraseToAnyPublisher()
}

let cancel = failPublisher()
  .print(""1&gt;"")
  .receive(on: RunLoop.main)
  .print(""2&gt;"")
  .sink(receiveCompletion: { status in
    print(""status&gt;"", status)
  }) { value in
    print(""value&gt;"", value)
}
</code></pre>
","1102215","","1102215","","2019-11-20 05:19:07","2019-11-21 21:19:36","Why does Combine's receive(on:) operator swallow errors?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"58948730","1","","","2019-11-20 07:16:47","","0","340","<p>I have a problem where the master pane list view rows are not updating correctly in an iPad. I have reduced the code for description purposes to</p>

<pre><code>struct CarsList : View {
    @State var isPresented = false
    @FetchRequest(fetchRequest: Car.allCarsFetchRequest())
    var cars: FetchedResults&lt;Car&gt;
    var body: some View {
        NavigationView {
            List {
                Button(""Add Car"") {
                    self.isPresented.toggle()
                }
                ForEach (self.cars) { car in
                    VStack {
                        Text (""List Car name: \(car.name!)"")
                        NavigationLink(destination: CarDetailView(carVM: CarViewModel(car: car)) )  {
                            CarRowView(car: car)
                        }
                    }
                }
            }
        }
        .sheet(isPresented: $isPresented, onDismiss: { }, content: {
            CarDetailView(carVM: CarViewModel())
        })
    }
}
</code></pre>

<p>The iPad left pane shows a list of car names (CoreData managed objects). For test purposes, I show the name twice - in the Text(“List car name…“) and below the name is shown again in the CarRowView. The CarRowView has car: Car declared as an ObservedObject.
I can tap on a row, to go to a detail view, where I can change the car name. When I do so, the List updates in that the Text(“List car name…“) shows the new name, but the CarRowView does not change. 
So changing the ""car"" in the detail pane, immediately shows in the List (in Text(""List car name.."") ) and yet even though that car object is sent to the CarRowView, where it is an ObservedObject, the CarRowView display does not change.
 The app uses CloudKit, and after I make the change, the new name appears ok on an iPhone (in CarRowView) running the same code. Any ideas why CarRowView would not update on the master pane of the iPad? </p>
","5752268","","","","","2019-11-22 12:12:06","Why would SwiftUI ObservedObject not work in a List Row?","<swiftui><master-detail><combine><swiftui-list>","1","3","","","","CC BY-SA 4.0"
"58977360","1","58978323","","2019-11-21 14:33:01","","1","1551","<p>I am having troubles with running view methods on published property value change. My playground sample code looks like this:</p>

<pre><code>class MyFoo: ObservableObject {
    @Published var bar: String
    init(bar: String) {
        self.bar = bar
    }

    func setNewText(newString: String) {
        self.bar = newString
    }

    func runFunctions() {
        setNewText(newString: ""Test"")
    }
}

struct TestView: View {
    @ObservedObject let foo = MyFoo(bar: ""bar0"")

    init(){
        let barSink = foo.$bar
            .sink() { //THIS IS WHERE I GET ERROR ""Escaping closure captures mutating 'self' parameter""
                self.printResult(result: $0)
            }
    }

    func printResult(result: String) {
        print(result)
    }
}

let a = TestView()
</code></pre>

<p>Basically I know why I get this error in closure but I don't know how to go around it. Is this the right approach for running view methods on VM published property value changed? </p>

<p>I need this because I am using custom spinner that is not SwiftUI ready so I cant bind to it, and the only way to show/hide it is by calling its methods.</p>

<p>Any help would be most appreciated</p>
","2707795","","2707795","","2019-11-21 15:24:13","2019-11-21 15:26:27","SwiftUI run method on view when Published view model member value changes","<ios><swift><xcode><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"58996403","1","58996712","","2019-11-22 14:34:31","","17","3972","<p>I'm trying to display an activity indicator when performing an async request.
What I did is creating an ActivityTracker object that will track life cycle of a publisher.
This ActivityTracker is an ObservableObject and will be stored in the view model which also is an ObservableObject.</p>

<p>It seems that this kind of setup isn't refreshing the View. Here's my code:</p>

<pre><code>struct ContentView: View {
    @ObservedObject var viewModel = ContentViewModel()

    var body: some View {
        VStack(spacing: 16) {
            Text(""Counter: \(viewModel.tracker.count)\nPerforming: \(viewModel.tracker.isPerformingActivity ? ""true"" : ""false"")"")

            Button(action: {
                _ = request().trackActivity(self.viewModel.tracker).sink { }
            }) {
                Text(""Request"")
            }
        }
    }
}

class ContentViewModel: ObservableObject {
    @Published var tracker = Publishers.ActivityTracker()
}

private func request() -&gt; AnyPublisher&lt;Void, Never&gt; {
    return Just(()).delay(for: 2.0, scheduler: RunLoop.main)
        .eraseToAnyPublisher()
}

extension Publishers {
    final class ActivityTracker: ObservableObject {
        // MARK: Properties

        @Published var count: Int = 0

        var isPerformingActivity: Bool {
            return count &gt; 0
        }

        private var cancellables: [AnyCancellable] = []
        private let counterSubject = CurrentValueSubject&lt;Int, Never&gt;(0)
        private let lock: NSRecursiveLock = .init()

        init() {
            counterSubject.removeDuplicates()
                .receive(on: RunLoop.main)
                .print()
                .sink { [weak self] counter in
                    self?.count = counter
                }
                .store(in: &amp;cancellables)
        }

        // MARK: Private methods

        fileprivate func trackActivity&lt;Value, Error: Swift.Error&gt;(
            ofPublisher publisher: AnyPublisher&lt;Value, Error&gt;
        ) {
            publisher
                .receive(on: RunLoop.main)
                .handleEvents(
                    receiveSubscription: { _ in self.increment() },
                    receiveOutput: nil,
                    receiveCompletion: { _ in self.decrement() },
                    receiveCancel: { self.decrement() },
                    receiveRequest: nil
                )
                .print()
                .sink(receiveCompletion: { _ in }, receiveValue: { _ in })
                .store(in: &amp;cancellables)
        }

        private func increment() {
            lock.lock()
            defer { lock.unlock() }
            counterSubject.value += 1
        }

        private func decrement() {
            lock.lock()
            defer { lock.unlock() }
            counterSubject.value -= 1
        }
    }
}

extension AnyPublisher {
    func trackActivity(_ activityTracker: Publishers.ActivityTracker) -&gt; AnyPublisher {
        activityTracker.trackActivity(ofPublisher: self)
        return self
    }
}
</code></pre>

<p>I also tried to declare my ActivityTracker as <code>@Published</code> but same result, my text is not updated.
Note that storing the activity tracker directly in the view will work but this is not what I'm looking for.</p>

<p>Did I miss something here ?</p>
","1224751","","","","","2020-09-28 20:17:09","ObservedObject inside ObservableObject not refreshing View","<ios><swift><swiftui><combine>","2","0","7","","","CC BY-SA 4.0"
"58998940","1","59381886","","2019-11-22 17:17:46","","1","1025","<pre><code>publisher.collect(&lt;#T##strategy: Publishers.TimeGroupingStrategy&lt;Scheduler&gt;##Publishers.TimeGroupingStrategy&lt;Scheduler&gt;#&gt;)
</code></pre>

<p>I couldn't find any example anywhere and the <a href=""https://developer.apple.com/documentation/combine/publishers/timegroupingstrategy"" rel=""nofollow noreferrer"">documentation</a> is bland... free <a href=""https://heckj.github.io/swiftui-notes/#reference-collectbytime"" rel=""nofollow noreferrer"">Using Combine</a> book has nothing interesting as well.</p>
","12106051","","","","","2019-12-17 20:50:16","How to use collect(.byTime) or collect(.byTimeOrCount) in Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"59002502","1","","","2019-11-22 22:20:46","","45","32136","<p>If I have stored a cancellable set into a ViewController:</p>
<pre><code>private var bag = Set&lt;AnyCancellable&gt;()
</code></pre>
<p>Which contains multiple subscription.</p>
<p>1 - Should I cancel subscription in deinit?  or it does the job automatically?</p>
<p>2 - If so, how can I cancel all the stored subscriptions?</p>
<pre><code>bag.removeAll() is enough?
</code></pre>
<p>or should I iterate through the set and cancel all subscription one by one?</p>
<pre><code>for sub in bag {
   sub.cancel()
}
</code></pre>
<p>Apple says that the subscription is alive until the stored AnyCancellable is in memory. So I guess that deallocating the cancellables with <code>bag.removeAll()</code> should be enough, isn't it?</p>
","6747915","","5175709","","2022-04-15 14:10:30","2022-04-15 14:10:30","iOS Swift Combine: cancel a Set<AnyCancellable>","<ios><swift><swiftui><combine><anycancellable>","5","0","10","","","CC BY-SA 4.0"
"59007014","1","","","2019-11-23 11:13:45","","5","2696","<p>I have only started learning combine, so it's still a little fuzzy to me. I would like to create a custom <code>Publisher</code>, that would use <code>CLLocationManager</code> to expose current user location. I would like it to work in such a way, that <code>locationManager</code> only starts updating location when there are some subscribers connected. And after all subscribers were removed, canceled, etc, then it should stop updating location. Is this possible to do? How can I create such a <code>publisher</code>? Also is this the right approach, or is there something wrong with it?</p>
","4528716","","","","","2020-10-15 09:47:17","Swift Combine - Create publisher for CoreLocation","<swift><reactive-programming><core-location><combine><publisher>","2","4","1","","","CC BY-SA 4.0"
"59018112","1","59024012","","2019-11-24 13:24:58","","1","229","<p>I have an array of strings that I would like to map into different objects. I'm using map to transform the array to another, but it's very nested:</p>

<pre><code>$favorites
    .map { articleIDs in
        articleIDs.compactMap { id in
            state.articles.first { $0.id == id }
        }
    }
    .assign(to: \Self.favorites, on: self)
    .store(in: &amp;cancellable)
</code></pre>

<p>Is there a shorthand to applying a transform to each individual item? I was originally trying to do this but it didn't work:</p>

<pre><code>state.$favorites
    .mapEach { id in state.articles.first { $0.id == id } }
    .assign(to: \Self.favorites, on: self)
    .store(in: &amp;cancellable)
</code></pre>
","235334","","235334","","2019-11-24 23:06:50","2019-11-25 16:52:58","How to avoid nesting closures when mapping Combine arrays?","<swift><combine>","1","4","","","","CC BY-SA 4.0"
"59018561","1","","","2019-11-24 14:12:26","","1","762","<p>In <a href=""https://developer.apple.com/documentation/combine/subject/3362858-send"" rel=""nofollow noreferrer"">documentation</a> for the <a href=""https://developer.apple.com/documentation/combine/subject"" rel=""nofollow noreferrer""><code>Subject</code></a> protocol of Apple's Combine framework there's this description for the <code>send(subscription: Subscription)</code> function:</p>

<blockquote>
  <p>This call provides the <code>Subject</code> an opportunity to establish demand for any new upstream subscriptions.</p>
</blockquote>

<p>There are similar <a href=""https://developer.apple.com/documentation/combine/subject/3213648-send"" rel=""nofollow noreferrer""><code>send</code></a> functions on <code>Subject</code> that allow publishing either an <code>Output</code> value or a <code>Void</code> value, but it's still isn't clear how would a <code>Subject</code> type use a subscription sent to it or what's the meaning of that.</p>

<p>The only two types conforming to <code>Subject</code> that Combine currently provides are <a href=""https://developer.apple.com/documentation/combine/currentvaluesubject"" rel=""nofollow noreferrer""><code>CurrentValueSubject</code></a> and <a href=""https://developer.apple.com/documentation/combine/passthroughsubject"" rel=""nofollow noreferrer""><code>PassthroughSubject</code></a>, neither has any documentation for their <code>send(subscription: Subscription)</code> implementations.</p>

<p>What does it mean for a type conforming to <code>Subject</code> to have an ""upstream subscription""? A downstream subscription for a <code>Subject</code> would be created for something that subscribes to this subject, but what would be the purpose of an upstream subscription here? Please provide real-world examples if possible.</p>
","442427","","442427","","2019-11-25 17:40:58","2022-07-12 12:50:09","What does ""upstream subscription"" mean for a Combine Subject type?","<swift><reactive-programming><combine>","2","0","1","","","CC BY-SA 4.0"
"59018880","1","59019302","","2019-11-24 14:46:39","","17","5556","<p>In the Combine framework, we can throw a generic <code>Error</code> protocol type while using <code>tryMap</code>.</p>

<p>However, how can we be more specific about the <code>Error</code> type?</p>

<p>For example,</p>

<pre class=""lang-swift prettyprint-override""><code>let publisher = urlSession.dataTaskPublisher(for: request).tryMap { (data, response) -&gt; (Data, HTTPURLResponse) in
      guard let response = response as? HTTPURLResponse else {
        throw URLError(.cannotParseResponse)
      }
      return (data, response)
}
</code></pre>

<p>How to specify the <code>Error</code> type of this <code>publisher</code>? I'd like to use <code>URLError</code> instead of <code>Error</code>.</p>

<p>I found the method <code>setFailureType(to:)</code> in the <code>Combine</code> framework. However, it is not available to <code>tryMap(_:)</code>.</p>
","2949840","","","","","2021-06-24 08:56:27","Swift Combine: How to specify the Error type of tryMap(_:)?","<ios><swift><xcode><macos><combine>","2","0","1","","","CC BY-SA 4.0"
"59025718","1","","","2019-11-25 05:29:18","","0","355","<p>I have a global object of class UserLocation which is initialized in <code>AppDelegate.swift</code>. I'm getting current location of user and changing an image inside my SwiftUI view based on current location of user. 
Here is <code>UserLocation</code> class: </p>

<pre><code>class UserLocation: ObservableObject {
      var userCurrentState: StateEnum = .None 
// StateEnum is an enum to store state areas like west, east and its default value is .None
}
</code></pre>

<p>Inside my <code>CoreLocation</code> method, after some calculation I'm setting the <code>userCurrentState</code> of global <code>userLocation</code> object</p>

<pre><code> func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation])
    {

        * some calculations * 
        userLocation.userCurrentState = .West
    }
</code></pre>

<p><code>StateEnum</code> has a method <code>getStateImage</code> that returns a <code>String</code> which is the name of an image inside my app's <code>xcassets</code> so here is how I am using it inside my SwiftUI view: </p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {

    @EnvironmentObject var locationOfUser: UserLocation 
    var body: some View {
        HStack {
            Image(locationOfUser.userCurrentState.getStateImage)
                    .resizable()
                    .frame(width: 30, height: 30, alignment: .leading)
        }
    }
    .
    .
    .
    .
    .
    struct ContentView_Previews: PreviewProvider {
           static var previews: some View {
                  ContentView().environmentObject(userLocation)
           }
    }
</code></pre>

<p>The problem is when I start the app, the image against the ""None"" state shows up and does not change. I am changing the image based on current location, as soon as user enters in a new area and user's state gets changed the image changes but I am not getting the expected behavior. However if I put a 2 msec interval before initializing my view then the images keeps changing based on current location. It just doesn't change when I start the application and gets the image against None enum. What I observe is the micro seconds difference between view initialization and <code>CoreLocation</code> getting current location. Which gets resolved with <code>Timer</code> but I do not want to use <code>Timer</code>or any other hack.</p>
","2725239","","","","","2019-11-25 05:29:18","SwiftUI Image not updating its URL when View loads","<swift><swiftui><core-location><appdelegate><combine>","0","6","","","","CC BY-SA 4.0"
"59028791","1","","","2019-11-25 09:35:55","","2","1052","<p>Consider the following example:</p>

<pre><code>    cancellable = Just(2).map { x in
        Just(x * x).delay(for: 2.0, scheduler: RunLoop.main)
    }
    .switchToLatest()
    .sink(receiveCompletion: {_ in
        print(""completed"")
    }, receiveValue: {result in
        print(result)
    })
</code></pre>

<p>Here I try to mimic behavior of famous switchMap operator using Combine operators. I expect to get result after two seconds and completion. In reality neither result nor completion comes.
Which is very bad because upstream was completed!</p>

<p>Looks like switchToLatest cancels itself as soon as upstream completes and forgets to complete. 
On the other hand if I replace it with a <code>flatMap</code> everything works as expected.</p>

<p>Are there any good examples of a proper switchMap operator?</p>

<p>Disclaimer: Well I do understand my upstream completes. Though I want my switchMap to work irrespectively if my upstream completed before inner publisher or after.</p>
","2794542","","2794542","","2019-11-26 13:53:46","2020-03-07 23:04:46","How to implement proper switchMap operator in Combine?","<swift><combine>","3","3","","","","CC BY-SA 4.0"
"59029071","1","59038211","","2019-11-25 09:51:07","","1","557","<p>I have a time selection subview with two wheel pickers, one for minutes and one for seconds. The values are bound to two (local) state variables in the parent view. I'm looking for a way to have a global state variable ""time"" changed every time when either one of the two local variables changes. I don't want to directly bind the two state variables for min/sec to the global state as I want only one variable there holding the time in seconds only. So there should be a conversion time = min * 60 + seconds.</p>

<p>I'm struggling to find a way of detecting a value change of the two local state variables.</p>

<p>Here's the subview:</p>

<pre><code>struct TimePicker: View {
    var min: Binding&lt;Int&gt;
    var sec: Binding&lt;Int&gt;

    var body: some View {
        HStack() {
            Spacer()
            Picker(selection: min, label: EmptyView()) {
                ForEach((0...9), id: \.self) { ix in
                    Text(""\(ix)"").tag(ix)
                }
            }.frame(width: 40).clipped().pickerStyle(WheelPickerStyle())
            Text(""Min."")
            Picker(selection: sec, label: EmptyView()) {
                ForEach((0...59), id: \.self) { ix in
                    Text(""\(ix)"").tag(ix)
                }
            }.frame(width: 40).clipped().pickerStyle(WheelPickerStyle())
            Text(""Sec."")
            Spacer()
        }
    }
}
</code></pre>
","10826194","","","","","2019-11-25 18:40:21","How to call a function when a @State variable changes","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"59034299","1","59039703","","2019-11-25 14:42:31","","4","919","<p>Using SwiftUI I want to press a button and have it switch the class which is used to filter an image.</p>

<p>In SwiftUI, the button would do something like what follows:</p>

<pre><code>@ObservedObject var currentFilter = FilterChoice()
...
var body: some View {..
  Button(action:{
    print(""clicked"")
    var newFilter = Luminance()
    self.currentFilter = newFilter
  }) {
     Text(""Switch to Luminance Filter"")
  }
}
</code></pre>

<p>There is an ObservableObject:</p>

<pre><code>class FilterChoice: ObservableObject {  
    @Published var filter = Luminance()
}
</code></pre>

<p>Which is consumed by a UIViewRepresentable:</p>

<pre><code>struct FilteredPhotoView: UIViewRepresentable {
  @ObservedObject var currentFilter = FilterChoice()

  func makeUIView(context: Context) -&gt; UIView {
     ...
     // Code works and pulls correct filter but can not be changed
     let className = currentFilter.filter
     let filteredImage = testImage.filterWithOperation(className)
     ...   
  }...
</code></pre>

<p>Currently, FilteredPhotoView is properly returning the filtered image.</p>

<p>But how can ObservedObject be used to change a CLASS?</p>

<p>In other words, the ObservedObject sets the class correctly here:</p>

<pre><code>class FilterChoice: ObservableObject {
   @Published var filter = Luminance()    
}
</code></pre>

<p>But how can this ObservableObject be changed so that the class can be changed in SwiftUI? For example, I want to click a button and the filter should be changed to another class (for example:</p>

<pre><code>new filter = ColorInversion()
</code></pre>

<p>I think I understand how ObservableObjects work but I can't get it to work as a change of class rather than something simple like a string value.</p>
","4406080","","1015258","","2019-11-25 16:07:29","2019-11-25 20:35:25","SwiftUI = ObservableObject as Choice of Class","<swift><uikit><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59036863","1","59067605","","2019-11-25 17:08:54","","7","5752","<p>I am trying to make a <code>ObservableObject</code> that has properties that wrap a <code>UserDefaults</code> variable.</p>

<p>In order to conform to <code>ObservableObject</code>, I need to wrap the properties with <code>@Published</code>. Unfortunately, I cannot apply that to computed properties, as I use for the <code>UserDefaults</code> values.</p>

<p>How could I make it work? What do I have to do to achieve <code>@Published</code> behaviour?</p>
","5727960","","5727960","","2020-06-04 12:02:42","2020-10-15 19:57:13","Add @Published behaviour for computed property","<swift><swiftui><combine><property-wrapper>","4","1","7","","","CC BY-SA 4.0"
"59040013","1","59040171","","2019-11-25 20:59:34","","6","4938","<p>I am playing around with Swift UI. I created a table view (a List) containing all my desired elements. Also the TextField change is working when pressing enter on the keyboard. Nice to build so fast a table view ;).</p>

<p>But now I want to track every change on the textfield. Every time user enter another text I want to send a request which triggers a search.</p>

<p>How could this be done in my code? I read also this documentation here <a href=""https://developer.apple.com/documentation/combine/receiving_and_handling_events_with_combine"" rel=""noreferrer"">https://developer.apple.com/documentation/combine/receiving_and_handling_events_with_combine</a></p>

<p>I don't now how to use it in my struct.</p>

<p>The proposed solution here <a href=""https://stackoverflow.com/questions/57875550/textfield-changes-in-swiftui"">TextField changes in SwiftUI</a> does not work (anymore)</p>

<p>I would be thankful for every hint and every idea you can share with me. I am looking for hours for a solution :(.</p>

<p>My code looks like this:</p>

<pre><code>import Foundation
import SwiftUI

struct MyListView: View {
    @ObservedObject var viewModel: MyViewModel

    @State private var query = """"

    var body: some View {

        NavigationView {
            List {
                // how to listen for changes here?
                // if I add onEditingChange here, Get the value only after the user finish search (by pressing enter on the keyboard)
                TextField(String.localizedString(forKey: ""search_bar_hint""), text: self.$query) {
                    self.fetchListing()
                } 

                ForEach(viewModel.myArray, id: \.id) { arrayObject in
                    MyRow(arrayObj: arrayObject)
                }
            }
            .navigationBarTitle(navigationBarTitle())
        }
        .onAppear(perform: fetchListing)
    }

    private func fetchListing() {
        query.isEmpty ? viewModel.fetchRequest(for: nil) : viewModel.fetchRequest(for: query)
    }

    private func navigationBarTitle() -&gt; String {
        return query.isEmpty ? String.localizedString(forKey: ""my_title"") : query
    }
}
</code></pre>
","4017243","","","","","2020-07-26 09:14:32","Observe changes on SwiftUI TextField","<ios><swift><combine><swift5>","2","0","3","","","CC BY-SA 4.0"
"59047426","1","59052169","","2019-11-26 09:15:30","","1","451","<p>I have such <code>ObservableObject</code> that I am injecting into views hierarchy by using <code>environmentObject()</code>.</p>

<pre><code>class MenuModel: ObservableObject {

    @Published var selection: Int = 0
    @Published var isMenuOpen: Bool = false

    @Published var tabItems : [TabItem] = [TabItem]()
//    {
//        didSet {
//            objectWillChange.send()
//        }
//    }
    @Published var menuItems : [MenuItem] = [MenuItem]()
//    {
//        didSet {
//            objectWillChange.send()
//        }
//    }

    //var objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
}
</code></pre>

<p>And here are issues I do not really understand well: 
1. Above code with works correctly, as all properties are @Published. 
2. But If I change it to something like this </p>

<pre><code>class Click5MenuModel: ObservableObject {

    @Published var selection: Int = 0
    @Published var isMenuOpen: Bool = false

    var tabItems : [TabItem] = [TabItem]()
    {
        didSet {
            objectWillChange.send()
        }
    }
    var menuItems : [MenuItem] = [MenuItem]()
    {
        didSet {
            objectWillChange.send()
        }
    }

    var objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
}
</code></pre>

<p>Then @Published properties stop refreshing Views that depends on this ObservableObject! 
Why is that. I also tried to add <code>didSet</code> with <code>objectWillChange.send()</code> but this also causes some odd behaviour and code is a little bit awkward. </p>

<p>Does this mean that I can only use <strong>ONLY @Published</strong> or <strong>ONLY  objectWillChange</strong> approach?</p>
","4415642","","","","","2019-11-26 13:35:21","SwiftUI ObservableObject used as EnvironmentObject odd behaviour","<swiftui><combine><observableobject>","1","2","","","","CC BY-SA 4.0"
"59049974","1","59050148","","2019-11-26 11:30:07","","6","3986","<h2>Problem:</h2>
<p>Passing down the view model and modifying it from the children, won't refresh the parent.</p>
<h2>What I want:</h2>
<p>Whenever I modify the view model from the child view, the parent refresh too.</p>
<h2>Problem description:</h2>
<p>I'm looking for a way to pass down a <code>ViewModel ObservedObject</code> to some child views.</p>
<p>This is my struct:</p>
<pre><code>struct Parent: View {
    @ObservedObject viewModel: ViewModel

     var body: some View {
            NavigationView {
                Form {
                    ScrollView(showsIndicators: false) {
                         Section {
                            ChildViewOne(model: viewModel)
                        }
                        
                        Section {
                            ChildViewTwo(model: viewModel)
                        }
                        
                        Section {
                            ChildViewThree(model: viewModel)
                        }
                    }
                }
            }
        }
}

struct AnyChild: View {
    @ObservedObject viewModel: ViewModel

     var body: some View {
            // some stuff
        }
}
</code></pre>
<p>In this way, whenever I modify from the child views the view model, the children rebuild correctly, but the parent won't, and the scrollview does not resize correctly.</p>
<p>I would like to pass down to the children the viewModel like a Binding object, so the parent will refresh too.</p>
<p>But I don't know how to do. Any help?</p>
<h2>Solution:</h2>
<p>I had a specific problem with the <code>Form</code> when I've removed everything worked fine.</p>
<p>But still the correct solution as <strong>@Alladinian</strong> wrote is to use the  <code>@EnvironmentObject</code></p>
","6747915","","-1","","2020-06-20 09:12:55","2019-11-26 15:12:26","iOS SwiftUI: ObservableObject from parent to child","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59055022","1","59059838","","2019-11-26 16:08:46","","4","618","<p>In <a href=""http://developer.apple.com/reference/combine"" rel=""nofollow noreferrer"">Combine</a> framework there's a concept of a <a href=""https://developer.apple.com/documentation/combine/subscribers/demand"" rel=""nofollow noreferrer"">demand</a>, which allows signalling backpressure to <a href=""https://developer.apple.com/documentation/combine/publisher"" rel=""nofollow noreferrer"">publishers</a>.</p>

<p>Suppose I have a simple publisher:</p>

<pre class=""lang-swift prettyprint-override""><code>let numbers = Publishers.Sequence&lt;ClosedRange&lt;Int&gt;, Error&gt;(sequence: 0...100)
</code></pre>

<p>I would like to download certain URLs that use these numbers as arguments. I also would like a next download to start only after a previous download has finished.</p>

<p>A naive approach then would look like this:</p>

<pre class=""lang-swift prettyprint-override""><code>let subscription = numbers.sink(receiveCompletion: { _ in }, receiveValue: {
  let url = URL(string: ""https://httpbin.org/get?value=\($0)"")!
  URLSession.shared.dataTask(with: url) { 
    $0.map { print(String(data: $0, encoding: .utf8)!) }
  }.resume()
})
</code></pre>

<p>Unfortunately, this wouldn't satisfy the requirement of waiting for a previous download to complete before starting the next one. As far as I know, <code>sink</code> function would return a value of type <a href=""https://developer.apple.com/documentation/combine/anycancellable"" rel=""nofollow noreferrer""><code>AnyCancellable</code></a>, not of type <a href=""https://developer.apple.com/documentation/combine/subscription"" rel=""nofollow noreferrer""><code>Subscription</code></a>. If the latter was the case, we could call the <a href=""https://developer.apple.com/documentation/combine/subscription/3213720-request"" rel=""nofollow noreferrer""><code>request</code></a> function on the <code>subscription</code> with a specific demand after an upload completes.</p>

<p>What would be the best way to control demand of a subscription provided by <code>sink</code> or any other standard Combine <code>Subscriber</code>?</p>
","442427","","442427","","2019-11-26 21:48:47","2019-11-26 21:48:47","How to adjust Combine's Publisher demand without a custom Subscriber?","<swift><reactive-programming><combine>","1","2","3","","","CC BY-SA 4.0"
"59056881","1","59335347","","2019-11-26 18:00:02","","0","1266","<p>I have written a List with SwiftUI. I also have a TextField object which is used as a search bar. My code looks like this:</p>

<pre><code>import SwiftUI

struct MyListView: View {
    @ObservedObject var viewModel: MyViewModel

    @State private var query = """"

    var body: some View {

        NavigationView {
            List {
                // how to listen for changes here?
                // if I add onEditingChange here, Get the value only after the user finish search (by pressing enter on the keyboard)
                TextField(String.localizedString(forKey: ""search_bar_hint""), text: self.$query) {
                    self.fetchListing()
                } 

                ForEach(viewModel.myArray, id: \.id) { arrayObject in
                    NavigationLink(destination: MyDetailView(MyDetailViewModel(arrayObj: arrayObject))) {
                         MyRow(arrayObj: arrayObject)
                    }
                }
            }
            .navigationBarTitle(navigationBarTitle())
        }
        .onAppear(perform: fetchListing)
    }

    private func fetchListing() {
        query.isEmpty ? viewModel.fetchRequest(for: nil) : viewModel.fetchRequest(for: query)
    }

    private func navigationBarTitle() -&gt; String {
        return query.isEmpty ? String.localizedString(forKey: ""my_title"") : query
    }
}
</code></pre>

<p>The problem I have now is that the List remains behind the keyboard :(. How can I set the list padding bottom or edge insets (or whatever else works, I am totally open) so that the scrolling of the list ends above the keyboard? The list „size“ should also adjust automatically depending on if keyboard will be opened or closed. </p>

<p>Problem looks like this: </p>

<p><a href=""https://i.stack.imgur.com/xdtGX.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xdtGX.gif"" alt=""enter image description here""></a></p>

<p>Please help me with any advice on this, I really have no idea how to do this :(. I am a SwiftUI beginner who is trying to learn it :). </p>
","4017243","","12047322","","2019-11-26 20:34:45","2019-12-14 13:02:13","SwiftUI List with TextField adjust when keyboard appears/disappears","<ios><xcode><swiftui><combine><swift5>","2","1","","","","CC BY-SA 4.0"
"59059519","1","59123718","","2019-11-26 21:22:33","","1","221","<p>Scenario: <br/>
I'm playing around with accessing &amp; displaying remote images to learn Combine's assorted notification flags/protocols.
<p></p>

<p>One Goal: <br/>
Accessing a bad URL should <em>immediately</em> display an Alert().
<p>
Reality: <br/>
Alert is displayed <em>AFTER</em> then second request and beyond.</p>

<p><a href=""https://i.stack.imgur.com/DCtYp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DCtYp.png"" alt=""enter image description here""></a></p>

<p><p>
Here's the main (calling) view:</p>

<pre><code>import Combine
import SwiftUI

struct ContentView: View {
    @EnvironmentObject var settings: MySettings
    @State private var url: String = ""https://garbage.com""  // ...purposely set to display alert.
    @State private var image: URLImage = URLImage()
    @State private var angelFish: Image = Image(""QueenAngelfish"")
    @State private var isPresented = false

    var body: some View {
        ZStack {
            Color.green
            NavigationView {
                VStack {
                    Button(action: {
                        self.url = ""garbage.com""
                        self.isPresented = self.image.imageLoader.isPresented
                        self.image.imageLoader.load(url: URL(string: self.url)!)
                    }) {
                        Text(""Get An Image"")
                    }

                    angelFish
                        .resizable()
                        .frame(width: 300, height: 200, alignment: .center)
                        .padding()
                    image
                        .alert(isPresented: $isPresented, content: { () -&gt; Alert in
                            Alert(title: Text(verbatim: ""Unable to Acquire Image.""))
                        })

                }.navigationBarTitle(Text(settings.name))
            }
        }
    }
}
</code></pre>

<p><p>
Here's the access engine: <p></p>

<pre><code>import Combine
import SwiftUI

enum ImageURLError: Error {
    case dataIsNotAnImage
}

struct URLImage: View {
    @EnvironmentObject var settings: MySettings
    @ObservedObject var imageLoader: ImageLoader
    var placeholder: Image

    init() {
        self.placeholder = Image(systemName: ""photo"")
        self.imageLoader = ImageLoader()
    }

    var body: some View {
        VStack {
            imageLoader.image == nil ?
                placeholder : Image(uiImage: imageLoader.image!)
            Button(action: {
                self.settings.name = ""Happy Thanks Giving""
                self.settings.isPresented = true
            }, label: {
                Text(""Touch Me"")
            })
        }
    }
}

// =====================================================================================================

class ImageLoader: ObservableObject {
    let id: String = UUID().uuidString
    var didChange = PassthroughSubject&lt;Void, Never&gt;()

    @Published var isPresented = false

    @Published var image: UIImage? {
        didSet {
            DispatchQueue.main.async {
                self.didChange.send()
            }
        }
    }

    // ---------------------------------------------------------------------------

    func load(url: URL) {
        print(""Hello Ric: "", #function)

        URLSession.shared.dataTask(with: url) { data, _, error in
            DispatchQueue.main.async {
                if error != nil {
                    self.isPresented = true
                    self.didChange.send()   // ...attempting to activate alert().
                    return
                }

                self.image = UIImage(data: data!)
            }

        }.resume()
    }
}
</code></pre>

<p><p></p>

<p>This code purposely creates an error due to a bad URL. <br/>
I tried to immediately notify the calling routine via passing the boolean 'isPresented' flag as an '@Published' variable
<p>
Expected Result: <br/>
Displayed Alert.
<p>
Actual Result: <br/>
Alert is displayed AFTER &amp; beyond the initial attempt.
<p>
Question: How do I perform an INSTANT Alert display?</p>
","715747","","","","","2019-12-01 08:09:25","Why the Delayed Alert Display?","<alert><swiftui><combine>","1","0","0","","","CC BY-SA 4.0"
"59060419","1","","","2019-11-26 22:39:31","","10","3632","<p>Is there a way to specify that count should only publish on the <em>main thread</em>? I've seen docs that talk about setting up your Publisher using <code>receive(on:)</code>, but in this case the <code>@Publisher</code> wrapper hides that logic.</p>
<pre><code>import SwiftUI
import Combine

class MyCounter: ObservableObject {
  @Published var count = 0

  public static let shared = MyCounter()
  
  private init() { }
}

struct ContentView: View {
    @ObservedObject var state = MyCounter.shared
    var body: some View {
        return VStack {
            Text(&quot;Current count: \(state.count)&quot;)
            Button(action: increment) {
                HStack(alignment: .center) {
                    Text(&quot;Increment&quot;)
                        .foregroundColor(Color.white)
                        .bold()
                }
            }
        }
    }
    
    private func increment() {
        NetworkUtils.count()
    }
}

public class NetworkUtils {

    public static func count() {
        guard let url = URL.parse(&quot;https://www.example.com/counter&quot;) else {
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = &quot;GET&quot;
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            if let response = response as? HTTPURLResponse {
                let statusCode = response.statusCode
                if statusCode &gt;= 200 &amp;&amp; statusCode &lt; 300 {
                    do {
                        guard let responseData = data else {
                            return
                        }
                        
                        guard let json = try JSONSerialization.jsonObject(with: responseData, options: []) as? [String: Any] else {
                            return
                        }
                        
                        if let newCount = json[&quot;new_count&quot;] as? Int{
                            MyCounter.shared.count = newCount
                        }
                    } catch  {
                        print(&quot;Caught error&quot;)
                    }
                }
            } 
        }
        task.resume()
    }   
}
</code></pre>
<p>As you can see from my updated example, This is a simple SwiftUI view that has a button that when clicked makes a network call.  The network call is asynchronous. When the network call returns, the <code>ObservableObject MyCounter</code> is updated on a background thread. I would like to know if there is a way to make the <code>ObservableObject</code> publish the change on the main thread. The only way I know to accomplish this now is to wrap the update logic in the network call closure like this:</p>
<pre><code>DispatchQueue.main.async {
    MyCounter.shared.count = newCount
}
</code></pre>
","654720","","819340","","2021-06-17 01:13:03","2022-07-04 11:26:35","Consume @Published values on the main thread?","<swift><swiftui><combine>","3","3","1","","","CC BY-SA 4.0"
"59061582","1","59069315","","2019-11-27 01:01:56","","5","1111","<p>I can specify the scheduler as <code>RunLoop.main</code>, but I could not find a native way to provide the associated <code>RunLoop.Mode</code> mode to receive elements from a publisher.</p>

<p><strong>Why do I need this:</strong> I'm updating a tableView cell from my publisher but the UI does not update if the user is scrolling, it then updates as soon as the user interaction or scroll stops. <a href=""https://stackoverflow.com/questions/4109898/my-custom-ui-elements-are-not-being-updated-while-uiscrollview-is-scrolled/4136988"">This is a known behaviour for scrollViews</a> but I want my content to be displayed as soon as possible, and being able to specify the run loop tracking mode would fix this.</p>

<p><strong>Combine API:</strong> I do not think the <code>receive(on:options:)</code> method <a href=""https://developer.apple.com/documentation/combine/publisher/3204743-receive"" rel=""noreferrer"">have any matching options</a> to provide this. I think internally, if I call <code>receive(on:RunLoop.main)</code> then <code>RunLoop.main.perform { }</code> is called. This perform method can take <a href=""https://developer.apple.com/documentation/foundation/runloop/2091880-perform"" rel=""noreferrer"">the mode as parameter</a> but this is not exposed to the Combine API.</p>

<hr>

<p><strong>Current Idea:</strong> To go around this I could do the perform action myself and not use the Combine API, so instead of doing this:</p>

<pre><code>cancellable = stringFuture.receive(on: RunLoop.main) // I cannot specify the mode here
                          .sink { string in
    cell.textLabel.text = string
}
</code></pre>

<p>I could do this:</p>

<pre><code>cancellable = stringFuture.sink { string in
    RunLoop.main.perform(inModes: [RunLoop.Mode.common]) { // I can specify it here
        cell.textLabel.text = string
    }
}
</code></pre>

<p>But this is not ideal.</p>

<p><strong>Ideal Solution:</strong> I was wondering how could I wrap this into my own implementation of a publisher function to have something like this:</p>

<pre><code>cancellable = stringFuture.receive(on: RunLoop.main, inMode: RunLoop.Mode.common)
                          .sink { string in
    cell.textLabel.text = string
}
</code></pre>

<p>Were the API of this function could be something like this:</p>

<pre><code>extension Publisher {
    public func receive(on runLoop: RunLoop, inMode: RunLoop.Mode) -&gt; AnyPublisher&lt;Future.Output, Future.Failure&gt; {

        // How to implement this?

    }
}
</code></pre>
","596857","","","","","2020-02-25 06:27:29","Is there a way to specify the run loop & mode to to receive elements from a publisher","<swift><uikit><combine><runloop>","2","0","2","","","CC BY-SA 4.0"
"59064289","1","59078334","","2019-11-27 06:29:00","","2","1645","<p>I've successfully set up authentication within my app using Google Sign-In to where I am able to return a Firebase User. I am attempting to set up a Sign-In screen that is only shown when there is no authenticated Firebase User, however with my current code the Sign-In screen is always visible even though I am consistently returning an authenticated user.</p>

<p>I've implemented the <code>didSignInFor</code> function in <code>AppDelegate</code></p>

<pre><code>func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error?) {
      // ...
      if let error = error {
        print(error.localizedDescription)
        return
      }

      guard let authentication = user.authentication else { return }
      let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken,
                                                        accessToken: authentication.accessToken)
      // ...
        Auth.auth().signIn(with: credential) { (authResult, error) in
            if let error = error {
                print(error.localizedDescription)
                return
            }
            let session = FirebaseSession.shared

            if let user = Auth.auth().currentUser {
                session.user = User(uid: user.uid, displayName: user.displayName, email: user.email)
                print(""User sign in successful: \(user.email!)"")
            }
        }
    }
</code></pre>

<p>as well as a few lines in <code>didFinishLaunchingWithOptions</code> that sets the <code>isLoggedIn</code> property of my <code>ObservableObject</code> <code>FirebaseSession</code></p>

<pre><code>func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
        // Override point for customization after application launch.

        FirebaseApp.configure()

        let auth = Auth.auth()

        if auth.currentUser != nil {
            FirebaseSession.shared.isLoggedIn = true
            print(auth.currentUser?.email!)
        } else {
            FirebaseSession.shared.isLoggedIn = false
        }

        //Cache
        let settings = FirestoreSettings()
        settings.isPersistenceEnabled = false

        GIDSignIn.sharedInstance().clientID = FirebaseApp.app()?.options.clientID
        GIDSignIn.sharedInstance().delegate = self

        return true
    }
</code></pre>

<p>My <code>ObservableObject</code></p>

<pre><code>class FirebaseSession: ObservableObject {

        static let shared = FirebaseSession()
        init () {}

        //MARK: Properties
        @Published var user: User?
        @Published var isLoggedIn: Bool?

        @Published var items: [Thought] = []

        var ref: DatabaseReference = Database.database().reference(withPath: ""\(String(describing: Auth.auth().currentUser?.uid ?? ""Error""))"")

        //MARK: Functions
        func listen() {
            _ = Auth.auth().addStateDidChangeListener { (auth, user) in

                if auth.currentUser != nil {
                    self.isLoggedIn = true
                }

                if let user = user {
                    self.user = User(uid: user.uid, displayName: user.displayName, email: user.email)
                } else {
                    self.user = nil
                }
            }
        }
    }
</code></pre>

<p>Finally, I perform my authentication check in the main view of my app here accessing <code>FirebaseSession</code> via my <code>ObservedObject</code></p>

<pre><code>struct AppView: View {

    @ObservedObject var session = FirebaseSession.shared

    @State var modalSelection = 1
    @State var isPresentingAddThoughtModal = false

    var body: some View {
        NavigationView {
            Group {
                if session.isLoggedIn == true {
                    ThoughtsView()
                } else {
                    SignInView()
                }
            }
        }
    }
}
</code></pre>

<p>As mentioned above my check doesn't seem to work. Even though my user is authenticated, <code>SignInView</code> is always visible.</p>

<p>How can I successfully check my user authentication each time my app loads?</p>

<p><strong>UPDATE</strong></p>

<p>I am now able to check authentication when the app loads, but after implementing Sohil's solution I am not observing realtime changes to my <code>ObservableObject</code> <code>FirebaseSession</code>. I want to observe changes to <code>FirebaseSession</code> so that after a new user signs in, the body of <code>AppView</code> will be redrawn and present <code>ThoughtsView</code> instead of <code>SignInView</code>. Currently I have to reload the app in order for the check to occur after authentication.</p>

<p>How do I observe changes to <code>FirestoreSession</code> from <code>AppView</code>?</p>
","6035021","","6035021","","2019-11-27 17:41:52","2020-05-22 23:21:51","Checking user authentication using Google Sign In and SwiftUI","<ios><swift><firebase-authentication><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"59074995","1","59079883","","2019-11-27 16:51:46","","3","2403","<p>I'm trying to work out how I can correctly pass an object or a set of values between two ViewModels in a parent-child relationship so that when the child ViewModel is updated the change bubbles back up to the parent.</p>

<p>This is pretty simple when just using SwiftUI views and binding directly to the stores but I wanted to keep my business logic for field validation and so on separate from the SwiftUI views.</p>

<p>The code below shows the child updating (as expected) when the parent gets updated, but I need to somehow pass the changed values in the child back up to the parent. I'm very new to mobile app development and still learning so I'm sure I'm missing something quite simple.</p>

<pre><code>import SwiftUI
import Combine

struct Person: Hashable {
  var givenName: String
  var familyName: String
}

// my person store - in the real app it's backed by coredata
class PersonStore: ObservableObject {
  @Published var people: [Person] = [
    Person(
      givenName: ""Test"",
      familyName: ""Person""
    )
  ]
  static let shared = PersonStore()
}

// app entrypoint
struct PersonView: View {
  @ObservedObject var viewModel: PersonView_ViewModel = PersonView_ViewModel()

  var body: some View {
    NavigationView {
      VStack {
        List(viewModel.people.indices, id: \.self) { idx in
          NavigationLink(destination: PersonDetailView(viewModel: PersonDetailView_ViewModel(personIndex: idx))) {
            Text(self.viewModel.people[idx].givenName)
          }
        }
      }
    }
  }
}

class PersonView_ViewModel: ObservableObject {
  @Published var people: [Person] = PersonStore.shared.people
}

// this is the detail view
struct PersonDetailView: View {
  @ObservedObject var viewModel: PersonDetailView_ViewModel

  var body: some View {
    Form {
      Section(header: Text(""Parent View"")) {
        VStack {
          TextField(""Given Name"", text: self.$viewModel.person.givenName)
          Divider()
          TextField(""Family Name"", text: self.$viewModel.person.familyName)
        }
      }
      PersonBasicDetails(viewModel: PersonBasicDetails_ViewModel(person: viewModel.person))
    }
  }
}

// viewmodel associated with detail view
class PersonDetailView_ViewModel: ObservableObject {
  @Published var person: Person

  init(personIndex: Int) {
    self.person = PersonStore.shared.people[personIndex]
  }
}

// this is the child view - in the real app there are multiple sections which are conditionally rendered
struct PersonBasicDetails: View {
  @ObservedObject var viewModel: PersonBasicDetails_ViewModel

  var body: some View {
    Section(header: Text(""Child View"")) {
      VStack {
        TextField(""Given Name"", text: self.$viewModel.person.givenName)
        Divider()
        TextField(""Family Name"", text: self.$viewModel.person.familyName)
      }
    }
  }
}

class PersonBasicDetails_ViewModel: ObservableObject {
  @Published var person: Person

  init(person: Person) {
    self.person = person
  }
}

struct PersonView_Previews: PreviewProvider {
  static var previews: some View {
    PersonView()
  }
}
</code></pre>
","12440639","","","","","2020-05-22 04:14:22","Bidirectional binding with SwiftUI and Combine","<swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"59098343","1","59121796","","2019-11-29 03:14:50","","3","1487","<p>I am trying to transition an app from UIKit to SwiftUI which depends on basic DynamoDB resources but I have hit a snag in forcing the view to refresh as data is added to the list. I have been at this set of code for hours trying different things and I thought I might see if anyone might know why the 'SessionsData' seems to be thrown away and will not accumulate the 'Sessions' objects.</p>

<p>Does anyone have any quick thoughts???</p>

<pre><code>class SessionsData: ObservableObject {

    let didChange = PassthroughSubject&lt;SessionsData, Never&gt;()
    @Published var data: [Sessions] = [] {
        didSet {
            didChange.send(self)
        }
    }

    init() {
        load()
    }

    func load() {
        let dynamoDBObjectMapper = AWSDynamoDBObjectMapper.default()
        let scanExpression = AWSDynamoDBScanExpression()
        scanExpression.limit = 20

        var temp : [Sessions] = []

        dynamoDBObjectMapper.scan(Sessions.self, expression: scanExpression).continueWith(block: { (task:AWSTask&lt;AWSDynamoDBPaginatedOutput&gt;!) -&gt; Any? in
            if let error = task.error as NSError? {
                 print(""The request failed. Error: \(error)"")
             } else if let paginatedOutput = task.result {
                for session in paginatedOutput.items as! [Sessions] {
                    print(""Item Found"")
                    temp.append(session)
                }
                DispatchQueue.main.async {
                    self.data = temp
                    self.didChange.send(self)
                }
             }
            print(self.data.count)
            return true
         })
    }
}
</code></pre>

<pre><code>struct Events: View {

    @ObservedObject var sessionsData = SessionsData()


    var body: some View {...}
}

</code></pre>
","12454606","","7948372","","2019-11-29 07:36:06","2019-12-01 01:25:36","How do I load data using ObservableObject in SwiftUI?","<amazon-dynamodb><swiftui><combine>","2","2","1","","","CC BY-SA 4.0"
"59103163","1","59103792","","2019-11-29 10:35:34","","10","3465","<p>I'm using swiftUI and combine, I'have some business logic in my VM. Some results have to dismiss my view.</p>

<p>I'v used this one in some views :</p>

<pre><code>@Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;

self.presentationMode.wrappedValue.dismiss()

</code></pre>

<p>I want to something similar in my view model.</p>
","2114456","","2114456","","2019-12-02 08:31:37","2021-12-30 07:19:55","Dismiss view from view model [MODAL PAGE]","<swift><swiftui><combine>","2","2","1","","","CC BY-SA 4.0"
"59108467","1","","","2019-11-29 16:43:12","","2","1417","<p>I´m banging my head against the desk about the following problem. I have a nested DataStore (for convenience), integrated into a view via @EnvironmentObject. If I change something in the DataStore (eg. putting a new object inside - which works fine-), the UI does not update. </p>

<p>In the console, I also get the results of the print(""Object Changed""), caused by a change in the fetched results. But the UI only updates after I restart the app. Whats wrong here?</p>

<p>Thanks a lot in advance!</p>

<p>My Test Code looks like this:</p>

<p><strong>The DataStore:</strong></p>

<pre><code>import Foundation
import Combine

class DataStore : ObservableObject{
    @Published var documents    = DocumentStore()
    @Published var attachments  = AttachmentStore()
}

</code></pre>

<p><strong>The Attachment Store</strong></p>

<pre><code>//
//  AttachmentStore.swift

import SwiftUI
import Combine
import CoreData

class AttachmentStore: NSObject, ObservableObject {


    // MARK: Private Properties
     let persistenceManager = PersistenceManager()

    private lazy var fetchedResultsController: NSFetchedResultsController&lt;ManagedAttachment&gt; = {
        let fetchRequest: NSFetchRequest&lt;ManagedAttachment&gt; = ManagedAttachment.fetchRequest()
        fetchRequest.sortDescriptors = [NSSortDescriptor(key: ""dateCreated"", ascending: false)]

        let fetchedResultsController = NSFetchedResultsController(
            fetchRequest: fetchRequest,
            managedObjectContext: self.persistenceManager.managedObjectContext,
            sectionNameKeyPath: nil,
            cacheName: nil)
        fetchedResultsController.delegate = self
        return fetchedResultsController
    }()

    private var attachment: [ManagedAttachment] {
        return fetchedResultsController.fetchedObjects ?? []
    }

    // MARK: Public Properties

    @Published var Items : [ManagedAttachment] = []

    public var allItems: [ManagedAttachment] {
        return self.attachment.filter {$0 == $0}
       }

    func setup(){
        self.Items = allItems
    }
    // MARK: Object Lifecycle

    override init() {
        super.init()
        fetchDocuments()
        setup()
    }

    // MARK: Public Methods

    public func allAttachments(for id: UUID) -&gt; [ManagedAttachment]
    {
        let attachments = self.allItems.filter {$0.parentID == id}
        return attachments
    }

    public func create(attachment: Attachment) {
        ManagedAttachment.create(object: attachment, in: self.persistenceManager.managedObjectContext)
         saveChanges()
     }

    public func delete(attachment: ManagedAttachment){
        persistenceManager.managedObjectContext.delete(attachment)
        self.saveChanges()
    }

    public func update(){
        self.saveChanges()
    }


    // MARK: Private Methods

    private func fetchDocuments() {
        do {
            try fetchedResultsController.performFetch()
            dump(fetchedResultsController.sections)
        } catch {
            fatalError()
        }
    }

    private func saveChanges() {
        guard persistenceManager.managedObjectContext.hasChanges else { return }
        do {
            try persistenceManager.managedObjectContext.save()
            self.objectWillChange.send()
            print(""Object Changed"")
        } catch { fatalError() }
    }
}


extension AttachmentStore: NSFetchedResultsControllerDelegate {
    func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
        self.objectWillChange.send()
        print(""Object Changed"")
    }
}


</code></pre>

<p><strong>The TestView</strong></p>

<pre><code>import SwiftUI

struct TestView: View {
    @EnvironmentObject var data : DataStore

    var body: some View {
        VStack{
            Button(action: {
                self.data.attachments.create(attachment: Attachment(url: ""Test""))
            }
            ) {
                Text(""Add"")
            }
            // Print the Items in the DataStore
            ForEach(data.attachments.Items, id:\.self){Item in
                Text(Item.url).font(.caption)
            }
        }

    }
}
</code></pre>
","5007451","","","","","2019-12-09 00:45:19","Swift UI - EnvironmentObject change does not update UI","<core-data><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"59122903","1","59147976","","2019-12-01 05:49:40","","3","66","<p>I have a flow which transforms data, acts on it, transform it again, and acts on that. For example:</p>

<pre><code>// Current code
Just(0)
    .map({ $0 + 1 })
    .map({ funcX($0); return $0 })
    .map({ $0 + 1 })
    .map({ funcY($0); return $0 })
    ...
</code></pre>

<p>I know reactive programming is about streams, but I would like to call <code>funcX</code> without needing to return the value. Is there a function which passes in the value and automatically passes along the value? Something like:</p>

<pre><code>// Hypothetical
Just(0)
    .map({ $0 + 1 })
    .call({ funcX($0) })
    .map({ $0 + 1 })
    .call({ funcY($0) })
    ...
</code></pre>

<p>Note: The above swift needs more syntax to actually compile, just is an example.</p>
","359532","","","","","2019-12-02 23:09:54","Is there a reactive function which executes and passes the original value?","<swift><reactive-programming><combine>","2","0","1","","","CC BY-SA 4.0"
"59148845","1","59165563","","2019-12-03 01:07:34","","3","1554","<p>I have been working on an app with a compass in it that updates its heading based on <a href=""https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/LocationHeadingProxy.swift"" rel=""nofollow noreferrer"">this example</a> for publishing heading changes and <a href=""https://github.com/heckj/swiftui-notes/blob/master/UIKit-Combine/HeadingViewController.swift"" rel=""nofollow noreferrer"">this example</a> for creating a publisher to deal with those changes.</p>

<p>I'm very new to reactive programming, but the issue I'm running into seems like a common problem, so I wanted to post it and see if someone can help.</p>

<p>Sometimes it works for a little while, with new headings coming from the publisher and updating the UI, but then stops working. Other times, it doesn't ever start updating (an error is being delivered before any heading updates). In either case, it makes sense that the events would stop since a failure completion event is being sent to the publisher:</p>

<pre><code>func locationManager(_ manager: CLLocationManager,
                     didFailWithError error: Error) {

    headingPublisher.send(completion: Subscribers.Completion.failure(error))

    print(""error: \(error.localizedDescription)"")
}
</code></pre>

<p>First, I'm trying to figure out what these errors are so I can try to deal with them better... is the error really worth stopping the publisher? I am wondering what kind of error can happen mid-stream of heading updates, since heading updates resume after the error, even though the publisher stops. I tried printing the error, but all I get is this, which doesn't seem helpful:
<code>error: The operation couldn’t be completed. (kCLErrorDomain error 0.)</code></p>

<p>I am not great at iOS, so if anyone has suggestions for how to get a better error description here please let me know.</p>

<p>Second, I'm wondering how I can ignore errors from the publisher on the subscription, if that's what I should be doing, so <code>.sink</code> will keep getting heading updates even after there is an error. Here's my publisher code below, based on the example:</p>

<pre><code>    _ = headingProxy
        .publisher
        .receive(on: RunLoop.main)
        .sink(receiveCompletion: { completion in },
              receiveValue: { [weak self] (heading) in
                self?.currentHeadingAccuracy = heading.headingAccuracy
                self?.currentHeading = heading.trueHeading
        })
        .store(in: &amp;cancellableSet)
</code></pre>

<p>I realize I could just not ever send the error to the publisher (is that what I should do? have a specific publisher just for the heading updates that never sends errors?) but I am assuming the person who made this included sending the error to the publisher with good reason, and that it may be a best practice to deal with it on the subscription side instead, or that there is some best-practice for recovering after an error.</p>
","241163","","1000551","","2019-12-07 09:59:23","2019-12-07 09:59:23","What is the best practice for dealing with errors in a publisher in Combine? (Publishing heading updates from CoreLocation)","<ios><swift><core-location><combine>","1","1","1","","","CC BY-SA 4.0"
"59203083","1","","","2019-12-05 20:52:12","","3","3748","<p>I know in which situations to use <code>@Binding</code> and <code>@Published</code></p>
<p>like in <strong>ObservableObject</strong> I generally use <strong>@Published</strong>, or <code>objectWillChange.send()</code></p>
<p>And <code>@Binding</code> in subviews to propagate changes to parent</p>
<p>But here I have snippet which seems to be working that uses both <code>@Binding</code> and <code>@Published</code>
in <strong>ObservableObject</strong></p>
<p>I consider what is the difference.</p>
<pre><code>@Binding var input: T
@Binding var validation: Validation

@Published var value: T {
    didSet {
        self.input = self.value
        self.validateField()
    }
}

init(input: Binding&lt;T&gt;, rules: [Rule&lt;T&gt;], validation: Binding&lt;Validation&gt;) {
    self._input = input
    self.value = input.wrappedValue
    self.rules = rules
    self._validation = validation
}
</code></pre>
<p>As I tested it seems that if I bind TextField to @Published then didSet is called but if I bind it to @Binding then didSet won't be called.</p>
","4415642","","614065","","2020-07-19 14:04:37","2020-07-19 14:04:37","SwiftUI and Combine what is the difference between Published and Binding","<binding><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"59206514","1","59206913","","2019-12-06 03:37:27","","1","234","<p>I have problem, that UI gets ugly updated from zero to some number. <em>Problem is when removing all items and adding new items to array UI gets updated</em> because this array is marked with <strong><em>@Published</em></strong> property wrapper. More detailed explanation about problem:</p>

<ol>
<li>At stage 1 (marked in the code snapshot) removing items from the list. </li>
<li>In this case UI gets updated and count in the UI updates to zero.</li>
<li>After some time when fetch is done and new items are added into array
(stage 2).  </li>
<li>Then UI gets update with new items count.</li>
<li>Problem is that here is ugly count update from zero to some number in the UI.</li>
</ol>

<p>Is here a way to disable distributing event for class members which are marked with @Published property wrapper?</p>

<pre><code>class ItemsProvider: ObservableObject {
    @Published var items: [Item] = []

    func fetchUsing(query: Query, completion: @escaping (Error?) -&gt; Void) {
        self.items.removeAll() // 1. Removing old items.

        query.getDocuments { (result, error) in
            result?.forEach {
                self.items.append(try? $0.data(as: Item.self)) // 2. Adding new items.
            }
            completion(error)
        }
    }
}
</code></pre>
","1151916","","","","","2019-12-06 04:31:55","Disable sending events for @Published variables in the ObservableObject","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"59221320","1","","","2019-12-06 22:50:51","","0","686","<p>I have such view model for search bar that has search done on term typed into bar. Then it make request and assigns to results. </p>

<pre><code>class SearchViewModel&lt;T&gt;: ObservableObject {

    @Published var searchTerm = """"
    @Published var results: [T] = []

    private var disposables = Set&lt;AnyCancellable&gt;()

    init() {
        $searchTerm
            .debounce(for: .seconds(1), scheduler: DispatchQueue.global())
            .flatMap { term in
                self.search(by: term)
            }
            .print(""searching"")
            .assign(to: \.results, on: self)
            .store(in: &amp;disposables)
    }

    open func search(by term: String) -&gt; AnyPublisher&lt;[T], Never&gt; {
        fatalError()
    }
}
</code></pre>

<p>View is checking based on this $viewModel.results whether to display Results View in over fullscreen mode or not. </p>

<p>But in spite of search being generally hidden (if user not tap onto button) there is constantly something happaning in this Publisher stream</p>

<pre><code>2019-12-06 23:45:09.810053+0100 CRM[1589:440623] [SwiftUI] Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.
Dim drag (19.666656494140625, -1.6666717529296875)
searching: receive subscription: (FlatMap)
searching: request unlimited
Dim drag (42.33332824707031, -7.6666717529296875)
End dim drag: (56.33332824707031, -13.333328247070312)
searching: receive subscription: (FlatMap)
searching: request unlimited
searching: receive subscription: (FlatMap)
searching: request unlimited
searching: receive subscription: (FlatMap)
searching: request unlimited
Search button tapped!
searching: receive value: ([])
searching: receive value: ([])
searching: receive value: ([])
searching: receive value: ([])
</code></pre>

<p>It is odd as this should be triggered only on input (term) typed into the field. </p>

<p>I think here is something wrong.</p>

<p>UPDATE!</p>

<p>important this multiple searchning stream logs appear in console where there is dragged in Hamburger menu if it is shown using bar button then there is only one refresh. It's a little bit wierd that showing view (or rather moving it with offset causes @Published var term to get new input, and also I see that my List content is then refreshing. </p>
","4415642","","","","","2019-12-09 06:32:21","SwiftUI and Combine Observable object having @Published is constantly publishing","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59224781","1","59248313","","2019-12-07 09:50:05","","9","4186","<p>I want to make a network request more than one time when some error occurs using retry() from Swift/Combine. The block inside the publisher is called once only which means one only one request is made for a real app when error happens. My code is:</p>

<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Combine
import PlaygroundSupport

enum TestFailureCondition: Error {
    case invalidServerResponse
}

var backgroundQueue: DispatchQueue = DispatchQueue(label: ""backgroundQueue"")

var failPublisher: AnyPublisher&lt;(Data, URLResponse), Error&gt; {
    Future&lt;(Data, URLResponse), Error&gt; { promise in
        print(""Attempt to call"")
        backgroundQueue.asyncAfter(deadline: .now() + Double.random(in: 1..&lt;3)) {
            promise(.failure(TestFailureCondition.invalidServerResponse))
        }
    }
    .eraseToAnyPublisher()
}

let cancellable = failPublisher
.print(""(1)&gt;"")
.retry(3)
.print(""(2)&gt;"")
.sink(receiveCompletion: { fini in
    print("" ** .sink() received the completion:"", String(describing: fini))


    PlaygroundPage.current.finishExecution()
}, receiveValue: { stringValue in
    print("" ** .sink() received \(stringValue)"")
})

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre>

<p>I expect that <code>backgroundQueue.asyncAfter(deadline)</code> is called three time before some error happens. Does anyone know why?</p>
","6305934","","","","","2019-12-29 12:12:07","Swift. Combine. Is there any way to call a publisher block more than once when retry?","<swift><combine>","2","2","1","","","CC BY-SA 4.0"
"59235975","1","","","2019-12-08 13:42:01","","0","258","<p>I have written a custom PropertyWrapper, that tries to wrap UserDefaults while also giving them the same behaviour as a <code>@Published</code> variable. It almost works, except that the ObservableObject does not propagate the changes without observing the UserDefaults themselves.</p>

<p>I cannot pass a <code>objectWillChange</code> ref to the <code>@Setting</code> init, as <code>self</code> is not available during <code>Settings.init</code>...</p>

<p>I wonder how <code>@Published</code> does that..</p>

<pre><code>import Combine
import Foundation

class Settings: ObservableObject {

// Trying to avoid this:
/////////////////////////////////////////////
  let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
  private var didChangeCancellable: AnyCancellable?
  private init(){
    didChangeCancellable = NotificationCenter.default
      .publisher(for: UserDefaults.didChangeNotification)
      .map { _ in () }
      .receive(on: DispatchQueue.main)
      .subscribe(objectWillChange)
  }
/////////////////////////////////////

  static var shared = Settings()

  @Setting(key: ""isBla"") var isBla = true
}


@propertyWrapper
public struct Setting&lt;T&gt; {

  let key: String
  let defaultValue: T

  init(wrappedValue value: T, key: String) {
    self.key = key
    self.defaultValue = value
  }

  public var wrappedValue: T {
    get {
      let val = UserDefaults.standard.object(forKey: key) as? T
      return val ?? defaultValue
    }
    set {
      objectWillChange?.send()
      publisher?.subject.value = newValue
      UserDefaults.standard.set(newValue, forKey: key)
    }
  }

  public struct Publisher: Combine.Publisher {

    public typealias Output = T

    public typealias Failure = Never

    public func receive&lt;Downstream: Subscriber&gt;(subscriber: Downstream)
      where Downstream.Input == T, Downstream.Failure == Never {
        subject.subscribe(subscriber)
    }

    fileprivate let subject: Combine.CurrentValueSubject&lt;T, Never&gt;

    fileprivate init(_ output: Output) {
      subject = .init(output)
    }
  }

  private var publisher: Publisher?

  internal var objectWillChange: ObservableObjectPublisher?

  public var projectedValue: Publisher {
    mutating get {
      if let publisher = publisher {
        return publisher
      }
      let publisher = Publisher(wrappedValue)
      self.publisher = publisher
      return publisher
    }
  }
}
</code></pre>
","5727960","","","","","2019-12-08 13:42:01","Make ObservableObject subscribe to custom PropertyWrapper","<swift><swiftui><combine>","0","5","","","","CC BY-SA 4.0"
"59240848","1","59243722","","2019-12-08 23:26:35","","1","126","<p><strong>Scenario:</strong> Attempting to broadcast a variable value via an <em>ObservableObject</em>.
<br/>
<strong>Problem:</strong> I'm only getting the default value; not the <em>assigned</em> value.
<p>
Here's the origin. <br/>
Button #1 starts a function to get data.
<br/>
Button #2 retrieves the ObservedObject's revised value
<p>
I removed some of the vestigial code to make the presentation simpler:
<p></p>

<pre><code>struct ContentView: View {
    @ObservedObject var networkManager = NetworkManager()

    let fontCustom = Font.custom(""Noteworthy"", size: 23.0)

    var body: some View {
        ZStack {
        // ...
        // ...
 HStack {
         Button(
              action: {
                  NetworkManager().getCalculatorIDs()
              },
              label: { 
                 Text(""1"")
              }
         )

        Button(
             action: {
                 self.calculator.calculate(""2"");
                 print(self.networkManager.calculationID)  // stop and check.                            
             },
             label: { Text(""2"") }
        )
// ...
// ...
}
}
</code></pre>

<p><p>
So I tap Button #1 then tap Button #2 to check if the <em>ObservedObject</em> has the <em>generated id value</em>.  <p>
I'm expecting an alphanumeric id value in the print(). <p>
Instead, I got the original value:<br/></p>

<pre><code>Royal Turkey
(lldb) 
</code></pre>

<p><p>
Here's the ObservableObject:
<p></p>

<pre><code>struct CalculationIdentifier: Decodable {
    let id: String
    let tokens: [String]
}

class NetworkManager: ObservableObject {
    @Published var calculationID = ""Royal Turkey""
    @Published var isAlert = false
    @Published var name = ""Ric Lee""

    let calculations = ""https://calculator-frontend-challenge.herokuapp.com/Calculations""

    func getCalculatorIDs() {
        let urlRequest = URLRequest(url: URL(string: calculations)!)
        let configuration = URLSessionConfiguration.ephemeral

        let task = URLSession(configuration: configuration).dataTask(with: urlRequest) { data, _, error in

            DispatchQueue.main.async {
                do {
                    let result = try JSONDecoder().decode([CalculationIdentifier].self, from: data!)
                    if !result.isEmpty {
                        self.calculationID = (result[0] as CalculationIdentifier).id
                        print(""Inside do{}. result = \(result)"")
                        self.isAlert = true
                    } else {
                        print(#function, ""Line:"", #line, "": No Result"")
                    }
                } catch {
                    print(error)
                }
            }
        }

        task.resume()
    }
}
</code></pre>

<p><p>
BTW: Here's the <em>local</em> console output, the string value of 'id' should have been passed to the host as an <em>ObservedObject</em> value:</p>

<pre><code>Inside do{}. result = [RicCalculator2.CalculationIdentifier(id: ""d3dd3b1e-d9f6-4593-8c85-b8fd3d018383"", tokens: [])]
</code></pre>

<p><p>
So I do have a bona fide id value to send.
<p>
Why only the original value? <br/>
What am I missing?<p>
...do I need to do a 'send' or something?</p>
","715747","","715747","","2019-12-08 23:36:53","2019-12-09 06:39:54","ObservedObject only passes its default value; not its assigned value. Why?","<combine><observableobject><observedobject>","1","0","","","","CC BY-SA 4.0"
"59242482","1","","","2019-12-09 04:17:39","","18","14325","<p>My main problem is that I'm trying to work around the (undocumented) fact that <code>@Published</code> properties don't update the property's value until after subscribers have been notified of the change. I can't seem to get a good way around it.</p>

<p><strong>Consider the following contrived combination of a <code>Subject</code> and <code>@Published</code> properties. First, a simple class:</strong></p>

<pre><code>class StringPager {
    @Published var page = 1
    @Published var string = """"
}
let pager = StringPager()
</code></pre>

<p><strong>And then a simple passthrough subject:</strong></p>

<pre><code>let stringSubject = PassthroughSubject&lt;String, Never&gt;()
</code></pre>

<p>For debugging, let's subscribe to the string property and print it out:</p>

<pre><code>pager.$string.sink { print($0) }
</code></pre>

<p>So far so good. Next, let's subscribe to the subject and alter the pager based on its value:</p>

<pre><code>stringSubject.sink { string in
  if pager.page == 1 {
    pager.string = string
  } else {
    pager.string = string.uppercased()
  }
}
</code></pre>

<p>Hopefully, this logic will allow us to make the pager string uppercased whenever we're not on the first page.</p>

<p><strong>Now let's send values through the stringSubject when the page gets updated:</strong></p>

<pre><code>pager.$page.sink { 
  $0 == 1 ? stringSubject.send(""lowercase"") : stringSubject.send(""uppercase"") 
}
</code></pre>

<p>If we've gotten this logic right, then lowercase will always be lowercased, while uppercase will always be uppercased. Unfortunately, that's not at all what happens. Here's a sample output:</p>

<pre><code>pager.page = 1 // lowercase
pager.page = 2 // uppercase
pager.page = 3 // UPPERCASE
pager.page = 4 // UPPERCASE
pager.page = 1 // LOWERCASE
pager.page = 1 // lowercase
</code></pre>

<p>The reason for this is when we subscribe to the subject, we check the value of <code>pager.page</code>... but updating <code>pager.page</code> is what triggers the subject's closure, so the <code>pager.page</code> doesn't have an updated value yet, so the subject executes the wrong branch.</p>

<p><strong>I've tried fixing this by both <code>zip</code>ing the <code>pager.$page</code> with the subject before sinking:</strong></p>

<pre><code>stringSubject.zip(pager.$page).eraseToAnyPublisher().sink { ...same code... }
</code></pre>

<p>as well as <code>combineLatest</code>ing it:</p>

<pre><code>stringSubject.combineLatest(pager.$page).eraseToAnyPublisher().sink { ...same code... }
</code></pre>

<p>but that leads either to the exact same observed behavior (in the former case) or equally undesired behavior except more of it (in the latter case).</p>

<p><strong>How can I get the <em>current</em> page <em>within</em> the subject <code>sink</code> closure?</strong></p>
","1799154","","10584330","","2019-12-09 05:37:30","2019-12-17 23:20:29","Combine @Published property: get current value during update, from elsewhere","<ios><swift><combine>","2","1","7","","","CC BY-SA 4.0"
"59253731","1","59271206","","2019-12-09 17:20:45","","-1","1075","<p>I am getting the following compiler-time error, for a Swift publisher solution I am working on:</p>

<p><code>Instance method 'store(in:)' requires that 'Set&lt;[AnyCancellable]&gt;' conform to 'RangeReplaceableCollection'</code></p>

<p>My code block is as follows:</p>

<pre><code>public class APIService {
    static let baseURL = URL(string: ""https://api.recommendations.samba.tv"")!
    var apiKey: String

    var logger = Logger(label: ""com.samba.tv.recommendations"")

    private var subscriptions = Set&lt;AnyCancellable&gt;()

    private let jsonDecoder: JSONDecoder = {
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = ""yyyy-mm-dd""
        jsonDecoder.dateDecodingStrategy = .formatted(dateFormatter)
        return jsonDecoder
    }()


    /// Defines the type of API error returbed,
    /// An enumerating type to classify the types of errors that can occur. Returns an `Error`, such as `noResponse`. Specific errors with messages will return both an error message and code.
    enum APIError: Error, LocalizedError {
        case missingCredentials
        case urlError(URLError)
        case responseError(Int)
        case decodingError(DecodingError)
        case genericError

        var localizedDescription: String {
            switch self {
            case .missingCredentials:
                return ""Missing credentials""
            case .urlError(let error):
                return error.localizedDescription
            case .decodingError(let error):
                return error.localizedDescription
            case .responseError(let status):
                return ""Bad response code: \(status)""
            case .genericError:
                return ""An unknown error has been occured""
            }
        }
    }

    /// Obtain Endpoint complete with baseURL
    ///
    /// An enumeration type, with an in-line function. This method constructs the entire URL, using the `baseURL` variable declared prior.
    /// By passing the specific enum type, such as `.popular(param)`, along with a `Popular` parameter, which is optional.
    enum Endpoint {
        case popular(popularParam: Popular?)

        func path() -&gt; URLComponents {
            switch self {
            case let .popular(popularParam):
                var queryItems = [URLQueryItem]()
                let urlString = ""\(baseURL)/popularity""
                var components = URLComponents(url: URL(string: urlString)!, resolvingAgainstBaseURL: true)!

                if let countryCode = popularParam?.country {
                    queryItems.append(URLQueryItem(name: ""country_code"", value: countryCode.rawValue))
                }
                if let namespace = popularParam?.namespace {
                        queryItems.append(URLQueryItem(name: ""response_namespace"", value: namespace.rawValue))
                }
                if let contentType = popularParam?.contentType {
                            queryItems.append(URLQueryItem(name: ""content_type"", value: contentType.rawValue))
                }
                if let genres = popularParam?.genres {
                    let genreArrayString = genres.compactMap({String($0.rawValue)}).joined(separator: "","")
                                queryItems.append(URLQueryItem(name: ""genre_ids"", value: genreArrayString))
                }
                components.queryItems = queryItems
                return components
            }
        }
    }

    init(key: String) {
        apiKey = key
    }

    /// Generic `GET` function, facilitating calls by passing in an `Endpoint` along with any parameters.
    /// It returns a `Result&lt;T, APIError&gt;`.
    ///  The method also inserts the required header parameters, including `apiKey`, and will fail if it is not valid, or missing.
    func GET&lt;T: Codable&gt;(endpoint: Endpoint,
                         params: [String: String]?) -&gt; Future&lt;[T], APIError&gt; {

//        guard let apiKey = APIService.shared.apiKey else {
//            throw APIError.missingCredentials
//        }

        return Future&lt;[T], APIError&gt; { promise in


            var components = endpoint.path()
            var request = URLRequest(url: components.url!)
            request.addValue(""Bearer \(self.apiKey)"", forHTTPHeaderField: ""Authorization"")
            request.addValue(""application/json"", forHTTPHeaderField: ""accept"")

            if let params = params {
                for (_, value) in params.enumerated() {
                    components.queryItems?.append(URLQueryItem(name: value.key, value: value.value))
                }
            }

            request.httpMethod = ""GET""

            URLSession.shared.dataTaskPublisher(for: request)
            .tryMap{ data, response -&gt; Data in
                guard let httpResponse = response as? HTTPURLResponse, 200...299 ~= httpResponse.statusCode else {
                    throw APIError.responseError((response as? HTTPURLResponse)?.statusCode ?? 500)
                }
                return data
            }
            .decode(type: PaginatedResponse.self, decoder: self.jsonDecoder)
            .receive(on: RunLoop.main)
                .sink(receiveCompletion: { (completion) in
                    if case let .failure(error) = completion {
                        switch error {
                        case let urlError as URLError:
                            promise(.failure(.urlError(urlError)))
                        case let decodingError as DecodingError:
                            promise(.failure(.decodingError(decodingError)))
                        case let apiError as APIError:
                            promise(.failure(apiError))
                        default:
                            promise(.failure(.genericError))
                        }
                    }
                }, receiveValue: { promise(.success($0.results)) })
                .store(in: &amp;self.subscriptions)
            }

    }

}
</code></pre>

<p>The error appears in the last line, for <code>.store(in:....</code>. 
<a href=""https://i.stack.imgur.com/BGEkq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BGEkq.png"" alt=""enter image description here""></a></p>

<h2>Question</h2>

<p>How do I resolve the error? </p>

<h2>Additional referenced classes</h2>

<p><em>PaginatedResponse.swift</em></p>

<pre><code>import Foundation

struct PaginatedResponse&lt;T: Codable&gt;: Codable {
    let paginator: Paginator
    let results: [T]
}

</code></pre>

<p><em>ContentItem.swift</em></p>

<pre><code>struct ContentItem: Codable, Equatable {
    enum ContentID: Codable {
        case text(String)
        case number(Int)

        case empty
    }
    enum SeriesID: Codable {
        case text(String)
        case number(Int)

        case empty
    }

    enum CodingKeys: String, CodingKey {
        case contentID = ""content_id""
        case seriesID = ""series_id""
        case rank = ""rank""
        case score = ""score""
    }

    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        rank = try values.decode(Int.self, forKey: .rank)
        score = try values.decode(Float.self, forKey: .score)
        seriesID = try values.decode(SeriesID.self, forKey: .seriesID)
        contentID = try values.decode(ContentID.self, forKey: .contentID)
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(score, forKey: .score)
        try container.encode(rank, forKey: .rank)
        try container.encode(seriesID, forKey: .seriesID)
        try container.encode(contentID, forKey: .contentID)
    }


    let rank: Int
    let score: Float
    let seriesID: SeriesID
    let contentID: ContentID

}

extension ContentItem.SeriesID: Equatable, Hashable {

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .text(let text):
            try container.encode(text)
        case .number(let number):
            try container.encode(number)
        case .empty:
            break
        }
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.hashValue)
    }


    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let text = try? container.decode(String.self) {
            self = .text(text)
        } else if let number = try? container.decode(Int.self) {
            self = .number(number)
        } else {
            //assertionFailure(""Unknown id type"")
            self = .empty
        }
    }

}

extension ContentItem.ContentID: Equatable, Hashable {

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .text(let text):
            try container.encode(text)
        case .number(let number):
            try container.encode(number)
        case .empty:
            break
        }
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(self.hashValue)
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let text = try? container.decode(String.self) {
            self = .text(text)
        } else if let number = try? container.decode(Int.self) {
            self = .number(number)
        } else {
//            assertionFailure(""Unknown id type"")
            self = .empty
        }
    }

}
</code></pre>
","163845","","163845","","2019-12-10 00:25:05","2019-12-10 16:03:23","In Swift Combine Publisher, I am getting conform to 'RangeReplaceableCollection' error","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"59259921","1","59260001","","2019-12-10 03:47:41","","42","24883","<h1>Aim:</h1>

<p>I have a model which is an <code>ObservableObject</code>. It has a <code>Bool</code> property, I would like to use this <code>Bool</code> property to initialise a <code>@Binding</code> variable.</p>

<h1>Questions:</h1>

<ol>
<li>How to convert an <code>@ObservableObject</code> to a <code>@Binding</code> ?</li>
<li>Is creating a <code>@State</code> the only way to initialise a <code>@Binding</code> ?</li>
</ol>

<h1>Note:</h1>

<ul>
<li>I do understand I can make use of <code>@ObservedObject</code> / <code>@EnvironmentObject</code>, and I see it's usefulness, but I am not sure a simple button needs to have access to the entire model. </li>
<li>Or is my understanding incorrect ?</li>
</ul>

<h1>Code:</h1>

<pre><code>import SwiftUI
import Combine
import SwiftUI
import PlaygroundSupport

class Car : ObservableObject {

    @Published var isReadyForSale = true
}

struct SaleButton : View {

    @Binding var isOn : Bool

    var body: some View {

        Button(action: {

            self.isOn.toggle()
        }) {
            Text(isOn ? ""On"" : ""Off"")
        }
    }
}

let car = Car()

//How to convert an ObservableObject to a Binding
//Is creating an ObservedObject or EnvironmentObject the only way to handle a Observable Object ?

let button = SaleButton(isOn: car.isReadyForSale) //Throws a compilation error and rightly so, but how to pass it as a Binding variable ?

PlaygroundPage.current.setLiveView(button)
</code></pre>
","1046037","","","","","2022-08-23 13:01:14","Binding value from an ObservableObject","<swift><swiftui><combine>","4","0","8","","","CC BY-SA 4.0"
"59274296","1","59276234","","2019-12-10 19:43:38","","9","6924","<p>I am discovering Combine. I wrote methods that make HTTP requests in a ""combine"" way, for example:</p>

<pre class=""lang-swift prettyprint-override""><code>func testRawDataTaskPublisher(for url: URL) -&gt; AnyPublisher&lt;Data, Error&gt; {
    var request = URLRequest(url: url,
                             cachePolicy: .useProtocolCachePolicy,
                             timeoutInterval: 15)
    request.httpMethod = ""GET""

    return urlSession.dataTaskPublisher(for: request)
        .tryMap {
            return $0.data
        }
        .eraseToAnyPublisher()
}
</code></pre>

<p>I would like to call the method multiple times and do a task after all, for example:</p>

<pre class=""lang-swift prettyprint-override""><code>let myURLs: [URL] = ...

for url in myURLs {
    let cancellable = testRawDataTaskPublisher(for: url)
        .sink(receiveCompletion: { _ in }) { data in
            // save the data...
        }
}
</code></pre>

<p>The code above won't work because I have to store the cancellable in a variable that belongs to the class.
The first question is: is it a good idea to store many (for example 1000) cancellables in something like <code>Set&lt;AnyCancellable&gt;</code>??? Won't it cause memory leaks?</p>

<pre class=""lang-swift prettyprint-override""><code>var cancellables = Set&lt;AnyCancellable&gt;()

...

    let cancellable = ...

    cancellables.insert(cancellable) // ???
</code></pre>

<p>And the second question is: how to start a task when all the cancellables are finished? I was thinking about something like that</p>

<pre class=""lang-swift prettyprint-override""><code>class Test {
    var cancellables = Set&lt;AnyCancellable&gt;()

    func run() {
        // show a loader

        let cancellable = runDownloads()
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { _ in }) { _ in
                // hide the loader
            }

        cancellables.insert(cancellable)
    }

    func runDownloads() -&gt; AnyPublisher&lt;Bool, Error&gt; {
        let myURLs: [URL] = ...

        return Future&lt;Bool, Error&gt; { promise in
            let numberOfURLs = myURLS.count
            var numberOfFinishedTasks = 0

            for url in myURLs {
                let cancellable = testRawDataTaskPublisher(for: url)
                    .sink(receiveCompletion: { _ in }) { data in
                        // save the data...
                        numberOfFinishedTasks += 1

                        if numberOfFinishedTasks &gt;= numberOfURLs {
                            promise(.success(true))
                        }
                    }

                cancellables.insert(cancellable)
            }
        }.eraseToAnyPublisher()
    }

    func testRawDataTaskPublisher(for url: URL) -&gt; AnyPublisher&lt;Data, Error&gt; {
        ...
    }
}
</code></pre>

<p>Normally I would use <code>DispatchGroup</code>, start multiple HTTP tasks and consume the notification when the tasks are finished, but I am wondering how to write that in a modern way using Combine.</p>
","3278728","","1102215","","2019-12-11 03:43:43","2019-12-11 07:54:22","Apple Combine framework: How to execute multiple Publishers in parallel and wait for all of them to finish?","<swift><combine>","1","0","5","","","CC BY-SA 4.0"
"59279806","1","","","2019-12-11 06:14:34","","8","5540","<p>When trying to make a network request, I'm getting an error </p>

<pre><code>finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled""
</code></pre>

<p>If I use <code>URLSession.shared.dataTask</code> instead of <code>URLSession.shared.dataTaskPublisher</code> it will work on IOS 13.3. </p>

<p>Here is my code : </p>

<pre><code>return  URLSession.shared.dataTaskPublisher(for : request).map{ a in
    return a.data
}
.decode(type: MyResponse.self, decoder: JSONDecoder())
.receive(on: DispatchQueue.main)
.eraseToAnyPublisher()
</code></pre>

<p>This code worked on IOS 13.2.3.</p>
","6125859","","1033581","","2019-12-14 15:56:18","2020-06-16 17:05:22","URLSession.shared.dataTaskPublisher not working on IOS 13.3","<swift><swiftui><combine><ios13.3>","3","0","1","","","CC BY-SA 4.0"
"59286892","1","59335239","","2019-12-11 13:28:43","","3","123","<p>I've created a view for setting a time (minutes and seconds). It uses two wheel pickers bound to two state variables.</p>

<p>Now I'd like to use that view at different places in the app, but I don't like the interface with two seperate variables for the time. Instead, I'd like to have just one bound variable holding the time in seconds (so time = 185 would translate to 3 minutes and 5 seconds).</p>

<p>Is it possible to have some sort of ""adapter"" between bindings?</p>

<p>Here's the view:</p>

<pre><code>import SwiftUI

struct TimePicker: View {
    var minutes: Binding&lt;Int&gt;
    var seconds: Binding&lt;Int&gt;

    var body: some View {
        HStack() {
            Spacer()
            Picker(selection: minutes, label: EmptyView()) {
                ForEach((0...9), id: \.self) { ix in
                    Text(""\(ix)"").tag(ix)
                }
                }.pickerStyle(WheelPickerStyle()).frame(width: 50).clipped()
            Text(""Min."")
            Picker(selection: seconds, label: EmptyView()) {
                ForEach((0...59), id: \.self) { ix in
                    Text(""\(ix)"").tag(ix)
                }
                }.pickerStyle(WheelPickerStyle()).frame(width: 50).clipped()
            Text(""Sec."")
            Spacer()
        }
    }
}
</code></pre>
","10826194","","","","","2022-08-23 14:49:16","How to translate bindings in a view?","<binding><swiftui><combine>","1","3","1","","","CC BY-SA 4.0"
"59290481","1","","","2019-12-11 16:47:33","","0","235","<p>So, I'm trying to display photos in SwiftUI using photo_references provided by Google's Places API, but am having an issue I cant seem to solve.</p>

<p>From what I understand, one needs to create a URL using a photo reference and API key in order to access Google place photos. <a href=""https://developers.google.com/places/web-service/photos"" rel=""nofollow noreferrer"">Info here</a></p>

<p>I'm currently able to correctly request all the necessary information from google and create the correct URL to get specific photos. But when I try to display the returned image using the URL, my application wont show the image and instead shows my placeholder/backup option in case the google images don't load.</p>

<p>-</p>

<p>More code details are listed below:</p>

<p>I modeled my code after the tutorial <a href=""https://www.youtube.com/watch?v=1IlUBHvgY8Q"" rel=""nofollow noreferrer"">here</a></p>

<p>Example url i've created and passed in:
(excludes my api key for this question)</p>

<pre><code>https://maps.googleapis.com/maps/api/place/photo?maxwidth=200&amp;photoreference=CnRtAAAATLZNl354RwP_9UKbQ_5Psy40texXePv4oAlgP4qNEkdIrkyse7rPXYGd9D_Uj1rVsQdWT4oRz4QrYAJNpFX7rzqqMlZw2h2E2y5IKMUZ7ouD_SlcHxYq1yL4KbKUv3qtWgTK0A6QbGh87GB3sscrHRIQiG2RrmU_jF4tENr9wGS_YxoUSSDrYjWmrNfeEHSGSc3FyhNLlBU&amp;key=YOUR_API_KEY
</code></pre>

<p><strong>ImageViewWidget.view</strong> - Here is the View that handles requesting and displaying Google Place Photos:</p>

<pre><code>import SwiftUI
import Foundation
import Combine


class ImageLoader: ObservableObject {
    var didChange = PassthroughSubject&lt;Data, Never&gt;()

    var data = Data() {
        didSet {
            didChange.send(data)
        }
    }

    init(imageUrl: String) {
        // implementation
        guard let url = URL(string: imageUrl) else { return }
        URLSession.shared.dataTask(with: url) { (data, _, _) in
            guard let data = data else { return }

            DispatchQueue.main.async {
                self.data = data
                print(""imageLoader.data - "", data)
            }
        }.resume()
    }
}


struct ImageViewWidget: View {

    @ObservedObject var imageLoader: ImageLoader

    init(imageUrl: String) {
        imageLoader = ImageLoader(imageUrl: imageUrl)
        print(""imageUrl - "", imageUrl)
    }

    var body: some View {
        Image(uiImage: (imageLoader.data.count == 0) ? UIImage(named: ""turtlerock"")! : UIImage(data: imageLoader.data)!)
            .resizable()
            .frame(width: 55, height: 55)
            .cornerRadius(6)
    }
}
</code></pre>

<p><strong>MarkerInfoWindow.view</strong> - And here is the file/view in my application that calls <strong>ImageViewWidget.view</strong>:</p>

<pre><code>import SwiftUI
import UIKit


struct MarkerInfoWindow: View {


    var placedata: [String: Any]
    var placetypedata: [String]


    var body: some View {

        HStack {
            Text(""4"")
                    VStack(alignment: .leading) {
                        HStack {
//This is where i call ImageViewWidget vvv
                            ImageViewWidget(imageUrl: placedata[""photo_reference""] as! String)

                            VStack(alignment: .leading) {
                                HStack {
                                    Text(placedata[""name""] as! String)
                                        .font(.system(size: 16))
                                        .bold()
                                    Spacer()
                                    Text(""10am-10pm"")
                                    .font(.system(size: 12))
                                }
                                HStack {
                                    Text(""⭐ \(placedata[""rating""] as! String)"")
                                        .font(.system(size: 14))
                                        .foregroundColor(Color(UIColor.systemYellow))
                                    Text(""$ \(placedata[""price_level""]! as! String)"")
                                        .font(.system(size: 14))
                                        .foregroundColor(Color(UIColor.systemGreen))
                                }
                                HStack {
                                Text(placetypedata[0])
                                    .font(.system(size: 14))
                                }
                            }
                            Spacer()

                        }

                    }
                    Spacer()

                }


    }

}
</code></pre>

<p>I've verified the url im passing in is correct becsause when I paste it into my browser, the images appear properly. But when I run my app it keeps displaying the 'turtlerock' image defined at the bottom of the <strong>MarkerInfoWindow.view</strong> file above instead of the one i'm requesting. So that being said,</p>

<p><strong>Does anyone know why my application isn't displaying the Google Place Photos I'm requesting, and displaying my fail safe option instead?</strong></p>

<p>EDIT: 
I think the 'turtlerock' image is showing up because my imageLoader.data is initially empty, but ImageViewWidget doesn't update to the proper image because it isn't picking up changes to imageLoader.data. I could be wrong but I hope someone who is more experienced finds this useful in helping find an answer to this</p>
","9473628","","11406138","","2019-12-18 05:21:50","2019-12-18 05:21:50","How do you display Google Place Photos using URL in SwiftUI?","<swift><uiimage><google-places-api><swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"59292764","1","59294149","","2019-12-11 19:29:23","","6","1486","<p>Here is my pipeline:</p>

<pre><code>URLSession.shared
      .dataTaskPublisher(for: urlRequest)
      .map { $0.data }
      .mapError { ...... }
      .eraseToAnyPublisher()
      .decode(type: MyObject.self, decoder: JSONDecoder())
      .receive(on: RunLoop.main)
      .catch { [weak self] error -&gt; Just&lt;MyObject&gt; in
        guard let self = self else { return Just(emptyPayload) }
        self.hasError = true
        return Just(emptyPayload)
    }
    .sink(
      receiveCompletion: { [weak self] _ in
        print(""i'm here"")
      },
      receiveValue: { [weak self] value in
        print(""value"")
      }
    )
</code></pre>

<p>Why is sink never called?</p>
","1366265","","1102215","","2019-12-11 21:13:18","2019-12-12 02:14:01","Why is sink never called in my combine pipeline?","<swift><nsurlsession><combine>","1","2","","2019-12-11 21:16:48","","CC BY-SA 4.0"
"59299410","1","","","2019-12-12 07:10:41","","5","3453","<p>After scouring Apple's SwiftUI docs, the web and stackoverflow, I can't seem to figure out how to use multiple classes and passing EnviromentObject data between them. All the articles on SwiftUI's EnvironmentObject, ObservableObjects, Bindings show how to pass data from a model to a view, but how about from one model to another. Or am I thinking about this the wrong way altogether.</p>

<p>How can I pass a @Published var from Class A to Class B? </p>

<p>In this simple SwiftUI example app I am trying to pass @Published data from a Settings class to a NetworkManager class. This app has a single ContentView with two form fields for username and password with a button that when pressed will contact an API and display the results.</p>

<p>The below code will crash because the NetworkManager mockService function does not know what ""settings"" is. I can read the ""Settings"" observed EnvironmentObject in a View, but how do I get that data in another class? I am guessing there is something to do with Bindings here, but not sure what to do.</p>

<p><strong>SceneDelegate:</strong></p>

<pre><code>...
var settings = Settings()
var networkManager = NetworkManager()

...
let contentView = ContentView()
    .environmentObject(settings)
    .environmentObject(networkManager)
...
</code></pre>

<p><strong>ContentView.swift</strong></p>

<pre><code>class Settings: ObservableObject {
    @Published var username: String = """"
    @Published var password: String = """"    
}

// This function in reality will be rewritten and expanded with multiple networking calls
class NetworkManager: ObservableObject {
    @Published var token: String = """"

    func mockService() {
        token = settings.username + settings.password
    }
}

struct ContentView: View {
    @EnvironmentObject var settings: Settings
    @EnvironmentObject var networkManager: NetworkManager
    var body: some View {
        VStack {
            TextField(""Username"", text: $settings.username)
            TextField(""Password"", text: $settings.password)
            Button(""Update""){
                self.networkManager.mockService()
            }
            Divider()
            Text(""\(networkManager.token)"")

        }
    }
}
</code></pre>
","457478","","","","","2022-03-18 12:24:53","SwiftUI passing data between multiple classes","<binding><swiftui><combine><swiftui-environment>","2","5","1","","","CC BY-SA 4.0"
"59303651","1","59308544","","2019-12-12 11:32:53","","-2","662","<p>I would like to verify if some <code>CurrentValueSubject</code> has any subscriptions added. Is there any way to verify this?</p>
","4528716","","","","","2019-12-13 09:50:55","Combine - test if CurrentValueSubject has any subscribers","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"59330610","1","59330861","","2019-12-13 22:33:06","","2","214","<p>In the iOS 13 Combine framework, there are three <code>collect</code> operator methods. The first two are obvious but the third uses types I can't figure out.</p>

<pre><code> collect(_:options:)
</code></pre>

<p><a href=""https://developer.apple.com/documentation/foundation/timer/timerpublisher/3329497-collect"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/foundation/timer/timerpublisher/3329497-collect</a></p>

<pre><code>func collect&lt;S&gt;(_ strategy: Publishers.TimeGroupingStrategy&lt;S&gt;, 
    options: S.SchedulerOptions? = nil) 
    -&gt; Publishers.CollectByTime&lt;Timer.TimerPublisher, S&gt; 
    where S : Scheduler
</code></pre>

<p>Can anyone give an example of how one would call this method?</p>
","341994","","","","","2019-12-18 00:06:27","Combine framework third `collect` method","<ios><ios13><combine>","2","0","","","","CC BY-SA 4.0"
"59335797","1","59337643","","2019-12-14 13:58:33","","3","1970","<p>I've seen several posts about this, but so far none of the solutions seem to be working for me.</p>

<p>I'm trying to create an array of Identifiable items using ForEach -- with both a <code>Text()</code> and <code>Toggle()</code> view inside. The array is stored in a <code>@Published</code> property of an <code>@ObservableObject</code>.</p>

<p>I'm currently looping through the indices to create the toggle bindings (as suggested in <a href=""https://stackoverflow.com/questions/57631225/using-foreach-loop-with-binding-causes-index-out-of-range-when-array-shrinks-sw"">other posts</a>). </p>

<p>Everything appears to be working, until I try to delete a row. </p>

<p>(Specifically the last row - which triggers a ""Fatal error: Index out of range"" every time.)</p>

<p>Any help would be greatly appreciated!</p>

<pre class=""lang-swift prettyprint-override""><code>struct Rule: Identifiable {
  let id: String
  var displayName: String
  var isEnabled: Bool
}

class UserData: ObservableObject {
  @Published var rules: [Rule] = []
}

struct RuleListView: View {
  @ObservableObject var userData: UserData

  var body: some View {
    List {
      ForEach(userData.rules.indices, id: \.self) { index in
        HStack {
          Toggle(
            isOn: self.$userData.rules[index].isEnabled
          ) { Text(""Enabled"") }
          Text(self.userData.rules[index].displayName)
        }
      }
      .onDelete(perform: delete)
    }
  }

  func delete(at offsets: IndexSet) {
    userData.rules.remove(atOffsets: offsets)
  }
}

</code></pre>
","10311552","","4546641","","2019-12-14 21:59:13","2020-05-17 06:44:33","SwiftUI: ForEach using Array/Index crashes when rows are deleted","<swift><swiftui><combine><swiftui-list>","1","1","","","","CC BY-SA 4.0"
"59342986","1","59355728","","2019-12-15 10:27:45","","3","1269","<p>Let's say that I've this simple chain that from an HTTP request creates a publisher for <code>&lt;T, APIManagerError&gt;</code></p>

<pre><code>   func run&lt;T:Decodable&gt;(request:URLRequest)-&gt;AnyPublisher&lt;T, APIManagerError&gt;{
        return URLSession.shared.dataTaskPublisher(for: request)
            .map{$0.data}
            .decode(type: T.self, decoder: JSONDecoder())
            .eraseToAnyPublisher()// it should run mapError before this point
    }
</code></pre>

<p>This code produces this error since I'm returning Error instead of <code>APIManagerError</code>.</p>

<pre><code>Cannot convert return expression of type 
'AnyPublisher&lt;T, Publishers.Decode&lt;Upstream, Output, Coder&gt;.Failure&gt;' 
(aka 'AnyPublisher&lt;T, Error&gt;') 
to return type 'AnyPublisher&lt;T, RestManagerError&gt;'
</code></pre>

<p>I know that to fix the issue I need to add a mapError after <code>.decode</code>.  </p>

<pre><code>.mapError{error in 
    APIManagerError.error(""Decode Fail"")
}
</code></pre>

<p>but I can't really understand what is reported with the error message before the ""aka"" part that is quite clear instead</p>

<p>How do you read the error <code>Publishers.Decode&lt;Upstream, Output, Coder&gt;.Failure</code>? specifically what does it mean the <code>.Failure</code> part? where can I find the <code>Failure</code> in the Swift Doc?  </p>
","499990","","","","","2019-12-16 21:12:01","Swift `Failure` keyword meaning in a Swift Combine chain error","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"59345963","1","59468331","","2019-12-15 16:45:18","","6","1542","<p>Let's say that: </p>

<p>• My application is a client of a Socket server. </p>

<p>• I'm free to write the Socket client implementation to fit with <code>Combine</code> as I prefer </p>

<p>I've implemented 2 solutions, one with <code>CurrentValueSubject</code> (quite easy) and a second with a custom subscription and a custom publisher that I'm not sure about. I really don't know which is the best way to bridge the code that I'm using to handle server messages with Combine. </p>

<p>Here is my code: </p>

<p>To simulate the socket server I've create a fake <code>SocketServerManager</code> that generates some events every <code>N</code> seconds: </p>

<pre><code>protocol SocketServerManagerDelegate{
    func newEvent(event:String)
}

class SocketServerManager {

    let timing: Double
    var timerHandler:Timer? = nil
    var delegates:[SocketServerManagerDelegate] = []

    init(timing:Double){
        self.timing = timing
    }

    func start(){
        // Just start a timer that calls generateEvent to simulate some events
        timerHandler = Timer.scheduledTimer(withTimeInterval: timing, repeats: true){
            [weak self] _ in
            self?.generateEvent()
        }
        timerHandler?.fire()
    }


    private func generateEvent(){
        let events = [""New Player"", ""Player Disconnected"", ""Server Error""]
        let currentEvent = events.randomElement

        for delegate in delegates{
           delegate.newEvent(event: currentEvent)
        }
    }            
}
</code></pre>

<h2>Custom Publisher and Subscription</h2>

<p>My custom subscription keeps  a reference to an instance of the server manager and to the subscriber. 
Also, it implements a <code>SocketServerManager</code> delegate. So that when the server has a new event it calls the subscription that can now send the <code>receive</code> event on the subscriber <strong>(This is the choice where I have A LOT OF doubts...)</strong></p>

<pre><code>class EventSubscription&lt;S:Subscriber&gt;:Subscription, SocketServerManagerDelegate 
    where S.Input == String{

    private var subscriber:S?
    private unowned var server:SocketServerManager

    init(sub:S, server:EventsServer){
        self.subscriber = sub
        self.server = server
    }

    func request(_ demand: Subscribers.Demand) {}

    func cancel() {
        subscriber = nil
    }

    // HERE IS WHERE I SEND THE EVENT TO THE SUBSCRIBER since this subscription 
    is a delegate of the server manager 
    func newEvent(event: Event) {
        _ = subscriber?.receive(event) 
    }
}
</code></pre>

<p>The publisher has nothing special...it will just create the subscription with the <code>receive</code> function. Also it appends the subscription to the list of delegates registered on the server so that the <code>generatesEvents</code> function can broadcast the event through the delegates (hence, through the subscriptions).</p>

<pre><code>// PUBLISHER CODE ----------
func receive&lt;S&gt;(subscriber: S)
    where S:Subscriber,
    EventsPublisher.Failure == S.Failure,
    EventsPublisher.Output == S.Input {

        let subscription = EventSubscription(sub:subscriber, server: self.server)
        server.delegates.append(subscription)
        subscriber.receive(subscription: subscription)
}
</code></pre>

<p>What do you think about this implementation? to me it seems quite clunky, but I really don't know how to bridge the events from the Server Manager to Subscribers. </p>
","499990","","","","","2022-08-23 14:49:28","Swift Combine Subscriptions, right flow and architectural choices","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"59360660","1","","","2019-12-16 16:31:39","","0","831","<p>just trying to implement SwiftUI and Combine in my new project.
But stuck in this:</p>

<pre><code>    func task() -&gt; AnyPublisher&lt;Int, Error&gt; {

        return AnyPublisher { subscriber in

            subscriber.receive(Int(arc4random()))
            subscriber.receive(completion: .finished)
        }
    }
</code></pre>

<p>This produces the following compiler error:</p>

<p><em>Type '(_) -> ()' does not conform to protocol 'Publisher'</em></p>

<p>Why? </p>

<p><strong>Update</strong></p>

<p>Actually <code>Random</code> here is just as an example. The real code will look like this:</p>

<pre><code> func task() -&gt; AnyPublisher&lt;SomeCodableModel, Error&gt; {

    return AnyPublisher { subscriber in

        BackendCall.MakeApiCallWithCompletionHandler { response, error in 

           if let error == error {

               subscriber.receive(.failure(error))
           } else {

               subscriber.receive(.success(response.data.filter))
               subscriber.receive(.finished)
           }
       }
    }
}
</code></pre>

<p>Unfortunately, I don't have access to BackendCall API since it is private.
It's kind of pseudocode but, it pretty close to the real one. </p>
","3092968","","3092968","","2019-12-16 18:27:37","2019-12-18 00:28:49","Why this produces compiler error in Combine?","<ios><swift><combine><publisher>","3","0","","","","CC BY-SA 4.0"
"59365370","1","59417496","","2019-12-16 22:53:49","","0","626","<p>I'm trying to flip the answer to this question on it's head:</p>

<p><a href=""https://stackoverflow.com/questions/58240070/whats-the-idiomatic-way-to-control-a-nested-uiview-in-swiftui"">What&#39;s the idiomatic way to control a nested UIView in SwiftUI</a></p>

<p>And publish the events from the child (<code>WebView</code>) and subscribe in the <code>ParentView</code>.</p>

<p>I can pass the eventSender in the constructor of the <code>WebView</code> like:</p>

<pre><code>WebView(eventSender: eventSender)
</code></pre>

<p>Then the <code>WebView</code> should be able to send events but how to I subscribe to the published events in the <code>ParentView</code>?</p>

<p>Does anyone have an elegant solution?</p>

<p>Ordinarily I would use <code>@EnvironmentObject</code> but these do not seem to work with <code>UIViewRepresentable</code>.</p>

<p>UPDATE - I've created a gist here of the issue: <a href=""https://gist.github.com/mattlaver/45519a58de65a304b10acaee663b06a2"" rel=""nofollow noreferrer"">https://gist.github.com/mattlaver/45519a58de65a304b10acaee663b06a2</a></p>

<p>Note that my childView is a class, not a struct as it needs to inherit from NSObject to be able to use the navigationDelegate.</p>

<p>I want to close this view (navigate back to before it was shown when the navigationDelegate kicks in).</p>
","117859","","117859","","2019-12-18 21:40:53","2019-12-19 22:09:49","Publish a message from child to parent View","<swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"59367202","1","59386819","","2019-12-17 03:25:05","","13","6696","<p>Using the new Combine framework in iOS 13.</p>

<p>Suppose I have an upstream publisher sending values at a highly irregular rate - sometimes seconds or minutes may go by without any values, and then a stream of values may come through all at once. I'd like to create a custom publisher that subscribes to the upstream values, buffers them and emits them at a regular, known cadence when they come in, but publishes nothing if they've all been exhausted.</p>

<p><strong>For a concrete example:</strong></p>

<ul>
<li>t = 0 to 5000ms: no upstream values published</li>
<li>t = 5001ms: upstream publishes ""a""</li>
<li>t = 5002ms: upstream publishes ""b""</li>
<li>t = 5003ms: upstream publishes ""c""</li>
<li>t = 5004ms to 10000ms: no upstream values published</li>
<li>t = 10001ms: upstream publishes ""d""</li>
</ul>

<p><strong>My publisher subscribed to the upstream would produce values every 1 second:</strong></p>

<ul>
<li>t = 0 to 5000ms: no values published</li>
<li>t = 5001ms: publishes ""a""</li>
<li>t = 6001ms: publishes ""b""</li>
<li>t = 7001ms: publishes ""c""</li>
<li>t = 7001ms to 10001ms: no values published</li>
<li>t = 10001ms: publishes ""d""</li>
</ul>

<p>None of the existing publishers or operators in Combine seem to <em>quite</em> do what I want here. </p>

<ul>
<li><a href=""https://developer.apple.com/documentation/combine/publisher/3204760-throttle"" rel=""noreferrer""><code>throttle</code></a> and <a href=""https://developer.apple.com/documentation/combine/publisher/3204702-debounce"" rel=""noreferrer""><code>debounce</code></a> would simply sample the upstream values at a certain cadence and drop ones that are missing (e.g. would only publish ""a"" if the cadence was 1000ms)</li>
<li><a href=""https://developer.apple.com/documentation/combine/publisher/3204704-delay"" rel=""noreferrer""><code>delay</code></a> would add the same delay to every value, but not space them out (e.g. if my delay was 1000ms, it would publish ""a"" at 6001ms, ""b"" at 6002ms, ""c"" at 6003ms)</li>
<li><a href=""https://developer.apple.com/documentation/combine/publisher/3235802-buffer"" rel=""noreferrer""><code>buffer</code></a> seems promising, but I can't quite figure out how to use it - how to force it to publish a value from the buffer on demand. When I hooked up a sink to <code>buffer</code> it seemed to just instantly publish all the values, not buffering at all.</li>
</ul>

<p>I thought about using some sort of combining operator like <code>zip</code> or <code>merge</code> or <code>combineLatest</code> and combining it with a Timer publisher, and that's probably the right approach, but I can't figure out exactly how to configure it to give the behavior I want.</p>

<p><strong>Edit</strong></p>

<p>Here's a marble diagram that hopefully illustrates what I'm going for:</p>

<pre><code>Upstream Publisher:
-A-B-C-------------------D-E-F--------|&gt;

My Custom Operator:
-A----B----C-------------D----E----F--|&gt;
</code></pre>

<p><strong>Edit 2: Unit Test</strong></p>

<p>Here's a unit test that should pass if <code>modulatedPublisher</code> (my desired buffered publisher) works as desired. It's not perfect, but it stores events (including the time received) as they're received and then compares the time intervals between events, ensuring they are no smaller than the desired interval.</p>

<pre><code>func testCustomPublisher() {
    let expectation = XCTestExpectation(description: ""async"")
    var events = [Event]()

    let passthroughSubject = PassthroughSubject&lt;Int, Never&gt;()
    let cancellable = passthroughSubject
        .modulatedPublisher(interval: 1.0)
        .sink { value in
            events.append(Event(value: value, date: Date()))
            print(""value received: \(value) at \(self.dateFormatter.string(from:Date()))"")
        }

    // WHEN I send 3 events, wait 6 seconds, and send 3 more events
    passthroughSubject.send(1)
    passthroughSubject.send(2)
    passthroughSubject.send(3)

    DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(6000)) {
        passthroughSubject.send(4)
        passthroughSubject.send(5)
        passthroughSubject.send(6)

        DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(4000)) {

            // THEN I expect the stored events to be no closer together in time than the interval of 1.0s
            for i in 1 ..&lt; events.count {
                let interval = events[i].date.timeIntervalSince(events[i-1].date)
                print(""Interval: \(interval)"")

                // There's some small error in the interval but it should be about 1 second since I'm using a 1s modulated publisher.
                XCTAssertTrue(interval &gt; 0.99)
            }
            expectation.fulfill()
        }
    }

    wait(for: [expectation], timeout: 15)
}
</code></pre>

<p>The closest I've gotten is using <code>zip</code>, like so:</p>

<pre><code>public extension Publisher where Self.Failure == Never {
    func modulatedPublisher(interval: TimeInterval) -&gt; AnyPublisher&lt;Output, Never&gt; {
        let timerBuffer = Timer
        .publish(every: interval, on: .main, in: .common)
        .autoconnect()

      return timerBuffer
        .zip(self, { $1 })                  // should emit one input element ($1) every timer tick
        .eraseToAnyPublisher()
    }
}
</code></pre>

<p>This properly attunes the first three events (1, 2, and 3), but not the second three (4, 5, and 6). The output:</p>

<pre><code>value received: 1 at 3:54:07.0007
value received: 2 at 3:54:08.0008
value received: 3 at 3:54:09.0009
value received: 4 at 3:54:12.0012
value received: 5 at 3:54:12.0012
value received: 6 at 3:54:12.0012
</code></pre>

<p>I believe this is happening because <code>zip</code> has some internal buffering capacity. The first three upstream events are buffered and emitted on the Timer's cadence, but during the 6 second wait, the Timer's events are buffered - and when the second set ups upstream events are fired, there are already Timer events waiting in the queue, so they're paired up and fired off immediately.</p>
","1722048","","1722048","","2019-12-17 21:12:00","2020-07-20 21:02:21","Swift Combine: Buffer upstream values and emit them at a steady rate?","<ios><swift><combine>","4","5","8","","","CC BY-SA 4.0"
"59393618","1","59403832","","2019-12-18 13:58:25","","3","6047","<p>How can I, using SwiftUI and Combine, have a state of the uppermost View depend on a state of its contained SubView, determined by criteria among others dependent on <em>its</em> contained SubSubView?</p>

<hr>

<h2>The scenario</h2>

<p>I have the following View hierarchy: V1 contains V2, which contains V3.</p>

<ol>
<li><p>V1 is a general, mostly decorative, 'wrapper' of a specific settings view V2 and holds a ""Save"" button. The button's disabled state of type <code>Bool</code> should depend on the save-ability state of V2.</p></li>
<li><p>V2 is a specific settings view. <em>Which</em> type of V2, the specific settings shown, may differ depending on the rest of my program. It is guaranteed to be able to determine its save-ability. It contains a Toggle and V3, a MusicPicker. V2's save-ability is dependent on criteria processing V3's selection-state and its Toggle-state.</p></li>
<li><p>V3 is a general 'MusicPicker' view with a selection-state of type <code>Int?</code>. It could be used with any parent, communicating bidirectionally its selection-state.</p></li>
</ol>

<p>A <code>Binding</code> should normally be used to communicate back and forth between 2 views. As such, there could be a binding between V1 and V2 and V2 and V3. However, V2 cannot/should not react to a binding's value change of V3 and communicate this (along with other criteria) back to V1, as far as I know/understand. I may use <code>ObservableObject</code>s to share a save-ability with V1 and V2 and to share a selection-state with V2 and V3, but it is unclear to me how to integrate V3's ObservableObject changes with other criteria to set V1's ObservableObject.</p>

<h2>The examples</h2>

<h3>Using <code>@State</code> and <code>@Binding</code></h3>

<pre><code>/* V1 */
struct SettingsView: View {
    @State var saveable = false

    var body: some View {
        VStack {
            Button(action: saveAction){
                Text(""Save"")
            }.disabled(!saveable)
            getSpecificV2(saveable: $saveable)
        }
    }

    func getSpecificV2(saveable: Binding&lt;Bool&gt;) -&gt; AnyView {
        // [Determining logic...]
        return AnyView(SpecificSettingsView(saveable: saveable))
    }

    func saveAction(){
        // More code...
    }
}

/* V2 */
struct SpecificSettingsView: View {
    @Binding var saveable: Bool

    @State var toggled = false
    @State var selectedValue: Int?

    var body: some View {
        Form {
            Toggle(""Toggle me"", isOn: $toggled)
            CustomPicker(selected: $selectedValue)
        }
    }

    func someCriteriaProcess() -&gt; Bool {
        if let selected = selectedValue {
            return (selected == 5)
        } else {
            return toggled
        }
    }
}

/* V3 */
struct CustomPicker: View {
    @Binding var selected: Int?

    var body: some View {
        List {
            Text(""None"")
                .onTapGesture {
                    self.selected = nil
            }.foregroundColor(selected == nil ? .blue : .primary)
            Text(""One"")
                .onTapGesture {
                    self.selected = 1
            }.foregroundColor(selected == 1 ? .blue : .primary)
            Text(""Two"")
                .onTapGesture {
                    self.selected = 2
            }.foregroundColor(selected == 2 ? .blue : .primary)
        }
    }
}
</code></pre>

<p>In this example code, I would need to essentially have <code>saveable</code> be dependent on <code>someCriteriaProcess()</code>.</p>

<h3>Using <code>ObservableObject</code></h3>

<p>In response to Tobias' answer, a possible alternative would be to use <code>ObservableObject</code>s.</p>

<pre><code>/* V1 */
class SettingsStore: ObservableObject {
  @Published var saveable = false
}

struct SettingsView: View {
    @ObservedObject var store = SettingsStore()

    var body: some View {
        VStack {
            Button(action: saveAction){
                Text(""Save"")
            }.disabled(!store.saveable)
            getSpecificV2()
        }.environmentObject(store)
    }

    func getSpecificV2() -&gt; AnyView {
        // [Determining logic...]
        return AnyView(SpecificSettingsView())
    }

    func saveAction(){
        // More code...
    }
}

/* V2 */
struct SpecificSettingsView: View {
    @EnvironmentObject var settingsStore: SettingsStore
    @ObservedObject var pickerStore = PickerStore()

    @State var toggled = false
    @State var selectedValue: Int?

    var body: some View {
        Form {
            Toggle(""Toggle me"", isOn: $toggled)
            CustomPicker(store: pickerStore)
        }.onReceive(pickerStore.objectWillChange){ selected in
            print(""Called for selected: \(selected ?? -1)"")
            self.settingsStore.saveable = self.someCriteriaProcess()
        }
    }

    func someCriteriaProcess() -&gt; Bool {
        if let selected = selectedValue {
            return (selected == 5)
        } else {
            return toggled
        }
    }
}

/* V3 */

class PickerStore: ObservableObject {
    public let objectWillChange = PassthroughSubject&lt;Int?, Never&gt;()
    var selected: Int? {
        willSet {
            objectWillChange.send(newValue)
        }
    }
}

struct CustomPicker: View {
    @ObservedObject var store: PickerStore

    var body: some View {
        List {
            Text(""None"")
                .onTapGesture {
                    self.store.selected = nil
            }.foregroundColor(store.selected == nil ? .blue : .primary)
            Text(""One"")
                .onTapGesture {
                    self.store.selected = 1
            }.foregroundColor(store.selected == 1 ? .blue : .primary)
            Text(""Two"")
                .onTapGesture {
                    self.store.selected = 2
            }.foregroundColor(store.selected == 2 ? .blue : .primary)
        }
    }
}
</code></pre>

<p>Using the <code>onReceive()</code> attachment, I try to react to any changes of the <code>PickerStore</code>. Although the action fires and the debug prints correctly, no UI change is shown.</p>

<hr>

<h2>The question</h2>

<p>What is (in this scenario) the most appropriate approach to react to a change in V3, process this with other states in V2, and correspondingly change a state of V1, using SwiftUI and Combine?</p>
","2204668","","2204668","","2019-12-18 17:53:50","2019-12-19 05:40:49","How to use SwiftUI and Combine to propagate state changes of child View to parent View?","<swift><swiftui><combine>","3","0","3","","","CC BY-SA 4.0"
"59406924","1","","","2019-12-19 09:40:16","","1","472","<p>I have a SwiftUI View where I declare a condition like this</p>

<pre><code>@State var condition = UserDefaults.standard.bool(forKey: ""JustKey"")
</code></pre>

<p>When I first push this view into the navigation stack condition variable is getting the correct value. Then when I pop this View I change the value in UserDefaults but when I push this screen again condition variable remembers the old value which it got first time. 
How to find a workaround for this because I want to reinitialize my condition variable each time I enter my custom view where I declared it?</p>
","5903004","","","","","2019-12-19 17:20:06","SwiftUI @State variables not getting deinitialized","<ios><swift><xcode><swiftui><combine>","1","3","1","","","CC BY-SA 4.0"
"59415161","1","59415264","","2019-12-19 18:30:23","","0","130","<p>For context, I am using swift &amp; MVVM architecture to manage a list of data, and a table view that displays it. Reactive patterns (RxSwift or Combine) work well for letting me reload my entire table view when the view model's list data changes. </p>

<p>ViewModel (using RxSwift):</p>

<pre><code>var tableData = BehaviorRelay&lt;[String]&gt;(value: [""First Item"", ""Second Item""])
</code></pre>

<p>ViewController:</p>

<pre><code>var tableView = UITableView()
var disposeBag = DisposeBag()
var viewModel = ViewModel()

init() {
    ...
    viewModel.tableData.subscribe(onNext: { _ in 
       self.tableView.reloadData()
    }).disposed(by: disposeBag)
}
</code></pre>

<p>But what if only one item has been inserted or deleted from <code>tableData</code>? In this case, I don't want to call <code>tableView.reloadData()</code>, instead I'd like to use <code>tableView.insertRows(at: &lt;[IndexPath]&gt;, with: &lt;UITableView.RowAnimation&gt;)</code> or <code>tableView.deleteRows(at: &lt;[IndexPath]&gt;, with: &lt;UITableView.RowAnimation&gt;)</code>. In order to do this, I need to be able to subscribe to the index paths that have been inserted or removed, instead of the list data as a whole. Does any one know what the most efficient way to do this? </p>
","3707524","","","","","2019-12-19 18:39:32","How to use reactive programming to subscribe to single-item changes (insertions or deletions) in an array of data?","<ios><swift><reactive-programming><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"59424243","1","","","2019-12-20 11:06:54","","0","116","<p>I put <code>Store1:ObservableObject</code> into <code>GlobalStore2:ObservableObject</code> and use <code>field1</code> and <code>field2</code> in <code>MultiStoresDemo2:View</code>.
I type <code>A</code> character in <code>field1</code>, <code>field2</code> doesn't redraw in <code>View</code>.
I type <code>B</code> character in <code>field1</code>, <code>field2</code> shows <code>A</code> character only.</p>

<p>Is this SwiftUI bug?</p>

<p>I wrote a little code to demo how to reproduce it.</p>

<pre><code>final class GlobalStore2: ObservableObject {
    static let shared = GlobalStore2()

    @Published var store1 = Store1()
}

final class Store1: ObservableObject {
    static let shared = Store1()
    @Published var field1 = """" {
        didSet {
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                self.field2 = self.field1
            }
        }
    }
    @Published var field2 = """"
}

struct MultiStoresDemo2: View {
    @ObservedObject var store = GlobalStore2.shared

    var body: some View {
        VStack {
            TextField(""field1"", text: $store.store1.field1)
            Text(""field2 \(store.store1.field2)"")
        }
    }
}
</code></pre>

<p>If I change my code like below it will work</p>

<pre class=""lang-swift prettyprint-override""><code>struct MultiStoresDemo2: View {
    @ObservedObject var store1 = Store1.shared
...
            Text(""field2 \(Store1.shared.field2)"")
            Text(""field2 \(store1.field2)"")
...
}
</code></pre>
","4067700","","4067700","","2019-12-20 14:38:27","2019-12-20 14:38:27","@Published var in a nested ObservableObject changed only after second change. SwiftUI bug?","<swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"59424354","1","","","2019-12-20 11:13:43","","3","2384","<p>I'd like to implement a navigator/router for an architecture implemented with SwiftUI and Combine. In a few words the <code>View</code> will share <code>viewModel</code> with <code>Router</code>. When the <code>View</code> triggers a change on the <code>viewModel</code> the <code>Router</code> should navigate to a new sheet. </p>

<p>This is a version of my code where I'm directly passing the <code>viewModel</code> from <code>View</code> to <code>Router</code>. Is there anything wrong? My biggest doubt is that since I'm using <code>@ObservedObject</code> on both the <code>Router</code> and the <code>View</code>, two different instances of the <code>viewModel</code> are created. </p>

<h1>VIEW MODEL</h1>

<pre><code>class BootViewModel:ObservableObject{
    @Published var presentSignIn = false
}
</code></pre>

<h1>VIEW</h1>

<pre><code>struct BootView: View {

    @ObservedObject var viewModel:BootViewModel
    var navigator:BootNavigator&lt;BootView&gt;? = nil

    init(viewModel:BootViewModel) {
        self.viewModel = viewModel
        self.navigator = BootNavigator(view: self, viewModel: viewModel)
        self.navigator.setSubscriptions()
    }

    var body: some View {
        VStack{
            Text(""Hello"")
            Button(""Button""){
                self.viewModel.presentSignIn.toggle()
            }
        }
    }
}
</code></pre>

<h1>NAVIGATOR</h1>

<pre><code>class BootNavigator&lt;T:View&gt;{
    var view:T? = nil
    @ObservedObject var viewModel:BootViewModel

    init(view:T, viewModel:BootViewModel) {
        self.view = view
        self.viewModel = viewModel
    }

    func setSubscriptions(){
        subscribe(onSigninPressed: $viewModel.presentSignIn)
    }


    func subscribe(onSigninPressed : Binding&lt;Bool&gt;){
        _ = view.sheet(isPresented: $viewModel.presentSignIn){
            SignInView()
        }
    }
}
</code></pre>

<ul>
<li>Why the <code>SignInView</code> is never presented?  </li>
<li>Without taking into account the fact that using a router with swiftUI is not needed in general(I'm mostly doing an exercise)... is there anything wrong with this implementation?</li>
</ul>
","499990","","499990","","2019-12-20 16:10:36","2019-12-20 16:10:36","Sharing ViewModel between SwiftUI components","<swift><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"59424964","1","","","2019-12-20 12:02:26","","1","672","<p>I'm working with Swift Combine and do not get the difference between</p>

<pre><code>func subscribe&lt;S&gt;(_ subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input
</code></pre>

<p>and</p>

<pre><code>func subscribe&lt;S&gt;(_ subject: S) -&gt; AnyCancellable where S : Subject, Self.Failure == S.Failure, Self.Output == S.Output
</code></pre>

<p>Why does one return an <code>AnyCancellable</code> wheras the other <code>Void</code>?</p>

<p>I have a custom <code>Subscriber</code> so is it totally safe for me to use</p>

<pre><code>myPublisher.subscribe(myCustomSubscriber)
</code></pre>

<p>without having to deal with an <code>AnyCancellable</code>?</p>
","27404","","13328195","","2020-09-04 09:37:09","2020-09-10 10:47:31","Why does subscribe(subject) return AnyCancellable but subscribe(subscriber) Void?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"59426092","1","","","2019-12-20 13:33:26","","6","838","<p>I am developing an app with SwiftUI and Combine using MVVM architecture targeting only iOS 13. I want to implement Data sync between devices and sharing using CloudKit framework. How can I Combine-ify the CloudKit framework to use in my project? Is there anything that can be done to CloudKit operations to use Combine ?</p>
","7680493","","","","","2021-06-20 01:15:54","Cloudkit with Combine","<ios><swift><swiftui><cloudkit><combine>","1","1","3","","","CC BY-SA 4.0"
"59428026","1","59430629","","2019-12-20 15:52:45","","17","9454","<p>I was using PromiseKit successfully in a project until Xcode 11 betas broke PK v7. In an effort to reduce external dependencies, I decided to scrap PromiseKit. The best replacement for handling chained async code seemed to be Futures using the new Combine framework.</p>
<p>I am struggling to replicate the simple PK syntax using Combine</p>
<p><strong>ex. simple PromiseKit chained async call syntax</strong></p>
<pre class=""lang-swift prettyprint-override""><code>getAccessCodeFromSyncProvider.then{accessCode in startSync(accessCode)}.then{popToRootViewController}.catch{handleError(error)}
</code></pre>
<blockquote>
<p>I understand:</p>
<blockquote>
<p>A Swift standard library implementation of async/await would solve this problem (<em>async/await does not yet exist, despite lots of chatter and involvement from <a href=""https://gist.github.com/lattner/429b9070918248274f25b714dcfc7619"" rel=""noreferrer"">Chris Latter himself</a></em>)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>I could replicate using Semaphores (<em>error-prone?</em>)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>flatMap can be used to chain Futures</p>
</blockquote>
</blockquote>
<p>The async code I'd like should be able to be called on demand, since it's involved with ensuring user is logged in. I'm wrestling with two conceptual problems.</p>
<ol>
<li><p>If I wrap Futures in a method, with <code>sink</code> to handle result, it seems that the method goes out of scope before subscriber is called by <code>sink</code>.</p>
</li>
<li><p>Since Futures execute only once, I worry that if I call the method multiple times I'll only get the old, stale, result from the first call. To work around this, maybe I would use a PassthroughSubject? This allows the Publisher to be called on demand.</p>
</li>
</ol>
<p>Questions:</p>
<ol>
<li>Do I have to retain every publisher and subscriber outside of the
calling method</li>
<li>How can I replicate simple chained async using the Swift standard library and then embed this in a swift instance method I can call on-demand to restart the chained async calls from the top??</li>
</ol>
<pre class=""lang-swift prettyprint-override""><code>//how is this done using Combine?
func startSync() {
 getAccessCodeFromSyncProvider.then{accessCode in startSync(accessCode)}.catch{\\handle error here}
}
</code></pre>
","4705368","","4705368","","2020-06-30 11:26:32","2021-05-02 18:10:01","How to replicate PromiseKit-style chained async flow using Combine + Swift","<swift><asynchronous><combine>","4","3","7","","","CC BY-SA 4.0"
"59442379","1","59516582","","2019-12-22 07:24:22","","0","89","<p>I am stuck with this issue and tried various ways but no luck. Below code used to work few days back. However, its not working now. I tried with the Xcode version 11.1 and works like charm. Can someone let me know what could be the reason or a workaround?</p>

<p>Issue is whenever I typed in a key, it does not fire the corresponding method using the dispatchqueue.</p>

<p>Current Swift version: 11.3</p>

<pre><code>Code snippet:

 init(
    weatherFetcher: WeatherFetchable,
    scheduler: DispatchQueue = DispatchQueue(label: ""WeatherViewModel"")
  ) {
    self.weatherFetcher = weatherFetcher
    _ = $city
      .dropFirst(1)
      .debounce(for: .seconds(0.5), scheduler: DispatchQueue.global())
      .sink(receiveValue: fetchWeather(forCity:))
  }
</code></pre>

<p>Reference code:
<a href=""https://www.raywenderlich.com/4161005-mvvm-with-combine-tutorial-for-ios"" rel=""nofollow noreferrer"">https://www.raywenderlich.com/4161005-mvvm-with-combine-tutorial-for-ios</a></p>
","1007451","","1007451","","2019-12-22 23:05:38","2019-12-29 03:08:01","Issue with the DispatchQueue not working in Swift","<ios><swift><xcode><combine>","1","0","","","","CC BY-SA 4.0"
"59446365","1","59505799","","2019-12-22 17:11:26","","0","163","<p>I'm quite new to <code>Combine</code> and, instead of running all my tasks into the <code>viewModel</code>, I'm trying to better isolate the code that has to do with business logic.  </p>

<p>Let's take a <code>SignIn</code> service as example. The service receives <code>username</code> and <code>password</code> and return <code>token</code> and <code>userID</code>. </p>

<p>The exposed call of the service is <code>signIn</code> that internally calls a private func <code>networkCall</code>. I'd like to implement the two functions to return a <code>Publisher</code>. 
The role of <code>networkCall</code> should be calling the API and storing the received token, while the role of <code>signIn</code> is only to return a success or a failure. </p>

<p>This is my code, where I'm also highlighting where I'm getting stuck.
In general I don't know where is the right place to work with the information received from the API (and store the token). At the moment I'm doing it inside a <code>.map</code> call but it sounds wrong to me. Could you share some advice to improve this logic and especially explain which is the right place to run the business logic... I'm supposing that <code>.map</code> is not the right place! and <code>.sink</code> will just stop the chain.</p>

<pre><code>struct SignInResponse:Codable{
    var token:String
    var userID:String
}

class SignInService {

    // Perform the API call
    private func networkCall(with request:SignInRequest)-&gt;AnyPublisher&lt;SignInResponse, ServiceError&gt;{
        return URLSession.DataTaskPublisher(request: request, session: .shared)
        .decode(type: SignInResponse.self, decoder: JSONDecoder())
        .mapError{error in return ServiceError.error}
        .eraseToAnyPublisher()
    }

    func signIn(username:String, password:String)-&gt;AnyPublisher&lt;Result&lt;String, ServiceError&gt;, Never&gt;{
        let request = SignInRequest(with username:username, password:password)

        return networkCall(with: request)
            .map{ (response) -&gt; Result&lt;String, ServiceError&gt; in

                if response.token != """"{
                    // THIS SOUNDS EXTREMELLY WRONG. I SHOULD NOT USE MAP TO HANDLE THE TOKEN -------
                    self.storage.save(key: ""token"", value: response.token)
                    return Result.success(response.userID)
                }else{
                    return Result.failure(ServiceError.unknown)
                }
            }
            .replaceError(with: Result.failure(ServiceError.unknown))
            .eraseToAnyPublisher()
    }
    ...... 
}
</code></pre>

<p>From the model I call SignIn in this way: </p>

<pre><code>func requestsSignIn(){

    if let username = username, let password = password{
        cancellable = service.signIn(username: username, password: password)
            .sink(receiveValue: { (result) in
                switch result{
                case .failure(let error):
                    self.errorMessage = error.localizedDescription
                case .success(let userID):
                    // the sigin succeeded do something here

                }
            })
    }
}
</code></pre>
","499990","","","","","2019-12-28 02:56:18","Consecutive Combine Publishers. Isolating business logic in a Simple Sign In flow example","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"59452113","1","59452575","","2019-12-23 08:24:45","","1","435","<p>I made a &quot;State&quot; Object for my App in EnvironmentObject
Like this:</p>
<pre><code>class AppState: ObservableObject {
    @Published var counter = Counter()
}
</code></pre>
<p>To add this to my App I use:</p>
<pre><code>window.rootViewController = UIHostingController(rootView: contentView.environmentObject(state))
</code></pre>
<p>The counter is a background task</p>
<pre><code>class Counter: ObservableObject {
    
    @Published var amount: Double
    
    var timer = Timer()
    
    init() {
        self.amount = 0.0
        self.timer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(setCoords), userInfo: nil, repeats: true)
    }
    
    @objc private func setCoords() {
        DispatchQueue.main.async() { () -&gt; Void in
            self.amount = self.amount + 0.1
            print(self.amount)
        }
    }  
}
</code></pre>
<p>And in my View I have:</p>
<pre><code>struct ContentView: View {

    @EnvironmentObject var state: AppState
    @State var isVisible = true
    
    var body: some View {
        VStack {
            Button(action: {
                self.isVisible.toggle()
            }) {
               Text(&quot;Button&quot;)
            }
            if isVisible {
                Text(state.counter.amount.description)
            }
        }
    }
}
</code></pre>
<p>So basically, what I was hoping was that I see the counter in my UI update after every second. But the UI does not update. I see the print statement fire every second and if I trigger the UI update from the UI Button <code>self.isVisible.toggle()</code> then the counter will also update.</p>
<p>How could I solve this problem without moving the counter into the View or implementing it in the state object?</p>
","4129110","","13302","","2021-07-11 12:54:55","2021-07-11 12:55:03","Publisher inside a Publisher does not trigger SwiftUi re-render","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59455385","1","59455515","","2019-12-23 12:27:21","","5","2179","<p>I'm using sink method to call function when variable value changed.
Code working on iOS 13.2.2 but not on iOS 13.3. Function segmentedChanged not called when segmentedSelected variable changed.</p>

<pre><code>public class ChooseViewModel: ObservableObject {

    @Published var segmentedSelected = Int()


    init() {
        _ = $segmentedSelected
                .debounce(for: .seconds(0.1), scheduler: DispatchQueue.main)
                .sink(receiveValue: self.segmentedChanged(indexValue:))

    }

    func segmentedChanged(indexValue segIndex: Int) {
      print(segIndex)
    }

}
</code></pre>
","9515003","","","","","2022-08-23 07:13:29",".sink method from Combine not working on iOS 13.3","<ios><xcode><swiftui><combine><ios13.3>","1","0","1","","","CC BY-SA 4.0"
"59456502","1","59458194","","2019-12-23 13:51:32","","0","812","<p>I can't understand why in this code, if I call <code>send</code> on the <code>subject</code> after the subject has been subscribed to <code>publisher</code>, it seems that the events are not received by the <code>subscriber</code>. </p>

<p>While if I move the <code>send</code> calls before the <code>subscribe</code> function all the items are listed (10,20,1,2,3) </p>

<pre><code>    let publisher = [1,2,3].publisher
    let subject = PassthroughSubject&lt;Int, Never&gt;()
    let subscriber = subject.sink { print(""value :\($0)"")}

    publisher.subscribe(subject)
    subject.send(10)
    subject.send(30)
</code></pre>

<p>This prints </p>

<pre><code>value: 1
value: 2
value: 3
</code></pre>

<p>while this:</p>

<pre><code>    let publisher = [1,2,3].publisher
    let subject = PassthroughSubject&lt;Int, Never&gt;()
    let subscriber = subject.sink { print(""value :\($0)"")}

    subject.send(10)
    subject.send(30)           
    publisher.subscribe(subject)
</code></pre>

<p>prints </p>

<pre><code>value: 10
value: 30
value: 1
value: 2
value: 3
</code></pre>
","499990","","","","","2019-12-23 16:06:13","Combine subscribe and send from subject, why does order matter?","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"59458550","1","","","2019-12-23 16:32:25","","-1","212","<p>Hello I'm currently having a problem with displaying images when they are fetched from url. So I currently fetch data from genius API and I get the information needed while also getting an image url, however when I set the data to a view then the app freeze for a few second and later it works fine.</p>

<p>I get my data by the following way:</p>

<pre><code>class NetworkManager: ObservableObject {
    var objectWillChange = PassthroughSubject&lt;NetworkManager, Never&gt;()
    var imageLoader = ImageLoader()

    var fetchedSongsResults = [SongCardViewModel]() {
        willSet {
            objectWillChange.send(self)
        }
    }

    func fetchSongs(userSearched callback: String) {
        guard let url = URL(string: ""https://api.genius.com/search?q=\(callback.replacingOccurrences(of: "" "", with: ""%20""))"") else { return }
        var urlRequest = URLRequest(url: url)
        urlRequest.setValue(""Bearer"", forHTTPHeaderField: ""Authorization"")

      URLSession.shared.dataTask(with: urlRequest) {data, response, error in
            guard let data = data else { return }
            let songs = try! JSONDecoder().decode(feed.self, from: data)
            self.imageLoader.fetchSongImages(urlStrings: songs.response.hits.map({ $0.result.imageUrl }))
            DispatchQueue.main.async {
                if self.imageLoader.dataIsValid == true {
                    for song in songs.response.hits {

                        self.fetchedSongsResults.append(SongCardViewModel(Id: song.result.id, ImageURL: self.imageLoader.fetchedImage[0], LyricsUrl: song.result.lyricsUrl, Title: song.result.title, Lyrics_State: song.result.lyrics_state, Primary_Artist: song.result.primary_artist))
                    }
                }
            }
        }.resume()
    }
}
</code></pre>

<p>So, network manager is like my main class and as you can see in the function fetchSongs I call another class which is imageLoader which also is an fetches the images and appends to the array fetched image, I have hard coded the 0 index don't mind that. Here is the following code for imageLoader </p>

<pre><code>class ImageLoader: ObservableObject {
    @Published var dataIsValid = false
    var fetchedImage = [Data]()

    func fetchSongImages(urlStrings: [String]) {
        for urlString in urlStrings {
            guard let url = URL(string: urlString) else { return }
            let task = URLSession.shared.dataTask(with: url) { data, response, error in
                guard let data = data else { return }
                DispatchQueue.main.async {
                    self.dataIsValid = true
                    self.fetchedImage.append(data)
                }
            }
            task.resume()
        }
    }
}
</code></pre>

<p>Just to be clear the data is displayed and however when I set the view and trigger the network manager with the callback I can see the data has been received but when I try to scroll down I can't until I wait a few seconds my theory is that the images are still being fetched from background and that is why the app freezes, I have tried to use the isDataValid boolean to determine also when the images are fetched but sadly it didn't work. </p>

<p>here is the code on how I show the data </p>

<pre><code>@ObservedObject var networkManager = NetworkManager()

    var body: some View {
           ScrollView {
                    ForEach(self.networkManager.fetchedSongsResults, id: \.title) { song in
                        VStack {
                            NavigationLink(destination: LyricView(url: song.lyricsUrl)) {
                                SongCardView(isSearching: self.isSearching, imageData: song.imageUrl, title: song.title, artist: song.primary_artist.name)

                            }
                        }
                    }
                }
</code></pre>

<p>Here is my custom SongCardView </p>

<pre><code>truct SongCardView: View {
    var isSearching: Bool
    var imageData: Data
    var title: String
    var artist: String

    var body: some View {
        ZStack(alignment: .topLeading) {
            CustomImageView(ImageData: imageData)
            HStack {
                Text(title)
                    .modifier(SongCardViewTextModifier())
                Text(""-"")
                    .modifier(SongCardViewTextModifier())
                Text(artist)
                    .modifier(SongCardViewTextModifier())

            }
            .frame(minWidth: 0, maxWidth: 240, minHeight: 0, maxHeight: 30)
            .background(Color.gray.opacity(0.8))
            .padding()
        }
    }
}
</code></pre>

<p>The thing that is most curious to me is that when I tried I remove self.isDataValid = true from dispatchQueue and have be outside of the for loop it didn't work instead my array fetched image became empty and I don't know why?. The main goal is that to stop make app freeze and my conclusion was that the images are the ones that makes things hard because they get fetched before the images. Thank you for helping</p>

<p>Here is SondCardViewModel: </p>

<pre><code>class SongCardViewModel: Identifiable {
    var id: Int
    var imageUrl: Data
    var lyricsUrl: String
    var title: String
    var lyrics_state: String
    var primary_artist: artist

    init(Id:Int, ImageURL:Data, LyricsUrl:String, Title:String, Lyrics_State:String, Primary_Artist: artist) {
        id = Id
        imageUrl = ImageURL
        lyricsUrl = LyricsUrl
        title = Title
        lyrics_state = Lyrics_State
        primary_artist = Primary_Artist

    }

}
</code></pre>

<p>Also here is CustomImageView</p>

<pre><code>import SwiftUI

func imageFromData(_ data:Data) -&gt; UIImage {
    UIImage(data: data) ?? UIImage()
}

struct CustomImageView: View {
    var imageData: Data
    init(ImageData data:Data) {
        imageData = data
    }

    var body: some View {
        // checking for our fetched is not nil if nil then we just use an empty UIImage
        // if we have fetched our image then we set as our image
        Image(uiImage: imageFromData(imageData))
           .renderingMode(.original) 
           .resizable()
           .cornerRadius(30)
           .frame(width: UIScreen.main.bounds.width/1.5, height: UIScreen.main.bounds.width/1.5)
    }
}
</code></pre>
","9912566","","9912566","","2019-12-23 19:32:33","2019-12-24 17:18:32","Fetching images and setting them makes the app freeze using Combine SwiftUI","<swift><swiftui><combine>","1","5","0","","","CC BY-SA 4.0"
"59461539","1","59475444","","2019-12-23 21:34:29","","4","2334","<p>I'm trying to handle the responses that arrive from a <code>DataTaskPublisher</code> reading its response status code. </p>

<p>When status code is greater than 299, I'd like to return a <code>ServiceError</code> type as Failure. In every examples that I've seen I've used <code>.mapError</code> and <code>.catch</code>... in this specific case, from a <code>.flatMap</code>, I really don't know how to handle the publisher response to return the Error instead of the <code>TResponse</code>...</p>

<pre><code>    return URLSession.DataTaskPublisher(request: urlRequest, session: .shared)
        .mapError{error in return ServiceError.request}
        .flatMap{ data, response -&gt; AnyPublisher&lt;TResponse, ServiceError&gt; in

            if let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode){

                return Just(data)
                    .decode(type: TResponse.self, decoder: JSONDecoder())
                    .mapError{error in return ServiceError.decode}
                    .eraseToAnyPublisher()
            }else{
                //???? HOW TO HANDLE THE ERROR?
            }
        }
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
</code></pre>
","499990","","","","","2021-09-24 20:25:59","handling HTTP status code with URLSession and Combine","<swift><urlsession><combine>","3","0","","","","CC BY-SA 4.0"
"59464845","1","59468903","","2019-12-24 06:41:41","","2","1877","<p>My View doesn't update when I change a property in an Array in the <code>ObservableObject</code> Class. I even declared a <code>objectWillChange</code> property and called it manually but the View just updated randomly or not how i want to. I don't understand this.</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import SocketIO
import Combine

class SocketService: ObservableObject {
    static let instance = SocketService()

    let manager = SocketManager(socketURL: URL(RequestURL.base_url)!)
    let socket: SocketIOClient
//    let objectWillChange = ObservableObjectPublisher()

    @Published var allMessages: [Message] = []
//        {
//        willSet {
//            self.objectWillChange.send()
//        }
//    }
    @Published var writtenUsers: [PreviewMessage] = []
//        {
//        willSet {
//            self.objectWillChange.send()
//        }
//    }

    init() {
        socket = manager.defaultSocket
        setSocketEvents()
    }

    // This method is called
    func recieve_read_all_messages() {
        socket.on(""recieve-read-all-messages"") { (data, ack) in
            guard let arr = data as? [[String: Any]] else { return }
            guard let userID = arr[0][""userID""] as? Int else {
                print(""no userID, \(#function), line: \(#line)""); return
            }

            // self.objectWillChange.send()
            for msg in self.allMessages {
                // Here im trying to change the property in the array
                msg.content.readStatus = .read
            }
    }    
}

</code></pre>

<p>Even when i directly change this property the view doesn't update</p>

<pre class=""lang-swift prettyprint-override""><code>@EnvironmentObject private var socketService: SocketService

var body: some View {
    VStack {
         List(filteredMessages, id: \.content.uuid, rowContent: chatSpeechBubbleView)
         sendView
    }
}

private func chatSpeechBubbleView(forMessage message: Message) -&gt; some View {
        ChatSpeechBubble(message: message)
    }

private var sendView: some View {
        Button(action: sendMessage) {
            SFSymbol(.paperplane_fill)
                .fontSize(20)
                .foregroundColor(.white)
                .rotate(.degrees(45))
                .padding(10)
                .padding(.trailing, 5)
                .backgroundColor(.blue)
                .clipCircle()
        }
        .padding(.bottom, 2)
    }

    func sendMessage() {
        for msg in socketService.allMessages {            
            msg.content.readStatus = .read
        }
    }
</code></pre>

<p>My other view where it should be updated:</p>

<pre class=""lang-swift prettyprint-override""><code>struct DoubleCheckmark: View {
    var messageContent: MessageContent

    var body: some View {
        HStack(spacing: 0) {
            SFSymbol(.checkmark)
                .resizable()
                .scaledToFit()
            SFSymbol(.checkmark)
                .resizable()
                .scaledToFit()
                .padding(.leading, -9)
        }
        .height(13)
        .foregroundColor(self.messageContent.readStatus == .read ? .blue : .gray)
    }
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>struct ChatSpeechBubble: View {

    // MARK: - init variables
    var message: Message

    // MARK: - normal variables
    var ownSendMessage: Bool {
        message.fromUser.id == UDService.shared.user.id
    }

    // MARK: - Body
    var body: some View {
        messageContent
    }

    private var messageContent: some View {
        HStack(alignment: .bottom) {
            if message.content.text != nil {
                Text(message.content.text!)
                    .foregroundColor(.black)
            }
            if message.content.imageURL != nil {
                Spacer(minLength: 0)
            }
            Text(message.content.timeHourMinute)
                .font(.caption)
                .foregroundColor(.gray)

            if ownSendMessage {
                DoubleCheckmark(messageContent: self.message.content)
            }
        }
    }
}
</code></pre>
","11411002","","11411002","","2019-12-24 08:23:59","2021-11-24 12:04:07","SwiftUI View doesn't update","<ios><swift><swiftui><swift5><combine>","1","0","","","","CC BY-SA 4.0"
"59468389","1","59473283","","2019-12-24 11:50:07","","1","206","<p>I'm trying to validate user's email and password using two separate function calls. </p>

<p>Both functions return AnyPublisher publishers, and I use combineLatest to collect the returned values (each validate call returns the string it's validating) into a tuple.</p>

<p>Then I'm using flatMap to make a network request to sign the user up using the values returned by combineLatest, however the flatMap operator never gets called. </p>

<pre><code>validator.validate(text: email, with: [.validEmail])
  .combineLatest(validator.validate(text: password, with: [.notEmpty]))
  .flatMap { credentials in
    return self.userSessionRepository.signUp(email: credentials.0, password: credentials.1)
  }
  .sink(receiveCompletion: { completion in
    switch completion {
    case .failure(let error):
      print(error)
      self.indicateErrorSigningIn(error)
    case .finished:
      self.goToSignInNavigator.navigateToOtp()
    }
  }, receiveValue: { _ in })
  .store(in: &amp;subscriptions)
</code></pre>

<p>signUp(email:password:) returns AnyPublisher</p>

<p>Here's the validator function:</p>

<pre><code>public func validate(text: String, with rules: [Rule]) -&gt; AnyPublisher&lt;String, ErrorMessage&gt; {
  rules.publisher
    .compactMap { $0.check(text) }
    .setFailureType(to: ErrorMessage.self)
    .flatMap {
      Fail&lt;Void, ErrorMessage&gt;(error: ErrorMessage(title: ""Error"", message: $0.description))
    }
    .map { text }
    .eraseToAnyPublisher()
}
</code></pre>

<p>And the signUp function:</p>

<pre><code>public func signUp(email: String, password: String) -&gt; AnyPublisher&lt;Void, ErrorMessage&gt; {
  remoteAPI.signUp(email: email, password: password)
    .flatMap(dataStore.save)
    .mapError { error -&gt; ErrorMessage in
      return ErrorMessage(title: ""Error"", message: error.description)
    }
    .eraseToAnyPublisher()
}
</code></pre>

<p>It calls these two functions:</p>

<pre><code>public func signUp(email: String, password: String) -&gt; AnyPublisher&lt;Confirmation, RemoteError&gt; {
  guard email == ""john.doe@email.com"" else {
    return Fail&lt;Confirmation, RemoteError&gt;(error: .invalidCredentials)
      .eraseToAnyPublisher()
  }

  return Just(Confirmation(otp: """", nonce: ""abcd""))
    .setFailureType(to: RemoteError.self)
    .eraseToAnyPublisher()
}

public func save(confirmation: Confirmation) -&gt; AnyPublisher&lt;Void, RemoteError&gt; {
  self.nonce = confirmation.nonce

  return Empty().eraseToAnyPublisher()
}
</code></pre>

<p>I'm not sure what's wrong, though it's likely my not understanding Combine enough, as I've just started learning it recently. </p>
","","user11042303","","","","2019-12-24 20:48:35","flatMap doesn't get invoked","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"59471512","1","","","2019-12-24 16:44:51","","2","231","<p>I have a view binded to a @FetchRequest property wrapper.
When changes are made to Core Data with Main Context, views are updated with the corresponding @FetchRequest property wrapper. 
However, when changes are made to Core Data with Private BackgroundContext, the view is not reacting to @FetchRequest.
Is this a bug with @FetchRequest ?</p>
","7680493","","","","","2019-12-24 16:44:51","SwiftUI @FetchRequest property wrapper not updating Views with Coredata Background Context","<ios><swift><core-data><swiftui><combine>","0","0","","","","CC BY-SA 4.0"
"59483962","1","","","2019-12-26 04:50:37","","1","673","<p>Notice in the gif that once I navigate and dismiss the new view, I am unable to navigate back! Is this a SwiftUI bug or a misuse of NavigationLinks?</p>

<pre><code>
struct ContentView: View {
    var body: some View {
        return NavigationView {
            NavigationLink(destination: FakeView1()) {
                Text(""Navigate"")
            }
        }
    }
}

struct FakeView1: View {
    var body: some View {
        Text(""Hey"")
    }
}
</code></pre>

<p><img src=""https://i.stack.imgur.com/BZD3Z.gif"" alt=""Video""></p>
","2066353","","2066353","","2019-12-26 04:57:15","2020-02-21 10:15:42","SwiftUI unable to navigate back and forth with navigationLink","<swiftui><combine><swiftui-navigationlink>","2","6","","","","CC BY-SA 4.0"
"59494690","1","","","2019-12-27 00:13:17","","1","1682","<p>When I'm handling the case when a user denies the notifications, the onReceive block isn't being triggered. It's working if the user accepts the prompt for notifications. Any help would be appreciated. Here are the necessary snippets of code:</p>

<pre><code>import SwiftUI

struct UIView: View {
    @ObservedObject var loginViewModel = LogInViewModel()
    ...
    var body: some View {
        VStack {
            ...
            Button(action: {
                UNUserNotificationCenter.current().requestAuthorization(options: [ .alert, .badge, .sound ]) { (success, error) in
                        if error == nil {
                            DispatchQueue.main.async {
                                if success {
                                    UIApplication.shared.registerForRemoteNotifications()
                                } else {
                                    self.loginViewModel.loginCall(...)
                                }
                            }
                        }
                    }
            }) {
                ...
            }.onReceive(loginViewModel.success) {
                print(""Login successful!"") // &lt;- This doesn't get called if a user doesn't allow the notifications
            }
            ...
        }
    }
}

import Combine

class LogInViewModel: ObservableObject {
    var success = PassthroughSubject&lt;Void, Never&gt;()
    ...
    func loginCall(...) {
        async API call here { (result: Result&lt;..., ...&gt;) in
            if case .success(...) = result {
                DispatchQueue.main.async {
                    self.success.send()
                }
            }
        }
    }
}
</code></pre>
","2955161","","1536149","","2019-12-27 05:17:46","2019-12-27 05:17:46","onReceive not being triggered in SwiftUI","<ios><swift><swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"59497691","1","","","2019-12-27 07:57:58","","0","252","<p>I have to pass the value of movie.id which is received from a <code>View</code> which is called ReviewView.</p>

<p>I need to pass the movie.id value received in this view to ReviewFetcher and then make a network request using that movie.id. As of now I have hard coded the movie id in ReviewFetcher but I require this to be received from ReviewView and then make a request and then update the list in ReviewView.</p>

<p>Below is the Code:-</p>

<p><strong>ReviewFetcher.swift</strong></p>

<pre><code>import Foundation
import Alamofire
import SwiftUI

class ReviewObserver: ObservableObject {
    @Published var review = ReviewArray(id: 1, page: 9, results: [])
    // @State var movieID:Int

    init() {
       // self.movieID = movieID
        getReviews(movieID : 181812)
    }

    func getReviews(movieID:Int) {
        //self.review.results.removeAll()
        let reviewURL = ""https://api.themoviedb.org/3/movie/""+String(movieID)+""/reviews?api_key=a18f578d774935ef9f0453d7d5fa11ae&amp;language=en-US&amp;page=1""

        Alamofire.request(reviewURL)
            .responseJSON { response in
                if let json = response.result.value {
                    if  (json as? [String : AnyObject]) != nil {
                        if let dictionaryArray = json as? Dictionary&lt;String, AnyObject?&gt; {
                            let json = dictionaryArray
                            if let id = json[""id""] as? Int,
                               let page = json[""page""] as? Int,
                               let results = json[""results""] as? Array&lt;Dictionary&lt;String, AnyObject?&gt;&gt; {
                               for i in 0..&lt;results.count {
                                   if let author = results[i][""author""] as? String,
                                      let content = results[i][""content""] as? String,
                                      let url = results[i][""url""] as? String {

                                       let newReview = ReviewModel(author: author,
                                                                    content: content,
                                                                   url: url)

                                       self.review.results.append(newReview)

                                    }
                                }
                            }
                        }
                    }
                }
            }
       }
  }
</code></pre>

<p><strong>ReviewView.swift</strong></p>

<pre><code>import SwiftUI

struct ReviewsView: View {
    @State var movie: MovieModel
    @Binding var reviews:[ReviewModel]
    @ObservedObject var fetcher = ReviewObserver()

    var body: some View {
        VStack(alignment:.leading) {
            Text(""Review"")
                .font(.largeTitle)
                .bold()
                .foregroundColor(Color.steam_rust)
                .padding(.leading)
            Divider()
            // Text(String(fetcher.movieID))
            List(fetcher.review.results) { item in
                VStack(alignment:.leading) {
                    Text(""Written by : ""+item.author)
                        .font(.body)
                        .bold()
                        .padding(.bottom)
                    Text(item.content)
                        .font(.body)
                        .lineLimit(.max)
                }
            }
        }
    }
}
</code></pre>

<p><strong>MovieModel.swift</strong></p>

<pre><code>import Foundation
import SwiftUI
import Combine

struct MovieArray: Codable {
    var page: Int = 0
    var total_results: Int = 0
    var total_pages: Int = 0
    var results: [MovieModel] = []

}

struct MovieModel: Codable, Identifiable {

    var id : Int
    var original_title: String
    var title: String
    var original_language:String
    var overview: String
    var poster_path: String?
    var backdrop_path: String?
    var popularity: Double
    var vote_average: Double
    var vote_count: Int
    var video: Bool
    var adult: Bool
    var release_date: String? 
}
</code></pre>
","12605987","","7948372","","2019-12-27 17:21:15","2019-12-27 17:21:15","pass values dynamically for network request","<ios><swift><swiftui><swift5><combine>","1","0","","","","CC BY-SA 4.0"
"59505048","1","","","2019-12-27 19:07:40","","4","1827","<p>I am trying to learn Combine and it is a PITA for me. I never learned RX Swift, so this is all new to me. I am sure I am missing something simple with this one, but hoping for some help. </p>

<p>I am trying to fetch some JSON from an API and load it in a List view. I have a view model that conforms to ObservableObject and updates a @Published property which is an array. I use that VM to load my list, but it looks like the view loads way before this API returns (List showing up blank). I was hoping these property wrappers would do what I thought they were supposed to and re-render the view whenever the object changed. </p>

<p>Like I said, I am sure I am missing something simple. If you can spot it, I would love the help. Thanks!</p>

<pre><code>class PhotosViewModel: ObservableObject {

    var cancellable: AnyCancellable?

    @Published var photos = Photos()

    func load(user collection: String) {
        guard let url = URL(string: ""https://api.unsplash.com/users/\(collection)/collections?client_id=\(Keys.unsplashAPIKey)"") else {
            return
        }
        cancellable = URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: Photos.self, decoder: JSONDecoder())
            .replaceError(with: defaultPhotosObject)
            .receive(on: RunLoop.main)
            .assign(to: \.photos, on: self)
    }

}
</code></pre>

<pre><code>struct PhotoListView: View {
    @EnvironmentObject var photosViewModel: PhotosViewModel
    var body: some View {
        NavigationView {
            List(photosViewModel.photos) { photo in
                NavigationLink(destination: PhotoDetailView(photo)) {
                    PhotoRow(photo)
                }
            }.navigationBarTitle(""Photos"")
        }
    }
}
</code></pre>

<pre><code>struct PhotoRow: View {
    var photo: Photo
    init(_ photo: Photo) {
        self.photo = photo
    }
    var body: some View {
        HStack {
            ThumbnailImageLoadingView(photo.coverPhoto.urls.thumb)
            VStack(alignment: .leading) {
                Text(photo.title)
                    .font(.headline)
                Text(photo.user.firstName)
                    .font(.body)
            }
            .padding(.leading, 5)
        }
        .padding(5)
    }
}
</code></pre>
","6917336","","","user12518608","2019-12-29 23:47:49","2020-01-14 16:40:38","Combine SwiftUI Remote Fetch Data - ObjectBinding doesn't update view","<swift><swiftui><combine>","2","4","0","","","CC BY-SA 4.0"
"59506120","1","","","2019-12-27 21:18:01","","0","112","<p><strong>Environment:</strong><br/>
Xcode Version 11.3 (11C29)<br/>
Apple Swift version 5.1.3 
<p>
<strong>Scenario:</strong>
Combine Neophyte attempting to learn <strong>URLSession.shared.dataTaskPublisher</strong>
<p>
<strong>Details:</strong>
I made a simple app to access weather data (any data) via two means: <br/>
1) <strong>Standard</strong>  and <br/>
2) via <strong>Publisher</strong></p>

<p>1) Here's the result: Weather data via <strong>Standard</strong> paradigm:
<p></p>

<pre><code>Sample(coord: DataTaskPublisher.Coord(lon: -0.13, lat: 51.51), weather: [DataTaskPublisher.Weather(id: 300, main: ""Drizzle"", description: ""light intensity drizzle"")], base: ""stations"", main: DataTaskPublisher.Main(temp: 280.32, pressure: 1012, humidity: 81, tempMin: 279.15, tempMax: 281.15), visibility: 10000, wind: DataTaskPublisher.Wind(speed: 4.1, deg: 80), clouds: DataTaskPublisher.Clouds(all: 90), dt: 1485789600.0, id: 2643743, name: ""London"")
</code></pre>

<p><p>
2) However the following error result is what I get via Combine's <strong>Publisher</strong> paradigm: <p>
<p></p>

<pre><code>2019-12-27 12:48:31.019760-0800 DataTaskPublisher[36228:13390491] Task &lt;8770DDAB-78BC-48D1-BA6C-F5941742E4FA&gt;.&lt;2&gt; finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled"" UserInfo={NSErrorFailingURLStringKey=https://samples.openweathermap.org/data/2.5/weather?q=London,uk&amp;appid=b6907d289e10d714a6e88b30761fae22, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=https://samples.openweathermap.org/data/2.5/weather?q=London,uk&amp;appid=b6907d289e10d714a6e88b30761fae22}
</code></pre>

<p><p>
<hr/>
Here are the two codes (Standard, following with Publish):</p>

<pre><code>import UIKit

let weatherURL = ""https://samples.openweathermap.org/data/2.5/weather?q=London,uk&amp;appid=b6907d289e10d714a6e88b30761fae22""
let calculationID = ""51f82d8e-64ed-4d80-808c-b1c29c780d28""
let calculatorBase = ""https://calculator-frontend-challenge.herokuapp.com/Calculations""

enum EndPoint {
    case weather
    case calc

    func path() -&gt; URL? {
        switch self {
        case .weather:
            return URL(string: weatherURL)
        default:
            return nil
        }
    }
}
   func doStandard() {
        let url = EndPoint.weather.path()

        let task = URLSession.shared.dataTask(with: url!) { (data: Data?, _: URLResponse?, error: Error?) -&gt; Void in

            do {
                let decoder = JSONDecoder()
                decoder.keyDecodingStrategy = .convertFromSnakeCase
                let result = try decoder.decode(Sample.self, from: data!)
                print(result)
            } catch let error as NSError {
                print(error)
            }
        }
        task.resume()
    }

    // ---------------------------------------------------------------------------

    func doPublish() {
        let url = EndPoint.weather.path()
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase

        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: url!)
            // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
            .map { $0.data }
            .decode(type: Sample.self, decoder: decoder)

        let _ = remoteDataPublisher
            .sink(receiveCompletion: { completion in
                print("".sink() received the completion"", String(describing: completion))
                switch completion {
                case .finished:
                    break
                case .failure(let anError):
                    print(""received error: "", anError)
                }
            }, receiveValue: { someValue in
                print("".sink() received \(someValue)"")
            })
    }
}
</code></pre>

<p><p>
Note: the 'Publish' version code is from a template in a tutorial.  
It had worked with a different URL. <p>
What am I missing? <br/>... or doing wrong?</p>

<p><hr/>
Here's the data object for the JSON Decoder:
<p></p>

<pre><code>struct Coord: Codable {
    let lon: Double
    let lat: Double
}

struct Weather: Codable {
    let id: Int
    let main: String
    let description: String
}

struct Wind: Codable {
    let speed: Double
    let deg: Int
}

struct Main: Codable {
    let temp: Double
    let pressure: Int
    let humidity: Int
    let tempMin: Double
    let tempMax: Double
}

struct Sys: Codable {
    let type: Int
    let id: Int
    let message: Double
    let country: String
    let sunrise: Int
    let sunset: Int
}

struct Clouds: Codable {
    let all: Int
}

struct Sample: Codable {
    let coord: Coord
    let weather: [Weather]
    let base: String
    let main: Main
    let visibility: Int
    let wind: Wind
    let clouds: Clouds
    let dt: Double
//    let sys: Sys
    let id: Int
    let name: String
//    let cod: Int
}
</code></pre>
","715747","","715747","","2019-12-27 21:25:03","2019-12-27 21:34:50","URLSession's dataTaskPublisher ends with a 'Cancelled' response vs regular completion. Why?","<ios><combine><nsurlsessiondatatask><swift5>","0","2","","2019-12-27 21:36:01","","CC BY-SA 4.0"
"59511750","1","","","2019-12-28 14:25:16","","2","3848","<p>I'm trying to remove the logic from the view, while keeping the benefits of SwiftUI. Idea 1 works but it makes use of an extra variable than I would want to. Idea 2 gives error: Property wrappers are not yet supported on local properties. The view should return ""bar"". What is the best way of making this work? Many thanks.</p>

<pre><code>import Combine
import Foundation
import SwiftUI

// Model

enum Model: String, RawRepresentable {

    case foo = ""foo""
    case bar = ""bar""
}

// State

var data1: String = Model.foo.rawValue

class State: ObservableObject {

    @Published internal var data2: String = data1
}

// Logic

func logic() {

// Idea 1: OK

    //data1 = Model.bar.rawValue
    //print(State().data2)

// Idea 2: Error Property wrappers are not yet supported on local properties

    @EnvironmentObject private var state: State
    state.data2 = Model.bar.rawValue
    print(state.data2)
}

// View

struct bar: View {

    @EnvironmentObject private var state: State

    internal var body: some View {

        logic()
        return Text(verbatim: self.state.data2)
    }
}
</code></pre>
","11952678","","","","","2019-12-28 15:27:52","Swift - How to access @Published var from func outside of view?","<swift><swiftui><combine><property-wrapper>","1","0","","","","CC BY-SA 4.0"
"59519530","1","","","2019-12-29 12:45:58","","13","5924","<p>The <code>ObservableObject</code> protocol defined by the Combine framework has an <code>objectWillChange</code> publisher property that lets you know when the properties of this object <em>will</em> change, meaning that, if subscribers to this publisher were to read its value when they get this will change event, they will still read the value <em>before</em> it is changed, what I am trying to understand is:</p>

<ul>
<li>How do frameworks like SwiftUI know that the value actually <strong>did</strong> change (ie: how do they get the new value) when it seems the only event you can subscribe to is the <em>will change</em> one? Is the underlying mechanism a publicly available API in the Combine framework?</li>
<li>How to get the actual new value of an <code>ObservableObject</code> after you received the will change event?</li>
</ul>
","2801589","","472495","","2020-05-07 19:13:45","2021-02-26 16:17:58","How does Combine know an ObservableObject actually changed","<swift><combine>","3","0","6","","","CC BY-SA 4.0"
"59521928","1","59522376","","2019-12-29 17:58:23","","4","2427","<p>How can I mock <code>URLSession.DataTaskPublisher</code>? I have a class <code>Proxy</code> that require to inject a <code>URLSessionProtocol</code> </p>

<pre><code>protocol URLSessionProtocol {
    func loadData(from url: URL) -&gt; URLSession.DataTaskPublisher
}
</code></pre>

<pre><code>class Proxy {

    private let urlSession: URLSessionProtocol

    init(urlSession: URLSessionProtocol) {
        self.urlSession = urlSession
    }

    func get(url: URL) -&gt; AnyPublisher&lt;Data, ProxyError&gt; {
        // Using urlSession.loadData(from: url)
    }

}

</code></pre>

<p>This code was originally used with the traditional version of <code>URLSession</code> with the completion handler. It was perfect since I could easily mock <code>URLSession</code> for testing like Sundell's solution here: <a href=""https://www.swiftbysundell.com/articles/mocking-in-swift/"" rel=""nofollow noreferrer"">Mocking in Swift</a>.</p>

<p>Is it possible to do the same with the Combine Framework? </p>
","6453483","","","","","2020-06-26 22:46:28","How to mock URLSession.DataTaskPublisher","<ios><swift><mocking><urlsession><combine>","3","0","2","","","CC BY-SA 4.0"
"59552487","1","59552828","","2020-01-01 12:26:07","","11","8733","<p>I want to listen to notifications when the app goes to the background and comes back. I'm trying to use the NotificationCenter publishers and have the SwiftUI view listen to them.<br/>
I can use a few methods to do it and I'm trying to use two of them but the interesting thing is, that although all seem legit when I put the subscriber in the <code>init()</code> method, it just does not work. <br/>
I tried to put it on the <code>main</code> thread but still no success.<br/>
Does anyone have any idea why?<br/>
Here's my code:</p>

<pre><code>struct ContentView: View {
    @State var isActive = true
    @State var cancellables = Set&lt;AnyCancellable&gt;()
    var body: some View {
        ZStack {
            Image(""background"")
                .resizable()
                .scaledToFill()
                .edgesIgnoringSafeArea(.all)                        
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.willResignActiveNotification)) { _ in
            self.isActive = false
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification), perform: {_ in
            self.isActive = true
        })
    }

    init() {
        NotificationCenter.default.publisher(for: UIApplication.willResignActiveNotification)
         //   .receive(on: RunLoop.main)
            .sink(receiveValue: { _ in
                print(""init"")
            }
            .store(in: &amp;cancellables)
    }
}
</code></pre>

<p>Strangely the listener in the <code>onReceive</code> modifier works like a charm. In the <code>init()</code> the <code>print(""init"")</code> never gets called.</p>
","5767040","","5268185","","2020-01-01 13:34:10","2022-08-23 08:35:10","SwiftUI with NotificationCenter publishers","<swiftui><combine><notificationcenter>","2","0","2","","","CC BY-SA 4.0"
"59563141","1","59565473","","2020-01-02 12:10:48","","1","763","<p>Im trying to create a networking layer, using <code>Combine</code> framework. I have a few functions already implemented, which are working fine. Some of these api calls are requiring an <code>access token</code>, and there are calls to obtain and refresh this token. Now the problem Im facing is that I would like the functions that require this token, to automatically try to refresh it before executing - only if it needs refreshing, or if I get an error. Right now I have functions like this:</p>

<pre><code>static func login(with parameters: CredentialsRequest) -&gt; AnyPublisher&lt;LoggedUser, RequestError&gt; 
static func refreshToken(_ token: Token) -&gt; AnyPublisher&lt;Token, RequestError&gt;
static func activeGames(token: Token) -&gt; AnyPublisher&lt;[Game], RequestError&gt;
</code></pre>

<p>Token has a property: <code>requiresRefresh: Bool</code></p>

<p>How could I make the function <code>activeGames</code> still return the type <code>AnyPublisher&lt;[Game], RequestError&gt;</code>, but work in such a way, that if first checks if token needs to be refreshed and if so, it waits before it's refreshed?</p>
","4528716","","","","","2020-01-03 09:32:33","Swift Combine - perform tasks in given sequence","<ios><swift><combine>","1","1","2","","","CC BY-SA 4.0"
"59565999","1","63231492","","2020-01-02 15:37:33","","16","13212","<p>I'm looking for the best way to create a bind between <code>textfields</code> and <code>ViewModel</code>. 
At the moment I'm creating a <code>@State</code> for each textfield and I'm manually sending the value from textfield to the viewModel properties when needed. I'm pretty sure this is not the best way to go... Is there a way to bind the <code>TextField</code> with the <code>ViewModel</code> property? </p>

<p>This is my current code: </p>

<pre><code>struct SigninView: View {
    @State var username:String = """"
    @State var password:String = """"

    var viewModel:SignInViewModel

    var body: some View {
        VStack(alignment: .leading, spacing: 15.0){

            DefaultTextField(placeholder: ""username"", value: $username)
            DefaultTextField(placeholder: ""password"", value: $password)

            Spacer()

            FillButton(title:""Sign In""){
                ///// IS THIS CORRECT?
                self.viewModel.email = self.username
                self.viewModel.password = self.password
                //------------------
                self.viewModel.signin()
            }
        }.padding()
    }
}
</code></pre>

<p>The view model is something like: </p>

<pre><code>class SignInViewModel:ObservableObject{

    var username:String? = nil
    var password:String? = nil
</code></pre>
","499990","","","","","2022-08-23 13:56:13","Binding ViewModel and TextFields with SwiftUI","<ios><swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"59568889","1","59569036","","2020-01-02 19:22:42","","5","375","<p>I am very new to SwiftUI and Combine, and even though I have plenty of experience with Swift, and a bit with ReactiveKit, I am finding it hard to get some basic stuff to work.</p>

<p>For example, I am trying to add an <code>isLoggedIn</code> property on my ViewModel, which should simply ""forward"" the <code>UserManager</code> class' <code>isLoggedIn</code> property. With ReactiveKit this is rather trivial but with SwiftUI/Combine I can't get is to work. The value is only set once, and then never updated again.</p>

<pre class=""lang-swift prettyprint-override""><code>class UserManager: ObservableObject {
  @Published private(set) var isLoggedIn = false

  // This class has all the actual logic for logging in, 
  // keeping track of the logged in user and the auth status, etc.
}

class ViewModel: ObservableObject {
  @Published var isLoggedIn = false

  private let userManager: UserManager

  init(userManager: UserManager) {
    self.userManager = userManager
    isLoggedIn = userManager.isLoggedIn // &lt;- this doesn't work
    userManager.$isLoggedIn.assign(to: \.isLoggedIn, on: self) // &lt;- neither does this
  }

  func logout() {
    userManager.logout()
  }
}

struct ContentView: View  {
  @ObservedObject var viewModel: ViewModel

  var body: some View {
    // this will use viewModel.isLoggedIn at some point
  }
}
</code></pre>
","403425","","","","","2020-10-22 19:52:33","How to ""forward"" a @Published value","<swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"59572251","1","","","2020-01-03 01:44:48","","1","520","<p>I'm trying to do a fairly simple View with MVVM to be a good ViewModel citizen. However,
the code breaks while accessing the @Enviromnent Core Data in the ViewModel. I created
two functions in the ViewModel. One accesses Core Data through the @Environment and one
accesses Core Data with the old style - get a reference to AppDelegate and do my own
thing. The OldSchool method works. Comment 2 below. The @Environment does not - it breaks
at the line indicated below with an error that is not helpful for me. Comment 1.
    (Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0))</p>

<p>Now if I take the same @Environment code and put it directly into the view it Works.
And if I call the same line that breaks the MVVM in a Text in the View I get the
correct response. Comment 2</p>

<p>This is the view:</p>

<pre><code>struct UserUtilities: View {

@Environment(\.managedObjectContext) var managedObjectContext
@FetchRequest(fetchRequest: DermPhoto.getAllDermPhotos()) var dermPhotos: FetchedResults&lt;DermPhoto&gt;

@State private var reminderInterval = 1
@State private var enableReminders = true
@State private var daysSincePhoto: Int = 0

@ObservedObject var userUtilitiesVM = UserUtilitiesViewModel()

var body: some View {
    NavigationView {
        VStack {
            Group { //group 1
            Toggle(isOn: $enableReminders) {
                Text(""Enable Reminders"")
            }
            .padding(EdgeInsets(top: 50, leading: 50, bottom: 0, trailing: 50))
            Text(""Reminders are"" + (enableReminders == true ? "" On"" : "" Off""))
            Spacer()

            //Comment 3 - this always works   
            Text(""String interpolation of self.dermPhotos.count"")
                Text(""\(self.dermPhotos.count)"")
            }  //group 1

            Group { //group 2
            Text(""It has been "" + ""\(self.daysSincePhoto) "" + (daysSincePhoto == 1 ? ""day"" : ""days"") + "" since a photo was added."")
            .padding(EdgeInsets(top: 0, leading: 50, bottom: 0, trailing: 50))
                //options for the sentence above
                //\(self.userUtilitiesVM.getTheDateInterval())
                //\(self.userUtilitiesVM.getFromEnvironment())
                //\(self.userUtilitiesVM.dateInterval)
            Spacer()
            Stepper(""Reminder Interval"", value: $reminderInterval, in: 1 ... 30)
            .padding(EdgeInsets(top: 0, leading: 50, bottom: 0, trailing: 50))
            Text(""Reminder Interval is: \(reminderInterval)"" + (reminderInterval == 1 ? "" day"" : "" days""))
            Spacer()

        }//group 2
        }
        .navigationBarTitle(""Reminder Days"", displayMode: .inline)
        .navigationBarItems(trailing: Button(action: {
            print(""getting the date interval from the nav button"")
            //self.daysSincePhoto = self.userUtilitiesVM.getOldSchool()
            self.daysSincePhoto = self.userUtilitiesVM.getFromEnvironment()
            //self.daysSincePhoto = self.getFromEnvironment()
        } , label: { Text(""Fetch"")
        }))
    }
}

//this always works
func getFromEnvironment() -&gt; Int {

    let numberOfRecords = self.dermPhotos.count

    if numberOfRecords &gt; 0 {
        let now = Date()
        let lastDate = self.dermPhotos.last?.addDate
        //ok to bang - addDate is always added to core data
        let dateInterval = DateInterval(start: lastDate!, end: now)
        let days = Int(dateInterval.duration) / (24 * 3600)
        self.daysSincePhoto = days
        return days
    }
    return 0
}
}
</code></pre>

<p>And this is the ViewModel:</p>

<pre><code>class UserUtilitiesViewModel: ObservableObject {
    @Environment(\.managedObjectContext) var managedObjectContext
    @FetchRequest(fetchRequest: DermPhoto.getAllDermPhotos()) var dermPhotos: FetchedResults&lt;DermPhoto&gt;
    @Published var dateInterval: Int = 50

    //Comment 2 this always works
    func getOldSchool() -&gt; Int { 
        let kAppDelegate = UIApplication.shared.delegate as! AppDelegate
        let context = kAppDelegate.persistentContainer.viewContext
        var resultsDermPhotos : [DermPhoto] = []

        let fetchRequest: NSFetchRequest&lt;DermPhoto&gt; = DermPhoto.fetchRequest() as! NSFetchRequest&lt;DermPhoto&gt;
        let sortDescriptor = NSSortDescriptor(key: ""addDate"", ascending: true)
        fetchRequest.sortDescriptors = [sortDescriptor]

        do {
            resultsDermPhotos = try context.fetch(fetchRequest)
        } catch {
            print(""the fetchRequest error is \(error.localizedDescription)"")
        }

        let numberOfRecords = resultsDermPhotos.count
        if numberOfRecords &gt; 0 {
            let now = Date()
            let lastDate = resultsDermPhotos.last?.addDate
            //ok to bang this since addDate is always added to core data
            let di = DateInterval(start: lastDate!, end: now)
            let days = Int(di.duration) / (24 * 3600)
            dateInterval = days
            return days
        }
        return 0
    }

    //this never works
    func getFromEnvironment() -&gt; Int {

        //Comment 1 - this breaks
        let numberOfRecords = self.dermPhotos.count

        if numberOfRecords &gt; 0 {
            let now = Date()
            let lastDate = self.dermPhotos.last?.addDate
            //ok to bang this since addDate is always added to core data
            let di = DateInterval(start: lastDate!, end: now)
            let days = Int(di.duration) / (24 * 3600)
            dateInterval = days

            return days
        }

        return 0
    }
}
</code></pre>

<p>Clearly I can use old school or abandon the ViewModel idea but I would like to know how to fix this. Any guidance would be appreciated. Xcode 11.3 (11C29)</p>
","2698617","","","","","2020-07-26 22:45:21","SwiftUI MVVM @Environment Breaks","<xcode><core-data><swiftui><combine>","1","0","0","","","CC BY-SA 4.0"
"59573754","1","59573797","","2020-01-03 05:48:56","","4","935","<p>I am trying to bind the value of <code>query</code> to a search box sitting in a <code>SwiftUI</code> view.</p>

<pre><code>class DataSet: ObservedObject {

... 

@Published var query: String = """"

init() {
    let sub = AnySubscriber&lt;String, Never&gt;(
        receiveSubscription: nil,
        receiveValue: { query in
            print(query)
            return .unlimited
        })
    self.$query.subscribe(sub)
}

...
}
</code></pre>

<p>When the user changes the value of the <code>query</code> I'd like to filter some other property in my <code>ObservedObject</code>. Yet I cannot find anywhere in the documentation how do I subscribe to changes to <code>query</code> property.</p>
","1646086","","2876009","","2020-01-03 08:21:47","2022-08-23 10:00:49","Subscribing to changes to @Published","<ios><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59581973","1","","","2020-01-03 16:26:00","","0","1569","<p>I have a timer inside my view model class which every second changes two @Published strings inside the view model. View model class is an Observable Object which Observed by the view but the changes to these string objects are not updating my view.</p>

<p>I have a very similar structure in many other views(Published variables inside a ObservableObject which is observed by view) and it always worked. I can't seem to find what am I doing wrong?</p>

<h2>ViewModel</h2>

<pre class=""lang-swift prettyprint-override""><code>final class QWMeasurementViewModel: ObservableObject {

    @Published var measurementCountDownDetails: String = """"
    @Published var measurementCountDown: String = """"

    private var timer: Timer?
    private var scheduleTime = 0

    func setTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in
            DispatchQueue.main.async {
                self.scheduleTime += 1
                if self.scheduleTime == 1 {
                    self.measurementCountDownDetails = ""Get ready""
                    self.measurementCountDown = ""1""
                }
                else if self.scheduleTime == 2 {
                    self.measurementCountDownDetails = ""Relax your arm""
                    self.measurementCountDown = ""2""
                }
                else if self.scheduleTime == 3 {
                    self.measurementCountDownDetails = ""Breathe""
                    self.measurementCountDown = ""3""
                }
                else if self.scheduleTime == 4 {
                    self.measurementCountDownDetails = """"
                    self.measurementCountDown = """"
                    timer.invalidate()
                }
            }
        }
    }
}
</code></pre>

<h2>View</h2>

<pre class=""lang-swift prettyprint-override""><code>struct QWMeasurementView: View {
    @ObservedObject var viewModel: QWMeasurementViewModel

    var body: some View {
        VStack {
            Text(viewModel.measurementCountDownDetails)
                .font(.body)
            Text(viewModel.measurementCountDown)
                .font(.title)
        }
        .onAppear {
            viewModel.setTimer()
        }
    }
}
</code></pre>

<h3>Edit</h3>

<p>After investigation, this seems to be related to how it is being presented. Cause if it's a single view this code works but I am actually presenting this as a sheet. (Still cannot understand why would it make a difference..)</p>

<pre class=""lang-swift prettyprint-override""><code>struct QWBPDStartButtonView: View {

    @ObservedObject private var viewModel: QWBPDStartButtonViewModel
    @State private var startButtonPressed: Bool = false

    init(viewModel: QWBPDStartButtonViewModel) {
        self.viewModel = viewModel
    }

    var body: some View {
        Button(action: {
            self.startButtonPressed = true
        }) {
            ZStack {
                Circle()
                    .foregroundColor(Color(""midGreen""))
                Text(""Start"")
                    .font(.title)
            }
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $startButtonPressed) {
            QWMeasurementView(viewModel: QWMeasurementViewModel())
        }
    }
}
</code></pre>
","1621925","","1311272","","2020-01-07 18:10:55","2020-01-29 03:58:26","SwiftUI: Published string changes inside view model are not updating view","<swift><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"59587303","1","59587459","","2020-01-04 01:54:51","","4","3887","<p>I'm trying to build an app with SwiftUI, and I'm just getting started with Combine framework. My first simple problem is that I'd like a single variable that defines when the app has been properly initialized. I'd <em>like</em> it to be driven by some nested objects, though. For example, the app is initialized when the account object is initialized, the project object is initialized, etc. My app could then use GlobalAppState.isInitialized, instead of inspected each nested object.</p>

<pre><code>class GlobalAppState: ObservableObject {

    @Published var account: Account = Account()
    @Published var project: Project = Project()

    @Published var isInitialized: Bool {
        return self.account.initialized &amp;&amp; self.project.initialized;
    }
}
</code></pre>

<p>I get the error <code>Property wrapper cannot be applied to a computed property</code></p>

<p>So...clearly, this is currently disallowed. Is there a way I can work around this??? I'd like to be able to use <code>GlobalAppState.initialized</code> as a flag in the app. More to the point, something like <code>GlobalAppState.project.currentProject</code>, which would be a computed property returning the currently selected project, etc...</p>

<p>I can see this pattern being used in a thousand different places! Any help would be wildly appreciated...</p>

<p>Thanks!</p>
","482425","","","","","2020-01-04 03:46:07","@Published for a computed property (or best workaround)","<ios><swift><swiftui><combine>","2","0","2","","","CC BY-SA 4.0"
"59593139","1","59594915","","2020-01-04 17:28:58","","9","2790","<p>As we know, usually publishers are struct. What will change if it is a class?</p>

<p>Let's consider we have 1 publisher which emits 1 value and 2 subscribers, which subscribes to it.</p>

<pre><code>let p1 = Just(20)
let s1 = p1.print().sink { _ in }
let s2 = p1.print().sink { _ in }

// s1 - receive value: (20)
// s2 - receive value: (20)
</code></pre>

<p>in print logs, we can see that both subscribers got value (20).</p>

<p>If we open the documentation of share() operator, we will see</p>

<blockquote>
  <p>share() - Returns a publisher as a class instance.</p>
</blockquote>

<p>So it just changes semantic of the publisher from value to reference. In our example, we don't pass <code>p1</code> publisher to any function or assign to any object and that's why for me there is no difference publisher is struct or class ...
But if I add <code>share()</code> operator behavior will be different, <code>s2</code> won't get value. </p>

<pre><code>let p1 = Just(20).share() // !
let s1 = p1.print().sink { _ in }
let s2 = p1.print().sink { _ in }

// s1 - receive value: (20)
</code></pre>

<p>I saw some examples with <code>URLSession.shared.dataTaskPublisher(\_: URL)</code> or with some ""delayed"" publishers, when <code>s2</code> also gets value, but it's still unclear for me how just changing semantic of publisher change its behaviour in such way.</p>
","3785970","","8261341","","2020-01-04 17:58:29","2020-03-02 02:24:17","Understanding share() in Combine","<swift><combine>","2","0","2","","","CC BY-SA 4.0"
"59593765","1","59593842","","2020-01-04 18:45:02","","2","974","<p>I have a <code>@Published</code> property in a singleton class which is observed in a view model class and it only received the first initial value and not after that. Why?</p>

<p>View</p>

<pre><code>import SwiftUI

struct ContentView: View {

    @ObservedObject var viewModel = ContentViewModel(singletonService: SingletonService.shared)

    var body: some View {
        NavigationView {
            Form {
                Text(""Hello World"")
            }.navigationBarItems(trailing: Button(""Increase Number"", action: {
                SingletonService.shared.increaseNumber()
            }))
        }
    }
}
</code></pre>

<p>ViewModel</p>

<pre><code>import Combine

class ContentViewModel: ObservableObject {

    init(
        singletonService: SingletonService
    ) {
        let cencellable = singletonService.$number.sink(receiveValue: { print($0) })
        // Never called after the first time
    }

}
</code></pre>

<p>Singleton</p>

<pre><code>import Combine

class SingletonService {

    static let shared = SingletonService()

    @Published var number = 0

    func increaseNumber() {
        number += 1
    }

}
</code></pre>
","2577123","","","","","2020-01-04 18:52:57","@Published property in singleton not emitting events after the first one","<ios><swift><functional-programming><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"59596627","1","59802785","","2020-01-05 02:54:24","","1","1472","<p>I have a class called <code>QueryObserver</code> that can produce <em>multiple results over time</em>, given back as callbacks (closures). You use it like this:</p>

<pre class=""lang-swift prettyprint-override""><code>let observer = QueryObserver&lt;ModelType&gt;(query: query) { result in
  switch result {
  case .success(let value):
    print(""result: \(value)"")
  case .failure(let error):
    print(""error: \(error)"")
  }
}
</code></pre>

<p>(<code>QueryObserver</code> is actually a wrapper around Firebase Firestore's unwieldy <code>query.addSnapshotListener</code> functionality, in case you were wondering. Using modern <code>Result</code> type instead of a callback with multiple optional parameters.)</p>

<p>In an older project I am using ReactiveKit and have an extension that turns all this into a <code>Signal</code>, like so:</p>

<pre class=""lang-swift prettyprint-override""><code>extension QueryObserver {
  public static func asSignal(query: Query) -&gt; Signal&lt;[T], Error&gt; {
    return Signal { observer in
      let queryObserver = QueryObserver&lt;T&gt;(query: query) { result in
        switch result {
        case .success(let value):
          observer.receive(value)
        case .failure(let error):
          if let firestoreError = error as? FirestoreError, case .noSnapshot = firestoreError {
            observer.receive([])
          } else {
            observer.receive(completion: .failure(error))
          }
        }
      }

      return BlockDisposable {
        queryObserver.stopListening()
      }
    }
  }
}
</code></pre>

<p>In a brand new project though, I am using Combine and am trying to rewrite this. So far as I have managed to write this, but it doesn't work. Which makes sense: the <code>observer</code> is not retained by anything so it's immediately released, and nothing happens.</p>

<pre class=""lang-swift prettyprint-override""><code>extension QueryObserver {
  public static func asSignal(query: Query) -&gt; AnyPublisher&lt;[T], Error&gt; {
    let signal = PassthroughSubject&lt;[T], Error&gt;()

    let observer = QueryObserver&lt;T&gt;(query: query) { result in
      switch result {
      case .success(let value):
        print(""SUCCESS!"")
        signal.send(value)
      case .failure(let error):
        if let firestoreError = error as? FirestoreError, case .noSnapshot = firestoreError {
          signal.send([])
        } else {
          signal.send(completion: .failure(error))
        }
      }
    }

    return signal.eraseToAnyPublisher()
  }
}
</code></pre>

<p>How do I make the Combine version work? How can I wrap existing async code? The only examples I found used <code>Future</code> for one-off callbacks, but I am dealing with multiple values over time.</p>

<p>Basically I am looking for the ReactiveKit-to-Combine version of <a href=""https://github.com/DeclarativeHub/ReactiveKit#wrapping-asynchronous-calls-into-signals"" rel=""nofollow noreferrer"">this</a>.</p>
","403425","","403425","","2020-01-06 01:02:35","2020-01-18 16:54:26","Wrapping asynchronous code in Swift's Combine publisher","<swift><combine><reactivekit>","1","1","","","","CC BY-SA 4.0"
"59599408","1","","","2020-01-05 11:29:17","","1","152","<p>I've been learning Swift &amp; SwiftUI and all has been going well until very recently. I have successfully used <code>@Published</code> properties to keep my data &amp; views in sync. However, I now want to  display some data that is a combination of several <code>@Published</code> properties.</p>

<p>The simplified data model class:</p>

<pre><code>import Foundation

final class GameAPI: ObservableObject {

    struct PlayerStats: Identifiable, Codable {
        var gamesPlayed: Int
        var wins: Int
        var losses: Int
    }

    struct Player: Identifiable, Codable {
        var id = UUID()
        var name: String
        var stats: PlayerStats
    }

    struct Room: Identifiable, Codable {
        var id = UUID()
        var name: String
        var players: [Player]
    }

    struct ServerStats {
        var totalGamesPlayed: Int
        var totalPlayers: Int
        var totalPlayersOnline: Int
    }

    @Published var players: [Player] = []
    @Published var rooms: [Room] = []

    func addPlayer(name: String) {
        players.append(Player(
            name: name,
            stats: PlayerStats(
                gamesPlayed: 0,
                wins: 0,
                losses: 0
            )
        ))
    }

    func removePlayer(id: UUID) { ... }

    func updatePlayerStats(playerId: UUID, stats: PlayerStats) { ... }

    func getLeaderboard() -&gt; [Player] {
        return players.sorted({ $0.stats.wins &gt; $1.stats.wins }).prefix(10)
    }

    func getServerStats() -&gt; ServerStats {
        return ServerStats(
            totalGamesPlayed: ...,
            totalPlayers: ...,
            totalPlayersOnline: ...,
        )
    }
}
</code></pre>

<p>View:</p>

<pre><code>import SwiftUI

struct LeaderboardTabView: View {
    @EnvironmentObject var gameAPI: GameAPI

    var body: some View {
        VStack {
            Text(""TOP PLAYERS"")
            Leaderboard(model: gameAPI.getLeaderboard())
            // ^^^ How can I make the view automatically refresh when players are added/removed or any of the player stats change?
        }
    }
}
</code></pre>

<p>How can I wire up my views to leaderboard &amp; server stats data so that the view refreshes whenever the data model changes?</p>
","12651891","","","","","2020-01-05 11:29:17","How to model data using Combine & SwiftUI","<swift><model><swiftui><combine>","0","2","1","","","CC BY-SA 4.0"
"59602045","1","","","2020-01-05 16:47:15","","3","1373","<p><a href=""https://i.stack.imgur.com/2byvL.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2byvL.gif"" alt=""Animation Glitch""></a></p>

<p>So I have a list that changes when user fill in search keyword, and when there is no result, all the cells collapse and somehow they would fly over to the first section which looks ugly. Is there an error in my code or is this an expected SwiftUI behavior? Thanks.</p>

<pre><code>import SwiftUI

struct ContentView: View {

    @ObservedObject var viewModel = ViewModel(photoLibraryService: PhotoLibraryService.shared)

    var body: some View {
        NavigationView {
            List {
                Section {
                    TextField(""Enter Album Name"", text: $viewModel.searchText)
                }
                Section {
                    if viewModel.libraryAlbums.count &gt; 0 {
                        ForEach(viewModel.libraryAlbums) { libraryAlbum -&gt; Text in
                            let title = libraryAlbum.assetCollection.localizedTitle ?? ""Album""
                            return Text(title)
                        }
                    }
                }
            }.listStyle(GroupedListStyle())
                .navigationBarTitle(
                    Text(""Albums"")
                ).navigationBarItems(trailing: Button(""Add Album"", action: {
                        PhotoLibraryService.shared.createAlbum(withTitle: ""New Album \(Int.random(in: 1...100))"")
                }))
        }.animation(.default)
    }
}
</code></pre>
","2577123","","","","","2020-02-02 01:27:53","List reload animation glitches","<ios><swift><swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"59605344","1","59607167","","2020-01-06 00:13:01","","0","290","<p>I have an <code>NSFetchedResultsController</code> and a dynamic table view. My table view cells have a text label. How should I bind objects from the fetched results controller to the cell?</p>

<p>In <a href=""https://developer.apple.com/videos/play/wwdc2019/230/"" rel=""nofollow noreferrer"">WWDC 2019 230</a>, there’s a code snippet where a core data object is bound to a view...</p>

<pre><code>if let tag = try? fetchRequest.execute().first {
  nameSubscription = tag.publisher(for: \.name).assign(to: \.text, on: tagLabel)
  colorSubscription = tag.publisher(for: \.color).map({ $0 as? UIColor}).assign(to: \.textColor, on: tagLabel)
}
</code></pre>

<p>Where should this happen in the context of a table view controller with a cell that has a label? Where should the subscriber (<code>AnyCancellable</code>) go? Will I need a collection of subscribers since there’s an indefinite number of cells?</p>
","6191825","","6191825","","2020-01-06 05:16:41","2020-01-06 06:38:48","How can I bind an NSManagedObject to a table/collection view cell using Combine?","<ios><core-data><uikit><combine>","2","1","","","","CC BY-SA 4.0"
"59615078","1","","","2020-01-06 15:50:12","","14","10959","<p>I am trying to use Swift combine to run many tasks with the same result.
at the moment each task is a publisher that will emit a result. now I am facing a problem that I have to wait for all publishers to emit the element then moving on. kind of like dispatch group. I found zip(with:<em>:</em>:_) operator which takes 4 publishers.</p>

<blockquote>
  <p><a href=""https://developer.apple.com/documentation/combine/passthroughsubject/3333571-zip"" rel=""noreferrer"">https://developer.apple.com/documentation/combine/passthroughsubject/3333571-zip</a></p>
</blockquote>

<p>but what if you have an array of publishers (in case that they emit the same kind of element) ? is there any way to do that? </p>
","893310","","4667835","","2020-01-06 15:54:21","2021-06-29 07:13:58","Swift Combine - Wait for all publishers","<swift><combine>","2","5","3","","","CC BY-SA 4.0"
"59635077","1","59635790","","2020-01-07 19:42:27","","7","4953","<p>I have a model type which looks like this:</p>

<pre><code>enum State {
    case loading
    case loaded([String])
    case failed(Error)

    var strings: [String]? {
        switch self {
        case .loaded(let strings): return strings
        default: return nil
        }
    }
}

class MyApi: ObservableObject {
    private(set) var state: State = .loading

    func fetch() {
        ... some time later ...
        self.state = .loaded([""Hello"", ""World""])
    }
}
</code></pre>

<p>and I'm trying to use this to drive a SwiftUI View.</p>

<pre><code>struct WordListView: View {
    @EnvironmentObject var api: MyApi

    var body: some View {
        ZStack {
            List($api.state.strings) {
                Text($0)
            }
        }
    }
}
</code></pre>

<p>It's about here that my assumptions fail. I'm trying to get a list of the strings to render in my <code>List</code> when they are loaded, but it won't compile.</p>

<p>The compiler error is <code>Generic parameter 'Subject' could not be inferred</code>, which after a bit of googling tells me that bindings are two-way, so won't work with both my <code>private(set)</code> and the var on the State enum being read-only.</p>

<p>This doesn't seem to make any sense - there is no way that the view should be able to tell the api whether or not it's loading, that definitely should be a one-way data flow!</p>

<p>I guess my question is either </p>

<ol>
<li>Is there a way to get a one-way binding in SwiftUI - i.e. some of the UI will update based on a value it cannot change.</li>
</ol>

<p>or</p>

<ol start=""2"">
<li>How should I have architected this code! It's very likely that I'm writing code in a style which doesn't work with SwiftUI, but all the tutorials I can see online neatly ignore things like loading / error states.</li>
</ol>
","13000","","1027644","","2020-01-07 20:06:59","2022-08-18 01:21:23","Binding to a read-only property in SwiftUI","<swift><swiftui><combine>","2","4","3","","","CC BY-SA 4.0"
"59637100","1","59692095","","2020-01-07 22:40:39","","15","2571","<p><strong>Ground of Being</strong>: It will help, before reading, to know that you cannot assign a UIImage to an image view outlet's <code>image</code> property through the keypath <code>\UIImageView.image</code>. Here's the property:</p>

<pre><code>@IBOutlet weak var iv: UIImageView!
</code></pre>

<p>Now, will this compile?</p>

<pre><code>    let im = UIImage()
    let kp = \UIImageView.image
    self.iv[keyPath:kp] = im // error
</code></pre>

<p>No!</p>

<blockquote>
  <p>Value of optional type 'UIImage?' must be unwrapped to a value of type 'UIImage'</p>
</blockquote>

<p>Okay, now we're ready for the actual use case.</p>

<hr>

<p>What I'm actually trying to understand is how the Combine framework <code>.assign</code> subscriber works behind the scenes. To experiment, I tried using my own Assign object. In my example, my publisher pipeline produces a UIImage object, and I assign it to the <code>image</code> property of a UIImageView property <code>self.iv</code>.</p>

<p>If we use the <code>.assign</code> method, this compiles and works:</p>

<pre><code>URLSession.shared.dataTaskPublisher(for: url)
    .map {$0.data}
    .replaceError(with: Data())
    .compactMap { UIImage(data:$0) }
    .receive(on: DispatchQueue.main)
    .assign(to: \.image, on: self.iv)
    .store(in:&amp;self.storage)
</code></pre>

<p>So, says I to myself, to see how this works, I'll remove the <code>.assign</code> and replace it with my own Assign object:</p>

<pre><code>let pub = URLSession.shared.dataTaskPublisher(for: url)
    .map {$0.data}
    .replaceError(with: Data())
    .compactMap { UIImage(data:$0) }
    .receive(on: DispatchQueue.main)

let assign = Subscribers.Assign(object: self.iv, keyPath: \UIImageView.image)
pub.subscribe(assign) // error
// (and we will then wrap in AnyCancellable and store)
</code></pre>

<p>Blap! We can't do that, because <code>UIImageView.image</code> is an Optional UIImage, and my publisher produces a UIImage plain and simple.</p>

<p>I tried to work around this by unwrapping the Optional in the key path:</p>

<pre><code>let assign = Subscribers.Assign(object: self.iv, keyPath: \UIImageView.image!)
pub.subscribe(assign)
</code></pre>

<p>Cool, that compiles. But it crashes at runtime, presumably because the image view's image is initially <code>nil</code>.</p>

<p>Now I can work around all of this just fine by adding a <code>map</code> to my pipeline that wraps the UIImage up in an Optional, so that all the types match correctly. But my question is, how does this <em>really</em> work? I mean, why don't I have to do that in the first code where I use <code>.assign</code>? Why am I able to specify the <code>.image</code> keypath there? There seems to be some trickery about how key paths work with Optional properties but I don't know what it is.</p>

<hr>

<p>After some input from Martin R I realized that if we type <code>pub</code> explicitly as producing <code>UIImage?</code> we get the same effect as adding a <code>map</code> that wraps the UIImage in an Optional. So this compiles and works</p>

<pre><code>let pub : AnyPublisher&lt;UIImage?,Never&gt; = URLSession.shared.dataTaskPublisher(for: url)
    .map {$0.data}
    .replaceError(with: Data())
    .compactMap { UIImage(data:$0) }
    .receive(on: DispatchQueue.main)
    .eraseToAnyPublisher()

let assign = Subscribers.Assign(object: self.iv, keyPath: \UIImageView.image)
pub.subscribe(assign)
let any = AnyCancellable(assign)
any.store(in:&amp;self.storage)
</code></pre>

<p>This still doesn't explain how the original <code>.assign</code> works. It appears that it is able to <em>push</em> the optionality of the type <em>up</em> the pipeline into the <code>.receive</code> operator. But I don't see how that is possible.</p>
","341994","","341994","","2020-01-08 20:16:59","2022-08-03 15:40:43","How does Swift ReferenceWritableKeyPath work with an Optional property?","<swift><option-type><combine><swift-keypath>","1","7","5","","","CC BY-SA 4.0"
"59659292","1","59659918","","2020-01-09 07:45:48","","1","529","<p>I have the following method (named: <code>stories</code>) from Combine's book by Ray Wenderlich that fetches stories from <a href=""https://hacker-news.firebaseio.com/v0/"" rel=""nofollow noreferrer"">Hacker News Public API</a> as follows:</p>

<p>Model Object:</p>

<pre><code>public struct Story: Codable {
  public let id: Int
  public let title: String
  public let by: String
 public let time: TimeInterval
 public let url: String
}

extension Story: Comparable {
  public static func &lt; (lhs: Story, rhs: Story) -&gt; Bool {
  return lhs.time &gt; rhs.time
  }
}

extension Story: CustomDebugStringConvertible {
   public var debugDescription: String {
   return ""\n\(title)\nby \(by)\n\(url)\n-----""
  }
}
</code></pre>

<p>API Struct:</p>

<pre><code>struct API {
  enum Error: LocalizedError {
   case addressUnreachable(URL)
   case invalidResponse

var errorDescription: String? {
  switch self {
  case .invalidResponse: return ""The server responded with garbage.""
  case .addressUnreachable(let url): return ""\(url.absoluteString) is unreachable.""
    }
   }
 }

enum EndPoint {
   static let baseURL = URL(string: ""https://hacker-news.firebaseio.com/v0/"")!

   case stories
   case story(Int)

   var url: URL {
  switch self {
  case .stories:
    return EndPoint.baseURL.appendingPathComponent(""newstories.json"")
  case .story(let id):
    return EndPoint.baseURL.appendingPathComponent(""item/\(id).json"")
     }
   }
 }


var maxStories = 10


private let decoder = JSONDecoder()
private let apiQueue = DispatchQueue(label: ""API"", qos: .default, attributes: .concurrent)

func story(id: Int) -&gt; AnyPublisher&lt;Story, Error&gt; {
    URLSession.shared.dataTaskPublisher(for: EndPoint.story(id).url)
        .receive(on: apiQueue)
        .map(\.data)
        .decode(type: Story.self, decoder: decoder)
        .catch{ _ in Empty&lt;Story, Error&gt;() }
        .eraseToAnyPublisher()
}

func mergedStories(ids storyIDs: [Int]) -&gt; AnyPublisher&lt;Story, Error&gt; {
    let storyIDs = Array(storyIDs.prefix(maxStories))
    precondition(!storyIDs.isEmpty)
    let initialPublisher = story(id: storyIDs[0])
    let remainder = Array(storyIDs.dropFirst())
    return remainder.reduce(initialPublisher) { combined, id in //Swift's reduce method
        combined
        .merge(with: story(id: id))
        .eraseToAnyPublisher()
    }
}

func stories() -&gt; AnyPublisher&lt;[Story], Error&gt; {
    URLSession.shared
        .dataTaskPublisher(for: EndPoint.stories.url)
        .map(\.data)
        .decode(type: [Int].self, decoder: decoder)
        .mapError { error -&gt; API.Error in
            switch error {
            case is URLError:
                return Error.addressUnreachable(EndPoint.stories.url)
            default:
                return Error.invalidResponse
            }
    }
    .filter { !$0.isEmpty }
    .flatMap { storyIDs in
        print(""StoryIDs are \(storyIDs)"") //the print statement that causes the error
       return self.mergedStories(ids: storyIDs)
    }
    .scan([]) { stories, story -&gt; [Story] in
        stories + [story] //&lt;--- Error fires here
    }
    .map { $0.sorted() }
    .eraseToAnyPublisher()
  }
}
</code></pre>

<p>Consumer Code:</p>

<pre><code>let api = API()
var subscriptions = Set&lt;AnyCancellable&gt;()
api.stories()
.sink(receiveCompletion: { print($0) },
      receiveValue: { print($0) })
.store(in: &amp;subscriptions)
</code></pre>

<p>The method works perfectly without putting in the <code>print(""storyIDs are \(storyIDs)"")</code> statement, once this print statement is placed, a weird compiler error fires at the line: <code>stories + [story]</code>  which says:</p>

<blockquote>
  <p><code>'[Any]' is not convertible to 'Array&lt;Story&gt;'</code></p>
</blockquote>

<p>I don't know what does this misleading error mean in such case ? </p>
","1056118","","1056118","","2020-01-09 08:33:25","2020-01-09 11:26:06","Combine weird compile error after placing a print statement in a flatMap operator closure","<ios><swift><combine>","1","4","","","","CC BY-SA 4.0"
"59666945","1","","","2020-01-09 15:12:12","","4","1884","<p>I wrote a very simple app to test Combine and the NotificationCenter:</p>

<pre><code>
extension Notification.Name {
    static let Test = Notification.Name(rawValue: ""Test"")
}

// SOLUTION 1
NotificationCenter.default
            .publisher(for: .Test)
            .sink(receiveCompletion: { _ in
                print(""SOLUTION 1: COMPLETION"")
            }, receiveValue: { _ in
                print(""SOLUTION 1: VALUE"")
            })

// SOLUTION 2
    NotificationCenter.Publisher(center: .default, name: .Test)
        .sink(receiveCompletion: { _ in
            print(""SOLUTION 2: COMPLETION"")
        }, receiveValue: { _ in
            print(""SOLUTION 2: VALUE"")
        })

// SOLUTION 3
NotificationCenter.default.addObserver(self, selector: #selector(doSomething), name: .Test, object: nil)

@objc
func doSomething() {
        print(""SOLUTION 3: VALUE"")
}

// RAISE NOTIFICATION

NotificationCenter.default.post(name: .Test, object: nil)NotificationCenter.default.post(name: .Test, object: nil)
</code></pre>

<p>Notifications aren't catched using Combine. The only solution working is the third one, the old-style one. The weird thing is that if I run the same code in the Playground, it works!</p>

<p>The deployment target for the project is iOS 13. I've executed the app on both a physical device and simulator. I've also installed iOS 13.2.2 simulator.</p>

<p>Any suggestion?</p>
","4815555","","4815555","","2020-01-09 15:20:55","2020-01-09 16:13:12","Combine and NotificationCenter: Notifications not working","<ios><swift><nsnotificationcenter><combine>","1","0","","2020-01-09 19:41:39","","CC BY-SA 4.0"
"59672603","1","","","2020-01-09 21:47:25","","1","199","<p>I have a class with a timer (updating every millisecond). </p>

<pre><code>class TimeCount {
    let currentTimePublisher = Timer.TimerPublisher(interval: 0.001, runLoop: .main, mode: .common)
    let cancellable: AnyCancellable?

    init() {
        self.cancellable = currentTimePublisher.connect() as? AnyCancellable
    }

    deinit {
        self.cancellable?.cancel()
    }
}
</code></pre>

<p>I also have a List() of TimerView objects</p>

<pre><code>List() {
    ForEach(self.timers) { timer in
        TimerPlusView(timer: timer)
    }
}
</code></pre>

<p>And inside each object i have a Text that updates its content listening to the timer</p>

<pre><code>Text(""\(currentTime.timeIntervalSince(timer.time ?? Date()))"")
    .font(.largeTitle)
    .fontWeight(.bold)
    .foregroundColor(.black)
    .opacity(0.5)
    .onReceive(timeCount.currentTimePublisher) { newCurrentTime in
        self.currentTime = newCurrentTime
    }
</code></pre>

<p>Thing is, after (not while) scrolling the list for about 100px, the timer stops working and the labels stop updating, and I have no idea why.</p>

<p>Behavior I get: 
<a href=""https://i.stack.imgur.com/i5iJq.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/i5iJq.gif"" alt=""enter image description here""></a></p>

<blockquote>
  <p>UPD: here's a link to the full project for reference. 
  <a href=""https://www.dropbox.com/s/47zoizfqp6upz1e/TimerMinimal.zip?dl=0"" rel=""nofollow noreferrer"">https://www.dropbox.com/s/47zoizfqp6upz1e/TimerMinimal.zip?dl=0</a></p>
</blockquote>
","6090166","","6090166","","2020-01-10 08:11:38","2020-01-28 20:45:52","Timer breaks after List scroll","<ios><swift><xcode><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"59674192","1","","","2020-01-10 00:54:00","","1","687","<p>I am trying to write my own <code>@Published</code> like property wrapper - I have hundreds of member values that I would like to only emit publication values when they actually change equality-wise (as opposed to every time they are set, which is default)</p>

<p>The property wrapper itself is straightforward </p>

<pre><code>@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)
@propertyWrapper public struct EqPublished&lt;Value: Equatable&gt; {

    public var wrappedValue: Value
    {
        willSet {
            _projectedValue.send(newValue)
        }
    }
    public var projectedValue: AnyPublisher&lt;Value, Never&gt;
    private var _projectedValue: CurrentValueSubject&lt;Value, Never&gt;

    public init(wrappedValue: Value)
    {
        self.wrappedValue = wrappedValue
        self._projectedValue = CurrentValueSubject&lt;Value, Never&gt;(wrappedValue)
        self.projectedValue = _projectedValue.removeDuplicates().eraseToAnyPublisher()
    }
}
</code></pre>

<p>Which can be used with something like </p>

<pre><code>class Model: ObservableObject {
    @EqPublished var value = 5
}


// In some view later on 
@State var count = 0
...
Text(""El Tappo"")
        .onTapGesture {
            // Update every 3rd tap
            self.count = (self.count + 1) % 3
            self.model.value = self.model.value + (self.count == 0 ? 1 : 0)
        }
        .onReceive(self.model.$value) { val in
            print(""Value is \(val)"")
        }
</code></pre>

<p>Works as expected - the <code>onReceive</code> gets fired on the 3rd tap with a 6. Replace <code>EqPublished</code> with <code>Published</code> and its called every time. </p>

<p>However - if I change the consuming view to be </p>

<pre><code>Text(""Value is \(model.value)"")
        .onTapGesture {
            // Update every 3rd tap
            self.count = (self.count + 1) % 3
            self.model.value = self.model.value + (self.count == 0 ? 1 : 0)
        }
        .onReceive(self.model.objectWillChange) { _ in
            print(""Model"")
        }
</code></pre>

<p>The <code>objectWillChange</code> publisher never fires and the UI will never recalculate - if I change the <code>@EqPublished</code> to a plain <code>@Published</code> it all works. </p>

<p><strong>The question(s) - updated for deeper understanding</strong></p>

<ul>
<li>How does the <code>ObservedObject</code> class connect itself to its publishing members? </li>
<li>When does the connection take place? (I think in the accessor of <code>objectWillChange</code> from looking at the headers) </li>
<li>Is there some sort of reflection that can be done to inspect each member and connect without caring what the <code>Value</code> type of <code>Published&lt;Value&gt;</code> is? </li>
</ul>
","3886090","","3886090","","2020-01-10 01:48:23","2020-01-12 06:14:57","How does ObservedObject subscribe to its @Published members","<swiftui><observers><combine>","2","0","","","","CC BY-SA 4.0"
"59676570","1","59679010","","2020-01-10 06:35:44","","0","959","<p>I've got a question about the <code>zip</code> operator in Combine in combination with backpressure.</p>

<p>Take the following code snippet:</p>

<pre><code>let sequencePublisher = Publishers.Sequence&lt;Range&lt;Int&gt;, Never&gt;(sequence: 0..&lt;Int.max)
let subject = PassthroughSubject&lt;String, Never&gt;()

let handle = subject
    .zip(sequencePublisher.print())
    .print()
    .sink { letters, digits in
        print(letters, digits)
    }

subject.send(""a"")
</code></pre>

<p>When executing this in the playground, the following is the output:</p>

<pre><code>receive subscription: (0..&lt;9223372036854775807)
receive subscription: (Zip)
request unlimited
request unlimited
receive value: (0)
receive value: (1)
receive value: (2)
receive value: (3)
receive value: (4)
receive value: (5)
receive value: (6)
receive value: (7)
...
</code></pre>

<p>When executing it on an iOS device, the code crashes after a few seconds because of memory issues.</p>

<p>The underlying reason can be seen in the fourth line above where <code>zip</code> requests an unlimited amount of values from the <code>sequencePublisher</code>. Since the <code>sequencePublisher</code> provides the whole range of <code>Int</code> values, this causes memory overflows.</p>

<p>What I think to know:</p>

<ul>
<li><code>zip</code> waits for one value of each publisher before combining them and pushing them on </li>
<li>backpressure is used to control the demand from a subscriber to a publisher</li>
</ul>

<p>My expectation would be that <code>zip</code> only requests one value from each publisher, waits for them to arrive and only requests the next values when it received one from each. </p>

<p>In this particular case I tried to build a behaviour where a sequence number is assigned to every value that is produced by the  <code>subject</code>. However, I could imagine that this is always a problem when <code>zip</code> combines values from publishers that publish with very different frequencies. </p>

<p>Utilising backpressure in the <code>zip</code> operator seems to be perfect tool to solve that issue. Do you know why this isn't the case? Is this a bug or intentional? If intentional, why?</p>

<p>Thanks guys</p>
","1668608","","1668608","","2020-01-10 06:47:23","2020-08-23 09:20:22","Swift Combine: Unexpected backpressure behaviour with zip operator","<ios><swift><reactive-programming><combine>","2","0","1","","","CC BY-SA 4.0"
"59684743","1","","","2020-01-10 15:38:42","","1","146","<p>So i have this strict with a function that calls a Combine publisher, with the purpose of passing in the results to another function. I am getting the following error:
<a href=""https://i.stack.imgur.com/RZ8tF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RZ8tF.png"" alt=""Error message""></a></p>

<p>My code snippet is:</p>

<pre class=""lang-swift prettyprint-override""><code>public func execute(state: FluxState?, dispatch: @escaping DispatchFunction) {
            let config = Popular(country: .usa, genres: nil)

            subscriptions = []

            let params = [
                ""page"": ""\(self.page)"",
                ""per_page"": ""\(20)""
            ]
            print(""on page \(self.page)"")

            var moviesResult = [Movie]()

            SwiftRecommendations.APIService.shared
                .getMovies(settings: config, params: params)
                //.receive(on: DispatchQueue.main)
                .sink(receiveCompletion: { (completion) in
                    if case let .failure(error) = completion {
                        print(""error \(error)"")
                    } else {
                        self.popularMovies = moviesResult
                        dispatch(SetMovieMenuList(page: self.page,
                            list: MovieSwift.MoviesMenu.popular,
                            response: moviesResult))
                    }
                }, receiveValue: { [unowned self] in
                    moviesResult = $0
                })
                .store(in: &amp;self.subscriptions)
        }
    }
</code></pre>

<p>The <code>SetMovieMenuList</code> snippet is:</p>

<pre class=""lang-swift prettyprint-override""><code>class SetMovieMenuList: Action {
        let page: Int
        let list: MoviesMenu
        let response: [Movie]
    }
</code></pre>

<p>The dispatch function is a SwiftFlux state, and APIService is a struct. Not sure if I need to provide any additional information, but I wanted to see if this was the way to structure this, or how do I use <code>subscriptions</code> and persist the list of movies in this scenario. </p>

<p>Thanks </p>
","163845","","163845","","2020-01-10 22:53:56","2020-01-10 22:53:56","Escaping closure captures mutating self in Swift Combine Subscriber","<swift><combine>","0","13","","2020-01-10 15:53:11","","CC BY-SA 4.0"
"59689442","1","59693022","","2020-01-10 21:47:10","","3","2615","<p>I feel like I can sort of understand why what I'm doing isn't working but I'm still trying to wrap my head around Combine and SwiftUI so any help here would be welcome.</p>

<p>Consider this example:</p>

<p>Single view app that stores some strings in UserDefaults, and uses those strings to display some Text labels. There are three buttons, one to update the title, and one each to update the two UserDefaults-stored strings to a random string.</p>

<p>The view is a dumb renderer view and the title string is stored directly in an ObservableObject view model. The view model has a published property that holds a reference to a UserSettings class that implements property wrappers to store the user defined strings to UserDefaults.</p>

<p>Observations:</p>

<p>• Tapping ""Set A New Title"" correctly updates the view to show the new value</p>

<p>• Tapping either of the ""Set User Value"" buttons does change the value internally, however the view does not refresh. 
If ""Set A New Title"" is tapped after one of these buttons, the new values are shown when the view body rebuilds for the title change.</p>

<p>View:</p>

<pre><code>import SwiftUI

struct ContentView: View {
    @ObservedObject var model = ViewModel()

    var body: some View {
        VStack {
            Text(model.title).font(.largeTitle)
            Form {
                Section {
                    Text(model.settings.UserValue1)
                    Text(model.settings.UserValue2)
                }

                Section {
                    Button(action: {
                        self.model.title = ""Updated Title""
                    }) { Text(""Set A New Title"") }
                    Button(action: {
                        self.model.settings.UserValue1 = ""\(Int.random(in: 1...100))""
                    }) { Text(""Set User Value 1 to Random Integer"") }
                    Button(action: {
                        self.model.settings.UserValue2 = ""\(Int.random(in: 1...100))""
                    }) { Text(""Set User Value 2 to Random Integer"") }
                }

                Section {
                    Button(action: {
                        self.model.settings.UserValue1 = ""Initial Value One""
                        self.model.settings.UserValue2 = ""Initial Value Two""
                        self.model.title = ""Initial Title""
                    }) { Text(""Reset All"") }
                }

            }
        }
    }
}
</code></pre>

<p>ViewModel:</p>

<pre><code>import Combine

class ViewModel: ObservableObject {

    @Published var title = ""Initial Title""

    @Published var settings = UserSettings()

}
</code></pre>

<p>UserSettings model:</p>

<pre><code>import Foundation
import Combine

@propertyWrapper struct DefaultsWritable&lt;T&gt; {
    let key: String
    let value: T

    init(key: String, initialValue: T) {
        self.key = key
        self.value = initialValue
    }

    var wrappedValue: T {
        get { return UserDefaults.standard.object(forKey: key) as? T ?? value }
        set { return UserDefaults.standard.set(newValue, forKey: key) }
    }
}



final class UserSettings: NSObject, ObservableObject {
    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()

    @DefaultsWritable(key: ""UserValue"", initialValue: ""Initial Value One"") var UserValue1: String {
        willSet {
            objectWillChange.send()
        }
    }
    @DefaultsWritable(key: ""UserBeacon2"", initialValue: ""Initial Value Two"") var UserValue2: String {
        willSet {
            objectWillChange.send()
        }
    }

}
</code></pre>

<p>When I put a breakpoint on <code>willSet { objectWillChange.send() }</code> in UserSettings I see that the objectWillChange message is going to the publisher when I would expect it to so that tells me that the issue is likely that the view or the view model is not properly subscribing to it. I know that if I had UserSettings as an <code>@ObservedObject</code> on the view this would work, but I feel like this should be done in the view model with Combine.</p>

<p>What am I missing here? I'm sure it's really obvious...</p>
","12482631","","","","","2022-08-23 13:58:32","Passing an ObservableObject model through another ObObject?","<ios><swift><swiftui><combine><observableobject>","1","0","2","","","CC BY-SA 4.0"
"59690913","1","59691976","","2020-01-11 01:32:41","","15","4220","<p>Im trying to test a simple publisher within the Combine framework and SwiftUI.  My test tests a published bool named isValid in my view model.  My view model also has a published username string, that when changes and becomes 3 characters or more isValid is assigned the value.  Here is the view model.  I am sure I am not understanding how publishers work in a test environment, timing etc...  Thanks in advance. </p>

<pre><code>public class UserViewModel: ObservableObject {
  @Published var username = """"
  @Published var isValid = false
  private var disposables = Set&lt;AnyCancellable&gt;()

  init() {
    $username
      .receive(on: RunLoop.main)
      .removeDuplicates()
      .map { input in
        print(""~~~&gt; \(input.count &gt;= 3)"")
        return input.count &gt;= 3
    }
    .assign(to: \.isValid, on: self)
    .store(in: &amp;disposables)
  }
}
</code></pre>

<p>Here is my view, not really important here</p>

<pre><code>struct ContentView: View {
  @ObservedObject private var userViewModel = UserViewModel()
  var body: some View {
    TextField(""Username"", text: $userViewModel.username)
  }
}
</code></pre>

<p>Here is my test file and single test that fails</p>

<pre><code>class StackoverFlowQuestionTests: XCTestCase {
  var model = UserViewModel()

    override func setUp() {
        model = UserViewModel()
    }

    override func tearDown() {
    }

    func testIsValid() {
      model.username = ""1""
      XCTAssertFalse(model.isValid)
      model.username = ""1234""
      XCTAssertTrue(model.isValid) //&lt;----- THIS FAILS HERE
    }

}
</code></pre>
","1302387","","","","","2022-08-23 13:53:49","How do I properly test a var that changes through a publisher in my viewModel in XCTestCase","<swift><swiftui><combine>","3","0","5","","","CC BY-SA 4.0"
"59698091","1","59700392","","2020-01-11 19:50:30","","3","3172","<p>I've created a custom Publisher for use with a Realm database which seems to function as expected in isolation but doesn't want to play nicely with SwiftUI.</p>

<p>I've isolated the issue to the interface between the view model and SwiftUI. The view model appears to behave as expected based on the results from the various property observers and .print() statements I've dropped in for the bug hunt but outside the scope of the view model, the view model's data repository (represented by the 'state' property) is reported as empty hence the blank UI. </p>

<p>Interestingly, if I replace my Combine code with a straight array conversion of the Realm Results query the UI is displayed as expected (although I haven't implemented notification tokens for a dynamic update when items are added/deleted, etc). </p>

<p>I suspect I can't see the wood for all the trees so an outside perspective and guidance would be very much appreciated :-)</p>

<p>Codebase below - I've left out Apple-generated boilerplate for the most part.</p>

<p><strong>SceneDelegate:</strong></p>

<pre><code>class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).

        // Create the SwiftUI view that provides the window contents.
        let patientService = MockPatientService()
        let viewModel = AnyViewModel(PatientListViewModel(patientService: patientService))
        print(""#(function) viewModel contains \(viewModel.state.patients.count) patients"")
        let contentView = PatientListView()
            .environmentObject(viewModel)

        // Use a UIHostingController as window root view controller.
        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: contentView)
            self.window = window
            window.makeKeyAndVisible()
        }
    }
</code></pre>

<p><strong>Patient.swift</strong></p>

<pre><code>import Foundation
import RealmSwift

@objcMembers final class Patient: Object, Identifiable {
    dynamic let id: String = UUID().uuidString
    dynamic var name: String = """"

    required init() {
        super.init()
    }

    init(name: String) {
        self.name = name
    }
}
</code></pre>

<p><strong>PatientService</strong></p>

<pre><code>import Foundation
import RealmSwift

@objcMembers final class Patient: Object, Identifiable {
    dynamic let id: String = UUID().uuidString
    dynamic var name: String = """"

    required init() {
        super.init()
    }

    init(name: String) {
        self.name = name
    }
}
</code></pre>

<p><strong>ViewModel</strong></p>

<pre><code>import Foundation
import Combine

protocol ViewModel: ObservableObject where ObjectWillChangePublisher.Output == Void {
    associatedtype State // the type of the state of a given scene
    associatedtype Input // inputs to the view model that are transformed by the trigger method

    var state: State { get }
    func trigger(_ input: Input)
}

final class AnyViewModel&lt;State, Input&gt;: ObservableObject { // wrapper enables ""effective"" (not true) type erasure of the view model
    private let wrappedObjectWillChange: () -&gt; AnyPublisher&lt;Void, Never&gt;
    private let wrappedState: () -&gt; State
    private let wrappedTrigger: (Input) -&gt; Void


    var objectWillChange: some Publisher {
        wrappedObjectWillChange()
    }

    var state: State {
        wrappedState()
    }

    func trigger(_ input: Input) {
        wrappedTrigger(input)
    }

    init&lt;V: ViewModel&gt;(_ viewModel: V) where V.State == State, V.Input == Input {
        self.wrappedObjectWillChange = { viewModel.objectWillChange.eraseToAnyPublisher() }
        self.wrappedState = { viewModel.state }
        self.wrappedTrigger = viewModel.trigger
    }
}

extension AnyViewModel: Identifiable where State: Identifiable {
    var id: State.ID {
        state.id
    }
}
</code></pre>

<p><strong>RealmCollectionPublisher</strong></p>

<pre><code>import Foundation
import Combine
import RealmSwift

// MARK: Custom publisher - produces a stream of Object arrays in response to change notifcations on a given Realm collection
extension Publishers {
    struct Realm&lt;Collection: RealmCollection&gt;: Publisher {
        typealias Output = Array&lt;Collection.Element&gt;
        typealias Failure = Never // TODO: Not true but deal with this later

        let collection: Collection

        init(collection: Collection) {
            self.collection = collection
        }

        func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
            let subscription = RealmSubscription(subscriber: subscriber, collection: collection)
            subscriber.receive(subscription: subscription)
        }
    }
}

// MARK: Convenience accessor function to the custom publisher
extension Publishers {
    static func realm&lt;Collection: RealmCollection&gt;(collection: Collection) -&gt; Publishers.Realm&lt;Collection&gt; {
        return Publishers.Realm(collection: collection)
    }
}

// MARK: Custom subscription
private final class RealmSubscription&lt;S: Subscriber, Collection: RealmCollection&gt;: Subscription where S.Input == Array&lt;Collection.Element&gt; {
    private var subscriber: S?
    private let collection: Collection
    private var notificationToken: NotificationToken?

    init(subscriber: S, collection: Collection) {
        self.subscriber = subscriber
        self.collection = collection

        self.notificationToken = collection.observe { (changes: RealmCollectionChange) in
            switch changes {
            case .initial:
                // Results are now populated and can be accessed without blocking the UI
                print(""Initial"")
                subscriber.receive(Array(collection.elements))
            case .update(_, let deletions, let insertions, let modifications):
                print(""Updated"")
                subscriber.receive(Array(collection.elements))
            case .error(let error):
                fatalError(""\(error)"")
                #warning(""Impl error handling - do we want to fail or log and recover?"")
            }
        }
    }

    func request(_ demand: Subscribers.Demand) {
        // no impl as RealmSubscriber is effectively just a sink
    }

    func cancel() {
        print(""Cancel called on RealnSubscription"")
        subscriber = nil
        notificationToken = nil
    }

    deinit {
        print(""RealmSubscription de-initialised"")
    }
}
</code></pre>

<p><strong>PatientListViewModel</strong></p>

<pre><code>class PatientListViewModel: ViewModel {
    @Published var state: PatientListState = PatientListState(patients: [AnyViewModel&lt;PatientDetailState, Never&gt;]()) {
        willSet {
            print(""Current PatientListState : \(newValue)"")
        }
    }

    private let patientService: PatientService
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(patientService: PatientService) {
        self.patientService = patientService

        // Scenario 1 - This code sets state which is correctly shown in UI (although not dynamically updated)
        let viewModels = patientService.allPatientsAsArray()
            .map { AnyViewModel(PatientDetailViewModel(patient: $0, patientService: patientService)) }
        self.state = PatientListState(patients: viewModels)

        // Scenario 2 (BUGGED) - This publisher's downstream emissions update dynamically, downstream outputs are correct and the willSet observer suggests .assign is working
        // but the UI does not reflect the changes (if the above declarative code is removed, the number of patients is always zero)
        let publishedState = Publishers.realm(collection: patientService.allPatientsAsResults())
            .print()
            .map { results in
                results.map { AnyViewModel(PatientDetailViewModel(patient: $0, patientService: patientService)) } }
            .map { PatientListState(patients: $0) }
            .eraseToAnyPublisher()
            .assign(to: \.state, on: self)
            .store(in: &amp;cancellables)
    }

    func trigger(_ input: PatientListInput) {
        switch(input) {
        case .delete(let indexSet):
            let patient = state.patients[indexSet.first!].state.patient
            patientService.deletePatient(patient)
            print(""Deleting item at index \(indexSet.first!) - patient is \(patient)"")
            #warning(""Know which patient to remove but need to ensure the state is updated"")
        }
    }

    deinit {
        print(""Viewmodel being deinitialised"")
    }
}
</code></pre>

<p><strong>PatientListView</strong></p>

<pre><code>struct PatientListState {
    var patients: [AnyViewModel&lt;PatientDetailState, Never&gt;]
}

enum PatientListInput {
    case delete(IndexSet)
}


struct PatientListView: View {
    @EnvironmentObject var viewModel: AnyViewModel&lt;PatientListState, PatientListInput&gt; 

    var body: some View {
        NavigationView {

            VStack {
                Text(""Patients: \(viewModel.state.patients.count)"")

                List {
                    ForEach(viewModel.state.patients) { viewModel in
                        PatientCell(patient: viewModel.state.patient)
                    }
                    .onDelete(perform: deletePatient)

                }
                .navigationBarTitle(""Patients"")
            }
        }
    }

    private func deletePatient(at offset: IndexSet) {
        viewModel.trigger(.delete(offset))
    }
}
</code></pre>

<p><strong>PatientDetailViewModel</strong></p>

<pre><code>class PatientDetailViewModel: ViewModel {
    @Published private(set) var state: PatientDetailState
    private let patientService: PatientService
    private let patient: Patient

    init(patient: Patient, patientService: PatientService) {
        self.patient = patient
        self.patientService = patientService
        self.state = PatientDetailState(patient: patient)
    }

    func trigger(_ input: Never) {
        // TODO: Implementation
    }
}
</code></pre>

<p><strong>PatientDetailView</strong></p>

<pre><code>struct PatientDetailState {
    let patient: Patient
    var name: String {
        patient.name
    }
}

extension PatientDetailState: Identifiable {
    var id: Patient.ID {
        patient.id
    }
}

struct PatientDetailView: View {
    var body: some View {
        Text(/*@START_MENU_TOKEN@*/""Hello, World!""/*@END_MENU_TOKEN@*/)
    }
}

struct PatientDetailView_Previews: PreviewProvider {
    static var previews: some View {
        PatientDetailView()
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/7T1EE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7T1EE.png"" alt=""**Using arrays:**""></a>
<a href=""https://i.stack.imgur.com/uVDYn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uVDYn.png"" alt=""**Using custom Publisher**""></a></p>
","2733214","","","","","2020-01-12 02:11:45","Combine & SwiftUI with a custom Publisher - unexpected behaviour when using .assign subscriber","<swift><realm><swiftui><combine>","1","0","2","","","CC BY-SA 4.0"
"59699132","1","","","2020-01-11 22:18:26","","0","509","<p><strong>Scenario:</strong> 
I want to be able to display an Alert() from an Observable Object, via  @Published values (networkMessage &amp; hasAlert).
<p>
This alert should be fired when missing a network connection. <br/>
via 
<a href=""https://i.stack.imgur.com/7e6vt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7e6vt.png"" alt=""enter image description here""></a>
<p>
<strong>Host View</strong> that displays the Alert() :
<p></p>

<pre><code>import SwiftUI

struct EndPointView: View {
    @EnvironmentObject var settings: Settings
    @ObservedObject var standardWeatherReport = StandardWeatherReport()
    @ObservedObject var publishedWeatherReport = PublishedWeatherReport()
    @ObservedObject var pepBoy = PepBoy()
    @ObservedObject var postMan = PostMan()

    var body: some View {
        Form {
            Text(""Chosen One: \(settings.endpointSection)"")
            Text(""Row Two"")
            Text(""Row Three"")
            Text(""Row Four"")

        }.onAppear {
            self.acquireData()
        }
        .alert(isPresented: $standardWeatherReport.hasAlert, content: { () -&gt; Alert in
            Alert(title: Text(verbatim: standardWeatherReport.networkMessage!))
        })
    }

    func acquireData() {
        let chosenEndPoint = EndPoints(rawValue: settings.endpointSection)
        switch chosenEndPoint {
            case .standardWeather:
                standardWeatherReport.doStandard()
            case .publishedWeather:
                publishedWeatherReport.doPublish()
            case .postman:
                postMan.doPublishPostMan()
            case .publishpepboy:
                pepBoy.doPublishPep()
            case .none:
                print(""none"")
        }
    }
}
</code></pre>

<p><p>
<strong>Observable Object</strong> the initially fired off the Alert() via case .failure(let anError):</p>

<pre><code>import Foundation

class PublishedWeatherReport: ObservableObject {
    @Published var networkMessage: String?
    @Published var hasAlert = false
    @Published var weatherReport: String?

    func doPublish() {
        let url = EndPoint.weather.path()
        var request = URLRequest(url: EndPoint.weather.path()!)
        request.httpMethod = ""GET""
        request.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")

        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase

        // Publisher:
        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: url!)
            // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
            .map { $0.data }
            .decode(type: Sample.self, decoder: decoder)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()

        // Subscriber:
        sub = remoteDataPublisher // ...must assign to an iVar to keep alive.
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case .failure(let anError):
                    self.networkMessage = anError.localizedDescription
                    self.hasAlert = true.  // ... unable to host Alert().
                }
            }, receiveValue: { someValue in
                print("".sink() received \(someValue)"")
            })
    }
}
</code></pre>

<p><p>
<strong>Question:</strong> Why am I not getting this alert() via </p>

<pre><code>(isPresented: $standardWeatherReport.hasAlert)?
</code></pre>
","715747","","715747","","2020-01-11 22:25:48","2020-01-12 00:16:48","Unable to display Alert from an Observable Object","<swiftui><alert><combine>","2","0","","","","CC BY-SA 4.0"
"59705030","1","","","2020-01-12 14:54:44","","1","1063","<p>Using SwiftUI (or Combine) how might I set up a series of one or more events that are triggered by the (system) clock.  Examples might include:</p>

<ul>
<li>Every night at midnight,</li>
<li>On the hour,</li>
<li>Every fifteen minutes on the quarter hour,</li>
<li>Finally, on a slightly different note: On the 29th of February 2020 at 12:15.</li>
</ul>

<p>An approximation is easily achieved by setting up a timer event that fires every second and then checking the hours/minutes/seconds, etc. but this seems very inefficient for events that may be many hours or days apart.  </p>

<p>I'm looking for something that is closely synchronised to the actual system clock and fires off a single event at the required time rather than firing loads of events and having each one ask ""Are we there yet?"".   </p>
","2215831","","","","","2020-04-18 06:53:18","SwiftUI or Combine Clock/Timer events","<asynchronous><time><swiftui><clock><combine>","2","2","","","","CC BY-SA 4.0"
"59708086","1","","","2020-01-12 21:00:24","","3","823","<p>I think I've discovered a memory leak related to Swift Combine's debounce operator. 
It's either a leak, or I'm doing something very wrong. 
Here's a simple example that recreates the problem:</p>

<pre><code>
    @IBOutlet weak var currentValueLabel: UILabel!

    var numberSubject = CurrentValueSubject&lt;Int, Never&gt;(0)
    var bag = [AnyCancellable]()

    override func viewDidLoad() {
        super.viewDidLoad()

        setupSubscription()
        bag.removeAll()
    }

    func setupSubscription() {
        numberSubject
            .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
            .sink { [weak self] in self?.currentValueLabel.text = ""\($0)"" }
            .store(in: &amp;bag)
    }
}
</code></pre>

<p>The simple usage of the <code>debounce</code> operator seems to be causing a <code>malloc</code> leak(Checked using Memory Debugger):</p>

<p><a href=""https://i.stack.imgur.com/Av7Ny.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Av7Ny.png"" alt=""Leak with debounce""></a></p>

<p>Updating <code>setupSubscription()</code> to ditch the <code>debounce</code> seems to fix it: </p>

<pre><code>    func setupSubscription() {
        numberPublisher
//        .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] in self?.currentValueLabel.text = ""\($0)"" }
            .store(in: &amp;bag)
    }
</code></pre>

<p>If you run with this modification, and wait for the view to load, (aka for the subscription to happen and then for it to be removed from the array) you will notice that the leak is no longer there.
The leak is magically gone.</p>

<p>Could someone tell me if I'm doing something horribly wrong? This looks like a bug to me.</p>

<p>Thanks!</p>
","733334","","733334","","2020-01-12 22:42:29","2020-11-02 14:55:52","Swift Combine .debounce memory leak?","<swift><memory-leaks><combine><debounce>","2","4","0","","","CC BY-SA 4.0"
"59712847","1","59713607","","2020-01-13 08:25:38","","2","2106","<p>I have LocationManager class that works well. This is part of LocationManager class. </p>

<pre><code>  var headingDegree = PassthroughSubject&lt;Double, Never&gt;()

  func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
    headingDegree.send(-newHeading.magneticHeading)
  }
</code></pre>

<p><code>headingDegree</code> is the value I want to send to my ViewModel. I debugged it to make sure it has correct values, and it does. </p>

<p>So, in my view model,</p>

<pre><code>class CompassViewViewModel: ObservableObject {
 @Published var degree: Double = 0.0
 @State var cancellable = Set&lt;AnyCancellable&gt;()

 func update() {
    LocationManager.shared.headingDegree.sink {
      self.degree = $0
    }
    .store(in: &amp;cancellable)
  }

</code></pre>

<p>I sinked my <code>headingDegree</code>. This is the part that brings my problems. If I put breakpoints in <code>update()</code> function, <code>self.degree = $0</code> is never called. </p>

<p>This is how my View looks like. </p>

<pre><code>struct CompassView: View {
  @ObservedObject var viewModel: CompassViewViewModel

  init(viewModel: CompassViewViewModel) {
    self.viewModel = viewModel
  }

 var body: some View {
    ZStack {
      Text(""aa"")
        .font(.footnote)
    }
      .onAppear {
        self.viewModel.update()
    }
  }
}
</code></pre>

<p>Could you tell me why my sink() is not called? </p>
","11258185","","11258185","","2020-01-13 08:40:54","2020-07-08 08:53:27","sink() is not called in combine swift","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"59719270","1","","","2020-01-13 15:12:24","","5","3167","<p>I'm trying to implement a refresh token strategy in Swift 5 and the Combine Framework for iOS.</p>

<p>I don't plan on using any third party package, just using what is provided by the framework, `URLSession.dataTaskPublisher`, so mu goal is to :</p>

<ol>
<li>Make a request</li>
<li>If the request fails with 401, refresh the auth token (which is another request)

<ol>
<li>After the refresh token is done, retry the first request</li>
<li>If it fails throw the error to be handled by the caller</li>
</ol></li>
</ol>

<p>&#x200B;</p>

<p>This is a very trivial use case, but seems to be very hard to implement in Combine, that makes it really hard to use in any real life scenario.</p>

<p>Any help would be welcome !</p>

<p>&#x200B;</p>

<p>This is my try, which unfortonately doesn't work</p>

<pre><code>private func dataTaskPublisherWithAuth(for request: URLRequest) -&gt; URLSession.DataTaskPublisher {
    return session.dataTaskPublisher(for: request)

        .tryCatch { error -&gt; URLSession.DataTaskPublisher in
guard error.errorCode == 401 else {
throw error
}
var components = URLComponents(url: self.baseUrl, resolvingAgainstBaseURL: true)
components?.path += ""/refresh""
components?.queryItems = [
URLQueryItem(name: ""refresh_token"", value: KeychainHelper.RefreshToken),
]

let url = components?.url
var loginRequest = URLRequest(url: url!)
loginRequest.httpMethod = ""GET""
loginRequest.setValue(""application/json"", forHTTPHeaderField: ""Content-Type"")

return session.dataTaskPublisher(for: loginRequest)
.decode(type: LoginResponse.self, decoder: JSONDecoder())
.map { result in
if result.accessToken != nil {
// Save access token
KeychainHelper.AccessToken = result.accessToken!
KeychainHelper.RefreshToken = result.refreshToken!
KeychainHelper.ExpDate = Date(timeIntervalSinceNow: TimeInterval(result.expiresIn!))
}
return result
}
.flatMap { data -&gt; URLSession.DataTaskPublisher in
session.dataTaskPublisher(for: request)
}
    }.eraseToAnyPublsiher()

}
</code></pre>
","7285299","","","","","2020-01-13 21:47:47","Refresh token with SwiftUI Combine","<swift><swiftui><combine>","1","1","2","","","CC BY-SA 4.0"
"59725439","1","59773983","","2020-01-13 23:02:40","","0","736","<p>I've never come across a witness table error before but this is my first venture into testing custom Publishers and, if I was to guess, I suspect there is something weird and wonderful going on with threading based on how mangled the witness name is. Completely out at sea here so a pointer (or pointers!) would be much appreciated.</p>

<p><strong>Custom publisher</strong></p>

<pre><code>// MARK: Custom publisher - produces a stream of Object arrays in response to change notifcations on a given Realm collection
extension Publishers {
    struct Realm&lt;Collection: RealmCollection&gt;: Publisher {
        typealias Output = Array&lt;Collection.Element&gt;
        typealias Failure = Never // TODO: Not true but deal with this later

        let collection: Collection

        init(collection: Collection) {
            self.collection = collection
        }

        func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
            let subscription = RealmSubscription(subscriber: subscriber, collection: collection)
            subscriber.receive(subscription: subscription)
        }
    }
}

// MARK: Convenience accessor function to the custom publisher
extension Publishers {
    static func realm&lt;Collection: RealmCollection&gt;(collection: Collection) -&gt; Publishers.Realm&lt;Collection&gt; {
        return Publishers.Realm(collection: collection)
    }
}

// MARK: Custom subscription
private final class RealmSubscription&lt;S: Subscriber, Collection: RealmCollection&gt;: Subscription where S.Input == Array&lt;Collection.Element&gt; {
    private var subscriber: S?
    private let collection: Collection
    private var notificationToken: NotificationToken?

    init(subscriber: S, collection: Collection) {
        self.subscriber = subscriber
        self.collection = collection

        self.notificationToken = collection.observe { (changes: RealmCollectionChange) in
            switch changes {
            case .initial:
                // Results are now populated and can be accessed without blocking the UI
                print(""Initial"")
                let _ = subscriber.receive(Array(collection.elements)) // ERROR THROWN HERE 
            //            case .update(_, let deletions, let insertions, let modifications):
            case .update(_, _, _, _):
                print(""Updated"")
                let _ = subscriber.receive(Array(collection.elements))
            case .error(let error):
                fatalError(""\(error)"")
                #warning(""Impl error handling - do we want to fail or log and recover?"")
            }
        }
    }

    func request(_ demand: Subscribers.Demand) {
        // no impl as RealmSubscriber is effectively just a sink
    }

    func cancel() {
        print(""Cancel called on RealnSubscription"")
        subscriber = nil
        notificationToken = nil
    }
}
</code></pre>

<p><strong>Service class</strong></p>

<pre><code>protocol RealmServiceType {
    func all&lt;Element&gt;(_ type: Element.Type, within realm: Realm) -&gt; AnyPublisher&lt;Array&lt;Element&gt;, Never&gt; where Element: Object

    @discardableResult
    func addPatient(_ name: String, to realm: Realm) throws -&gt; AnyPublisher&lt;Patient, Never&gt;

    func deletePatient(_ patient: Patient, from realm: Realm)
}

extension RealmServiceType {
    func all&lt;Element&gt;(_ type: Element.Type) -&gt; AnyPublisher&lt;Array&lt;Element&gt;, Never&gt; where Element: Object {
        print(""Called \(#function)"")
        return all(type, within: try! Realm())
    }
}

final class TestRealmService: RealmServiceType {
    private let patients = [
        Patient(name: ""Tiddles""), Patient(name: ""Fang""), Patient(name: ""Phoebe""), Patient(name: ""Snowy"")
    ]

    init() {
        let realm = try! Realm()
        guard realm.isEmpty else { return }
        try! realm.write {
            for p in patients {
                realm.add(p)
            }
        }
    }

    func all&lt;Element&gt;(_ type: Element.Type, within realm: Realm) -&gt; AnyPublisher&lt;Array&lt;Element&gt;, Never&gt; where Element: Object {
        return Publishers.realm(collection: realm.objects(type).sorted(byKeyPath: ""name"")).eraseToAnyPublisher()
    }


    func addPatient(_ name: String, to realm: Realm) throws -&gt; AnyPublisher&lt;Patient, Never&gt; {
        let patient = Patient(name: name)
        try! realm.write {
            realm.add(patient)
        }
        return Just(patient).eraseToAnyPublisher()
    }

    func deletePatient(_ patient: Patient, from realm: Realm) {
        try! realm.write {
            realm.delete(patient)
        }
    }

}
</code></pre>

<p><strong>Test case</strong></p>

<pre><code>class AthenaVSTests: XCTestCase {
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private var service: RealmServiceType?

    override func setUp() {
        service = TestRealmService()
    }

    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        service = nil
        cancellables.removeAll()
    }

    func testRealmPublisher() {
        var outcome = [""""]
        let expectation = self.expectation(description: #function)
        let expected = [""Tiddles"", ""Fang"", ""Phoebe"", ""Snowy""]

        let _ = service?.all(Patient.self)
            .sink(receiveCompletion: { _ in
                expectation.fulfill() },
                  receiveValue: { value in
                    outcome += value.map { $0.name }
            })
            .store(in: &amp;cancellables)

        waitForExpectations(timeout: 2, handler: nil)

        XCTAssert(outcome == expected, ""Expected \(expected) Objects but got \(outcome)"")
    }
}
</code></pre>

<p><strong>Error message</strong></p>

<p>failed to demangle witness for associated type 'Iterator' in conformance 'RealmSwift.Results: Sequence' from mangled name '10RealmSwift11RLMIteratorVyxG'
2020-01-13 22:46:07.159964+0000 AthenaVS[3423:171342] failed to demangle witness for associated type 'Iterator' in conformance 'RealmSwift.Results: Sequence' from mangled name '10RealmSwift11RLMIteratorVyxG'</p>

<p>The error is thrown when attempting to execute code in the Realm notification observer within RealmSubscription (I've flagged it in the code above), specifically:</p>

<pre><code>let _ = subscriber.receive(Array(collection.elements))
</code></pre>

<p>Ideas?</p>
","2733214","","","","","2020-01-16 16:27:56","Failed to demangle witness error when using Realm in a custom Publisher","<swift><realm><combine>","1","5","","","","CC BY-SA 4.0"
"59728852","1","59729053","","2020-01-14 06:58:52","","2","652","<p>@Published ObservedObjects SwiftUI Updates not Happening</p>

<p>I have created a very basic ObservableObject app and some bindings are updated
correctly and some are not. I must be missing something simple. Two views only - the
start view and a second view. I only use Text, Button and Toggle - just to test 
this concept.</p>

<p>I want to store startup property values in UserDefaults. That part seems to work
fine. When I make changes on the second page, they are updated on that page, and the
UserDefaults are correctly written. However, on returning to the start view, the
Published bindings are not updated. Interestingly, the UserDefaults are updated.</p>

<p>The main view simply displays the values of the bindings and user defaults. </p>

<p>The start view:</p>

<pre><code>import SwiftUI

struct ContentView: View {
    @State private var showUtilities = false
    @ObservedObject var userDefaultManager = UserDefaultsManager()

    var body: some View {
        NavigationView {
            VStack{
                Group { //group 1
                    Text(""Published userDefaultManager.name:"")
                    Text(""\(UserUtilities().makeSubString(stringIn: self.userDefaultManager.name, count: 24))"")
                        .padding(.bottom, 30)
                        .lineLimit(0)

                    Text(""UserDefaults.standard.value:"")
                    Text(""\(UserUtilities().makeSubString(stringIn: UserDefaults.standard.value(forKey: ""name"") as! String, count: 24))"")
                    .padding(.bottom, 30)
                    .lineLimit(0)

                    Text(""Published userDefaultsManager.enableBiometrics:"")
                    Text(String(self.userDefaultManager.enableBiometrics))
                        .padding(.bottom, 30)
                        .font(.headline)
                } //group 1

                Group { //group 2
                    Text(""UserDefaults.standard.bool:"")
                    Text(String(UserDefaults.standard.bool(forKey: AppDelegate.eb)))
                        .padding(.bottom, 30)
                        .font(.headline)
                    Button(action: {
                        self.showUtilities.toggle()
                    }) {
                        Text(""Show Utilities"")
                    }
                    .frame(width: 200)
                    .padding()
                    .font(.headline)
                }//group 2

            }//vstack
            .navigationBarTitle(""Read the Values"")
            .sheet(isPresented: $showUtilities) {
                UserUtilities()
            }
        }
    }
}
</code></pre>

<p>The second view: </p>

<pre><code>import SwiftUI
import Combine

struct UserUtilities: View {
    @ObservedObject var userDefaultManager = UserDefaultsManager()

    var body: some View {
        NavigationView {
            VStack {
                Toggle(isOn: self.$userDefaultManager.enableBiometrics) {
                    Text(""Enable Biometric Login"")
                }
                .padding(EdgeInsets(top: 50, leading: 50, bottom: 30, trailing: 50))

                //this does not update
                Text(""Published name is \(UserUtilities().makeSubString(stringIn: self.userDefaultManager.name, count: 24))"")
                    .padding(EdgeInsets(top: 0, leading: 0, bottom: 30, trailing: 0))

                Text(""UserDefaults name is \(UserUtilities().makeSubString(stringIn: UserDefaults.standard.value(forKey: ""name"") as! String, count: 24))"")
                    .padding(EdgeInsets(top: 0, leading: 0, bottom: 30, trailing: 0))

                \\this does not update
                Text(""Published enableBiometrics is ""  + String(self.userDefaultManager.enableBiometrics) )

                Text(""UserDefaults is "" + String(UserDefaults.standard.bool(forKey: AppDelegate.eb)) )
                    .padding(.bottom, 20)

                Button(action: {
                    self.userDefaultManager.name = UUID().uuidString
                }) {
                    Text(""Change the Published name"")
                }
                .padding()
                .font(.headline)

            }
            .navigationBarTitle(""User Utilities"", displayMode: .inline)
        }
    }//body

    func makeSubString(stringIn: String, count: Int) -&gt; String {
        if stringIn.count &gt; count {
            let modString = stringIn.dropFirst(count)
            let returnString = String(modString)
            return returnString
        }
        return ""can't get substring""
    }
}
</code></pre>

<p>My UserDefault Manager:</p>

<pre><code>import SwiftUI
import Combine

class UserDefaultsManager: ObservableObject {
    @Published var name = UserDefaults.standard.value(forKey: ""name"") as! String {
           didSet {
               UserDefaults.standard.set(self.name, forKey: ""name"")
           }
    }

    @Published var enableBiometrics: Bool = UserDefaults.standard.bool(forKey: AppDelegate.eb) {
        didSet {
            UserDefaults.standard.set(self.enableBiometrics, forKey: AppDelegate.eb)
        }
    }
}
</code></pre>

<p>And for completeness - in the AppDelegate:</p>

<pre><code>static let eb = ""enablebiometrics""
@ObservedObject var userDefaultManager = UserDefaultsManager()
</code></pre>

<p>In didFinishLaunchingWithOptions:</p>

<pre><code>    if UserDefaults.standard.value(forKey: AppDelegate.eb) == nil {
        UserDefaults.standard.set(false, forKey: AppDelegate.eb)
    }

    userDefaultManager.enableBiometrics = UserDefaults.standard.bool(forKey: AppDelegate.eb)

    if UserDefaults.standard.value(forKey: ""name"") == nil {
        UserDefaults.standard.set(""set in AppDelegate"", forKey: ""name"")
    }

    userDefaultManager.name = UserDefaults.standard.value(forKey: ""name"") as! String
</code></pre>

<p>Any guidance would be appreciated. Xcode 11.3 (11C29)</p>
","2698617","","286618","","2020-01-15 20:38:49","2020-01-15 20:38:49","@Published ObservedObjects SwiftUI Updates not Happening","<xcode><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"59741924","1","","","2020-01-14 21:18:50","","0","331","<p><strong>Scenario:</strong><br/>
I'm using an Observable Class to acquire data from the network. <br/>
In this case some elementary weather data.
<p>
<strong>Problem:</strong>
<br/>
I don't know how to display this data in the calling View.
<p>
For the time-being, I merely am trying to populate a Textfield (and worry about more-eleborate layout later).
<p>
I get the following:</p>

<blockquote>
  <p>.../StandardWeatherView.swift:22:13: Cannot invoke initializer for
  type 'TextField&lt;_>' with an argument list of type '(Text, text:
  Sample?)'</p>
</blockquote>

<p>Here's is my calling View which is the receiver of @ObservedObject data:
<p></p>

<pre><code>import SwiftUI

struct StandardWeatherView: View {
    @EnvironmentObject var settings: Settings
    @ObservedObject var standardWeatherReportLoader = StandardWeatherReportLoader()

    init() {
        self.standardWeatherReportLoader.doStandard()
    }

    var body: some View {
        ZStack {
            Color(""FernGreen"").edgesIgnoringSafeArea(.all)
            TextField(Text(""Weather Data""), text: standardWeatherReportLoader.weatherReport)
        }
    }
}

struct StandardWeatherView_Previews: PreviewProvider {
    static var previews: some View {
        StandardWeatherView()
    }
}
</code></pre>

<p><p>
Here's the publisher, acquiring data:</p>

<pre><code>import Foundation

class StandardWeatherReportLoader: ObservableObject {
    @Published var networkMessage: String?
    @Published var hasAlert = false
    @Published var weatherReport: Sample?
    @Published var hasReport = false

    func doStandard() {
        let url = EndPoint.weather.path()
        var request = URLRequest(url: EndPoint.weather.path()!)
        request.httpMethod = ""GET""
        request.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")

        let task = URLSession.shared.dataTask(with: url!) { (data: Data?, _: URLResponse?, error: Error?) -&gt; Void in
            DispatchQueue.main.async {
                guard error == nil else {
                    self.networkMessage = error?.localizedDescription
                    self.hasAlert = true
                    return
                }

                do {
                    let decoder = JSONDecoder()
                    decoder.keyDecodingStrategy = .convertFromSnakeCase
                    let result = try decoder.decode(Sample.self, from: data!)
                    self.weatherReport = result
                    self.hasReport = true
                    print(""\n Standard Weather ----------------"")
                    print(#function, ""line: "", #line, ""Result: "",result)
                    print(""\n"")
                } catch let error as NSError {
                    print(error)
                }
            }
        }
        task.resume()
    }
}
</code></pre>

<p><p>
What's the simplest way of passing a string of data to the View via @Published var?
<p>
Log: <p></p>

<blockquote>
  <p>Standard Weather ---------------- doStandard() line:  38 Result: 
  Sample(coord: DataTaskPubTab.Coord(lon: -0.13, lat: 51.51), weather:
  [DataTaskPubTab.Weather(id: 300, main: ""Drizzle"", description: ""light
  intensity drizzle"")], base: ""stations"", main:
  DataTaskPubTab.Main(temp: 280.32, pressure: 1012, humidity: 81,
  tempMin: 279.15, tempMax: 281.15), visibility: 10000, wind:
  DataTaskPubTab.Wind(speed: 4.1, deg: 80), clouds:
  DataTaskPubTab.Clouds(all: 90), dt: 1485789600.0, id: 2643743, name:
  ""London"")</p>
</blockquote>

<p><p>
But I'm getting nil at the TextField:</p>

<blockquote>
  <p>(lldb) po standardWeatherReportLoader.weatherReport  nil</p>
</blockquote>
","715747","","715747","","2020-01-14 21:41:23","2020-01-14 21:56:32","Simplest way to pass @Published data to a Textfield()?","<swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"59743938","1","59829746","","2020-01-15 01:14:12","","31","8507","<p>How do I get the asynchronous pipelines that constitute the Combine framework to line up synchronously (serially)?</p>

<p>Suppose I have 50 URLs from which I want to download the corresponding resources, and let's say I want to do it one at a time. I know how to do that with Operation / OperationQueue, e.g. using an Operation subclass that doesn't declare itself finished until the download is complete. How would I do the same thing using Combine?</p>

<p>At the moment all that occurs to me is to keep a global list of the remaining URLs and pop one off, set up that one pipeline for one download, do the download, and in the <code>sink</code> of the pipeline, repeat. That doesn't seem very Combine-like.</p>

<p>I did try making an array of the URLs and map it to an array of publishers. I know I can ""produce"" a publisher and cause it to publish on down the pipeline using <code>flatMap</code>. But then I'm still doing all the downloading simultaneously. There isn't any Combine way to walk the array in a controlled manner — or is there?</p>

<p>(I also imagined doing something with Future but I became hopelessly confused. I'm not used to this way of thinking.)</p>
","341994","","","","","2021-03-22 15:15:32","Combine framework serialize async operations","<ios><swift><combine>","8","0","11","","","CC BY-SA 4.0"
"59767427","1","59812117","","2020-01-16 10:19:10","","5","1901","<p>I am working with a web API which delivers results up to a given limit (<code>pageSize</code> parameter of the request). If the number of results surpasses this limit, the response message is pre-populated with an URL to which the follow-up request can be made to fetch more results. If there are even more results, this is again indicated in the same manner.</p>

<p>My intend is to fetch all results at once.</p>

<hr/>

<p>Currently I have something like the following request and response structures:</p>

<pre class=""lang-swift prettyprint-override""><code>// Request structure
struct TvShowsSearchRequest {
    let q: String
    let pageSize: Int?
}

// Response structure
struct TvShowsSearchResponse: Decodable {
    let next: String?
    let total : Int
    let searchTerm : String
    let searchResultListShow: [SearchResult]?
}
</code></pre>

<p>When resolving the problem '<strong>old style</strong>' using completion handlers, I had to write a handler, which is triggering a 'handle more' request with the URL of the response:</p>

<pre class=""lang-swift prettyprint-override""><code>func handleResponse(request: TvShowsSearchRequest, result: Result&lt;TvShowsSearchResponse, Error&gt;) -&gt; Void {
    switch result {
    case .failure(let error):
        fatalError(error.localizedDescription)
    case .success(let value):
        print(""&gt; Total number of shows matching the query: \(value.total)"")
        print(""&gt; Number of shows fetched: \(value.searchResultListShow?.count ?? 0)"")

        if let moreUrl = value.next {
            print(""&gt; URL to fetch more entries \(moreUrl)"")

            // start recursion here: a new request, calling the same completion handler...
            dataProvider.handleMore(request, nextUrl: moreUrl, completion: handleResponse)
        }
    }
}

let request = TvShowsSearchRequest(query: ""A"", pageSize: 50)
dataProvider.send(request, completion: handleResponse)
</code></pre>

<p>Internally the <code>send</code> and <code>handleMore</code> functions are both calling the same <code>internalSend</code> which is taking the <code>request</code> and the <code>url</code>, to call afterwards <code>URLSession.dataTask(...)</code>, check for HTTP errors, decode the response and call the completion block.</p>

<hr/>

<p>Now I want to use the Combine framework and use a Publisher which is providing the paged responses automatically, without the need to call for another Publisher.</p>

<p>I have therefore written a <code>requestPublisher</code> function which takes <code>request</code> and the (initial) <code>url</code> and returns a <code>URLSession.dataTaskPublisher</code> which checks for HTTP errors (using <code>tryMap</code>), <code>decode</code> the response.</p>

<p>Now I have to ensure that the Publisher automatically ""renews"" itself whenever the last emitted value had a valid <code>next</code> URL and the completion event occurs.</p>

<p>I've found that there is a <code>Publisher.append</code> method which would exactly do this, but the problem I had so far: I want to append only under a certain condition (=valid <code>next</code>).</p>

<p>The following pseudo-code illustrates it:</p>

<pre class=""lang-swift prettyprint-override""><code>func requestPublisher(for request: TvShowsSearchRequest, with url: URL) -&gt; AnyPublisher&lt;TvShowsSearchResponse, Error&gt; {
    // ... build urlRequest, skipped here ...

    let apiCall = self.session.dataTaskPublisher(for: urlRequest)
        .tryMap { data, response -&gt; Data in
            guard let httpResponse = response as? HTTPURLResponse else {
                throw APIError.server(message: ""No HTTP response received"")
            }
            if !(200...299).contains(httpResponse.statusCode) {
                throw APIError.server(message: ""Server respondend with status: \(httpResponse.statusCode)"")
            }
            return data
        }
        .decode(type: TvShowsSearchResponse.self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
    return apiCall
}


// Here I'm trying to use the Combine approach

var moreURL : String?

dataProvider.requestPublisher(request)
    .handleEvents(receiveOutput: {
        moreURL = $0.next   // remember the ""next"" to fetch more data
    })
    .append(dataProvider.requestPublisher(request, next: moreURL))  // this does not work, because moreUrl was not prepared at the time of creation!!
    .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) })
    .store(in: &amp;cancellableSet)
</code></pre>

<p>I suppose there are people out there who have already resolved this problem in a reactive way. Whenever I find a doable solution, it involves again recursion. I don't think this is how a proper solution should look like.</p>

<p>I'm looking for a Publisher which is sending the responses, without me providing a callback function. Probably there must be a solution using Publisher of Publishers, but I'm not yet understanding it.</p>

<hr/>

<p>After the comment of @kishanvekariya I've tried to build everything with multiple publishers:</p>

<ol>
<li><p>The <code>mainRequest</code> publisher which is getting the response to the ""main"" request.</p></li>
<li><p>A new <code>urlPublisher</code> which is receiving all the <code>next</code> URLs of the ""main"" or any follow-up requests.</p></li>
<li><p>A new <code>moreRequest</code> publisher which is fetching for each value of <code>urlPublisher</code> a new request, sending all <code>next</code> URLs back to the <code>urlPublisher</code>.</p></li>
</ol>

<p>Then I tried to attach the <code>moreRequest</code> publisher to the <code>mainRequest</code>  with <code>append</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>var urlPublisher = PassthroughSubject&lt;String, Error&gt;()

var moreRequest = urlPublisher
    .flatMap {
        return dataProvider.requestPublisher(request, next: $0)
            .handleEvents(receiveOutput: {
                if let moreURL = $0.next {
                    urlPublisher.send(moreURL)
                }
            })
    }

var mainRequest = dataProvider.requestPublisher(request)
    .handleEvents(receiveOutput: {
        if let moreURL = $0.next {
            urlPublisher.send(moreURL)
        }
    })
    .append(moreRequest)
    .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) })
    .store(in: &amp;cancellableSet)
</code></pre>

<p>But this still does not work... I always get the result of the ""main"" request. All follow up requests are missing.</p>
","6238009","","6238009","","2020-01-16 20:54:57","2021-09-23 06:00:43","What Combine operator/approach can be used to load all pages of ""paged API""?","<ios><swift><combine>","2","3","0","","","CC BY-SA 4.0"
"59774678","1","","","2020-01-16 17:10:58","","0","242","<p>I'm building a SwiftUI app that is using the MVVM pattern. The data source for the view models is provided by a custom Publisher for a Realm database. As I'm trying to be good and do a bit of test-driven development, I wrote a test to ensure that the view model responds appropriately to inputs from the SwiftUI front end (specifically in this instance, only querying the Realm once the UI was displayed). The code functions as expected but the test doesn't...</p>

<p>This is almost certainly because I'm not accounting for background processing / thread issues. My normal approach would to set up an expectation but this doesn't help as I need to use the property I'm interested in to create a Publisher but this completes immediately after emitting the initial state and I don't know how to keep it ""alive"" until the expectation expires. Can anyone point me in the right direction?</p>

<p><strong>View model:</strong></p>

<pre><code>final class PatientListViewModel: ObservableObject, UnidirectionalDataFlowType {
    typealias InputType = Input

    enum Input {
        case onAppear
    }

    private var cancellables = Set&lt;AnyCancellable&gt;()
    private let onAppearSubject = PassthroughSubject&lt;Void, Never&gt;()

    // MARK: Output
    @Published private(set) var patients: [Patient] = []

    // MARK: Private properties
    private let realmSubject = PassthroughSubject&lt;Array&lt;Patient&gt;, Never&gt;()
    private let realmService: RealmServiceType

    // MARK: Initialiser
    init(realmService: RealmServiceType) {
        self.realmService = realmService
        bindInputs()
        bindOutputs()
    }

    // MARK: ViewModel protocol conformance (functional)
    func apply(_ input: Input) {
        switch input {
        case .onAppear:
            onAppearSubject.send()
        }
    }

    // MARK: Private methods
    private func bindInputs() {
        let _ = onAppearSubject
            .flatMap { [realmService] _ in realmService.all(Patient.self) }
            .share()
            .eraseToAnyPublisher()
            .receive(on: RunLoop.main)
            .subscribe(realmSubject)
            .store(in: &amp;cancellables)
    }

    private func bindOutputs() {
        let _ = realmSubject
            .assign(to: \.patients, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>

<p><strong>Test class: (very bulky due to my debugging code!)</strong></p>

<pre><code>import XCTest
import RealmSwift
import Combine

@testable import AthenaVS

class AthenaVSTests: XCTestCase {
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private var service: RealmServiceType?

    override func setUp() {
        service = TestRealmService()
    }

    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        service = nil
        cancellables.removeAll()
    }

        func testPatientListViewModel() {
            let viewModel = PatientListViewModel(realmService: service!)
            let expectation = self.expectation(description: #function)
            var outcome = Array&lt;Patient&gt;()

            let _ = viewModel.patients.publisher.collect()
               .handleEvents(receiveSubscription: { (subscription) in
                    print(""Receive subscription"")
                }, receiveOutput: { output in
                    print(""Received output: \(output)"")
                    outcome = output
                }, receiveCompletion: { _ in
                    print(""Receive completion"")
                    expectation.fulfill()
                }, receiveCancel: {
                    print(""Receive cancel"")
                    expectation.fulfill()
                }, receiveRequest: { demand in
                    print(""Receive request: \(demand)"")})
                .sink { _ in }
            .store(in: &amp;cancellables)

            viewModel.apply(.onAppear)

            waitForExpectations(timeout: 2, handler: nil)
            XCTAssertEqual(outcome.count, 4, ""ViewModel state should change once triggered"")
        }
    }
</code></pre>

<p>EDITED:
My apologies for the lack of clarity. The rest of the code base is as follows:</p>

<p><strong>SwiftUI View</strong></p>

<pre><code>struct ContentView: View {
    @ObservedObject var viewModel: PatientListViewModel

    var body: some View {
        NavigationView {

            List {
                ForEach(viewModel.patients) { patient in
                    Text(patient.name)
                }
                .onDelete(perform: delete )
            }
            .navigationBarTitle(""Patients"")
            .navigationBarItems(trailing:
                Button(action: { self.viewModel.apply(.onAdd) })
                { Image(systemName: ""plus.circle"")
                    .font(.title)
                }
            )

        }
        .onAppear(perform: { self.viewModel.apply(.onAppear) })
    }

    func delete(at offset: IndexSet) {
        viewModel.apply(.onDelete(offset))
    }
}
</code></pre>

<p><strong>Realm Service</strong></p>

<pre><code>protocol RealmServiceType {
    func all&lt;Element&gt;(_ type: Element.Type, within realm: Realm) -&gt; AnyPublisher&lt;Array&lt;Element&gt;, Never&gt; where Element: Object

    @discardableResult
    func addPatient(_ name: String, to realm: Realm) throws -&gt; AnyPublisher&lt;Patient, Never&gt;

    func deletePatient(_ patient: Patient, from realm: Realm)
}

extension RealmServiceType {
    func all&lt;Element&gt;(_ type: Element.Type) -&gt; AnyPublisher&lt;Array&lt;Element&gt;, Never&gt; where Element: Object {
        all(type, within: try! Realm())
    }

    func deletePatient(_ patient: Patient) {
        deletePatient(patient, from: try! Realm())
    }
}

final class TestRealmService: RealmServiceType {
    private let patients = [
        Patient(name: ""Tiddles""), Patient(name: ""Fang""), Patient(name: ""Phoebe""), Patient(name: ""Snowy"")
    ]

    init() {
        let realm = try! Realm()
        guard realm.isEmpty else { return }
        try! realm.write {
            for p in patients {
                realm.add(p)
            }
        }
    }

    func all&lt;Element&gt;(_ type: Element.Type, within realm: Realm) -&gt; AnyPublisher&lt;Array&lt;Element&gt;, Never&gt; where Element: Object {
        return Publishers.realm(collection: realm.objects(type).sorted(byKeyPath: ""name"")).eraseToAnyPublisher()
    }


    func addPatient(_ name: String, to realm: Realm) throws -&gt; AnyPublisher&lt;Patient, Never&gt; {
        let patient = Patient(name: name)
        try! realm.write {
            realm.add(patient)
        }
        return Just(patient).eraseToAnyPublisher()
    }

    func deletePatient(_ patient: Patient, from realm: Realm) {
        try! realm.write {
            realm.delete(patient)
        }
    }

}
</code></pre>

<p><strong>Custom Publisher (using Realm as a backend)</strong></p>

<pre><code>/ MARK: Custom publisher - produces a stream of Object arrays in response to change notifcations on a given Realm collection
extension Publishers {
    struct Realm&lt;Collection: RealmCollection&gt;: Publisher {
        typealias Output = Array&lt;Collection.Element&gt;
        typealias Failure = Never // TODO: Not true but deal with this later

        let collection: Collection

        init(collection: Collection) {
            self.collection = collection
        }

        func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
            let subscription = RealmSubscription(subscriber: subscriber, collection: collection)
            subscriber.receive(subscription: subscription)
        }
    }
}

// MARK: Convenience accessor function to the custom publisher
extension Publishers {
    static func realm&lt;Collection: RealmCollection&gt;(collection: Collection) -&gt; Publishers.Realm&lt;Collection&gt; {
        return Publishers.Realm(collection: collection)
    }
}

// MARK: Custom subscription
private final class RealmSubscription&lt;S: Subscriber, Collection: RealmCollection&gt;: Subscription where S.Input == Array&lt;Collection.Element&gt; {
    private var subscriber: S?
    private let collection: Collection
    private var notificationToken: NotificationToken?

    init(subscriber: S, collection: Collection) {
        self.subscriber = subscriber
        self.collection = collection

        self.notificationToken = collection.observe { (changes: RealmCollectionChange) in
            switch changes {
            case .initial:
                // Results are now populated and can be accessed without blocking the UI
                let _ = subscriber.receive(Array(collection.elements))
            //            case .update(_, let deletions, let insertions, let modifications):
            case .update(_, _, _, _):
                let _ = subscriber.receive(Array(collection.elements))
            case .error(let error):
                fatalError(""\(error)"")
                #warning(""Impl error handling - do we want to fail or log and recover?"")
            }
        }
    }

    func request(_ demand: Subscribers.Demand) {
        // no impl as RealmSubscriber is effectively just a sink
    }

    func cancel() {
        subscriber = nil
        notificationToken = nil
    }
}
</code></pre>

<p>The issue I'm experiencing is a failure of the test case. I am anticipating the the view model will map an input (.onAppear) from the SwiftUI front end into an array of 'Patients' and assign this array to its <code>patients</code> property. The code works as expected but XCTAssertEqual fails, reporting that the 'patients' property is an empty array after calling 'viewmodel.assign(.onAppear)'. If I put a property observer on 'patients' it does update as expected but the test is not ""seeing"" the this. </p>
","2733214","","2733214","","2020-01-17 08:37:53","2020-01-17 08:37:53","Testing view models that rely on an asynchronous data source","<swift><realm><swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"59779479","1","","","2020-01-16 23:51:48","","0","55","<p>I'm trying to display data from an observed object.
<p>
Initially I tried to keep it simple, to merely display one member of a struct: 'base' (value: ""stations""). <br/></p>

<pre><code>struct Sample: Codable {
    let coord: Coord
    let weather: [Weather]
    let base: String
    let main: Main
    let visibility: Int
    let wind: Wind
    let clouds: Clouds
    let dt: Double
//    let sys: Sys
    let id: Int
    let name: String
//    let cod: Int
}
</code></pre>

<p>I did some defensive coding with '?' but I got the following compiler error: <p></p>

<p><a href=""https://i.stack.imgur.com/AKPvT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AKPvT.png"" alt=""enter image description here""></a></p>

<p><p>
So I replaced the '?' with '!', knowing that I should have some data. <p></p>

<p><a href=""https://i.stack.imgur.com/bHmFP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bHmFP.png"" alt=""enter image description here""></a>
<p>
I find this frustrating, coming from an imperative-paradigm background.
<br/>
What am I doing wrong?</p>

<p><p>
Here's the data dump: 

<blockquote>
  <p>Sample(coord: DataTaskPubTab.Coord(lon: -0.13, lat: 51.51), weather:
  [DataTaskPubTab.Weather(id: 300, main: ""Drizzle"", description: ""light
  intensity drizzle"")], base: ""stations"", main:
  DataTaskPubTab.Main(temp: 280.32, pressure: 1012, humidity: 81,
  tempMin: 279.15, tempMax: 281.15), visibility: 10000, wind:
  DataTaskPubTab.Wind(speed: 4.1, deg: 80), clouds:
  DataTaskPubTab.Clouds(all: 90), dt: 1485789600.0, id: 2643743, name:
  ""London"")</p>
</blockquote>

<p><p></p>

<p>Here's the Observable Object: <p></p>

<pre><code>class StandardWeatherReportLoader: ObservableObject {
    @Published var networkMessage: String?
    @Published var hasAlert = false
    @Published var weatherReport: Sample?
    @Published var hasReport = false

    func doStandard() {
        let url = EndPoint.weather.path()
        var request = URLRequest(url: EndPoint.weather.path()!)
        request.httpMethod = ""GET""
        request.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")

        let task = URLSession.shared.dataTask(with: url!) { (data: Data?, _: URLResponse?, error: Error?) -&gt; Void in
            DispatchQueue.main.async {
                guard error == nil else {
                    self.networkMessage = error?.localizedDescription
                    self.hasAlert = true
                    return
                }

                do {
                    let decoder = JSONDecoder()
                    decoder.keyDecodingStrategy = .convertFromSnakeCase
                    let result = try decoder.decode(Sample.self, from: data!)
                    self.weatherReport = result
                    self.hasReport = true
                    print(result)
                } catch let error as NSError {
                    print(error)
                }
            }
        }
        task.resume()
    }
}
</code></pre>

<p><p></p>
","715747","","","","","2020-01-24 17:30:48","Unable to extract data from Observable Object","<ios><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"59779962","1","59811596","","2020-01-17 01:13:06","","3","869","<p>The declarative syntax of Swift Combine looks odd to me and it appears that there is a lot going on that is not visible.</p>

<p>For example the following code sample builds and runs in an Xcode playground:</p>

<pre><code>[1, 2, 3]

.publisher
.map({ (val) in
        return val * 3
    })

.sink(receiveCompletion: { completion in
  switch completion {
  case .failure(let error):
    print(""Something went wrong: \(error)"")
  case .finished:
    print(""Received Completion"")
  }
}, receiveValue: { value in
  print(""Received value \(value)"")
})
</code></pre>

<p>I see what I assume is an array literal instance being created with [1, 2, 3].  I guess it is an array literal but I'm not accustomed to seeing it ""declared"" without also assigning it to a variable name or constant or using _=.</p>

<p>I've put in an intentional new line after and then .publisher.  Is Xcode ignoring the whitespace and newlines?  </p>

<p>Because of this style, or my newness to visually parsing this style, I mistakenly thought "", receiveValue:"" was a variadic parameter or some new syntax, but later realized it is actually an argument to .sink(...).</p>
","2246630","","2246630","","2020-01-18 00:42:59","2020-01-19 15:37:18","swift combine declarative syntax","<swift><variadic><combine>","2","2","","","","CC BY-SA 4.0"
"59787109","1","59797226","","2020-01-17 12:10:51","","3","2265","<p>I use the following piece of code to generate a cold <code>RxSwift Observable</code>:</p>

<pre><code>func doRequest&lt;T :Mappable&gt;(request:URLRequestConvertible) -&gt; Observable&lt;T&gt; {
        let observable = Observable&lt;T&gt;.create { [weak self] observer in
        guard let self = self else { return Disposables.create() }
        self.session.request(request).validate().responseObject { (response: AFDataResponse&lt;T&gt;) in
            switch response.result {
                case .success(let obj):
                    observer.onNext(obj)
                    observer.onCompleted()
                case .failure(let error):
                    let theError = error as Error
                    observer.onError(theError)
            }
        }
         return Disposables.create()
    }
    return observable
}
</code></pre>

<p>where <code>Mappable</code> is an <a href=""https://github.com/tristanhimmelman/ObjectMapper"" rel=""nofollow noreferrer"">ObjectMapper</a> based type, and <code>self.session</code> is an Alamofire's <code>Session</code> object.</p>

<p>I can't find an equivalent to <code>Observable.create {...}</code> in Apple's <code>Combine</code> framework. What I only found is <code>URLSession.shared.dataTaskPublisher(for:)</code> which creates a publisher using Apple's <code>URLSession</code> class.</p>

<p>How can I convert the above observable to an Alamofire Combine's publisher ?</p>

<p><strong>EDIT</strong>:
using the solution provided by rob, I ended up with the following:</p>

<pre><code> private let apiQueue = DispatchQueue(label: ""API"", qos: .default, attributes: .concurrent)

  func doRequest&lt;T&gt;(request: URLRequestConvertible) -&gt; AnyPublisher&lt;T, AFError&gt; where T : Mappable {

       Deferred { [weak self] () -&gt; Future&lt;T, AFError&gt; in

          guard let self = self else {
              return Future&lt;T, AFError&gt; { promise in  
promise(.failure(.explicitlyCancelled))  }
        }

          return Future { promise in
            self.session
            .request(request)
            .validate()
            .responseObject { (response: AFDataResponse&lt;T&gt;) in
                promise(response.result)
            }
        }
    }
    .handleEvents(receiveCompletion: { completion in
        if case .failure (let error) = completion {
                //handle the error
        }
    })
    .receive(on: self.apiQueue)
    .eraseToAnyPublisher()
}
</code></pre>

<p><strong>EDIT2:</strong> I have to remove the private queue since it's not needed, Alamofire does the parsing the decoding on its own, so remove the queue and its usages (<code>.receive(on: self.apiQueue)</code>)</p>
","1056118","","1056118","","2020-01-22 05:06:09","2020-01-22 05:06:09","Creating a Combine's publisher like RxSwift's Observable.Create for an Alamofire request","<ios><swift><alamofire><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"59792756","1","59793389","","2020-01-17 18:06:26","","5","3236","<p>I'm trying to write a custom Combine <code>Publisher</code> that will send decibel and timestamps from an <code>AVAudioEngine</code> tap. After going through numerous tutorials and the WWDC videos, I <em>still</em> can't find an example of how a <code>Publisher</code> keeps track of the <code>Subscriber</code>s that have subscribed to it.</p>

<pre><code>public typealias AudioVolume = Double

public struct AudioVolumePublisher: Publisher {
    public typealias Output = AudioVolume
    public typealias Failure = Error
}

public class AudioVolumeSubscription&lt;S: Subscriber&gt;: NSObject, Subscription {
    private var subscriber: S?
    public var combineIdentifier = CombineIdentifier()

    public init(for subscriber: S) {
        self.subscriber = subscriber
    }

    public func request(_ demand: Subscribers.Demand) {
        ...
    }

    public func cancel() {
        subscriber = nil
    }
}

</code></pre>

<p>I assume that the <code>AudioVolumePublisher</code> should store a list of its active subscribers, but adding a property like</p>

<pre><code>var subscribers = [S]()
</code></pre>

<p>won't compile because <code>Subscriber</code> has associated types. Is this even the right approach to handling <code>Subscriber</code>s, and if so, what's the best way to store them? Is type erasure my only practical option?</p>
","665456","","665456","","2020-01-17 18:20:52","2020-01-17 20:08:21","Swift Combine custom Publisher: Storing a reference to an array of Subscribers?","<swift><combine>","1","1","2","","","CC BY-SA 4.0"
"59800861","1","59800885","","2020-01-18 13:03:50","","1","1170","<p>I have a strange problem with the SwiftUI Alert view. In an ObservableObject, I do some network requests and in case of a error I will show a alert. This is my simplified model:</p>

<pre class=""lang-swift prettyprint-override""><code>class MyModel: ObservableObject {
    let objectWillChange = ObservableObjectPublisher()

    @Published var isError: Bool = false

    public func network() {
        Service.call() {
            self.isError = true

            DispatchQueue.main.async {
                self.objectWillChange.send()
            }
        }
    }
}
</code></pre>

<p><code>Service.call</code> is a dummy for my network request. My view looks like:</p>

<pre class=""lang-swift prettyprint-override""><code>struct MyView: View {
    @ObservedObject var model: MyModel

    var body: some View {
        …
        .alert(isPresented: self.$model.isError) {
            print(""Error Alert"")
            return Alert(title: Text(""Alert""))
        }
    }
}
</code></pre>

<p>On the first call, everything works and the alert is shown. For all further calls,<code>print(""Error Alert"")</code> will be executed and <em>Error Alert</em> appears in the console, but the alert is not shown.</p>

<p>Does anyone have any idea why Alert is only shown once?</p>
","3941413","","3941413","","2020-01-18 13:25:31","2020-01-18 13:45:18","SwiftUI – Alert is only showing once","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"59809842","1","59827709","","2020-01-19 12:04:28","","2","851","<p>I'm currently building a SwiftUI app and used a networking library from github (<a href=""https://github.com/borchero/Squid"" rel=""nofollow noreferrer"">GitHub/Squid</a>) to implement the api calls. </p>

<p>It works fine except when the request fails, then the library internal debug messages indicate an error (404 in my test), but the Combine subscriber never receives a completion signal. </p>

<p>I created a new request that will try to fetch and decode the users of ""jsonplaceholder.typicode.com"".</p>

<pre><code>import Foundation
import Squid

struct GetUsersFromMockApiRequest: JsonRequest {
    typealias Result = [User]

    var routes: HttpRoute {
        [""users""]
    }
}
</code></pre>

<p>User is just a simple struct: </p>

<pre><code>struct User: Decodable {
    let id: Int
    let username: String
    let name: String
}
</code></pre>

<p>In my ApiRequestManager.swift file I declared a function to request the scheduling:</p>

<pre><code>public func getUsersFromMockApi() -&gt; Response&lt;GetUsersFromMockApiRequest&gt; {
    return GetUsersFromMockApiRequest().schedule(with: ApiService(apiUrl: ""jsonplaceholder.typicode.com""))
}
</code></pre>

<p>And in my view where I want to call the api, I have a cancellable set and a instance of the ApiRequestManager.</p>

<pre><code>@State private var cancellableSet: Set&lt;AnyCancellable&gt; = []
private let requestManager = ApiRequestManager()
</code></pre>

<p>Now the last step is to call a function on the press of a button which executes the following code:</p>

<pre><code>self.requestManager.getUsersFromMockApi()
  .print(""Debug:"")
  .sink(receiveCompletion: { completion in
    switch completion {
    case .failure:
      print(""ApiCall failed."")
    case .finished:
      print(""ApiCall finished."")
    }
  }) { result in
    print(""Received users from apiCall: \(result)"")
  }
  .store(in: &amp;cancellableSet)
</code></pre>

<p>If the api request is sucessfull, everything works out fine. But as soon as it hits any error the sink will get any signals / completion at all.</p>

<p>I tried to print every message that the subscriber received, breakOnError and also followed the library step by step to find out if he even throws an error. It does correctly check the HTTP response code against the accepted status codes in the schedule() function in the NetworkScheduler.swift file and throws a custom error <code>throw Squid.Error.requestFailed(statusCode: statusCode, response: response.data)</code> on line 285.</p>

<p>However with my lacking debug and combine knowledge I have a hard time following the throw afterwards. </p>
","12741764","","12741764","","2020-01-19 12:10:40","2020-01-20 16:47:23","Combine sink does not complete when publisher fails","<network-programming><swiftui><combine>","1","0","0","","","CC BY-SA 4.0"
"59829402","1","59970789","","2020-01-20 18:58:49","","1","709","<p>I have the following Problem:</p>

<pre><code>struct Item {
    var foo: Int

    init(_ iFoo: Int = 0){
        self.foo = iFoo
    }
}

class TestObject {
    @Published var items = [Item(1), Item(2), Item(3), Item(4)]

    private var avg:Double = 0.0{
        didSet{
            print(""didSet: avg: '\(self.avg)'"")
        }
    }

    private var cancellableSet: Set&lt;AnyCancellable&gt; = []
    private var isItemChangedPublisher: AnyPublisher&lt;[Item], Never&gt;{
        self.$items
            .eraseToAnyPublisher()
    }

    init(){
        self.isItemChangedPublisher
            .map{ items in
                var sum = 0
                for item in items{
                    sum += item.foo
                }
                return Double(sum)/Double(items.count)}
            .assign(to: \.avg, on: self)
            .store(in: &amp;cancellableSet)
    }

    func changeItem(at index: Int, to value: Int){
        if self.items.count &lt; index{
            self.items.append(Item(value))
        }else{
            self.items[index].foo = value
        }
    }

    func getAvg() -&gt; Double{
        //Request: Items changed --&gt; Change Value of avg here
        //Set Value of avg only if items has changed AND ""Request"" is called
        //  - don't set the new Value if Items has not changed and ""Request"" is called
        //  - don't set the new Value if Items has changed, but ""Request"" is not called
        return self.avg
    }
}

var bar = TestObject()

bar.changeItem(at: 2, to: 20)
bar.changeItem(at: 0, to: 3)

print(""1. avg: '\(bar.getAvg())'"")

bar.changeItem(at: 2, to: 20)

print(""2. avg: '\(bar.getAvg())'"")

bar.changeItem(at: 2, to: 30)

print(""3. avg: '\(bar.getAvg())'"")

bar.changeItem(at: 2, to: 20)
</code></pre>

<p>The Value of <code>var avg</code> is set every Time I change the items-Array. I understand that this is the intended behavior. </p>

<p>But is there any way to update the Variable <code>avg</code> only if the items-Array has changed AND something like a ""Request"" is called. 
If only the items have been changed the Variable <code>avg</code> should not be update, also if only the ""Request"" is called, but no items have been changed, the Variable shouldn't be updated.</p>

<p>I don't have any clue how to do this.</p>

<p>Do you have any idea to do this with the combine framework or with another solution?</p>

<p>Edit - 23.Jan.2020:</p>

<p>I could do something like that:</p>

<pre><code>import Combine

struct Item: Equatable {
    var foo: Int

    init(_ iFoo: Int = 0){
        self.foo = iFoo
    }
}

class TestObject {
    @Published var items = [Item(1), Item(2), Item(3), Item(4)]

    private var newAverage: Double? {
        didSet{
            print(""didSet: items changed --&gt; newAverage: '\(String(describing: self.newAverage))'"")
        }
    }

    private var average:Double = 0.0{
        didSet{
            print(""didSet: average: '\(self.average)'"")
        }
    }

    private var cancellable: AnyCancellable?
    private var isItemChangedPublisher: AnyPublisher&lt;[Item], Never&gt;{
        self.$items
            .eraseToAnyPublisher()
    }

    init(){
        cancellable = self.isItemChangedPublisher
            .removeDuplicates()
            .map{Double($0.map{$0.foo}.reduce(0, +))/Double($0.count)}
            .sink{self.newAverage = $0}
    }

    func changeItem(at index: Int, to value: Int){
        if self.items.count &lt; index{
            self.items.append(Item(value))
        }else{
            self.items[index].foo = value
        }
    }

    func getAverage() -&gt; Double{
        if self.newAverage != nil{
            self.average = self.newAverage!
            self.newAverage = nil
        }
        return self.average
    }
}

var bar = TestObject()

bar.changeItem(at: 2, to: 20)
bar.changeItem(at: 0, to: 20)
print(""1. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 1, to: 20)
print(""2. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 1, to: 20)
print(""3. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 3, to: 20)

/*
 prints:
 didSet: items changed --&gt; newAverage: 'Optional(2.5)'
 didSet: items changed --&gt; newAverage: 'Optional(6.75)'
 didSet: items changed --&gt; newAverage: 'Optional(11.5)'
 didSet: average: '11.5'
 didSet: items changed --&gt; newAverage: 'nil'
 1. avg: '11.5'
 didSet: items changed --&gt; newAverage: 'Optional(16.0)'
 didSet: average: '16.0'
 didSet: items changed --&gt; newAverage: 'nil'
 2. avg: '16.0'
 3. avg: '16.0'
 didSet: items changed --&gt; newAverage: 'Optional(20.0)'
 */
</code></pre>

<p>But, I'm still looking for a solution with combine only (without the dirty solution with the <code>newAverage</code> variable).</p>

<p>I also tried a solution with a custom DispatchQueue (it is just an attempt, not a good solution or idea):</p>

<pre><code>import Combine
import SwiftUI

struct Item: Equatable {
    var foo: Int

    init(_ iFoo: Int = 0){
        self.foo = iFoo
    }
}

struct MyQueue {
//    let queue = DispatchQueue(label: ""myQueue"", attributes: .concurrent, target: .global())
    let queue = DispatchQueue(label: ""myQueue"")

    init(){
        self.queue.suspend()
    }

    func releaseData(){
        self.queue.resume()
        self.queue.suspend()
    }
}

class TestObject {
    @Published var items = [Item(1), Item(2), Item(3), Item(4)]

    private var average:Double = 0.0{
        didSet{
            print(""didSet: average: '\(self.average)'"")
        }
    }

    private var cancellable: AnyCancellable?
    let myQueue = MyQueue()
    private var isItemChangedPublisher: AnyPublisher&lt;[Item], Never&gt;{
        self.$items
            .eraseToAnyPublisher()
    }

    init(){
        cancellable = self.isItemChangedPublisher
            .removeDuplicates()
            .map{ items in
                Double(items.map{ $0.foo }.reduce(0, +))/Double(items.count)}
            .buffer(size: 1, prefetch: .keepFull, whenFull: .dropOldest) //The Buffer changes nothing
            .receive(on: self.myQueue.queue)
            .assign(to: \.average, on: self)
    }

    func changeItem(at index: Int, to value: Int){
        if self.items.count &lt; index{
            self.items.append(Item(value))
        }else{
            self.items[index].foo = value
        }
    }

    func getAverage() -&gt; Double{
        self.myQueue.releaseData()
        return self.average
    }
}
var bar = TestObject()

bar.changeItem(at: 2, to: 20)
bar.changeItem(at: 0, to: 20)
print(""1. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 1, to: 20)
print(""2. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 1, to: 20)
print(""3. avg: '\(bar.getAverage())'"")
bar.changeItem(at: 3, to: 20)

/*
 Prints:

 didSet: average: '2.5'
 1. avg: '2.5'
 didSet: average: '6.75'
 didSet: average: '11.5'
 2. avg: '11.5'
 didSet: average: '16.0'
 3. avg: '16.0'


 But im looking for:

 didSet: average: '11.5' (because 2.5 and 6.5 are dropped)
 1. avg: '11.5'
 didSet: average: '16.0'
 2. avg: '16.0'
 3. avg: '16.0'
 */
</code></pre>

<p>but that doesn't work either...</p>
","12523385","","8160252","","2020-01-29 17:51:53","2020-01-31 09:37:35","Change Variable only if other Variables have changed and Update is requested","<ios><swift><combine>","1","4","0","","","CC BY-SA 4.0"
"59840437","1","","","2020-01-21 11:45:52","","6","5611","<p>Multiline text input is currently not natively supported in SwiftUI (hopefully this feature is added soon!) so I've been trying to use the combine framework to implement a UITextView from UIKit which does support multiline input, however i've been having mixed results.</p>

<p>This is the code i've created to make the Text view:</p>

<pre><code>struct MultilineTextView: UIViewRepresentable {

    @Binding var text: String


    func makeUIView(context: Context) -&gt; UITextView {
        let view = UITextView()
        view.isScrollEnabled = true
        view.isEditable = true
        view.isUserInteractionEnabled = true
        view.backgroundColor = UIColor.white
        view.textColor = UIColor.black
        view.font = UIFont.systemFont(ofSize: 17)
        view.delegate = context.coordinator
        return view
    }

    func updateUIView(_ uiView: UITextView, context: Context) {
        uiView.text = text
    }

    func frame(numLines: CGFloat) -&gt; some View {
        let height = UIFont.systemFont(ofSize: 17).lineHeight * numLines
        return self.frame(height: height)
    }

    func makeCoordinator() -&gt; MultilineTextView.Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, UITextViewDelegate {
        var parent: MultilineTextView

        init(_ parent: MultilineTextView) {
            self.parent = parent
        }

        func textViewDidChange(_ textView: UITextView) {
            parent.text = textView.text
        }
    }
}
</code></pre>

<p>I've then implemented it in a swiftUI view like:</p>

<pre><code>MultilineTextView(text: title ? $currentItem.titleEnglish : $currentItem.pairArray[currentPair].english)//.frame(numLines: 4)
</code></pre>

<p>And bound it to a state variable:</p>

<pre><code>@State var currentItem:Item
</code></pre>

<p>It sort of works. However, the state var currentItem:Item contains an array of strings which I'm then cycling through using buttons which update the string array based on what has been inputted into MultilineTextView. This is where i'm encountering a problem where the MultilineTextView seems to bind to only the first string item in the array, and then it won't change. When I use swiftUI's native TextField view this functionality works fine and I can cycle through the string array and update it by inputting text into the TextField.</p>

<p>I think I must be missing something in the MultilineTextView struct to allow this functionality. Any pointers are gratefully received.</p>

<p><strong>Update:</strong> Added model structs</p>

<pre><code>struct Item: Identifiable, Codable {
    let id = UUID()
    var completed = false
    var pairArray:[TextPair]
}

struct TextPair: Identifiable, Codable {
    let id = UUID()
    var textOne:String
    var textTwo:String
}
</code></pre>

<p><strong>Edit:</strong>
So I've done some more digging and I've found what I think is the problem. When the textViewDidChange of the UITextView is triggered, it does send the updated text which I can see in the console. The strange thing is that the updateUIView function then also gets triggered and it updates the UITextView's text with what was in the binding var before the update was sent via textViewDidChange. The result is that the UITextview just refuses to change when you type into it. The strange thing is that it works for the first String in the array, but when the item is changed it won't work anymore.</p>
","12603749","","12603749","","2020-01-21 14:13:47","2021-05-15 14:24:00","SwiftUI UIViewRepresentable UITextView Binding","<swiftui><combine>","2","7","2","","","CC BY-SA 4.0"
"59848687","1","","","2020-01-21 20:23:31","","7","4509","<p>I use the following <code>UIViewController</code> and <code>RxSwift/RxCocoa</code> based piece of code to write a very simply MVVM pattern to bind a <code>UIButton</code> tap event to trigger some <code>Observable</code> work and listen for the result:</p>

<pre><code>import UIKit
import RxSwift
import RxCocoa

class ViewController: UIViewController {

    @IBOutlet weak var someButton: UIButton!

    var viewModel: ViewModel!
    private var disposeBag = DisposeBag()

    override func viewDidLoad() {
        super.viewDidLoad()
        viewModel = ViewModel()
        setupBindings()
    }

    private func setupBindings() {
        someButton.rx.tap
        .bind(to: self.viewModel.input.trigger)
        .disposed(by: disposeBag)

        viewModel.output.result
            .subscribe(onNext: { element in
            print(""element is \(element)"")
            }).disposed(by: disposeBag)
    }
}

class ViewModel {

    struct Input {
        let trigger: AnyObserver&lt;Void&gt;
    }

    struct Output {
        let result: Observable&lt;String&gt;
    }

    let input: Input
    let output: Output

    private let triggerSubject = PublishSubject&lt;Void&gt;()

    init() {
        self.input = Input(trigger: triggerSubject.asObserver())
        let resultObservable = triggerSubject.flatMap { Observable.just(""TEST"") }
        self.output = Output(result: resultObservable)
    }
}
</code></pre>

<p>It compiles and runs well. However, I need to <code>Combin</code>ify this pattern with <code>SwiftUI</code>, so I converted that code into the following:</p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    var viewModel: ViewModel
    var subscriptions = Set&lt;AnyCancellable&gt;()

    init(viewModel: ViewModel) {
        self.viewModel = viewModel
        setupBindings()
    }

    var body: some View {

        Button(action: {
            // &lt;---- how to trigger viewModel's trigger from here
        }, label: {
            Text(""Click Me"")
        })
    }

    private func setupBindings() {
        self.viewModel.output.result.sink(receiveValue: { value in
            print(""value is \(value)"")
            })
            .store(in: &amp;subscriptions) // &lt;--- doesn't compile due to immutability of ContentView
    }
}

class ViewModel {

    struct Input {
        let trigger: AnySubscriber&lt;Void, Never&gt;
    }

    struct Output {
        let result: AnyPublisher&lt;String, Never&gt;
    }

    let input: Input
    let output: Output

    private let triggerSubject = PassthroughSubject&lt;Void, Never&gt;()

    init() {
        self.input = Input(trigger: AnySubscriber(triggerSubject))

        let resultPublisher = triggerSubject
            .flatMap { Just(""TEST"") }
            .eraseToAnyPublisher()

        self.output = Output(result: resultPublisher)
    }
}

</code></pre>

<p>This sample doesn't compile due to two errors (commented in code):</p>

<p><strong>(1) Problem 1</strong>: How to trigger the publisher's work from the button's action closure like the case of <code>RxSwift</code> above ? </p>

<p><strong>(2) Problem 2</strong> is related somehow to architectural design rather than a compile error: 
the error says: <code>... Cannot pass immutable value as inout argument: 'self' is immutable ...</code>, that's because <code>SwiftUI</code> views are structs, they are designed to be changed only through sorts of bindings (<code>@State</code>, <code>@ObservedObject</code>, etc ...), I have two sub-questions related to problem 2:</p>

<p>[A]: is it considered a bad practice to <code>sink</code> a publisher in a <code>SwiftUI</code> View ? which may need some workaround to store the <code>cancellable</code> at the <code>View</code>'s struct scope ?</p>

<p>[B]: which one is better for <code>SwiftUI/Combine</code> projects in terms of MVVM architectural pattern: using a ViewModel with [ Input[Subscribers], Output[AnyPublishers] ] pattern, or a 
<code>ObservableObject</code> ViewModel with [ <code>@Published</code> properties] ?</p>
","1056118","","","","","2020-11-24 17:59:46","Binding a SwiftUI Button to AnySubscriber like RxCocoa's button tap","<ios><swiftui><rx-swift><combine><rx-cocoa>","2","1","2","","","CC BY-SA 4.0"
"59852494","1","59852665","","2020-01-22 04:10:23","","0","270","<p>i try to replace the addObserver method with Notification publisher
But i cant make it work , hope someone can help </p>

<p>i try to setup the publisher under viewDidLoad and receive notification from another swiftui . Since i cant make it work ,So I make it under viewWillAppear within the same swift file for debugging . In the below coding , I can only receive it from the old school method and the method from viewWillAppear not from the viewDidLoad . The setup in viewDidLoad not working and if i miss out let temp2 = under viewWillAppear , it didnt work too . Is that a bugs for combine?</p>

<p>Result is 
BBBB
CCCC</p>

<pre><code>    override func viewDidLoad() {
    super.viewDidLoad()

    NotificationCenter.default.addObserver(forName: .dismissSwiftUI, object: nil, queue: .main) { (_) in
        print(""BBBB"")
    }
    let abc = NotificationCenter.default.publisher(for: .dismissSwiftUI).sink { (_) in
        print(""AAAA"")
    }
}


override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    //        self.checkIfProfitSetup()
    let temp2 = NotificationCenter.default.addObserver(forName: .dismissSwiftUI, object: nil, queue: .main) { (_) in
        print(""CCCC"")
    }

    NotificationCenter.default.post(name: .dismissSwiftUI ,object: nil)
}
</code></pre>
","2598401","","","","","2020-01-22 04:33:41","Combine: Problem when replace addObserver with Notification publisher","<combine>","1","0","","","","CC BY-SA 4.0"
"59855019","1","","","2020-01-22 07:56:32","","3","339","<p>I have the following simple <code>Future</code>:</p>

<pre><code>class ViewModel {
    var cancellables = Set&lt;AnyCancellable&gt;()
    func test() {
        let trigger = PassthroughSubject&lt;Void, Error&gt;()

       let future =  Future&lt;String, Error&gt; { promise in
                       promise(.success(""Future Succeded""))
                   }

        trigger
        .flatMap { future }
        .sink(receiveCompletion: { completion in
            print(""completion received \(completion)"")
        }, receiveValue: { val in
            print(""value received \(val)"")
        })
        .store(in: &amp;cancellables)

        trigger.send(())
    }
}
</code></pre>

<p>I don't know why it never completes when flat mapped with another publisher (in this case a <code>PassthroughSubject</code>), it only produces the value.</p>

<p>when it's not flat mapped it produces the value and completes normally.</p>
","1056118","","","","","2021-10-12 10:14:50","Combine's Future never completes when flatMapped","<ios><combine>","2","1","1","","","CC BY-SA 4.0"
"59868393","1","59868521","","2020-01-22 21:18:15","","4","10715","<p>I've implemented a List with a search bar in SwiftUI. Now I want to implement paging for this list. When the user scrolls to the bottom of the list, new elements should be loaded. My problem is, how can I detect that the user scrolled to the end? When this happens I want to load new elements, append them and show them to the user.</p>

<p>My code looks like this:</p>

<pre><code>import Foundation
import SwiftUI

struct MyList: View {
    @EnvironmentObject var webService: GetRequestsWebService

    @ObservedObject var viewModelMyList: MyListViewModel

    @State private var query = """"

    var body: some View {

        let binding = Binding&lt;String&gt;(
            get: { self.query },
            set: { self.query = $0; self.textFieldChanged($0) }
        )

        return NavigationView {
            // how to detect here when end of the list is reached by scrolling?
            List {
                // searchbar here inside the list element
                TextField(""Search..."", text: binding) {
                    self.fetchResults()
                }

                ForEach(viewModelMyList.items, id: \.id) { item in
                    MyRow(itemToProcess: item)
                }
            } 
            .navigationBarTitle(""Title"")
        }.onAppear(perform: fetchResults)

    }

    private func textFieldChanged(_ text: String) {        
        text.isEmpty ? viewModelMyList.fetchResultsThrottelt(for: nil) : viewModelMyList.fetchResultsThrottelt(for: text)
    }

    private func fetchResults() {
        query.isEmpty ? viewModelMyList.fetchResults(for: nil) : viewModelMyList.fetchResults(for: query)
    }
}
</code></pre>

<p>Also a little bit special this case, because the list contains the search bar. I would be thankful for any advice because with this :).</p>
","4017243","","","","","2020-08-20 16:49:41","SwiftUI pagination for List object","<ios><swift><list><swiftui><combine>","3","0","3","","","CC BY-SA 4.0"
"59871172","1","","","2020-01-23 03:23:11","","2","745","<p>I'm messing around with Combine code and Swift UI and came across this problem. Effectively I want to pass a <code>Publisher</code> into a <code>View</code> and have that <code>View</code> update every time the publisher publishes an update. </p>

<p>Here's a sample playground that will not compile. Instead it puts up an error - <em><code>Escaping closure captures mutating 'self' parameter</code></em> on the <code>.sink(...</code> line. </p>

<pre class=""lang-swift prettyprint-override""><code>import Combine
import SwiftUI

struct MyView: View {

    let cancellable: AnyCancellable
    @State var current: Int = 0

    init&lt;P&gt;(publisher: P) where P: Publisher, P.Output == Int, P.Failure == Never {
        cancellable = publisher.sink { value in
            self.current = value
        }
    }

    var body: some View {
        Text(""\(current)"")
    }
}

let subject = PassthroughSubject&lt;Int, Never&gt;()
let x = MyView(publisher: subject)
subject.send(5)
</code></pre>

<p>Currently I've changed the code to use an <code>ObservableObject</code> view model with the value inside it and telling that object to send an update. But I'm interested how others have gotten around this problem as I'd like a none view model option too.</p>

<p>What have you guys done?</p>
","247090","","247090","","2020-01-23 03:35:44","2020-01-23 04:55:45","Combine: Init mutating 'self' parameter","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"59879487","1","","","2020-01-23 13:16:21","","1","1286","<p>I'm playing around with publishers in Swift/Combine, I have a function that fetches 100 records and returns them as an array.</p>

<p>As a test I want to return just the first two items, but it's not working as I expected it to, it always returns 100, my feeling is that it's because, the first item is an array of 100 items, if so, how do I split them out?</p>

<pre><code>import UIKit
import Combine

struct Post : Decodable {
    let userId: Int
    let id: Int
    let title: String
    let body: String
}

//let url = URL(string: ""https://jsonplaceholder.typicode.com/todos/1"")!
let url = URL(string: ""https://jsonplaceholder.typicode.com/posts"")!

var subscriptions: Set&lt;AnyCancellable&gt; = []

func fetch() -&gt; AnyPublisher&lt;[Post], Never&gt; {
    return URLSession.shared.dataTaskPublisher(for: url)
        .tryCompactMap{ (arg) -&gt; [Post]? in
            let (data, _) = arg
            return try JSONDecoder().decode([Post].self, from: data)
    }
        //.print(""here"")
        .replaceError(with: [])
        .eraseToAnyPublisher()
}

fetch()
    .prefix(2)
    .sink(receiveCompletion: { (comp) in
        print(""comp: \(comp)"")
    }) { (res) in
        print(""Res: \(res.count)"")
}.store(in: &amp;subscriptions)
</code></pre>

<p>Update, this seems to work, not sure on the syntax though:</p>

<pre><code>fetch()
.flatMap { Publishers.Sequence(sequence: $0) }
.prefix(2)
.sink(receiveCompletion: { (comp) in
  print(""comp: \(comp)"")
}) { (res) in
  print(""Res: \(res)"")
}.store(in: &amp;subscriptions)
</code></pre>
","174955","","174955","","2020-01-23 14:58:17","2020-05-25 18:24:04","Swift Combine - prefix publisher on array","<swift><combine><split-apply-combine>","2","2","","","","CC BY-SA 4.0"
"59880753","1","59881488","","2020-01-23 14:23:08","","0","344","<p>I am trying to figure out a way to insert multiple arrays of views in a VStack in SwiftUI using <code>collect()</code> operator. </p>

<pre><code>struct ChatsTab: View {
    var subscriptions = Set&lt;AnyCancellable&gt;()
    var body: some View {
        VStack {
            [""A"", ""B"", ""C"", ""D"", ""E""].publisher.collect(2).sink(receiveCompletion: { _ in
                // Do nothing on completion
            }) { (stringArray) in
                HStack {
                    Text(stringArray[0])
                    Text(stringArray[1])
                }
            }
        .store(in: &amp;subscriptions)
        }
    }
}
</code></pre>

<p>But I'm getting this below error: </p>

<pre><code>Cannot convert value of type '()' to closure result type '_'
</code></pre>

<p>I want to do this with <code>collect</code> only so I can add my text views in pair. I know I have other options but I want to get it done with <code>collect</code> only.</p>
","10678413","","","","","2020-01-23 15:03:57","How to create views in SwiftUI using collect","<swift><swiftui><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"59925393","1","59937796","","2020-01-27 05:08:00","","0","321","<p>I have an <code>ObservedObject</code> that I pass values into based on user inputs from the form's <code>TextFields</code>.  However, I want the user to have the option to use CoreLocation.  When they change the toggle, I want the input value for one of the <code>TextFields</code> to switch to my <code>CoreLocation</code> publisher.  Here are the code snippets:</p>

<pre><code>@EnvironmentObject var locationManager: LocationManager
@ObservedObject var calculator: CalculatorObject
@State var useGPS: Bool = false

if self.useGPS {
   //I'm not sure what to put here
   //I’ve tried several options to set the binding element of the
   //   CalculatorObject to the speed object of the
   //   locationManager but they don’t change the values within
   //   the calculations. 
}

var body: Some View {
    VStack {
       Toggle(isOn: $useGPS) {
          Text(""Use GPS for Ground Speed"")
       }

       if useGPS {
          Text(locationManager.locationInfo.speed)
       } else {
          TextField(""Ground Speed"", text: self.$calculator.groundSpeed)
       }
    }
}
</code></pre>

<p>I have tried a number of different options, but I cannot seem to get the data from the location manager to pass it's data to the <code>CalculatorObject.</code> I have verified that when I change the toggle, the UI <em>is</em> showing the changing speed, so I am sure that the location publisher is working. I'm not clear on how to change the binding source here.</p>
","9701514","","7271020","","2020-01-27 06:44:11","2020-01-27 19:39:39","How do I change an object's binding source based on a boolean (SwiftUI)?","<swift><swiftui><core-location><combine>","2","0","0","","","CC BY-SA 4.0"
"59946043","1","","","2020-01-28 09:50:52","","0","466","<p>I'm trying to make a dynamic view to answer some questions. Those questions are created from my back office, ant the next question depends on the current user answer. So I have to build my view as things progress. </p>

<p>Here is a example :</p>

<p>First Question :</p>

<pre><code>Are you alive ? :  |      Are you sure ?
                   |
YES/NO (no chosen) |        YES/NO
</code></pre>

<p>I made a subview with the different type of question, and a container view to embed the path like that :</p>

<p><a href=""https://i.stack.imgur.com/kR7NZ.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kR7NZ.jpg"" alt=""enter image description here""></a></p>

<p>Here is the code of my container View, the white block is embed in a Scrollview</p>

<pre><code>    @ObservedObject var VM:SurveyBrowserViewModel

    @State private var offsetX:CGFloat = 0
    @State private var opacity:Double = 1
    @State var myView:AnyView = AnyView(EmptyView())
    var body: some View {
        ZStack{
            Image(""background_survey_canyon"")
                .resizable()
            backgroundTriangle
                .opacity(0.65)
            ScrollView(showsIndicators:false){
                myView
                    .padding(.top, 55 + safeAreaTop)
                    .padding(.bottom, 60 + safeAreaBottom)
                    .offset(x : offsetX , y: 0)
                    .opacity(opacity)
                    .onReceive(VM.nextQuestionPassthrough) { (v) in
                        self.myView = v
                    }
                .onReceive(VM.nextQuestionValuePassthrough) { (v) in
                    self.offsetX = v
                    self.opacity = 0
                    withAnimation(.spring()) {
                        self.offsetX = 0
                        self.opacity = 1
                    }
                }
            }
            .frame(maxWidth: .infinity,maxHeight: .infinity)
        }
    }
</code></pre>

<p>and here is the viewModel section which updates the View state, current question is the question which needs to be displayed according the good type.</p>

<pre><code>    var nextQuestionPassthrough = PassthroughSubject&lt;AnyView,Never&gt;()
    /// Get The good view to match the correct question tyoe
    /// - Parameter answerSelected: Binding bool to hide/show next button  visibility
    private func getGoodView(){
        guard (currentQuestion != nil) else { nextQuestionPassthrough.send(AnyView(EmptyView())); return }
        switch QuestionType.intToQuestionType(value: currentQuestion!.type!){
        case .YesOrNo :
            if currentQuestionViewModel == nil{
                currentQuestionViewModel = YesNoQuestionViewModel(question: currentQuestion!,temporaryId: temporaryId)
            }
            nextQuestionPassthrough.send(AnyView(YesNoQuestionView(VM: currentQuestionViewModel as! YesNoQuestionViewModel,answerSelected: nextViewState! )))
        }
    }
</code></pre>

<p>I've tried different way to achieve what I'm expecting :</p>

<ul>
<li>I want a animation like a auto scroll coming form right to left, but it's cosmetic and it's not my main problem.</li>
</ul>

<p>My problem is that when i send view from the nextQuestionPassthrough the init section from my new view is called but not the appear one. So all state are saved as we can see on the picture ( yes and no answer are two @State set to false at initialization but stay selected when I send the new view. I tried several ideas, like a published view instead of a @State but the behavior is the same.</p>

<p>I'm thinking about a new approch, with my container embed two views to make the good animation and the good life cycle ( init then appear )</p>

<p>Has anyone ever studied this problem or done something similar?</p>
","2114456","","","","","2020-01-28 09:50:52","Dynamic view with swiftUI","<ios><swift><swiftui><combine>","0","2","1","","","CC BY-SA 4.0"
"59948428","1","59949936","","2020-01-28 12:07:21","","0","137","<p>I have an observable object with two properties</p>

<pre><code>class Demo: ObservableObject {
  @Published var propertyA: Bool
  @Published var propertyB: Bool
}
</code></pre>

<p>Now I want to add a derived property ""propertyC"" that is ""true"" if both propertyA and propertyB are true.</p>

<p>I found similar questions with answers that didn't satisfy me. I'm looking for a solution that uses the Combine Framework and not a ""didSet"" method as my real world project computes the derived property from more than two other properties.</p>

<p>When I'm using the derived propertyC in a SwiftUI view it should trigger a refresh whenever propertyA or propertyB changes even if I don't use those in the view. </p>
","10826194","","","","","2022-08-23 14:50:19","How to implement derived property using Combine?","<swift><combine>","2","6","","","","CC BY-SA 4.0"
"59972398","1","59977197","","2020-01-29 17:20:05","","1","1907","<p>iOS 13, Swift 5, Xcode 11.3.1</p>

<p>Learning SwiftUI. I put this together, and it works, but is it correct.</p>

<p>In <strong>External.swift</strong></p>

<pre><code>class BlobModel: ObservableObject {
  @Published var score: String = """" 
}

var globalBlob = BlobModel()
</code></pre>

<p>In <strong>ContentView.swift</strong></p>

<pre><code>struct ContentView: View {

@ObservedObject var globalBlob:BlobModel

var body: some View {
  Text(""\(globalBlob.score)"")
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
      ContentView(globalBlob: globalBlob)
    }
}
</code></pre>

<p>When I write to the globalBlob in <strong>External.swift</strong> it updates the display. </p>

<pre><code>globalBlob.score = backToString
</code></pre>

<p>But globalBlob is a global variable, which is surely poor coding practice. Is there a better way I should have done this?</p>
","3069232","","3069232","","2020-01-29 18:36:26","2020-01-29 23:43:08","SwiftUI setting up external variables that will trigger a view refresh","<swift><global-variables><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"59990481","1","59994211","","2020-01-30 16:33:06","","0","128","<p>I'm relatively new to the Functional Reactive programming world, and still trying to wrap my head around the concepts. I'm utilizing an SDK to make some network requests - specifically to query a remote database. The SDK returns a publisher, and I have a working pipeline that transforms that result into model objects. Here's that working pipeline:</p>

<pre><code>let existingClaimQuery = ""SELECT Id, Subject, CaseNumber FROM Case WHERE Status != 'Closed' ORDER BY CaseNumber DESC""
let requestForOpenCases = RestClient.shared.request(forQuery: existingClaimQuery, apiVersion: RestClient.apiVersion)
caseCancellable = RestClient.shared
  .publisher(for: requestForOpenCases)
  .receive(on: RunLoop.main)
  .tryMap({restresponse -&gt; [String:Any] in
    let json = try restresponse.asJson() as? [String:Any]
    return json ?? RestClient.JSONKeyValuePairs()
  })
  .map({json -&gt; [[String:Any]] in
    let records = json[""records""] as? [[String:Any]]
    return records ?? [[:]]
  })
  .map({
    $0.map{(item) -&gt; Claim in
      return Claim(
        id: item[""Id""] as? String ?? ""None Listed"",
        subject: item[""Subject""] as? String ?? ""None Listed"",
        caseNumber: item[""CaseNumber""] as? String ?? ""0""
      )
    }
  })
  .mapError{error -&gt; Error in
    print(error)
    return error
  }
  .catch{ error in
    return Just([])
  }
.assign(to: \.claims, on: self)
</code></pre>

<p>I went to work on another section of the code, and realized I <em>often</em> need to do this same process - write a query, create a request for that query, and process it through a pipeline that ultimately returns a [[String:Any]]. </p>

<p>So here's the million dollar question. What's the <em>right</em> way to encapsulate this pipeline such that I can re-use it without having to copy/pasta the entire pipeline all over the code base? This is my ... attempt at it, but it feels ...wrong?</p>

<pre><code>class QueryStream: ObservableObject {

  var query: String = """"
  private var queryCancellable: AnyCancellable?

  @Published var records: [[String:Any]] = [[String:Any]]()

  func execute(){
    let queryRequest = RestClient.shared.request(forQuery: query, apiVersion: RestClient.apiVersion)

    queryCancellable = RestClient.shared.publisher(for: queryRequest)
      .receive(on: RunLoop.main)
      .tryMap({restresponse -&gt; [String:Any] in
        let json = try restresponse.asJson() as? [String:Any]
        return json ?? [String:Any]()
      })
      .map({json -&gt; [[String:Any]] in
        let records = json[""records""] as? [[String:Any]]
        return records ?? [[:]]
      })
      .mapError{error -&gt; Error in
        print(error)
        return error
      }
      .catch{ error in
        return Just([])
      }
    .assign(to: \.records, on: self)
  }

}
</code></pre>

<p>This still requires a pipeline to be written for each use. I feel like there should be some way to have a one off promise like pipeline that would allow for </p>

<pre><code>let SomeRecords = QueryStream(""Query here"").execute()
</code></pre>

<p>Am I too n00b? overthinking it? What's the stack's wisdom?</p>
","1132573","","","","","2020-01-31 22:43:53","What's the proper method for creating re-usable pipelines with Combine?","<swift><combine>","2","1","","","","CC BY-SA 4.0"
"60017564","1","60019566","","2020-02-01 13:59:10","","6","1352","<p>I have a LoginView that shows a RegisterView if the user is not logged in, and a ContentView if he is logged in:</p>

<pre><code>struct LoginView: View {
    @EnvironmentObject var userManager: UserManager
    var body: some View {
        Group {
            if userManager.isRegistered {
                ContentView()
            } else {
                RegisterView()
            }
        }
    }
}
</code></pre>

<p><code>ContentView</code> have three <code>ObservedObject</code> properties, that uses combine to fetch content from a server with rest api's.</p>

<pre><code>struct ContentView: View {
    @EnvironmentObject var userManager: UserManager
    @ObservedObject var usersStore = UsersStore()
    @ObservedObject var rolesStore = RolesStore()
    @ObservedObject var elementsStore = ElementsStore()

    var body: some View {
        NavigationView {
            ZStack {
                Image(""stell"")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .opacity(0.1)

                VStack(alignment: .leading, spacing: 5) {
                    NavigationLink(destination: UsersView(usersStore: usersStore) ) {
                        Text(""Users"")
                    }
                    NavigationLink(destination: RolesView(rolesStore: rolesStore)) {
                        Text(""Roles"")
                    }
                    NavigationLink(destination: ElementsView(elements: $elementsStore.elements)) {
                        Text(""Elements"")
                    }
                }.font(.title).padding(20)
            }.navigationBarTitle(Text(""STELL""))
        }
    }
}
</code></pre>

<p>The problem I have is that I want to reference <code>userManager</code> from any of the observedObjects, e.g. when the rest api's returns <code>401 Unauthorized</code> when the session token has expired. Then I want the ObservedObject to set the <code>isRegistered</code> flag in <code>userManager</code> to <code>false</code> so the <code>RegisterView</code> is automatically shown. But how can I do that? I can't set a reference to <code>userManager</code> in any of the ObservedObject property initializers, because the compiler complains about property initializers is run before <code>self</code> is available.</p>
","6394244","","","","","2022-08-23 14:14:21","Reference EnvironmentObject in ObservableObject","<swiftui><combine><observableobject>","1","0","1","","","CC BY-SA 4.0"
"60027949","1","","","2020-02-02 16:04:15","","0","466","<p>Two <code>ViewModels</code>, one is a store of <code>roles</code> containing <code>skills</code>:</p>

<pre><code>final class RolesStore: ObservableObject {
  @Published var roles: [Role] = []
.....
</code></pre>

<p>A role model is:</p>

<pre><code>struct Role: Codable, Identifiable {
    let id: String
    var name: String
    var skills: [Skill]
}
</code></pre>

<p>The other <code>ViewModel</code> is a store of <code>skills</code>:</p>

<pre><code>final class SkillStore: ObservableObject {
    @Published var skills: [Skill] = []
.....
</code></pre>

<p>The following shows what i want to do, remove a skill from <code>SkillStore</code> (handy), and also have the deleted skill automatically removed from any <code>role</code> that happen to have the skill in the <code>RoleStore</code>:</p>

<p><a href=""https://i.stack.imgur.com/gokVT.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gokVT.gif"" alt=""remove handy skill""></a></p>

<p>As you can see, removing the skill <code>handy</code> doesn't remove it from the role <code>Ansatt</code>.
I am not sure how to do that, so I prepared a Xcode Playground anyone can clone from Github: <a href=""https://github.com/imyrvold/roleSkills"" rel=""nofollow noreferrer"">https://github.com/imyrvold/roleSkills</a> </p>

<p>There must be a way of having <code>SkillStore</code> having a dependency on the skills in <code>SkillStore</code> or is there no other way than looping through all the roles and remove the skill from all the roles that have this skill?</p>
","6394244","","","","","2020-02-09 10:14:02","Remove objects from ObservableObject","<swiftui><combine><observableobject>","1","0","","","","CC BY-SA 4.0"
"60033588","1","60047197","","2020-02-03 05:33:04","","1","1318","<pre class=""lang-swift prettyprint-override""><code>let a = Just(""a"")
let b = Just(""b"")
_ = Publishers.CombineLatest(a, b).map { a, b in
    print(a, b)
}
</code></pre>

<p>This is my simple <code>CombineLatest</code> test. I am calling this method in <code>onAppear</code> function. 
However, my <code>print(a,b)</code> is not called. How should I fix my code to run <code>print(a, b)</code> ? </p>
","11258185","","5130481","","2020-02-03 08:25:32","2020-02-03 21:10:17","CombineLatest in Combine is not fired","<swift><combine><combinelatest>","1","2","","","","CC BY-SA 4.0"
"60051829","1","","","2020-02-04 06:35:16","","-1","236","<p>My goal is to use Combine to run code at a specific time of day. In the code below, I use Combine to update a SwiftUI textview when a timer fires. I'd like the text view to be updated at a specific time of day rather than when the timer fires. I believe NotificationCenter can be used for the purpose, but I'm not quite sure how to make this work as documentation is lacking.</p>

<p>Can you solve this problem and use Notification Center to update the textview at a certain time of the day (for example, 6 pm)?</p>

<pre><code>import SwiftUI

struct ContentView: View {

    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()

    @State private var counter = 0


    var body: some View {

        Text(""The time is now \(counter)"")
            .onReceive(timer) { time in
                if self.counter == 30 {
                    self.timer.upstream.connect().cancel()
                }
                    self.counter += 1
        }
    }
}
</code></pre>
","11698443","","","","","2020-02-04 07:13:28","Run code at specific time of day using Combine","<ios><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"60054800","1","64747762","","2020-02-04 09:56:00","","0","1215","<p>I have main View which has ViewModel and it's declared like this </p>

<p><code>@ObservedObject var viewModel = ViewModel()</code></p>

<p>Everything works perfectly but when I move the app to background and then to foreground the View recreates itself as well as my viewModel and everything stored in viewModel disappears. </p>

<p>In this case making ViewModel a singleton class will solve the problem but making all ViewModels singleton classes is not a good idea. </p>

<p>Is there a workaround for this ?  </p>
","5903004","","4056108","","2020-02-04 10:41:51","2020-11-09 08:01:34","SwiftUI View memory lifecycle","<ios><swift><xcode><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"60055282","1","","","2020-02-04 10:22:28","","2","812","<p>I'm working on a SwiftUI project where I have a centralized app state architecture (similar to Redux). This app state class is of type ObservableObject and bound to the SwiftUI view classes directly using @EnvironmentObject.</p>

<p>The above works well for small apps. But as the view hierarchy becomes more and more complex, performance issues start to kick in. The reason is, that ObservableObject fires an update to each view that has subscribed even though the view may only need one single property.</p>

<p>My idea to solve this problem is to put a model view between the global app state and the view. The model view should have a subset of properties of the global app state, the ones used by a specific view. It should subscribe to the global app state and receive notification for every change. But the model view itself should only trigger an update to the view for a change of the subset of the global app state.</p>

<p>So I would have to bridge between two observable objects (the global app state and the model view). How can this be done?</p>

<p>Here's a sketch:</p>

<pre><code>class AppState: ObservableObject {
  @Published var propertyA: Int
  @Published var propertyB: Int
}

class ModelView: ObservableObject {
  @Published var propertyA: Int
}

struct DemoView: View {
  @ObservedObject private var modelView: ModelView

  var body: some View {
    Text(""Property A has value \($modelView.propertyA)"")
  }
}
</code></pre>
","10826194","","","","","2020-02-04 21:45:21","How to bridge global app state to model view (using @ObservedObject)?","<swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"60061271","1","","","2020-02-04 16:04:51","","2","1119","<p>I have an @Environment who store all share data for my views. One of my views use one of its variables to present a list with collapsable items. For make the list collapsable I use a @State whether is true or false expand the collapsable content, inside this list I want the user could delete its items so I made a function that remove item from the variable in the @Environment and update the view. The problem is that the State change to his default value and the Expanded list comback to be collapse. I would like to know how to preserve the previus states or maybe tell my views that only re-render the parts that actually changes. </p>

<p>This is my Environment object. All my views have acces to this.</p>

<pre><code>class GlobalData:ObservableObject {
    @Published var SpoonData: [Item?] = []
    @Published var currentTab: Int = 0

    func deleteSpoonData(at offsets: IndexSet) {
        self.SpoonData.remove(atOffsets: offsets)
    }

    func addSpoonData(item: Item, itemList: Items){
       let exists = SpoonData.firstIndex(where: {$0?.ItemId == item.ItemId})
        var rt = item
        rt.ItemList = itemList

        if exists == nil {
            self.SpoonData.append(rt)
        }
    }
    func deleteProductFromItemList(product: Product, itemId: Int) {
        let fatherIndex = self.SpoonData.firstIndex { item -&gt; Bool in
            item?.ItemId == itemId
        }

        let childIndex = (self.SpoonData[fatherIndex!]?.ItemList?.ItemList?.firstIndex(where: { productfiltered -&gt; Bool in
            productfiltered?.EntryID == product.EntryID
        }))!

        print(self.SpoonData[fatherIndex!]?.ItemList?.ItemList![childIndex])
        self.SpoonData[fatherIndex!]?.ItemList?.ItemList!.remove(at: childIndex)

    }
}
</code></pre>

<p>This is the view that present the list.</p>

<pre><code>    struct SpoonListItemView: View {

    private let viewModel: SpoonListItemViewModel
    @State private var isCollapsed: Bool =  false

    init(viewModel: SpoonListItemViewModel) {
           self.viewModel = viewModel
    }

    var body: some View {
        VStack {
            VStack {
                HStack(alignment: .top) {

                    if self.viewModel.ItemType == 1 {
                        AsyncImage(url: viewModel.ItemImageUrl, size: CGSize(width: 45.0, height: 45.0), contentMode: .fit)
                            .clipShape(Rectangle())
                    } else {
                        AsyncImage(url: viewModel.ItemImageUrl, size: CGSize(width: 45.0, height: 45.0), contentMode: .fit)
                            .clipShape(Circle())
                    }
                    VStack(alignment: .leading) {
                        Text(""\(viewModel.ItemName)"")
                            .font(.custom(""NunitoSans-Bold"", size: 14))
                            .lineLimit(1)
                            .multilineTextAlignment(.leading)
                        Text(viewModel.ItemType == 1 ? ""Receta"" : ""Producto"")
                            .foregroundColor(Color(""textColor""))
                            .font(.custom(""NunitoSans-Light"", size: 12))
                    }
                    Spacer()
                }.frame(height: 50)
                    .padding(EdgeInsets(top: 0, leading: 24, bottom: 0, trailing: 24)).onTapGesture {
                        self.isCollapsed.toggle()
                }

            }
            if self.viewModel.ItemType == 1 {
                if self.isCollapsed {
                    SpoonListProductView(viewModel: SpoonListProductViewModel(items: self.viewModel.ItemList, father: self.viewModel.ItemId))
                }
            }
        }

        }
}

And this is the view that present the childs when is expanded

    struct SpoonListProductView: View {
    @EnvironmentObject var globalData: GlobalData
    @ObservedObject var viewModel: SpoonListProductViewModel
    @State private var isInEditingMode: Bool = false
    var fatherId: Int?

    init(viewModel: SpoonListProductViewModel) {
            self.viewModel = viewModel
       }

       var body: some View {

        VStack(alignment: .leading) {
            ForEach(viewModel.dataSource) { vm in
                Group{
                    HStack {
                        SpoonProductView.init(viewModel: vm).onLongPressGesture {
                            self.isInEditingMode = true
                        }
                        Spacer()
                        if self.isInEditingMode {
                            Image(systemName: ""trash.fill"").foregroundColor(Color(""textColor"")).onTapGesture {
                                self.delete(vm: vm)
                            }
                        }
                    }
                    Divider()
                }
            }

           }.padding(EdgeInsets(top: 8, leading: 8, bottom: 0, trailing: 8))

       }

    func delete(vm: ProductViewModel) {
        //self.viewModel.ItemList?.remove(atOffsets: offsets)
        self.globalData.deleteProductFromItemList(product: vm.product, itemId: self.viewModel.father!)
    }
}
</code></pre>

<p>This is The code for the List:</p>

<pre><code>struct SpoonListView: View {
    @EnvironmentObject var globalData: GlobalData
    @ObservedObject var viewModel: SpoonListViewModel
    var items: [Item?]

    init(items: [Item?] ) {
        self.items = items
        self.viewModel = SpoonListViewModel(items: self.items)
    }

    var body: some View {
        SpoonListItemsView(viewModel: viewModel.dataSource!)
    }
}
</code></pre>

<p>And this is its viewModel: </p>

<pre><code>class SpoonListViewModel: ObservableObject, Identifiable {
     @Published var dataSource: SpoonListItemsViewModel? = nil
    var items: [Item?]

    init(items: [Item?]) {
        self.items = items
        self.dataSource =    SpoonListItemsViewModel(items: self.items as! [Item])
    }
}
</code></pre>
","12840104","","12840104","","2020-02-05 13:04:30","2022-01-27 03:23:01","Updating Environment makes view re-render with all his States Swiftui","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"60075802","1","60088674","","2020-02-05 12:25:29","","3","284","<p>Loading a anchor using LoadAnchorAsync(contentsOf: URL) does not work. Here is my code:</p>

<pre><code>if let url = url {
    let loadRequest = Entity.loadAnchorAsync(contentsOf: url)
    _ = loadRequest.sink(receiveCompletion: { completion in
        // handle completion
    }, receiveValue: { anchor in
        self.arView.scene.addAnchor(anchor)
    })
} else {
        fatalError(""no url"")
}
</code></pre>

<p>but this crashes every time with an error:</p>

<p>Thread 27: EXC_BREAKPOINT (code=1, subcode=0x1051e0dfc)</p>

<p><a href=""https://i.stack.imgur.com/lfHgJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lfHgJ.png"" alt=""enter image description here""></a></p>

<p>Update: If i wrap the entire code block in an DispatchQueue.main.async block it doenst crash but neither reveiceCompletion or recieveValue gets called</p>
","8432840","","8432840","","2020-02-05 12:31:42","2020-02-06 06:09:57","Loading anchor from url async doesnt work","<swift><augmented-reality><arkit><combine><realitykit>","2","0","0","","","CC BY-SA 4.0"
"60089803","1","","","2020-02-06 07:34:45","","8","5375","<p>I'm trying to write some unit tests for my API using URLSession.DataTaskPublisher. I've found an already existing question on Stackoverflow for the same but I'm struggling to implement a working class using the proposed solution.</p>

<p>Here's the existing question: <a href=""https://stackoverflow.com/questions/59521928/how-to-mock-urlsession-datataskpublisher"">How to mock URLSession.DataTaskPublisher</a></p>

<pre><code>protocol APIDataTaskPublisher {
    func dataTaskPublisher(for request: URLRequest) -&gt; URLSession.DataTaskPublisher
}

class APISessionDataTaskPublisher: APIDataTaskPublisher {
    func dataTaskPublisher(for request: URLRequest) -&gt; URLSession.DataTaskPublisher {
        return session.dataTaskPublisher(for: request)
    }

    var session: URLSession

    init(session: URLSession = URLSession.shared) {
        self.session = session
    }
}

class URLSessionMock: APIDataTaskPublisher {
    func dataTaskPublisher(for request: URLRequest) -&gt; URLSession.DataTaskPublisher {
        // How can I return a mocked URLSession.DataTaskPublisher here?
    }
}
</code></pre>

<p>My API then uses the above like this:</p>

<pre><code>class MyAPI {
    /// Shared URL session
    private let urlSession: APIDataTaskPublisher

    init(urlSession: APIDataTaskPublisher = APISessionDataTaskPublisher(session: URLSession.shared)) {
        self.urlSession = urlSession
    }
}
</code></pre>

<p>What I don't know is how to implement URLSessionMock.dataTaskPublisher().</p>
","10826194","","","","","2020-09-10 13:41:54","How to mock DataTaskPublisher?","<swift><unit-testing><combine>","4","1","2","","","CC BY-SA 4.0"
"60119057","1","","","2020-02-07 18:21:05","","6","1267","<p>I'd like to extend ObservableObject behavior in SwiftUI to nested classes, and I'm looking for the proper way to do it. It can be done ""manually"" with Combine, but I imagine there's a much cleaner way to do it using SwiftUI, and I'm hoping you can point me in the right direction. Here's what I mean…</p>

<p>Below is a typical application of ObservableObject to make a View dynamically respond to changes to a reference type. Tapping the button toggles the <code>showText</code> value, which makes the text appear/disappear on the screen:</p>

<pre><code>import SwiftUI

class MyClass: ObservableObject {
    @Published var showText = false
}


struct ContentView: View {

    @ObservedObject var instance = MyClass()

    var body: some View {
        VStack(spacing: 10) {
            Button(action: {
                print(self.instance.showText)
                self.instance.showText.toggle()
            }) {
                Text(""BUTTON"").bold().padding()
                    .foregroundColor(.white)
                    .background(Color.red)
            }
            if instance.showText {
                Text(""Hello, World!"")
            }
        }
    }
}
</code></pre>

<p>This works fine.</p>

<p>But what about the modification below, where the class containing <code>showText</code> is an <code>InnerClass</code>, itself contained in an <code>OuterClass</code>? The button toggles <code>showText</code> just fine, but the notification of the value change no longer propagates through the <code>OuterClass</code> instance to the View, so the View no longer displays the Text at all.</p>

<pre><code>import SwiftUI

class OuterClass: ObservableObject {
    @Published var innerInstance = InnerClass()
}

class InnerClass: ObservableObject {
    @Published var showText = false
}

struct ContentView: View {

    @ObservedObject var outerInstance = OuterClass()

    var body: some View {
        VStack(spacing: 10) {
            Button(action: {
                self.outerInstance.innerInstance.showText.toggle()
            }) {
                Text(""BUTTON"").bold().padding()
                    .foregroundColor(.white)
                    .background(Color.red)
            }
            if outerInstance.innerInstance.showText {
                Text(""Hello, World!"")
            }
        }
    }
}
</code></pre>

<p>What is the elegant fix for this?</p>
","9085376","","9085376","","2020-02-07 18:35:37","2020-02-08 16:36:57","SwiftUI - propagating change notifications through nested reference types","<swiftui><combine><propagation><observableobject>","2","0","1","","","CC BY-SA 4.0"
"60123470","1","60141681","","2020-02-08 02:41:45","","1","123","<p>Formatting the published value in my model (as computed property) I've got very strange error </p>

<pre><code>class Model: ObservableObject {
    @Published var value = 0.0
    var progress: String {
        String(format: ""%.2f %%"", value) // Expression type 'String' is ambiguous without more context
    }
}
</code></pre>

<p>I found a ""workaround""</p>

<pre><code>class Model: ObservableObject {
    @Published var value = 0.0
    var progress: String {
        String(format: ""%.2f %%"", value * 1) // No error :-)
    }
}
</code></pre>

<p>Can somebody explain this strange behavior?</p>
","3441734","","220819","","2020-02-10 07:03:42","2020-02-10 10:56:39","strange error while formatting a string from published value","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"60130090","1","","","2020-02-08 18:50:29","","1","2423","<p>I am experimenting with SwiftUI and having a hard time figuring out the proper architecture for my app.</p>

<p>What I am trying to achieve is simple. I want to have an initial screen that either show a sign up screen or the home screen for a given user depending on current authentication state. I cannot figure out how to make the initial screen pick up changes from the sign up screen once authentication has taken place. Here's some relevant code:</p>

<pre class=""lang-swift prettyprint-override""><code>struct InitialView: View {
    @EnvironmentObject var viewModel: InitialViewModel

    var body: some View {
        VStack {
            if viewModel.auth.identity != nil {
                NewHomeView()
            } else {
                SignInView()
            }
        }
    }
}
</code></pre>

<p>In the sign in view, I have a usual sign in form and when the user presses the sign in button, I want to send a login request to the backend and remember the resulting token.</p>

<pre class=""lang-swift prettyprint-override""><code>
class SignInViewModel: ObservableObject {
    private let auth: AuthStore
    private let signInApi: SignInApi
    private var cancellableSet: Set&lt;AnyCancellable&gt;

    // Input
    @Published var name: String = """"
    @Published var password: String = """"
    @Published var showSignUp: Bool = false

    // Output
    @Published var authSuccess: Bool = false

    init(auth: AuthStore, signInApi: SignInApi) {
        self.auth = auth
        self.signInApi = signInApi
        self.cancellableSet = Set&lt;AnyCancellable&gt;()
    }

    func signIn() {
        signInApi.signIn(email: name, password: password).sink(receiveCompletion: { _ in }) { response in
            self.auth.identity = Identity(
                person: Person(id: 1, name: ""user"", sex: nil, birthday: nil),
                token: response.token
            )
            self.authSuccess = true
        }.store(in: &amp;cancellableSet)
    }
}
</code></pre>

<p>HOWEVER, this does not work. Even after clicking the sign in button, the initial view is not updated. Note that I am passing the same AuthStore to both view models.</p>

<pre class=""lang-swift prettyprint-override""><code>  let auth = AuthStore()

        // Create the SwiftUI view that provides the window contents.
        let contentView = InitialView()
            .environmentObject(InitialViewModel(auth: auth))
            .environmentObject(SignInViewModel(auth: auth, signInApi: SignInApi()))

</code></pre>

<p>where AuthStore is defined as</p>

<pre><code>
class AuthStore: ObservableObject {
    @Published var identity: Identity? = nil
}
</code></pre>

<p>Ideally, I'd love to be able to 1) have each view be paired with its own VM 2) have each VM access global state via @EnvironmentObject. However, it seems that @EnvironmentObject is restricted to views only? If so, how do I access the global auth state from within each VM that requires it? </p>
","12864509","","12864509","","2020-02-08 19:18:04","2020-02-13 09:31:19","SwiftUI access global state from ViewModel","<ios><swift><mvvm><swiftui><combine>","2","6","4","","","CC BY-SA 4.0"
"60131928","1","60136273","","2020-02-08 22:44:42","","0","363","<p>I have a map based app so I want to have an app-wide property for the current position of the map.</p>

<p>I'm initializing it in SceneDelegate</p>

<pre><code>    let currentPosition = CurrentPosition()
    let mainView = MainView(appState: AppState(), selectedWeatherStation: nil).environmentObject(currentPosition)
</code></pre>

<p>I have it declared in <code>MainView</code> as an <code>@EnvironmentObject</code></p>

<pre><code>struct MainView: View {
    @State var appState: AppState
    @State var selectedWeatherStation: WeatherStation? = nil

    @EnvironmentObject var currentPosition: CurrentPosition
</code></pre>

<p>and I inject it into my <code>UIViewRepresentable</code> child</p>

<pre><code> MapView(weatherStations: $appState.appData.weatherStations,
                    selectedWeatherStation: $selectedWeatherStation).environmentObject(currentPosition)
                    .edgesIgnoringSafeArea(.vertical)
</code></pre>

<p>in <code>MapView</code></p>

<pre><code>struct MapView: UIViewRepresentable {
    @Binding var weatherStations: [WeatherStation]
    @Binding var selectedWeatherStation: WeatherStation?

    @EnvironmentObject var currentPosition: CurrentPosition
</code></pre>

<p>i have a final subclass </p>

<pre><code>final class Coordinator: NSObject, MKMapViewDelegate {
        @EnvironmentObject var currentPosition: CurrentPosition
</code></pre>

<p>which acts as my mapview delegate, where I want to update the <code>currentPosition</code></p>

<pre><code>  func mapViewDidChangeVisibleRegion(_ mapView: MKMapView) {
            currentPosition = CurrentPosition(northEast: mapView.northEastCoordinate, southWest: mapView.southWestCoordinate)
        }
</code></pre>

<p>But this assignament
<code>currentPosition = CurrentPosition(northEast: mapView.northEastCoordinate, southWest: mapView.southWestCoordinate)</code>
will throw an error
<code>Cannot assign to property: 'currentPosition' is a get-only property</code>
and I really have no idead what I'm doing wrong.</p>

<p>The purpose is to update the position each time the user moves the map so I can perform a request to my API with the current coordinates.</p>

<p>CurrentPosition is declared as follows</p>

<pre><code>class CurrentPosition: ObservableObject {
    @Published var northEast = CLLocationCoordinate2D()
    @Published var southWest = CLLocationCoordinate2D()

    init(northEast: CLLocationCoordinate2D = CLLocationCoordinate2D(), southWest: CLLocationCoordinate2D = CLLocationCoordinate2D()) {
        self.northEast = northEast
        self.southWest = southWest
    }
}
</code></pre>
","2984775","","","","","2020-02-09 11:53:10","Trying to assign to an @EnvironmentObject from a child view to a parent fails as EnvironmentObject is read-only","<swift><mapkit><swiftui><combine><uiviewrepresentable>","1","2","","","","CC BY-SA 4.0"
"60136350","1","60141414","","2020-02-09 11:57:37","","1","256","<p>I have an <code>ObservableObject</code></p>

<pre><code>
class CurrentPosition: ObservableObject {
    @Published var northEast = CLLocationCoordinate2D()
    @Published var southWest = CLLocationCoordinate2D()


    init(northEast: CLLocationCoordinate2D = CLLocationCoordinate2D(), southWest: CLLocationCoordinate2D = CLLocationCoordinate2D()) {
        self.northEast = northEast
        self.southWest = southWest
    }

    func updateCoordinates(from mapView: MKMapView) {
        self.northEast = mapView.northEastCoordinate
        self.southWest = mapView.southWestCoordinate
    }
}
</code></pre>

<p>which I want to update from a MapView</p>

<pre><code>struct MapView: UIViewRepresentable {
    @Binding var weatherStations: [WeatherStation]
    @Binding var selectedWeatherStation: WeatherStation?

    @EnvironmentObject var currentPosition: CurrentPosition

    func makeUIView(context: Context) -&gt; MKMapView {
        let map = MKMapView()
        map.showsUserLocation = true
        map.delegate = context.coordinator
        return map
    }

    func updateUIView(_ uiView: MKMapView, context: Context) {
        updateAnnotations(from: uiView)
    }

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }


    final class Coordinator: NSObject, MKMapViewDelegate {
        var control: MapView

        init(_ control: MapView) {
            self.control = control
        }

        func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated: Bool) {
            control.currentPosition.updateCoordinates(from: mapView)
        }

    }
}
</code></pre>

<p>and pass it to an <code>AppState</code> object</p>

<pre><code> MapView(weatherStations: $appState.appData.weatherStations,
                        selectedWeatherStation: $selectedWeatherStation).environmentObject(self.currentPosition)
                    .edgesIgnoringSafeArea(.vertical).onReceive(currentPosition.objectWillChange) { () in
                        self.appState.currentPosition = self.currentPosition
                }}
</code></pre>

<p>which in turn passes it to my API client</p>

<pre><code>class AppState: ObservableObject {
    @Published var appData = AppData(weatherStations: [WeatherStation]())
    var currentPosition: CurrentPosition! {
        didSet {
            api.currentPosition = self.currentPosition
        }
    }
}
</code></pre>

<p>My issues is that it gets passed each time one of my <code>CurrentPosition</code> properties gets updated, meaning it first gets passed when <code>northEast</code> gets updated, than when <code>southWest</code> gets updated.</p>

<p>How can I pass it only one, when both finished updating?</p>
","2984775","","","","","2020-02-09 21:16:15","SwiftUI be notified when all properties of an ObservableObject are updated","<swift><mvvm><swiftui><xcode11><combine>","1","0","","","","CC BY-SA 4.0"
"60149906","1","60152554","","2020-02-10 11:56:15","","6","4225","<p>I am currently trying to implement the merging of two publishers. But I can't find a solution for my use case. </p>

<p>I want to merge 2 publishers that both emit an array of structs of the same type. I want the combined publisher to emit values when either one of the merged publishers emit a new value. </p>

<p>Basically this would be a use case for <code>Publishers.CombineLatest</code>, but since my underlying publishers both emit values of the same type a <code>merge</code> would be more fitting here. But <code>Publishers.Merge</code> will not remember the last values of the merged publishers.</p>

<p>Therefore I would like to have a <code>Publishers.CombineLatest</code> behaviour with a <code>Publishers.Merge</code> operation. Is there something inside the Combine framework which can accomplish this kind of behaviour ? </p>

<p><strong>Rough example what should happen:</strong></p>

<pre><code>Definitions:

PublisherA: emits -&gt; [Value]
PublisherB emits -&gt; [Value]

CombinedAB: -&gt; [Value]


PublisherA changes: CombinedAB -&gt; [NewA, OldB]
PublisherB changes: CombinedAB -&gt; [OldA, NewB]
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>
let a = CurrentValueSubject&lt;[Int], Never&gt;([""a"", ""b"", ""c""])
let b = CurrentValueSubject&lt;[Int], Never&gt;([""d"", ""e"", ""f""])

let combined = Publisher.AnyThing(a, b)

combined.sink {
   print($0)
}


b.send([""g"", ""h"", ""i""])


Outputs:
[""a"", ""b"", ""c"", ""d"", ""e"", ""f""]
[""a"", ""b"", ""c"", ""g"", ""h"", ""i""]

</code></pre>

<p>So it's basically a <code>Publishers.CombineLatest</code> but without emitting a tuple of (NewA,OldB) but instead already merged, because both values have the same type.</p>

<p>Any help is much appreciated.</p>
","4454752","","4454752","","2020-02-10 14:51:10","2021-09-12 05:04:10","Combine Publishers.Merge but with Publishers.combineLatest behaviour","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"60157510","1","60171763","","2020-02-10 19:57:43","","1","885","<p>I am looking to trigger a SwiftUI function by physically shaking the device.  Since motion detection is not a capability of SwiftUI at this time, I need to use UIKit integration along with a coordinator to return a Bool value which will indicate that the device has been shaken, thereby triggering the SwiftUI function.</p>

<p>The following code all works great in recognizing the shaking of the device (this is proven by the separate “makeShakerSound()” function which plays a soundclip upon being shaken and it works great).  Besides the working code to recognize the shaking, I also included the code used to call ShakableViewRepresentable(isShaken: $shakeOccurred) from ContentView, below.</p>

<p>I created an EnvironmentObject to flag that the device has been shaken, and used objectWillChange to announce that a change has occurred.  </p>

<p>My problem is this:  When the shaking motion is detected, the shaking sound effect works great, but my ContentView is not updated for the change in the environmental object myDevice.isShaken.  I thought using objectWillChange might take care of this, but it doesn't.  What am I missing?  </p>

<p>My apologies - I'm a bit new at this.</p>

<pre><code>/* CREATE AN ENVIRONMENTAL OBJECT TO INDICATE DEVICE HAS BEEN SHAKEN */

import Combine
import SwiftUI

class MyDevice: ObservableObject {
    // let objectWillChange = ObservableObjectPublisher()
    var isShaken: Bool = false {
        willSet {
            self.objectWillChange.send()
        }
    }
}


/* DETECT SHAKE GESTURE AND FLAG THAT SHAKING HAS OCCURRED */

import UIKit
import SwiftUI

struct ShakableViewRepresentable: UIViewControllerRepresentable {

    class Coordinator: NSObject {
        var parent: ShakableViewRepresentable
        init(_ parent: ShakableViewRepresentable) {
            self.parent = parent
        }
    }

    func makeCoordinator() -&gt; ShakableViewRepresentable.Coordinator {
        Coordinator(self)
    }

    func makeUIViewController(context: Context) -&gt; ShakableViewController {
        ShakableViewController()
    }
    func updateUIViewController(_ uiViewController: ShakableViewController, context: Context) {}
}

class ShakableViewController: UIViewController {

    override func motionBegan(_ motion: UIEvent.EventSubtype, with event: UIEvent?) {
        guard motion == .motionShake else { return }

         /* SHAKING GESTURE WAS DETECTED */
        myDevice?.isShaken = true       /* ContentView doesn't update! */
        makeShakerSound()       /* This works great */

        /* I’M TRYING TO TRIGGER A FUNCTION IN SWIFTUI BY SHAKING THE DEVICE:  Despite setting the myDevice.isShaken environment object to ""true"", my ContentView doesn't update when the shaking gesture is detected.   */

    }
}


ContentView.swift

    @EnvironmentObject var myDevice: MyDevice

    var body: some View {
        NavigationView {

            ZStack {

                /* DETECT SHAKE GESTURE - This works */
                ShakableViewRepresentable()
                    .allowsHitTesting(false)

                VStack {
                    /* SHOW CURRENT STATE OF myDevice.isShaken - Doesn't update */
                    Text(self.myDevice.isShaken ? ""The device has been shaken"" : ""No shaking has occurred"")
                    Text(""Device was shaken: \(self.myDevice.isShaken.description)"")
                }

/* more views below */
</code></pre>
","12874585","","12874585","","2020-02-11 15:34:11","2020-02-11 16:41:01","Setting EnvironmentObject from a Shake Gesture (using UIKit) in SwiftUI doesn't update View","<ios><uikit><swiftui><combine><shake>","1","0","1","","","CC BY-SA 4.0"
"60157828","1","60167853","","2020-02-10 20:20:47","","0","177","<p>I have a strange issue where the textfield gets deleted after selecting another textfield.</p>

<p>I have an <code>EnvironmentObject</code></p>

<pre><code>func applicationDidFinishLaunching(_ aNotification: Notification) {
        // Create the SwiftUI view that provides the window contents.
        let shellInteractor = ShellInteractor()
        let contentView = ContentView().environmentObject(shellInteractor)
}
</code></pre>

<p>injected in the view</p>

<pre><code>struct ContentView: View {
    @EnvironmentObject var shellInteractor: ShellInteractor

    var body: some View {
        ScrollView {
            VStack {
                HStack {
                    Text(""Enter target bundle identifier:"")
                    TextField(""com.mycompany.app"", text: $shellInteractor.bundleId)
                }.padding()
                HStack {
                    Text(""Enter icon badge count:"")
                    TextField(""0"", text: $shellInteractor.badgeNumber)
                }.padding()
                HStack {
                    Text(""Enter message identifier:"")
                    TextField(""ABCDEFGHIJ"", text: $shellInteractor.messageId)
                }.padding()

                Text(""Found Running Sim: "")
                Text(self.shellInteractor.shellOutput).fontWeight(.semibold)
                Button(action: {
                    self.shellInteractor.sendNotification()
                }) {
                    Text(""SEND!!!"")
                    .fontWeight(.semibold)
                }.padding()
            }.padding()
        }
    }
}
</code></pre>

<pre><code>class ShellInteractor: ObservableObject {
    @Published var shellOutput: String = """"

    public var badgeNumber: String = """"
    public var messageId: String = """"
    public var bundleId: String = """"
}
</code></pre>

<p>As I said, when I enter a text in any of the textfields and select another text field or tap the <code>TAB</code> key (basically when losing focus), the textfield deletes the text and shows the placeholder again.</p>
","2984775","","","","","2020-02-11 11:30:05","macOS SwiftUI Textfield gets deleted after losing focus","<macos><swiftui><textfield><combine>","1","0","","","","CC BY-SA 4.0"
"60164640","1","60165493","","2020-02-11 08:27:47","","3","1613","<p>I'm building a graphics app for iOS. Here is my code.</p>

<pre><code>class Group {

    /// All the shapes contained in the group
    public var shapes: CurrentValueSubject&lt;[Shape], Never&gt;

    /// The frame of the group
    var frame: CurrentValueSubject&lt;CGRect, Never&gt;

    /// The path to be calculated and displayed to users from the contained shapes
    var cgPath: CurrentValueSubject&lt;CGPath, Never&gt;
}

class Shape {
    var path: CurrentValueSubject&lt;Path, Never&gt;  = .init(Path())
}

struct Path {
    public var points = [CGPoint]()
}
</code></pre>

<p>So, here is what I want to do but don't know how to do it with Combine. </p>

<p>I want <code>Group</code> to observe it's own <code>frame</code>, <code>shapes</code>, and the <code>path</code> of it's shapes (I need to merge all this), so every time each of they change, I can calculate the new CGPath to display and assign it to the <code>cgPath</code> property (which will be observed by the View that draws everything).</p>

<p>Please, let me know if this is possible or if there is a better approach to all this.</p>

<p>Thanks in advance.</p>
","705309","","","","","2020-02-11 09:38:10","Swift Combine - Observe property in object inside array of N objects and merge with other properties","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"60173183","1","60173385","","2020-02-11 16:15:45","","2","1685","<p>I have a simple question that I can see only <code>dataTaskPublisher</code> in <a href=""https://developer.apple.com/documentation/foundation/urlsession"" rel=""nofollow noreferrer"">documentation</a> with which I was able to call a get web service but how can I call a post web service which can return a publisher?</p>
","8487592","","","","","2020-02-11 16:27:48","How to call a post web service with UrlSession.DataTaskPublisher?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"60188805","1","","","2020-02-12 12:52:06","","2","124","<p>I am attempting to post a struct via notification centre, and then processing it with a subscriber elsewhere. I have confirmed that the object within the notification is indeed an optional with the the Or object within it. The following code snippet works when the struct is converted to a class, however not with a struct - throwing the following error:</p>

<blockquote>
  <p>Could not cast value of type '__SwiftValue' (0x7fff89b99a48) to 'Recogniser.Gate' (0x7fff89b91168)</p>
</blockquote>

<p>Is there any reason for this? And is there anything that I can do to solve this? </p>

<pre><code>protocol Gate { var description: String { get } }
struct Not: Gate { var description: String { ""Not"" } }
struct Or: Gate { var description: String { ""Or"" } }

var gateSubscriber = NotificationCenter.Publisher(center: .default, name: .gateRecognised, object: nil)
    .map { notification in return notification.object as! Gate }
    .sink(receiveValue: { gate in print(gate.description) } )

NotificationCenter.default.post(name: .gateRecognised, object: GateType.buildGate(of: .or))
</code></pre>
","7965651","","7965651","","2020-02-12 13:14:07","2020-02-12 13:14:07","Unwrapping Struct vs Class within Swift Combine Publisher","<swift><struct><option-type><combine>","0","1","","2020-02-13 10:44:48","","CC BY-SA 4.0"
"60198065","1","60215469","","2020-02-12 22:52:00","","0","1195","<p>I have an app where users can sign up and login using Firebase. However, I can not seem to alert the user of any errors in the view.</p>

<p>First we have a <strong>UserStore</strong> which is a <code>ObservableObject</code> and is initialised as an <code>EnvironmentObject</code> when setting up the view in the <code>SceneDelegate</code>. </p>

<pre><code>let appView = AppView().environmentObject(userStore)

  if let windowScene = scene as? UIWindowScene {
        let window = UIWindow(windowScene: windowScene)
        window.rootViewController = UIHostingController(rootView: appView)
        self.window = window
        window.makeKeyAndVisible()

}
</code></pre>

<p>Then we sign up or login to the View like so. </p>

<p><strong>In View</strong> </p>

<pre><code>self.userStore.logIn(email: self.email, password: self.password)
self.isLoggingIn = true

if self.userStore.failedToLogin {
   self.isLoggingIn = false
   self.alertTitle = ""There seems to be a problem""
   self.alertBody = self.userStore.errorMessage
   self.showingAlert = true
}
</code></pre>

<p>Then the actual method should update the UserStore property values which then update the view and display an alert, however, this is not the case. </p>

<p><strong>SignIn</strong> </p>

<pre><code>// Session Properties
@Published var isLoggedIn = false {didSet{didChange.send() }}
@Published var isNewUser = false {didSet{didChange.send() }}
@Published var failedToCreateAccount = false {didSet{didChange.send() }}
@Published var failedToLogin = false {didSet{didChange.send() }}
@Published var errorMessage = """" {didSet{didChange.send() }}

init () {
  handle = Auth.auth().addStateDidChangeListener { (auth, user) in
    if let user = user {
      self.session = user
      self.isLoggedIn = true
      //Change isNewUser is user document exists?
   } else {
      self.session = nil
      self.isLoggedIn = false
    }
  }
}

func logIn(email: String, password: String) {

    Auth.auth().signIn(withEmail: email, password: password) { [weak self] user, error in

        print(""Signed In"")

        if(error != nil) {
            print(""Failed to login"")

            self!.failedToLogin = true
            self!.errorMessage = (""\(String(describing: error))"")
            print(error!)
            return
        } else if error == nil {
            print(""Success Logging In"")

        }
    }
}
</code></pre>

<p>The AppView determines which view is loaded depending if the user is logged in.</p>

<p><strong>AppView</strong></p>

<pre><code>        if !userStore.isLoggedIn {
            LoginView().transition(.opacity)
        }

        if userStore.isLoggedIn  {
            ContentView().transition(.opacity)
        }
</code></pre>

<p>Atm error messages are not shown; the login view is also shown shortly before the main view.</p>

<p>How can I correctly display error messages in the view ? </p>
","4556409","","4556409","","2020-02-13 19:56:58","2020-06-14 00:51:42","Handling Firebase Auth error in SwiftUI Combine app","<swift><firebase><firebase-authentication><swiftui><combine>","2","3","1","","","CC BY-SA 4.0"
"60211919","1","","","2020-02-13 15:57:47","","0","317","<p>I've been beating my head against this for a few hours and I'm starting to go crazy. I have a SwiftUI view, defined like this:</p>

<pre><code>struct ExistingClaims: View {
  @ObservedObject var viewModel = ExistingClaimsListModel()
  @EnvironmentObject var newClaim : NewClaimModel

  var body: some View {
    NavigationView{
      List(viewModel.claims) { dataItem in
        NavigationLink(destination: ClaimDetails()){
          HStack(spacing: 10){
            VStack(alignment: .leading, spacing: 3) {
              Text(dataItem.subject)
              Text(String(dataItem.caseNumber)).font(.subheadline).italic()
            }
          }
        }
      }
      // Navigation Bar
      .navigationBarTitle(Text(""Exisitng Claims""), displayMode: .inline)
      // Navigation bar button
      .navigationBarItems(
        leading: Button(""Logout"") {
          self.viewModel.claims = []
          UserAccountManager.shared.logout()
        },
        trailing: NavigationLink(
        destination: NewClaim()) {
          Image(systemName: ""plus"")
        }
      )
    }
    .onAppear{
      print(""On Appear firing for ExistingClaims()"")
      self.viewModel.fetchDataFromSalesforce()
    }
  }
}
</code></pre>

<p>All this works fine. Until i try to add an .onReceive clause to the List like this:</p>

<pre><code>List(viewModel.claims) { dataItem in
    NavigationLink(destination: ClaimDetails()){
      HStack(spacing: 10){
        VStack(alignment: .leading, spacing: 3) {
          Text(dataItem.subject)
          Text(String(dataItem.caseNumber)).font(.subheadline).italic()
        }
      }
    }
  }.onReceive(self.newClaim.complete){ data in
    print(data)
  }
</code></pre>

<p>As soon as I add that onReceive I get a really odd error - shown in this screen shot:
<a href=""https://i.stack.imgur.com/eG5Ih.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eG5Ih.png"" alt=""Screenshot showing error""></a></p>

<p>Any ideas what's going on? My end goal is to refresh the list data when the environmentobject's published property (or state, I've tried both) update</p>
","1132573","","","","","2020-02-13 16:34:15","Addition of an .onReceive closure to SwiftUI List -> Weird errors","<swift><xcode><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"60218009","1","60219175","","2020-02-13 23:29:25","","0","1372","<p>In the example below, ""2"" will never be printed, since the error is a completion event, stopping the publisher from sending any more events. That's very clear to me.</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine

enum TestError: Error {
  case ohnoes
}

let publisher = PassthroughSubject&lt;Int, Error&gt;()

publisher
  .sink(receiveCompletion: { completion in
  print(completion)
}) { int in
  print(int)
}

publisher.send(1)
publisher.send(completion: .failure(TestError.ohnoes))
publisher.send(2)
</code></pre>

<p>Sadly, even <code>replaceError</code> and <code>catch</code> won't stop the completion event, so the pipeline will still end.</p>

<p>So my question is, how can I replace the error with a <code>nil</code> value and prevent the completion event? Basically I want to transform <code>AnyPublisher&lt;Int, Error&gt;</code> into <code>AnyPublisher&lt;Int?, Never&gt;</code>, for those cases where I simply don't care about the error at all, and just want to keep receiving future values.</p>

<p>With ReactiveKit I had this extension:</p>

<pre class=""lang-swift prettyprint-override""><code>extension Signal {
  func errorToOptional() -&gt; Signal&lt;Element?, Never&gt; {
    return Signal&lt;Element?, Never&gt; { observer in
      self.observe { event in
        switch event {
        case .next(let element):
          observer.receive(element)
        case .failed:
          observer.receive(nil)
        case .completed:
          observer.receive(completion: .finished)
        }
      }
    }
  }
}
</code></pre>

<p>And it worked great. But the Combine types make creating extensions like these very difficult (if not impossible?).</p>
","403425","","","","","2020-02-14 02:28:39","Combine: can I replace an error with nil?","<swift><combine><reactivekit>","1","2","","","","CC BY-SA 4.0"
"60222064","1","60222152","","2020-02-14 07:49:08","","1","1762","<p>I have a SwiftUI view that displays the result of a CoreData query.<br>
In it's parent view I want to display the count of the query (without querying one more time).<br>
I tried to pass the count to the parent in a Binding, but I get the warning ""Modifying state during view update, this will cause undefined behavior."" an it does not work.</p>

<pre><code>import SwiftUI

struct CD_Main: View {
  @State var count = 0

    var body: some View {
      VStack {
        Text(""count in main: \(count)"")
        CD_Query(c: $count)
      }
    }
}

struct CD_Query: View {
  @Binding var c : Int

  @Environment(\.managedObjectContext) var moc
  @FetchRequest(entity: Item.entity(), sortDescriptors: [], predicate: nil) var items: FetchedResults&lt;Item&gt;

  var body: some View {
  c = items.count // Produces: Modifying state during view update, this will cause undefined behavior.
    return VStack {
      Text(""Count Innen: \(items.count) "")
      List(items, id: \.self) {
        item in
        Text(item.title)
      }
    }
  }
}
</code></pre>

<p>Any ideas how to set the Binding correctly or how else to pass the count to the parent?</p>
","1165251","","","","","2020-02-14 07:56:07","return count from a SwiftUI CoreData View","<ios><core-data><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"60223041","1","60226849","","2020-02-14 09:01:41","","3","1012","<p>I have a simple <code>Deferred Publisher</code> that reads data from disk and I display the data in a <code>SwiftUI List</code>, the <code>Publisher</code> works well most of the time, but <strong><em>sometimes</em></strong> it doesn't behave well, it just loses its value (which's an array of <code>Model</code> objects) and completes with <code>finished</code> message. I've tried a workaround mentioned <a href=""https://forums.swift.org/t/combine-receive-on-runloop-main-loses-sent-value-how-can-i-make-it-work/28631/5"" rel=""nofollow noreferrer"">here</a> to use the <code>buffer</code> operator to keep the value in buffer because I believe the <code>Combine's Publisher</code> by design won't pass the data downstream if there is no demand requested by subscribers and hence dropping this data and completes, however using <code>buffer</code> didn't solve the issue.</p>

<p>The code I have:</p>

<pre><code>enum FileError: Error {
    case someError
}

class ViewModel: ObservableObject {
    @Published var modelArray = [Model]()
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    func readData() {
        DataSource()
            .readFromBundle(resource: ""Sample"", type: ""json"")
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                print(""Completion: \(completion)"")
            }) { array in
                self.modelArray = array
        }.store(in: &amp;subscriptions)
    }
}
struct ContentView: View {
    @ObservedObject var viewModel: ViewModel

    var body: some View {
        VStack {
            List(self.viewModel.modelArray) { model in
                Text(""\(model.name)"")
            }
        }
        .onAppear {
            self.viewModel.readData()
        }
    }
}

struct Model: Codable, Identifiable {
    var id: Int
    var name: String
}

class DataSource {
    private let readQueue = DispatchQueue(label: ""ReadQueue"", qos: .default, attributes: .concurrent)

    func readFromBundle (resource: String, type:String) -&gt; AnyPublisher&lt;[Model], FileError&gt; {
            Deferred {
                 Future { promise in
                    guard let url = Bundle.main.url(forResource: ""Sample"", withExtension: ""json""),
                      let data = try? Data(contentsOf: url),
                      let modelArray = try? JSONDecoder().decode([Model].self, from: data)
                      else {
                        promise(.failure(.someError))
                        return
                    }
                      promise(.success(modelArray))
                }
            }
           .receive(on: self.readQueue)
           .eraseToAnyPublisher()
        }
}
</code></pre>

<p><a href=""https://www.dropbox.com/s/2vuit169xl8gspq/Test.zip?dl=0"" rel=""nofollow noreferrer"">This is a link</a> to download a working sample project.</p>

<p><strong>EDIT:</strong></p>

<p>Environment: Xcode 11.3.1, iOS 13.3 iPhone 11 Pro Max simulator and device.</p>

<p>gif screenshot (notice the console output) </p>

<p><a href=""https://i.stack.imgur.com/WmWDI.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WmWDI.gif"" alt=""enter image description here""></a></p>

<p><strong><em>EDIT2:</em></strong></p>

<p>if I add any downstream publishers, like <code>combineLatest</code> for example just before <code>sink</code> in the consumer function <code>readData()</code> then a new behavior introduced, which's chaining an async publisher (readFromBundle) with a sync publisher (<code>combineLatest</code>) will result in the value will not deliver at all on <code>iOS 13.3+</code> devices and will sometimes deliver on devices below <code>iOS 13.3</code>, as stated on <a href=""https://forums.swift.org/t/combine-receive-on-runloop-main-loses-sent-value-how-can-i-make-it-work/28631/39"" rel=""nofollow noreferrer"">this link</a>.</p>
","1056118","","1056118","","2020-02-15 10:36:49","2021-03-04 10:11:16","Combine: Publisher sometimes loses value and completes","<ios><swiftui><combine>","4","7","","","","CC BY-SA 4.0"
"60227260","1","","","2020-02-14 13:26:07","","2","646","<p>I'm trying to learn SwiftUI and Core Data (no experience with swift or objective C at all), and working my way through it by writing an app to track gym workouts.  </p>

<p>I have a Workout entity that has a one-many relationship to an Exercise entity.</p>

<p>In my app, I start with a list of Workouts in a nav view pulled from core data.  Then I use a nav link to pass the selected Workout object to a details view that displays the properties of the Workout object.  The details view includes the workout name, date created, and a list of exercises tied to that workout.  The exercise list is loaded from the relationship property of the Workout object.</p>

<p>Next, I use a button to pass the Workout object to a sheet view that has a list of exercises.  The exercise list is a fetchrequest of the Exercise entity, and there is a checkmark next to each exercise in the list that has a relationship to the workout.  Each row in the list is an instance of another ""row"" view, and the entire row is a button.  The user can tap on row to add/remove it from the workout.</p>

<p>So far, this all works great. My problem is that the workout details view doesn't update when I use the exercise list sheet view to make changes to the workout's relationship to the exercise entity.  Core data does get updated, but the details view doesn't refresh the updated object from core data when the exercise sheet view is closed.  </p>

<p>If I go back one step more to the parent view with the list of Workouts, and select that same Workout object again, now the details view refreshes with the correct exercise list from core data.</p>

<p>I think this is because the parent workout list is using a fetch request to get workout objects, and all the child views are just passing a single instance of the workout object down but not monitoring it for changes.  When I get back to the workout list, I guess fetch request is replacing the object instance with the latest data.</p>

<p>I want the details view to realize when the relationship property is changed in the exercise sheet view, and then update the Exercise list that appears on that details view with those changes.  </p>

<p>How can I make this work? I've tried <code>@ObservedObject</code> on the Workout object that is getting passed through the view hierarchy, and I've tried <code>managedObjectContext.refresh(Workout, mergeChanges: true)</code> when the dismiss button on the sheet view is tapped, but nothing.</p>

<p>Any ideas?</p>

<pre><code>//
//  WorkoutDetail.swift


import SwiftUI

struct WorkoutDetail: View {

    @Environment (\.managedObjectContext) var moc

    @ObservedObject var workout: Workout
    @State private var workoutDate: Date
    @State private var exerciseArray: [Exercise]
    @State private var workoutName: String
    @State private var showingAddScreen = false
    var fetchRequest: FetchRequest&lt;Workout&gt;



    static let setDateFormat: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = ""MMMM d, y, h:mm a""
        return formatter
    }()

    init(workout: Workout) {
        self.workout = workout
        // Define the initial form field values
        _workoutName = .init(initialValue: workout.wrappedWorkoutName)
        _workoutDate = .init(initialValue: workout.wrappedWorkoutDate)
        _exerciseArray = .init(initialValue: workout.workoutExerciseArray)
        let workoutPredicate = NSPredicate(format: ""workoutName == %@"", workout.workoutName!)
        fetchRequest = FetchRequest&lt;Workout&gt;(entity: Workout.entity(), sortDescriptors: [], predicate: workoutPredicate)

    }

    var body: some View {
            Form {
                Section(header: Text(""Workout Name"")) {
                    TextField(""Workout Name"", text: $workoutName)
                    Text(""Created \(workoutDate, formatter: Self.setDateFormat)"")

                    Button(""Save Changes"") {
                        self.workout.setValue(self.workoutName, forKey: ""workoutName"")
                        try? self.moc.save()
                    }
                }
                Section(header: Text(""Exercises"")) {
                    Button(action: {self.showingAddScreen.toggle()}) {
                    HStack {
                        Image(systemName: ""pencil"")
                        Text(""Add/Remove Exercises"")}
                    }
                    List{
                        ForEach(exerciseArray, id:\ .self) { exercise in
                            VStack(alignment: .leading) {
                                NavigationLink(destination: ExerciseSet(exerciseSetExercise: exercise, exerciseSetWorkout: self.workout)) {
                                    WorkoutExercise(exercise: exercise)
                                }
                            }
                        }
                    }
                }
            }.navigationBarTitle(""\(workoutName)"")
            .sheet(isPresented: $showingAddScreen) {
                AddExerciseToWorkout(workout: self.workout).environment(\.managedObjectContext, self.moc)}
        }
}
</code></pre>

<pre><code>//
//  AddExerciseToWorkout.swift


import SwiftUI


struct AddExerciseToWorkout: View {
    @ObservedObject var workout: Workout
    @State private var exerciseArray: [Exercise]
    @State private var workoutName: String
    var exerciseNameArray: [String] = []
    @State var selectedExercises: [String] = []
    @FetchRequest(entity: Type.entity(), sortDescriptors: [NSSortDescriptor(key:""typeName"", ascending: true)]) var strengthExercises: FetchedResults&lt;Type&gt;
    @Environment(\.presentationMode) var presentationMode


    init(workout: Workout) {
        self.workout = workout
        _exerciseArray = .init(initialValue: workout.workoutExerciseArray)
        _workoutName = .init(initialValue: workout.wrappedWorkoutName)
    }


    var body: some View {
        VStack {

            Text(""\(workoutName) exercises:"")
                .font(.headline)
                .padding()
            List{
                ForEach(strengthExercises, id:\.self) { strengthExercise in
                    Section(header: Text(strengthExercise.wrappedTypeName)) {
                        ForEach(strengthExercise.typeExerciseArray, id: \.self) { exercise in
                            AddExerciseToWorkoutRow(workout: self.workout, exercise: exercise)

                        }
                    }
                }
            }
            Button(""Done"") {self.presentationMode.wrappedValue.dismiss()
            }
        }
    }
}
</code></pre>

<pre><code>//
//  AddExerciseToWorkoutRow.swift


import SwiftUI
import CoreData

struct AddExerciseToWorkoutRow: View {
    @Environment(\.managedObjectContext) var moc
    let exercise: Exercise
    @ObservedObject var workout: Workout
    @State private var exerciseArray: [Exercise]
    @State private var isSelected: Bool = false


    init(workout: Workout, exercise: Exercise) {
        self.workout = workout
        self.exercise = exercise
        _exerciseArray = .init(initialValue: workout.workoutExerciseArray)
        if exerciseArray.contains(exercise) {
            _isSelected = .init(initialValue: true)
        } else {
            _isSelected = .init(initialValue: false)
        }
    }


    var body: some View {
        Button(action: {
            if self.exerciseArray.contains(self.exercise) {
                self.workout.removeFromWorkoutToExercise(self.exercise)
                self.isSelected = false
            } else {
                self.workout.addToWorkoutToExercise(self.exercise)
                self.isSelected = true
            }
            try? self.moc.save()
                self.moc.refresh(self.workout, mergeChanges: true)
                self.workout.didChangeValue(forKey: ""workoutToExercise"")
        }) {
            HStack {
                Text(exercise.wrappedExerciseName)
                Spacer()
                if self.isSelected {
                    Image(systemName: ""checkmark"")
                        .foregroundColor(.green)
                }
            }
        }
    }
}
</code></pre>
","12783119","","12783119","","2020-02-14 23:17:55","2020-02-15 12:23:59","ManagedObject and ObservedObject","<core-data><observable><swiftui><nsmanagedobject><combine>","1","0","","","","CC BY-SA 4.0"
"60241335","1","60241460","","2020-02-15 17:33:55","","3","1274","<p>For some reason when I type in the search field it does not print out Xcode console the ""str"". What am I missing here? I followed his tutorial <a href=""https://www.letsbuildthatapp.com/course_video?id=5232"" rel=""nofollow noreferrer"">https://www.letsbuildthatapp.com/course_video?id=5232</a></p>

<pre><code>import UIKit

class SearchViewController: UIViewController {

    let searchController = UISearchController(searchResultsController: nil)

    var sink: Any?

    override func viewDidLoad() {
        super.viewDidLoad()

        setupSearchBarListener()

        navigationItem.searchController = searchController

        navigationController?.navigationBar.prefersLargeTitles = true
        navigationItem.title = ""Contact""

        searchController.obscuresBackgroundDuringPresentation = false

        view.backgroundColor = .white
    }

    fileprivate func setupSearchBarListener() {

        let publisher = NotificationCenter.default.publisher(for: UISearchTextField.textDidChangeNotification, object: searchController.searchBar.searchTextField)
        publisher
            .map {
            ($0.object as! UISearchTextField).text
        }
            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)
            .sink { (str) in
                print(str ?? """")
        }

    }
}
</code></pre>
","10655230","","","","","2020-02-15 18:46:10","Somehow combine with search controller not working, any idea?","<ios><swift><xcode><uikit><combine>","1","0","1","","","CC BY-SA 4.0"
"60242270","1","60243156","","2020-02-15 19:17:48","","1","136","<p>I have the following model object that I use to populate a <code>List</code> with a <code>Toggle</code> for each row, which is bound to <code>measurement.isSelected</code></p>

<pre><code>final class Model: ObservableObject {

    struct Measurement: Identifiable {
        var id = UUID()
        let name: String
        var isSelected: Binding&lt;Bool&gt;

        var selected: Bool = false

        init(name: String) {
            self.name = name

            let selected = CurrentValueSubject&lt;Bool, Never&gt;(false)
            self.isSelected = Binding&lt;Bool&gt;(get: { selected.value }, set: { selected.value = $0 })
        }
    }

    @Published var measurements: [Measurement]
    @Published var hasSelection: Bool = false  // How to set this?

    init(measurements: [Measurement]) {
        self.measurements = measurements
    }
}
</code></pre>

<p>I'd like the <code>hasSelection</code> property to be true whenever any <code>measurement.isSelected</code> is <code>true</code>. I'm guessing somehow <code>Model</code> needs to observe changes in <code>measurements</code> and then update its <code>hasSelection</code> property… but I've no idea where to start!</p>

<p>The idea is that <code>hasSelection</code> will be bound to a <code>Button</code> to enable or disable it.</p>

<hr>

<p><code>Model</code> is used as follows…</p>

<pre><code>struct MeasurementsView: View {

    @ObservedObject var model: Model

    var body: some View {
        NavigationView {
            List(model.measurements) { measurement in
                MeasurementView(measurement: measurement)
            }
            .navigationBarTitle(""Select Measurements"")
            .navigationBarItems(trailing: NavigationLink(destination: NextView(), isActive: $model.hasSelection, label: {
                Text(""Next"")
            }))
        }
    }
}

struct MeasurementView: View {
    let measurement: Model.Measurement
    var body: some View {
        HStack {
            Text(measurement.name)
                .font(.subheadline)
            Spacer()
            Toggle(measurement.name, isOn: measurement.isSelected)
                .labelsHidden()
        }
    }
}
</code></pre>

<hr>

<p>For info, here's a screenshot of what I'm trying to achieve. A list of selectable items, with a navigation link that is enabled when one or more is selected, and disabled when no items are selected.</p>

<p><a href=""https://i.stack.imgur.com/KnPgil.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KnPgil.png"" alt=""enter image description here""></a></p>
","123632","","123632","","2020-02-16 17:16:32","2020-02-16 18:32:25","How to add an observable property when other properties change","<swiftui><combine>","2","3","","","","CC BY-SA 4.0"
"60285177","1","","","2020-02-18 16:14:41","","1","3849","<p>I'm struggling to implement a custom view which can take Binding as an argument and implement two-way updates of that value.</p>

<p>So basically I'm implementing my custom slider and want its initializer to be like this:</p>

<p><code>MySlider(value: &lt;Binding&lt;Float&gt;)</code></p>

<hr>

<p>What I'm struggling with:</p>

<ol>
<li>How do I subscribe to remote updates of the binding value so that I can update the view's state?</li>
<li>Is there any nice way to bind a Binding with @State property?</li>
</ol>

<hr>

<p>Here's my current implementation so far which is not perfect.</p>

<pre><code>struct MySlider: View {

    @Binding var selection: Float?
    @State private var selectedValue: Float?

    init(selection: Binding&lt;Float?&gt;) {
        self._selection = selection

        // https://stackoverflow.com/a/58137096
        _selectedValue = State(wrappedValue: selection.wrappedValue)
    }

    var body: some View {
         HStack(spacing: 3) {
             ForEach(someValues) { (v) in
                 Item(value: v,
                      isSelected: v == self.selection)
                     .onTapGesture {
                         // No idea how to do that other way so I don't have to set it twice
                         self.selection = v
                         self.selectedValue = v
                    }
             }
         }
    }
}
</code></pre>

<hr>

<p><strong>Edit 1:</strong>
I suppose my problem is that the underlying model object comes from Core Data and <strong>wasn't owned by any SwiftUI view which would observe its changes.</strong> The model object was owned by the UIKit ViewController and I was passing only a Binding to the SwiftUI view which is not enough.
My solution now is to pass the model object also to the SwiftUI View so that it can marked it as an <code>@ObservedObject</code>.</p>

<pre><code>struct MySlider&lt;T&gt;: View where T: ObservableObject {

    @ObservedObject var object: T
    @Binding var selection: Float?

    var body: some View {
        return ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 3) {
                ForEach(values) { (v) in
                    Item(value: v,
                         isSelected: v == self.selection)
                        .onTapGesture {
                            self.selection = v
                    }
                }
            }
        }
    }
}
</code></pre>
","380014","","380014","","2020-02-19 10:04:30","2020-08-24 09:53:14","Custom SwiftUI view with a two-way binding","<ios><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"60295544","1","60307697","","2020-02-19 08:02:28","","5","1548","<p>In <code>Combine</code>, using only the built-in operators, is there a way to skip an operator on the first value but then apply that operator for all subsequent values? </p>

<p>Consider the following: </p>

<pre><code>publisher
  .debounce(...)
  .sink(...)
</code></pre>

<p>In this arrangement, <code>debounce</code> will wait for the specified timeout to elapse before passing on the value to <code>sink</code>. However, there are many times when you only want <code>debounce</code> to kick-in after the first element. For example, if the user is trying to filter a list of contacts, it's very possible that they only enter one letter into a text field. If that's the case, the application should probably start filtering immediately, without having to wait for the <code>debounce</code> to timeout.</p>

<p>I'm aware of the <code>Drop</code> publishers, but I can't seem to find a combination of them that will perform more of a ""skip"" operation such that the <code>sink</code> receives every value, but the <code>debounce</code> is ignored on the first value. </p>

<p>Something like the following: </p>

<pre><code>publisher
  .if_first_element_passthrough_to_sink(...), else_debounce(...)
  .sink(...)
</code></pre>

<p>Is something like this possible with the built-in operators? </p>

<p><strong>Clarification</strong></p>

<p>Some clarification since my original posting wasn't as clear as it should have been... The answer provided by Asperi below is very close, but ideally the first element in a sequence is always delivered, then <code>debounce</code> would kick in. </p>

<p>Imagine the user is typing the following: </p>

<blockquote>
  <p>A B C ... (pauses typing for a few seconds) ... D ... (pauses) ... E F G</p>
</blockquote>

<p>What I would like is: </p>

<ul>
<li><code>A</code>, <code>D</code> and <code>E</code> are delivered immediately.</li>
<li><code>B C</code> is coalesced into just <code>C</code> using <code>debounce</code></li>
<li><code>F G</code> is coalesced into just <code>G</code> using <code>debounce</code></li>
</ul>
","48321","","48321","","2020-02-19 21:51:17","2020-02-20 09:53:41","How do you apply a Combine operator only after the first message has been received?","<ios><swift><macos><combine>","2","0","","","","CC BY-SA 4.0"
"60306102","1","60306248","","2020-02-19 17:30:58","","0","781","<p>The issue can be seen in the following playground. There are four published values that will be updated asynchronously (an image and three strings). When all four of them have been initialized or subsequently changed then the UI will need to be updated. When I try to capture this data flow using CombineLatest4 the compiler immediately objects to the fourth argument with the message <code>Extra argument in call</code>. (<strong>Note:</strong> the following code doesn't actually do anything since it only has a publisher, but it is sufficient to produce the error message in Playground).</p>

<pre><code>import Combine
import UIKit

struct CustomerUpdates
{
    @Published var photo: UIImage!
    @Published var firstName: String!
    @Published var lastName: String!
    @Published var id: String!

    typealias customerTuple =
        (   photo: UIImage,
            firstName: String,
            lastName: String,
            id: String )
    var validatedCustomer: AnyPublisher&lt; customerTuple, Never &gt;
    {
        return Publishers.CombineLatest4( $photo,
                                          $firstName,
                                          $lastName,
                                          $id )
        {
            photo, firstName, lastName, id in
            if      photo == nil
                ||  firstName == nil
                ||  lastName == nil
                ||  id == nil
            {
                return nil
            }
            return ( photo!, firstName!, lastName!, id! )
        }
        .compactMap
        .return( on: RunLoop.main )
    }
}
</code></pre>

<p>My question is, why does the compiler flag the fourth argument (the ""id"")? Apple's documentation for the CombineLatest4 generic struct says:</p>

<blockquote>
  <p>A publisher that receives and combines the latest elements from four
  publishers.</p>
</blockquote>
","7366424","","7366424","","2020-02-19 17:40:52","2020-02-20 09:47:10","""Extra argument"" error when using CombineLatest from the Combine framework","<ios><swift><compiler-errors><combine>","2","0","","","","CC BY-SA 4.0"
"60345806","1","","","2020-02-21 20:27:06","","10","6938","<p>I'm using Swift Combine for my API requests. Now I'm facing a situation where I want to have more than 4 parallel requests that I want to zip together. Before I had exactly 4 requests that I zipped together using Zip4() operator. I can imagine that you do the zipping in multiple steps but I don't know how to write the receiveValue for it.</p>

<p>Here's a simplification of my current code with 4 parallel requests:</p>

<pre><code>    Publishers.Zip4(request1, request2, request3, request4)
        .sink(receiveCompletion: { completion in
            // completion code if all 4 requests completed
        }, receiveValue: { request1Response, request2Response, request3Response, request4Response in
            // do something with request1Response
            // do something with request2Response
            // do something with request3Response
            // do something with request4Response
        }
    )
        .store(in: &amp;state.subscriptions)
</code></pre>
","10826194","","","","","2022-05-13 08:27:09","How to zip more than 4 publishers","<swift><combine>","8","0","6","","","CC BY-SA 4.0"
"60346009","1","","","2020-02-21 20:46:35","","3","1889","<p>I am new to SwiftUI and also Combine. I have a simple List and I am loading iTunes data and building the list. Loading of the images works - but they are flickering, because it seems my dispatch on the main thread keeps firing. I am not sure why. Below is the code for the image loading, followed by where it's implemented. </p>

<pre><code>struct ImageView: View {
    @ObservedObject var imageLoader: ImageLoaderNew
    @State var image: UIImage = UIImage()

    init(withURL url: String) {
        imageLoader = ImageLoaderNew(urlString: url)
    }

    func imageFromData(_ data: Data) -&gt; UIImage {
        UIImage(data: data) ?? UIImage()
    }

    var body: some View {
        VStack {
            Image(uiImage: imageLoader.dataIsValid ?
                imageFromData(imageLoader.data!) : UIImage())
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width:60, height:60)
                .background(Color.gray)
        }
    }
}

class ImageLoaderNew: ObservableObject
{    
    @Published var dataIsValid = false
    var data: Data?

    // The dispatch fires over and over again. No idea why yet
    // this causes flickering of the images in the List. 
    // I am only loading a total of 3 items. 

    init(urlString: String) {
        guard let url = URL(string: urlString) else { return }
        let task = URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data else { return }
            DispatchQueue.main.async {
                self.dataIsValid = true
                self.data = data
                print(response?.url as Any) // prints over and over again.
            }
        }
        task.resume()
    }
}
</code></pre>

<p>And here it's implemented after loading the JSON, etc. </p>

<pre><code>List(results, id: \.trackId) { item in
    HStack {

        // All of these image end up flickering
        // every few seconds or so.
        ImageView(withURL: item.artworkUrl60)
            .padding(EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: 5))

        VStack(alignment: .leading) {
            Text(item.trackName)
                .foregroundColor(.gray)
                .font(.headline)
                .truncationMode(.middle)
                .lineLimit(2)

            Text(item.collectionName)
                .foregroundColor(.gray)
                .font(.caption)
                .truncationMode(.middle).lineLimit(1)
            }
        }
    }
    .frame(height: 200.0)
    .onAppear(perform: loadData) // Only happens once
</code></pre>

<p>I am not sure why the images keep loading over and over again (yet). I must be missing something simple, but I am definitely not wise to the ways of Combine quite yet. Any insight or solution would be much appreciated.</p>
","852046","","","","","2022-08-23 15:16:17","SwiftUI List - Remote Image loading = images flickering (reloading)","<swiftui><combine>","4","0","","","","CC BY-SA 4.0"
"60355280","1","60357810","","2020-02-22 18:15:59","","2","73","<p>In the Combine framework, what is the <code>Never</code> type exactly?</p>

<p>I don't mean how is it used or what does it signify; I understand that. I mean what is the what-it-is-to-be-a-Never (as Aristotle would say).</p>

<p>I ask because I can't find a declaration of any <code>Never</code> other than this one:</p>

<blockquote>
  <p><a href=""https://developer.apple.com/documentation/swift/never"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/swift/never</a></p>
</blockquote>

<p>But the Combine framework <code>Never</code> cannot be that <code>Never</code>, because the Combine <code>Never</code> has to be usable as a <code>Failure</code> type, and a <code>Failure</code> type can only be an <code>Error</code> adopter:</p>

<blockquote>
  <p><a href=""https://developer.apple.com/documentation/combine/subscriber/3213651-failure"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/combine/subscriber/3213651-failure</a></p>
</blockquote>

<p>But I can find no declaration that the <code>Never</code> in my first link adopts the <code>Error</code> protocol as required by my second link.</p>

<p>So I would expect to be able to find either (1) a place where that <code>Never</code> is declared to adopt the <code>Error</code> protocol or (2) the declaration of a completely different <code>Never</code>. But I can't find it.</p>
","341994","","1271826","","2020-02-23 00:00:47","2020-02-23 00:00:47","What is the ontological status of the Combine framework's Never type?","<ios><combine>","1","0","","","","CC BY-SA 4.0"
"60377801","1","60378223","","2020-02-24 14:17:01","","2","832","<p>I just started to learn SwiftUI, but did not have time to Combine. I don’t understand much about this.
How to pass a value to the progress of downloading in ProgressView.
how to configure ODRManager and how to transfer the value when downloading is in progress, not 0 and immediately 1, but 0.0 ... 0.1.0.2 ... 0.8,0.9,1.0
I would like to know different ways and means only SwiftUI, and using Combine or other methods.</p>

<p>Thanks a lot .</p>

<p>SwiftUI Code</p>

<pre><code>import SwiftUI

struct ProgressView: View {

    @Binding var value: Float

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                Rectangle()
                    .frame(width: geometry.size.width, height: geometry.size.height)
                    .opacity(0.3)
                    .foregroundColor(.gray)

                Rectangle()
                    .frame(width: min(CGFloat(self.value) * geometry.size.width, geometry.size.width), height: geometry.size.height)
                    .foregroundColor(.blue)
                    .animation(.linear)
            }.cornerRadius(45.0)
        }
    }
}

struct ContentView: View {

    @State var progressValue: Float = 0.0

    var body: some View {
        VStack {
            Button(action: { //here is the function to download from ondemand }) {
                Text(""Download"")
                    .padding(.init(top: 10, leading: 30, bottom: 10, trailing: 30))
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(14)

            }
            .padding(.bottom, 30)

            ProgressView(value: $progressValue)
                .environmentObject(self.manager)
                .frame(width: 250, height: 20)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()

    }
}

</code></pre>

<p>OnDemand manager code</p>

<pre><code>class ODRManager: NSObject {
    var resourceRequest : NSBundleResourceRequest?
    var progress:Float = 0.0 

    func fetchODRResourceWithName(fileName: String) {
        guard self.resourceRequest == nil else {return}
        self.resourceRequest = NSBundleResourceRequest(tags: [fileName])
        progress = Float((resourceRequest?.progress.fractionCompleted)!)
        self.resourceRequest!.progress.addObserver(self, forKeyPath: ""fractionCompleted"", options: .new, context: nil)
        self.resourceRequest?.conditionallyBeginAccessingResources(completionHandler: { (resourceAvailable) in
            if !resourceAvailable {
                self.resourceRequest!.beginAccessingResources { err in
                    guard err == nil else {
                        print(err as Any)
                        return
                    }
                  print(""downloading.."")
                }
            } else { 
               print(""was downloaded"")
            }
        })
    }

    func stopDownloadingFile() {
        guard self.resourceRequest != nil else {
            return
        }
        self.resourceRequest!.endAccessingResources()
        self.resourceRequest!.progress.removeObserver(self, forKeyPath: ""fractionCompleted"")
        self.resourceRequest!.progress.cancel()
        self.resourceRequest = nil
    }

    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == ""fractionCompleted"" {
            DispatchQueue.main.async { [weak self] in
                self.progress = Float((self?.resourceRequest!.progress.fractionCompleted)!)
            }
        }
    }
}
</code></pre>
","9000279","","","","","2020-02-24 14:45:00","How to pass the value of progress in SwiftUI(maybe with combine)?","<swiftui><key-value-observing><combine>","2","0","1","","","CC BY-SA 4.0"
"60381905","1","60381982","","2020-02-24 18:26:06","","1","227","<p>I can see the Foundation header that defines <code>NSObject.KeyValueObservingPublisher</code>. But I can't find the header that defines the <code>publish(for:)</code> method that returns this publisher. And I can’t find it in the documentation. </p>

<p>It must involve NSObject, because only an NSObject can be observed with KVO. And it must come in the forms <code>publisher(for:)</code> and <code>publisher(for:options:)</code>, because that's what code completion offers me in Xcode. But <em>where</em> is code completion getting that information <em>from?</em></p>
","341994","","341994","","2020-02-25 11:13:52","2020-04-08 20:11:25","Where is the header that defines the `publisher(for:)` method that yields a KeyValueObservingPublisher?","<ios><combine>","1","0","","","","CC BY-SA 4.0"
"60386000","1","60390057","","2020-02-25 00:40:50","","7","2162","<p>I'm trying to use the Combine framework NSObject.KeyValueObservingPublisher. I can see how to produce this publisher by calling <code>publisher(for:options:)</code> on an NSObject. But I'm having two problems:</p>

<ul>
<li><p>I can include <code>.old</code> in the <code>options</code>, but no <code>.old</code> value ever arrives. The only values that appear are the <code>.initial</code> value (when we subscribe) and the <code>.new</code> value (each time the observed property changes). I can suppress the <code>.initial</code> value but I can't suppress the <code>.new</code> value or add the <code>.old</code> value.</p></li>
<li><p>If the <code>options</code> are <code>[.initial, .new]</code> (the default), I see no way to distinguish whether the value I'm receiving is <code>.initial</code> or <code>.new</code>. With ""real"" KVO I get an NSKeyValueChangeKey or an NSKeyValueObservedChange that tells me what I'm getting. But with the Combine publisher, I don't. I just get unmarked values.</p></li>
</ul>

<p>It seems to me that these limitations make this publisher all but unusable except in the very simplest cases. Are there any workarounds?</p>
","341994","","","","","2022-09-12 20:25:33","How to use Combine framework NSObject.KeyValueObservingPublisher?","<ios><combine>","2","2","1","","","CC BY-SA 4.0"
"60406189","1","60406282","","2020-02-26 03:11:38","","2","1365","<pre><code>import UIKit
import Combine

class ViewController: UIViewController {

    @IBOutlet weak var allowMessageSwitch: UISwitch!
    @IBOutlet weak var sendButton: UIButton!
    @IBOutlet weak var messageLabel: UILabel!

    @Published var canSendMessages: Bool = false
    @Published var newMsg: String = """"

    private var switchSubscriber: AnyCancellable?
    private var btnSubscriber: AnyCancellable?


    override func viewDidLoad() {
        allowMessageSwitch.isOn = false
        super.viewDidLoad()
        setupProcesscingChain()
    }

    func setupProcesscingChain() {
        switchSubscriber = $canSendMessages.receive(on: DispatchQueue.main).assign(to: \.isEnabled, on: sendButton)

        btnSubscriber = $newMsg.receive(on: DispatchQueue.main).assign(to: \.text, on: messageLabel)
    }

    @IBAction func didSwitch (_ sender: UISwitch) {
        canSendMessages = sender.isOn
    }

    @IBAction func sendMessage( _ sender: Any) {
    }


}
</code></pre>

<p>I am getting error in </p>

<pre><code>btnSubscriber = $newMsg.receive(on: DispatchQueue.main).assign(to: \.text, on: messageLabel)
</code></pre>

<p>error msg is </p>

<blockquote>
  <p>Type of expression is ambiguous without more context</p>
</blockquote>

<p>I dont understand why label does not work as Switcher (bool) </p>

<p>I assume it is because <code>\.isEnabled</code> is not optional, and <code>\.text</code> is optional..??</p>

<p>how can I make this work with the same format. this is for practice and to understand how Combine works.. please help!</p>
","12139943","","1271826","","2020-02-26 04:51:09","2020-02-26 04:51:09","Swift Combine question with UILabel subscribe","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"60409809","1","","","2020-02-26 08:40:01","","11","1412","<p>I'm trying to figure out how to work with async operations using Combine and SwiftUI.</p>

<p>For example, I have a <code>HealthKitManager</code> class that, among other things, handles requesting health store authorisation…</p>

<pre><code>final class HealthKitManager {

    enum Error: Swift.Error {
        case notAvailable
        case authorisationError(Swift.Error)
    }

    let healthStore = HKHealthStore()

        func getHealthKitData(for objects: Set&lt;HKObjectType&gt;, completion: @escaping (Result&lt;Bool, Error&gt;) -&gt; Void) {

        guard HKHealthStore.isHealthDataAvailable() else {
            completion(.failure(.notAvailable))
            return
        }

        self.healthStore.requestAuthorization(toShare: nil, read: objects) { completed, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(.failure(.authorisationError(error)))
                }
                completion(.success(completed))
            }
        }
    }
}
</code></pre>

<p>which is used as follows…</p>

<pre><code>struct ContentView: View {

    let healthKitManager = HealthKitManager()

    @State var showNextView = false
    @State var showError = false
    @State var hkError: Error?

    let objectTypes = Set([HKObjectType.quantityType(forIdentifier: .bloodGlucose)!])

    var body: some View {
        NavigationView {
            NavigationLink(destination: NextView(), isActive: $showNextView) {
                Button(""Show Next View"") {
                    self.getHealthKitData()
                }
            }.navigationBarTitle(""Content View"")
        }.alert(isPresented: $showError) {
            Alert(title: Text(""Error""), message: Text(hkError?.localizedDescription ?? """"), dismissButton: .cancel())
        }
    }

    func getHealthKitData() {
        self.healthKitManager.getHealthKitData(for: self.objectTypes) { result in
            switch result {
            case let .success(complete):
                self.showNextView = complete
            case let .failure(error):
                self.hkError = error
                self.showError = true
            }
        }
    }
}
</code></pre>

<p>What I'd like to do is use Combine rather than a <code>Result</code> closure. I'm guessing something like this…</p>

<pre><code>final class HealthKitManager: ObservableObject {

    enum Error: Swift.Error {
        case notAvailable
        case authorisationError(Swift.Error)
    }

    @Published var authorisationResult: Result&lt;Bool, Error&gt;?

     let healthStore = HKHealthStore()

    func getHealthKitData(for objects: Set&lt;HKObjectType&gt;) {

        guard HKHealthStore.isHealthDataAvailable() else {
            self.authorisationResult = .failure(.notAvailable)
            return
        }

        self.healthStore.requestAuthorization(toShare: nil, read: objects) { completed, error in
            DispatchQueue.main.async {
                if let error = error {
                    self.authorisationResult = .failure(.authorisationError(error))
                    return
                }
                self.authorisationResult = .success(completed)
            }
        }
    }
}
</code></pre>

<p>But then it's unclear how to bind to the values for <code>NavigationLink(isActive:)</code> and <code>alert(isPresented:)</code>, and to get the error.</p>

<pre><code>struct ContentView: View {

    @ObservedObject var healthKitManager = HealthKitManager()

    let objectTypes = Set([HKObjectType.quantityType(forIdentifier: .bloodGlucose)!])

    var body: some View {
        NavigationView {
            NavigationLink(destination: NextView(), isActive: ????) { // How do I get this
                Button(""Show Next View"") {
                    self.healthKitManager.getHealthKitData(for: self.objectTypes)
                }
            }.navigationBarTitle(""Content View"")
        }.alert(isPresented: ????) { // or this
            Alert(title: Text(""Error""), message: Text(????.localizedDescription ?? """"), dismissButton: .cancel()) // or this
        }
    }
}
</code></pre>

<p>I'm guessing that <code>@Published var authorisationResult: Result&lt;Bool, Error&gt;?</code> isn't correct? 
Should I be using <code>Future / Promise</code>, something else?</p>

<hr>

<p><em>Update</em></p>

<p>I found there's another way to present an alert…</p>

<pre><code>.alert(item: self.$error) { error in
        Alert(title: Text(error.localizedDescription))
</code></pre>

<p>which means I don't need the Bool for <code>showError</code> (it just requires the <code>Error</code> object to be <code>Identifiable</code>)</p>
","123632","","123632","","2020-03-09 09:06:47","2022-08-23 14:40:06","async operations using Combine and SwiftUI","<asynchronous><swiftui><combine>","2","1","3","","","CC BY-SA 4.0"
"60416549","1","60418000","","2020-02-26 14:49:45","","4","4742","<p>I am creating a Contact Class to fetch user's phoneNumbers asynchronously. </p>

<p>I created 3 functions that leveraged on the new Combine framework's Future. </p>

<pre><code>func checkContactsAccess() -&gt; Future&lt;Bool, Never&gt;  {
    Future { resolve in
            let authorizationStatus = CNContactStore.authorizationStatus(for: .contacts)

        switch authorizationStatus {
            case .authorized:
                return resolve(.success(true))

            default:
                return resolve(.success(false))
        }
    }
}
</code></pre>

<pre><code>func requestAccess() -&gt; Future&lt;Bool, Error&gt;  {
    Future { resolve in
        CNContactStore().requestAccess(for: .contacts) { (access, error) in
            guard error == nil else {
                return resolve(.failure(error!))
            }

            return resolve(.success(access))
        }
    }
}
</code></pre>

<pre><code>func fetchContacts() -&gt; Future&lt;[String], Error&gt;  {
   Future { resolve in
            let contactStore = CNContactStore()
            let keysToFetch = [
                CNContactFormatter.descriptorForRequiredKeys(for: .fullName),
                CNContactPhoneNumbersKey,
                CNContactEmailAddressesKey,
                CNContactThumbnailImageDataKey] as [Any]
            var allContainers: [CNContainer] = []

            do {
                allContainers = try contactStore.containers(matching: nil)
            } catch {
                return resolve(.failure(error))
            }

            var results: [CNContact] = []

            for container in allContainers {
                let fetchPredicate = CNContact.predicateForContactsInContainer(withIdentifier: container.identifier)

                do {
                    let containerResults = try contactStore.unifiedContacts(matching: fetchPredicate, keysToFetch: keysToFetch as! [CNKeyDescriptor])
                    results.append(contentsOf: containerResults)
                } catch {
                    return resolve(.failure(error))
                }
            }

            var phoneNumbers: [String] = []

            for contact in results {
                for phoneNumber in contact.phoneNumbers {
                    phoneNumbers.append(phoneNumber.value.stringValue.replacingOccurrences(of: "" "", with: """"))
                }
            }

            return resolve(.success(phoneNumbers))
        }
}
</code></pre>

<p>Now how do I combine these 3 Future into a single future? </p>

<p>1) Check if permission is available</p>

<p>2) If true fetchContacts asynchronously</p>

<p>3) If false requestAccess asynchronously then fetchContacts asynchronously</p>

<p>Any tips or tricks of how you will handle this better are also welcomed</p>

<pre><code>func getPhoneNumbers() -&gt; Future&lt;[String], Error&gt; {
...
}
</code></pre>
","9930296","","9930296","","2020-02-26 15:27:47","2020-10-29 02:33:04","Using Combine's Future to replicate async await in Swift","<swift><asynchronous><async-await><combine>","2","6","1","","","CC BY-SA 4.0"
"60421957","1","","","2020-02-26 20:21:27","","3","2454","<p>I am currently building a small one view app to help learn some more SwiftUI. 
The app is a simple app to calculate values in a ratio. I have 4 main variables at the moment, the left and right side of the ratio, and the first and second value that will be calculated in ratio. 
Initially I had each of these stored as <code>@State</code> properties:</p>

<pre><code>@State var leftSide = Double()
@State var rightSide = Double()
@State var value1 = Double()
@State var value2 = Double()
</code></pre>

<p>In the app there are 4 sliders that allow each variable to be changed independently of each other. What I want to now allow to happen is that changing the variable <code>value1</code> will also update <code>value2</code> according to the ratio the user has set. To achieve this I believe I need to use Combine however I have not got much experience with the framework. </p>

<p>To begin with I moved the variables to an <code>ObservableObject</code> class:</p>

<pre><code>final class UserData: ObservableObject {
    @Published var leftSide = Double()
    @Published var rightSide = Double()
    @Published var value1 = Double()
    @Published var value2 = Double()
}
</code></pre>

<p>I updated my main view with <code>@ObservedObject var userData = UserData()</code> so I could access the variables in my view and this works fine</p>

<p>Now I want to update the value1 and value2 variables when the other changes. From the reading I have done I think I need to use a subscriber but I cannot find anything on how to set this up with they <code>@Published</code> property. Have I gone about this in the correct way or is there a better way to do this?</p>
","9682666","","","","","2020-02-27 18:16:31","SwiftUI and Combine - Update variable in view model when another changes","<ios><swift><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"60423149","1","60426960","","2020-02-26 21:51:58","","1","71","<p>I am trying to create a basic sign up screen. The screen appears fine however when I click submit, and an error is returned, the <code>@State</code> variables (such as <code>$viewModel.firstName</code> and <code>$lastname</code> reset back to empty strings, so my user loses all their progress.</p>

<p>Sign Up Screen</p>

<pre><code>struct SignUpScreen: View {

    @State
    var firstName: String = """"
    @State
    var lastName: String = """"
    @State
    var birthday: String = """"
    @State
    var number: String = """"
    @State
    var email: String = """"
    @State
    var password: String = """"
    @State
    var confirmPassword: String = """"

    @ObservedObject
    var viewModel: SignUpViewModel = SignUpViewModel()


    var body: some View {
        ZStack {
            VStack {
                VClearBackground()
                Spacer()
            }
            ScrollView {
                VStack(alignment: .leading) {
                    Group {
                        PreHeaderText(header: ""Get Started"")
                            .alignmentGuide(.leading, computeValue: {d in
                                d[.leading]
                            })
                            .padding(EdgeInsets.init(top: 32, leading: 0, bottom: 0, trailing: 0))
                        HeaderText(header: ""Create Account"")
                        EditText(hint: ""John"", text: $viewModel.firstName, label: ""FIRST NAME"", textContentType: UITextContentType.name)
                        EditText(hint: ""Doe"", text: $lastName, label: ""LAST NAME"", textContentType: UITextContentType.name)
                        EditText(hint: ""01/01/2001"", text: $birthday, label: ""BIRTHDAY"")
                        EditText(hint: ""(123) 456-7890)"", text: $number, label: ""MOBILE NUMBER"", textContentType: UITextContentType.telephoneNumber, keyboardType: UIKeyboardType.phonePad)
                        EditText(hint: ""email@exmaple.com"", text: $email, label: ""EMAIL"", textContentType: UITextContentType.emailAddress)
                        EditText(hint: ""********"", text: $password, label: ""PASSWORD"", textContentType: UITextContentType.newPassword)
                        EditText(hint: ""********"", text: $confirmPassword, label: ""CONFIRM PASSWORD"", textContentType: UITextContentType.newPassword)
                    }
                    Group {
                        if self.viewModel.error != nil {
                            HStack {
                                Spacer()
                                Text(viewModel.error ?? """")
                                    .foregroundColor(ColorTheme.error.color)
                                Spacer()
                            }
                            .padding()
                        }
                        HStack {
                            Spacer()
                            VowerButton(text: ""Submit"") {
                                self.viewModel.signUp(firstName: self.viewModel.firstName, lastName: self.lastName, email: self.email, birthday: self.birthday, phoneNumber: self.number, password: self.password, confirmPassword: self.confirmPassword)
                            }
                            Spacer()
                        }
                        .padding()

                        HStack {
                            Spacer()
                            NavigationLink(destination: LoginScreen(), isActive: $viewModel.goToLogin) {
                                CtaText(text: ""Have an account?"", cta: ""Login"") {
                                    self.viewModel.onGoToLoginClicked()
                                }
                            }
                            .padding()
                            Spacer()
                        }

                        Spacer()
                    }
                }
            }
            .padding(EdgeInsets.init(top: 16, leading: 16, bottom: 16, trailing: 16))
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .leading)
        }
        .background(LinearGradient(gradient: Gradient(colors: [.black, ColorTheme.brandPurple.color]), startPoint: .top, endPoint: .bottom))
        .edgesIgnoringSafeArea(.all)
    }
}
</code></pre>

<p>Sign Up ViewModel</p>

<pre><code>class SignUpViewModel : ObservableObject {
    @State
    var firstName: String = """"

    @Published
    var error: String? = nil

    @Published
    var goHome: Bool = false

    @Published
    var goToLogin: Bool = false

    func onGoToLoginClicked() {
        self.goToLogin = true
    }

    func signUp(firstName: String, lastName: String, email: String, birthday: String, phoneNumber: String, password: String, confirmPassword: String) {
        if (firstName.count &lt; 3) {
            error = ""Please enter first name""
            return
        }
        if (lastName.count &lt; 3) {
            error = ""Please enter last name""
            return
        }
        if (!email.isEmail()) {
            error = ""Pleaes enter valid email""
            return
        }
        if (birthday.isEmpty) {
            error = ""Pleae enter valid birthday""
            return
        }
        if (!phoneNumber.isDigits) {
            error = ""Please enter valid phone number""
            return
        }
        if (password.count &lt; 8) {
            error = ""Please enter a password that is at least 8 characters long""
        }
        if (password != confirmPassword) {
            error = ""Password do not match""
        }
        Auth.auth().createUser(withEmail: email, password: password, completion: { authResult, error in
            if authResult != nil {
                self.goHome = true
            } else {
                self.error = error?.localizedDescription
            }
        })
    }
}
</code></pre>

<p>EditText View</p>

<pre><code>struct EditText: View {

    var hint: String
    @Binding
    var text: String
    var label: String = """"
    var defaultValue =  """"
    var textContentType: UITextContentType? = .none
    var keyboardType: UIKeyboardType = .default

    private func initializeDefaultValue() {
        DispatchQueue.main.async {
            self.text = self.defaultValue
        }
    }

    var body: some View {
        initializeDefaultValue()
        return VStack(alignment: .leading) {
            Text(label).font(.system(size: 12)).bold()
                .foregroundColor(ColorTheme.text.color)
            HStack {
                TextField(hint, text: $text)
                .lineLimit(1)
                .textContentType(textContentType)
                .keyboardType(keyboardType)
                    .foregroundColor(ColorTheme.text.color)
            }
            Divider().background(Color(ColorTheme.brandBlue.value))
        }
        .padding(EdgeInsets.init(top: 12, leading: 0, bottom: 8, trailing: 0))
    }
}
</code></pre>
","1120154","","","","","2020-02-27 05:46:24","Why do my @State objects not retain their value?","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60428303","1","60444607","","2020-02-27 07:35:39","","5","2493","<p>How to convert <code>URLSession.DataTaskPublisher</code> to <code>Future</code> in Combine framework.
In my opinion, the Future publisher is more appropriate here because the call can emit only one response and fails eventually.</p>

<p>In RxSwift there is helper method like <code>asSingle</code>.</p>

<p>I have achieved this transformation using the following approach but have no idea if this is the best method.</p>

<pre><code>        return Future&lt;ResponseType, Error&gt;.init { (observer) in
        self.urlSession.dataTaskPublisher(for: urlRequest)
            .tryMap { (object) -&gt; Data in
            //......
            }
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { (completion) in
                if case let .failure(error) = completion {
                    observer(.failure(error))
                }
            }) { (response) in
                observer(.success(response))
            }.store(in: &amp;self.cancellable)
    }
}
</code></pre>

<p>Is there any easy way to do this?</p>
","1401983","","1401983","","2020-02-28 07:15:52","2021-02-03 22:59:39","Convert URLSession.DataTaskPublisher to Future publisher","<ios><swift><combine>","3","4","","","","CC BY-SA 4.0"
"60439788","1","60440663","","2020-02-27 18:42:12","","2","5245","<p>I don't manage to trigger the onReceive method in a SwiftUI View whenever a variable from ObservedObject changes.</p>

<p>I tried two methods: using <strong>@Publish</strong> and using <strong>PassthroughSubject&lt;></strong></p>

<p><strong>Here is the ViewModel</strong> </p>

<pre><code>class MenuViewModel: ObservableObject {

@Published var selectedItems = Set&lt;UUID&gt;()
@Published var currentFocusItem: UUID?

// Output
let newItemOnFocus = PassthroughSubject&lt;(UUID?), Never&gt;()

// This function gets called good :)
func tapOnMenuItem(_ item: MenuItem) {
    if selectedItems.contains(item.id) {
        //These changes should trigger the onReceive?
        currentFocusItem = item.id  
        newItemOnFocus.send(item.id)
    } else {
        selectedItems.insert(item.id)
        currentFocusItem = nil
        newItemOnFocus.send(nil)
    }
}
}
</code></pre>

<p><strong>Here is the View</strong> when trying to catch the changes in <strong>@Published</strong> var currentFocusItem</p>

<pre><code>struct MenuView: View {

    @ObservedObject private var viewModel: MenuViewModel
    @State var showPicker = false
    @State private var menu: Menu = Menu.mockMenu()


    init(viewModel: MenuViewModel = MenuViewModel()) {
        self.viewModel = viewModel
    }

    var body: some View {
        VStack {
            List(menu.items, selection: $viewModel.selectedItems) { item in
                MenuItemView(item: item)
            }

            Divider()
            getBottomView(showPicker: showPicker)
        }

        .navigationBarTitle(""Title"")
        .navigationBarItems(trailing: Button(action: closeModal) {
            Image(systemName: ""xmark"")
        })
        .onReceive(viewModel.$currentFocusItem, perform: { itemUUID in
            self.showPicker = itemUUID != nil // &lt;-- This only gets called at launch time
        })           
    }
}
</code></pre>

<p><strong>The View</strong> in the same way but trying to catch the <strong>PassthroughSubject&lt;></strong></p>

<pre><code>.onReceive(viewModel.newItemOnFocus, perform: { itemUUID in
            self.showPicker = itemUUID != nil // &lt;-- This never gets called
        })
</code></pre>

<p><strong>----------EDIT----------</strong> </p>

<p>Adding MenuItemView, although viewModel.tapOnMenuItem gets always called, so I am not sure if it's very relevant</p>

<p><strong>MenuItemView</strong> is here:</p>

<pre><code>struct MenuItemView: View {

    var item: MenuItem
    @ObservedObject private var viewModel: MenuViewModel = MenuViewModel()
    @State private var isSelected = false

    var body: some View {
        HStack(spacing: 24) {
            Text(isSelected ? "" 1 "" : item.icon)
                .font(.largeTitle)
                .foregroundColor(.blue)
                .bold()
            VStack(alignment: .leading, spacing: 12) {
                Text(item.name)
                    .bold()
                Text(item.description)
                    .font(.callout)
            }
            Spacer()
            Text(""\(item.points)\npoints"")
                .multilineTextAlignment(.center)
        }
        .padding()
        .onTapGesture {
            self.isSelected = true
            self.viewModel.tapOnMenuItem(self.item). // &lt;-- Here tapOnMenuItem gets called
        }
    }

    func quantityText(isItemSelected: Bool) -&gt; String {
        return isItemSelected ? ""1"" : item.icon
    }
}
</code></pre>

<p>What am I doing wrong?</p>
","3891891","","3891891","","2020-02-27 19:37:49","2020-02-27 19:42:19","onReceive not getting called in SwiftUI View when ObservedObject changes","<ios><swift><mvvm><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"60452433","1","60453592","","2020-02-28 13:09:01","","2","364","<p>Imagine I have a view with some mutable state, but that the state might need to be updated to reflect changes in another object (e.g. a <code>ViewModel</code>).</p>

<p>How can I implement that in SwiftUI?</p>

<p>I've tried the following, but can't get the view to reflect updates coming from the <code>ViewModel</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {

    @Published var text: String = ""loading""

    private var task: AnyCancellable?

    func fetch() {
        task = Just(""done"")
            .delay(for: 1, scheduler: RunLoop.main)
            .assign(to: \.text, on: self)
    }
}

struct ContentView: View {

    @ObservedObject var viewModel = ViewModel()

    @State var viewText = ""idle""

    private var bind: AnyCancellable?

    init() {
        viewText = viewModel.text
        bind = viewModel
            .$text
            .print()
            .assign(to: \.viewText, on: self)
    }

    var body: some View {
        VStack {
            TextField(titleKey: ""editable text"", text: $viewText)
            Text(viewText)
            Text(viewModel.text)
        }
        .onAppear {
            self.viewModel.fetch()
        }
    }
}
</code></pre>

<p>The <code>TextField</code> and the first <code>Text</code> element get their content from <code>ContentView.viewText</code>, the second <code>Text</code> goes directly to the source: <code>ViewModel.text</code>.</p>

<p>As expected, the second <code>Text</code> shows <code>""loading""</code> and then <code>""done""</code>. The first <code>Text</code> never changes from <code>""idle""</code>.</p>
","969305","","969305","","2020-02-29 22:16:42","2020-02-29 22:16:42","How can I update view state in response to external changes?","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"60457051","1","60482150","","2020-02-28 18:01:46","","0","170","<p>When I type in my EditText view to fill out all the required information and then click submit. Everything I typed disappears. I want this text to remain. I am guessing there is something wrong with my <code>@State</code> objects but cannot figure out what.</p>

<p>SignUpViewModel</p>

<pre><code>class SignUpViewModel : ObservableObject {

    @Published
    var error: String? = nil

    @Published
    var goHome: Bool = false

    @Published
    var goToLogin: Bool = false

    func onGoToLoginClicked() {
        self.goToLogin = true
    }

    func signUp(firstName: String, lastName: String, email: String, birthday: String, phoneNumber: String, password: String, confirmPassword: String) {
        if (firstName.count &lt; 3) {
            error = ""Please enter first name""
            return
        }
        if (lastName.count &lt; 3) {
            error = ""Please enter last name""
            return
        }
        if (!email.isEmail()) {
            error = ""Pleaes enter valid email""
            return
        }
        if (birthday.isEmpty) {
            error = ""Pleae enter valid birthday""
            return
        }
        if (!phoneNumber.isDigits) {
            error = ""Please enter valid phone number""
            return
        }
        if (password.count &lt; 8) {
            error = ""Please enter a password that is at least 8 characters long""
        }
        if (password != confirmPassword) {
            error = ""Password do not match""
        }
        Auth.auth().createUser(withEmail: email, password: password, completion: { authResult, error in
            if authResult != nil {
                self.goHome = true
            } else {
                self.error = error?.localizedDescription
            }
        })
    }
}
</code></pre>

<p>SignUp View</p>

<pre><code>struct SignUpScreen: View {

    @State
    var firstName: String = """"
    @State
    var lastName: String = """"
    @State
    var birthday: String = """"
    @State
    var number: String = """"
    @State
    var email: String = """"
    @State
    var password: String = """"
    @State
    var confirmPassword: String = """"

    @EnvironmentObject
    var viewModel: SignUpViewModel


    var body: some View {
        ZStack {
            VStack {
                VClearBackground()
                Spacer()
            }
            ScrollView {
                VStack(alignment: .leading) {
                    Group {
                        PreHeaderText(header: ""Get Started"")
                            .alignmentGuide(.leading, computeValue: { d in
                                d[.leading]
                            })
                            .padding(EdgeInsets.init(top: 32, leading: 0, bottom: 0, trailing: 0))
                        HeaderText(header: ""Create Account"")
                        EditText(hint: ""Huey"", text: $firstName, label: ""FIRST NAME"", textContentType: UITextContentType.name)
                        EditText(hint: ""Freeman"", text: $lastName, label: ""LAST NAME"", textContentType: UITextContentType.name)
                        EditText(hint: ""04-19-1994"", text: $birthday, label: ""BIRTHDAY"")
                        EditText(hint: ""(281) 456-7890)"", text: $number, label: ""MOBILE NUMBER"", textContentType: UITextContentType.telephoneNumber, keyboardType: UIKeyboardType.phonePad)
                        EditText(hint: ""email@exmaple.com"", text: $email, label: ""EMAIL"", textContentType: UITextContentType.emailAddress)
                        EditText(hint: ""********"", text: $password, label: ""PASSWORD"", textContentType: UITextContentType.newPassword)
                        EditText(hint: ""********"", text: $confirmPassword, label: ""CONFIRM PASSWORD"", textContentType: UITextContentType.newPassword)
                    }
                    Group {
                        if self.viewModel.error != nil {
                            HStack {
                                Spacer()
                                Text(viewModel.error ?? """")
                                    .foregroundColor(ColorTheme.error.color)
                                Spacer()
                            }
                            .padding()
                        }
                        HStack {
                            Spacer()
                            VowerButton(text: ""Submit"") {
                                self.viewModel.signUp(firstName: self.firstName, lastName: self.lastName, email: self.email, birthday: self.birthday, phoneNumber: self.number, password: self.password, confirmPassword: self.confirmPassword)
                            }
                            Spacer()
                        }
                        .padding()

                        HStack {
                            Spacer()
                            NavigationLink(destination: LoginScreen(), isActive: $viewModel.goToLogin) {
                                CtaText(text: ""Have an account?"", cta: ""Login"") {
                                    self.viewModel.onGoToLoginClicked()
                                }
                            }
                            .padding()
                            Spacer()
                        }

                        Spacer()
                    }
                }
            }
            .padding(EdgeInsets.init(top: 16, leading: 16, bottom: 16, trailing: 16))
            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .leading)
        }
        .background(LinearGradient(gradient: Gradient(colors: [.black, ColorTheme.brandPurple.color]), startPoint: .top, endPoint: .bottom))
        .edgesIgnoringSafeArea(.all)
    }
}
</code></pre>

<p>EditText View</p>

<pre><code>struct EditText: View {

    var hint: String
    @Binding
    var text: String
    var label: String = """"
    var defaultValue =  """"
    var textContentType: UITextContentType? = .none
    var keyboardType: UIKeyboardType = .default

    private func initializeDefaultValue() {
        DispatchQueue.main.async {
            self.text = self.defaultValue
        }
    }

    var body: some View {
        initializeDefaultValue()
        return VStack(alignment: .leading) {
            Text(label).font(.system(size: 12)).bold()
                .foregroundColor(ColorTheme.text.color)
            HStack {
                TextField(hint, text: $text)
                .lineLimit(1)
                .textContentType(textContentType)
                .keyboardType(keyboardType)
                    .foregroundColor(ColorTheme.text.color)
            }
            Divider().background(Color(ColorTheme.brandBlue.value))
        }
        .padding(EdgeInsets.init(top: 12, leading: 0, bottom: 8, trailing: 0))
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/eUVYr.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eUVYr.gif"" alt=""Preview""></a></p>
","1120154","","1120154","","2020-03-01 18:37:28","2020-03-02 03:24:07","Why does Text disappear when i click submit?","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"60464226","1","","","2020-02-29 10:42:53","","10","1338","<p>I'm trying to using Swift Combine to get the changed event of a property.</p>

<p>I have this class that publish the <code>isLogged</code> property</p>

<pre><code>class CurrentUser: Account {
    static let me = CurrentUser() //Singleton 

    @Published var isLogged: Bool = false

}
</code></pre>

<p>that inherit from this other class that publish the <code>profileImageVersion</code> property</p>

<pre><code>class Account {

    @Published var profileImageVersion: String?

    init(){
       self.profileImageVersion = """"
    }
}
</code></pre>

<p>I'm trying to subscribe to the published inherit <code>profileImageVersion</code> property like this without success!</p>

<pre><code>// Subscribe to account image changes
userImageChangedSubscriber = CurrentUser.me.$profileImageVersion.receive(on: DispatchQueue.main).sink(receiveValue: { (imageVersion) in           
       ...
    }
})
</code></pre>

<p>The error is <code>Fatal error: Call of deleted method</code></p>

<p>if, on the other hand, I subscribe to the <code>isLogged</code> property, all Is working fine...</p>

<pre><code>// Subscribe to logged changes
userLoggedSubscriber = CurrentUser.me.$isLogged.receive(on: DispatchQueue.main).sink(receiveValue: { (logged) in
   ...
})
</code></pre>

<p>This error is thrown only on Xcode 11.4 beta 2 / iOS 13.4.<br>
Using Xcode 11.3.1 / 13.3 all is working fine!</p>
","394566","","1000551","","2020-03-11 14:27:48","2020-05-02 12:45:53","Swift Combine properties inheritance throws 'Fatal error: Call of deleted method' on Xcode 11.4 beta 2 / iOS 13.4","<ios><swift><xcode><combine><xcode11.4>","2","7","2","","","CC BY-SA 4.0"
"60467247","1","60534193","","2020-02-29 16:23:57","","2","3699","<p>Today again one combine problem I currently run in and I hope that someone of you can help. How can normal unit tests be written for ObservableObjects classes which contain @Published attributes? How can I subscribe in my test to them to get the result object which I can assert?</p>

<p>The injected mock for the web service works correctly, <code>loadProducts()</code> function set exactly the same elements from the mock in the <code>fetchedProducts</code> array. </p>

<p>But I don't know currently how to access this array in my test after it is filled by the function because it seems that I cannot work with expectations here, <code>loadProducts()</code> has no completion block.</p>

<p>The code looks like this:</p>

<pre><code>class ProductsListViewModel: ObservableObject {
    let getRequests: GetRequests
    let urlService: ApiUrls

    private let networkUtils: NetworkRequestUtils

    let productsWillChange = ObservableObjectPublisher()

    @Published var fetchedProducts = [ProductDTO]()
    @Published var errorCodeLoadProducts: Int?

    init(getRequestsHelper: GetRequests, urlServiceClass: ApiUrls = ApiUrls(), utilsNetwork: NetworkRequestUtils = NetworkRequestUtils()) {
        getRequests = getRequestsHelper
        urlService = urlServiceClass
        networkUtils = utilsNetwork
    }


    // nor completion block in the function used
    func loadProducts() {
        let urlForRequest = urlService.loadProductsUrl()

        getRequests.getJsonData(url: urlForRequest) { [weak self] (result: Result&lt;[ProductDTO], Error&gt;) in
            self?.isLoading = false
            switch result {
            case .success(let productsArray):
                // the products filled async here
                self?.fetchedProducts = productsArray
                self?.errorCodeLoadProducts = nil
            case .failure(let error):
                let errorCode = self?.networkUtils.errorCodeFrom(error: error)
                self?.errorCodeLoadProducts = errorCode
                print(""error: \(error)"")
            }
        }
    }
}
</code></pre>

<p>The test I try to write looks like this at the moment:</p>

<pre><code>import XCTest
@testable import MyProject

class ProductsListViewModelTest: XCTestCase {
    var getRequestMock: GetRequests!
    let requestManagerMock = RequestManagerMockLoadProducts()

    var productListViewModel: ProductsListViewModel!

    override func setUp() {
        super.setUp()

        getRequestMock = GetRequests(networkHelper: requestManagerMock)
        productListViewModel = ProductsListViewModel(getRequestsHelper: getRequestMock)
    }

    func test_successLoadProducts() {
        let loginDto = LoginResponseDTO(token: ""token-token"")
        UserDefaults.standard.save(loginDto, forKey: CommonConstants.persistedLoginObject)

        productListViewModel.loadProducts()

        // TODO access the fetchedProducts here somehow and assert them
    }
}

</code></pre>

<p>The Mock looks like this:</p>

<pre><code>class RequestManagerMockLoadProducts: NetworkRequestManagerProtocol {
    var isSuccess = true

    func makeNetworkRequest&lt;T&gt;(urlRequestObject: URLRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) where T : Decodable {
        if isSuccess {
            let successResultDto = returnedProductedArray() as! T
            completion(.success(successResultDto))
        } else {
            let errorString = ""Cannot create request object here""
            let error = NSError(domain: ErrorDomainDescription.networkRequestDomain.rawValue, code: ErrorDomainCode.unexpectedResponseFromAPI.rawValue, userInfo: [NSLocalizedDescriptionKey: errorString])

            completion(.failure(error))
        }
    }

    func returnedProductedArray() -&gt; [ProductDTO] {
        let product1 = ProductDTO(idFromBackend: ""product-1"", name: ""product-1"", description: ""product-description"", price: 3.55, photo: nil)
        let product2 = ProductDTO(idFromBackend: ""product-2"", name: ""product-2"", description: ""product-description-2"", price: 5.55, photo: nil)
        let product3 = ProductDTO(idFromBackend: ""product-3"", name: ""product-3"", description: ""product-description-3"", price: 8.55, photo: nil)
        return [product1, product2, product3]
    }
}
</code></pre>
","4017243","","4017243","","2020-03-01 07:31:19","2020-05-17 16:22:14","Write unit tests for ObservableObject ViewModels with Published results","<swift><xcode><unit-testing><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"60473348","1","60473693","","2020-03-01 08:35:37","","1","895","<p>Experimenting with Combine, I've seen the <code>AnyCancellable.store(in:)</code> method for retaining Subscribers. I've been wondering with this setup:</p>

<pre><code>class Controller
{
  static var cancellables = Set&lt;AnyCancellable&gt;()
}

let label = UILabel(frame: .zero)
</code></pre>

<p>if there an advantage over retaining a <code>Subscriber</code> with this:</p>

<pre><code>Controller.$value
  .assign(to: \UILabel.text, on: label)
  .store(in: &amp;cancellables)
</code></pre>

<p>over this:</p>

<pre><code>let subscriber = Controller.$value
  .assign(to: \UILabel.text, on: label)

Controller.cancellables.insert(subscriber)
</code></pre>

<p>or if it's mainly stylistic. Both seem to work in testing.</p>
","6205653","","","","","2020-03-01 09:27:58","Advantage of AnyCancellable.store(in:) over Set<AnyCancellable>.insert(:)","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"60478828","1","","","2020-03-01 19:15:33","","0","1031","<p>I'm new to Swift Combine, so having a small issue</p>

<p>Im trying to call two api calls, and merge the results as the second API call depends on the result from the first call.</p>

<p>Here is the code</p>

<pre><code>return self.gameRepository.fetchGames(forUser: user.id)
            .map { games -&gt; AnyPublisher&lt;[Game], ApiError&gt; in
                let result = games.map { gameDto -&gt; Game in
                    let location = self.venueRepository.fetch(by: gameDto.siteId)
                        .map { $0.mapToModel() }
                    let game = gameDto.mapToModel(location: location)
                    return game
                }
</code></pre>

<p>My error is on line 4 ""let location"" the compiler complains when I try and pass this through to 
line 5 </p>

<pre><code>game.mapToModel(location: location)
</code></pre>

<p>Cannot convert value of type 'AnyPublisher' to expected argument type Location</p>

<p>The fetch call signature from the repository looks like this</p>

<pre><code>func fetch(by id: String) -&gt; AnyPublisher&lt;LocationDto, ApiError&gt;
</code></pre>

<p>So it is correct, but the .map call I use on the result allows the </p>

<pre><code>$0.mapToModel() 
</code></pre>

<p>to occur, so I have locationDto object that allows me to cast to my Domain model.</p>

<p>Any help on how I can call these two apis together would be much appreciated.</p>
","2331402","","","","","2020-03-02 09:11:43","Call two Swift Combine calls where the second call depends on the result of the first call","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"60480652","1","60482411","","2020-03-01 23:13:13","","3","3326","<p>I'm trying to pause my AVPlayer when the item finishes playing. What is the best way to do this with SwiftUI? I don't know much about notifications, where to declare them, etc. Is there a way to use Combine for this? Sample code would be awesome! Thank you in advance.</p>

<p>UPDATE:</p>

<p>With help from the answer below, I managed to make a class which takes an AVPlayer and publishes a notification when the item ends. You can subscribe to the notification with the following:</p>

<p>Class:</p>

<pre><code>import Combine
import AVFoundation

class PlayerFinishedObserver {

    let publisher = PassthroughSubject&lt;Void, Never&gt;()

    init(player: AVPlayer) {
        let item = player.currentItem

        var cancellable: AnyCancellable?
        cancellable = NotificationCenter.default.publisher(for: .AVPlayerItemDidPlayToEndTime, object: item).sink { [weak self] change in
            self?.publisher.send()
            print(""Gotcha"")
            cancellable?.cancel()
        }
    }
}
</code></pre>

<p>Add to your struct:</p>

<pre><code>let finishedObserver: PlayerFinishedObserver
</code></pre>

<p>Subscribe on some View:</p>

<pre><code>.onReceive(finishedObserver.publisher) {
                print(""Gotcha!"")
            }
</code></pre>
","12506105","","12506105","","2020-03-11 17:04:48","2020-03-11 17:04:48","Struggling with NotificationCenter/Combine in SwiftUI/AVPlayer","<swift><swiftui><avplayer><combine><notificationcenter>","1","0","2","","","CC BY-SA 4.0"
"60482098","1","60483313","","2020-03-02 03:16:36","","14","8410","<p>Basically I try to figure out when my viewModel get updated, it will notify view and it will refresh whole body. How to avoid that. For example if my view GoLiveView already present another view BroadcasterView, and later my goLiveViewModel get updated, GoLiveView will be refreshed, and  it will create BroadcasterView again , because showBroadcasterView = true. And it will cause so many issues down the road, because of that. </p>

<pre><code>struct GoLiveView: View {

@ObservedObject var goLiveViewModel = GoLiveViewModel()
@EnvironmentObject var sessionStore: SessionStore
@State private var showBroadcasterView = false
@State private var showLiveView = false

init() {
    goLiveViewModel.refresh()
}

var body: some View {
    NavigationView {
        List(goLiveViewModel.rooms) { room in // when goLiveViewModed get updated 
            NavigationLink(destination: LiveView(clientRole: .audience, room: room, showLiveView: $showLiveView))) {
                LiveCell(room: room)

            }
        }.background(Color.white)
        .navigationBarTitle(""Live"", displayMode: .inline)
        .navigationBarItems(leading:
            Button(action: {
                self.showBroadcasterView = true
        }, label: {
            Image(""ic_go_live"").renderingMode(.original)
        })).frame(maxWidth: .infinity, maxHeight: .infinity)
            .background(Color(red: 34/255, green: 34/255, blue: 34/255))

        .sheet(isPresented: $showBroadcasterView) { // here is problem, get called many times, hence reload whole body ,and create new instances of BroadcasterView(). Because showBroadcasterView = is still true.

                BroadcasterView(broadcasterViewModel: BroadcasterViewModel(showBroadcasterView: $showBroadcasterView))
                    .environmentObject(self.sessionStore)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.clear)
            }

    }
}
</code></pre>

<p>this is my GoliveViewModel </p>

<pre class=""lang-swift prettyprint-override""><code>typealias RoomsFetchOuput = AnyPublisher&lt;RoomsFetchState, Never&gt;

enum RoomsFetchState: Equatable {

    static func == (lhs: RoomsFetchState, rhs: RoomsFetchState) -&gt; Bool {
        switch (lhs, rhs) {
        case (.loading, .loading): return true
        case (.success(let lhsrooms), .success(let rhsrooms)):
            return lhsrooms == rhsrooms
        case (.noResults, .noResults): return true
        case (.failure, .failure): return true
        default: return false
        }
    }

    case loading
    case success([Room])
    case noResults
    case failure(Error)
}
</code></pre>

<pre class=""lang-swift prettyprint-override""><code>class GoLiveViewModel: ObservableObject {

    private lazy var webServiceManager = WebServiceManager()
    @Published var rooms = [Room]()
    private lazy var timer = Timer()
    private var cancellables: [AnyCancellable] = []

    init() {
        timer = Timer.scheduledTimer(timeInterval: 4.0, target: self, selector: #selector(refresh) , userInfo: nil, repeats: true) //  call every 4 second refresh
    }

    func fetch() -&gt; RoomsFetchOuput {
        return webServiceManager.fetchAllRooms()
            .map ({ result -&gt; RoomsFetchState in
                switch result {
                case .success([]): return .noResults
                case let .success(rooms): return .success(rooms)
                case .failure(let error): return .failure(error)
                }
            })
            .eraseToAnyPublisher()

        let isLoading: RoomsFetchOuput = .just(.loading)
        let initialState: RoomsFetchOuput = .just(.noResults)

        let idle: RoomsFetchOuput = Publishers.Merge(isLoading, initialState).eraseToAnyPublisher()

        return Publishers.Merge(idle, rooms).removeDuplicates().eraseToAnyPublisher()

    }

    @objc func refresh() {
         cancellables.forEach { $0.cancel() }
          cancellables.removeAll()
        fetch()
            .sink { [weak self] state in
                guard let self = self else { return }
                switch state {
                case let .success(rooms):
                    self.rooms = rooms
                case .failure: print(""failure"")
                // show error alert to user
                case .noResults: print(""no result"")
                self.rooms = []
                // hide spinner
                case .loading:  print("".loading"")
                    // show spinner
                }
        }
        .store(in: &amp;cancellables)
    }
}
</code></pre>
","12990846","","9982386","","2020-03-02 05:12:39","2022-08-23 13:01:54","SwiftUI how to prevent view to reload whole body","<swift><xcode><swiftui><combine>","1","0","8","","","CC BY-SA 4.0"
"60482737","1","","","2020-03-02 04:55:17","","38","31658","<p>I happen to look into Apple's new Combine framework, where I see two things </p>

<p><code>PassthroughSubject&lt;String, Failure&gt;</code></p>

<p><code>CurrentValueSubject&lt;String, Failure&gt;</code></p>

<p>Can someone explain to me what is meaning &amp; use of them?</p>
","4260623","","","","","2022-07-17 16:32:19","What is PassthroughSubject & CurrentValueSubject","<ios><swiftui><reactive-programming><combine><declarative-programming>","6","1","9","","","CC BY-SA 4.0"
"60487628","1","60487739","","2020-03-02 11:08:44","","1","1099","<p>I have these two Codable objects :</p>

<pre><code>struct Parent: Codable {
    let name: String
    let children: [Child]
}

struct Child: Codable {
    let name: String
} 
</code></pre>

<p>That I have created to match this json :</p>

<pre><code>{
    name: ""test""
    children: (
        {
          name: ""test2""
        },
        {
          name: ""test3""
        }
     )
}
</code></pre>

<p>I retrieve the json and decode it to a Parent object using these methods :</p>

<pre><code>func parent(_ url: String) -&gt; AnyPublisher&lt;Parent, Error&gt; { 
    return dataFromURL(url)
        .map(\.value)
        .eraseToAnyPublisher()
}

struct Result&lt;T&gt; {
    let value: T
    let response: URLResponse
}

func dataFromURL&lt;T: Decodable&gt;(_ url: String, _ decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;Result&lt;T&gt;, Error&gt; {
    let request = URLRequest(url: URL(string:url)!)
    return URLSession.shared
        .dataTaskPublisher(for: request)
        .tryMap { result -&gt; Result&lt;T&gt; in
            let value = try decoder.decode(T.self, from: result.data)
            return Result(value: value, response: result.response)
        }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>

<p>It works, but I would like a method to retrieve the array of children, instead of the Parent object, like this :</p>

<pre><code>func children(_ url: String) -&gt; AnyPublisher&lt;[Child], Error&gt;  
</code></pre>

<p>But I don't know what I need to change.. Any help would be appreciated, thanks !</p>
","5120292","","","","","2020-03-02 13:38:39","iOS - Combine - Change Publisher type to child type","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"60493121","1","60533823","","2020-03-02 16:38:57","","0","621","<p>I have a setup like this with an error shown below</p>

<pre><code>enum DataError: Error {
    case failed(error: Error)
}

enum UIError: Error {
    case failed(error: Error)
}

struct SomeData {

}

func foo() -&gt; AnyPublisher&lt;Result&lt;[SomeData]?, DataError&gt;, Never&gt; {
    ...
}

func foo2() -&gt; AnyPublisher&lt;Result&lt;[SomeData]?, UIError&gt;, Never&gt; {
    return foo()
            .mapError { error -&gt; UIError 
                switch error {
                    ....
                }

                return UIError.failed(error: $0)
            }
            .eraseToAnyPublisher() ===&gt; // Error Cannot convert return expression of type 'AnyPublisher&lt;Result&lt;[SomeData]?, DataError&gt;, UIError&gt;' to return type 'AnyPublisher&lt;Result&lt;[T], UIError&gt;, Never&gt;'
}
</code></pre>

<p>The error message seem pretty straight forward but cant quite resolve it.</p>
","3355301","","","","","2020-03-04 19:59:11","Publisher mapError with the Combine Framework","<swift><combine>","2","1","","","","CC BY-SA 4.0"
"60495494","1","60521560","","2020-03-02 19:35:16","","13","5928","<p>I want to achieve the following: Whenever someone triggers a CoreData save (ie. <code>NSManagedObjectContextDidSave</code> notification gets sent), I'd like to perform some <strong>background</strong> calculation based the changed NSManagedObject. Concrete example: Assume in a notes app, I want to asynchronously calculate the total number of words in all notes.</p>
<p>The problem currently lies with the fact that NSManagedObject context is explicitly bound to thread and you are discouraged from using <code>NSManagedObject</code>s outside this thread.</p>
<p>I have setup two <code>NSManagedObjectContext</code>s in my <code>SceneDelegate</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext
let backgroundContext = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.newBackgroundContext()
</code></pre>
<p>I also have subscribed to the notification via <code>NotificationCenter.default.publisher(for: .NSManagedObjectContextDidSave)</code> and am receiving a save notification <em>twice</em> after I trigger only <em>one</em> <code>managedObjectContext.save()</code>. However, both notifications are sent from the same thread (which is the UIThread) and all <code>NSManagedObjects</code> in the user dictionary have a <code>.managedObjectContext</code> which is the <code>viewContext</code> and not the <code>backgroundContext</code>.</p>
<p>My idea was to filter the notifications based on whether or not the associated <code>NSManagedObjectContext</code> was the background one as I assumed that the notification is also sent on the (private) DispatchQueue but it seems all notifications are sent on the UIThread and the background context is never used.</p>
<p>Any idea on how to solve this? Is this a bug? How can I retrieve notifications based on the <code>backgroundContext</code> with downstream tasks being run on the associated DispatchQueue?</p>
","1138434","","814730","","2021-08-10 18:55:13","2021-08-10 18:55:13","How to: Using Combine to react to CoreData changes in the background","<ios><swift><core-data><swift5><combine>","3","2","12","","","CC BY-SA 4.0"
"60525159","1","","","2020-03-04 11:36:15","","4","553","<p>I have a class <code>Foo</code> that has multiple dependencies to <code>ObservableObject</code>. For testing purposes I want to create a mocked version of those objects but I cannot see a way to do so and then inject those into <code>Foo</code>.</p>

<ul>
<li>I can't create another protocol that my <code>ObservableObject</code> implements because the <code>ObservableObject</code> protocol has self or associated type requirements and can't be used as a type declared and</li>
<li>I cannot subclass the <code>ObservableObject</code> since it has <code>@Published</code> property wrapped members that cannot be overwritten.</li>
</ul>
","239880","","","","","2020-03-04 11:36:15","Mock and inject ObservableObject","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"60527631","1","","","2020-03-04 13:51:04","","4","1010","<p>When using Publishers.CombineLatest with Publishers which run an threads other that Main the .sink of the <code>Publishers.CombineLatest</code> is not always called.</p>

<p>The issue does not appear every time this is why I created unit tests which try the test 100 times in a row. Usually they fail after 4-5 iterations.</p>

<pre><code>import XCTest
import Combine

class CombineLatestTests: XCTestCase {

    override func setUp() {
        continueAfterFailure = false
    }

    func testCombineLatest_receiveOn() {
        for x in 0...1000 {
            print(""---------- RUN \(x)"")
            let queue1 = DispatchQueue.global(qos: .userInitiated)
            let queue2 = DispatchQueue.global(qos: .background)

            let subj1 = PassthroughSubject&lt;Int, Never&gt;()
            let subj2 = PassthroughSubject&lt;Int, Never&gt;()

            let publ1 = subj1.receive(on: queue1).map { value -&gt; Int in
                print(""-- Observer 1: \(value), Thread: \(Thread.current)"")
                return value
            }
            let publ2 = subj2.receive(on: queue2).map { value -&gt; Int in
                print(""-- Observer 2: \(value), Thread: \(Thread.current)"")
                return value
            }

            let exp = expectation(description: ""expect values"")
            exp.assertForOverFulfill = false
            let canc = Publishers.CombineLatest(publ1, publ2)
                .sink { value1, value2 in
                    print(""-- recieved \(value1):\(value2) on \(Thread.current)"")
                    if value1 == 10, value2 == 20 {
                        exp.fulfill()
                    }
                }

            subj1.send(5)
            subj2.send(20)
            subj1.send(10)

            wait(for: [exp], timeout: 10)
            canc.cancel()
        }
    }

    func testCombineLatest_currentValue_receiveOn() {
        for x in 0...100 {
            print(""---------- RUN \(x)"")
            let queue1 = DispatchQueue.global(qos: .userInitiated)
            let queue2 = DispatchQueue.global(qos: .background)

            let subj1 = CurrentValueSubject&lt;Int, Never&gt;(0)
            let subj2 = CurrentValueSubject&lt;Int, Never&gt;(0)

            let publ1 = subj1.receive(on: queue1).map { value -&gt; Int in
                print(""-- Observer 1: \(value), Thread: \(Thread.current)"")
                return value
            }
            let publ2 = subj2.receive(on: queue2).map { value -&gt; Int in
                print(""-- Observer 2: \(value), Thread: \(Thread.current)"")
                return value
            }

            let exp = expectation(description: ""expect values"")
            exp.assertForOverFulfill = false
            let canc = Publishers.CombineLatest(publ1,
                                                publ2)
                .sink { value1, value2 in
                    print(""-- recieved \(value1):\(value2) on \(Thread.current)"")
                    if value1 == 10, value2 == 20 {
                        exp.fulfill()
                    }
                }

            subj1.send(10)
            subj2.send(20)

            wait(for: [exp], timeout: 3)
            canc.cancel()
        }
    }

    func testCombineLatest_subscribeOn() {
        for x in 0...100 {
            print(""---------- RUN \(x)"")
            let queue1 = DispatchQueue.global(qos: .userInitiated)
            let queue2 = DispatchQueue.global(qos: .background)

            let subj1 = PassthroughSubject&lt;Int, Never&gt;()
            let subj2 = PassthroughSubject&lt;Int, Never&gt;()

            let publ1 = subj1.map { value -&gt; Int in
                print(""-- Observer 1: \(value), Thread: \(Thread.current)"")
                return value
            }
            let publ2 = subj2.map { value -&gt; Int in
                print(""-- Observer 2: \(value), Thread: \(Thread.current)"")
                return value
            }

            let exp = expectation(description: ""expect values"")
            exp.assertForOverFulfill = false
            let canc = Publishers.CombineLatest(publ1, publ2)
                .sink { value1, value2 in
                    print(""-- recieved \(value1):\(value2) on \(Thread.current)"")
                    if value1 == 10, value2 == 20 {
                        exp.fulfill()
                    }
                }

            queue1.async {
                subj1.send(5)
                subj1.send(10)
            }

            queue2.async {
                subj2.send(20)
            }

            wait(for: [exp], timeout: 5)
            canc.cancel()
        }
    }

}

</code></pre>

<p>Here are the logs of the 3rd test</p>

<pre><code>Test Case '-[xxxx.CombineLatestTests testCombineLatest_currentValue_receiveOn]' started.
---------- RUN 0
-- Observer 2: 0, Thread: &lt;NSThread: 0x6000004e0f80&gt;{number = 9, name = (null)}
-- Observer 1: 0, Thread: &lt;NSThread: 0x6000004f0000&gt;{number = 7, name = (null)}
-- Observer 2: 20, Thread: &lt;NSThread: 0x6000004f6e00&gt;{number = 6, name = (null)}
-- recieved 0:0 on &lt;NSThread: 0x6000004f0000&gt;{number = 7, name = (null)}
-- Observer 1: 10, Thread: &lt;NSThread: 0x600000439880&gt;{number = 4, name = (null)}
-- recieved 10:20 on &lt;NSThread: 0x600000439880&gt;{number = 4, name = (null)}
---------- RUN 1
-- Observer 2: 0, Thread: &lt;NSThread: 0x6000004f0000&gt;{number = 7, name = (null)}
-- Observer 1: 0, Thread: &lt;NSThread: 0x6000004f6e00&gt;{number = 6, name = (null)}
-- Observer 2: 20, Thread: &lt;NSThread: 0x6000004e0f80&gt;{number = 9, name = (null)}
-- recieved 0:0 on &lt;NSThread: 0x6000004f6e00&gt;{number = 6, name = (null)}
-- Observer 1: 10, Thread: &lt;NSThread: 0x6000004e80c0&gt;{number = 10, name = (null)}
-- recieved 10:20 on &lt;NSThread: 0x6000004e80c0&gt;{number = 10, name = (null)}
---------- RUN 2
-- Observer 2: 0, Thread: &lt;NSThread: 0x6000004f6e00&gt;{number = 6, name = (null)}
-- Observer 1: 0, Thread: &lt;NSThread: 0x6000004e0f80&gt;{number = 9, name = (null)}
-- Observer 2: 20, Thread: &lt;NSThread: 0x6000004e80c0&gt;{number = 10, name = (null)}
-- recieved 0:0 on &lt;NSThread: 0x6000004e0f80&gt;{number = 9, name = (null)}
-- Observer 1: 10, Thread: &lt;NSThread: 0x600000439880&gt;{number = 4, name = (null)}
-- recieved 10:20 on &lt;NSThread: 0x600000439880&gt;{number = 4, name = (null)}
---------- RUN 3
-- Observer 2: 0, Thread: &lt;NSThread: 0x600000439880&gt;{number = 4, name = (null)}
-- Observer 1: 0, Thread: &lt;NSThread: 0x6000004e0f80&gt;{number = 9, name = (null)}
-- Observer 2: 20, Thread: &lt;NSThread: 0x6000004f6e00&gt;{number = 6, name = (null)}
-- recieved 0:0 on &lt;NSThread: 0x6000004e0f80&gt;{number = 9, name = (null)}
-- Observer 1: 10, Thread: &lt;NSThread: 0x6000004e80c0&gt;{number = 10, name = (null)}
-- recieved 10:20 on &lt;NSThread: 0x6000004e80c0&gt;{number = 10, name = (null)}
---------- RUN 4
-- Observer 1: 0, Thread: &lt;NSThread: 0x6000004f6e00&gt;{number = 6, name = (null)}
-- Observer 2: 0, Thread: &lt;NSThread: 0x6000004f0000&gt;{number = 7, name = (null)}
-- recieved 0:0 on &lt;NSThread: 0x6000004f0000&gt;{number = 7, name = (null)}
-- Observer 1: 10, Thread: &lt;NSThread: 0x600000439880&gt;{number = 4, name = (null)}
-- Observer 2: 20, Thread: &lt;NSThread: 0x6000004e80c0&gt;{number = 10, name = (null)}
-- recieved 10:0 on &lt;NSThread: 0x600000439880&gt;{number = 4, name = (null)}
CombineLatestTests.swift:93: error: : Asynchronous wait failed: Exceeded timeout of 3 seconds, with unfulfilled expectations: ""expect values"".
Test Suite 'CombineLatestTests' failed at 2020-03-04 20:37:24.957.
     Executed 3 tests, with 3 failures (0 unexpected) in 18.159 (18.161) seconds
</code></pre>
","928870","","928870","","2020-03-04 19:38:51","2020-03-05 07:49:35","Swift Combine - Publishers.CombineLatest on multiple Threads","<ios><swift><combine>","1","5","1","","","CC BY-SA 4.0"
"60534430","1","60539275","","2020-03-04 20:45:48","","0","611","<p>I want to add a value to Firestore. When finished I want to return the added value. The value does get added to Firestore successfully. However, the value does not go through sink.</p>

<p>This is the function that does not work:</p>

<pre><code>func createPremium(user id: String, isPremium: Bool) -&gt; AnyPublisher&lt;Bool,Never&gt; {
    let dic = [""premium"":isPremium]
    return Future&lt;Bool,Never&gt; { promise in
        self.db.collection(self.dbName).document(id).setData(dic, merge: true) { error in
            if let error = error {
                print(error.localizedDescription)
            } else {
                /// does get called
                promise(.success(isPremium))

            }
        }
    }.eraseToAnyPublisher()
}
</code></pre>

<p>I made a test function that works:</p>

<pre><code>func test() -&gt; AnyPublisher&lt;Bool,Never&gt; {
    return Future&lt;Bool,Never&gt; { promise in
        promise(.success(true))
    }.eraseToAnyPublisher()
}


    premiumRepository.createPremium(user: userID ?? ""1234"", isPremium: true)
        .sink { receivedValue in
            /// does not get called
            print(receivedValue)
    }.cancel()

    test()
        .sink { recievedValue in
            /// does get called
            print(""Test"", recievedValue)
    }.cancel()
</code></pre>

<p>Also I have a similar code snippet that works:</p>

<pre><code>func loadExercises(category: Category) -&gt; AnyPublisher&lt;[Exercise], Error&gt; {
    let document = store.collection(category.rawValue)
    return Future&lt;[Exercise], Error&gt; { promise in
        document.getDocuments { documents, error in
            if let error = error {
                promise(.failure(error))
            } else if let documents = documents {
                var exercises = [Exercise]()
                for document in documents.documents {
                    do {
                        let decoded = try FirestoreDecoder().decode(Exercise.self, from: document.data())
                        exercises.append(decoded)
                    } catch let error {
                        promise(.failure(error))
                    }
                }
                promise(.success(exercises))
            }
        }
    }.eraseToAnyPublisher()
}
</code></pre>

<p>I tried to add a buffer but it did not lead to success.</p>
","8887336","","","","","2020-03-05 06:22:17","Future Combine sink does not recieve any values","<swift><future><combine><publisher>","1","1","","","","CC BY-SA 4.0"
"60548769","1","","","2020-03-05 15:25:38","","0","244","<p>I am new to reactive programming and Combine, I have the following method which fetching the weather Data from the API. </p>

<ul>
<li>First, I am checking that if I get 200 if not then throw an error.</li>
<li>If I get the proper data I am decoding it via JSONDecoder but just to
check if there is some problem JSON decoding I am returning the default Object.</li>
<li>Finally mapping the error which is thrown in the
first step but I am getting the following error in flatMAp function
instance method</li>
</ul>

<p><strong>flatMap(maxPublishers:_:)' requires the types 'Publishers.TryMap.Failure' (aka 'Error') and 'Just.Failure' (aka 'Never') be equivalent</strong></p>

<pre><code>private func fetchDataFor(urlStr: String) -&gt; AnyPublisher&lt;WeatherData, Error&gt; {
            let url = URL(string: urlStr)!
            return URLSession.shared.dataTaskPublisher(for: url)
                .tryMap({ (data, response)  in
                    let response = (response as? HTTPURLResponse)
                    if response?.statusCode != 200 {
                        throw NSError(domain: ""Error"", code: response!.statusCode, userInfo: .none)
                    }
                    return data
            })
            .flatMap{ data in
                Just(data)
                    .decode(type: WeatherData.self, decoder: JSONDecoder())
                    .catch{ error in
                        return Just(defaultWeatherData)
                    }
            }
            .mapError{ error in
                return error
            }
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
        }
</code></pre>

<p>Can somebody guide what is wrong here or I am using some wrong approach. Thanks</p>
","1306402","","","","","2020-03-05 15:34:40","Input and output type mismatch in Combine data fetching","<ios><swift><reactive-programming><combine><flatmap>","1","0","","","","CC BY-SA 4.0"
"60550577","1","60551057","","2020-03-05 17:03:17","","14","3488","<p>How to convert <code>Just&lt;[Int]&gt;</code> to <code>AnyPublisher&lt;[Int], Error&gt;</code>. When I use <code>eraseToAnyPublisher()</code> the type is <code>AnyPublisher&lt;[Int], Never&gt;</code> which is not the same as <code>AnyPublisher&lt;[Int], Error&gt;</code></p>

<p>For example I have a simple function which I want to mock temporary </p>

<pre><code>func getAllIds() -&gt; AnyPublisher&lt;[Int], Error&gt; {
    return Just&lt;[Int]&gt;([]).eraseToAnyPublisher()
}
</code></pre>

<p>Any ideas? </p>
","1401983","","","","","2020-03-06 00:41:27","Combine convert Just to AnyPublisher","<ios><swift><combine>","1","1","1","","","CC BY-SA 4.0"
"60552914","1","60555961","","2020-03-05 19:46:08","","2","920","<p>I am trying to build a <code>VOIP</code> app using lib called <code>VailerSIPLib</code>. As the library was built using <code>Obj-C</code> and heavily using <code>NotificationCenter</code> to to publish the changes the active states all over the place. </p>

<p>I currently at the <code>CallView</code> part of the project, I can manage to start, end, reject calls. However, I need to implement <code>connectionStatus</code> in the view which will give information about the call like duration, ""connecting.."", ""disconnected"", ""ringing"" etc. </p>

<p>The below code is all in <code>CallViewModel: ObservableObject</code>;</p>

<p><strong>Variables:</strong></p>

<pre><code>var activeCall: VSLCall!
@Published var connectionStatus: String = """"
</code></pre>

<p><strong>Initializer:</strong></p>

<pre><code>override init(){
        super.init()
        NotificationCenter.default.addObserver(self, selector: #selector(self.listen(_:)), name: Notification.Name.VSLCallStateChanged, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(self.buildCallView(_:)), name: Notification.Name.CallKitProviderDelegateInboundCallAccepted, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(self.buildCallView(_:)), name: Notification.Name.CallKitProviderDelegateOutboundCallStarted, object: nil)
    }
</code></pre>

<p><strong>Methods:</strong></p>

<pre><code>func setCall(_ call: VSLCall) {
    self.activeCall = call
    self.activeCall.observe(\.callStateText) { (asd, change) in
        print(""observing"")
        print(""\(String(describing: change.oldValue)) to \(String(describing: change.newValue)) for \(call.callId)"")
    } 
}

@objc func listen(_ notification: Notification) {
       if let _ = self.activeCall {
           print(self.activeCall.callStateText)
       }    
}

@objc func buildCallView(_ notification: Notification) {
    print(""inbound call"")
    self.isOnCall = true 
}
</code></pre>

<p><strong>Problem:</strong></p>

<p>It prints out every thing except the <code>completionBlock</code> in <code>setCall(_:)</code>. <code>listen(_:)</code> function validates that the state of the <code>activeCall</code> is changing and I would want to use that directly, however it does not work correct all the time. It should be triggered when the call is answered with <code>callState</code> value of <code>.confirmed</code> but sometime it does. This how I will know that it is time start the timer. </p>

<p>Other point is, in the example project of the <code>VialerSIPLib</code> they used <code>self.activeCall.addObserver(_:)</code> and it works fine. The problem for that is it throws a runtime error at the method something like <code>didObservedValueChange(_:)</code> and logs <code>An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.</code></p>

<p>Finally there is yellow warning at the <code>activeCall.observe(_:)</code> says </p>

<blockquote>
  <p><code>Result of call to 'observe(_:options:changeHandler:)' is unused</code>
  which I could not find anything related to it.</p>
</blockquote>
","1404324","","1244403","","2020-03-05 19:49:21","2020-03-06 01:00:30","SwiftUI - KV Observe completion from Combine does not get triggered","<swift><swiftui><key-value-observing><combine>","1","0","1","","","CC BY-SA 4.0"
"60560933","1","60562584","","2020-03-06 09:19:57","","2","1955","<p>I consider what is the difference</p>
<pre><code>@Published var isLoggedIn: Bool = false 

var isLoggedIn: AnyPublisher&lt;Bool, Never&gt; 
</code></pre>
<p>I know in the case of first I can use it directly in SwiftUI View i.e. create binding with $ sign and then for example use <code>if $isLoggedIn.animation()</code></p>
<p>But how can I achieve the same with <code>AnyPublisher&lt;Bool, Never&gt;</code> it seems that there I need to call somewhere <strong>assign</strong> or <strong>sink</strong> and <strong>store()</strong>. To make it work. So creating binding from it in SwiftUI seems to be impossible like <code>if $isLoggedIn.animation</code></p>
<p>Limitation of @Published is that I cannot make there custom observing. for example UserDefaults which I can do via AnyPublisher from UserDefaults.publisher.</p>
<p>As now it seems I need to have both and make <code>AnyPublisher</code> update <code>@Published var</code></p>
<p>But I've thought that @Published is property wrapper that has underneath regular AnyPublisher so why I cannot make binding in SwiftUI view directly from AnyPublisher?</p>
","4415642","","214143","","2021-09-29 16:36:24","2021-09-29 16:36:24","What is the difference between @Published and normal AnyPublisher property in ObservableObject","<swiftui><combine>","2","1","1","","","CC BY-SA 4.0"
"60563029","1","","","2020-03-06 11:18:39","","2","3060","<p>I am trying to filter only .portrait and .landscape orientation 
and then apply distinctUntilChanged i.e. removeDuplicates() </p>

<p>But removeDuplicates() seems to be never called as my debugger never stops inside comparator </p>

<p>and onReceive callback is called. </p>

<pre><code> // MARK: - Publishers
    private var orientationChange = NotificationCenter.default.publisher(for: UIDevice.orientationDidChangeNotification)
        .map { toOrientation($0) }
        .filter { filterOrientation($0) }
        //.removeDuplicates()
        .removeDuplicates(by: { o1, o2 in
           _ = filterOrientation(o1)
           _ = filterOrientation(o2)
            return false
        })
        .receive(on: DispatchQueue.main)
</code></pre>

<p>How to allow only .portrait, .landscape, .portrait, .landscape sequences 
and not .portrait, .portrait, .landscape etc </p>

<p><strong>Update</strong> </p>

<p>I need to use this, but it adds unnecessary boilerplate code:</p>

<pre><code>.onReceive(orientationChange) { orientation in
                guard orientation != self.lastOrientation else { return }
                self.lastOrientation = orientation
</code></pre>

<p>}</p>

<p>Here are internal implementations of helper functions</p>

<pre><code>fileprivate func toOrientation(_ notification: UIKit.Notification) -&gt; UIDeviceOrientation {
    (notification.object as? UIDevice)?.orientation ?? .unknown
}

fileprivate func filterOrientation(_ orientation: UIDeviceOrientation, orientations: [UIDeviceOrientation] = [.landscapeLeft, .landscapeRight, .portrait, .portraitUpsideDown]) -&gt; Bool {

    return orientations.contains(orientation)
}
</code></pre>
","4415642","","4415642","","2020-03-06 11:30:47","2020-03-06 11:40:27","Swift Combine removeDuplicates() not working as expected","<swift><combine>","1","3","1","","","CC BY-SA 4.0"
"60568858","1","60568944","","2020-03-06 17:24:19","","7","1116","<p>Consider the following code (you can c&amp;p it directly into a playground):</p>

<pre><code>class Foo: ObservableObject {
    @Published var bar = ""bar""
}

let foo = Foo()
let someSubscriber = foo.$bar
    .sink { value in
        print(""value is \(value)"")
    }
</code></pre>

<p>Although Foo has just been initialised once and it's member <code>bar</code> never changed, the sink executes it's <code>receiveValue</code> closure immediately. Is there any way to prevent this initial call from happening, e.g. is there an operator I might have overlooked?</p>
","239880","","","","","2020-03-06 19:52:02","Prevent sink receiveValue closure from being called immediately","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"60570901","1","60571151","","2020-03-06 20:06:52","","7","2446","<p>I'm running into an issue where in Combine where I have a boolean @Published property. </p>

<p>When I set it to true,
the sink closure is run and I can look at the value being received. It's true. But when I compare it against the actual property that I am observing, they are different.</p>

<p>This bit of code can be simply run in a playground. I'm not sure how this works or why the values would be different</p>

<pre><code>class TestModel {
    @Published var isLoading = false
}

let model = TestModel()

model.$isLoading.sink { (isLoading) in
    if isLoading != model.isLoading {
        print(""values NOT same"")
    }
}

model.isLoading = true
</code></pre>
","3786510","","","","","2022-09-23 21:54:36","Swift Combine sink value is different from value of @Published property","<swift><combine>","1","0","2","","","CC BY-SA 4.0"
"60572821","1","","","2020-03-06 23:19:05","","1","3223","<p>I got this simple playbook where I am trying to construct a dictionary from a list of key/value pairs using the <code>combine</code> filter. The problem is that it does not seem to work when looping over the pairs (I've tried loop, with_dict, with_items).</p>

<pre><code>- name: test jinja2 combine filter
  hosts: localhost    
    - name: test combine
      vars:
        x: {'three', 3}
      set_fact:
        x: ""{{ x | combine(item) }}""
      with_items: [{'one': 1},{'two': 2}]

    # I am expecting to see the two new dicts here,
    # but only the last one in the list is added
    - name: print x
      debug: msg={{ x }}
</code></pre>

<p>Expected output:</p>

<pre><code>ok: [localhost] =&gt; {
    ""msg"": {
        ""three"": 3,
        ""one"": 1,
        ""two"": 2
    }
}
</code></pre>

<p>My result:</p>

<pre><code>ok: [localhost] =&gt; {
    ""msg"": {
        ""three"": 3, 
        ""two"": 2
    }
}
</code></pre>

<p>From <a href=""https://stackoverflow.com/questions/34667091/how-to-combine-two-lists-together"">this</a> post, it seems that there's no out of the box solution for this kind of problem. While it wouldn't be hard to write a custom plugin, I am still wondering if there is a standard solution without writing a plugin.</p>
","8390382","","8390382","","2020-03-08 21:32:04","2020-08-12 10:31:46","Use ansible jinja2 combine filter in a loop","<filter><ansible><jinja2><combine>","3","1","","","","CC BY-SA 4.0"
"60578918","1","60591513","","2020-03-07 15:05:54","","0","1303","<p>This is what I am doing:</p>

<p>-> Login/Signup to Firebase using FirebaseAuthentification</p>

<p>-> Listining to AuthStateDidChangeListenerHandle</p>

<p>-> I store extra user information in Firestore, therefore I check if the user exists in Firestore</p>

<p>-> If the user does not exist I create an empty user</p>

<p>-> If everything was successful I return a Future Publisher via callback (I want to change that as well)</p>

<p>This is the checkLoginState function:</p>

<pre><code>func checkLoginState(completion: @escaping (AnyPublisher&lt;AccountDetails,Error&gt;) -&gt; Void) {
    self.handler = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
        guard let safeSelf = self else { return }
        completion(Future&lt;AccountDetails,Error&gt; { promise in
            if let user = user {
                print(user)
                print(auth)

                safeSelf.checkIfUserIsInDatabase(user: user.uid) { result in
                    switch result {
                    case .success(let isAvailable):
                        if isAvailable {
                             promise(.success(AccountDetails(userUID: user.uid,name: user.displayName, loggedIn: true, premiumUser: false)))
                        } else {
                            safeSelf.createEmptyUser(user: user.uid,email: user.email) { result in
                                switch result {
                                case .success(_):
                                    promise(.success(AccountDetails(userUID: user.uid,name: user.displayName, loggedIn: true, premiumUser: false)))
                                case .failure(let error):
                                    print(error)
                                }
                            }
                        }
                    case .failure(let error):
                        print(error)
                    }
                }
            } else {
                promise(.success(AccountDetails(userUID: nil, loggedIn: false, premiumUser: false)))
            }
            }.eraseToAnyPublisher()
        )
    }
}
</code></pre>

<p>These are my current functions:</p>

<pre><code>private func checkIfUserIsInDatabase(user id: String, completion: @escaping (Result&lt;Bool,Error&gt;) -&gt; Void)

private func createEmptyUser(user id: String, email:String?, completion: @escaping (Result&lt;Bool,Error&gt;) -&gt; Void)
</code></pre>

<p>Thats what I want to use:</p>

<pre><code>private func checkIfUserIsInDatabase(user id: String) -&gt; AnyPublisher&lt;Bool,Error&gt;

private func createEmptyUser(user id: String) -&gt; AnyPublisher&lt;Bool,Error&gt;

func checkLoginState() -&gt; AnyPublisher&lt;AccountDetails,Error&gt;
</code></pre>

<p>I had something like that, but it does not work, also looks confusing:</p>

<pre><code>func checkLoginState(completion: @escaping (AnyPublisher&lt;AccountDetails,Error&gt;) -&gt; Void) {
    self.handler = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
        guard let safeSelf = self else { return }
        completion(Future&lt;AccountDetails,Error&gt; { promise in
            if let user = user {
                print(user)
                print(auth)

                safeSelf.checkIfUserIsInDatabase(user: user.uid)
                    .sinkToResult { value in
                        switch value {
                        case .success(let isUserInDatabase):
                            if isUserInDatabase {
                                promise(.success(AccountDetails(userUID: user.uid,name: user.displayName, loggedIn: true, premiumUser: false)))
                            } else {
                                safeSelf.createEmptyUser(user: user.uid)
                                    .sinkToResult { value in
                                        switch value {
                                        case .success( _):
                                            promise(.success(AccountDetails(userUID: user.uid,name: user.displayName, loggedIn: true, premiumUser: false)))
                                        case .failure(let error):
                                            print(error)
                                        }
                                }
                            }
                        case .failure(let error):
                            print(error)
                        }

                }
            } else {
                promise(.success(AccountDetails(userUID: nil, loggedIn: false, premiumUser: false)))
            }
        }.eraseToAnyPublisher()
        )
    }
}
</code></pre>
","8887336","","","","","2020-03-08 19:56:01","Transform callback approach to reactive with Combine","<swift><firebase><future><combine><publisher>","2","8","1","","","CC BY-SA 4.0"
"60579822","1","60579823","","2020-03-07 16:37:26","","0","45","<p>The <a href=""https://developer.apple.com/documentation/combine/publisher/3204685-append"" rel=""nofollow noreferrer"">documentation</a> on the Combine Framework's <code>append</code> operator says:</p>

<blockquote>
  <p>This operator produces no elements until this publisher finishes. It then produces this publisher’s elements, followed by the given publisher’s elements.</p>
</blockquote>

<p>So I would expect the first publisher's elements to be produced all at once, with no regard for the timing by which they are actually published by the first publisher. But that is not the case. </p>

<p>For example:</p>

<pre><code>    [1,2,3,4].publisher.flatMap(maxPublishers: .max(1)) {
        Just($0).delay(for: 1, scheduler: DispatchQueue.main)
    }.append( Just(100) )
</code></pre>

<p>As you can see, the first publisher produces <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> at one-second intervals. According to the documentation, <code>append</code> should <em>wait</em> until all four values have been produced — that is, for four seconds — and then republish those values at all once. But that isn't what happens. What I see is just what the first publisher itself produces, namely, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> at one-second intervals. What's going on?</p>
","341994","","","","","2020-03-07 16:37:26","Timing of values in Combine Framework's `append` operator?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"60582659","1","","","2020-03-07 22:09:40","","2","1133","<p>Is there a Combine operator that will run a series of futures in sequence, running each to completion before starting the next?</p>

<p>I can do this with the very messy:</p>

<pre><code>f1
.flatMap { _ in 
  f2
}.flatMap { _ in 
  f3
}.flatMap { _ in 
  // ... 
}
</code></pre>

<p>but I'd prefer something like:</p>

<pre><code>sequence(f1, f2, f3, ...)
</code></pre>

<p>In some frameworks, this would look like:</p>

<pre><code>f1.then { f2 }.then { f3 }
</code></pre>
","126855","","126855","","2020-03-07 22:17:52","2020-03-09 00:22:25","In Combine, how do I run a series of futures in sequence?","<ios><macos><foundation><combine>","1","7","","","","CC BY-SA 4.0"
"60593147","1","60596388","","2020-03-08 23:47:46","","0","131","<p>I am trying to port this class in swift to Kotlin. Is there a Kotlin way of achieving extensions and to reduce the state(get the state)</p>

<pre><code>public final class MutateNode {
public var onSubscribe: (() -&gt; Void)?
public var onPublish: ((State) -&gt; Void)?
public var leafs: [Node]

public init(leafs: [Node], onSubscribe: (() -&gt; Void)? = nil, onPublish: ((State) -&gt; Void)? = nil) {
    self.leafs = leafs
    self.onPublish = onPublish
    self.onSubscribe = onSubscribe
}
}

extension MutateNode: ControlNode {
public var state: AnyPublisher&lt;State, Never&gt; {
    guard !leafs.isEmpty else {
        return Just(.failure)
            .eraseToAnyPublisher()
    }
    return leafs.reduce(into: Just(.failure).eraseToAnyPublisher()) { (resultPublisher, nextChild) in
        resultPublisher = resultPublisher.flatMap { state in
            state == .success ? Just(state).eraseToAnyPublisher() : nextChild.state.eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
    .handleEvents(
        receiveSubscription: { [weak self] _ in self?.onSubscribe?() },
        receiveOutput: { [weak self] state in self?.onPublish?(state) }
    )
    .eraseToAnyPublisher()
}
</code></pre>

<p>}</p>
","899611","","","","","2020-03-09 07:42:47","Kotlin equivalent for extensions and reduce","<swift><generics><kotlin><closures><combine>","1","0","","","","CC BY-SA 4.0"
"60593685","1","","","2020-03-09 01:26:59","","0","201","<p>This is for MacOS. I am trying to figure out how I can pump values to my model while the user holds down a custom button. Basically I am trying to recreate a MouseDown/MouseUp combo with a timer firing in between. It doesn’t seem possible with just a LongPressGesture so I have been experimenting with Combine and a Timer but with only partial success. I have the following:</p>

<pre><code>import SwiftUI
import Combine

var cancellable: Cancellable?

struct ContentView: View {
    var body: some View {
        ZStack{
            FastForwardButton().frame(width: 40, height: 40)
        }.frame(width: 200, height: 200)
    }
}

struct FastForwardButton: View {
    var timer = Timer.publish(every: 0.2, on: .main, in: .common)
    @GestureState private var isPressed = false
   // @State var cancellable: Cancellable?

    var body: some View {
        Rectangle()
            .gesture(
                LongPressGesture(minimumDuration: 4)
                    .updating($isPressed, body: { (currentState, state, transaction) in
                        if self.isPressed == false{
                            state = currentState
                            print(""Timer Started"")
                            cancellable = self.timer.connect()
                        }
                    })
            )

         .onReceive(timer) { time in
            // Do Something here eg myModel.pump()
            print(""The time is \(time)"")
            if self.isPressed == false{
                print(""Timer Cancelled"")
                cancellable?.cancel()
              //  cancellable = nil
            }
        }
    }
}

</code></pre>

<p>The above works one time. I get:</p>

<p>""Timer Started""<br>
""The Time is xxx""<br>
.....<br>
""The Time is xxx""<br>
""Timer Cancelled""</p>

<p>But the second press I just get:<br>
""Timer Started""</p>

<p>With no further actions</p>

<p>Note I also had to temporarily move the reference to cancellable outside the View as I got a warning about modifying the View while updating.</p>

<p>Can anyone figure out why the .onReceive closure is only called once? Thanks!</p>
","2234184","","2234184","","2020-03-09 01:43:32","2020-03-09 15:45:33","How to use LongPressGesture and Combine with Timer to ‘pump' values to model?","<swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"60594258","1","","","2020-03-09 03:05:45","","0","65","<p>Right now, I was able to observe changes to CoreData's NSManagedObject using</p>

<pre><code>NotificationCenter.default
.publisher(for: .NSManagedObjectContextObjectsDidChange, object: managedContext)
.sink(notification in
  guard let userInfo = notification.userInfo else { return }
  //get changed object and update each field
)
</code></pre>

<p>But is there a way to subscribe with .assign and just have the change of one particular field execute a UI change directly?</p>
","56952","","","","","2020-03-09 03:05:45","Is it possible to use Combine with individual field of NSManagedObject?","<swift><core-data><combine>","0","2","","","","CC BY-SA 4.0"
"60597769","1","","","2020-03-09 09:32:36","","0","42","<p>I have an <code>ObservableObject</code> with a few publishers:</p>

<pre class=""lang-swift prettyprint-override""><code>private class ViewModel: ObservableObject {
    @Published var top3: [SearchResult] = []
    @Published var albums: [SearchResult.Album] = []
    @Published var artists: [SearchResult.Artist] = []
}
</code></pre>

<p>The endpoint is a URLSessionDataPublisher that sends a single collection of values that can be either an album or an artist (there are actually more types but I'm reducing the problem set here.) What is the best way in Combine to separate this collection out into 3 collections: <code>[Album]</code>, <code>[Artist]</code>, and an array of 3 results that can be either <code>Artist</code> or <code>Album</code>?</p>

<pre class=""lang-swift prettyprint-override""><code>DatabaseRequest.Search(for: searchTerm)
    .publisher()
    // now i want to separate the collection out into [Album] and [Artist] and assign to my 3 @Published vars
    .receive(on: DispatchQueue.main)
    .sink { }
    .store(in: bag)
</code></pre>
","6938357","","","","","2020-03-13 00:44:43","What is the best way to demux a publisher's Output?","<swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"60598246","1","","","2020-03-09 10:02:59","","1","141","<p>I have a classic situation where I want to commit some action only once. For example update some entity in database using Swift Combine. My problem is that I don't really know what is the best approach for doing something only once. How do I unsubscribe when the update is finished?</p>

<p>This is code snippet through the layers that I am currently using:</p>

<p>ViewModel:
    let settingsModel: LocalSettingsModel    </p>

<pre><code>func saveLocalSettings(){
    let cancelable = settingsUseCase
                         .saveLocalSettings(localSettingsModel: settingsModel)
                         .sink(receiveCompletion: {_ in
                             print(""Completed!!!"")

                         }) { _ in
                             print(""Result of Save operation!!!"")
                         }
}
</code></pre>

<p>UseCase:</p>

<pre><code>func saveLocalSettings(settings: LocalSettingsModel) -&gt; AnyPublisher&lt;LocalSettingsModel, Error&gt; {
    return repository.saveLocalSettings(settings: settings)
}
</code></pre>

<p>Repository:</p>

<pre><code>    guard let realmSettings = LocalSettingsRealmModel(fromModel: settings) else {
            return Fail&lt;LocalSettingsModel, Error&gt;(error: .postconditionError(errorMessage: """"))
                .eraseToAnyPublisher()
        }

    return self.localDataSource
        .saveLocalSettings(localSettings: realmSettings)
        .receive(on: DispatchQueue.main)
        .subscribe(on: DispatchQueue.global())
        .mapError { (error) -&gt; Error in
             // do error mapping
        }
        .compactMap { settings in
            return (LocalSettingsModel(fromModel: settings))
        }
        .eraseToAnyPublisher()
</code></pre>

<p>Data Source:</p>

<pre><code>func saveLocalSettings(localSettings: LocalSettingsRealmModel) -&gt; AnyPublisher&lt;LocalSettingsRealmModel, LocalDataSourceError&gt; {
    do {
        return Just(try saveSettings(localSettings: localSettings))
            .mapError({ (Never) -&gt; LocalDataSourceError in})
            .eraseToAnyPublisher()
    } catch let error as NSError {
        // return some error
    }
}

func saveSettings(localSettings: LocalSettingsRealmModel) throws -&gt; LocalSettingsRealmModel
{
    let realm = try Realm()

    try realm.write {
        realm.add(localSettings, update: .modified)
    }

    return localSettings
}
</code></pre>

<p>I would really appreciate some pointers in the direction of what is a good practice when we are not expecting continuous stream of information in reactive world like in case of functions whose purpose is to execute single action. Do I really need to use Just() like in this example or is there a way do deal with this kind of situations from subscriber side. </p>
","2707795","","","","","2020-03-13 01:28:03","What is the right approach for resolving save operations with Swift Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"60601645","1","","","2020-03-09 13:31:53","","0","409","<p>I have such code:</p>

<pre><code>import Cocoa
import Combine

func prepareURLRequest(for url: URL) -&gt; URLRequest {
    let request = URLRequest(url: url)
    var token = ""token""

    print(""start value: \(token)"")

    let subscription = Token()
    subscription.getToken()
        .sink(receiveCompletion: { _ in
        print(""subscription completed"")
    }, receiveValue: { value in
        token = value
        print(""value received: \(token)"")
    })

    print(""new value: \(token)"")

    // attach received token to request
    return request
}


class Token {
    let token = PassthroughSubject&lt;String,Never&gt;()

    func verify() -&gt; Bool {
        // TODO: Token verification logic
        Bool.random()
    }

    func getToken() -&gt; AnyPublisher&lt;String,Never&gt; {
        return Future&lt;String, Never&gt; { promise in
            if self.verify() {
                let url = URLRequest(url: URL(string: ""http://avatars.io/twitter/twostraws"")!)
                URLSession.shared.dataTask(with: url) { data, response, error in
                    print(""Data Task started"")
                    if let error = error {
                        print(""error \(error)"")

                    }
                    guard let data = data else {
                        preconditionFailure(""data error"")
                    }
                    guard let response = response as? HTTPURLResponse else {
                        preconditionFailure(""response error"")
                    }

                    print(""data task received response with code: \(response.statusCode)"")
                    promise(.success(""\(response.statusCode)""))
                }.resume()
            } else {
                print(""keychain path"")
                sleep(2)
                promise(.success(""kwychain path success""))
            }
        }.eraseToAnyPublisher()
    }
}

let url = URL(string: ""http://avatars.io/twitter/twostraws"")!
let request = prepareURLRequest(for: url)
</code></pre>

<p>code should attach sinked token to prepared request object. Now the only <code>verify -&gt; false path</code> returns data in required order. When I try <code>verify -&gt; true</code> path data is sinked after prepareURLRequest ends it's life.</p>

<p>How to fix this to have both paths result with proper order (and token being updated before prepareURLRequest method ends?</p>
","1285959","","","","","2020-03-13 01:03:46","method ends before receiving data from Combine Future Publisher","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"60603137","1","","","2020-03-09 14:55:55","","1","763","<h2>Context</h2>

<p>I am following the example from WWDC 2019 722 <a href=""https://developer.apple.com/videos/play/wwdc2019/722/"" rel=""nofollow noreferrer"">https://developer.apple.com/videos/play/wwdc2019/722/</a> and WWDC 2019 721 <a href=""https://developer.apple.com/videos/play/wwdc2019/721/"" rel=""nofollow noreferrer"">https://developer.apple.com/videos/play/wwdc2019/721/</a> and making a field with validation the runs an asynchronous network check on a field.</p>

<p>What should happen, as mentioned in the talk, is that the username field should:</p>

<ol>
<li>Debounce</li>
<li>Show a loading indicator</li>
<li>Perform the network request</li>
<li>End with the network result</li>
<li>Hide the loading indicator</li>
<li>And show or hide a validation message as a result of the network response</li>
</ol>

<p>I have a prototype that has the debounce, and mocks the network request by using the delay operator. All of this is working well for the most part.</p>

<pre class=""lang-swift prettyprint-override""><code>let a = $firstName
    .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
    .flatMap { name -&gt; AnyPublisher&lt;String, Never&gt; in
        if name == """" {
            return Just(name)
                .eraseToAnyPublisher()
        } else {
            return Just(name)
                .handleEvents(receiveOutput: { _ in self.isFirstNameLoading = true})
                .delay(for: .seconds(2), scheduler: DispatchQueue.main)
                .handleEvents(receiveOutput: { _ in self.isFirstNameLoading = false})
                .eraseToAnyPublisher()
        }
    }
    .map { name -&gt; Bool in name != ""Q"" }
    .assign(to: \.isFirstNameValid, on: self)
</code></pre>

<p>The debounce waits until the input has paused. The <code>flatMap</code> acts as a conditional branching in the Combine flow of operators: if the value is empty, do not bother with the network request; else, if the value has value after the debounce, perform the network request. Lastly, my example is that ""Q"" is always an error, for mock purposes. </p>

<p>However, the slight problem is that the debounce happens before the branching. I would like to move the debounce to the else branch of the conditional, like so.</p>

<pre class=""lang-swift prettyprint-override""><code>let a = $firstName
    .flatMap { name -&gt; AnyPublisher&lt;String, Never&gt; in
        if name == """" {
            return Just(name)
                .eraseToAnyPublisher()
        } else {
            return Just(name)
                .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
                .handleEvents(receiveOutput: { _ in self.isFirstNameLoading = true})
                .delay(for: .seconds(2), scheduler: DispatchQueue.main)
                .handleEvents(receiveOutput: { _ in self.isFirstNameLoading = false})
                .eraseToAnyPublisher()
        }
    }
    .map { name -&gt; Bool in name != ""Q"" }
    .assign(to: \.isFirstNameValid, on: self)
</code></pre>

<p>When this happens, the true branch of the conditional (empty input) is run correctly, and the map+assign after the flatMap run correctly. However, when the input has value, and the else branch of the conditional runs, nothing after the debounce is run at all. </p>

<p>I have tried switching the <code>DispatchQueue</code> to <code>OperationQueue.main</code> and <code>RunLoop.main</code> to no avail.</p>

<p>Keeping the debounce to before the conditional works okay for now, but I'm wondering if I'm doing anything wrong with my attempt to put it in the branch. I'm also wondering if this would be the correct way to do ""branching"" in operators with Combine, particularly with my use of <code>flatMap</code> and <code>Just()</code>.</p>

<p>Any help would be appreciated!</p>
","464870","","","","","2020-03-09 17:51:06","Branching Combine operator, flatMap, and debounce oddity","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"60608199","1","","","2020-03-09 20:53:32","","6","1104","<p>Let's assume a model, which implements the protocol <code>ObservableObject</code> and has got a <code>@Published</code> property <code>name</code>. </p>

<pre class=""lang-swift prettyprint-override""><code>// MARK: Model
class ContentSinglePropertyModel: ObservableObject {
    @Published public var name: String
}
</code></pre>

<p>Now, I would like to display that name in a view and update the view, whenever <code>name</code> in the model changes. Additionally, I would like to use the Model-View-ViewModel (MVVM) pattern to achieve this goal. </p>

<pre class=""lang-swift prettyprint-override""><code>// MARK: ViewModel
final class ContentSinglePropertyViewModel: ObservableObject {
    private let model: ContentSinglePropertyModel

    @Published var name: String = """"

    init() {
        self.model = ContentSinglePropertyModel()
    }
}

// MARK: View
struct ContentSinglePropertyView: View {
    @ObservedObject var viewModel: ContentSinglePropertyViewModel

    var body: some View {
        Text(self.viewModel.name)
    }
}
</code></pre>

<p>Since I don't like the idea to make the model or it's properties public within the viewmodel, one option is to wrap the model's property <code>name</code> in the viewmodel. <strong>My question is</strong>: How to connect the <code>name</code> of the model and the viewmodel in the most idiomatic way?</p>

<p>I've came up with the solution to update the viewmodel's property through the use of Combine's <a href=""https://developer.apple.com/documentation/combine/currentvaluesubject/3235789-assign"" rel=""noreferrer"">assign</a> method:</p>

<pre class=""lang-swift prettyprint-override""><code>self.model.$name.assign(to: \.name, on: self).store(in: &amp;self.cancellables)
</code></pre>

<p>Is there a better solution?</p>

<p>My working example:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

// MARK: Model
class ContentSinglePropertyModel: ObservableObject {
    @Published public var name: String

    init() {
        self.name = ""Initial value""
    }

    func doSomething() {
        self.name = ""Changed value""
    }
}

// MARK: ViewModel
final class ContentSinglePropertyViewModel: ObservableObject {
    private let model: ContentSinglePropertyModel
    private var cancellables: Set&lt;AnyCancellable&gt; = []

    @Published var name: String = """"

    init() {
        self.model = ContentSinglePropertyModel()

        // glue Model and ViewModel
        self.model.$name.assign(to: \.name, on: self).store(in: &amp;self.cancellables)
    }

    func doSomething() {
        self.model.doSomething()
    }
}

// MARK: View
struct ContentSinglePropertyView: View {
    @ObservedObject var viewModel: ContentSinglePropertyViewModel

    var body: some View {
        VStack {
            Text(self.viewModel.name)

            Button(""Do something!"", action: {
                self.viewModel.doSomething()
            })
        }
    }
}

struct ContentSinglePropertyView_Previews: PreviewProvider {
    static var previews: some View {
        ContentSinglePropertyView(viewModel: .init())
    }
}
</code></pre>
","4354710","","","","","2020-06-05 04:00:23","How to connect published properties of model and viewmodel in Swift?","<swift><mvvm><swiftui><combine>","0","7","1","","","CC BY-SA 4.0"
"60612343","1","","","2020-03-10 06:10:24","","0","63","<p>I get difficulties to deal with below code, the value in dict <code>sectionMoviesBundle = [HomeSection: [T]]</code> could be <code>MovieViewModel</code> or <code>ActorViewModel</code> which two are struct type.</p>

<p>So generally how could I deal with this dict <code>[String: [typeA or typeB...]]</code>, using generic or AnyObject like <code>nowPlaying.results.map(MovieViewModel.init) as AnyObject</code>? And how to implement it in code?</p>

<pre><code>import SwiftUI
import Combine


class MovieListViewModel: ObservableObject {
    private var webService = WebService()
    private var cancellableSet: Set&lt;AnyCancellable&gt; = []

    @Published var sectionMoviesBundle = [HomeSection: [T]]() // Don't know how to deal with it now=.=!

    func getSectionMoviesBundle() {
        webService.getSectionsPublisher()
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { status in
                switch status {
                case .finished:
                    break
                case .failure(let error):
                    print(""ERROR: \(error)"")
                    break
                }
            }) { (nowPlaying, popular, upComing, topActor) in
                self.sectionMoviesBundle[.NowPlaying] = nowPlaying.results.map(MovieViewModel.init)
                self.sectionMoviesBundle[.Popular] = popular.results.map(MovieViewModel.init)
                self.sectionMoviesBundle[.Upcoming] = upComing.results.map(MovieViewModel.init) 
                self.sectionMoviesBundle[.TopActor] = topActor.results.map(ActorViewModel.init) 
        }.store(in: &amp;self.cancellableSet)
    }
}
</code></pre>
","10158398","","","","","2020-03-11 03:16:14","Swift: Dictionary with multi-types value","<swift><dictionary><combine>","3","0","","","","CC BY-SA 4.0"
"60614782","1","60615059","","2020-03-10 09:34:44","","0","45","<p>I execute my code in Playground:</p>

<pre><code>import PlaygroundSupport
import Combine

PlaygroundPage.current.needsIndefiniteExecution = true

var s = ""a""
let sb = s.publisher
    .sink(receiveValue: {
        print(""rec: \($0)"")
    })

let s0 = Timer.publish(every: 1.0, on: .main, in: .common)
.autoconnect()
.sink(receiveValue: {_ in
    print(""tiktok..."")
    s.append(""not work!"")
})
s.append(""not work too!"")
</code></pre>

<p>My Question is why s.publisher can't be triggered even though I changed s value???</p>
","5487391","","5487391","","2020-03-10 10:05:55","2020-03-10 10:05:55","Why String.publisher can't be triggered?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"60617914","1","60620163","","2020-03-10 12:42:40","","1","2094","<p>I use two publishers in View:</p>

<p>A: String.publisher</p>

<p>B: ObservableObject include one @Published String type</p>

<p>If I monitoring publisher A,I get a infinite loop.
But monitoring publisher B is OK!</p>

<pre><code>    import SwiftUI
    import Combine

    class Model: ObservableObject{
        @Published var someBool = false
        @Published var name:String = """"
    }

    struct ContentView: View {
        // Publisher A
        @State var name = """"
        // Publisher B
        @ObservedObject var model = Model()

        var body: some View {
            VStack {
                // Plan A: lead to infinite loop!!!
                TextField(""Input Name"", text: $name)
                // Plan B: It's OK
                //TextField(""Input Name"", text: $model.name)

                .onReceive(name.publisher.reduce("""", {t,c in
                    t + String(c)
                })) {text in
                    print(""change to \(text)"")
                    self.model.someBool.toggle()    //Plan A: infinite loop!!!
                }
                /*
                .onReceive(model.$name){name in
                    print(""change to \(name)"")
                    self.model.someBool.toggle()    //Plan B: It's OK!!!
                }
                */
            }
        }
    }
</code></pre>

<p>Although I changed model.someBool value in onReceive(),But Plan B is fine, Plan A lead to infinite loop.
Why is That??? Thanks :)</p>
","5487391","","","","","2020-11-20 15:35:33","onReceive String.publisher lead to infinite loop","<swift><swiftui><combine>","1","6","","","","CC BY-SA 4.0"
"60622272","1","60623463","","2020-03-10 16:47:34","","0","1502","<p>I just started using combine swift to handle the data request and response.</p>

<p>The Json data returned is a nested data which I will only need one part of it. 
such as:</p>

<pre><code>{
""page"": 1,
""data"": [
{
""id"": 1,
""title"": ""news-1"",
""content"": ""content 1""
},
{
""id"": 2,
""title"": ""news-2"",
""content"": ""content 2""
},
{
""id"": 3,
""title"": ""news-3"",
""content"": ""content 3""
}
],
""time"": 202021313,
""description"" :""xxxx""
}
</code></pre>

<p>I will need to use the <code>data</code> array.</p>

<p>Fetch functions below:</p>

<pre><code>    func fetchData() throws -&gt; URLSession.DataTaskPublisher {
        let headers = [
            ""Content-Type"": ""application/json"",
            ""cache-control"": ""no-cache"",
        ]

        guard let url = URL(string: endpointStr ) else {
            throw APIError.invalidEndpoint
        }

        var request = URLRequest(url: url,
        cachePolicy: .useProtocolCachePolicy,
        timeoutInterval: 10.0)

        request.httpMethod = ""GET""
        request.allHTTPHeaderFields = headers

        let session = URLSession.shared
        return session.dataTaskPublisher(for: request)
    }
</code></pre>

<pre><code>        let publisher = try? fetchData()
        let decoder = JSONDecoder()
        let cancellable = publisher?
            .receive(on: DispatchQueue.main)
            .map {
                 $0.data
            }
            .decode(type: DataModel.self, decoder: decoder)
            .sink(receiveCompletion: { (completion) in
            switch completion {
            case .failure(let error):
                print(""Error:"")
                print(error)
            case .finished:
                print(""DONE - get Publisher"")
            }
        }, receiveValue: { data in
            print(data.title)
        })
</code></pre>

<p>The data it returned is the complete json data, is there any elegant way to get only the array of data and convert into an array of [DataModel] and handle the data in receiveValue.</p>

<p>I have tried to edit map with no luck:</p>

<pre><code>            .map {
                if let dataString = String(data: $0.data, encoding: .utf8) {
                    let dataDic = APIService.convertToDictionary(text: dataString)
                    if let DataArray = dataDic?[""data""] {
                        return listDataDic! 
                    }
                 return $0.data
                }
</code></pre>
","3262769","","","","","2020-03-10 18:02:56","How can I read the nested json data by using swift combine","<json><swift><combine>","1","0","0","","","CC BY-SA 4.0"
"60624851","1","60627981","","2020-03-10 19:43:03","","13","5341","<p>I see how to use <code>.retry</code> directly, to resubscribe after an error, like this:</p>

<pre><code>    URLSession.shared.dataTaskPublisher(for:url)
        .retry(3)
</code></pre>

<p>But that seems awfully simple-minded. What if I think that this error might go away if I wait awhile? I could insert a <code>.delay</code> operator, but then the delay operates even if there is no error. And there doesn't seem to be a way to apply an operator conditionally (i.e. only when there's an error).</p>

<p>I see how I could work around this by writing a RetryWithDelay operator from scratch, and indeed such an operator has been written by third parties. But is there a way to say ""delay if there's an error"", purely using the operators we're given?</p>

<p>My thought was that I could use <code>.catch</code>, because its function runs only if there is an error. But the function needs to return a publisher, and what publisher would we use? If we return <code>somePublisher.delay(...)</code> followed by <code>.retry</code>, we'd be applying <code>.retry</code> to the wrong publisher, wouldn't we?</p>
","341994","","341994","","2020-03-11 13:29:05","2021-04-02 08:19:42","Combine framework retry after delay?","<ios><swift><combine>","4","0","3","","","CC BY-SA 4.0"
"60633154","1","60633415","","2020-03-11 09:47:09","","2","7959","<p>I do see a lot of similar questions in stack-overflow, but seems no one is similar with my case. I'm new to Combine frame work, and it took me this whole afternoon to figure out what is wrong, however still stuck at here...</p>

<p>Xcode gives me below error, what I do is using TMDB's API and to decode it into my Actor model. And it failed on this line <code>let result = try self.decoder.decode(TMDBActorsResult.self, from: output.data)</code>. Could you give me some hint what is going on with this <code>adult</code>?</p>

<blockquote>
  <p>ERROR: keyNotFound(CodingKeys(stringValue: ""adult"", intValue: nil), Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue: ""results"", intValue: nil), _JSONKey(stringValue: ""Index 0"", intValue: 0), CodingKeys(stringValue: ""knownFor"", intValue: nil), _JSONKey(stringValue: ""Index 0"", intValue: 0)], debugDescription: ""No value associated with key CodingKeys(stringValue: \""adult\"", intValue: nil) (\""adult\"")."", underlyingError: nil))</p>
</blockquote>

<p>Also I check the url is working and here is the return data from TMDB API:</p>

<p><a href=""https://i.stack.imgur.com/DWA73.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DWA73.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/SgnWT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SgnWT.png"" alt=""enter image description here""></a></p>

<p><strong>/// Model for Actor</strong></p>

<pre><code>import SwiftUI


struct TMDBActorsResult: Codable {
    let page: Int?
    let results: [Actor]
    let totalResults: Int?
    let totalPages: Int?
}

struct Actor: Codable {
    let profilePath: String?
    let adult: Bool
    let id: Int?
    let name: String?
    let popularity: CGFloat?
    let knownFor: [Production]?
    let knownForDepartment: String?
    let gender: Int?
}

// MARK: Used for two objects with media type = (Movie or TV)
struct Production: Codable {
    let posterPath: String?
    let adult: Bool
    let overview: String?
    let releaseDate: String?
    let originalTitle: String?
    let genreIds: [Int]?
    let id: Int?
    let mediaType: String?
    let originalLanguage: String?
    let title: String?
    let backdropPath: String?
    let popularity: Double?
    let voteCount: Int?
    let video: Bool
    let voteAverage: Double?
    let firstAirDate: String?
    let originCountry: [String]?
    let name: String?
    let originalName: String?
}
</code></pre>

<p><strong>/// The JSON decoding part.</strong></p>

<pre><code>import Foundation
import Combine

enum HTTPError: LocalizedError {
    case statusCode
    case post
}

struct WebService {

    private var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        return decoder
    }()

    private var session: URLSession = {
        let config = URLSessionConfiguration.default
        config.urlCache = URLCache.shared
        config.waitsForConnectivity = true
        config.requestCachePolicy = .reloadIgnoringLocalCacheData
        return URLSession(configuration: config, delegate: nil, delegateQueue: nil)
    }()

    private func createPublisher&lt;T: Codable&gt;(for url: URL) -&gt; AnyPublisher&lt;T, Error&gt; {
        print(""Pblisher URL: \(url)"")
        return session.dataTaskPublisher(for: url)
            .tryMap { output in
                guard let response = output.response as? HTTPURLResponse, response.statusCode == 200 else {
                    print(""Response: \(output.response)"")

                    do {
                        let ss = try self.decoder.decode(Response.self, from: output.data)
                        print(""ss:  \(ss)"")
                    } catch {
                        print(error)
                    }
                    throw HTTPError.statusCode
                }

                do {
                    let result = try self.decoder.decode(TMDBActorsResult.self, from: output.data)
                    print(""Result: \(result)"")
                } catch {
                    print(""ERROR: \(error)"")
                }
                return output.data
            }
            .decode(type: T.self, decoder: decoder)
            .eraseToAnyPublisher()
    }

    func getSectionsPublisher() -&gt; AnyPublisher&lt;TMDBActorsResult, Error&gt; {
        createPublisher(for: TMDBClient.Endpoints.popularActors.url).eraseToAnyPublisher()
    }

}


</code></pre>

<p>/ / / <strong>Update,</strong> As vadian's comment, I try to modify my data model to using enum associated value, as below code showed, but it gives me error <code>Instance method 'decode(_:forKey:)' requires that 'MediaType' conform to 'Decodable'</code>. I release that the different is that my model is using <code>type</code> in the items but not in the root Media struct.</p>

<pre><code>let jsonString = """"""
[{""name"": ""Popular Movies"",
""description"": ""Basic movie description"",
""items"": [ { ""id"": 15, ""budget"": 10, ""type"": ""movies"",""name"": ""Sample movie"", ""movieSPT"": """"}]
},
{""name"": ""Popular TV Shows"",
""description"": ""Basic shows description"",
""items"": [ { ""id"": 15, ""adult"": false, ""type"": ""tvshows"",""title"": ""Sample show"", ""showSPT"": """"}]
}
]
""""""
let data = Data(jsonString.utf8)


struct Movie : Decodable {
    let id: Int
    let name, movieSPT: String
    let type: String
    let budget: Int
}

struct TVShow : Decodable {
    let id: Int
    let title, showSPT: String
    let type: String
    let adult: Bool
}

enum MediaType {
    case movie([Movie]), tvShow([TVShow])
}

struct Media : Decodable {
    let name : String
    let description : String
    let items : MediaType

    private enum CodingKeys : String, CodingKey { case name, description, type, items }

    init(from decoder : Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try container.decode(String.self, forKey: .name)
        self.description = try container.decode(String.self, forKey: .description)
        self.items = try container.decode(MediaType.self, forKey: .items)
        // type = try container.decode(String.self, forKey: .type)
        if items.type == ""movies"" {
            let movieData = try container.decode([Movie].self, forKey: .items)
            // print(""AAA: \(movieData)"")
            items = .movie(movieData)
        } else { // add better error handling
            let showData = try container.decode([TVShow].self, forKey: .items)
            items = .tvShow(showData)
        }

    }
}

do {
    let result = try JSONDecoder().decode([Media].self, from: data)
    print(result)
} catch {
    print(error)
}
</code></pre>

<p><strong>Add JSON Data</strong>, <code>known_for</code> is an [object], which object could Movie type or TV type.</p>

<pre><code>{
  ""page"": 1,
  ""total_results"": 10000,
  ""total_pages"": 500,
  ""results"": [
    {
      ""popularity"": 57.168,
      ""known_for_department"": ""Acting"",
      ""name"": ""Thassapak Hsu"",
      ""id"": 1910848,
      ""profile_path"": ""/1fmjgN8EvDj1TiEJk2Zs4y0T40O.jpg"",
      ""adult"": false,
      ""known_for"": [
        {
          ""original_name"": ""萌妻食神"",
          ""genre_ids"": [
            35,
            10765,
            10766
          ],
          ""media_type"": ""tv"",
          ""name"": ""Cinderella Chef"",
          ""origin_country"": [],
          ""vote_count"": 5,
          ""first_air_date"": ""2018-04-23"",
          ""backdrop_path"": ""/rnzmWKEiWPb8GC1mlqQojj8ccWj.jpg"",
          ""original_language"": ""zh"",
          ""id"": 79574,
          ""vote_average"": 9,
          ""overview"": """",
          ""poster_path"": ""/xb40Li6ff1BK0pVOxV4lutssCrR.jpg""
        },
        {
          ""original_name"": ""外星女生柴小七"",
          ""genre_ids"": [
            35,
            10765
          ],
          ""media_type"": ""tv"",
          ""name"": ""My Girlfriend is an Alien"",
          ""origin_country"": [
            ""CN""
          ],
          ""vote_count"": 2,
          ""first_air_date"": ""2019-08-19"",
          ""backdrop_path"": ""/kCl7piWv3pypgYfyLFi7ZgFGlYV.jpg"",
          ""original_language"": ""zh"",
          ""id"": 92779,
          ""vote_average"": 9,
          ""overview"": ""The alien girl Chai Xiaoqi tells the story of Fang Xiaoqi, the overbearing president of the alien girl who died from the \""Cape Town Planet\"", who was suffering from the \""rainy weather heterosexual amnesia\"". A high-energy hilarious and romantic cross-star love story. The female host Chai Xiaoqi is not only an alien, but also a true-handed witch. Once she inhales the hormones emitted by the males in the earth, she will fall into the \""flowery state\"" and suffer from various diseases. The fun and ridiculously ridiculous romance will restore the singularity of the girl in the perfection of the girl. In order to survive on the human earth, Chai Xiaoqi will use his various super powers to solve one accident after another, like a roller coaster. The ups and downs will make the audience hooked. The male lord is cold and is an alternative overbearing president. When it rains, he will forget the opposite sex that appears around him. For this reason, he and the female host will launch various \""fighting and fighting\"" laughter dramas. The experience of high sweetness and romance is expected to be Strongly slammed the girl's heart when it was broadcast."",
          ""poster_path"": ""/5e2owvs9TWVsuIacTFxJGPp6KVW.jpg""
        },
        {
          ""original_name"": ""Devil Lover เผลอใจ..ให้นายปีศาจ"",
          ""id"": 74640,
          ""media_type"": ""tv"",
          ""name"": ""Devil Lover เผลอใจ..ให้นายปีศาจ"",
          ""vote_count"": 0,
          ""vote_average"": 0,
          ""first_air_date"": ""2015-10-07"",
          ""poster_path"": ""/moThN7iERydEHI2RbfrmhCp69R4.jpg"",
          ""genre_ids"": [
            35
          ],
          ""original_language"": ""th"",
          ""backdrop_path"": ""/iRYOwW6DRIRwDYVmRWA8nbfaV2c.jpg"",
          ""overview"": """",
          ""origin_country"": [
            ""TH""
          ]
        }
      ],
      ""gender"": 2
    },
    {
      ""popularity"": 39.35,
      ""known_for_department"": ""Acting"",
      ""gender"": 1,
      ""id"": 2487703,
      ""profile_path"": ""/jRdDoFoHq36hg4kYxxiLa5DRYUW.jpg"",
      ""adult"": false,
      ""known_for"": [
        {
          ""poster_path"": ""/d9PhCnofBEeQGR3lwywTjWKBiXj.jpg"",
          ""id"": 449924,
          ""vote_count"": 346,
          ""video"": false,
          ""media_type"": ""movie"",
          ""adult"": false,
          ""backdrop_path"": ""/ekP6EVxL81lZ4ivcqPsoZ72rY0h.jpg"",
          ""genre_ids"": [
            28,
            18,
            36
          ],
          ""original_title"": ""葉問4"",
          ""original_language"": ""cn"",
          ""title"": ""Ip Man 4: The Finale"",
          ""vote_average"": 6,
          ""overview"": ""Following the death of his wife, Ip Man travels to San Francisco to ease tensions between the local kung fu masters and his star student, Bruce Lee, while searching for a better future for his son."",
          ""release_date"": ""2019-12-20""
        }
      ],
      ""name"": ""Vanda Lee""
    },
    {
      ""popularity"": 28.664,
      ""known_for_department"": ""Acting"",
      ""gender"": 1,
      ""id"": 556435,
      ""profile_path"": ""/5MgWM8pkUiYkj9MEaEpO0Ir1FD9.jpg"",
      ""adult"": false,
      ""known_for"": [
        {
          ""release_date"": ""2019-05-30"",
          ""id"": 496243,
          ""vote_count"": 5120,
          ""video"": false,
          ""media_type"": ""movie"",
          ""vote_average"": 8.6,
          ""title"": ""Parasite"",
          ""genre_ids"": [
            35,
            18,
            53
          ],
          ""original_title"": ""기생충"",
          ""original_language"": ""ko"",
          ""adult"": false,
          ""backdrop_path"": ""/TU9NIjwzjoKPwQHoHshkFcQUCG.jpg"",
          ""overview"": ""All unemployed, Ki-taek's family takes peculiar interest in the wealthy and glamorous Parks for their livelihood until they get entangled in an unexpected incident."",
          ""poster_path"": ""/7IiTTgloJzvGI1TAYymCfbfl3vT.jpg""
        },
....
</code></pre>
","10158398","","10158398","","2020-03-14 13:59:03","2020-03-14 16:55:25","Swift: ERROR: keyNotFound(CodingKeys(stringValue: ""adult"", intValue: nil)","<swift><combine><jsondecoder>","1","0","","","","CC BY-SA 4.0"
"60640143","1","60651885","","2020-03-11 16:05:45","","10","6867","<p>I noticed that</p>

<pre><code>textField.publisher(for: \.text)
</code></pre>

<p>delivers events when editing finishes, but not for every character/editing change. How do I get a Publisher, that sends evens for every change?
In ReactiveSwift it would be</p>

<pre><code>textField.reactive.continousTextValues()
</code></pre>

<p>And in RxSwift it would be just (<a href=""https://stackoverflow.com/questions/45633173/how-do-you-get-a-signal-every-time-a-uitextfield-text-property-changes-in-rxswif"">How do you get a signal every time a UITextField text property changes in RxSwift</a>)</p>

<pre><code>textField.rx.text
</code></pre>

<p>Approaches I took:</p>

<ul>
<li>checking the <code>publisher(for:options:)</code> method, but there are no appropriate options for the desired outcome.</li>
<li>adding a target/action <code>textField.addTarget(self, action: #selector(theTextFieldDidChange), for: .editingChanged)</code> (<a href=""https://stackoverflow.com/questions/7010547/uitextfield-text-change-event"">UITextField text change event</a>)</li>
<li>doing essentially the same as the previous step by connecting the action via interface builder, both leading to extra work and cluttered code.</li>
<li>Watching the 2019 WWDC videos about Combine. They were not dealing with textfields, but using <code>@Published</code> variables instead, hiding were the values actually came from - (or did I miss something?).</li>
</ul>

<p>I have no clue at the moment, how to do this and I feel the tendency to go back to ReactiveSwift, but I wanted to ask you, before taking this step backwards.</p>
","1836024","","","","","2022-01-13 13:59:42","Swift Combine - How to get a Publisher that delivers events for every character change of UITextField's text property","<ios><swift><uitextfield><combine>","4","2","4","","","CC BY-SA 4.0"
"60646857","1","60647296","","2020-03-12 02:36:53","","3","2443","<p>I'm working in SwiftUI and have an AudioPlayer type that is a subclass of AVPlayer; it publishes AVPlayer's timeControllerStatus(?) (.playing, .paused, and others?). Rather than subclassing AVPlayer, I would like to pass in an AVPlayer and have it notify me using .onReceive in some View. Here is the current, functional type I have:</p>

<pre><code>import AVKit
import Combine

class AudioPlayer: AVPlayer, ObservableObject {
    @Published var buffering: Bool = false

    override init() {
        super.init()
        registerObservers()
    }

    private func registerObservers() {
        self.addObserver(self, forKeyPath: ""timeControlStatus"", options: [.old, .new], context: nil)
    }

    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {

        if keyPath == ""timeControlStatus"", let change = change, let newValue = change[NSKeyValueChangeKey.newKey] as? Int, let oldValue = change[NSKeyValueChangeKey.oldKey] as? Int {
            let oldStatus = AVPlayer.TimeControlStatus(rawValue: oldValue)
            let newStatus = AVPlayer.TimeControlStatus(rawValue: newValue)
            if newStatus != oldStatus {
                DispatchQueue.main.async {[weak self] in
                    if newStatus == .playing || newStatus == .paused {
                        self?.buffering = false
                    } else {
                        self?.buffering = true
                    }
                }
            }
        }
    }
}
</code></pre>

<p>And here is an example of a class like the one I would like (taken from <a href=""https://medium.com/@chris.mash/avplayer-swiftui-part-4-better-player-observing-3e5c3f24419d"" rel=""nofollow noreferrer"">Chris Mash's tutorial on SwiftUI &amp; AVPlayer</a>):</p>

<pre><code>import Combine
import AVFoundation

class PlayerItemObserver {
    let publisher = PassthroughSubject&lt;Bool, Never&gt;()
    private var itemObservation: NSKeyValueObservation?

    init(player: AVPlayer) {
        // Observe the current item changing
        itemObservation = player.observe(\.currentItem) { [weak self] player, change in
            guard let self = self else { return }
            // Publish whether the player has an item or not
            self.publisher.send(player.currentItem != nil)
        }
    }

    deinit {
        if let observer = itemObservation {
            observer.invalidate()
        }
    }
}
</code></pre>

<p>Your help is much appreciated.</p>
","12506105","","","","","2020-03-12 07:42:00","SwiftUI Combine for .onReceive notifications with AVPlayer","<swift><notifications><swiftui><avplayer><combine>","2","1","7","","","CC BY-SA 4.0"
"60667976","1","60668133","","2020-03-13 09:33:34","","2","2579","<p>SwiftUI and Combine noob here, I isolated in a playground the problem I am having. Here is the playground.</p>

<pre class=""lang-swift prettyprint-override""><code>final class ReactiveContainer&lt;T: Equatable&gt; {
    @Published var containedValue: T?
}

class AppContainer {
    static let shared = AppContainer()

    let text = ReactiveContainer&lt;String&gt;()
}

struct TestSwiftUIView: View {

    @State private var viewModel = ""test""

    var body: some View {
        Text(""\(viewModel)"")
    }

    init(textContainer: ReactiveContainer&lt;String&gt;) {

        textContainer.$containedValue.compactMap {
            print(""compact map \($0)"")
            return $0
        }.assign(to: \.viewModel, on: self)
    }
}

AppContainer.shared.text.containedValue = ""init""


var testView = TestSwiftUIView(textContainer: AppContainer.shared.text)
print(testView)

print(""Executing network request"")
DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    AppContainer.shared.text.containedValue = ""Hello world""
    print(testView)
}
</code></pre>

<p>When I run the playground this is what's happening:</p>

<pre><code>compact map Optional(""init"")
TestSwiftUIView(_viewModel: SwiftUI.State&lt;Swift.String&gt;(_value: ""test"", _location: nil))
Executing network request
TestSwiftUIView(_viewModel: SwiftUI.State&lt;Swift.String&gt;(_value: ""test"", _location: nil))
</code></pre>

<p>So as you can see, two problems there:</p>

<ul>
<li><p>The compact map closure is only called once, on subscription but not when the dispatch is ran</p></li>
<li><p>The assign operator is never called</p></li>
</ul>

<p>I have been trying to solve this these past few hours without any success. Maybe someone with a top knowledge in SwiftUI/Combine could help me, thx !</p>

<p><strong>EDIT</strong></p>

<p>Here is the working solution:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {

    @State private var viewModel = ""test""
    let textContainer: ReactiveContainer&lt;String&gt;

    var body: some View {
        Text(viewModel).onReceive(textContainer.$containedValue) { (newContainedValue) in
            self.viewModel = newContainedValue ?? """"
        }
    }

    init(textContainer: ReactiveContainer&lt;String&gt;) {
        self.textContainer = textContainer
    }
}
</code></pre>
","2614946","","2614946","","2020-03-19 17:58:03","2021-07-07 10:16:26","@Published and .assign not reacting to value update","<ios><swift><swiftui><combine><publisher>","3","1","","","","CC BY-SA 4.0"
"60681453","1","","","2020-03-14 09:43:18","","0","384","<p>I have a view class showing list of items coming from ViewModel class, in picker. Initial state of this picker is first element from the array of objects of the viewModel class.</p>

<p>On selection of item from picker, I want to do different actions in that view - 1. send  the object info to different screen on button click. 2. display information with respected to selected object from picker.</p>

<pre><code>import SwiftUI
import Combine
struct SetConfiguration: View {


@ObservedObject var profileListVM : ProfilesListViewModel = ProfilesListViewModel()  
@State private var selectedConfiguration  = 0 ///show ""Add"" as initial state
var body: some View {
HStack {
        Text(""Configuration:"")

        Picker(selection: $selectedConfiguration.onChange(connectToConfiguration), label: EmptyView()) {
            ForEach(profileListVM.profiles, id: \.self) {
                          choice in
                Text(choice.name).tag(choice)
            }
        }

        Text (“Selcted item is: \(self. selectedconfiguration.name)”)

        Button(action: {

        }) {
            Text(""Edit"")
        }.sheet(isPresented: $showEditConfig) {
            EditConfigurationView()
                                         //  TODO pass  selectedConfiguration as profile object
        }

      }  
</code></pre>

<p>}</p>

<p><strong>viewModel class:</strong></p>

<pre><code>class ProfilesListViewModel: ObservableObject { 
 @Published var profiles: [ProfileViewModel] = [ProfileViewModel]()   
static var addNewProfile = ProfileViewModel(name: ""Add Configuration"")
init() {
    fetchAllProfiles()
}
func fetchAllProfiles() {
     profiles.append(ProfilesListViewModel.addNewProfile) ///Add is first object
    self.profiles = CoreDataManager.shared.getConfigurations().map(ProfileViewModel.init) /// fetch all profile objects    
}
</code></pre>

<p>}</p>
","","user12994005","","","","2020-04-07 08:58:10","how to populate picker from ViewModel object, setting to initial state of first element and handle actions on selection of picker item","<core-data><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"60685810","1","","","2020-03-14 18:06:37","","9","2303","<p>Is there a good way to handle an array of <code>AnyCancellable</code> to remove a stored <code>AnyCancellable</code> when it's finished/cancelled?</p>

<p>Say I have this</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation

class Foo {

    private var cancellables = [AnyCancellable]()

    func startSomeTask() -&gt; Future&lt;Void, Never&gt; {
        Future&lt;Void, Never&gt; { promise in
            DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(2)) {
                promise(.success(()))
            }
        }
    }

    func taskCaller() {
        startSomeTask()
            .sink { print(""Do your stuff"") }
            .store(in: &amp;cancellables)
    }

}
</code></pre>

<p>Every time <code>taskCaller</code> is called, a <code>AnyCancellable</code> is created and stored in the array.
I'd like to remove that instance from the array when it finishes in order to avoid memory waste.</p>

<p>I know I can do something like this, instead of the array</p>

<pre><code>var taskCancellable: AnyCancellable?
</code></pre>

<p>And store the cancellable by doing:</p>

<pre><code>taskCancellable = startSomeTask().sink { print(""Do your stuff"") }
</code></pre>

<p>But this will end to create several single cancellable and can pollute the code. I don't want a class like</p>

<pre><code>class Bar {

    private var task1: AnyCancellable?
    private var task2: AnyCancellable?
    private var task3: AnyCancellable?
    private var task4: AnyCancellable?
    private var task5: AnyCancellable?
    private var task6: AnyCancellable?

}
</code></pre>
","5674721","","","","","2021-05-26 11:25:28","Remove from array of AnyCancellable when publisher finishes","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"60686946","1","","","2020-03-14 20:17:21","","2","1316","<p>I'm having a hard time using the <code>Connectable</code> protocol on a <code>PassthroughSubject</code>. What I would like to do is be able to control when the <code>PassthroughSubject</code> begins sending events to its subscribers.</p>

<pre><code>let eventPublisher = PassthroughSubject&lt;String, Never&gt;().makeConnectable()
let subscriber = MySubscriber()
eventPublisher.subscribe(subscriber)

eventPublisher.send(""Hello"") // Does not compile, send not found in Publisher.MakeConnectable

let cancelable = eventPublisher.connect()
// expect MySubscriber to recieve ""Hello""
</code></pre>

<p>I'm new to Combine, but I don't understand how I can send values downstream to subscribers after becoming a connectable publisher and calling <code>connect()</code>. The docs are quite sparse on this topic and I'm hoping someone can show me how to achive this behavior.</p>
","7710773","","","","","2020-03-17 04:46:41","Swift Combine makeConnectable with PassthroughSubject","<swift><combine>","2","1","","","","CC BY-SA 4.0"
"60689807","1","60690133","","2020-03-15 04:41:38","","2","1543","<pre><code>notificationCenterPublisher = NotificationCenter.default
            .publisher(for: .NSManagedObjectContextObjectsDidChange, object: context)
            .map { (notification) -&gt; (CoreDataContextObserverState) in
                self.handleContextObjectDidChangeNotification(notification: notification)
            }
            .eraseToAnyPublisher()
</code></pre>

<p>I have the method handleContextObjectDidChangeNotification doing the mapping.</p>

<p>Right now notificationCenterPublisher is of type <code>AnyPublisher&lt;CoreDataContextObserverState, Never&gt;</code></p>

<p>But I want to make it <code>AnyPublisher&lt;CoreDataContextObserverState, Error&gt;</code> and have handleContextObjectDidChangeNotification have some way of indicating an error has occured. </p>

<p>How do I do that?</p>
","56952","","","","","2020-03-15 05:55:16","How to change error type from Never to Error in Combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"60691335","1","","","2020-03-15 09:14:09","","0","2176","<p>I have an <code>ObservableObject</code> with a <code>@Published</code> value, how can I detect if the value was changed via <code>TextField</code> view or it was set directly (When <code>Button</code> is tapped for instance)?</p>

<pre><code>struct ContentView: View {

    @ObservedObject var model = Model()

    var body: some View {
        VStack {
            Button(""set value"") {
                self.model.value = ""user set value""
            }
            TextField(""value"", text: $model.value)
        }
    }
}

class Model: ObservableObject {

     @Published var value = """"

     var anyCancellable: AnyCancellable?

      init() {
          anyCancellable = $value.sink { val in
              // if changed by Button then ...
              // if changed by TextField then ...
          }
      }
}
</code></pre>

<p>My real case scenario sounds like this: when the user changes the value a request have to be sent to the server with the new value, but the server can also respond with a new value (in that case a new request to server should not be sent), so I have to distinguish between the case when the user changes the value (via TextField) and the case when the server changes the value.</p>
","10208552","","10208552","","2020-03-15 10:06:51","2020-03-15 22:46:15","How to detect what changed a @Published value in SwiftUI?","<ios><swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"60693099","1","","","2020-03-15 12:55:07","","1","58","<p>i have 2 classes (one for HealthKit and the other for CoreMotion) which assign values to some published variables, which I then access through my main swiftui file. My content view gets updates correctly. So far so good. Now I want to log the output of these variables to the console. I could do this directly by logging directly from the class, but the issue I have is that I need to have the output for both classes in a single line. I wrote a new function for this, but the values do not get updated. Anyone who can help me ? Is it because the function only gets called once so all parameters are always the parameters when the function got called ? </p>

<p>my main contentView.swift file:</p>

<pre><code>import SwiftUI

struct ContentView: View {

    @State var isActive: Bool = false
    @ObservedObject var motion = MotionManager()
    @ObservedObject var health = HealthKitManager()

    private var logger = ConsoleLogger()

    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                Indicator(title: ""X:"", value: motion.rotationX)
                Indicator(title: ""Y:"", value: motion.rotationY)
                Indicator(title: ""Z:"", value: motion.rotationZ)
                Divider()
                Indicator(title: ""Pitch:"", value: motion.pitch)
                Indicator(title: ""Roll:"", value: motion.roll)
                Indicator(title: ""Yaw:"", value: motion.yaw)
                Divider()
                Indicator(title: ""HR:"", value: health.heartRateValue)
                }
            .padding(.horizontal, 10)
            Button(action: {
                self.isActive.toggle()
                self.isActive ? self.start() : self.stop()
            }) {
                Text(isActive ? ""Stop"" : ""Start"")
            }
            .background(isActive ? Color.green : Color.blue)
            .cornerRadius(10)
        }.onAppear {
            self.health.autorizeHealthKit()
        }
    }

    private func start() {
        self.motion.startMotionUpdates()
        self.health.fetchHeartRateData(quantityTypeIdentifier: .heartRate)
        self.logger.startLogging(rotationX: self.motion.rotationX, rotationY: self.motion.rotationY, rotationZ: self.motion.rotationZ, pitch: self.motion.pitch, roll: self.motion.roll, yaw: self.motion.yaw, heartRate: self.health.heartRateValue)
    }

    private func stop() {
        self.motion.stopMotionUpdates()
        self.health.stopFetchingHeartRateData()
        self.logger.stopLogging()
    }

}

struct Indicator: View {
    var title: String
    var value: Double

    var body: some View {
        HStack {
            Text(title)
                .font(.footnote)
                .foregroundColor(.blue)
            Text(""\(value)"")
                .font(.footnote)
        }
    }
}
</code></pre>

<p>And here is my consoleLogger.swift file </p>

<pre><code>import Foundation
import os.log

class ConsoleLogger {

    private var timer: Timer?

    func startLogging(rotationX: Double, rotationY: Double, rotationZ: Double, pitch: Double, roll: Double, yaw: Double, heartRate: Double) {

        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true, block: { _ in
            let timestamp = Date().timeIntervalSince1970
            os_log(""Motion: %@, %@, %@, %@, %@, %@, %@, %@"",
                   String(timestamp),
                   String(rotationX),
                   String(rotationY),
                   String(rotationZ),
                   String(pitch),
                   String(roll),
                   String(yaw),
                   String(heartRate)
            )
        })
    }

    func stopLogging() {
        timer?.invalidate()
    }
}
</code></pre>

<p>So my timer is working, I'm seeing the output in the console every second, however all variables  (except the timestamp which is created in the class) have the initial value of 0.0. Any idea how to solve ?</p>
","4795917","","4795917","","2020-03-15 13:15:54","2020-03-15 13:18:12","Accessing published vars from ObservedObjects inside a function","<swift><swiftui><combine><observedobject>","1","2","","","","CC BY-SA 4.0"
"60699070","1","60699115","","2020-03-16 00:37:20","","7","5330","<p>I have a method that returns a Future:</p>

<pre><code>func getItem(id: String) -&gt; Future&lt;MediaItem, Error&gt; {
  return Future { promise in
    // alamofire async operation
  }
}
</code></pre>

<p>I want to use it in another method and covert <code>MediaItem</code> to <code>NSImage</code>, which is a synchronous operation.  I was hoping to simply do a <code>map</code> or <code>flatMap</code> on the original Future but it creates a long Publisher that I cannot erased to <code>Future&lt;NSImage, Error&gt;</code>.</p>

<pre><code>func getImage(id: String) -&gt; Future&lt;NSImage, Error&gt; {
  return getItem(id).map { mediaItem in
    // some sync operation to convert mediaItem to NSImage
    return convertToNSImage(mediaItem)  // this returns NSImage
  }
}
</code></pre>

<p>I get the following error:</p>

<p><code>Cannot convert return expression of type 'Publishers.Map&lt;Future&lt;MediaItem, Error&gt;, NSImage&gt;' to return type 'Future&lt;NSImage, Error&gt;'</code></p>

<p>I tried using <code>flatMap</code> but with a similar error. I can <code>eraseToAnyPublisher</code> but I think that hides the fact that <code>getImage(id: String</code> returns a Future.</p>

<p>I suppose I can wrap the body of <code>getImage</code> in a future but that doesn't seem as clean as chaining and mapping.  Any suggestions would be welcome.</p>
","3845803","","","","","2021-04-16 23:43:58","Mapping Swift Combine Future to another Future","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"60702699","1","60704282","","2020-03-16 08:41:03","","6","835","<p><code>ContentView2</code> view is not refreshed when <code>model.value</code> changes, if <code>Model</code> conforms to <code>ObservableObject</code> directly instead of inheriting <code>SuperModel</code> then it works fine</p>

<pre><code>class SuperModel: ObservableObject {

}

class Model: SuperModel {
    @Published var value = """"
}

struct ContentView2: View {

    @ObservedObject var model = Model()

    var body: some View {
        VStack {
            Text(model.value)
            Button(""change value"") {
                self.model.value = ""\(Int.random(in: 1...10))""
            }
        }

    }
}
</code></pre>
","10208552","","","","","2020-03-16 10:40:03","View refreshing not triggered when ObservableObject is inherited in SwiftUI","<ios><swift><swiftui><combine>","3","2","","","","CC BY-SA 4.0"
"60711337","1","60712803","","2020-03-16 18:25:51","","1","1321","<p>Lets say I have a publisher like this:</p>

<pre><code>NotificationCenter.default.publisher(for: NSNotification.Name.NSManagedObjectContextObjectsDidChange)
  .map { notification in /.. do something ../}
</code></pre>

<p>how do I make it so that in my block, I stop the publisher from emitting? </p>

<p>I could make it a trymap and then throw an error. But it's so weird to have to throw just to indicate a lack of results (in this case, let's say a non relevant NSManagedObject change)</p>
","56952","","","","","2020-03-16 20:34:54","How to write publisher that conditionally publish?","<swift><combine>","3","1","","","","CC BY-SA 4.0"
"60715143","1","60715429","","2020-03-17 01:28:27","","4","488","<p>So I'm much more familiar with <code>RxSwift</code> than <code>Combine</code>. A good way I manage mutable/immutable interfaces is I do something like this in <code>RxSwift</code></p>

<pre><code>
protocol SampleStream {
   /// An immutable interface. 
   var streamInfo: Observable&lt;String?&gt; { get} 
}

protocol MutableSampleStream: SampleStream {
   /// A mutable interface. 
   func updateStream( _ val: String?)
}

func SampleStreamImpl: MutableSampleStream {

   // Returns the immutable version of the stream.
   // If I pass down SampleStream as a dependency, then nothing else can write to this stream.
   // When they subscribe, they immediately get a value though since it's a behavior subject. 
   var streamInfo: Observable&lt;String?&gt; {
      return streamInfoSubject.asObservable()
   }

   private var streamInfoSubject = BehaviorSubject&lt;String?&gt;(value: nil) 

   func updateStream { }
}

</code></pre>

<p>How can I do something similar using <code>Combine</code>? Combine's <code>currentValueSubject</code> doesn't appear to have a way to cast this down to a non-read write version. Or am I missing something? </p>

<p>In my app, I don't want to directly pass down a <code>currentValueSubject</code> since I know for a fact I only want this stream updated from one place. Everywhere else should just read from the stream and not have write capability. </p>
","9718260","","","","","2020-03-17 02:20:08","How can I cast a currentValueSubject to non-mutable observable?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"60721207","1","60730608","","2020-03-17 11:12:15","","2","2500","<p>I use Combine in viewModels to update the views. But if I store the AnyCancellable objects into a set of AnyCancellable, the deinit method is never called. I use the deinit to cancel all cancellables objects.</p>

<pre><code>struct View1: View {

    @ObservedObject var viewModel:ViewTextModel = ViewTextModel()
    @Injected var appActions:AppActions

    var body: some View {
        VStack {
            Text(self.viewModel.viewText)

            Button(action: {
                self.appActions.goToView2()
            }) {
                Text(""Go to view \(self.viewModel.viewText)"")
            }
        }
    }
}
</code></pre>

<pre><code>class ViewTextModel: ObservableObject {
    @Published var viewText: String

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(state:AppState) {
        // initial state
        viewText = ""view  \(state.view)""
        // updated state
        state.$view.removeDuplicates().map{ ""view \($0)""}.assign(to: \.viewText, on: self).store(in: &amp;cancellables)
    }

    deinit {
        cancellables.forEach { $0.cancel() }
    } 
}
</code></pre>

<p>Each time the view is rebuilt, a new viewmodel is instantiated but the old one is not destroyed. <code>viewText</code> attribute is updated on each instance with <code>state.$view.removeDuplicates().map{ ""view \($0)""}.assign(to: \.viewText, on: self).store(in: &amp;cancellables)</code></p>

<p>If I don't store the cancellable object in the set, <code>deinit</code> is called but <code>viewText</code> is not updated if the state's changed for the current view.</p>

<p>Do you have an idea of ​​how to manage the update of the state without multiplying the instances of the viewmodel ?</p>

<p>Thanks</p>
","8649394","","","","","2021-10-20 13:18:00","How to deinit ViewModel with combine framework when views disappears","<swiftui><state><viewmodel><combine><deinit>","1","2","1","","","CC BY-SA 4.0"
"60721533","1","","","2020-03-17 11:31:33","","0","234","<p>This is for MacOS. I am trying to encapsulate a Timer publisher into a class so I can have added functionality that is self contained. I have the following code</p>

<pre><code>
import Combine


class MyTimer{
    let subscription: AnyCancellable
    var count: Int = 0

    init(){
       subscription = Timer.publish(every:0.1,on:.main,in:.default).autoconnect()
          .sink{_ in
             self.count += 1
             print(self.count)
         }
    }

    deinit {
        subscription.cancel()     
        print(""done"")
    }

}

</code></pre>

<p>The class is called like so:</p>

<pre><code>let timer = MyTimer()
</code></pre>

<p>And stopped by setting the timer to <code>nil</code>.</p>

<p>Unfortunately I get the </p>

<blockquote>
  <p>'self' captured by a closure before all members were initialized </p>
</blockquote>

<p>error. If I remove the <code>count</code> bit in sink it works fine. I tried moving the <code>init</code> contents to a <code>start()</code> method and that worked but <code>deinit()</code> was never called when timer was set to <code>nil</code>. I am currently using a global for count as a work around but that isn't very satisfactory as more code will go into this class. Any hints how I can do this? I have looked at a few other similar questions but none seem to be relevant. Thanks!</p>
","2234184","","4667835","","2020-03-17 12:15:02","2020-03-17 12:34:22","'self' captured by a closure before all members were initialized error in Timer Publisher","<swift><closures><combine>","1","4","","","","CC BY-SA 4.0"
"60722806","1","60724483","","2020-03-17 12:51:37","","1","283","<p>I'm looking for a way of observing <code>@State</code> or <code>@Binding</code> value changes in <code>onReceive</code>. I can't make it work, and I suspect it's not possible, but maybe there's a way of transforming them to <code>Publisher</code> or something while at the same time keeping the source updating value as it's doing right now?</p>

<p>Below you can find some context why I need this:</p>

<p>I have a parent view which is supposed to display half modal based on this library: <a href=""https://github.com/AndreaMiotto/PartialSheet"" rel=""nofollow noreferrer"">https://github.com/AndreaMiotto/PartialSheet</a></p>

<p>For this purpose, I've created a <code>@State private var modalPresented: Bool = false</code> and I'm using it to show and hide this modal view. This works fine, but my parent initializes this modal immediately after initializing self, so I completely loose the <code>onAppear</code> and <code>onDisappear</code> modifiers. The problem is that I need <code>onAppear</code> to perform some data fetching every time this modal is being presented (ideally I'd also cancel network task when modal is being dismissed).</p>
","1911042","","","","","2020-03-17 14:33:27","Observing Binding or State variables","<ios><swift><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"60726007","1","","","2020-03-17 16:02:22","","-1","957","<p>Currently I have the code below which I'm trying to use as a navigation switch so I can navigate through different views without using the crappy NavigationLinks and otherwise. I'm by default a WebDev, so I've been having a mountain of issues transferring my knowledge over to Swift, the syntax feels completely dissimilar to any code I've written before. Anyways, here's the code;</p>

<pre><code>import Foundation
import Combine
import SwiftUI

class ViewRouter: ObservableObject {
    let objectWillChange: PassthroughSubject&lt;ViewRouter,Never&gt;

    @Published var currentPage: String = ""page1"" {
        didSet {
            objectWillChange.send(self)
        }
    }

    init(currentPage: String) {
        self.currentPage = currentPage
    }

}
</code></pre>

<p>As you can see, it's really simple, and I just use the object to switch values and display different views on another file, the only errors which prevent me from building it is the fact that the initializer is saying ""Return from initializer without initializing all stored properties"", even though the only variable is the currentPage variable which is defined. I know it's saying that objectWillChange is not defined by the message, but objectWillChange doesn't have any value to be assigned. Any help would be appreciated.</p>
","12422326","","","","","2020-03-17 20:58:14","Swift: ObservableObject, initializer doesn't define all properties?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"60730835","1","","","2020-03-17 21:59:03","","0","394","<p>I have a <code>ObservableObject</code> that I use to update my UI when new data is sent from the server (an a class which contains an array of custom structs).</p>

<p>For some reason, when the data is sent, the <code>ContentView</code>'s <code>body</code> is called, but the data isn't changed. I even added a <code>print</code> statement to check if the data that the array contains is right and it is.</p>

<p>When I try to switch to another tab on my <code>TabView</code>, and then switch back to the main view, the UI <strong>does</strong> get updated. Does anybody know why the UI updates just when I switch tabs, although the <code>body</code> gets recalled to update the UI when the data changed?</p>

<p><strong>HomeView</strong></p>

<pre><code>struct HomeView: View {
    @ObservedObject private var fbData = firebaseData

    var body: some View {
        TabView {
            //Home Tab
            NavigationView {
                ScrollView(showsIndicators: false) {
                    ForEach(self.fbData.posts.indices, id: \.self) { postIndex in
                        PostView(post: self.$fbData.posts[postIndex])
                            .listRowInsets(EdgeInsets())
                            .padding(.vertical, 5)
                    }
                }
                .navigationBarTitle(""MyPhotoApp"", displayMode: .inline)
                .navigationBarItems(leading:
                    Button(action: {
                        print(""Camera btn pressed"")
                    }, label: {
                        Image(systemName: ""camera"")
                            .font(.title)
                    })
                , trailing:
                    Button(action: {
                        print(""Messages btn pressed"")
                    }, label: {
                        Image(systemName: ""paperplane"")
                            .font(.title)
                    })
                )
            } . tabItem({
                Image(systemName: ""house"")
                    .font(.title)
            })

            Text(""Search"").tabItem {
                Image(systemName: ""magnifyingglass"")
                    .font(.title)
            }

            Text(""Upload"").tabItem {
                Image(systemName: ""plus.app"")
                    .font(.title)
            }

            Text(""Activity"").tabItem {
                Image(systemName: ""heart"")
                    .font(.title)
            }

            Text(""Profile"").tabItem {
                Image(systemName: ""person"")
                    .font(.title)
            }
        }
        .accentColor(.black)
        .edgesIgnoringSafeArea(.top)
    }
}
</code></pre>

<p><strong>FirebaseData</strong>:</p>

<pre><code>class FirebaseData : ObservableObject {
    @Published var posts = [Post]()

    let postsCollection = Firestore.firestore().collection(""Posts"")

    init() {
        self.fetchPosts()
    }

    //MARK: Fetch Data
    private func fetchPosts() {
        self.postsCollection.addSnapshotListener { (documentSnapshot, err) in
            if err != nil {
                print(""Error fetching posts: \(err!.localizedDescription)"")
                return
            } else {
                documentSnapshot!.documentChanges.forEach { diff in
                    if diff.type == .added {
                        let post = self.createPostFromDocument(document: diff.document)
                        self.posts.append(post)
                    } else if diff.type == .modified {
                        self.posts = self.posts.map { (post) -&gt; Post in
                            if post.id == diff.document.documentID {
                                return self.createPostFromDocument(document: diff.document)
                            } else {
                                return post
                            }
                        }
                    } else if diff.type == .removed {
                        for index in self.posts.indices {
                            if self.posts[index].id == diff.document.documentID {
                                self.posts.remove(at: index)
                            }
                        }
                    }
                }
            }
        }
    }
</code></pre>
","8421180","","8421180","","2020-03-18 10:21:51","2020-03-19 04:06:40","UI changes with ObservableObject just after switching tabs","<ios><swift><iphone><swiftui><combine>","2","13","","","","CC BY-SA 4.0"
"60732790","1","60733341","","2020-03-18 02:40:11","","0","33","<p>Is it acceptable for a pipeline of publishers to have consumers subscribe to the different parts of the chain? </p>

<p>In theory the subscribers can do processing and filtering in its own pipeline. But I find that having a 'ready made' publisher makes it easy for the consumer. I see that this is not the pattern generally used for Combine. Is there a downside to this that I am missing?</p>

<pre><code>import UIKit
import Combine

class Publisher {
    var rootPublisher = [1, 2, 3, 4, 5].publisher
    var evenPublisher: AnyPublisher&lt;Int, Never&gt;

    init () {
        evenPublisher = rootPublisher.filter { num in num % 2 == 0 }.eraseToAnyPublisher()
    }
}

class Consumer {
    let publisher = Publisher()
    func numbers () {
        publisher.rootPublisher.sink { int in
            print(int)
        }
    }
    func evenNumbers() {
        publisher.evenPublisher.sink { int in
            print(int)
        }
    }
}

Consumer().numbers()
Consumer().evenNumbers()
</code></pre>
","56952","","2322778","","2020-03-18 03:26:36","2020-03-18 04:03:07","Is it appropriate to have different layers of Publishers for different subscribers?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"60740197","1","60748919","","2020-03-18 13:03:14","","1","339","<p>I'm trying to build an Instagram clone app using SwiftUI.</p>

<p>I'm fetching the data through <code>Firebase</code> and trying to achieve a UI update every time the data in the server changes.</p>

<p>For some reason, when I first open the app and fetch the data, the <code>body</code> of my view gets called, but the UI doesn't change. I even put a breakpoint and saw the <code>body</code> gets called and contains the correct information, it's just the UI which doesn't get updated.</p>

<p>I have a few tabs in my app, and when I switch to another tab (which doesn't contain anything but a <code>Text</code> yet), suddenly the UI <strong>does</strong> gets updated.</p>

<p>Please see the gif below:</p>

<p><a href=""https://i.stack.imgur.com/ji4WT.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ji4WT.gif"" alt=""gif""></a></p>

<p>Here is my code:</p>

<p><strong>HomeView</strong>:</p>

<pre><code>struct HomeView: View {
    @ObservedObject private var fbData = firebaseData

    var body: some View {
        TabView {
            //Home Tab
            NavigationView {
                ScrollView(showsIndicators: false) {
                    ForEach(self.fbData.posts.indices, id: \.self) { postIndex in
                        PostView(post: self.$fbData.posts[postIndex])
                            .listRowInsets(EdgeInsets())
                            .padding(.vertical, 5)
                    }
                }
                .navigationBarTitle(""Instagram"", displayMode: .inline)
                .navigationBarItems(leading:
                    Button(action: {
                        print(""Camera btn pressed"")
                    }, label: {
                        Image(systemName: ""camera"")
                            .font(.title)
                    })
                , trailing:
                    Button(action: {
                        print(""Messages btn pressed"")
                    }, label: {
                        Image(systemName: ""paperplane"")
                            .font(.title)
                    })
                )
            } . tabItem({
                Image(systemName: ""house"")
                    .font(.title)
            })

            Text(""Search"").tabItem {
                Image(systemName: ""magnifyingglass"")
                    .font(.title)
            }

            Text(""Upload"").tabItem {
                Image(systemName: ""plus.app"")
                    .font(.title)
            }

            Text(""Activity"").tabItem {
                Image(systemName: ""heart"")
                    .font(.title)
            }

            Text(""Profile"").tabItem {
                Image(systemName: ""person"")
                    .font(.title)
            }
        }
        .accentColor(.black)
        .edgesIgnoringSafeArea(.top)
    }
}
</code></pre>

<p><strong>FirebaseData</strong>:</p>

<pre><code>let firebaseData = FirebaseData()

class FirebaseData : ObservableObject {
    @Published var posts = [Post]()

    let postsCollection = Firestore.firestore().collection(""Posts"")

    init() {
        self.fetchPosts()
    }

    //MARK: Fetch Data
    private func fetchPosts() {
        self.postsCollection.addSnapshotListener { (documentSnapshot, err) in
            if err != nil {
                print(""Error fetching posts: \(err!.localizedDescription)"")
                return
            } else {
                documentSnapshot!.documentChanges.forEach { diff in
                    if diff.type == .added {
                        let post = self.createPostFromDocument(document: diff.document)
                        self.posts.append(post)
                    } else if diff.type == .modified {
                        self.posts = self.posts.map { (post) -&gt; Post in
                            if post.id == diff.document.documentID {
                                return self.createPostFromDocument(document: diff.document)
                            } else {
                                return post
                            }
                        }
                    } else if diff.type == .removed {
                        for index in self.posts.indices {
                            if self.posts[index].id == diff.document.documentID {
                                self.posts.remove(at: index)
                            }
                        }
                    }
                }
            }
        }
    }

    private func createPostFromDocument(document: QueryDocumentSnapshot) -&gt; Post {
        let data = document.data()

        let id = document.documentID
        let imageUrl = data[""imageUrl""] as! String
        let authorUsername = data[""authorUsername""] as! String
        let authorProfilePictureUrl = data[""authorProfilePictureUrl""] as! String
        let postLocation = data[""postLocation""] as! String
        let postDescription = data[""postDescription""] as! String
        let numberOfLikes = data[""numberOfLikes""] as! Int
        let numberOfComments = data[""numberOfComments""] as! Int
        let datePosted = (data[""datePosted""] as! Timestamp).dateValue()
        let isLiked = data[""isLiked""] as! Bool

        return Post(id: id, imageUrl: imageUrl, authorUsername: authorUsername, authorProfilePictureUrl: authorProfilePictureUrl, postLocation: postLocation, postDescription: postDescription, numberOfLikes: numberOfLikes, numberOfComments: numberOfComments, datePosted: datePosted, isLiked: isLiked)
    }
}
</code></pre>

<p>If you need me to post more code please let me know.</p>

<p>Update:</p>

<p><strong>PostView</strong>:</p>

<pre><code>struct PostView: View {
    @Binding var post: Post

    var body: some View {
        VStack(alignment: .leading) {
            //Info bar
            HStack {
                WebImage(url: URL(string: post.authorProfilePictureUrl))
                    .resizable()
                    .frame(width: 40, height: 40)
                    .clipShape(Circle())

                VStack(alignment: .leading, spacing: 2) {
                    Text(post.authorUsername).font(.headline)
                    Text(post.postLocation)
                }

                Spacer()

                Button(action: {
                    print(""More options pressed"")
                }, label: {
                    Image(systemName: ""ellipsis"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())
            }
            .padding(.horizontal)

            //Main Image
            WebImage(url: URL(string: post.imageUrl))
              .resizable()
              .aspectRatio(contentMode: .fit)

            //Tools bar
            HStack(spacing: 15) {
                Button(action: {
                    self.post.isLiked.toggle()
                    print(""Like btn pressed"")
                }, label: {
                    Image(systemName: post.isLiked ? ""heart.fill"" : ""heart"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())

                Button(action: {
                    print(""Comments btn pressed"")
                }, label: {
                    Image(systemName: ""message"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())

                Button(action: {
                    print(""Share btn pressed"")
                }, label: {
                    Image(systemName: ""paperplane"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())

                Spacer()

                Button(action: {
                    print(""Bookmark btn pressed"")
                }, label: {
                    Image(systemName: ""bookmark"")
                        .font(.title)
                        .foregroundColor(.black)
                }).buttonStyle(BorderlessButtonStyle())
            }.padding(8)

            Text(""Liked by \(post.numberOfLikes) users"")
                .font(.headline)
                .padding(.horizontal, 8)

            Text(post.postDescription)
                .font(.body)
                .padding(.horizontal, 8)
                .padding(.vertical, 5)

            Button(action: {
                print(""Show comments btn pressed"")
            }, label: {
                Text(""See all \(post.numberOfComments) comments"")
                    .foregroundColor(.gray)
                    .padding(.horizontal, 8)
            }).buttonStyle(BorderlessButtonStyle())

            Text(post.datePostedString)
                .font(.caption)
                .foregroundColor(.gray)
                .padding(.horizontal, 8)
                .padding(.vertical, 5)
        }
    }
}
</code></pre>

<p><strong>Post</strong>:</p>

<pre><code>struct Post : Identifiable, Hashable {
    var id: String
    var imageUrl: String
    var authorUsername: String
    var authorProfilePictureUrl: String
    var postLocation: String
    var postDescription: String
    var numberOfLikes: Int
    var numberOfComments: Int
    var datePostedString: String

    var isLiked: Bool

    init(id: String, imageUrl: String, authorUsername: String, authorProfilePictureUrl: String, postLocation: String, postDescription : String, numberOfLikes: Int, numberOfComments: Int, datePosted: Date, isLiked: Bool) {
        self.id = id
        self.imageUrl = imageUrl
        self.authorUsername = authorUsername
        self.authorProfilePictureUrl = authorProfilePictureUrl
        self.postLocation = postLocation
        self.postDescription = postDescription
        self.numberOfLikes = numberOfLikes
        self.numberOfComments = numberOfComments

        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = ""MMMM dd, yyyy""
        self.datePostedString = dateFormatter.string(from: datePosted)

        self.isLiked = isLiked
    }
}
</code></pre>

<p>Thank you!</p>
","8421180","","8421180","","2020-03-18 15:04:02","2020-03-18 23:46:54","View doesn't get updated when using ObservableObject","<ios><swift><iphone><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"60768004","1","","","2020-03-20 03:05:17","","1","1412","<p>I have been using swiftUI lately to build an application that has a feature to display images downloaded from the web. I tried to make it work but I am having trouble with it right now. I think Maybe there is maybe something wrong with ImageFetcher.swift? Can anyone help me out? Here is my code:</p>

<p><strong>ImageFetcher.swift :</strong></p>

<pre><code>import Foundation
import Combine
import SwiftUI

class ImageFetcher: ObservableObject {
var didChange = PassthroughSubject&lt;Data, Never&gt;()

var data: Data = Data() {
    didSet {
        didChange.send(data)
    }
}

init(url: String) {
    guard let imageUrl = URL(string: url) else {
        return
    }

    URLSession.shared.dataTask(with: imageUrl) { (data, _, _) in
        guard let data = data else { return }
        DispatchQueue.main.async { [weak self] in
            self?.data = data
        }

    }.resume()
}
}
</code></pre>

<p><strong>LoadableImageView.swift :</strong></p>

<pre><code>import SwiftUI

struct LoadableImageView: View {
@ObservedObject var imageFetcher: ImageFetcher

var stateContent: AnyView {
    if let image = UIImage(data: imageFetcher.data) {
        return AnyView(
            Image(uiImage: image).resizable()
        )
    } else {
        return AnyView(
            ActivityIndicator(style: .medium)
        )
    }
}

init(with urlString: String) {
    imageFetcher = ImageFetcher(url: urlString)
}

var body: some View {
    HStack {
        stateContent
    }
}
}

struct LoadableImageView_Previews : PreviewProvider {
static var previews: some View {
    LoadableImageView(with: ""https://is2-ssl.mzstatic.com/image/thumb/Music113/v4/3d/6d/d0/3d6dd00b-b480-740f-bc6e-e2ca78ff918e/190296882920.jpg/200x200bb.png"")
}
}
</code></pre>

<p><strong>ListCellView.swift :</strong></p>

<pre><code>import SwiftUI
import Foundation
import AlamofireImage
import Alamofire
import Combine


struct ListCellView: View {


@State var dataSource = DataSource()
var viewModel: RestrauntListViewModel
var imageLoader = ImageLoader()

var body: some View {
    HStack {

        LoadableImageView(with: viewModel.imageURL.absoluteString)

        Spacer()
        VStack(alignment: .center, spacing: 1.0) {
            Text(viewModel.name)

            Image(dataSource.configureRatings(rating: viewModel.rating))
            Text(""\(viewModel.formattedDistance) miles"")
        }
        .padding(.all)
        Spacer()
    }
}
}
struct ListCellView_Previews: PreviewProvider {

static var previews: some View {
    ListCellView(viewModel: RestrauntListViewModel(name: ""in 3nout"", imageURL: URL(string: ""https://s3-media2.fl.yelpcdn.com/bphoto/FNYCY1myO6qlqXLTpGPyIA/o.jpg"")!, distance: 4.94578764532, id: ""34526434"", rating: 4))
}
}
</code></pre>
","","user10081458","4667835","","2020-03-20 12:30:08","2020-03-20 12:30:08","How do I show a Image from the web in swiftui?","<swift><image><download><swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"60780545","1","","","2020-03-20 19:33:07","","0","98","<p>I'm working with <code>Property wrappers</code> in a project that is divided into few <code>Swift package</code> modules dependent on each others. I have been using my own property wrappers in the code, but I want to switch to <code>Combine</code>, as it contains a lot of similar functionalities to my own <code>property wrappers</code>. In the process of converting I often occur the compiler issue:</p>

<p><code>Abort trap: 6</code> with error message: <code>Global is external, but doesn't have external or weak linkage!</code>. </p>

<p>As the first step I have decided to get rid of this error while still using my own <code>property wrappers</code>, because it can occur even there, but I managed to get rid of it. But in not a clean way, and I would like to get more knowledge on what is going on, so I could proceed with <code>Combine</code> later - with the same errors.</p>

<p>Ok, so to get rid of the <code>Abort trap: 6</code> with my old <code>property wrappers</code> I needed to switch the way I used this property in some of modules. Instead of writing and reading it directly, I access it with $property.wrappedValue. Then it works, but this is very ugly in code, and kinda denies the puropse of using a <code>property wrapper</code>. Could someone explain me why this error occurs? In some of the modules Im able to use it directly with no problem. I have no idea what is going on, and what I can do to resolve this. I tried to convert a lot of similar properties with <code>Combine</code>, and I just get more of this errors, and actually I was not even able to resolve them like this. </p>

<p>Please tell me what is this error about, why it happens and what I can do to resolve it.
<a href=""https://i.stack.imgur.com/ENqZ0.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ENqZ0.jpg"" alt=""enter image description here""></a></p>

<p>If his helps, this is how this property wrapper is defined:</p>

<pre><code>@propertyWrapper
public class ObservableChangedValue&lt;Value: Equatable&gt;: Observable&lt;Value&gt; {

    public var projectedValue: ObservableChangedValue { self }

    public override var wrappedValue: Value {
        get { super.wrappedValue }
        set { super.wrappedValue = newValue }
    }

    override func shouldExecuteNotifications(oldValue: Value, newValue: Value) -&gt; Bool {
        oldValue != newValue
    }

}

public class Observable&lt;Value&gt; {

    public init(wrappedValue: Value) {
        self.wrappedValue = wrappedValue
    }

    internal var observations = [Observation&lt;Value&gt;]() { didSet { isBeingObserved = !observations.isEmpty } }

    public var wrappedValue: Value {
        didSet {
            guard shouldExecuteNotifications(oldValue: oldValue, newValue: wrappedValue) else { return }
            observations.forEach {
                $0.executeNotification(oldValue: oldValue, newValue: wrappedValue)
            }
        }
    }

    public weak var delegate: ObservableDelegate?

    public var isBeingObserved = false {
        didSet {
            guard isBeingObserved != oldValue else { return }
            delegate?.isBeingObservedChanged(isBeingObserved)
        }
    }

    internal func shouldExecuteNotifications(oldValue: Value, newValue: Value) -&gt; Bool { true }

}
</code></pre>

<p>One big thing - I have noticed that the error only occurs when I access this variable from other file than where it was defined. I added getters and setters for now, but still not a nice solution. This seems to be a compiler error, but Im not sure.</p>
","4528716","","3943125","","2020-03-20 20:48:55","2020-03-21 14:21:23","PropertyWrapper - Global is external, but doesn't have external or weak linkage","<swift><properties><combine>","1","5","","","","CC BY-SA 4.0"
"60780725","1","60785254","","2020-03-20 19:46:23","","3","1194","<p>I am trying to use the iOS 13 Combine framework in conjunction with some UIKit controls. I want to set up a viewcontroller that contains a switch that enables/disables a button whenever the switch is toggled on/off. According to Apple's documentation, UIKit controls have built-in support for Combine publishers, etc. so this should be possible.</p>

<p>I have a viewcontroller that contains a UISwitch and a UIButton, as shown here:</p>

<p><a href=""https://i.stack.imgur.com/Mf4qG.png"" rel=""nofollow noreferrer"">link to screenshot of my viewcontroller</a></p>

<p>and here is my code:</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine
import UIKit

class ViewController: UIViewController {

    @IBOutlet weak var mySwitch: UISwitch!
    @IBOutlet weak var myButton: UIButton!

    var myCancellable: AnyCancellable?

    override func viewDidLoad() {
        super.viewDidLoad()

        mySwitch.isOn = true // Set initial state of switch

        myButton.setTitle(""Enabled"", for: .normal)
        myButton.setTitle(""Disabled"", for: .disabled)

        myCancellable = mySwitch.publisher(for: \.isOn)
                                .subscribe(on: RunLoop.main)
                                .assign(to: \.isEnabled, on: myButton)
    }
}
</code></pre>

<p>The above code should (or so I thought) emit the value of the switch's <code>.isOn</code> property, whenever that property changes, and assign the value to the button's <code>.isEnabled</code> property. If it is running the way I would expect, that means that when the switch is toggled ON the button title should read ""Enabled"" and the button should be enabled. When the UISwitch is toggled OFF, then the button title should read ""Disabled"" and the button should be disabled.</p>

<p>But it does not behave the way I am expecting. The value from the switch's publisher is only emitted once, when the publisher is first set up inside <code>viewDidLoad()</code>. When tapping on the switch to toggle it on or off, it never emits a value ever again. I can tell it is at least emitting the value once, because if I change the initial state of the switch to either on or off, the button is set to the expected state when the viewcontroller is loaded.</p>

<p>Typically you are supposed to keep a strong reference to the publisher, or else the publisher/subscriber will be terminated immediately, so that's why I am holding a reference with the <code>myCancellable</code> variable. But this does not fix the issue, the values are still not emitted when tapping on the switch.</p>

<p>Does anyone have any ideas on how to fix this?  This seems like it should be a simple ""Hello World"" type of example using Combine, and I don't know what I am missing here.</p>
","9196483","","","","","2020-03-21 07:08:13","iOS Combine Framework - Publisher Only Publishes Once and Then Never Again","<ios><swift><reactive-programming><combine>","1","0","1","","","CC BY-SA 4.0"
"60781658","1","60782044","","2020-03-20 21:09:20","","0","51","<p>so I have this file which gets a JSON array from an api endpoint, then is supposed to assign it to an observable object variable so it can be retrieved and iterated through in a foreach loop. I'm still really new to Swift but it looks as so;</p>

<pre><code>import SwiftUI
import Combine
import Foundation

public struct ActivityModel: Codable {
    public let id: Int
    public let name: String
    public let activity_desc: String?
}


public struct ActivitiesModel2: Codable {
    public let location: String
    public let popular: [String:ActivityModel]
}

public struct ActivitiesModel: Codable {
    public let activities: ActivitiesModel2
}

public class ActivityFetcher: ObservableObject {
    var activities: [ActivitiesModel]()

    init(){
        guard let url = URL(string: ""http://mywebsite.com/api/loadapi"") else { return }

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = ""POST""

        URLSession.shared.dataTask(with: urlRequest) { (data, response, error) in

            do {
                if let d = data {
                    let decodedLists = try JSONDecoder().decode(ActivitiesModel.self, from: d)
                    DispatchQueue.main.async {
                        self.activities = [decodedLists]
                    }
                    print(self.activities)
                    print(decodedLists)
                } else {
                    print(""No Data"")
                }
            } catch {
                print(""Error"")
            }

        }.resume()
    }
}
</code></pre>

<p>The code works fine up to the point where I try to equate self.activities to decodedLists, because while printing decodedLists returns the correct array from the JSON API, printing self.activities after I define it as equal to decodedLists only returns: ""[]"". Why it returns an empty array when it is clearly defined when printing decodedLists is beyond me. I tried removing the brackets, thinking maybe it's converting a dictionary to an array and failing, but I can't remove any of the brackets without returning an error.</p>
","12422326","","","","","2020-03-20 21:48:17","Swift, issue assigning array to variable","<arrays><swift><dictionary><combine>","1","1","","","","CC BY-SA 4.0"
"60790382","1","","","2020-03-21 16:33:23","","0","62","<p>I am trying to build an application which receives a JSON Object from an API endpoint, which then I want to list out in the view. I've watched a lot of videos on this topic, but in each video they use very simplistic JSON Objects as examples and therefore the code they write doesn't really seem to transfer over, giving me errors no matter how I try to format it. The code is as follows</p>

<pre><code>import SwiftUI
import Combine
import Foundation

public struct ActivityModel: Codable, Identifiable {
    public let id: Int
    public let name: String
    public let activity_desc: String?
}


public struct ActivitiesModel2: Codable {
    public let location: String
    public let popular: [String:ActivityModel]
}

public struct ActivitiesModel: Codable {
    public let activities: ActivitiesModel2
}

public class ActivityFetcher: ObservableObject {
    var activities: ActivitiesModel?

    init(){
        guard let url = URL(string: ""https://mywebsite.com/api/loadapi"") else { return }

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = ""POST""

        URLSession.shared.dataTask(with: urlRequest) { (data, response, error) in

            do {
                if let d = data {
                    let decodedLists = try JSONDecoder().decode(ActivitiesModel.self, from: d)
                    DispatchQueue.main.async {
                        self.activities = decodedLists
                    }
                } else {
                    print(""No Data"")
                }
            } catch {
                print(""Error"")
            }

        }.resume()
    }
}

struct ActivityGuestView: View {
    let networkingServiceGeneral = NetworkingServiceGeneral()

    @ObservedObject var viewRouter: ViewRouter

    @ObservedObject var fetcher = ActivityFetcher()

    var body: some View {
        // This is where my issues start
        List(fetcher.activities?.activities.popular) { result in
            VStack {
                Text(result.name)
                Text(result.activity_desc)
                    .font(.system(size: 11))
                    .foregroundColor(Color.gray)
            }
        }
    }
}
</code></pre>

<p>This code, as I put it, gives me 5 errors. They are the following;</p>

<pre><code>    - Initializer 'init(_:rowContent:)' requires that '(key: String, value: ActivityModel)' conform to Identifiable
    - Initializer 'init(_:rowContent:)' requires that '[String : ActivityModel]' conform to 'RandomAccessCollection'
    -Value of optional type '[String : ActivityModel]?' must be unwrapped to a value of type '[String : ActivityModel]'
    - Coalesce using '??' to provide a default when the optional value contains 'nil'
    - Force-unwrap using '!' to abort execution if the optional value contains 'nil'
</code></pre>

<p>Some of these errors have options to fix it, but when I press fix it adds code but doesn't actually fix the error so I figured to just include them anyways. I'm still fairly new to Swift, but I know what some of it is asking, particularly the conforming to Identifiable, but it says that struct ActivitiesModel does not conform to identifiable when I try to add the tag, and the JSON Object doesn't have an ID for that section, so I can't ask the ID to make it identifiable.</p>

<p>Any help would be greatly appreciated, this has kind of been a wall right now.</p>

<p>EDIT: Here's the JSON</p>

<pre><code>""activities"": {
        ""location"": ""Dallas"",
        ""popular"": {
            ""10"": {
                ""id"": 38,
                ""name"": ""Adventure Landing Dallas"",
                ""activity_desc"": ""Aquatic complex chain with additional land attractions including mini-golf, laser tag &amp; go-karts."",
            },
            ""12"": {
                ""id"": 40,
                ""name"": ""Jumpstreet"",
                ""activity_desc"": ""None provided."",
            },
        }
    }
}
</code></pre>
","6611009","","6611009","","2020-03-23 00:44:15","2020-03-23 00:44:15","Swift Issue Listing out a Dynamic Dictionary from JSON","<json><swift><combine>","0","3","","","","CC BY-SA 4.0"
"60792028","1","60792635","","2020-03-21 18:56:57","","0","66","<p>For an instance as below example JSON data, I want to keep the object which has content &amp; video property, and ignore the ones doesn't have them. Objects like 2nd, 3rd with only address and error property should be ignored.</p>

<p><strong>/ / JSON data example</strong></p>

<pre><code>[
  {
    ""content"": ""asdhh"",
    ""url"": ""dasddd"",
    ""country"": ""kkjkkj"",
    ""address"": ""aksjdkasjd""
  },
  {
    ""address"": ""aabbccdd""
  },
  {
    ""error"": ""error description""
  }
]
</code></pre>

<p>I try to use <code>if video.content != nil &amp;&amp; video.url != nil</code> to control the displaying of VideoListRow in ForEach loop. But it turns out that I couldn't call the video.property in the ForEach closure. So how could I ignore the unwanted parsed back data and only show the wanted object, in this case only the first object was wanted. </p>

<pre><code>var body: some View {
        List {
            ForEach(self.model.videos) { video in
                if video.content != nil &amp;&amp; video.url != nil {
                  VStack(spacing: 0) {
                      VideoListRow(video: url)
                  }
                }
            }
        }.onAppear() {
            self.model.getVideoBundle()
        }
    }
</code></pre>

<p><strong>// Change my code to add filter:</strong>
The minor modification is to use <code>||</code> but not <code>&amp;&amp;</code>. Because I want to keep the object, which has only one of content and url, that one is valid. Only if it doesn't include two of them, then ignore it.</p>

<pre><code>ForEach(
    self.model.videos.filter { (video) -&gt; Bool in
        video.content != nil || video.url != nil
    }
) { video in
    VStack(spacing: 0) {
        VideoListRow(video: url)
    }
}
</code></pre>
","10158398","","10158398","","2020-03-22 02:25:56","2020-03-22 02:25:56","How to ignore some objects in JSON parsed back data?","<json><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60795062","1","60805267","","2020-03-22 01:26:55","","-1","307","<p>I just implemented multiple windows in my app and am having trouble checking when a core data item was updated in the window right next to it. It seems like Apple's Combine can fix this problem by adding a subscriber to the core data item to listen for changes, but all the documentation I'm finding on Combine is with SwiftUI and I'm using UIKit. </p>

<p>Can anyone help me add a subscriber to the core data item listen for any changes to it?</p>
","8203300","","","","","2020-03-22 21:37:48","How to use Combine to tell when a Core Data object changed","<swift><xcode><core-data><combine>","1","0","1","","","CC BY-SA 4.0"
"60799509","1","60808062","","2020-03-22 12:49:02","","3","5910","<p>I don't know how to deal with errors in a Combine flow. I would like to be able to catch errors from a Combine function. </p>

<p><strong>Could anyone help in explaining what I'm doing wrong here and how I should handle <em>catching</em> an error with Combine?</strong></p>

<blockquote>
  <p>Note: The function below is just an example to illustrate a case where an error <em>could</em> be caught instead of crashing the app.</p>
</blockquote>

<pre><code>func dataFromURL&lt;T: Decodable&gt;(_ url: String, _ decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;T, Error&gt; {
    // 1) Example: If the URL is not well-formatted, I would like to /create/raise/return an error (in a Combine way)

    // 2) Instead of the forced unwrapping here, I would also prefer to raise a catchable error if the creation of the request fails
    let request = URLRequest(url: URL(string:url)!)

    // 3) Any kind of example dealing with potential errors, etc

    return urlSession
        .dataTaskPublisher(for: request)
        .tryMap { result -&gt; T in
            return try decoder.decode(T.self, from: result.data)
        }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
} 

// function in another file:
func result() {
     // I would like to be able to catch or handle errors in this function

     dataFromURL(""test"").print()   

    // Example : if error 1), else if error 2) etc
}
</code></pre>

<p>As explained in the comments, I would like to be able to catch any error outside the <code>dataFromURL</code> function, but in a ""Combine way"". </p>

<p>I used a URL data fetching as an example, but it could be with anything else.</p>

<p>What is the recommended way to raise and catch errors with the Combine flow? Is it to return a Publisher with a specific error for example? If so, how can I do it?</p>

<hr>

<p><strong>EDIT</strong></p>

<p>Without Combine, I would just have thrown an error, added the <code>throws</code> keyword to the function, and would have caught the error in the <code>result</code> function. </p>

<p>But I would have expected Combine to have a simpler or more elegant way to achieve this. For example, maybe something that can be thrown at any time:</p>

<pre><code>guard &lt;url is valid&gt; else {
    return PublisherError(URLError.urlNotValid)
}
</code></pre>

<p>And could have been caught like this:</p>

<pre><code>dataFromURL
.print()
.onError { error in
   // handle error here
}
.sink { result in
    // no error
}
</code></pre>
","5120292","","814730","","2020-03-22 16:39:41","2020-03-23 04:45:58","Handling errors in Combine (Swift, iOS)","<ios><swift><combine>","1","6","2","","","CC BY-SA 4.0"
"60809670","1","","","2020-03-23 07:53:11","","1","518","<p>SwiftUI seems to me more and more confusing in the way it works. 
At first glance it seams fast and easy to grasp. But if you add more and more views
something that seems to be simple starts to behave very odd and take many time to solve. </p>

<p>I have <code>Input</code> field with validation. This is customized input with that I can reuse in many places. But on different screens this can work totally different and totally unreliable. </p>

<p><strong>View with form</strong> </p>

<pre><code>struct LoginView { 

@ObservedObject private var viewModel = LoginViewModel()

var body: some View { 
VStack(spacing: 32) {

                    Spacer()

                    LabeledInput(label: ""Email"", input: self.$viewModel.email, isNuemorphic: true, rules: LoginFormRules.email, validation: self.$viewModel.emailValidation)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)
                    .autocapitalization(.none)
                    .frame(height: 50)

                    LabeledInput(label: ""Password"", isSecure: true, input: self.$viewModel.password, isNuemorphic: true, rules: LoginFormRules.password, validation: self.$viewModel.passwordValidation)
                    .textContentType(.password)
                    .keyboardType(.asciiCapable)
                    .autocapitalization(.none)
                    .frame(height: 50)

                    self.makeSubmitButton()

                    Spacer()

                }
}
</code></pre>

<p><strong>LabeledInput - resuable custom input view with validation support</strong> </p>

<pre><code>struct LabeledInput: View {

    // MARK: - Properties
    let label: String?
    let isSecure: Bool

    // MARK: - Binding
    @Binding var input: String
    var isEditing: Binding&lt;Bool&gt;?

    // MARK: - Actions
    private let onEditingChanged: (Bool) -&gt; Void
    private let onCommit: () -&gt; Void

    // MARK: - Validation
    @ObservedObject var validator: FieldValidator&lt;String&gt;

    // MARK: - Init
    init(label: String? = nil,
         isSecure: Bool = false,
         input: Binding&lt;String&gt;,
         isEditing: Binding&lt;Bool&gt;? = nil,

         // validation
         rules: [Rule&lt;String&gt;] = [],
         validation: Binding&lt;Validation&gt;? = nil,

         // actions
         onEditingChanged: @escaping (Bool) -&gt; Void = { _ in },
         onCommit: @escaping () -&gt; Void = { }) {

        self.label = label
        self.isSecure = isSecure
        self._input = input
        self.isEditing = isEditing


        self.onEditingChanged = onEditingChanged
        self.onCommit = onCommit


        self.validator = FieldValidator(input: input, rules: rules, validation: validation ?? .constant(Validation()))
    }

    var useUIKit: Bool {
        self.isEditing != nil
    }

    var body: some View {

        GeometryReader { geometry in
            ZStack {


                    RoundedRectangle(cornerRadius: 4.0)
                    .stroke(lineWidth: 1)
                .foregroundColor(!self.validator.validation.isEdited ? Color(""LightGray"")
                    : self.validator.validation.isValid ? Color(""Green"") : Color(""Red""))
                    .frame(maxHeight: geometry.size.height)
                    .offset(x: 0, y: 16)


                VStack {
                    HStack {
                        self.makeLabel()
                            .offset(x: self.isNuemorphic ? 0 : 16,
                                    y: self.isNuemorphic ? 0 : 8)
                        Spacer()
                    }
                    Spacer()
                }

                self.makeField()
                .frame(maxHeight: geometry.size.height)
                    .offset(x: 0, y: self.isNuemorphic ? 20 : 16)
                .padding(10)
            }
        }

    }

    private func makeField() -&gt; some View {
        Group {
            if useUIKit {
                self.makeUIKitTextField(secure: self.isSecure)
            } else {
                if self.isSecure {
                    self.makeSecureField()
                } else {
                    self.makeTextField()
                }
            }
        }
    }

    private func makeLabel() -&gt; some View {
        Group {
            if label != nil {
                Text(""\(self.label!.uppercased())"")
                    .font(.custom(""AvenirNext-Regular"", size: self.isNuemorphic ? 13 : 11))
                    .foregroundColor(!self.validator.validation.isEdited ? Color(""DarkBody"")
                        : self.validator.validation.isValid ? Color(""Green"") : Color(""Red""))
                    .padding(.horizontal, 8)

            } else {
                EmptyView()
            }
        }
    }

    private func makeSecureField() -&gt; some View {

        SecureField("""", text: self.$input, onCommit: {
            self.validator.onCommit()
            self.onCommit()
        })
        .font(.custom(""AvenirNext-Regular"", size: 15))
            .foregroundColor(Color(""DarkBody""))
        .frame(maxWidth: .infinity)
    }

    private func makeTextField() -&gt; some View {

        TextField("""", text: self.$input, onEditingChanged: { editing in

            self.onEditingChanged(editing)
            self.validator.onEditing(editing)

            if !editing { self.onCommit() }

        }, onCommit: {
            self.validator.onCommit()
            self.onCommit()

        })
        .font(.custom(""AvenirNext-Regular"", size: 15))
            .foregroundColor(Color(""DarkBody""))
        .frame(maxWidth: .infinity)
    }

    private func makeUIKitTextField(secure: Bool) -&gt; some View {

        let firstResponderBinding = Binding&lt;Bool&gt;(get: {
            self.isEditing?.wrappedValue ?? false //?? self.isFirstResponder
        }, set: {
            //self.isFirstResponder = $0
            self.isEditing?.wrappedValue = $0
        })

        return UIKitTextField(text: self.$input, isEditing: firstResponderBinding, font: UIFont(name: ""AvenirNext-Regular"", size: 15)!, textColor: UIColor(named: ""DarkBody"")!, placeholder: """", onEditingChanged: { editing in

            self.onEditingChanged(editing)
            self.validator.onEditing(editing)

        }, onCommit: {

            self.validator.onCommit()
            self.onCommit()
        })
    }
}
</code></pre>

<p><strong>And here is how I store model (input values and validation) in ObservableObject i.e. LoginViewModel.</strong> </p>

<pre><code>final class LoginViewModel: ObservableObject {

    // MARK: - Published
    @Published var email: String = """"
    @Published var password: String = """"

    @Published var emailValidation: Validation = Validation(onEditing: true)
    @Published var passwordValidation: Validation = Validation(onEditing: true)

    @Published var validationErrors: [String]? = nil
    @Published var error: DescribableError? = nil

}
</code></pre>

<p>When I use this code depending on how I create ViewModel (in LoginView property or injected to LoginView constructor) depending on view parent views (screens) it is embedded can work totally different can cause hours of debugging and unexpected behaviour. </p>

<ol>
<li>Sometimes it seems that there is 1 ViewModel instance sometimes it seems that this instance is created with each View refresh </li>
<li>sometimes LabeledInput body is refreshing and validation colouring of label works corretly. Other times it seems it does not refresh at all and nothing happens </li>
<li>sometimes refreshes so often keyboard is immediately hiding </li>
<li>Other times there is no validation at all</li>
<li>Other times input is lost after exiting field or when rotating phone landscape to portrait </li>
<li>If there is some event that causes parent view refresh it can cause the inputs to lose data and validation. </li>
<li>Sometimes it refreshes to often other times it doesn't refresh at all as it should. </li>
</ol>

<p>I've tried to add .id(UUID) , custom .id(refreshId) or other Equatable protocol implementations but it doesn't work as expected to be reusable customized input with validation reusable between multiple forms on multiple screens. </p>

<p>Here is simple validation struct </p>

<pre><code>struct Validation {

    let onEditing: Bool

    init(onEditing: Bool = false) {
        self.onEditing = onEditing
    }

    var isEdited: Bool = false
    var errors: [String] = []
}
</code></pre>

<p>And here FieldValidator ObservableObject </p>

<pre><code>class FieldValidator&lt;T&gt;: ObservableObject {

    // MARK: - Properties
    private let rules: [Rule&lt;T&gt;]

    // MARK: - Binding
    @Binding private var input: T
    @Binding var validation: Validation

    // MARK: - Init
    init(input: Binding&lt;T&gt;, rules: [Rule&lt;T&gt;], validation: Binding&lt;Validation&gt;) {
        #if DEBUG
        print(""[FieldValidator] init: \(input.wrappedValue)"")
        #endif

        self._input = input
        self.rules = rules
        self._validation = validation 
    }

     private var disposables = Set&lt;AnyCancellable&gt;()
}

// MARK: - Public API
extension FieldValidator {

    func validateField() {

        validation.errors = rules
            .filter { !$0.isAsync }
            .filter { !$0.validate(input) }
            .map { $0.errorMessage() }
    }

    func validateFieldAsync() {

        rules
            .filter { $0.isAsync }
            .forEach { rule in

                rule.validateAsync(input)
                .filter { valid  in
                    !valid
                }.sink(receiveValue: { _ in
                    self.validation.errors.append(rule.errorMessage())
                })
                .store(in: &amp;disposables)
            }
    }
}

// MARK: - Helper Public API
extension FieldValidator {

    func onEditing(_ editing: Bool) {

        self.validation.isEdited = true

        if editing {
            if self.validation.onEditing {
                self.validateField()
            }
        } else {
            // on end editing
            self.validateField()
            self.validateFieldAsync()
        }
    }

    func onCommit() {
        self.validateField()
        self.validateFieldAsync()
    }
}
</code></pre>

<p>Rules are just subclasses of </p>

<pre><code>class Rule&lt;T&gt;  {

    var isAsync: Bool { return false }

    func validate(_ value: T) -&gt; Bool { return false }
    func errorMessage() -&gt; String { return """" }

    func validateAsync(_ value: T) -&gt; AnyPublisher&lt;Bool, Never&gt; {
        fatalError(""Async validation is not implemented!"")
    }
}
</code></pre>

<p>UPDATE </p>

<p>Complete UIKitTextField example </p>

<pre><code>@available(iOS 13.0, *)
struct UIKitTextField: UIViewRepresentable {

    // MARK: - Observed
    @ObservedObject private var keyboardEvents = KeyboardEvents()

    // MARK: - Binding
    @Binding var text: String
    var isEditing: Binding&lt;Bool&gt;?

    // MARK: - Actions
    let onBeginEditing: () -&gt; Void
    let onEndEditing: () -&gt; Void
    let onEditingChanged: (Bool) -&gt; Void
    let onCommit: () -&gt; Void

    // MARK: - Proprerties
    private let keyboardOffset: CGFloat

    private let textAlignment: NSTextAlignment
    private let font: UIFont
    private let textColor: UIColor
    private let backgroundColor: UIColor
    private let contentType: UITextContentType?
    private let keyboardType: UIKeyboardType
    private let autocorrection: UITextAutocorrectionType
    private let autocapitalization: UITextAutocapitalizationType
    private let isSecure: Bool
    private let isUserInteractionEnabled: Bool
    private let placeholder: String?

    public static let defaultFont = UIFont.preferredFont(forTextStyle: .body)

    private var hasDoneToolbar: Bool = false

    init(text: Binding&lt;String&gt;,
         isEditing: Binding&lt;Bool&gt;? = nil,
         keyboardOffset: CGFloat = 0,

         textAlignment: NSTextAlignment = .left,
         font: UIFont = UIKitTextField.defaultFont,
         textColor: UIColor = .black,
         backgroundColor: UIColor = .white,
         contentType: UITextContentType? = nil,
         keyboardType: UIKeyboardType = .default,
         autocorrection: UITextAutocorrectionType = .default,
         autocapitalization: UITextAutocapitalizationType = .none,
         isSecure: Bool = false,
         isUserInteractionEnabled: Bool = true,
         placeholder: String? = nil,

         hasDoneToolbar: Bool = false,

         onBeginEditing: @escaping () -&gt; Void = { },
         onEndEditing: @escaping () -&gt; Void = { },
         onEditingChanged: @escaping (Bool) -&gt; Void = { _ in },
         onCommit: @escaping () -&gt; Void = { }) {

        self._text = text
        self.isEditing = isEditing

        self.keyboardOffset = keyboardOffset

        self.onBeginEditing = onBeginEditing
        self.onEndEditing = onEndEditing
        self.onEditingChanged = onEditingChanged
        self.onCommit = onCommit

        self.textAlignment = textAlignment
        self.font = font
        self.textColor = textColor
        self.backgroundColor = backgroundColor
        self.contentType = contentType
        self.keyboardType = keyboardType
        self.autocorrection = autocorrection
        self.autocapitalization = autocapitalization
        self.isSecure = isSecure
        self.isUserInteractionEnabled = isUserInteractionEnabled
        self.placeholder = placeholder

        self.hasDoneToolbar = hasDoneToolbar
    }

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }

    func makeUIView(context: Context) -&gt; UITextField {

        let textField = UITextField()
        textField.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)
        textField.delegate = context.coordinator
        textField.keyboardType = keyboardType
        textField.textAlignment = textAlignment
        textField.font = font
        textField.textColor = textColor
        textField.backgroundColor = backgroundColor
        textField.textContentType = contentType
        textField.autocorrectionType = autocorrection
        textField.autocapitalizationType = autocapitalization
        textField.isSecureTextEntry = isSecure
        textField.isUserInteractionEnabled = isUserInteractionEnabled
        //textField.placeholder = placeholder
        if let placeholder = placeholder {
            textField.attributedPlaceholder = NSAttributedString(
                                    string: placeholder,
                                    attributes: [
                                        NSAttributedString.Key.foregroundColor: UIColor.lightGray
                                    ])
        }

        textField.addTarget(context.coordinator, action: #selector(Coordinator.valueChanged(_:)), for: .editingChanged)

        keyboardEvents.didShow = {
            if textField.isFirstResponder {
                DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(350)) {
                    textField.adjustScrollView(offset: self.keyboardOffset, animated: true)
                }
            }
        }

        if hasDoneToolbar {
            textField.addDoneButton {
                print(""Did tap Done Toolbar button"")
                textField.resignFirstResponder()
            }
        }

        return textField
    }

    func updateUIView(_ textField: UITextField, context: Context) {

        textField.text = text

        if let isEditing = isEditing {
            if isEditing.wrappedValue {
                textField.becomeFirstResponder()
            } else {
                textField.resignFirstResponder()
            }
        }
    }

    final class Coordinator: NSObject, UITextFieldDelegate {

        let parent: UIKitTextField

        init(_ parent: UIKitTextField) {
            self.parent = parent
        }

        @objc func valueChanged(_ textField: UITextField) {
            parent.text = textField.text ?? """"
            parent.onEditingChanged(true)
        }

        func textFieldDidBeginEditing(_ textField: UITextField) {
            parent.onBeginEditing()
            parent.onEditingChanged(true)
        }

        func textFieldDidEndEditing(_ textField: UITextField, reason: UITextField.DidEndEditingReason) {

            //guard textField.text != """" || parent.shouldCommitIfEmpty else { return }

            DispatchQueue.main.async {
               self.parent.isEditing?.wrappedValue = false
            }
            parent.text = textField.text ?? """"
            parent.onEditingChanged(false)
            parent.onEndEditing()
            parent.onCommit()
        }

        func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {
            parent.isEditing?.wrappedValue = false
            textField.resignFirstResponder()
            parent.onCommit()
            return true
        }
    }

}

extension UIView {

    func adjustScrollView(offset: CGFloat, animated: Bool = false) {

        if let scrollView = findParent(of: UIScrollView.self) {
            let contentOffset = CGPoint(x: scrollView.contentOffset.x, y: scrollView.contentOffset.y + offset)
            scrollView.setContentOffset(contentOffset, animated: animated)
        } else {
            print(""View is not in ScrollView - do not adjust content offset"")
        }
    }
}
</code></pre>

<p>Here is sample EmailRule implementation </p>

<pre><code>class EmailRule : RegexRule {

    static let regex = ""[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}""

    public convenience init(message : String = ""Email address is invalid""){
        self.init(regex: EmailRule.regex, message: message)
    }

    override func validate(_ value: String) -&gt; Bool {
        guard value.count &gt; 0 else { return true }

        return super.validate(value)
    }
}
</code></pre>
","4415642","","4415642","","2020-03-23 19:43:20","2020-03-23 19:43:20","SwiftUI: How it refreshes view and why @Published ObservableObject properties works randomly","<validation><swiftui><textfield><combine><observableobject>","0","8","","","","CC BY-SA 4.0"
"60821502","1","60825556","","2020-03-23 21:03:01","","0","523","<p>I am trying to build an application which receives a JSON Object from an API endpoint, which then I want to list out in the view. I've watched a lot of videos on this topic, but in each video they use very simplistic JSON Objects as examples and therefore the code they write doesn't really seem to transfer over, giving me errors no matter how I try to format it. The code is as follows</p>

<pre><code>import SwiftUI
import Combine
import Foundation

public struct ActivityModel: Codable, Identifiable {
    public let id: Int
    public let name: String
    public let activity_desc: String?
}


public struct ActivitiesModel2: Codable {
    public let location: String
    public let popular: [String:ActivityModel]
}

public struct ActivitiesModel: Codable {
    public let activities: ActivitiesModel2
}

public class ActivityFetcher: ObservableObject {
    var activities: ActivitiesModel?

    init(){
        guard let url = URL(string: ""https://mywebsite.com/api/loadapi"") else { return }

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = ""POST""

        URLSession.shared.dataTask(with: urlRequest) { (data, response, error) in

            do {
                if let d = data {
                    let decodedLists = try JSONDecoder().decode(ActivitiesModel.self, from: d)
                    DispatchQueue.main.async {
                        self.activities = decodedLists
                    }
                } else {
                    print(""No Data"")
                }
            } catch {
                print(""Error"")
            }

        }.resume()
    }
}

struct ActivityGuestView: View {
    let networkingServiceGeneral = NetworkingServiceGeneral()

    @ObservedObject var viewRouter: ViewRouter

    @ObservedObject var fetcher = ActivityFetcher()

    var body: some View {
        // This is where my issues start
        List(fetcher.activities?.activities.popular) { result in
            VStack {
                Text(result.name)
                Text(result.activity_desc)
                    .font(.system(size: 11))
                    .foregroundColor(Color.gray)
            }
        }
    }
}
</code></pre>

<p>This code, as I put it, gives me 5 errors. They are the following;</p>

<pre><code>    - Initializer 'init(_:rowContent:)' requires that '(key: String, value: ActivityModel)' conform to Identifiable
    - Initializer 'init(_:rowContent:)' requires that '[String : ActivityModel]' conform to 'RandomAccessCollection'
    -Value of optional type '[String : ActivityModel]?' must be unwrapped to a value of type '[String : ActivityModel]'
    - Coalesce using '??' to provide a default when the optional value contains 'nil'
    - Force-unwrap using '!' to abort execution if the optional value contains 'nil'
</code></pre>

<p>Some of these errors have options to fix it, but when I press fix it adds code but doesn't actually fix the error so I figured to just include them anyways. I'm still fairly new to Swift, but I know what some of it is asking, particularly the conforming to Identifiable, but it says that struct ActivitiesModel does not conform to identifiable when I try to add the tag, and the JSON Object doesn't have an ID for that section, so I can't ask the ID to make it identifiable.</p>

<p>Any help would be greatly appreciated, this has kind of been a wall right now.</p>

<p>Here's the JSON</p>

<pre><code>""activities"": {
        ""location"": ""Dallas"",
        ""popular"": {
            ""10"": {
                ""id"": 38,
                ""name"": ""Adventure Landing Dallas"",
                ""activity_desc"": ""Aquatic complex chain with additional land attractions including mini-golf, laser tag &amp; go-karts."",
            },
            ""12"": {
                ""id"": 40,
                ""name"": ""Jumpstreet"",
                ""activity_desc"": ""None provided."",
            },
        }
    }
}
</code></pre>
","6611009","","","","","2020-03-24 05:45:41","Swift ForEach Issues with JSON Dictionary","<ios><arrays><json><swift><combine>","1","3","","","","CC BY-SA 4.0"
"60832875","1","60833041","","2020-03-24 14:16:21","","0","210","<p>Is there any handy way to convert <code>Binding&lt;Error?&gt;</code> to <code>Binding&lt;Bool&gt;</code>? I'm having view model that has one of the property <code>@published var error: Error?</code>. I would like to show an alert if there is an error. But <code>Alert</code> accepts only <code>Binding&lt;Bool&gt;</code> as a parameter.</p>

<p>I was able to accomplish this by using introducing another property but this seems to me like not the most efficient way.</p>

<p>Code with the additional property</p>

<pre><code>class SampleViewModel: ObservableObject {

    @Published
    var error: Error? {
        didSet {
            isError = error != nil
        }
    }

    @Published
    var isError: Bool = false
}

struct SampleView: View {
    @ObservedObject
    var viewModel: SampleViewModel

    var body: some View {
        EmptyView().alert(isPresented: $viewModel.isError) { () -&gt; Alert in
            Alert(title: Text(""Error""), message: Text(viewModel.error!.localizedDescription), dismissButton: .default(Text(""OK"")))
        }
    }
}
</code></pre>
","1401983","","","","","2020-03-24 14:25:36","How to convert Binding<Error?> to Binding<Bool>","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60844286","1","60851629","","2020-03-25 07:09:01","","2","1017","<p>I am combining two publishers to determine what the center coordinate of a map view should be. The two publishers are:</p>

<ol>
<li>The user's initial location determined by a <code>CLLocationManager</code> (the first location reported once the <code>CLLocationManager</code> begins sending location updates).</li>
<li>The user's current location if the ""center map on current location"" button is tapped.</li>
</ol>

<p>In code:</p>

<pre><code>    class LocationManager: NSObject, ObservableObject {

        // The first location reported by the CLLocationManager.
        @Published var initialUserCoordinate: CLLocationCoordinate2D?
        // The latest location reported by the CLLocationManager.
        @Published var currentUserCoordinate: CLLocationCoordinate2D?
        // What the current map view center should be.
        @Published var coordinate: CLLocationCoordinate2D = CLLocationCoordinate2D(latitude: 42.35843, longitude: -71.05977) // Default coordinate.

        // A subject whose `send(_:)` method is being called elsewhere every time the user presses a button to center the map on the user's location.
        var centerButtonTappedPublisher: PassthroughSubject&lt;Bool, Never&gt; = PassthroughSubject&lt;Bool, Never&gt;()

        // The combined publisher that is where all my troubles lie.
        var coordinatePublisher: AnyPublisher&lt;CLLocationCoordinate2D, Never&gt; {
            Publishers.CombineLatest($initialUserCoordinate, centerButtonTappedPublisher)
                .map { initialCoord, centerButtonTapped in
                    var latestCoord = initialCoord
                    if centerButtonTapped {
                        latestCoord = self.currentUserCoordinate
                    }
                    return latestCoord
                }
                .replaceNil(with: CLLocationCoordinate2D(latitude: 42.35843, longitude: -71.05977))
                .eraseToAnyPublisher()
        }

        private var cancellableSet: Set&lt;AnyCancellable&gt; = []

        //... Other irrelevant properties

        private override init() {
            super.init()

            coordinatePublisher
                .receive(on: RunLoop.main)
                .assign(to: \.coordinate, on: self)
                .store(in: &amp;cancellableSet)

            //... CLLocationManager set-up
        }
    }

    extension LocationManager: CLLocationManagerDelegate {

        //...

        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
            // We are only interested in the user's most recent location.
            guard let location = locations.last else { return }
            let latestCoord = location.coordinate
            if initialUserCoordinate == nil {
                initialUserCoordinate = latestCoord
            }
            currentUserCoordinate = latestCoord
        }

        //...

    }
</code></pre>

<p>Both publishers, <code>$initialUserCoordinate</code> and <code>centerButtonTappedPublisher</code>, publish updates - I have confirmed this. However, the combined publisher <code>coordinatePublisher</code> only fires when the ""center map on current location"" button is tapped. It never fires when the <code>initialUserCoordinate</code> property is first set.</p>

<p><a href=""https://stackoverflow.com/questions/56910228/swift-combine-subsequent-publisher-that-consumes-other-publishers-using-combin"">This question</a> suggests adding a <code>.receive(on: RunLoop.main)</code> after the <code>Publishers.CombineLatest($initialUserCoordinate, centerButtonTappedPublisher)</code> but this does not work for me.</p>

<p>What am I doing wrong?</p>
","4752920","","4752920","","2020-03-25 07:35:59","2020-03-25 15:09:22","Swift Combine's CombineLatest does not fire in response to an update to one of its publishers","<swift><combine><combinelatest>","1","0","","","","CC BY-SA 4.0"
"60848908","1","","","2020-03-25 12:31:31","","2","1590","<p>I have a view that displays a few photos that are loaded from an API in a scroll view. I want to defer fetching the images until the view is displayed. My view, simplified looks something like this:</p>

<pre><code>struct DetailView : View {
    @ObservedObject var viewModel: DetailViewModel

    init(viewModel: DetailViewModel) {
        self.viewModel = viewModel
    }

    var body: some View {
        GeometryReader { geometry in
            ZStack {
                Color(""peachLight"").edgesIgnoringSafeArea(.all)
                if self.viewModel.errorMessage != nil {
                    ErrorView(error: self.viewModel.errorMessage!)
                } else if self.viewModel.imageUrls.count == 0 {
                    VStack {
                        Text(""Loading"").foregroundColor(Color(""blueDark""))
                        Text(""\(self.viewModel.imageUrls.count)"").foregroundColor(Color(""blueDark""))
                    }
                } else {
                    VStack {
                        UIScrollViewWrapper {
                            HStack {
                                ForEach(self.viewModel.imageUrls, id: \.self) { imageUrl in
                                    LoadableImage(url: imageUrl)
                                        .scaledToFill()
                                }.frame(width: geometry.size.width, height: self.scrollViewHeight)
                            }.edgesIgnoringSafeArea(.all)
                        }.frame(width: geometry.size.width, height: self.scrollViewHeight)
                        Spacer()
                    }
                }
            }
        }.onAppear(perform: { self.viewModel.fetchDetails() })
            .onReceive(viewModel.objectWillChange, perform: {
                print(""Received new value from view model"")
                print(""\(self.viewModel.imageUrls)"")
            })
    }
}
</code></pre>

<p>my view model looks like this:</p>

<pre><code>import Foundation
import Combine

class DetailViewModel : ObservableObject {
    @Published var imageUrls: [String] = []
    @Published var errorMessage : String?

    private var fetcher: Fetchable
    private var resourceId : String


    init(fetcher: Fetchable, resource: Resource) {
        self.resourceId = resource.id
        // self.fetchDetails() &lt;-- uncommenting this line results in onReceive being called + a view update
    }


    // this is a stubbed version of my data fetch that performs the same way as my actual
    // data call in regards to ObservableObject updates

    // MARK - Data Fetching Stub
    func fetchDetails() {
        if let path = Bundle.main.path(forResource: ""detail"", ofType: ""json"") {
            do {
                let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .mappedIfSafe)
                let parsedData = try JSONDecoder().decode(DetailResponse.self, from: data)
                self.imageUrls = parsedData.photos // &lt;-- this doesn't trigger a change, and even manually calling self.objectWillChange.send() here doesn't trigger onReceive/view update
                print(""setting image urls to \(parsedData.photos)"")

            } catch  {
                print(""error decoding"")
            }
        }
    }
}
</code></pre>

<p>If I fetch my data within the <code>init</code> method of my view model, the <code>onReceive</code> block on my view IS called when the @Published <code>imageUrls</code> property is set. However, when I remove the <code>fetch</code> from the <code>init</code> method and call from the view using:</p>

<pre><code> .onAppear(perform: { self.viewModel.fetchDetails() })

</code></pre>

<p>the <code>onReceive</code> for <code>viewModel.objectWillChange</code> is NOT called, even though the data is updated. I don't know why this is the case and would really appreciate any help here.</p>
","3879821","","","","","2021-12-20 03:05:32","SwiftUI - onReceive not being called for an ObservableObject property change when the property is updated after view is loaded","<swiftui><combine><observableobject>","2","1","","","","CC BY-SA 4.0"
"60862050","1","60881207","","2020-03-26 06:34:44","","4","1579","<p>I have a map view which has a button that, when pressed, should center the map on the user's current location. I am trying to achieve this using Swift's Combine framework. I tried solving this by adding a <code>@State</code> property called <code>mapCenter</code> and assigning to this property in Combine's <code>assign(to:on:)</code> subject, as follows:</p>

<pre><code>struct MapWithButtonView: View {

    // What the current map view center should be.
    @State var mapCenter = CLLocationCoordinate2D(latitude: 42.35843, longitude: -71.05977)

    // A subject whose `send(_:)` method is being called from within the CenterButton view to center the map on the user's location.
    private var centerButtonTappedPublisher = PassthroughSubject&lt;Bool, Never&gt;()

    // A publisher that turns a ""center button tapped"" event into a coordinate.
    private var centerButtonTappedCoordinatePublisher: AnyPublisher&lt;CLLocationCoordinate2D?, Never&gt; {
        centerButtonTappedPublisher
            .map { _ in LocationManager.default.currentUserCoordinate }
            .eraseToAnyPublisher()
    }

    private var coordinatePublisher: AnyPublisher&lt;CLLocationCoordinate2D, Never&gt; {
        Publishers.Merge(LocationManager.default.$initialUserCoordinate, centerButtonTappedCoordinatePublisher)
            .replaceNil(with: CLLocationCoordinate2D(latitude: 42.35843, longitude: -71.05977))
            .eraseToAnyPublisher()
    }

    private var cancellableSet: Set&lt;AnyCancellable&gt; = []

    init() {
        // This does not result in an update to the view... why not?
        coordinatePublisher
            .receive(on: RunLoop.main)
            .handleEvents(receiveSubscription: { (subscription) in
                    print(""Receive subscription"")
                }, receiveOutput: { output in
                    print(""Received output: \(String(describing: output))"")
                }, receiveCompletion: { _ in
                    print(""Receive completion"")
                }, receiveCancel: {
                    print(""Receive cancel"")
                }, receiveRequest: { demand in
                    print(""Receive request: \(demand)"")
                })
            .assign(to: \.mapCenter, on: self)
            .store(in: &amp;cancellableSet)
    }

    var body: some View {
        ZStack {
            MapView(coordinate: mapCenter)
                .edgesIgnoringSafeArea(.all)

            CenterButton(buttonTappedPublisher: centerButtonTappedPublisher)
        }
    }
}
</code></pre>

<p>The <code>MapView</code> is a <code>UIViewRepresentable</code> view and looks like this:</p>

<pre><code>struct MapView: UIViewRepresentable {
    // The center of the map.
    var coordinate: CLLocationCoordinate2D

    func makeUIView(context: Context) -&gt; MKMapView {
        let mapView = MKMapView(frame: .zero)
        mapView.showsUserLocation = true
        return mapView
    }

    func updateUIView(_ view: MKMapView, context: Context) {
        let span = MKCoordinateSpan(latitudeDelta: 0.02, longitudeDelta: 0.02)
        let region = MKCoordinateRegion(center: coordinate, span: span)
        view.setRegion(region, animated: true)
    }
}
</code></pre>

<p>The <code>CenterButton</code> is a simple button that looks like this:</p>

<pre><code>struct CenterButton: View {
    var buttonTappedPublisher: PassthroughSubject&lt;Bool, Never&gt;

    var body: some View {
        Button(action: {
            self.buttonTappedPublisher.send(true)
        }) {
            Image(systemName: ""location.fill"")
                .imageScale(.large)
                .accessibility(label: Text(""Center map""))
        }
    }
}
</code></pre>

<p>And the <code>LocationManager</code> is an <code>ObservableObject</code> which publishes the user's current and initial location:</p>

<pre><code>class LocationManager: NSObject, ObservableObject {

    // The first location reported by the CLLocationManager.
    @Published var initialUserCoordinate: CLLocationCoordinate2D?
    // The latest location reported by the CLLocationManager.
    @Published var currentUserCoordinate: CLLocationCoordinate2D?

    private let locationManager = CLLocationManager()

    static let `default` = LocationManager()

    private override init() {
        super.init()

        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.pausesLocationUpdatesAutomatically = true
        locationManager.activityType = .other
        locationManager.requestWhenInUseAuthorization()
    }
}

extension LocationManager: CLLocationManagerDelegate {

    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        switch status {
        case .authorizedAlways, .authorizedWhenInUse:
            NSLog(""Location authorization status changed to '\(status == .authorizedAlways ? ""authorizedAlways"" : ""authorizedWhenInUse"")'"")
            enableLocationServices()
        case .denied, .restricted:
            NSLog(""Location authorization status changed to '\(status == .denied ? ""denied"" : ""restricted"")'"")
            disableLocationServices()
        case .notDetermined:
            NSLog(""Location authorization status changed to 'notDetermined'"")
        default:
            NSLog(""Location authorization status changed to unknown status '\(status)'"")
        }
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        // We are only interested in the user's most recent location.
        guard let location = locations.last else { return }
        // Use the location to update the location manager's published state.
        let coordinate = location.coordinate
        if initialUserCoordinate == nil {
            initialUserCoordinate = coordinate
        }
        currentUserCoordinate = coordinate
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        NSLog(""Location manager failed with error: \(error)"")
    }

    // MARK: Helpers.

    private func enableLocationServices() {
        locationManager.startUpdatingLocation()
    }

    private func disableLocationServices() {
        locationManager.stopUpdatingLocation()
    }
}
</code></pre>

<p>Unfortunately, the above does not work. The view is never updated when the <code>CenterButton</code> is tapped. I ended up solving this problem by using an <code>ObservableObject</code> view model object with a <code>@Published var mapCenter</code> property, however I don't know why my initial solution using <code>@State</code> does not work. What is wrong with updating <code>@State</code> as I have done above?</p>

<p>Note that if trying to reproduce this, you will need to add the <code>NSLocationWhenInUseUsageDescription</code> key with a value such as ""This app needs access to your location"" in your <code>Info.plist</code> file in order to be able to grant location permissions.</p>
","4752920","","4752920","","2020-03-27 22:32:31","2020-09-24 11:35:35","Assigning to @State in Combine's `assign(to:on:)` subject does not result in view update","<swift><swiftui><combine><swiftui-state>","3","5","","","","CC BY-SA 4.0"
"60868788","1","","","2020-03-26 13:47:52","","6","1194","<p>Yesterday I upgraded XCode and my project to iOS 13.4 and I started to see a lot of failures in  around views that use GeometryReaders.</p>

<p>The error does not reveal anything besides ""precondition failure: invalid input index""</p>
","2838925","","","","","2020-09-08 05:02:12","precondition failure: invalid input index when using GeometryReader in SwiftUI starting with iOS 13.4","<swift><swiftui><ios13><combine>","2","2","1","","","CC BY-SA 4.0"
"60871095","1","","","2020-03-26 15:50:44","","2","938","<p>Learning how to cache image with native NSCache in YouTube. </p>

<p>Below is the example code, which is working well. I could see it set the image into cache in <code>getImageFromResponse</code> method after data is returned from <code>URLSession.shared.dataTask</code>. Well, it is the old way that using the @escaping completion handler.</p>

<pre><code>import Foundation
import SwiftUI

class UrlImageModel: ObservableObject {
    @Published var image: UIImage?
    var urlString: String?
    var imageCache = ImageCache.getImageCache()

    init(urlString: String?) {
        self.urlString = urlString
        loadImage()
    }

    func loadImage() {
        if loadImageFromCache() {
            print(""Cache hit"")
            return
        }

        print(""Cache miss, loading from url"")
        loadImageFromUrl()
    }

    func loadImageFromCache() -&gt; Bool {
        guard let urlString = urlString else {
            return false
        }

        guard let cacheImage = imageCache.get(forKey: urlString) else {
            return false
        }

        image = cacheImage
        return true
    }

    func loadImageFromUrl() {
        guard let urlString = urlString else {
            return
        }

        let url = URL(string: urlString)!
        let task = URLSession.shared.dataTask(with: url, completionHandler: getImageFromResponse(data:response:error:))
        task.resume()
    }


    func getImageFromResponse(data: Data?, response: URLResponse?, error: Error?) {
        guard error == nil else {
            print(""Error: \(error!)"")
            return
        }
        guard let data = data else {
            print(""No data found"")
            return
        }

        DispatchQueue.main.async {
            guard let loadedImage = UIImage(data: data) else {
                return
            }

            self.imageCache.set(forKey: self.urlString!, image: loadedImage)
            self.image = loadedImage
        }
    }
}

class ImageCache {
    var cache = NSCache&lt;NSString, UIImage&gt;()

    func get(forKey: String) -&gt; UIImage? {
        return cache.object(forKey: NSString(string: forKey))
    }

    func set(forKey: String, image: UIImage) {
        cache.setObject(image, forKey: NSString(string: forKey))
    }
}

extension ImageCache {
    private static var imageCache = ImageCache()
    static func getImageCache() -&gt; ImageCache {
        return imageCache
    }
}
</code></pre>

<p>And my app is using the latest Combine framework to download image. I try to add a line in <code>loadImageFromUrl()</code>, I think after <code>assign(to: \.image, on: self)</code>, the <code>image</code> should has a value. However, the console gave me the Error ""Fatal error: Unexpectedly found nil while unwrapping an Optional value: file /Users/Chuck/Documents/iOS/Projects/Moments/Moments/Model/Url Image/UrlImageModel.swift, line 55"". </p>

<p>So by using native NSCache, how or where to set the image cache when with Combine networking?
Below is my code, please give me some hint!</p>

<pre><code>import Foundation
import SwiftUI
import Combine

class UrlImageModel: ObservableObject {
    @Published var image: UIImage?
    private var url: URL?
    private var cancellable: AnyCancellable?
    private var imageCache = ImageCache.getImageCache()

    init(url: URL?) {
        self.url = url
        loadImage()
    }

    func loadImage() {
        if loadImageFromCache() {
            print(""Cache hit"")
            return
        }

        print(""Cache missing, loading from url"")
        loadImageFromUrl()
    }

    func loadImageFromCache() -&gt; Bool {
        guard let url = url else {
            return false
        }

        guard let cacheImage = imageCache.get(key: url) else {
            return false
        }

        image = cacheImage
        return true
    }

    func loadImageFromUrl() {
        cancellable = URLSession.shared.dataTaskPublisher(for: url!)
            .map { UIImage(data: $0.data) }
            .replaceError(with: nil)
            .receive(on: DispatchQueue.main)
            .assign(to: \.image, on: self)

        // set image as cache!!
        imageCache.set(key: url!, image: image!)

    }

    func cancel() {
        cancellable?.cancel()
    }
}

class ImageCache {
    var cache = NSCache&lt;NSURL, UIImage&gt;()

    func get(key: URL) -&gt; UIImage? {
        return cache.object(forKey: key as NSURL)
    }

    func set(key: URL, image: UIImage) {
        cache.setObject(image, forKey: key as NSURL)
    }
}

extension ImageCache {
    private static var imageCache = ImageCache()

    static func getImageCache() -&gt; ImageCache {
        return imageCache
    }
}
</code></pre>

<p>/ / / Update, I found how to do it. Add Combine <code>handleEvents</code>method and set image cache in receiveOutput closure fix the issue. Btw, there is more parameters that dealing with upstream publisher &amp; downstream receiver. For me, that needs more practice to consume this new way of networking in Combine.</p>

<p><strong>Fixed Code</strong>, I also add a subscript in image cache part.</p>

<pre><code>import Foundation
import SwiftUI
import Combine

class UrlImageModel: ObservableObject {
    @Published var image: UIImage?
    private var url: URL?
    private var cancellable: AnyCancellable?
    private var imageCache = ImageCache.getImageCache()

    init(url: URL?) {
        self.url = url
        loadImage()
    }

    func loadImage() {
        if loadImageFromCache() {
            print(""Cache hit"")
            return
        }

        print(""Cache missing, loading from url"")
        loadImageFromUrl()
    }

    func loadImageFromCache() -&gt; Bool {
        guard let url = url else {
            return false
        }

        guard let cacheImage = imageCache[url] else {
            return false
        }

        image = cacheImage
        return true
    }

    func loadImageFromUrl() {
        guard let url = url else {
            return
        }

        cancellable = URLSession.shared.dataTaskPublisher(for: url)
            .map { UIImage(data: $0.data) }
            .replaceError(with: nil)
            // set image into cache!
            .handleEvents(receiveOutput: { [unowned self] image in
                guard let image = image else {return}
                self.imageCache[url] = image
            })
            .receive(on: DispatchQueue.main)
            .assign(to: \.image, on: self)
    }
}

class ImageCache {
    var cache = NSCache&lt;NSURL, UIImage&gt;()

    subscript(_ key: URL) -&gt; UIImage? {
        get { cache.object(forKey: key as NSURL) }
        set { newValue == nil ? cache.removeObject(forKey: key as NSURL) : cache.setObject(newValue!, forKey: key as NSURL) }
    }
}

extension ImageCache {
    private static var imageCache = ImageCache()

    static func getImageCache() -&gt; ImageCache {
        return imageCache
    }
}
</code></pre>
","10158398","","10158398","","2020-03-27 04:37:56","2020-03-27 04:37:56","Where to set image cache when using Combine framwork","<swiftui><combine><image-caching>","0","0","2","","","CC BY-SA 4.0"
"60875043","1","","","2020-03-26 19:47:19","","3","252","<p>I would like to create a <code>property wrapper</code> for <code>CurrentValueSubject</code>. I have done this like that:</p>

<pre><code>@propertyWrapper
public class CurrentValue&lt;Value&gt; {

    public var wrappedValue: Value {
        get { projectedValue.value }
        set { projectedValue.value = newValue }
    }

    public var projectedValue: CurrentValueSubject&lt;Value, Never&gt;

    public init(wrappedValue: Value) {
        self.projectedValue = CurrentValueSubject(wrappedValue)
    }

}
</code></pre>

<p>This works but there is a little thing I would like to change with it - use struct instead of class. The problem with using struct for this is that sometimes I could get <code>Simultaneous accesses</code> error. And I know why, this happens when in <code>sink</code> from this publisher I would try to read the value from wrapped value. So for example with code like this:</p>

<pre><code>@CurrentValue
let test = 1
$test.sink { _ in
    print(self.test)
} 
</code></pre>

<p>And I more or less know why - because when <code>projectedValue</code> executes its observation, wrapped value is still in process of setting its value. In class this is ok, because it would just change the value, but with struct it actually modifies the struct itself, so Im trying to write and read from it at the same time.</p>

<p>My question is - is there some clever way to overcome this, while still using struct? I don't want to <code>dispatch async</code>.</p>

<p>Also I know that <code>@Projected</code> works similarly to this <code>propertyWrapper</code>, but there is a big difference - <code>Projected</code> executes on <code>willSet</code>, while <code>CurrentValueSubject</code> on <code>didSet</code>. And <code>Projected</code> has the same issue anyway.</p>

<p>I know that I can read the value inside the closure, but sometimes Im using this with various function calls, that might eventually use <code>self.test</code> instead.</p>
","4528716","","","","","2020-03-26 19:47:19","Property Wrapper for CurrentValueSubject - memory management","<ios><swift><combine><property-wrapper>","0","0","","","","CC BY-SA 4.0"
"60888539","1","60888871","","2020-03-27 14:57:54","","1","874","<p>In the following Playground example, the UI updates with the current date correctly, however when navigating away from the page and coming back the timer does not resume ticking:</p>

<pre><code>  import SwiftUI
  import PlaygroundSupport

  struct MainTabView: View {
    let timer = Timer.publish(every: 1, on: .main, in: .common)

    @State var time = Date()

    var body: some View {
        TabView {
            VStack {
                Text(""\(time)"").onReceive(self.timer) { self.time = $0 }
            }
            .onAppear { _ = self.timer.connect() }
            .tabItem {
                Text(""Page 1"")
            }

            Text(""Page 2"").tabItem {
                Text(""Page 2"")
            }

            Text(""Page 3"").tabItem {
                Text(""Page 3"")
            }
        }
    }
}

PlaygroundPage.current.setLiveView(MainTabView())
</code></pre>

<p>How do I have the timer start updating again when the page starts showing? </p>

<p>I have seen solutions that involve wrapping the Timer in another class, but nothing that can be done in the View.</p>

<p>I thought calling in <code>connect()</code>  in <code>onAppear {}</code> would do it.</p>
","24391","","","","","2020-03-27 15:17:15","How do I resume a published timer in SwiftUI after navigating to a different page?","<swift><timer><swiftui><combine><publisher>","2","0","","","","CC BY-SA 4.0"
"60891870","1","","","2020-03-27 18:15:42","","0","1418","<p>I am making an HTTP GET request using Combine and I don't know how to add a body. I know that it is not ok to have a body in a GET request, but I really need to test some things. I am using Xcode 11.4 and iOS 13.4. Stack Overflow doesn’t let me post this question unless i write some more information, but I can’t think of any more pieces of information that you might need for this. Here is my code:</p>

<pre><code>import Foundation
import Combine
//MARK: - Object to retrieve from JSON
struct Doctor: Codable, Identifiable {
    let id = UUID()
    let patients: [Patients]
}
struct Patients: Codable, Identifiable {
    let id: String
    let name: String
    let phone: String
    enum CodingKeys: String, CodingKey {
        case id = ""_id""
        case name
        case phone
    }
}
class Network {
  enum Error: LocalizedError {
    case invalidResponse
    case addressUnreachable(URL)
    var errorDescription: String? {
      switch self {
      case .invalidResponse:
        return ""The server responded with garbage.""
      case .addressUnreachable(let url):
        return ""\(url.absoluteString) is unreachable.""
      }
    }
  }
  let urlRequest = URL(string: URL)!
  let networkQueue = DispatchQueue(label: ""Networking"",
                                   qos: .default,
                                   attributes: .concurrent)
  func downloadPatients() -&gt; AnyPublisher&lt;Doctor, Error&gt; {
    URLSession.shared
      .dataTaskPublisher(for: urlRequest)
      .receive(on: networkQueue)
      .map(\.data)
      .decode(type: Doctor.self, decoder: JSONDecoder())
      .mapError { (error) -&gt; Network.Error in
        switch error {
        case is URLError:
          return Error.addressUnreachable(self.urlRequest)
        default:
          return Error.invalidResponse
        }
    }
    .eraseToAnyPublisher()
  }
}
let networkRequest = Network()
 func loadPatients() {
       cancelable = networkRequest.downloadPatients()
            .sink(
                receiveCompletion: {
                receiveValue: { doctor in
                    self.localPatients = doctor.patients
                    self.isShowing = false
            }
        )
    }
</code></pre>

<p>Thank you!</p>
","11508444","","11508444","","2020-03-27 18:57:13","2020-03-27 19:21:54","How do I add a body to an HTTP GET request made with Combine in Swift?","<swift><httprequest><combine>","1","1","0","","","CC BY-SA 4.0"
"60895489","1","","","2020-03-27 23:30:06","","-2","89","<p>I've been looking at a lot of posts and haven't quite found what I'm looking for. I'm not sure how to go about taking the following sample data:</p>

<pre><code>host1   input   nic1    ip1 ip2 PROT    30000   10
host1   input   nic1    ip1 ip2 PROT    40000   10
host1   input   nic1    ip1 ip2 PROT    50000   10
host1   input   nic1    ip1 ip2 PROT    60000   10
host1   input   nic1    ip3 ip2 PROT    10      30000
host1   input   nic1    ip3 ip2 PROT    10      40000
host1   input   nic1    ip3 ip2 PROT    10      50000
host1   input   nic1    ip3 ip2 PROT    10      60000
host1   output  nic1    ip2 ip1 PROT    10      30000
host1   output  nic1    ip2 ip1 PROT    10      40000
host1   output  nic1    ip2 ip1 PROT    10      50000
host1   output  nic1    ip2 ip1 PROT    10      60000
host1   output  nic1    ip2 ip3 PROT    30000   10
host1   output  nic1    ip2 ip3 PROT    40000   10
host1   output  nic1    ip2 ip3 PROT    50000   10
host1   output  nic1    ip2 ip3 PROT    60000   10
host1   output  loc     ip2 ip2 PROT    10      30000
host1   output  loc     ip2 ip2 PROT    10      50000
</code></pre>

<p>And merge it into:</p>

<pre><code>host1   input   nic1    ip1 ip2 PROT    30000:60000 10
host1   input   nic1    ip3 ip2 PROT    10          30000:60000
host1   output  nic1    ip2 ip1 PROT    10          30000:60000
host1   output  nic1    ip2 ip3 PROT    30000:60000 10
host1   output  loc     ip2 ip2 PROT    10          30000:50000
</code></pre>

<p>I have a large amount of data like this with the need to make ranges for multiple fields of a given line but I think if somebody can show me how to do it for one field as I have above, I should be able to figure the rest out. And if not I'll follow up :). Thanks in advance for any help.</p>
","13138158","","13138158","","2020-03-30 20:29:15","2020-03-30 20:29:15","Merge all lines that are identical aside from a key field and make key field a range","<bash><merge><scripting><combine>","1","5","","2020-03-28 02:56:52","","CC BY-SA 4.0"
"60895845","1","60898132","","2020-03-28 00:22:40","","0","64","<p>I am looking for a way to write swift code faster. SO I am wondering if there is i can combine </p>

<pre><code>    grassColor.backgroundColor
</code></pre>

<p>Into into something like </p>

<pre><code>   let combine = grassColor.backgroundColor
</code></pre>

<p>So I could code this instead of have to type grassColor.backgroundColor = .red every time. </p>

<pre><code>@objc func fanColorRed(){
    combine = .red

}

@objc func fanColorBlue(){
    combine = .blue
 }
@objc func fanColorYellow(){
    combine = .yellow

 }
@objc func fanColorOrange(){
    combine = .orange

 }
</code></pre>
","","user13124361","","","","2020-03-28 06:49:19","combine imageview and background image into one string","<swift><dictionary><object><var><combine>","1","0","","","","CC BY-SA 4.0"
"60900554","1","60900635","","2020-03-28 11:30:01","","20","10803","<p>In Swift you can define default values on a struct that can be overwritten on initialization:</p>

<pre class=""lang-swift prettyprint-override""><code>struct myStruct {
    var a: Int = 1
}
var instance1 = myStruct() // instance1.a -&gt; 1 
var instance2 = myStruct(a: 10) // instance2.a -&gt; 10
</code></pre>

<p>However when I try to apply this to Bindings in a SwiftUI view I get an error:</p>

<pre class=""lang-swift prettyprint-override""><code>struct MyView: View {
    @Binding var a: Bool = Binding.constant(true)
    var body: some View {
        Text(""MyView"")
    }
}
</code></pre>

<pre><code>Argument labels '(wrappedValue:)' do not match any available overloads
</code></pre>

<p>I want to create a view which by default uses a constant boolean value but that can be overwritten by a ""real"" Binding:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContainerView: View {
    @State var hasSet = false
    var body: some View {
        Group {
            MyView(a: $hasSet)
            MyView() // should be equivalent to MyView(a: .constant(true))
        }
    }
}
</code></pre>

<p>Is it possible to define such a default value for a Binding in SwiftUI?</p>
","6482408","","","","","2022-08-23 13:32:18","SwiftUI Binding default value (Argument labels '(wrappedValue:)' do not match any available overloads)","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"60903039","1","60906250","","2020-03-28 15:51:29","","1","415","<p>I want to create a method <code>authenticate</code> which, using Combine, allows the user to login with my API.</p>

<p>I am trying to add now a precondition, so that if the provided username is empty, my method does not touch the network. I want to make an early exist at this point, providing an error back to the Subscriber.</p>

<p>Please find below an snippet of my code. How could I return an error from the early exist in line 4?</p>

<pre><code>func authenticate(username: String, password: String) -&gt; AnyPublisher&lt;User, Error&gt; {

        guard !username.isEmpty else {
            // How to return an error to the subscribers from here?????
            return
        }

        let parameters: [String: Any] = [
            ""username"": username,
            ""password"": password
        ]

        var request = URLRequest(endpoint: Endpoint.login)
        request.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")
        request.httpBody = try? JSONSerialization.data(withJSONObject: parameters, options: [])

        return URLSession.shared.dataTaskPublisher(for: request)
            .map { $0.data }
            .decode(type: AuthenticationResult.self, decoder: JSONDecoder())
            .map { $0.user }
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
</code></pre>
","3750435","","","","","2020-03-28 19:56:53","Combine: how to early exit with error from a guard precondition","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"60907882","1","61880291","","2020-03-28 22:39:52","","0","803","<p>I have just updated my Xcode to 11.4 from 11.3 and my project written in SwiftUI started to behave differently. I used to call <code>toggle()</code> function for boolean values and it used to trigger <code>didSet</code> property observer, however, it is not working any more.</p>

<p>Let' say we have a <code>State</code> property called <code>isSettingOn</code>. I used to call this:</p>

<p><code>isSettingOn.toggle()</code></p>

<p>which was triggering <code>didSet</code> observer of the property. Now, only if I call this:</p>

<p><code>isSettingOn = true</code></p>

<p>it is working.</p>

<p>My projects are all based on this behaviour and now this change basically broke everything. Does anyone know if I am actually doing anything wrong here?</p>

<p><strong>Edit:</strong> </p>

<p>Demo code added:</p>

<pre><code>struct ContentView: View {

    @State var isSettingOn: Bool = true {
        didSet {
            print(""didSet isSettingOn"")
        }
    }

    var body: some View {
        Button(action: {
            self.isSettingOn = true // will trigger didSet
            self.isSettingOn.toggle() // won't trigger didSet
        }) {
            Text(""Toggle isSettingOn"")
        }
    }
}
</code></pre>
","2739567","","2739567","","2020-03-29 08:35:14","2020-05-18 22:47:33","SwiftUI toggle() function on Published values stopped triggering didSet with Swift 5.2","<swift><swiftui><combine><swift5><xcode11.4>","1","5","","","","CC BY-SA 4.0"
"60917286","1","","","2020-03-29 16:23:42","","1","314","<p>Is there an alternative to ReactiveSwift Action in Swift Combine? If not, how could it be implemented?</p>

<p>I am not very familiar with Swift Combine yet and could't find it anywhere.</p>
","11216994","","","","","2020-03-29 16:42:56","ReactiveSwift Action in Swift Combine","<swift><rx-swift><combine><reactive-swift>","1","1","","","","CC BY-SA 4.0"
"60917813","1","","","2020-03-29 17:07:14","","1","471","<p>I want to add an object to a local server and then see the updated list in my view.</p>

<p>I have a <strong>ViewModelClass</strong> that handles the REST requests: </p>

<pre><code>class CupcakeViewModel : ObservableObject {

    let objectWillChange = PassthroughSubject&lt;CupcakeViewModel,Never&gt;()

    init() {
        get()
    }

    var cupcakes : [Cupcake] = [Cupcake]() {
        didSet {
            objectWillChange.send(self)
        }
    }

    static let url = URL(string: ""http://localhost:1337/cupcakes"")!

    func get() {
        URLSession.shared.dataTask(with: CupcakeViewModel.url) { (data, response, error) in
            if let data = data {
                do {
                    print(data)
                    let cupcakes = try JSONDecoder().decode([Cupcake].self, from: data)
                    DispatchQueue.main.async {
                        self.cupcakes = cupcakes
                    }
                } catch {
                    print(""ERROR"")
                }
            }
        }.resume()
    }

    func post(cupcake : Cupcake) {
        AF.request(CupcakeViewModel.url, method: .post, parameters: cupcake, encoder: JSONParameterEncoder.default).responseDecodable {  (response: DataResponse&lt;Cupcake, AFError&gt;) in
            if let value = response.value {
                DispatchQueue.main.async {
                    self.cupcakes.append(value)
                }
            }
        }
    }

}
</code></pre>

<p>and in my <strong>MainView</strong> I have:</p>

<pre><code>struct CupcakesView: View {

    @ObservedObject var VM = CupcakeViewModel()
    @State var showed = false

    var body: some View {

        NavigationView {
            List(VM.cupcakes,id:\.self) {cupcake in
                Text(cupcake.gusto)
            }.padding(.top,1)
                .sheet(isPresented: $showed, content: {
                    AggiungiCupcake(showed: self.$showed)
                })
            .navigationBarItems(trailing:
                Button(action: {
                    self.showed = true
                }) {
                    Text(""ADD"")
                }
            )
        }
    }
}

struct AggiungiCupcake : View {

    @State var gusto = """"
    @State var prezzo : Float = 0
    @Binding var showed : Bool
    @ObservedObject var VM = CupcakeViewModel()

    var body : some View {
        VStack {
            TextField(""Gusto"", text: $gusto)
            TextField(""Prezzo"", value: $prezzo, formatter: NumberFormatter())
            Button(action: {
                let c = Cupcake(gusto: self.gusto, prezzo: self.prezzo)
                self.VM.post(cupcake: c)
                self.showed = false
            }) {
                Text(""ADD"")
            }
        }.padding(30)
    }
}
</code></pre>

<p>Both the get and the post requests go fine and on my server everything is updated, but my view does not add the new Object in the list. I use AlamoFire (AF) for the post request.</p>

<p>Anyone can help?</p>
","10840195","","","","","2021-09-10 01:04:28","Update list after HTTP POST request in SwiftUI","<xcode><rest><swiftui><alamofire><combine>","1","0","","","","CC BY-SA 4.0"
"60919082","1","60920017","","2020-03-29 18:42:20","","1","526","<p>I have backend API /search?q=New Je which is return list of JSON cities</p>

<ul>
<li>""city"": ""New Jersey""</li>
<li>""city"": ""New Jenny Lind""</li>
<li>""city"": ""New Jerusalem""</li>
<li>...</li>
</ul>

<p>I have a class </p>

<pre><code>final class LocationStore: ObservableObject{
     @Published var List : [LocationModel] = []
     func search(q: String) {
         call backend search API and assign to List
     }

}
</code></pre>

<p>and I have search TextField in my view.</p>

<p>How to call search api and assign to my list when user type in search TextField. Need to show dropdown after type 3 character in TextField </p>
","6029177","","","","","2020-03-29 19:59:49","SwiftUI combine search text","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60919474","1","","","2020-03-29 19:12:14","","1","178","<p>On iOS 13 a <code>NSManagedObject</code>'s <code>objectWillChange</code> will emit when its property changes, but will not notify another <code>NSManagedObject</code> in the relationship.</p>

<p>My temporary workaround is the following:</p>

<pre><code>class Child: NSManagedObject {

    @NSManaged var parent: Parent?

    override func willSave() {
        super.willSave()
        if isUpdated {
            parent?.objectWillChange.send()
        }
    }
}
</code></pre>

<p>This works. But in my case the model is more complex:</p>

<pre><code>class Child: NSManagedObject {

    @NSManaged var parent: Parent?

    override func willSave() {
        super.willSave()
        if isUpdated {
            parent?.objectWillChange.send()
            // NOTE
            // how to let grandParents objectWillChange also omit? 
        }
    }
}

class Parent: NSManagedObject {

    @NSManaged var grandParents: Set&lt;GrandParent&gt;

    override func willSave() {
        super.willSave()
        // call grandParents forEach objectWillChange.send() if isUpdated
    }
}
</code></pre>

<p>At NOTE, I can iterate all <code>grandParent</code> of <code>parent</code> and send notification manually. But I believe there is a better, general solution can make that when an object is dirty, the parent will be marked dirty too. Then all object in the relationship will publish <code>objectWillChange</code> automatically. Is it possible?</p>
","6570854","","","","","2020-10-15 11:52:32","Let parent NSManagedObject's objectWillChange send value when relation object's property changed","<swift><core-data><combine>","1","1","","","","CC BY-SA 4.0"
"60926829","1","60935207","","2020-03-30 08:40:32","","0","283","<p>I have the following class, I want to test that if an object subscribed to ""elapsedTime"" published property, it will receive updates whenever the property changes.</p>

<pre><code>class SampleSegmentTimer {
    @Published var elapsedTime: DateComponents?
    private var subs = Set&lt;AnyCancellable&gt;()

    func start(tickingEvery interval: TimeInterval = 1) {
        Timer.publish(every: interval, on: .main, in: .common)
            .autoconnect()
            .map(transform)
            .assign(to: \.elapsedTime, on: self)
            .store(in: &amp;subs)
    }

    private func transform(_ date: Date) -&gt; DateComponents {
        // do some calculation
        DateComponents()
    }
}
</code></pre>

<p>I want to write test like the following:</p>

<pre><code>func testStart() {
        // Given
        let segmentTimer = SampleSegmentTimer()
        var elapsedTimes = [DateComponents?]()
        let elapsedTimeSub = segmentTimer.$elapsedTime.sink { elapsedTimes.append($0) }

        // When
        segmentTimer.start(tickEvery: 1) // I want to wait 3 seconds to let it tick 3 times

        // Then
        XCTAssertEqual(elapsedTimes.count, 3)
}
</code></pre>
","5929027","","5929027","","2020-03-30 10:57:17","2020-03-30 16:37:35","Is there a way to a @Published property that it's actually getting updated and publishing?","<swift><unit-testing><combine>","1","18","","","","CC BY-SA 4.0"
"60933304","1","60933745","","2020-03-30 14:55:04","","2","809","<p>I want to hide my <code>NavigationBar</code> while scrolling, actually It must hide automatically but when I tried with multiple views It doesn't work. Also, It works when I remove custom views and capsulate <code>List</code> with <code>NavigationView</code>. But I need <code>SearchBar</code> and <code>StatusView</code> view. Is there any suggestion? </p>

<p>By the way, I run it on the device, I use canvas here for demonstration purposes. </p>

<p>Thank you.</p>

<pre><code>var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                SearchBar(searchText: $viewModel.searchText)
                StatusView(status: $viewModel.status)
                Divider()
                List(0...viewModel.characters.results.count, id: \.self) { index in
                    if index == self.viewModel.characters.results.count {
                        LastCell(vm: self.viewModel)
                    } else {
                        ZStack {
                            NavigationLink(destination: DetailView(detail: self.viewModel.characters.results[index])) {
                                EmptyView()
                            }.hidden()
                            CharacterCell(character: self.viewModel.characters.results[index])
                        }
                    }
                }
                .navigationBarTitle(""Characters"", displayMode: .large)
            }

        }
        .onAppear {
            self.viewModel.getCharacters()
        }
    }
</code></pre>

<p><img src=""https://thumbs.gfycat.com/DelightfulSomberAnnelida-mobile.mp4"" alt=""image description""></p>
","6657192","","6657192","","2020-03-30 15:24:55","2020-08-21 19:58:05","SwiftUI NavigationBar not disappearing while scrolling","<ios><swift><uikit><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"60934884","1","60938897","","2020-03-30 16:19:35","","0","2669","<p>I would like to update some variables with values received when handling a newly published value. For example, given:  </p>

<pre><code>class ProductViewModel: ObservableObject {
    @Published var PublishedX: Int = 0
    @Published var PublishedY: Int = 0
    @Published var PublishedProduct: Int = 0
    // ...
    init() {
        productPublisher = Publishers.CombineLatest(external.XPublisher, internal.YPublisher)
            // .assignAndContinue(\.PublishedX, \.PublishedY) // something like this
            .flatMap(MyPublishers.secretMultiplication)
            .assign(to: \.PublishedProduct, on: self)
     }
 }
</code></pre>

<p>I would like to also assign the new values of XPublisher and YPublisher to variables (PublishedX and PublishedY respectively).</p>

<p>Is there a way to set these two variables and then continue handling the event?</p>
","24391","","24391","","2020-03-30 17:41:33","2021-04-23 15:39:43","Is there a way to call assign() more than once in Swift Combine?","<swift><combine><observableobject>","2","6","","","","CC BY-SA 4.0"
"60953183","1","","","2020-03-31 14:36:13","","3","1155","<p>I was reading this article: <a href=""https://www.raywenderlich.com/4161005-mvvm-with-combine-tutorial-for-ios"" rel=""nofollow noreferrer"">https://www.raywenderlich.com/4161005-mvvm-with-combine-tutorial-for-ios</a> on Ray Wenderlich about how to use combine. They have an example where it fetches data from an API but it doesn't handle HTTP status codes. I wanted to add it but so far I'm not able to do so.</p>

<p>According to this answer you could add a <code>tryMap</code> but then XCode starts showing errors like: <code>Generic parameter 'T' could not be inferred</code>. </p>

<p>Below the code:</p>

<pre class=""lang-swift prettyprint-override""><code>extension WeatherFetcher: WeatherFetchable {
  func weeklyWeatherForecast(
    forCity city: String
  ) -&gt; AnyPublisher&lt;WeeklyForecastResponse, WeatherError&gt; {
    return forecast(with: makeWeeklyForecastComponents(withCity: city))
  }

  private func forecast&lt;T&gt;(
    with components: URLComponents
  ) -&gt; AnyPublisher&lt;T, WeatherError&gt; where T: Decodable {
    guard let url = components.url else {
      let error = WeatherError.network(description: ""Couldn't create URL"")
      return Fail(error: error).eraseToAnyPublisher()
    }
    return session.dataTaskPublisher(for: URLRequest(url: url))
      .mapError { error in
        .network(description: error.localizedDescription)
    }
    .flatMap(maxPublishers: .max(1)) { pair in
      decode(pair.data)
    }
    .eraseToAnyPublisher()
  }
}
</code></pre>

<p>And I was trying to add</p>

<pre class=""lang-swift prettyprint-override""><code>.tryMap { data, response in
    guard let httpResponse = response as? HTTPURLResponse,
        200..&lt;300 ~= httpResponse.statusCode else {
            switch (response as! HTTPURLResponse).statusCode {
            case (400...499):
                throw ServiceErrors.internalError((response as! HTTPURLResponse).statusCode)
            default:
                throw ServiceErrors.serverError((response as! HTTPURLResponse).statusCode)
            }
    }
    return data
}
</code></pre>
","657666","","8447312","","2020-03-31 14:47:06","2020-03-31 15:36:39","Swift combine handling HTTP status code errors","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"60959771","1","","","2020-03-31 20:57:37","","1","47","<p>I have an Observable Object class to store a forecast object for my app</p>

<p>The class looks like this:</p>

<pre><code>final class ForecastData: ObservableObject {
    @Published var forecast: DarkSkyResponse

    public func getForecast(at location: CLLocation) {
        let request = DarkSkyRequest(key: ""KEYGOESHERE"")
        let point = DarkSkyRequest.Point(location.coordinate.latitude, location.coordinate.longitude)

        guard let url = request.buildURL(point: point) else {
            //Handle this better
            preconditionFailure(""Failed to construct URL"")
        }

        let task = URLSession.shared.dataTask(with: url) {
            data, response, error in

            DispatchQueue.main.async {
                guard let data = data else {
                    //Handle this better
                    fatalError(""No Data Recieved"")
                }
                guard let forecast = DarkSkyResponse(data: data) else {
                    //Handle this better
                    fatalError(""Decoding Failed"")
                }
                self.forecast = forecast
            }
        }
        task.resume()
    }

    init() {
        self.getForecast(at: CLLocation(latitude: 37.334987, longitude: -122.009066))
    }
}
</code></pre>

<p>The first part simply generates a URL to access the API by. Then I start a <code>URLSession</code> which downloads the data and then parses it into a <code>DarkSkyResponse</code> object. Finally I set the <code>@Published</code> variable to the forecast object. </p>

<p>My problem is when I call the function in the initialiser, I get an error because the forecast property is not initialised. What is the best way to get around this? Where should I call the function?
By the way I am using this class in my SwiftUI View using an <code>@ObservedObject</code> property wrapper</p>
","9682666","","","","","2020-04-01 07:20:53","Call Function in init that waits for properties to initialise","<ios><swift><class><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"60983172","1","60984945","","2020-04-02 02:04:24","","3","2205","<p>I'm struggling to learn SwiftUI and Combine syntax and am trying to understand how to create a reusable publisher that will check if a String is empty.</p>

<p>I've got a SwiftUI with 5 TextFields which using @Binding to connect them to my data model object.</p>

<pre><code>class DataWhatIsLoanPayment: ObservableObject {
    // Input
    @Published var pv = """"
    @Published var iyr = """"
    // a bunch more fields...

    // Output
    @Published var isvalidform = false
}
</code></pre>

<p>I want to enable the Calculate button once all of the fields are filled in (isEmpty == false). </p>

<p>I'm following along with <a href=""https://peterfriese.dev/swift-combine-love/"" rel=""nofollow noreferrer"">https://peterfriese.dev/swift-combine-love/</a>, and I was able to get my SwiftUI to properly enable/disable my Calculate button by creating an <code>isValidPVPublisher</code> and an <code>isValidIYRPublisher</code> and combing them in an <code>isValidFormPublisher</code>, like so:</p>

<pre><code>private var isValidPVPublisher: AnyPublisher&lt;Bool, Never&gt; {
    $pv
        .debounce(for: 0.8, scheduler: RunLoop.main)
        .removeDuplicates()
        .map { input in
            return input.isEmpty == false
        }
        .eraseToAnyPublisher()
}

private var isValidIYRPublisher: AnyPublisher&lt;Bool, Never&gt; {
    $iyr
        .debounce(for: 0.8, scheduler: RunLoop.main)
        .removeDuplicates()
        .map { input in
            return input.isEmpty == false
        }
        .eraseToAnyPublisher()
}


private var isValidFormPublisher: AnyPublisher&lt;Bool, Never&gt; {
    Publishers.CombineLatest(isValidPVPublisher, isValidIYRPublisher)
        .map { pvIsValid, iyrIsValid in
            return pvIsValid &amp;&amp; iyrIsValid
        }
        .eraseToAnyPublisher()
}

init() {        
    isValidFormPublisher
        .receive(on: RunLoop.main)
        .assign(to: \.isValidForm, on: self)
        .store(in: &amp;cancellableSet)
}
</code></pre>

<p>However, I'm going to have a lot more than 2 fields, and I'm going to have a lot of other forms in my app in which I will want to check if my fields are empty. And repeating <code>.debounce(for: 0.8, scheduler: RunLoop.main).removeDuplicates().map { input in return input.isEmpty == false }.eraseToAnyPublisher()</code> over and over again is a bad idea. </p>

<p>I want to create a reusable <code>NotEmptyPublisher</code>, or something like that, which takes a field binding, like my <code>$pv</code> and sets up the chain as show in the <code>isValidPVPublisher</code> above. So I can have something like:</p>

<pre><code>// Something like this, but I'm not sure of the syntax...
private var isValidPVPublisher = NotEmptyPublisher(field:$pv)
// instead of ...
private var isValidPVPublisher: AnyPublisher&lt;Bool, Never&gt; {
    $pv
        .debounce(for: 0.8, scheduler: RunLoop.main)
        .removeDuplicates()
        .map { input in
            return input.isEmpty == false
        }
        .eraseToAnyPublisher()
}
</code></pre>

<p>But I'm having a great deal of trouble parsing a lot of Swift syntax that I'm not familiar with and I can't seem to figure out how to do it, and every example I find on the web is just defining the publisher chain inline instead of in a reusable fashion. </p>

<p>Any help? How can I create a reusable publisher so that I don't have to repeat these inline publishers which all do the same thing?</p>
","416631","","","","","2020-04-03 22:01:46","SwiftUI and Combine, how to create a reusable publisher to check if a string is empty","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"60983230","1","","","2020-04-02 02:13:24","","2","643","<p>I perform many repeated requests in order to populate a field. I would like to cache the result and use the cached value the next time around.</p>

<pre><code>public func getItem(_ id: String) -&gt; AnyPublisher&lt;Item?, Never&gt; {
    if let item = itemCache[id] {
        return Just(item).eraseToAnyPublisher()
    }

    return downloadItem(id: id)
        .map { item in
            if let item = item {
                itemCache[id] = item
            }
            return item
        }
        .eraseToAnyPublisher()
    }
}

func downloadItem(_ id: String) -&gt; AnyPublisher&lt;Item?, Never&gt; { ... }
</code></pre>

<p>And this is called like this:</p>

<pre><code>Just([""a"", ""a"", ""a""]).map(getItem)
</code></pre>

<p>However, all the requests are calling <code>downloadItem</code>. <code>downloadItem</code> does return on the main queue. I also tried wrapping the entire <code>getItem</code> function into Deferred but that had the same result.</p>
","359532","","","","","2020-04-03 06:34:18","How to properly pull from cache before remote using swift combine","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"60988047","1","60988887","","2020-04-02 09:15:08","","5","693","<p>Given a List in SwiftUI, once panning begins, updating of views in the list seems to pause until the scrolling has been stopped. Is there a way to prevent this?</p>

<p>Consider the following code:</p>

<pre><code>class Model: ObservableObject, Identifiable {
    @Published var offset: CGFloat = 0

    let id = UUID()
    private var timer: Timer!

    init() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true, block: { _ in
            self.update()
        })
    }

    func update() {
        offset = CGFloat.random(in: 0...300)
    }
}

struct ContentView: View {
    @ObservedObject var model1 = Model()
    @ObservedObject var model2 = Model()
    @ObservedObject var model3 = Model()
    @ObservedObject var model4 = Model()

    var body: some View {
        List {
            ForEach([model1, model2, model3, model4]) {
                Rectangle()
                    .foregroundColor(.red)
                    .frame(width: $0.offset, height: 30, alignment: .center)
                    .animation(.default)
            }
        }
    }
}
</code></pre>

<p>Will result in this behaviour:</p>

<p><a href=""https://i.stack.imgur.com/49ten.gif"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/49ten.gif"" alt=""Video of result""></a></p>
","666211","","","","","2020-04-02 19:08:16","SwiftUI stops updates during scrolling of List","<swiftui><combine>","2","1","1","","","CC BY-SA 4.0"
"61000353","1","61003639","","2020-04-02 20:16:09","","0","92","<p>I am trying to trigger a download when my app becomes active, but I can't figure out how to do it.</p>

<p>This is my code</p>

<pre><code>NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification).map{ _ in
    return self.urlSession.dataTaskPublisher(for: url)
}
.tryMap{ element in
    guard let httpResponse = element.response as? HTTPURLResponse,
    httpResponse.statusCode == 200 else {
        throw URLError(.badServerResponse)
    }

.....
</code></pre>

<p>I have no idea how to get this to work. I constantly get a compile error stating:</p>

<p><code>Value of type 'URLSession.DataTaskPublisher' has no member 'response'</code></p>

<p>Why does my return statement return the complete publisher and not its result?</p>

<p>If I remove the <code>NotificationCenter</code> part and call <code>tryMap</code> directly on <code>dataTaskPublisher</code> like this:</p>

<pre><code>        self.urlSession.dataTaskPublisher(for: url)
        .tryMap{ element in

</code></pre>

<p>the compiler does not complain.</p>

<p>Pretty confused here :) </p>
","251824","","","","","2020-04-03 01:11:20","Using Combine to trigger download on app activation not compiling","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"61008563","1","61013742","","2020-04-03 09:13:17","","0","64","<p>i have this code, and if i set my published variable with +=, didSet will not be called. An explicit addition works, is this a bug or intended?</p>

<pre><code>import SwiftUI

class Model : ObservableObject {

    @Published var counter : Int = 0 {
        didSet {
            print(""did set called"")
        }
    }
}

struct ContentView: View {

    @EnvironmentObject var model : Model

    var body: some View {
        VStack {
            Text(""\(model.counter)"")
            Button(action: {
                print(""before"")
                self.model.counter += 1
                print(""after"")
            }) {
                Text(""Add +="")
            }
            Button(action: {
                print(""before"")
                self.model.counter = self.model.counter + 1
                print(""after explicit +"")
            }) {
                Text(""Add"")
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView().environmentObject(Model())
    }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/BF6F1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/BF6F1.png"" alt=""enter image description here""></a></p>
","8457280","","8457280","","2020-04-03 10:19:16","2020-04-03 14:08:43","is += not calling didSet, but explicit + does call it, a bug?","<swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"61020336","1","61021350","","2020-04-03 21:00:01","","0","721","<p>I'm using Combine to write a simple web scraper. I'm trying to map the returned data to a string of HTML, throwing <code>ScraperError</code>s at each possible failure point. At the end, I want to pass this string to my <code>htmlSubject</code>, which is a <code>PassthroughSubject&lt;String, ScraperError&gt;</code>, for further processing.</p>

<pre class=""lang-swift prettyprint-override""><code>    urlSubscription = URLSession.shared
            .dataTaskPublisher(for: url)
            .mapError { _ -&gt; ScraperError in // Explicitly stating my failure type is ScraperError
                ScraperError.unreachableSite
            }
            .tryMap { (data, response) -&gt; String in
                guard let html = String(data: data, encoding: .utf8) else {
                    throw ScraperError.readFailed
                }

                return html
            }
            .subscribe(htmlSubject) // &lt;-- Not allowed because failure type is now Error
</code></pre>

<p>However, I'm finding that <code>.tryMap</code> is erasing my <code>ScraperError</code> to a regular <code>Error</code>, preventing me from chaining my <code>htmlSubject</code> to the end:</p>

<blockquote>
  <p>Instance method 'subscribe' requires the types 'Error' and
  'ScraperError' be equivalent.</p>
</blockquote>

<p>Is there an obvious way around this that I'm missing, or am I getting tripped up conceptually? I'm thinking of this chain as building blocks in a large function that maps <code>&lt;(Data, URLResponse), URLError&gt;</code> to <code>&lt;String, ScraperError&gt;</code>. </p>

<p>Any help is appreciated.</p>
","2432804","","","","","2021-01-20 14:22:35","Preserving Failure Type with Combine's tryMap","<swift><reactive-programming><combine>","2","1","","","","CC BY-SA 4.0"
"61025239","1","","","2020-04-04 07:56:10","","0","146","<p>In a youtube video tutorial one thing caught my eye. I've created a really simple project in order to reproduce it. I know that design of the code is not perfect, but I wonder why code behaves like this in this particular situation.</p>

<p>file #1</p>

<pre><code>import SwiftUI

struct ContentView: View {

    @ObservedObject var viewModel = ViewModel()

    var body: some View {
        Text(viewModel.content).onAppear() {
            self.viewModel.subsribe()
        }
    }
}
</code></pre>

<p>file #2</p>

<pre><code>import Combine

class ViewModel: ObservableObject {

    private let model = Model()
    @Published var content: String = """"
    var subscription: AnyCancellable?

    func subsribe() {
        subscription = model.getPublisher().sink { value in
            self.content = value
        }
    }
}
</code></pre>

<p>file #3</p>

<pre><code>import Foundation
import Combine

class Model {

    func getPublisher() -&gt; AnyPublisher&lt;String, Never&gt; {
        Just(""Test"")
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>In this code everything works as expected. But if in the file #3 <code>class Model</code> change to <code>struct Model</code> it stops work!<br>
It's very strange, because... it seems not make any difference.</p>

<p>Hint #1<br>
In fact we still get the message from publisher. But the view doesn't update it.</p>

<p>Hint #2<br>
If we slightly change the code in file #2</p>

<pre><code>private let publisher = Model().getPublisher()

func subsribe() {
    subscription = publisher.sink { value in
        self.content = value
    }
}
</code></pre>

<p>It works in both cases (with <code>class</code> and with <code>struct</code>)</p>

<p>Hint #3 (edited due to the comment of @Sweeper)<br>
In file #2 if we take line of code <code>private let model = Model()</code> and move it to the bottom like this:  </p>

<pre><code>    class ViewModel: ObservableObject {

        @Published var content: String = """"
        var subscription: AnyCancellable?
        private let model = Model()

        func subsribe() {
            subscription = model.getPublisher().sink { value in
                self.content = value
            }
        }
    }
</code></pre>

<p>The code starts to work!!!<br>
Can anybody else reproduce this behaviour?</p>

<p>P. S.<br>
Link to the original video tutorial: <a href=""https://www.youtube.com/watch?v=olZra64Wz9E&amp;list=PLblCJtxTed706WzuhUwSmaR18BIlRHbZP"" rel=""nofollow noreferrer"">Video</a></p>
","2167345","","2167345","","2020-04-04 10:14:05","2020-04-04 10:14:05","Weird behaviour in swiftUI+Combine when class --> struct","<swift><swiftui><combine>","0","7","1","","","CC BY-SA 4.0"
"61034743","1","61044439","","2020-04-04 21:02:49","","2","654","<p>I'm dealing with a legacy libraries where I'm not at liberty to modify their code, and am trying to use Combine to weave them into something more easy to use. My situation is that a method call can either return a response, or a response and two notifications. The response-only is a success scenario, the response + 2 notifications is an error scenario. I want to combine both response and payload from the two notifications into an error that I can pass on to my app. The really fun thing is that I don't have a guarantee if the response or notifications come first, nor which of the notifications comes first. The notifications come in on a different thread than the response. The good thing is that they come in ""just about the same time"".</p>

<p>For handling a notification, I do</p>

<pre class=""lang-swift prettyprint-override""><code>firstNotificationSink = notificationCenter.publisher(for: .firstErrorPart, object: nil)
  .sink { [weak self] notification in
    // parse and get information about the error
  }

secondNotificationSink = notificationCenter.publisher(for: .secondErrorPart, object: nil)
  .sink { [weak self] notification in
    // parse and get more information about the error
  }
</code></pre>

<p>and asking the legacy library for a response is:</p>

<pre class=""lang-swift prettyprint-override""><code>func doJob() -&gt; String {
  let resultString = libDoStuff(reference)
}
</code></pre>

<p>Is there a way for me to use Combine to merge these three signals into one, given i.e. a 50ms timeframe? Meaning, if I get the result and two notifications, I have an error response I can pass on to my app, and if I have only the result and no notifications arrived in 50ms, then I can pass that success response to my app?</p>
","80246","","","","","2020-04-05 14:55:43","Swift Combine: combining three signals into one","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"61037051","1","","","2020-04-05 01:45:44","","3","11889","<p><strong>TL;DR</strong></p>

<p>I want to delay a publication, but can't figure out how to, er, combine the parts</p>

<p><strong>In Brief</strong></p>

<p>I have a <code>Publisher</code> </p>

<pre><code>let generator = PassthroughSubject&lt;Bool, Never&gt;()
</code></pre>

<p>and want somehow to use the modifier </p>

<pre><code>.delay(for: 2, scheduler: RunLoop.main)
</code></pre>

<p>so that when I call</p>

<pre><code>generator.send(true)
</code></pre>

<p>the message is sent two seconds after the call to <code>send()</code></p>

<p>Looking at the docs for <a href=""https://developer.apple.com/documentation/combine/publishers/delay"" rel=""nofollow noreferrer""><code>Publishers.Delay</code></a> made the type error more clear, but doesn't help me to find the right way to hook things up.</p>

<p><strong>Code</strong></p>

<pre><code>import SwiftUI
import Combine

// Exists just to subscribe.
struct ContainedView : View {
    private let publisher: AnyPublisher&lt;Bool, Never&gt;
    init(_ publisher: AnyPublisher&lt;Bool, Never&gt; = Just(false).dropFirst().eraseToAnyPublisher()) {
        self.publisher = publisher
    }
    var body: some View {
        Rectangle().onReceive(publisher) { _ in print(""Got it"") }
    }
}

struct ContentView: View {
    let generator = PassthroughSubject&lt;Bool, Never&gt;()
                 // .delay(for: 2, scheduler: RunLoop.main)
                 // Putting it here doesn't work either.

    var body: some View {
        VStack {
            Button(""Tap"") {

                // Does not compile
                self.generator.delay(for: 2, scheduler: RunLoop.main).send(true)
                // Value of type 'Publishers.Delay&lt;PassthroughSubject&lt;Bool, Never&gt;, RunLoop&gt;' has no member 'send'
                // https://developer.apple.com/documentation/combine/publishers/delay

                // Does not compile
                self.generator.send(true).delay(for: 2, scheduler: RunLoop.main)
                // Value of tuple type '()' has no member 'delay'

                // Just a broken-up version of the first try.
                let delayed = self.generator.delay(for: 2, scheduler: RunLoop.main)
                delayed.send(true)

                // This, of course, builds and works.
                self.generator.send(true)
                print(""Sent it"")
            }

            ContainedView(generator.eraseToAnyPublisher())
            .frame(width: 300, height: 200)
        }
    }
}
</code></pre>
","2333941","","","","","2021-11-01 06:12:59","Swift Combine - delaying a publisher","<delay><publish-subscribe><combine>","3","0","0","","","CC BY-SA 4.0"
"61050314","1","61052839","","2020-04-05 22:21:44","","0","129","<p>I'm somewhat new to Combine and reactive programming in general. I think I've come across two different ways to do the same thing, but I'm wondering why I should chose one over the other.</p>

<p>I have a simple model that stores and publishes values related to the Apple Watch status. Below are the two different ways I think I'm doing the same thing.</p>

<p>In this first approach, I'm using a separate <code>AnyCancellable?</code> for each <code>Publisher</code>:</p>

<pre><code>class WatchConnectivityModel: ObservableObject {

    init() {
        activationState = WCSession.default.activationState
        isWatchAppInstalled = WCSession.default.isWatchAppInstalled
        isComplicationEnabled = WCSession.default.isComplicationEnabled

        assignPublishers()
    }

    @Published var activationState: WCSessionActivationState
    @Published var isWatchAppInstalled: Bool
    @Published var isComplicationEnabled: Bool

    private var activationStateStream: AnyCancellable?
    private var isWatchAppInstalledStream: AnyCancellable?
    private var isComplicationEnabledStream: AnyCancellable?

    private func assignPublishers() {
        activationStateStream = WCSession.default
            .publisher(for: \.activationState)
            .receive(on: RunLoop.main)
            .assign(to: \.activationState, on: self)

        isWatchAppInstalledStream = WCSession.default
            .publisher(for: \.isWatchAppInstalled)
            .receive(on: RunLoop.main)
            .assign(to: \.isWatchAppInstalled, on: self)

        isComplicationEnabledStream = WCSession.default
            .publisher(for: \.isComplicationEnabled)
            .receive(on: RunLoop.main)
            .assign(to: \.isComplicationEnabled, on: self)
    }
}
</code></pre>

<p>Here is my second approach, but instead of separate <code>AnyCancellable?</code> objects I'm using a single <code>Set&lt;AnyCancellable&gt;</code> along with <code>.store(in: &amp;self.cancellableSet)</code> on each <code>Publisher</code>:</p>

<pre><code>class WatchConnectivityModel: ObservableObject {

    init() {
        activationState = WCSession.default.activationState
        isWatchAppInstalled = WCSession.default.isWatchAppInstalled
        isComplicationEnabled = WCSession.default.isComplicationEnabled

        assignPublishers()
    }

    @Published var activationState: WCSessionActivationState
    @Published var isWatchAppInstalled: Bool
    @Published var isComplicationEnabled: Bool

    private var cancellableSet: Set&lt;AnyCancellable&gt; = []

    private func assignPublishers() {
        _ = WCSession.default
            .publisher(for: \.activationState)
            .receive(on: RunLoop.main)
            .assign(to: \.activationState, on: self)
            .store(in: &amp;self.cancellableSet)

        _ = WCSession.default
            .publisher(for: \.isWatchAppInstalled)
            .receive(on: RunLoop.main)
            .assign(to: \.isWatchAppInstalled, on: self)
            .store(in: &amp;self.cancellableSet)

        _ = WCSession.default
            .publisher(for: \.isComplicationEnabled)
            .receive(on: RunLoop.main)
            .assign(to: \.isComplicationEnabled, on: self)
            .store(in: &amp;self.cancellableSet)
    }
}
</code></pre>

<p>I'm guessing that the first approach would be better if I need to manually do something to one of the three specific streams, however I don't need to in this case. Other than that, is there anything that makes one of these approaches a better choice than the other? Is there anything major that I'm missing when it comes to memory management going with one over the other?</p>

<p>The second one seems a little weird to me because of the whole <code>_ =</code> part, because that seems like an extra artifact that's hard to explain: why am I assigning this whole thing to nothing? The first option avoids that possible confusion.</p>
","241163","","","","","2020-04-06 04:10:27","Which is better when creating multiple Publishers in Combine? AnyCancellable for each or Set<AnyCancellable> with .store(in: &self.cancellableSet)?","<ios><combine>","1","0","","","","CC BY-SA 4.0"
"61056787","1","66943597","","2020-04-06 09:35:11","","10","2315","<p>I'm seeing some struct vs class behavior that I don't really don't understand, when trying to assign a value using Combine.</p>

<p>Code:</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

struct Passengers {
  var women = 0
  var men = 0
}

class Controller {
  @Published var passengers = Passengers()
  var cancellables = Set&lt;AnyCancellable&gt;()
  let minusButtonTapPublisher: AnyPublisher&lt;Void, Never&gt;

  init() {
    // Of course the real code has a real publisher for button taps :)
    minusButtonTapPublisher = Empty&lt;Void, Never&gt;().eraseToAnyPublisher()

    // Works fine:
    minusButtonTapPublisher
      .map { self.passengers.women - 1 }
      .sink { [weak self] value in
        self?.passengers.women = value
      }.store(in: &amp;cancellables)

    // Doesn't work:
    minusButtonTapPublisher
      .map { self.passengers.women - 1 }
      .assign(to: \.women, on: passengers)
      .store(in: &amp;cancellables)
  }
}
</code></pre>

<p>The error I get is <code>Key path value type 'ReferenceWritableKeyPath&lt;Passengers, Int&gt;' cannot be converted to contextual type 'WritableKeyPath&lt;Passengers, Int&gt;'</code>.</p>

<p>The version using <code>sink</code> instead of <code>assign</code> works fine, and when I turn <code>Passengers</code> into a class, the <code>assign</code> version also works fine. My question is: why does it only work with a class? The two versions (sink and assign) really do the same thing in the end, right? They both update the <code>women</code> property on <code>passengers</code>.</p>

<p>(When I do change <code>Passengers</code> to a class, then the <code>sink</code> version no longer works though.)</p>
","403425","","403425","","2020-04-06 09:41:19","2022-08-23 10:09:38","Combine: can't use `.assign` with structs - why?","<swift><combine>","2","8","1","","","CC BY-SA 4.0"
"61057938","1","","","2020-04-06 10:41:52","","0","318","<p>I'm building a reusable custom stepper view.</p>

<p><a href=""https://i.stack.imgur.com/sQLpM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sQLpM.png"" alt=""enter image description here""></a></p>

<p>I have it all working, and am using Combine for observing value changes. However, I'd like to improve it by using two-way databinding, but not sure if that is possible?</p>

<p>Here is my current code:</p>

<pre class=""lang-swift prettyprint-override""><code>class Stepper: UIView {
  override init(frame: CGRect) {
    super.init(frame: frame)
    setup()
  }

  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }

  @Published var count = 0

  private let stackView = UIStackView()
  private let minusButton = BorderedRoundButton()
  private let plusButton = BorderedRoundButton()
  private let countLabel = UILabel()
  private var cancellables = Set&lt;AnyCancellable&gt;()

  func setup() {
    translatesAutoresizingMaskIntoConstraints = false
    stackView.translatesAutoresizingMaskIntoConstraints = false

    stackView.axis = .horizontal

    minusButton.setTitleColor(.primaryTint, for: .normal)
    plusButton.setTitleColor(.primaryTint, for: .normal)

    minusButton.setTitle(""-"", for: .normal)
    plusButton.setTitle(""+"", for: .normal)

    countLabel.text = ""0""
    countLabel.textColor = .blackText
    countLabel.font = .preferredFont(forTextStyle: .body)
    countLabel.textAlignment = .center

    stackView.addArrangedSubview(minusButton)
    stackView.addArrangedSubview(countLabel)
    stackView.addArrangedSubview(plusButton)

    minusButton.tapPublisher.sink { [weak self] _ in
      self?.count -= 1
    }.store(in: &amp;cancellables)

    plusButton.tapPublisher.sink { [weak self] _ in
      self?.count += 1
    }.store(in: &amp;cancellables)

    $count.map { ""\($0)"" }.assign(to: \.text, on: countLabel).store(in: &amp;cancellables)
    $count.map { $0 &gt; 0 }.assign(to: \.isEnabled, on: minusButton).store(in: &amp;cancellables)

    addSubview(stackView)

    NSLayoutConstraint.activate([
      minusButton.widthAnchor.constraint(equalToConstant: 38),
      minusButton.heightAnchor.constraint(equalToConstant: 38),

      plusButton.widthAnchor.constraint(equalToConstant: 38),
      plusButton.heightAnchor.constraint(equalToConstant: 38),

      countLabel.widthAnchor.constraint(equalToConstant: 44),

      stackView.leadingAnchor.constraint(equalTo: leadingAnchor),
      stackView.trailingAnchor.constraint(equalTo: trailingAnchor),
      stackView.topAnchor.constraint(equalTo: topAnchor),
      stackView.bottomAnchor.constraint(equalTo: bottomAnchor),
    ])
  }
}
</code></pre>

<p>And I am using it like this:</p>

<pre class=""lang-swift prettyprint-override""><code>class PickerViewController: UIViewController {
  @IBOutlet private var stepper: Stepper!
  private var cancellables = Set&lt;AnyCancellable&gt;()

  @Published var count = 0

  override func viewDidLoad() {
    super.viewDidLoad()

    stepper.count = count

    stepper.$count.sink { [weak self] value in
      self?.count = value
    }.store(in: &amp;cancellables)
  }
}
</code></pre>

<p>And that is the bit I want to improve: I now need to both set the initial value and then observe the changes. I know it's hardly a lot of code, but I am just wondering if I can do it in one line, with a sort of two-way databinding?</p>

<p>I thought about using SwiftUI's <code>@Bindable</code> propertywrapper (or a rebuilt version of it as to not have to import SwiftUI), so that <code>PickerViewController.count</code> is the one source, and the Stepper would automatically update it. However, then I have the problem that <code>@Bindable</code> is not observable itself, so these lines would no longer work:</p>

<pre class=""lang-swift prettyprint-override""><code>$count.map { ""\($0)"" }.assign(to: \.text, on: countLabel).store(in: &amp;cancellables)
$count.map { $0 &gt; 0 }.assign(to: \.isEnabled, on: minusButton).store(in: &amp;cancellables)
</code></pre>

<p>So my question is: can I improve the code to use two-way databinding, or should I just stick with setting the value and then observing it separately?</p>
","403425","","","","","2020-04-06 10:41:52","Two-way databinding using Combine","<swift><combine>","0","5","","","","CC BY-SA 4.0"
"61102801","1","61106205","","2020-04-08 14:12:54","","9","1708","<p>I'm using a <code>dataTaskPublisher</code> to fetch some data:</p>

<pre><code>func downloadData(_ req: URLRequest) {
  self.cancelToken = dataTaskPublisher(for: req).sink { /* ... */ }
}
</code></pre>

<p>If the function is called while the request is in progress, I would like to return.</p>

<p>Currently I either:<br>
1. Set the <code>cancelToken</code> to nil in the sink or<br>
2. Crate and manage a <code>isDownloading</code> variable.  </p>

<p>Is there a built-in way to check if the <code>dataTaskPublisher</code> is running (and optionally its progress)? </p>
","24391","","12299030","","2020-04-08 14:29:36","2020-04-11 16:36:16","How do I check the current progress of URLSession.dataTaskPublisher?","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"61104725","1","","","2020-04-08 15:47:59","","2","131","<p>I've already submitted a bug report to Apple (#7654122), but I'm hoping someone might know of a workaround because at this point I'm stuck on my project and can't make forward progress. </p>

<pre><code>class BaseData: ObservableObject {
    @Published var pmtstr = """" // &lt;-- here

    // ... bunch of other stuff
}

class DataWhatIsLoanPayment: BaseData {
    // ... other stuff

    override func calculate() {
        super.calculate()

        // ... other stuff

        self.pmtstr = ""stuff"" // &lt;-- here
    }
}
</code></pre>

<p>When I set <code>self.pmtstr = ""stuff""</code> and try to compile, the compiler crashes with Abort Trap 6. If I comment out that line, the app compiles correctly.</p>

<p>If I remove the <code>@Published</code> from the initial declaration of <code>pmtstr</code>, then the app compiles correctly. If I put the <code>@Published</code> back, the compiler crashes with Abort Trap 6. </p>

<p>I need to be able to update this string and publish the results of the calculation in order to make forward progress on developing this app. </p>

<p>Any suggestions for a workaround (or a fix)?</p>
","416631","","","","","2020-04-08 15:47:59","Swift Abort Trap 6 during compile caused by putting a value in @Published String","<swift><swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"61108947","1","","","2020-04-08 19:53:43","","12","14663","<p>My app contains a resource heavy operation that populates an Array based on data pulled from an XML feed. I do not want this operation to lock up the main thread (and the UI when the array is given new data), so it's done in the background. </p>

<pre><code>    let dispatchQueue = DispatchQueue(label: ""concurrent.queue"", qos: .utility, attributes: .concurrent)
    class XMLHandler: ObservableObject {
    let context: NSManagedObjectContext
    @Published var myArray: [CustomObject] = []
     init(context: NSManagedObjectContext) {
        self.context = context
    }
    ...some code...
      func populateArray {
      dispatchQueue.async {
       ...xml parsing happens...
       (xmlOutputObject) in 
          for x in xmlOutputObject {
                            self.myArray.append(x) }
    }
</code></pre>

<p>Elsewhere, my SwiftUI View uses myArray to populate it's List:</p>

<pre><code>struct MyView: View {

 @EnvironmentObject var handler: XMLHandler
    var body: some View {
            List{
                ForEach(handler.myArray) { CustomObject in
              ... generate rows ...
                    }
                }
            }
</code></pre>

<p>My error on runtime occurs when my app tries to update @Published var myArray: [CustomObject] = [].</p>

<p><strong>Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.</strong></p>

<p>I know this is something to do with adopting Combine, but I honestly have no idea where to start. Any help would be appreciated.</p>

<p>I simply want the following to happen:</p>

<ol>
<li>User presses button that initiates the XML data pull that populates myArray</li>
<li>myArray is populated on background thread, keeping UI responsive</li>
<li>List in MyView automatically updates upon task completion. At present, I have to navigate away from the view and back again for the List to refresh.</li>
</ol>
","5466589","","","","","2021-11-20 10:49:00","SwiftUI - make sure to publish values from the main thread (via operators like receive(on:)) on model updates","<swiftui><combine>","4","0","3","","","CC BY-SA 4.0"
"61115014","1","61115238","","2020-04-09 06:14:41","","2","946","<p>I'm trying to understand the Combine methodology of making a JSON network call. I'm
clearly missing something basic.</p>

<p>The closest I get fails with the URLSession cancelled.</p>

<pre><code>class NoteDataStore: ObservableObject {

    @Published var notes: [MyNote] = []

    init() {
        getWebserviceNotes()
    }

    func getWebserviceNotes() {

        let pub = Webservice().fetchNotes()
            .sink(receiveCompletion: {_ in}, receiveValue: { (notes) in
            self.notes = notes
            })
        }
    }
}//class
</code></pre>

<p>The data element:</p>

<pre><code>struct MyNote: Codable, Identifiable {
    let id = UUID()
    var title: String
    var url: String
    var thumbnailUrl: String

    static var placeholder: MyNote {
        return MyNote(title: ""No Title"", url: """", thumbnailUrl: """")
    }
}
</code></pre>

<p>The network setup:</p>

<pre><code>class Webservice {
    func fetchNotes() -&gt; AnyPublisher&lt;[MyNote], Error&gt; {
        let url = ""https://jsonplaceholder.typicode.com/photos""
        guard let notesURL = URL(string: url) else { fatalError(""The URL is broken"")}

        return URLSession.shared.dataTaskPublisher(for: notesURL)
            .map { $0.data }
            .decode(type: [MyNote].self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>The console output is:</p>

<blockquote>
  <p>Task &lt;85208F00-BC24-44AA-B644-E0398FE263A6>.&lt;1> finished with error
  [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled""
  UserInfo={NSErrorFailingURLStringKey=<a href=""https://jsonplaceholder.typicode.com/photos"" rel=""nofollow noreferrer"">https://jsonplaceholder.typicode.com/photos</a>,
  NSLocalizedDescription=cancelled,
  NSErrorFailingURLKey=<a href=""https://jsonplaceholder.typicode.com/photos"" rel=""nofollow noreferrer"">https://jsonplaceholder.typicode.com/photos</a>}</p>
</blockquote>

<p>Any guidance would be appreciated. Xcode 11.4</p>
","2698617","","12299030","","2020-04-09 06:33:43","2020-04-09 18:53:07","SwiftUI Combine URLSession JSON Network Call","<ios><json><xcode><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"61116079","1","61116276","","2020-04-09 07:33:09","","0","210","<p>I am very new to Combine and I am trying to get two SwiftUI sliders to update to and from a third value which represents the ‘single source of truth’ for their respective values. </p>

<p>Each slider has a range from 0…1 but uses a different function to determine its value. In the example below, if the true value is 0.5, the first slider sets and gets that directly (0.5) while the second slider uses the value squared (0.25). </p>

<p>The example works, but I get the impression that this isn’t really the proper way to do it. I get infinite recursion if the guard statements are removed in the Model. Can anyone show me the correct way to do this? Thanks!</p>

<p>Here is the Model:</p>

<pre><code>import SwiftUI

class Model : ObservableObject{

    @Published var trueValue: CGFloat = 0{
        didSet{
            slider1Value = trueValue
            slider2Value = trueValue * trueValue
        }
    }

    @Published var slider1Value: CGFloat = 0{
        didSet{
            guard oldValue != slider1Value else { return }

            trueValue = slider1Value
        }
    }

    @Published var slider2Value: CGFloat = 0{
        didSet{
            guard oldValue != slider2Value else { return }

            trueValue = slider2Value.squareRoot()
        }
    }
}

</code></pre>

<p>Here is the ContentView:</p>

<pre><code>
struct ContentView: View {
    @EnvironmentObject var model: Model

    var body: some View {
        GeometryReader{ geometry in
            VStack{
                ProportionalSlider(value: self.$model.slider1Value, width: geometry.size.width - 20)
                    .frame(width: geometry.size.width, height: 18)
                ProportionalSlider(value: self.$model.slider2Value, width: geometry.size.width - 20)
                    .frame(width: geometry.size.width, height: 18)
            }
        }
    }
}

</code></pre>

<p>And here is the ProportionalSlider:</p>

<pre><code>
struct ProportionalSlider: View {
    @Binding var value: CGFloat
    var width: CGFloat

    var body: some View{
        let gesture =  DragGesture(minimumDistance: 0)
            .onChanged({ mouse in         
                let clamped = min(self.width, max(0, mouse.location.x))
                self.value = clamped/self.width
            })

        return GeometryReader{ geometry in
            ZStack{
                ZStack(alignment: .leading){
                    Capsule().fill(Color.blue).frame(width: self.width, height: 15)
                       .gesture(gesture)
                    Capsule().fill(Color.red).frame(width: self.value * self.width, height: 15)
                       .gesture(gesture)
                }
            }
        }
    }
}

</code></pre>
","2234184","","","","","2020-04-09 08:20:49","How to get two SwiftUI sliders to update to and from a third value which represents the ‘single source of truth’ for their respective values","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61128355","1","","","2020-04-09 18:58:36","","1","822","<p>I am using the Combine Future to wrap around an async block operation and adding a subscriber to that publisher to receive the values.. I am noticing the future object is not getting deallocated, even after the subscribers are deallocated. The XCode memory graph and instruments leaks graph itself shows no reference to these future objects. I am puzzled why are they still around.</p>
<pre><code>   func getUsers(forceRefresh: Bool =  false) -&gt; AnyPublisher&lt;[User], Error&gt; {
        let future = Future&lt;[User], Error&gt; { [weak self] promise in
            guard let params = self?.params else {
                promise(.failure(CustomErrors.invalidData))
                return
            }
            
            self?.restApi.getUsers(params: params, forceRefresh: forceRefresh, success: { (users: [User]?, _) in
                guard let users = users else {
                    return promise(.failure(CustomErrors.invalidData))
                }
                
                promise(.success(users))
            }) { (error: Error) in
                promise(.failure(error))
            }
        }
        
        return future.eraseToAnyPublisher()
   }
</code></pre>
<p>Here's how I am adding a subscription:</p>
<pre><code>   self.userDataService?.getUsers(forceRefresh: forceRefresh)
        .sink(receiveCompletion: { [weak self] completion in
            self?.isLoading = false
            if case let .failure(error) = completion {
                self?.publisher.send(.error(error))
                return
            }
            
            guard let users = self?.users, !users.isEmpty else {
                self?.publisher.send(.empty)
                return
            }
            
            self?.publisher.send(.data(users))
        }) { [weak self] (response: Array&lt;User&gt;) in
            self?.users = response
    }.store(in: &amp;self.subscribers)

    deinit {
        self.subscribers.removeAll()
    }
</code></pre>
<p>This is the screenshot of the leaked memory for the future that got created above.. It's still staying around even after the subscribers are all deleted. Instruments is also showing a similar memory graph. Any thoughts on what could be causing this ??</p>
<p><a href=""https://i.stack.imgur.com/V2XP6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/V2XP6.png"" alt=""enter image description here"" /></a></p>
","9421473","","-1","","2020-06-20 09:12:55","2021-01-03 12:37:37","Combine Future Publisher is not getting deallocated","<ios><swift><combine>","1","4","","","","CC BY-SA 4.0"
"61143246","1","61162973","","2020-04-10 15:12:23","","3","274","<p>Suppose I have a custom subscriber that requests one value on subscription and then an additional value three seconds after it receives the previous value:</p>

<pre><code>class MySubscriber: Subscriber {
    typealias Input = Int
    typealias Failure = Never

    private var subscription: Subscription?

    func receive(subscription: Subscription) {
        print(""Subscribed"")

        self.subscription = subscription
        subscription.request(.max(1))
    }

    func receive(_ input: Int) -&gt; Subscribers.Demand {
        print(""Value: \(input)"")

        DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(3)) {
            self.subscription?.request(.max(1))
        }

        return .none
    }

    func receive(completion: Subscribers.Completion&lt;Never&gt;) {
        print(""Complete"")
        subscription = nil
    }
}
</code></pre>

<p>If I use this to subscribe to an infinite range publisher, back pressure is handled gracefully, with the publisher waiting 3 seconds each time until it receives the next demand to send a value:</p>

<pre><code>(1...).publisher.subscribe(MySubscriber())

// Prints values infinitely with ~3 seconds between each:
//
//     Subscribed
//     Value: 1
//     Value: 2
//     Value: 3
//     ...
</code></pre>

<p>But if I add a <code>map</code> operator then <code>MySubscriber</code> never even receives a subscription; <code>map</code> appears to have synchronously requested <code>Demand.Unlimited</code> upon receiving its subscription and the app infinitely spins as <code>map</code> tries to exhaust the infinite range:</p>

<pre><code>(1...).publisher
    .map { value in
        print(""Map: \(value)"")
        return value * 2
    }
    .subscribe(MySubscriber())

// The `map` transform is executed infinitely with no delay:
//
//     Map: 1
//     Map: 2
//     Map: 3
//     ...
</code></pre>

<p>My question is, why does <code>map</code> behave this way? I would have expected <code>map</code> to just pass its downstream demand to the upstream. Since <code>map</code> is supposed to be for transformation rather than side effects, I don't understand what the use case is for its current behavior.</p>

<h1>EDIT</h1>

<p>I implemented a version of map to show how I think it ought to work:</p>

<pre><code>extension Publishers {
    struct MapLazily&lt;Upstream: Publisher, Output&gt;: Publisher {
        typealias Failure = Upstream.Failure

        let upstream: Upstream
        let transform: (Upstream.Output) -&gt; Output

        init(upstream: Upstream, transform: @escaping (Upstream.Output) -&gt; Output) {
            self.upstream = upstream
            self.transform = transform
        }

        public func receive&lt;S: Subscriber&gt;(subscriber: S) where S.Input == Output, S.Failure == Upstream.Failure {
            let mapSubscriber = Subscribers.LazyMapSubscriber(downstream: subscriber, transform: transform)
            upstream.receive(subscriber: mapSubscriber)
        }
    }
}

extension Subscribers {
    class LazyMapSubscriber&lt;Input, DownstreamSubscriber: Subscriber&gt;: Subscriber {
        let downstream: DownstreamSubscriber
        let transform: (Input) -&gt; DownstreamSubscriber.Input

        init(downstream: DownstreamSubscriber, transform: @escaping (Input) -&gt; DownstreamSubscriber.Input) {
            self.downstream = downstream
            self.transform = transform
        }

        func receive(subscription: Subscription) {
            downstream.receive(subscription: subscription)
        }

        func receive(_ input: Input) -&gt; Subscribers.Demand {
            downstream.receive(transform(input))
        }

        func receive(completion: Subscribers.Completion&lt;DownstreamSubscriber.Failure&gt;) {
            downstream.receive(completion: completion)
        }
    }
}

extension Publisher {
    func mapLazily&lt;Transformed&gt;(transform: @escaping (Output) -&gt; Transformed) -&gt; AnyPublisher&lt;Transformed, Failure&gt; {
        Publishers.MapLazily(upstream: self, transform: transform).eraseToAnyPublisher()
    }
}
</code></pre>

<p>Using this operator, <code>MySubscriber</code> receives the subscription immediately and the <code>mapLazily</code> transform is only executed when there is demand:</p>

<pre><code>(1...).publisher
    .mapLazily { value in
        print(""Map: \(value)"")
        return value * 2
    }
    .subscribe(MySubscriber())

// Only transforms the values when they are demanded by the downstream subscriber every 3 seconds:
//
//     Subscribed
//     Map: 1
//     Value: 2
//     Map: 2
//     Value: 4
//     Map: 3
//     Value: 6
//     Map: 4
//     Value: 8
</code></pre>

<p>My guess is that the particular overload of <code>map</code> defined for <code>Publishers.Sequence</code> is using some kind of shortcut to enhance performance. This breaks for infinite sequences, but even for finite sequences eagerly exhausting the sequence regardless of the downstream demand messes with my intuition. In my view, the following code:</p>

<pre><code>(1...3).publisher
    .map { value in
        print(""Map: \(value)"")
        return value * 2
    }
    .subscribe(MySubscriber())
</code></pre>

<p>ought to print:</p>

<pre><code>Subscribed
Map: 1
Value: 2
Map: 2
Value: 4
Map: 3
Value: 6
Complete
</code></pre>

<p>but instead prints:</p>

<pre><code>Map: 1
Map: 2
Map: 3
Subscribed
Value: 2
Value: 4
Value: 6
Complete
</code></pre>
","642233","","642233","","2020-04-11 19:20:32","2020-04-13 13:14:15","Why does `Publishers.Map` consume upstream values eagerly?","<swift><combine><backpressure>","1","4","","","","CC BY-SA 4.0"
"61145309","1","61293161","","2020-04-10 17:17:53","","0","388","<p>I'm relatively new to reactive programming concepts, and I'm trying to build a simple view model to update <code>@Published Bool</code> values that are used to keep UI updated with SwiftUI.</p>

<p>This particular model is setting up those <code>Bool</code> values based on other values from the <code>WatchConnectivity</code> framework as they change over time.</p>

<p>Even though this is a simple example and it's working, I feel like I'm missing opportunities to reduce redundancy.</p>

<p>Specifically, it feels weird that I am repeating the logic used to set up the initial values of <code>appNotInstalled</code> and <code>complicationNotInstalled</code> later when I use <code>Publishers.CombineLatest</code> and <code>Publishers.CombineLatest3</code>.</p>

<p>Even though the initial values are passed through the publishers, so they go through the <code>CombineLatest</code> pipelines and set the initial values, it feels wrong to arbitrarily set the published variables to <code>true</code> or <code>false</code>, but the compiler is making me set initial values for them somewhere.</p>

<p>If I don't set initial values, I get the <code>Variable 'self.appNotInstalled' used before being initialized</code> error.</p>

<p>Is there a way I can avoid setting initial values, without making them nil, or another way to avoid duplicating the logic used to determine their values?</p>

<p>Here's the working code I have:</p>

<pre><code>class WatchConnectivityModel: ObservableObject {

    // values used to show/hide UI
    @Published var appNotInstalled: Bool
    @Published var complicationNotInstalled: Bool

    private var cancellables: [AnyCancellable] = []

    init() {

        // initialize based on the values of everything at class init
        let activated = WCSession.default.activationState == .activated
        let appInstalled = WCSession.default.isWatchAppInstalled
        let complicationInstalled = WCSession.default.isComplicationEnabled
        appNotInstalled = !(activated &amp;&amp; appInstalled)
        complicationNotInstalled = activated &amp;&amp; appInstalled &amp;&amp; !complicationInstalled

        // set up the publishers for any changes
        let activationStatePublisher = WCSession.default.publisher(for: \.activationState)
        let isWatchAppInstalledPublisher = WCSession.default
            .publisher(for: \.isWatchAppInstalled)
        let isComplicationEnabledPublisher = WCSession.default
            .publisher(for: \.isComplicationEnabled)

        // set up assignment of appNotInstalled for changes
        Publishers.CombineLatest(activationStatePublisher.removeDuplicates(),
                                 isWatchAppInstalledPublisher.removeDuplicates())
            .map { (state, installed) in
                // repeated logic from above
            return !(state == .activated &amp;&amp; installed)
        }.receive(on: RunLoop.main)
            .assign(to: \.appNotInstalled, on: self)
            .store(in: &amp;cancellables)

        // set up assignment of complicationNotInstalled for changes
        Publishers.CombineLatest3(activationStatePublisher.removeDuplicates(),
                                  isWatchAppInstalledPublisher.removeDuplicates(),
                                  isComplicationEnabledPublisher.removeDuplicates())
            .map { (state, appInstalled, complicationInstalled) in
                // repeated logic again
                return state == .activated &amp;&amp; appInstalled &amp;&amp; !complicationInstalled
        }.receive(on: RunLoop.main)
            .assign(to: \.complicationNotInstalled, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
","241163","","241163","","2020-04-18 17:19:43","2020-04-18 17:19:43","Using Combine to set up Publishers and while also satisfying requirement for initial values on non-nil variables","<swift><swiftui><combine><watchconnectivity>","1","4","","","","CC BY-SA 4.0"
"61147014","1","","","2020-04-10 19:07:02","","5","3784","<p>I am implementing a library with a Login function using Swift Combine.</p>

<p>With the following code, I am already able to login, serialize the response to an object AuthenticationResult, and return a Publisher with a User or ApiError as a result.</p>

<p>As part of the response (AuthenticationResult object), I am also getting an accessToken from the API. I would like to save that token locally as part of this stream.
But I would like that to be done internally in the library, so that the response from the login function does not change.</p>

<p>Is there a way to handle this type of situations in the stream, to handle the event but then to continue with the stream to return an User?</p>

<pre><code>func authenticate(username: String, password: String) -&gt; AnyPublisher&lt;User, ApiError&gt; {
    let parameters: [String: Any] = [
        ""username"": username,
        ""pw"": password
    ]

    var request = URLRequest(endpoint: Endpoint.login)
    request.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")
    request.httpBody = try? JSONSerialization.data(withJSONObject: parameters, options: [])

    return URLSession.shared.dataTaskPublisher(for: request)
        .map { $0.data }
        .decode(type: AuthenticationResult.self, decoder: JSONDecoder())
        .map { $0.user }
    // Here I would like to do something like: .handleAndContinue { self.save($0.accessToken }
        .mapError { _ in ApiError.loginError }
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
</code></pre>

<p>Or is there any other way to handle this type of situations with Swift Combine?</p>
","3750435","","3750435","","2020-04-10 19:15:13","2020-04-11 01:00:42","Swift Combine: How to handle event and continue stream","<ios><swift><xcode><combine>","1","0","","","","CC BY-SA 4.0"
"61170511","1","","","2020-04-12 11:12:16","","1","127","<p>My target is 2 thing:
1. to make a view depending on a view model protocol not a concrete class.
2. a sub view gets the view model from the environment instead of passing it through the view hierarchy
I've mentioned my goals so if there's a totally different way to achieve them, I'm open to suggestion.
Here's what've tried and failed of course and raised weird error:</p>

<pre><code>struct ContentView: View {
    var body: some View {
        NavigationView {
            MyView()
        }
    }
}

struct MyView: View {
    @EnvironmentObject var viewModel: some ViewModelProtocol

    var body: some View {
        HStack {
            TextField(""Enter something..."", text:$viewModel.text)
            Text(viewModel.greetings)
        }
    }
}

//MARK:- View Model
protocol ViewModelProtocol: ObservableObject {
    var greetings: String { get }
    var text: String { get set }
}

class ConcreteViewModel: ViewModelProtocol {
    var greetings: String { ""Hello everyone..!"" }
    @Published var text = """"
}

//MARK:- Usage
let parent = ContentView().environmentObject(ConcreteViewModel())

</code></pre>

<p><a href=""https://i.stack.imgur.com/VInfD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VInfD.png"" alt=""Error""></a></p>
","5929027","","5929027","","2020-04-12 13:09:28","2020-04-12 15:49:27","Is there a way decouple views from view models like the following?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61171372","1","61194209","","2020-04-12 12:20:17","","3","286","<p>It seems <code>View.onReceive</code> doesn't cancel subscription after that view disappeared. Action keeps getting called when no Child view on screen. 
How can I keep that subscription alive while the view is visible only?</p>

<pre><code>struct BugDemo: View {
    var body: some View {
        NavigationView {
            NavigationLink(""Go to child"", destination: Child())
        }
    }
}

struct Child: View {
    @State private var date: Date = Date()

    var body: some View {
        Text(DateFormatter.localizedString(from: date, dateStyle: .medium, timeStyle: .medium))
            .navigationBarTitle(""Child"")
            .onReceive(PublisherHolder.shared.publisher) {
                print(""Child.onReceive"")
                self.date = $0
            }
            .onDisappear {
                print(""Child.onDisappear"")
            }
    }
}

private class PublisherHolder {
    static let shared = PublisherHolder()
    lazy var publisher: AnyPublisher&lt;Date, Never&gt; = {
        Timer.publish(every: 1, on: .main, in: .default)
            .autoconnect()
            .print()
            .eraseToAnyPublisher()
    }()
}
</code></pre>
","1434829","","","","","2020-04-13 18:25:33","View.onReceive doesn't cancel subscription when the view removed from hierarchy","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61178868","1","61180001","","2020-04-12 22:11:00","","73","21978","<p>So I'm trying to learn SwiftUI and Combine. I usually start new tech by making a simple tip calculator. </p>

<p>I seem to be getting a random ""Extra argument in call."" error while coding 
Here is my SwiftUI File</p>

<pre><code>import SwiftUI

internal enum ReceiptRowType {
    case subtotal
    case tax
    case total
    case tip
    case grandTotal
}

struct TipView: View {
    @ObservedObject internal var adBannerView: BannerAdView = BannerAdView()
    @ObservedObject internal var receiptViewModel: ReceiptViewModel

    private let percentageFormatter: NumberFormatter = {
        let f = NumberFormatter()
        f.numberStyle = .percent
        return f
    }()

    var body: some View {
        ZStack {
            Color.white
                .scaledToFit()

            VStack {
                if adBannerView.adHasLoaded {
                    adBannerView
                        .frame(maxHeight: adBannerView.adHeight)
                        .animation(.easeInOut(duration: 2.0))
                }

                BorderView()

                Text(ARCHLocalizedStrings.receipt)
                    .foregroundColor(Color.gray)

                BorderView()

                HStack {
                    Spacer()

                    Button(action: {
                        self.receiptViewModel.addNewReceiptItem()
                    }) {
                        Text(ARCHLocalizedStrings.buttonTitleAddItem)
                    }
                }

                BorderView()

                ScrollView {
                    ForEach(receiptViewModel.receiptItems) { receiptItem in
                        ItemView(receiptItem: receiptItem)

                        if receiptItem != self.receiptViewModel.receiptItems.last {
                            Divider()
                        }
                    }
                }

                BorderView()

                BottomOfReceiptRow(receiptViewModel: receiptViewModel,
                                   type: ReceiptRowType.subtotal,
                                   title: ARCHLocalizedStrings.subtotal)

                BottomOfReceiptRow(receiptViewModel: receiptViewModel,
                                   type: ReceiptRowType.tax,
                                   title: ARCHLocalizedStrings.tax)
            }
            .padding(.horizontal, ARCHSwiftUILayoutConstants.defaultPaddingAndSpacing)
        }
    }
}

struct BorderView: View {
    var body: some View {
        Text(""================================"")
            .lineLimit(1)
            .foregroundColor(Color.gray)
            .minimumScaleFactor(0.5)
    }
}

struct ItemView: View {
    @ObservedObject var receiptItem: ReceiptItemViewModel

    var body: some View {
        HStack {
            TextField(receiptItem.name, text: $receiptItem.name)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .foregroundColor(Color.gray)
                .multilineTextAlignment(TextAlignment.leading)

            TextField(""Price"", value: $receiptItem.price, formatter: ARCHUtilities.currencyFormatter)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .foregroundColor(Color.gray)
                .multilineTextAlignment(TextAlignment.trailing)
                .minimumScaleFactor(0.5)
                .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
        }
    }
}

struct BottomOfReceiptRow: View {
    @ObservedObject internal var receiptViewModel: ReceiptViewModel

    internal var type: ReceiptRowType
    internal var title: String

    var body: some View {
        HStack {
            Spacer()

            Text(title)
                .foregroundColor(Color.gray)

            if type == ReceiptRowType.subtotal {
                Text(""\(receiptViewModel.subtotal)"")
                    .foregroundColor(Color.gray)
                    .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
            } else if type == ReceiptRowType.tax {
                Text(""\(receiptViewModel.taxRate)"")
                    .foregroundColor(Color.gray)
                    .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
            } else if type == ReceiptRowType.total {
                Text(""\(receiptViewModel.total)"")
                    .foregroundColor(Color.gray)
                    .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
            } else if type == ReceiptRowType.tip {

            } else if type == ReceiptRowType.grandTotal {
                Text(""\(receiptViewModel.grandTotal)"")
                    .foregroundColor(Color.gray)
                    .frame(width: ARCHSwiftUILayoutConstants.widthForCurrency)
            }
        }
    }
}

struct TipView_Previews: PreviewProvider {
    static var previews: some View {
        TipView(receiptViewModel: ReceiptViewModel())
    }
}
</code></pre>

<p>However, if I add another view on the TipView body (Any View) I seem to get a ""Extra argument in call"" error. </p>

<p><a href=""https://i.stack.imgur.com/GCAXk.png"" rel=""noreferrer"">Picture of error here</a></p>

<p>Does anyone know what's going on? </p>
","2593831","","","","","2022-09-02 17:46:37","SwiftUI: Random ""Extra argument in call"" error","<swiftui><combine>","3","3","3","","","CC BY-SA 4.0"
"61207937","1","61208499","","2020-04-14 12:40:36","","1","1315","<p>Trying to solve the challenge from the milestone via <code>Combine</code>, but stuck on a error:</p>

<pre><code>Value of type 'Published&lt;[User]&gt;.Publisher' has no member 'store'
</code></pre>

<p>Source code:</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation


// MARK: Main model from API
struct User: Decodable, Identifiable {
    let id: UUID
    let isActive: Bool
    let name: String
    let age: Int
    let company: String
    let email: String
    let address: String
    let about: String
    let registered: Date
    let tags: [String]
    let friends: [Friend]
}

// MARK: - Friend array API
struct Friend: Decodable {
    let id: String
    let name: String
}


final class ViewModel: ObservableObject {
    @Published var model = [User]()

    private var subscriptions: Set&lt;AnyCancellable&gt; = []

    // Error: Value of type 'Published&lt;[User]&gt;.Publisher' has no member 'store'
    init() { $model.store(in: &amp;subscriptions )}
}

extension ViewModel {
    // MARK: - Make request to API
    func fetch() -&gt; AnyPublisher&lt;User, Error&gt; {
        guard let mainURL = URL(string: ""https://www.hackingwithswift.com/samples/friendface.json"") else {
            fatalError(""404: Not found"")
        }

        return URLSession.shared.dataTaskPublisher(for: mainURL)
            .map(\.data)
            .decode(type: User.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
}

</code></pre>

<p>I don't understand, where do I need to create a Publisher?</p>
","8377355","","8377355","","2020-04-14 13:01:52","2020-04-14 13:19:42","@Published class has no member .store | Combine SwiftUI","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"61212263","1","61212823","","2020-04-14 16:10:54","","9","2269","<p>I'm new to Combine and I'd like to get a seemingly simple thing. Let's say I have a collection of integer, such as:</p>

<pre><code>let myCollection = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>I'd like to publish each element with a delay of, for example, 0.5 seconds. </p>

<pre><code>print 0
wait for 0.5secs
print 1
wait for 0.5secs
and so forth
</code></pre>

<p>I can easily get the sequence publisher and print the elements like this:</p>

<pre><code>let publisherCanc = myCollection.publisher.sink { value in
    print(value)
}
</code></pre>

<p>But in this case all the values are printed immediately. How can I print the values with a delay? In Combine there's a <code>.delay</code> modififer, but it's not for what I need (indeed, <code>.delay</code> delays the entire stream and not the single elements). If I try:</p>

<pre><code>let publisherCanc = myCollection.publisher.delay(for: .seconds(0.5), scheduler: RunLoop.main).sink { value in
    print(value)
}
</code></pre>

<p>All I get it's just an ""initial"" delay, then the elements are printed immediately. </p>

<p>Thanks for your help.</p>
","1291872","","","","","2021-05-25 14:24:12","Combine: publish elements of a sequence with some delay","<ios><swift><combine>","3","3","1","","","CC BY-SA 4.0"
"61216852","1","61230138","","2020-04-14 20:41:33","","6","1878","<p>I want to do an asynchronous job with Future.
But the below <strong>.sink() closures</strong> never get called.
It seems that the instance of Future was released right after it was called.</p>

<pre><code>    Future&lt;Int, Never&gt; { promise in
        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
            promise(.success(1))
        }
    }
    .receive(on: DispatchQueue.main)
    .sink(receiveCompletion: { completion in
        print(completion)
    }, receiveValue: {
        print($0)
    })
</code></pre>

<p>So I replaced <strong>.sink() closures</strong> to <strong>.subscribe(Subscribers.Sink())</strong> like below. It works fine.
But the problem is I don't understand why it works fine. :(
It looks the same to me.
What is the difference between these two codes? And when can I use <strong>.sink()</strong>, and when can I not?</p>

<pre><code>    Future&lt;Int, Never&gt; { promise in
        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
            promise(.success(1))
        }
    }
    .receive(on: DispatchQueue.main)
    .subscribe(Subscribers.Sink(receiveCompletion: { completion in
        print(completion)
    }, receiveValue: {
        print($0)
    }))
</code></pre>

<p>Thanks in advance.</p>
","2848557","","","","","2020-04-15 15:47:48","What's the difference between .sink and Subscribers.Sink?","<swift><swiftui><combine>","1","1","3","","","CC BY-SA 4.0"
"61249506","1","61250761","","2020-04-16 11:49:29","","2","1797","<h1>Overview:</h1>

<ul>
<li>I have a class called Player and a class called Song.</li>
<li>Player contains a Song</li>
<li>A view is showing the song title</li>
</ul>

<h1>Aim:</h1>

<p>When I change the player.song.title, the view needs to be updated.</p>

<h1>Problem:</h1>

<p>When the song's attributes changes, it wouldn't update the view automatically. Only when a new song is assigned will the changes be reflected.</p>

<h1>My Attempts:</h1>

<p>I have made 2 attempts (code below), both work as expected.</p>

<h1>Questions:</h1>

<ul>
<li>Is there a better way to do it ? (It seems like a common problem, one would encounter.)
Are my attempts reasonable and is attempt 2 better?</li>
<li>Or is there something fundamentally flawed with my design? (I was hoping to have the song inside the player because it represented the <strong>current</strong> song).</li>
</ul>

<h1>Original Code (view wouldn't be updated):</h1>

<h2>Model</h2>

<pre><code>import Foundation
import Combine

class Player : ObservableObject {

    @Published var duration = 0
    @Published var song     : Song

    init(song: Song) {
        self.song = song
    }
}

class Song : ObservableObject {

    @Published var id     : Int
    @Published var title  : String
    @Published var artist : String

    init(id: Int,
         title: String,
         artist: String) {

        self.id     = id
        self.title  = title
        self.artist = artist
    }
}
</code></pre>

<h2>View</h2>

<pre><code>import SwiftUI

struct ContentView: View {

    @ObservedObject var player : Player

    var body: some View {

        VStack {
            Text(String(player.duration))
            Text(player.song.title)
            Text(player.song.artist)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {

        let song = Song(id: 1, title: ""title1"", artist: ""artist1"")
        let player = Player(song: song)

        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            player.song.title = ""title2""
        }

        return ContentView(player: player)
    }
}
</code></pre>

<h3>Attempt1 - Using CombineLatest</h3>

<p><strong>Problem</strong>: It is not very scalable as the number of properties in a song increases.</p>

<pre><code>class Player : ObservableObject {

    @Published var duration = 0
    @Published var song     : Song
    private var songChangeCanceller : AnyCancellable?

    init(song: Song) {
        self.song = song

        songChangeCanceller = song.$title.combineLatest(song.$artist, song.$id).sink { _, _, _ in
            self.objectWillChange.send()
        }
    }
}
</code></pre>

<h3>Attemp2: Uses objectWillChange.sink</h3>

<pre><code>class Player : ObservableObject {

    @Published var duration = 0
    @Published var song     : Song

    private var songChangeCanceller : AnyCancellable?
    private var songAttributesChangeCanceller : AnyCancellable?

    init(song: Song) {
        self.song = song

        songChangeCanceller = $song.sink { newSong in

            self.songAttributesChangeCanceller = newSong.objectWillChange.sink { _ in
                self.objectWillChange.send()
            }
        }
    }
}
</code></pre>
","1046037","","","","","2020-04-16 13:16:21","SwiftUI Observe Changes","<swift><swiftui><combine><observableobject>","2","0","1","","","CC BY-SA 4.0"
"61272203","1","61273595","","2020-04-17 12:55:43","","4","809","<p>I'm trying to create chunks of a stream in Apple's Combine framework.</p>

<p>What I'm going for is something like this:</p>

<pre><code>Stream a:
--1-2-3-----4-5---&gt;

Stream b:
--------0-------0-&gt;

a.chunk(whenOutputFrom: b)

-------[1, 2, 3]---[4, 5]--&gt;
</code></pre>

<p>Can this be implemented in Combine?</p>
","4239752","","","","","2020-06-22 05:22:10","Swift Combine Chunk Operator","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"61280353","1","","","2020-04-17 20:43:10","","5","4508","<p>I've been struggling for hours on an issue with SwiftUI.</p>

<p>Here is a simplified example of my issue :</p>

<pre><code>class Parent: ObservableObject {
    @Published var children = [Child()]
}

class Child: ObservableObject {
    @Published var name: String?

    func loadName() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            // Async task here...
            self.objectWillChange.send()
            self.name = ""Loaded name""
        }
    }

}

struct ContentView: View {
    @ObservedObject var parent = Parent()

    var body: some View {
        Text(parent.children.first?.name ?? ""null"")
            .onTapGesture {
                self.parent.objectWillChange.send()
                self.parent.children.first?.loadName() // does not update
            }
    }
}
</code></pre>

<p>I have an ObservableObject (Parent) storing a @Published array of ObservableObjects (Child).</p>

<p>The issue is that when the name property is changed via an async task on one object in the array, the view is not updated.</p>

<p>Do you have any idea ?</p>

<p>Many thanks
Nicolas</p>
","2742293","","","","","2020-04-18 05:09:06","Change on ObservableObject in @Published array does not update the view","<swift><swiftui><combine><observedobject>","3","3","1","","","CC BY-SA 4.0"
"61288459","1","","","2020-04-18 11:37:47","","2","628","<p>If I correctly understand about IOC, it means that any framework or module you are configuring to drive your functionality should be able to drive your code whenever the need arises (Ref: <a href=""https://martinfowler.com/bliki/InversionOfControl.html"" rel=""nofollow noreferrer"">Martin Flower IOC Blog</a>). This means that control is framework driven.</p>

<p>I was going through a wonderful blog <a href=""https://www.vadimbulavin.com/asynchronous-programming-with-future-and-promise-in-swift-with-combine-framework/"" rel=""nofollow noreferrer"">Future and Promises in Combine</a>. The blog in the very beginning says that handling of asynchronous behaviour by callbacks or closures violate IOC. I kind of disagree with the statement but just want to clarify my understandings.</p>

<p>Scenario: </p>

<p>I created a <code>TestFramework</code> which handles some functionality for the framework user. </p>

<pre><code>public class TestFramework {

    typealias UpdatedFrameworkData = (FrameworkData?) -&gt; Void

    var giveUpdatedValues: (() -&gt; UpdatedFrameworkData)?

    init() { }

    private func someAction() {
        var updatedValuesCallback = giveUpdatedValues?()
        updatedValuesCallback = { [weak self] updatedFrameworkData in
            // Perform some action

        }
    }
}
</code></pre>

<p>Now I have a class which uses this framework</p>

<pre><code>class FrameworkUser {
    let framework: TestFramework = TestFramework()
    var updatedValuesCallback: TestFramework.UpdatedFrameworkData?

    init() {
       setupBinding()
    }

    private func setupBinding() {
        updatedValuesCallback = framework.giveUpdatedValues?()
    }

    private func getUpdatedData(completion: @escaping TestFramework.UpdatedFrameworkData) {
        // Return some data
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            self.updatedValuesCallback?(self.getFrameworkData())
        }
    }

    private func getFrameworkData() -&gt; FrameworkData? {
        nil
    }
}
</code></pre>

<p>The framework sometimes could need to work on updated data rather than some stale data. If you observe my framework still can control the functionality of when to get updated data via the listener that is provided by the user. The user provides the data via an asynchronous callback to the framework.</p>

<p>So, in this case, am I not achieving IOC via callbacks or am I missing something?</p>

<p><strong>EDIT:</strong> </p>

<p>I had made a minor mistake in the above code of setup binding. The user still calls the framework to provide updated values.</p>

<p>I made the below modifications to my above code to find out that yes asynchronous handling of a program by callbacks does violate the IOC principles. The <code>setupBinding()</code> method above is incorrect on how it binds to the callback of the Framework. It should have been something like this:</p>

<pre><code>private func setupBinding() {
        framework.giveUpdatedValues = {
            return getUpdatedData() // This won't work
        }
    }
</code></pre>

<p>In order to follow IOC principles, the user should bind its code to the framework callback. The above code simply won't work because you can not simply just return an escaping closure from a function and this closure will be executed in some timeline later.</p>
","5395919","","5395919","","2020-04-19 06:56:35","2020-04-19 06:56:35","Callback violates Inversion of Control","<ios><swift><callback><inversion-of-control><combine>","1","2","","","","CC BY-SA 4.0"
"61295078","1","61297221","","2020-04-18 19:30:29","","0","193","<p>I have the following code which should indicate a memory leak. but it actually doesn't when I test it with Xcode leak instrument.
Does this mean that there's actually no memory leak, or the instrument may be wrong?</p>

<pre><code>private func initTimePublisher() {
        timer.publish(every: tickInterval, on: runloop, in: runloopMode)
            .autoconnect()
            .map { self.durationCalculator.activeDuration(between: self.startDate!, and: $0) }
            .assign(to: \.activeDuration, on: self) // This should be a retain cycle which causes a memory like right?
            .store(in: &amp;subs)
}
</code></pre>
","5929027","","752890","","2020-04-18 19:50:56","2020-04-18 22:37:49","Is the leak instrument in Xcode instruments accurate?","<swift><instruments><combine>","1","0","","","","CC BY-SA 4.0"
"61295242","1","61295668","","2020-04-18 19:44:02","","0","294","<p>I currently have a struct, which has a computed property called ""answerArray"". I want to compare this array of values with another array of values that is stored in an Environment object. </p>

<pre><code>struct CandidateModel {
@EnvironmentObject var model: CardViewModel

let index: Int
var name: String
var answers: [AnswerModel]
var answerArray: [Double] {
    get {
        var arr: [Double] = []
        for i in answers {
            if i.isKeyIssue {
            // If answer is a key issue
                arr.append(i.score * 1.5)
                // Apply multiplier and append to answer array
            }
            else {arr.append(i.score)}
            // otherwise just append to list
        }
        return arr
    }
}
var scoreArray: [Double] {
    get {

        var compScoreArray: [Double] = []

        for i in 0...self.model.getAnswerList().count - 1 {
            let questionDifference = abs(self.answerArray[i] - self.model.answerList[i])
            compScoreArray.append(questionDifference)
        }

        return compScoreArray
    }
}
</code></pre>

<p>I when attempt to access this property I get the following error:</p>

<pre><code>Thread 1: Fatal error: No ObservableObject of type CardViewModel found. A View.environmentObject(_:) for CardViewModel may be missing as an ancestor of this view.
</code></pre>

<p>I am simply trying to update the scoreArray property in the CandidateModel as the answerList property in my environment object changes. How could I better implement this? </p>

<p>Here is my View Code:</p>

<pre><code>struct SentimentComparisonBarView: View {
@EnvironmentObject var model: CardViewModel

var body: some View {
    HStack {
      // 2
        Image(""Jobs_Economy"")
            .renderingMode(.template)
            .resizable()
            .scaledToFit()
            .frame(width: 50)
            .foregroundColor(Color.init(#colorLiteral(red: 0.3942148186, green: 0.3146163453, blue: 0.4587302703, alpha: 1)))

        Text(""Jobs/Economy"")
            .frame(width: 120, alignment: .leading)
          // 3
          Rectangle()
            .fill(Color.init(#colorLiteral(red: 0.5201314092, green: 0.3027745485, blue: 0.49252671, alpha: 1)))
            .frame(width: CGFloat(2 * 10.0), height: 5.0)
          // 4
          Spacer()
            Text(""Low"")
                .padding(.horizontal, 10)

        Button(""Test"") {
            print(self.model.presidentialCandidates[0].scoreArray)
        }

    }
}
</code></pre>
","8898639","","8898639","","2020-04-18 21:04:21","2020-04-18 21:04:21","Access environment object property within a struct's computed property","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61303466","1","61382527","","2020-04-19 11:19:58","","13","3871","<p>I am trying to add a close button to the modally presented View's navigation bar. However, after dismiss, my view models <strong>deinit</strong> method is never called. I've found that the problem is where it captures the <strong>self</strong> in <strong>navigationBarItem</strong>'s. I can't just pass a <code>weak self</code> in <strong>navigationBarItem</strong>'s action, because View is a struct, not a class. Is this a valid issue or just a lack of knowledge?</p>

<pre><code>struct ModalView: View {

    @Environment(\.presentationMode) private var presentation: Binding&lt;PresentationMode&gt;
    @ObservedObject var viewModel: ViewModel

    var body: some View {

        NavigationView {
            Text(""Modal is presented"")
            .navigationBarItems(leading:
                Button(action: {
                    // works after commenting this line
                    self.presentation.wrappedValue.dismiss()
                }) {
                    Text(""close"")
                }

            )
        }
    }
}
</code></pre>
","7876148","","","","","2022-08-23 15:07:39","SwiftUI - memory leak in NavigationView","<ios><swift><memory-leaks><swiftui><combine>","4","0","2","","","CC BY-SA 4.0"
"61306309","1","61367084","","2020-04-19 14:49:48","","1","661","<h1>Overview:</h1>

<ul>
<li>I have a async task to fetch from the database</li>
<li>I have created a Future for the async task (fetching from the database).</li>
</ul>

<h1>Question:</h1>

<ul>
<li>How can execute custom code when the Future is cancelled?</li>
</ul>

<h1>Purpose:</h1>

<ul>
<li>I would like the database connection to be closed when the subscription is cancelled.</li>
</ul>

<p>For example, I would like to use <code>Combine</code> to rewrite this helper method:</p>

<pre class=""lang-swift prettyprint-override""><code>// Similar to https://developer.apple.com/documentation/coredata/nspersistentcontainer/1640564-performbackgroundtask
func withDatabaseFTSContext(block: @escaping (FMDatabase?) -&gt; Void) {
  queue.async {
    guard let database = self.database else {
      block(nil)
      return
    }

    database.open()
    let simpleTokenizer = FMSimpleTokenizer(locale: nil)
    FMDatabase.registerTokenizer(simpleTokenizer, withKey: ""simple"")
    database.installTokenizerModule()

    block(database)

    database.close()
  }
}
</code></pre>

<p>Could I leverage <code>Combine</code> to rewrite this method to return <code>FMDatabase</code> as a parameter of a publisher?</p>

<p>I was attempting to use <code>Combine</code> but it does not work. The database will be closed before <code>cancel()</code></p>

<pre class=""lang-swift prettyprint-override""><code>private func withDatabaseFTSContext() -&gt; AnyPublisher&lt;FMDatabase?, Never&gt; {
  return Future&lt;FMDatabase?, Never&gt; { promise in
    self.queue.async {
      guard let database = self.database else {
        promise(.success(nil))
        return
      }

      database.open()
      let simpleTokenizer = FMSimpleTokenizer(locale: nil)
      FMDatabase.registerTokenizer(simpleTokenizer, withKey: ""simple"")
      database.installTokenizerModule()

      promise(.success(database))

      database.close() // When to close this database? Currently it will be closed before `cancel()`
    }
  }.eraseToAnyPublisher()
}
</code></pre>
","2949840","","1046037","","2020-04-20 12:49:18","2020-04-22 14:04:15","Combine: How to clean up resources while an AnyCancellable is being cancelled?","<swift><swiftui><combine>","1","7","","","","CC BY-SA 4.0"
"61306692","1","","","2020-04-19 15:14:01","","1","532","<p>I am using the Redux pattern for building a messaging application. Everything works fine so far but then I notice a memory leak in some parts of the app that I'm unable to solve. My view controller that binds to messages publisher. Deinit won't get called when the view controller is dismissed.</p>

<pre><code>        let messages = {
            store.$state
                .map { $0.chatState.messagesByChannel[self.channelId] }
                .removeDuplicates()
                .eraseToAnyPublisher()
        }()

        messages.combineLatest(Just(""Hello world""))
            .sink { [weak self] (messages, state) in

        }
        .store(in: &amp;cancellableSet)
</code></pre>

<p>When I changed from referencing a dictionary object to another object in the chat state <code>deinit</code> gets called</p>

<pre><code>        let chatRoomDetailResponse = {
            store.$state
            .map { $0.chatState.getChatRoomDetailResponse }
                .removeDuplicates()
                .eraseToAnyPublisher()
        }()

        chatRoomDetailResponse.combineLatest(Just(""Hello world""))
            .sink { [weak self] (messages, state) in

        }
        .store(in: &amp;cancellableSet)
</code></pre>

<p>This is a small snapshot of my store: </p>

<pre><code>final public class Store&lt;State: FluxState&gt;: ObservableObject {
    @Published public var state: State

    private var dispatchFunction: DispatchFunction!
    private let reducer: Reducer&lt;State&gt;
</code></pre>

<p>and my ChatState: </p>

<pre><code>
public struct ChatState: FluxState {

    public typealias ChannelID = String

    public var messagesByChannel: [ChannelID: [Message]] = [:]

    public var getChatRoomDetailResponse: NetworkResponse&lt;ChatChannel&gt;? = nil
}
</code></pre>
","9930296","","","","","2020-04-19 15:33:22","Memory leak when using CombineLatest in Swift Combine","<swift><redux><memory-leaks><combine>","1","0","","","","CC BY-SA 4.0"
"61309091","1","61315780","","2020-04-19 17:54:33","","2","1390","<p>I have an ObservableObject which is supposed to hold my application state:</p>

<pre class=""lang-swift prettyprint-override""><code>final class Store: ObservableObject {
  @Published var fetchInterval = 30
}
</code></pre>

<p>now, that object is being in injected at the root of my hierarchy and then at some component down the tree I'm trying to access it and bind it to a TextField, namely:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ConfigurationView: View {
  @EnvironmnetObject var store: Store

  var body: some View {
    TextField(""Fetch interval"", $store.fetchInterval, formatter: NumberFormatter())
    Text(""\(store.fetchInterval)""
  }
}
</code></pre>

<ol>
<li>Even though the variable is binded (with <code>$</code>), the property is not being updated, the initial value is displayed correctly but when I change it, the textfield changes but the binding is not propagated</li>
<li>Related to the first question, is, how would I receive an event once the value is changed, I tried the following snippet, but nothing is getting fired (I assume because the textfield is not correctly binded...</li>
</ol>

<pre class=""lang-swift prettyprint-override""><code>$fetchInterval
           .debounce(for: 0.8, scheduler: RunLoop.main)
           .removeDuplicates()
           .sink { interval in
               print(""sink from my code \(interval)"")
           }
</code></pre>

<p>Any help is much appreciated.</p>

<p>Edit: I just discovered that for text variables, the binding works fine out of the box, ex:</p>

<pre class=""lang-swift prettyprint-override""><code>// on store
@Published var testString = ""ropo""

// on component
TextField(""Ropo"", text: $store.testString)
Text(""\(store.testString)"")
</code></pre>

<p>it is only on the int field that it does not update the variable correctly</p>

<p>Edit 2: 
Ok I have just discovered that only changing the field is not enough, one has to press <code>Enter</code> for the change to propagate, which is not what I want, I want the changes to propagate every time the field is changed...</p>
","3107926","","3107926","","2020-04-19 18:34:18","2020-04-21 11:24:44","SwiftUI, how to bind EnvironmnetObject Int property to TextField?","<ios><swift><macos><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"61328231","1","61333515","","2020-04-20 17:17:04","","0","455","<p>I have three publishers. Two which already produced value, and one that may or may not do it. I need to combine them and produce output.</p>

<pre><code>var changeDay = NotificationCenter.Publisher.init(center: .default, name: .NSCalendarDayChanged

    var someDate: AnyPublisher&lt;Date, Never&gt; {
        Publishers.CombineLatest3($someInputBool, $someInputDate, changeDay).map { (a, b, c) -&gt; Date in
            return &lt;someDate based on a and b, but if day changes, the result will be different.&gt;
        }.eraseToAnyPublisher()
    }
</code></pre>

<p>If the day hasn't yet changed, the CombineLatest3 won't return anything as it waits for the initial value from c before running the clousure. How can I make sure the CombineLatest3 returns even if one publisher hasn't emitted a single value? I'm using <code>c</code> as a trigger here to recompute my custom date.</p>
","8693775","","","","","2020-04-20 23:08:39","How to make CombineLatest3 return result if one publisher hasn't produced any values?","<ios><swift><uikit><combine>","1","0","","","","CC BY-SA 4.0"
"61335519","1","61336518","","2020-04-21 03:35:36","","9","14147","<p>I have a problem with observed object in SwiftUI.
I can see changing values of observed object on the View struct.
However in class or function, even if I change text value of TextField(which is observable object) but ""self.codeTwo.text still did not have changed.</p>

<p>here's my code sample (this is my ObservableObject)</p>

<pre><code>class settingCodeTwo: ObservableObject {

private static let userDefaultTextKey = ""textKey2""
@Published var text: String = UserDefaults.standard.string(forKey: settingCodeTwo.userDefaultTextKey) ?? """"

private var canc: AnyCancellable!

     init() {
        canc = $text.debounce(for: 0.2, scheduler: DispatchQueue.main).sink { newText in
        UserDefaults.standard.set(newText, forKey: settingCodeTwo.userDefaultTextKey)

    }
}


   deinit {
     canc.cancel()
   }

}
</code></pre>

<p>and the main problem is... ""self.codeTwo.text"" never changed!</p>

<pre><code>class NetworkManager: ObservableObject {


@ObservedObject var codeTwo = settingCodeTwo()
@Published var posts = [Post]()


func fetchData() {
    var urlComponents = URLComponents()
    urlComponents.scheme = ""http""



    urlComponents.host = ""\(self.codeTwo.text)"" //This one I want to use observable object




    urlComponents.path = ""/mob_json/mob_json.aspx""
    urlComponents.queryItems = [
        URLQueryItem(name: ""nm_sp"", value: ""UP_MOB_CHECK_LOGIN""),
        URLQueryItem(name: ""param"", value: ""1000|1000|\(Gpass.hahaha)"")
    ]

    if let url = urlComponents.url {
        print(url)
        let session = URLSession(configuration: .default)
        let task = session.dataTask(with: url) { (data, response, error) in
            if error == nil {
                let decoder = JSONDecoder()
                if let safeData = data {
                    do {
                        let results = try decoder.decode(Results.self, from: safeData)

                        DispatchQueue.main.async {
                            self.posts = results.Table
                        }   
                    } catch {
                        print(error)
                    }
                }
            }
        }
        task.resume()
    }

}
}
</code></pre>

<p>and this is view, I can catch change of the value in this one</p>

<pre><code>import SwiftUI
import Combine



struct SettingView: View {

  @ObservedObject var codeTwo = settingCodeTwo()
  var body: some View {
    ZStack {
        Rectangle().foregroundColor(Color.white).edgesIgnoringSafeArea(.all).background(Color.white)
        VStack {


            TextField(""test"", text: $codeTwo.text).textFieldStyle(BottomLineTextFieldStyle()).foregroundColor(.blue)

            Text(codeTwo.text)
        }
    }
}
}
</code></pre>

<p>Help me please.</p>
","13292453","","12299030","","2020-04-21 05:28:21","2020-04-21 05:30:24","SwiftUI: How can I catch changing value from observed object when I execute function","<ios><swiftui><combine><observableobject><observedobject>","2","0","","","","CC BY-SA 4.0"
"61359307","1","62241442","","2020-04-22 07:15:44","","0","922","<p>I have a ScrollView with a HStack of views that would animate depending on their own position. To do that, I am using a GeometryReader that would read the current global position of each view and when a certain position is reached the view would switch from out of focus to in-focus state and do some transformations and change the @State variable to indicate that the view is in focus so that other parts of the view can act on that.</p>

<p>Fairly simple, right? Unfortunately, when I change the @State from within the GeometryReader, the state change wouldn't happen. Therefore I built a simplified version to demonstrate the issue. </p>

<p>Here is the code: </p>

<pre><code>import SwiftUI

struct GeometryReaderTest: View {
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            //
            HStack(spacing: 40){
                ForEach(0..&lt;10) { _ in
                    SlideView()
                }
            }
        }

    }
}

struct SlideView : View {
    //
    @State var isInFocus : Bool = false
    var body: some View {
        ZStack {
            Rectangle().fill( isInFocus ? Color.green : Color.orange).frame(width: UIScreen.main.bounds.width - 60, height: 120, alignment: .center)
            MyContent(isInFocus: self.$isInFocus)
        }

    }
}

struct MyContent : View {
    @Binding var isInFocus : Bool

    var body: some View {
        GeometryReader { geo in

            self.toggleFocusState(geometry: geo)
        }
    }

    func toggleFocusState(geometry : GeometryProxy)-&gt; some View{
        let distance = geometry.frame(in: .global).origin.x.magnitude


        self.isInFocus = distance &lt; 120


        return VStack {
            Text(""Focused: \(self.isInFocus ? ""Yes"" : ""Nope"" )"")
             Text(""Distance: \(distance)"")
            Button(action: {
                //
                self.isInFocus.toggle()
            }) {
                Text(""Toggle"")
            }
        }
    }
}

struct GeometryReaderTest_Previews: PreviewProvider {
    static var previews: some View {
        GeometryReaderTest()
    }
}
</code></pre>

<p>When you tap on the ""toggle"" button, which also runs from within the GeometryReader, the @State  variable would change successfully and the change would be reflected. </p>

<p>When you actually scroll the ScrollView and leave it to naturally scroll through, nothing will happen. It would not update even after it stops. </p>

<p>see here: <a href=""https://streamable.com/d3op74"" rel=""nofollow noreferrer"">https://streamable.com/d3op74</a></p>

<p>When you slowly scroll through the ScrollView and not lift your finger, the @State variable would change.</p>

<p>here: <a href=""https://streamable.com/7m15t9"" rel=""nofollow noreferrer"">https://streamable.com/7m15t9</a></p>

<p>If you introduce a delay with DispatchQueue.main.asyncAfter() like this:</p>

<pre><code>DispatchQueue.main.asyncAfter(deadline: .now() + 0.0) {
            self.isInFocus = distance &lt; 120
        }
</code></pre>

<p>even if the delay is 0, the @State change would work as you scroll through, no matter how fast however this time the toggle button wouldn't function(which makes sense, since the GeometryReader would re-calculate and overturn the action taken by the button).</p>

<p>here: <a href=""https://streamable.com/q3ylu1"" rel=""nofollow noreferrer"">https://streamable.com/q3ylu1</a></p>

<p>Can please someone explain what is going on here? Is this an intended behaviour or a bug?</p>
","1781521","","1781521","","2020-04-22 07:29:15","2020-06-07 05:57:17","SwiftUI would not reflect changes to a @Binding @State variable when the change is made from within a GeometryReader","<swift><combine><swiftui><geometryreader>","1","2","1","","","CC BY-SA 4.0"
"61360848","1","61384265","","2020-04-22 08:43:31","","2","1691","<p>I want to create a Swift Combine publisher which achieves the following:</p>

<ul>
<li>The publisher should be triggered by changes in <em>either</em> <a href=""https://github.com/sindresorhus/Defaults#observe-changes-to-a-key"" rel=""nofollow noreferrer"">Defaults</a> (a <code>UserDefaults</code> Swift package) <em>or</em> changes in GRDB sqlite database values (using <a href=""https://github.com/groue/GRDBCombine#database-observation"" rel=""nofollow noreferrer"">GRDBCombine</a>).</li>
<li>The updated <code>UserDefaults</code> received from the <a href=""https://github.com/sindresorhus/Defaults#observe-changes-to-a-key"" rel=""nofollow noreferrer"">Defaults</a> publisher should be used <em>within</em> the database query in the <a href=""https://github.com/groue/GRDBCombine#database-observation"" rel=""nofollow noreferrer"">GRDBCombine</a> publisher.</li>
</ul>

<p>Here is a simplified version of what I have tried so far:</p>

<pre><code>func tasksPublisher() -&gt; AnyPublisher&lt;[Task], Never&gt; {
    Defaults.publisher(.myUserDefault)
        .flatMap { change in
            let myUserDefault = change.newValue

            return ValueObservation
                .tracking { db in
                    try Task.
                        .someFilter(myUserDefault)
                        .fetchAll(db)
                }
                .removeDuplicates()
                .publisher(in: database)
                .eraseToAnyPublisher()
        }
        .eraseToAnyPublisher()
}
</code></pre>

<p>However, this publisher produces the following error (edited according to the simplified version of my publisher above):</p>

<blockquote>
  <p><code>Cannot convert return expression of type 'AnyPublisher&lt;Publishers.FlatMap&lt;_, AnyPublisher&lt;Defaults.KeyChange&lt;Int&gt;, Never&gt;&gt;.Output, Publishers.FlatMap&lt;_, AnyPublisher&lt;Defaults.KeyChange&lt;Int&gt;, Never&gt;&gt;.Failure&gt;' (aka 'AnyPublisher&lt;_.Output, Never&gt;') to return type 'AnyPublisher&lt;[Task], Never&gt;'</code></p>
</blockquote>

<p>My bet is that there is a problem with the two publishers having different values: <code>[Task]</code> and <code>Defaults.KeyChange&lt;Int&gt;</code>. However, I cannot find a way to work around this.</p>
","2906284","","","","","2020-04-23 10:02:31","How can I create a Swift Combine publisher from two publishers A and B where publisher B consumes the value from publisher A?","<swift><combine><userdefaults><grdb><grdbcombine>","1","0","","","","CC BY-SA 4.0"
"61361004","1","61370886","","2020-04-22 08:51:41","","0","817","<p>And what shall we use instead?<br>
I'm surprised that nobody asked this before.</p>
","2167345","","","","","2021-07-15 21:14:55","Why don't we have tryFlatMap operator in Combine?","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"61361788","1","61361941","","2020-04-22 09:34:03","","6","2623","<p>I'm currently getting familiar with SwiftUI and Combine frameworks. And I'm not really getting the difference between these two approaches. When we have to keep track of some data (say, a list of tasks), we can declare a @State variable, and it's change will automatically send notification and update current view. However, it looks like it can also be done this way:</p>

<pre><code>class TaskList: ObservableObject{
    //a list that's going to be modified and updated on different occasions
    @Published var list: [String]
}

class TodoListView {
    @ObservedObject var todoList = TaskList()
}
</code></pre>

<p>So, I missing a point - <strong>how are @State and @ObservedObject approaches different and which one is preferable under which circumstances?</strong></p>

<p>Thanks!</p>
","6029661","","","","","2020-10-01 09:51:00","@State vs @ObservableObject - which and when?","<swift><swiftui><combine>","2","1","2","","","CC BY-SA 4.0"
"61362821","1","61424222","","2020-04-22 10:26:43","","0","915","<p>One of the requirements of my application is the ability to start multiple timers, for reporting purposes.</p>

<p>I've tried to store the timers and seconds passed in an <code>@EnvironmentObject</code> with <code>@Published</code> variables, but every time the object refreshes, any view that observes the <code>@EnvironmentObject</code> refreshes too.</p>

<p>Example</p>

<pre class=""lang-swift prettyprint-override""><code>class TimerManager: ObservableObject {
   @Published var secondsPassed: [String: Int]
   var timers: [String:AnyCancellable]

   func startTimer(itemId: String) {
      self.secondsPassed[itemId] = 0
      self.timers[itemId] = Timer
          .publish(every: 1, on: .main, in: .default)
          .autoconnect()
          .sink(receiveValue: { _ in
                self.secondsPassed[itemId]! += 1
          })
   }

   func isTimerValid(itemId: String) -&gt; Bool {
       return self.timers[itemId].isTimerValid
   }

   // other code...
}
</code></pre>

<p>So for example, if in any other view I need to know if a particular timer is active by calling a function <code>isTimerValid</code>, I need to include this <code>@EnvironmentObject</code> in that view, and it won't stop refreshing it because the timer changes <code>secondsPassed</code> which is <code>Published</code>, causing lags and useless redrawings.</p>

<p>So one thing I did was to cache the <code>itemId</code> of the active timers somewhere else, in a <code>static</code> <code>struct</code> that I update every time I start or stop a timer. </p>

<p>It seemed a bit hacky, so lately I've been thinking to move all this into a Singleton, like this for example </p>

<pre class=""lang-swift prettyprint-override""><code>class SingletonTimerManager {

   static let singletonTimerManager = SingletonTimerManager()

   var secondsPassed: [String: Int]
   var timers: [String:AnyCancellable]

   func startTimer(itemId: String) {
      self.secondsPassed[itemId] = 0
      self.timers[itemId] = Timer
          .publish(every: 1, on: .main, in: .default)
          .autoconnect()
          .sink(receiveValue: { _ in
                self.secondsPassed[itemId]! += 1
          })
   }

   // other code...
}
</code></pre>

<p>and <strong>only let some Views</strong> observe the changes to <code>secondsPassed</code>. On the plus side, I can maybe move the timer on the background thread.</p>

<p>I've been struggling how to do this properly.</p>

<p>These are my <code>Views</code> (albeit a very simple extract)</p>

<pre><code>struct ContentView: View {

    // set outside the ContentView
    var selectedItemId: String

    // timerValue: set by a publisher?

    var body: some View {
        VStack {  
            ItemView(seconds: Binding.constant(timerValue))
        }
    }
}

struct ItemView: View {
    @Binding var seconds: Int

    var body: some View {
        Text(""\(self.seconds)"")
    }
}
</code></pre>

<p>I need to somehow observe the <code>SingletonChronoManager.secondsPassed[selectedItemId]</code> so the <code>ItemView</code> updates in real time. </p>
","4663815","","13860","","2020-05-09 11:52:03","2020-05-09 11:52:03","Observe singleton timer value changes with Publisher in Combine","<swift><timer><swiftui><combine>","2","0","0","","","CC BY-SA 4.0"
"61373280","1","","","2020-04-22 19:11:15","","0","166","<h1>Code</h1>

<pre><code>.onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillShowNotification))
</code></pre>

<h1>Current Behaviour:</h1>

<p>Above code gets executed for every view in my hierarchy.</p>

<h1>Question:</h1>

<p>How can I receive <code>keyboardWillShowNotification</code> only for a specific view</p>
","6570822","","1046037","","2020-04-23 15:44:15","2020-04-23 15:44:15","NotificationCenter.default.publisher called from child views in NavigationView hierarchy SwiftUI","<swift><xcode><swiftui><combine><notificationcenter>","0","3","","","","CC BY-SA 4.0"
"61377655","1","","","2020-04-23 01:07:57","","0","500","<p>I have a data model object that I have to fill with multiple network requests. </p>

<p>My model looks like this</p>

<pre><code>struct CO2Data: Identifiable, Codable {
    let id = UUID()
    let totalCO2: Double
    let dailyAverage: Int
    let calendar = Calendar.current
    let dateString: String
    let emissionStats: EmissionStats

let driveLog: String 
    // It is an ID to get the trip details

    let trip : Trip
    // This is what needs to be filled from the next URL request using driveLog


    enum CodingKeys: String, CodingKey {
        case id
        case totalCO2 = ""totCO2""
        case dateString = ""stDt""
        case dailyAverage = ""avg""
        case emissionStats = ""emisStats""
        case drLogRefId = ""drLogRefId""
        //Not having case trip here breaks the conformance to codable
        // and results in error
    }
}
</code></pre>

<pre><code>struct Trip: Codable {
    let startTime: String
    let endTime: String
    let startLat: String
    let startLong: String
    let endLat: String
    let endLong: String
}
</code></pre>

<p>This is the flow of the network request and responses</p>

<ol>
<li><p>request to get the CO2Data and decode it using JSONDecoder()</p></li>
<li><p>use the driveLog Property in the fetched CO2Data to make another network request to get the Trip object.</p></li>
<li><p>The result of the second network request should be added to the CO2Data object in the trip property.</p></li>
</ol>

<p>How should I go about this. Is it even possible to store the Trip in CO2 data?</p>

<p>I am using the Combine &amp; URLSession.shared.dataTaskPublisher(for: URLRequest) for this, but I can totally use plain old simple data task.
Are there known ways to handle request dependencies like this? 
I am not using any third party libraries and wish to stick with URLSession.</p>

<p>JSON Objects look like this</p>

<pre><code>// for CO2Data
[
  {
    ""stDt"": ""2019-11-17T16:00:00.000+0000"",
    ""totCO2"": 50,
    ""avg"": 0,
    ""emisStats"": {
      ""wea"": 10,
      ""aggDr"": 10,
      ""tfc"": 10,
      ""tirePress"": 0,
      ""ac"": 10,
      ""seatHeater"": 10
    },
    ""drLogRefId"": ""5dc20204199f752c7726a8f0""
  }
]

//for Trip
[
  {
    ""id"": ""5dc20204199f752c7726a8f0"",
    ""startTime"": ""..."",
    ""startLat: ""..."",
    ""startLong: ""..."",
    ""endLat: ""..."",
    ""endLong"": ""..."",
  }
]
</code></pre>
","8686844","","8686844","","2020-04-23 01:17:01","2020-04-26 13:28:16","How to fill a single Model Object with multiple chained URL requests Request Dependency?","<ios><swift><swiftui><combine><urlsession>","2","0","","","","CC BY-SA 4.0"
"61402122","1","61403996","","2020-04-24 06:01:44","","2","2034","<p>New to Combine &amp; reactive programming here so the help is very much appreciated.</p>

<p>I have the following scenario: I'd like to build a UI where a user can filter down content via various 'filter' buttons on the page. When a user taps one of the buttons, I need to shoot off an API request to get the data.</p>

<p>Now, I have a publisher that provides me with the 'state' of these selections, and I've structured my code like this:</p>

<pre><code>        state
            .publisher /* sends whenever 'state' updates behind the scenes */
            .debounce(for: 1.0, scheduler: DispatchQueue.main)
            .map { /*  create some URL request */ }
            .flatMap {
                URLSession.shared.dataTaskPublisher(for: someRequest)
                    .map { $0.data }
                    .decode(type: MyResponseType.self, decoder: JSONDecoder())
        }.sink(receiveCompletion: { (completion) in
            /// cancelled
        }) { (output) in
             /// go show my results
             /// Ideally, this is only called when the most recent API call finishes!
        }.store(in: &amp;cancellables)
</code></pre>

<p>However, this implementation has a bug in the following scenario: If one event makes it through to the flatMap to fire off a request, and a subsequent event does the same before the network call completes, then we will call the completion handler twice.</p>

<p>Preferably, we are somehow a canceling the inner pipeline so we only execute the completion handler with the most recent event.</p>

<p>How can I 'cancel' that inner pipeline (the one started by the dataTaskPublisher) when new events come down the pipeline without tearing down the outer pipeline?</p>
","1284996","","","","","2020-04-24 20:23:36","Combine: How to cancel a flatMap'ed publisher","<ios><swift><reactive-programming><combine>","1","0","1","","","CC BY-SA 4.0"
"61404517","1","61480024","","2020-04-24 08:50:20","","5","4362","<p>I'm having a hard time with dealing with Combine. After the publisher is complete I want to update a value but whenever I update that value the memory is allocated and never goes away.</p>

<p>Whenever I try to assign image there is a leak. If I don't assign no leak.</p>

<p>EDIT: Reproducible example here: <a href=""https://github.com/peterwarbo/MemoryAllocation"" rel=""noreferrer"">https://github.com/peterwarbo/MemoryAllocation</a></p>

<p>This is what my code looks like:</p>

<pre><code>final class CameraController: ObservableObject {

    private var storage = Set&lt;AnyCancellable&gt;()    
    var image: UIImage?

    func capture(_ image: UIImage) {

        PhotoLibrary.saveImageToTemporaryDirectory(image) // AnyPublisher&lt;URL, Error&gt;
            .zip(PhotoLibrary.saveImage(image, location: self.locationObserver.location) // AnyPublisher&lt;UIImage, Error&gt;)
            .sink(receiveCompletion: { [weak self] (completion) in
                switch completion {
                case let .failure(error):
                    Log.error(error)
                    self?.handleCaptureError(error)
                case .finished: break
                }
            }) { [weak self] (value) in
                print(value.1) // no leak
                self.image = value.1 // leak

            }
            .store(in: &amp;self.storage)
     }
}
</code></pre>

<p>I've also tried instead of using <code>sink</code>:</p>

<pre><code>.receive(
    subscriber: Subscribers.Sink(
        receiveCompletion: { [weak self] completion in
            switch completion {
            case let .failure(error):
                Log.error(error)
                self?.handleCaptureError(error)
            case .finished: break
            }
        },
        receiveValue: { value in
            print(value.1) // no leak
            self.image = value.1 // leak            
        }
    )
)
</code></pre>
","294661","","294661","","2020-04-28 10:22:46","2021-08-09 12:12:54","swift combine sink receiveValue memory leak","<swift><memory-leaks><combine>","3","0","2","","","CC BY-SA 4.0"
"61442507","1","","","2020-04-26 14:31:42","","5","1358","<p>I have an app that fetches a list of items with images URL's from remote API, and then it has to fetch an image per item from given url inside that item's position. 
The problem is that when scrolling up and down and thus removing list items from view and moving them back into view they do show up. However on initial load they stay in ""loading"" status forever until moved out and in. 
My code: </p>

<pre><code>import SwiftUI

struct ContentView: View {

    @EnvironmentObject var artObjectStore: ArtObjectStore
    @State private var pageCount = 1
    @State private var tappedLink: String? = nil
    @Environment(\.imageCache) var cache: ImageCache

    var body: some View {
        NavigationView {
            Form {

                Section(header: Text(""Art"")) {

                    List {
                        ForEach(artObjectStore.artObjects, id: \.self) { artObject in
                            self.link(for: artObject)

                        }
                        Button(action: loadMore) {
                            Text("""")
                        }
                        .onAppear {
                            DispatchQueue.global(qos: .background).asyncAfter(deadline: DispatchTime(uptimeNanoseconds: 10)) {
                                self.loadMore()
                            }
                        }
                    }
                }
            }
            .navigationBarTitle(""Art objects"")
        }
        .onAppear(perform: loadMore)

    }

    func loadMore() {
        pageCount += 1
        artObjectStore.loadMore(pageCount)
    }

    private func link(for artObject: ArtObject) -&gt; some View {
        let selection = Binding(get: { self.tappedLink },
            set: {
                UIApplication.shared.endEditing()
                self.tappedLink = $0
        })

        return NavigationLink(destination: DetailView(artObject: artObject, cache: self.cache),
                              tag: artObject.id,
                              selection: selection) {
            HStack(alignment: .center) {
                VStack(alignment: .leading){
                    Text(""\(artObject.title)"").font(.system(size: 12))
                    Text(""\(artObject.principalOrFirstMaker)"").font(.system(size: 9)).foregroundColor(.gray)
                }
                Spacer()
                AsyncImage(
                    url: URL(string: artObject.headerImage.url)!,
                    cache: self.cache,
                    width: 200,
                    height: 50
                )
            }
        }
    }
}


extension UIApplication {
    func endEditing() {
        sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>

<p><strong>Image container:</strong> </p>

<pre><code>import SwiftUI
import Combine
import Foundation

class ImageLoader: ObservableObject {

    let objectWillChange = ObservableObjectPublisher()

    private var cancellable: AnyCancellable?
    @Published var image: UIImage? {
        willSet {
            objectWillChange.send()
        }
    }


    private let url: URL

    private var cache: ImageCache?

    init(url: URL, cache: ImageCache? = nil) {
        self.url = url
        self.cache = cache
    }

    deinit {
        cancellable?.cancel()
    }

    private func cache(_ image: UIImage?) {
        image.map { cache?[url] = $0 }
    }

    func load() {
        if let image = cache?[url] {
            self.image = image
            return
        }

        cancellable = URLSession.shared.dataTaskPublisher(for: url)
            .map { UIImage(data: $0.data) }
            .replaceError(with: nil)
            .handleEvents(receiveOutput: { [weak self] in self?.cache($0) })
            .receive(on: DispatchQueue.main)
            .assign(to: \.image, on: self)


    }

    func cancel() {
        cancellable?.cancel()
    }
}


struct AsyncImage: View {
    @ObservedObject private var loader: ImageLoader
    private let width: CGFloat?
    private let height: CGFloat?
    @State var spin = false

    init(url: URL, cache: ImageCache? = nil, width: CGFloat? = nil, height: CGFloat? = nil) {
        loader = ImageLoader(url: url, cache: cache)
        self.width = width
        self.height = height
    }

    var body: some View {
        image
            .onAppear(perform: loader.load)
            .onDisappear(perform: loader.cancel)
    }

    private var image: some View {
        Group {
            if loader.image != nil {
                Image(uiImage: loader.image!)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: width, height: height)
            } else {
                Image(""loadingCircle"")
                    .resizable()
                    .frame(width: 20, height: 20)
                    .rotationEffect(.degrees(spin ? 360 : 0))
                    .animation(Animation.linear(duration: 0.8).repeatForever(autoreverses: false))
                    .onAppear() {
                        self.spin.toggle()
                }
            }
        }
    }
}

protocol ImageCache {
    subscript(_ url: URL) -&gt; UIImage? { get set }
}

struct TemporaryImageCache: ImageCache {
    private let cache = NSCache&lt;NSURL, UIImage&gt;()

    subscript(_ key: URL) -&gt; UIImage? {
        get { cache.object(forKey: key as NSURL) }
        set { newValue == nil ? cache.removeObject(forKey: key as NSURL) : cache.setObject(newValue!, forKey: key as NSURL) }
    }
}


struct ImageCacheKey: EnvironmentKey {
    static let defaultValue: ImageCache = TemporaryImageCache()
}

extension EnvironmentValues {
    var imageCache: ImageCache {
        get { self[ImageCacheKey.self] }
        set { self[ImageCacheKey.self] = newValue }
    }
}
</code></pre>

<p>I did try to add willSet on the image, that doesn't seem to work. Can you help me?</p>
","1791703","","1791703","","2020-04-26 15:49:20","2020-04-26 16:18:37","SwiftUI @ObservedObject does not get updated on Async fetch of the image","<ios><swift><xcode><swiftui><combine>","1","2","2","","","CC BY-SA 4.0"
"61447762","1","64192666","","2020-04-26 20:37:38","","3","424","<p>I have a list with selecting rows and a search bar. <strong>Search bar freezes up the list</strong>, but I fixed that using <code>id(UUID())</code></p>
<p>It created another problem, in which when user taps on a row, <strong>scroll jumps to top</strong>. Sometimes, when selecting few rows it <strong>crashes</strong> with this error: <code>precondition failure: attribute failed to set an initial value: 96</code></p>
<pre><code>struct ContentView: View {

@ObservedObject var viewModel = ViewModel()
@State private var searchText: String = &quot;&quot;
@State private var selected = Set&lt;Model&gt;()

var body: some View {
    VStack {
        SearchBar(text: $searchText, placeholder: &quot;Search&quot;)
        List(
            viewModel.strings.filter({ searchText.isEmpty ? true : $0.title.lowercased().contains(searchText.lowercased()) })
        , selection: $selected) { model in
            MultipleSelectionRow(selectedItems: self.$selected, model: model)
        }
        .id(UUID()) /// This line causes strange behaviour.
    }
  }
}
</code></pre>
<p>The full project is available on <a href=""https://gitlab.com/dosboxd/question"" rel=""nofollow noreferrer"">GitLab</a> with other screencasts and files like selection view, search bar and viewModel.</p>
<p><a href=""https://i.stack.imgur.com/2oybe.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2oybe.gif"" alt=""Screencast shows jumping scroll view"" /></a></p>
","11318219","","11318219","","2020-10-04 08:39:31","2020-10-04 08:42:07","SwiftUI: List scrolls up on selection of a row when there's `.id(UUID())`","<ios><swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"61457661","1","","","2020-04-27 11:16:45","","2","164","<p>I'm trying to use VIPER architecture with SwiftUI, using some protocols I was already using with UIKit.</p>
<p>These are my <code>BasePresenter</code> and <code>Assembler</code> implementations:</p>
<pre><code>class BasePresenter &lt;V, I, R&gt;: NSObject, Presenter {
    typealias View = V
    typealias Interactor = I
    typealias Router = R
    
    var view: View!
    var interactor: Interactor!
    var router: Router!
    
    func viewDidLoad() {
           print(&quot;Base presenter: Viewdidload&quot;)
       }
}

protocol Assembler {
    associatedtype CustomView: ViewProtocol
    associatedtype CustomInteractor: Interactor
    associatedtype CustomPresenter: Presenter
    associatedtype CustomRouter: Router
    static func assembleView(_ view: CustomView) -&gt; CustomView
    
}


extension Assembler {
    static func assembleView(_ view: CustomView) -&gt; CustomView {
        let presenter = CustomPresenter.init()
        var view = view
        
        presenter.view = (view as! CustomPresenter.View)
        view.presenter = (presenter as! CustomView.Presenter)
        
        let interactor = CustomInteractor.init()
        interactor.presenter = (presenter as! CustomInteractor.Presenter)
        presenter.interactor = (interactor as! CustomPresenter.Interactor)
        
        let router = CustomRouter.init()
        router.presenter = (presenter as! CustomRouter.Presenter)
        presenter.router = (router as! CustomPresenter.Router)
        
        return view
    }
}
</code></pre>
<p>It was working fine with SwiftUI views until I wanted to add environment objects.</p>
<p>The problem is that if I add it this way:</p>
<pre><code>LoginAssembler.assembleView(LoginView()).environmentObject(user)
</code></pre>
<p>the app crashes when I try to modify it with</p>
<blockquote>
<p>A <code>View.environmentObject(_:)</code> for <code>UserModel</code> may be missing as an ancestor of this view</p>
</blockquote>
<p>I tried to change the environment object injection to the view's initialization, but then it's no longer of type <code>LoginView</code> (it's <code>ModifiedContent&lt;...&gt;</code>) and the assembler crashes.</p>
<pre><code>let view = view.init().environmentObject(environmentObject)
let presenter = CustomPresenter.init()
print(view is LoginView) // Prints false
</code></pre>
<p>Any idea of what could I use to assemble my modules and having the environmentObject option working?</p>
","11010299","","3585796","","2021-11-03 02:56:21","2021-11-03 02:56:21","SwiftUI. How to keep VIPER protocols adding EnvironmentObject?","<swift><swiftui><combine><viper-architecture><environmentobject>","0","0","1","","","CC BY-SA 4.0"
"61465392","1","61466234","","2020-04-27 18:02:00","","1","89","<p>For my understanding, I've written the following code which expands / collapses a section inside of a list.</p>

<pre><code>struct WORKING_CollapsableListView: View {
  @State var sectionExpansionStates = [true, true, true]

  var body: some View {
    VStack {
      List {
          Section(header: CollapsableSectionHeader(expansionState: self.$sectionExpansionStates[0])) {
            if self.sectionExpansionStates[0] {
              ForEach(0..&lt;10) { item in
                Text(""\(item) is \(self.sectionExpansionStates[0] ? ""Expanded"" : ""Collapsed"")"")
                  .frame(height: self.sectionExpansionStates[0] ? 10 : 10)
              }
            }
          }

        Section(header: CollapsableSectionHeader(expansionState: self.$sectionExpansionStates[1])) {
          if self.sectionExpansionStates[1] {
            ForEach(0..&lt;10) { item in
              Text(""\(item) is \(self.sectionExpansionStates[1] ? ""Expanded"" : ""Collapsed"")"")
                .frame(height: self.sectionExpansionStates[1] ? 10 : 10)
            }
          }
        }
        Section(header: CollapsableSectionHeader(expansionState: self.$sectionExpansionStates[2])) {
          if self.sectionExpansionStates[2] {
            ForEach(0..&lt;10) { item in
              Text(""\(item) is \(self.sectionExpansionStates[2] ? ""Expanded"" : ""Collapsed"")"")
                .frame(height: self.sectionExpansionStates[2] ? 10 : 10)
            }
          }
        }
      }
    }
  }
}

struct CollapsableSectionHeader: View {
  @Binding var expansionState: Bool

  var body: some View {
    Button(action: {
      self.expansionState.toggle()
    }) {
      Text(""HEADER: \(expansionState ? ""Expanded"" : ""Collapsed"")"")
        .bold()
    }
  }
}
</code></pre>

<p>This works as expected. However the following code does NOT work. All I've done is replaced the multiple sections with a <code>ForEach</code>. This code should be identical in its behavior, but nothing happens when I tap on the section headers. What am I missing? It's as though the binding isn't working.</p>

<pre><code>struct NOT_WORKING_CollapsableListView: View {
  @State var sectionExpansionStates = [true, true, true]

  var body: some View {
    VStack {
      List {
        ForEach(0 ..&lt; 3) { section in
          Section(header: CollapsableSectionHeader(expansionState: self.$sectionExpansionStates[section])) {
            if self.sectionExpansionStates[section] {
              ForEach(0..&lt;10) { item in
                Text(""\(item) is \(self.sectionExpansionStates[section] ? ""Expanded"" : ""Collapsed"")"")
                  .frame(height: self.sectionExpansionStates[section] ? 10 : 10)
              }
            }
          }
        }
      }
    }
  }
}
</code></pre>
","3900270","","","","","2022-08-23 15:14:16","Binding in SwiftUI fails to work inside of a loop","<xcode><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"61469571","1","61472904","","2020-04-27 22:33:07","","1","291","<p>I have a logon screen followed by an overview screen. When the user is successful at logon, the logon response sends back a list of items, which I want to display on the subsequent overview screen.</p>

<p>I can see the response being successfully mapped but the overview view is not receiving any update to the @ObservedObject. I could be missing something obvious but I've been through a bunch of articles and haven't managed to get anything working. Any help appreciated!</p>

<p><strong>Logon view</strong></p>

<pre><code>import SwiftUI

struct LogonView: View {

    @State private var username: String = """"
    @State private var password: String = """"
    @State private var inputError: Bool = false
    @State private var errorMessage: String = """"
    @State private var loading: Bool? = false
    @State private var helpShown: Bool = false
    @State private var successful: Bool = false


    //MARK:- UIView
    var body: some View {

        NavigationView {

            VStack {

                VStack {
                    TextField(""Username"", text: $username)
                        .padding(.horizontal)
                        .disabled(loading! ? true : false)
                    Rectangle()
                        .frame(height: 2.0)
                        .padding(.horizontal)
                        .foregroundColor(!inputError ? Color(""SharesaveLightGrey"") : Color(""SharesaveError""))
                        .animation(.easeInOut)
                }.padding(.top, 80)


                VStack {
                    SecureField(""Password"", text: $password)
                        .padding(.horizontal)
                        .disabled(loading! ? true : false)
                    Rectangle()
                        .frame(height: 2.0)
                        .padding(.horizontal)
                        .foregroundColor(!inputError ? Color(""SharesaveLightGrey"") : Color(""SharesaveError""))
                        .animation(.easeInOut)
                }.padding(.top, 40)



                if (inputError) {
                    HStack {
                        Text(errorMessage)
                            .padding(.top)
                            .padding(.horizontal)
                            .foregroundColor(Color(""SharesaveError""))
                            .animation(.easeInOut)
                            .lineLimit(nil)
                            .font(.footnote)
                        Spacer()
                    }
                }


                SharesaveButton(action: {self.submit(user: self.username, pass: self.password)},
                       label: ""Log on"",
                       loading: $loading,
                       style: .primary)
                    .padding(.top, 40)
                .animation(.interactiveSpring())


                NavigationLink(destination: OverviewView(), isActive: $successful) {
                    Text("""")
                }

                Spacer()

            }
            .navigationBarTitle(""Hello."")
            .navigationBarItems(
                trailing: Button(action: { self.helpShown = true }) {
                     Text(""Need help?"").foregroundColor(.gray)
                })
                .sheet(isPresented: $helpShown) {
                    SafariView( url: URL(string: ""http://google.com"")! )
            }

        }
    }


    //MARK:- Functions
    private func submit(user: String, pass: String) {

        loading = true
        inputError = false
        let resultsVM = ResultsViewModel()

        resultsVM.getGrants(user: user, pass: pass,

        successful: { response in
            self.loading = false
            if ((response) != nil) { self.successful = true }
        },

        error: { error in
            self.inputError = true
            self.loading = false
            self.successful = false
            switch error {
            case 401:
                self.errorMessage = ""Your credentials were incorrect""
            default:
                self.errorMessage = ""Something went wrong, please try again""
            }
        },

        failure: { fail in
            self.inputError = true
            self.loading = false
            self.successful = false
            self.errorMessage = ""Check your internet connection""
        })
    }
}

</code></pre>

<p><strong>Results View Model</strong></p>

<pre><code>import Foundation
import Moya
import Combine
import SwiftUI

class ResultsViewModel: ObservableObject {

    @Published var results: Results = Results()

    func getGrants(
        user: String,
        pass: String,
        successful successCallback: @escaping (Results?) -&gt; Void,
        error errorCallback: @escaping (Int) -&gt; Void,
        failure failureCallback: @escaping (MoyaError?) -&gt; Void
        )
    {
        let provider = MoyaProvider&lt;sharesaveAPI&gt;()

        provider.request(.getSharesave(username: user, password: pass)) { response in

            switch response.result {

            case .success(let value):
                do {
                    let data = try JSONDecoder().decode(Results.self, from: value.data)
                    self.results = data
                    successCallback(data)

                } catch {
                    let errorCode = value.statusCode
                    errorCallback(errorCode)
                }

            case .failure(let error):
                failureCallback(error)
            }
        }
    }

}
</code></pre>

<p><strong>Overview View</strong></p>

<pre><code>import SwiftUI
import Combine

struct OverviewView: View {

    @ObservedObject var viewModel: ResultsViewModel = ResultsViewModel()

    var body: some View {

        let text = ""\(self.viewModel.results.market?.sharePrice ?? 0.00)""

        return List {
            Text(text)
        }           
    }
}
</code></pre>
","13420081","","","","","2020-04-28 04:57:02","SwiftUI/Combine no updates to @ObservedObject from @Published","<ios><swift><swiftui><combine><observedobject>","2","0","","","","CC BY-SA 4.0"
"61471559","1","61496925","","2020-04-28 02:17:38","","0","1552","<p>I'm trying to wrap my head around Combine, and as I refactor code I'm running into some confusion when I try to re-compose to avoid repeating myself.</p>

<p>In this case, I have a value I want to update any time:</p>

<ul>
<li>A specific subject changes</li>
<li>The app comes to the foreground</li>
<li>A 3-second refresh timer fires</li>
</ul>

<p>Since the 3-second refresh timer doesn't publish anything until the first time it fires, I'm assuming I need multiple publishers.</p>

<p>I'm always only using the value from the subject, and ignoring any values sent from the foreground notification and timer.</p>

<p>Here is some example code, where I am processing the value based on only one publisher:</p>

<pre><code>import UIKit
import Combine

class DataStore {

    @Published var fillPercent: CGFloat = 0

    private var cancellables: [AnyCancellable] = []

    // how much the glass can hold, in milliliters
    private let glassCapacity: Double = 500

    // how full the glass is, in milliliters
    private var glassFillLevelSubject = CurrentValueSubject&lt;Double,Never&gt;(250)

    // a publisher that fires every three seconds
    private let threeSecondTimer = Timer
        .publish(every: 3,
                 on: RunLoop.main,
                 in: .common)
        .autoconnect()

    // a publisher that fires every time the app enters the foreground
    private let willEnterForegroundPublisher = NotificationCenter.default
        .publisher(for: UIApplication.willEnterForegroundNotification)

    init() {
        // publisher that fires any time the glass level changes or three second timer fires
        let glassLevelOrTimerPublisher = Publishers.CombineLatest(glassFillLevelSubject, threeSecondTimer)
            // is there shorthand to only return the first item? like .map{ $0 }?
            .map { glassFillLevel, timer -&gt; Double in
                return glassFillLevel
            }
            .eraseToAnyPublisher()

        // publisher that fires any time the glass level changes or three second timer fires
        let glassLevelOrForegroundPublisher = Publishers.CombineLatest(glassFillLevelSubject, willEnterForegroundPublisher)
            .map{ glassFillLevel, notification -&gt; Double in
                return glassFillLevel
            }
            .eraseToAnyPublisher()

        // how can I define map and everything after it as something, and then subscribe it to the two publishers above?
        glassLevelOrTimerPublisher
            .map{ fillLevelInMilliliters in

                let fillPercent = fillLevelInMilliliters / self.glassCapacity

                return CGFloat(fillPercent)
            }
            .assign(to: \.fillPercent, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>

<p>I think what I want to do here is somehow separate out <code>.map</code> and everything after it, and somehow subscribe that to both publishers above.</p>

<p>I tried this, as a way to isolate everything after <code>.map</code> to make it reusable:</p>

<pre><code>    let fillPercentStream = Publishers.Map{ fillLevelInMilliliters in

        let fillPercent = fillLevelInMilliliters / self.glassCapacity

            return CGFloat(fillPercent)
        }
        .assign(to: \.fillPercent, on: self)
        .store(in: &amp;cancellables)
</code></pre>

<p>But that gave me an error that said <code>Missing argument for parameter 'upstream' in call</code> so I tried adding something for that parameter, and ended up with this:</p>

<pre><code>    let fillPercentStream = Publishers.Map(upstream: AnyPublisher&lt;Double,Never&gt;, transform: { fillLevelInMilliliters in

            let fillPercent = fillLevelInMilliliters / self.glassCapacity

            return CGFloat(fillPercent)
        })
        .assign(to: \.fillPercent, on: self)
        .store(in: &amp;cancellables)
</code></pre>

<p>Then, I end up in a chain of compiler errors: <code>Unable to infer complex closure return type; add explicit type to disambiguate</code> and it suggests I specify <code>-&gt; CGFloat</code> in <code>.map</code>, which I added, but then it tells me I should change <code>CGFloat</code> to <code>_</code> and I end up with more errors.</p>

<p>Is this even something I'm supposed to be able to do with Combine? Am I going about this all the wrong way? How can I properly re-use the <code>.map</code> and <code>.assign</code> chain with two different publishers?</p>

<p>I'm somewhat new to Combine and reactive programming in general, so if you have other suggestions to improve how I'm doing everything here please tell me.</p>
","241163","","","","","2020-04-29 07:59:59","Swift Combine: How can I create a reusable Publishers.Map to connect to multiple upstream Publishers?","<ios><combine>","1","0","","","","CC BY-SA 4.0"
"61482485","1","61482723","","2020-04-28 14:20:23","","1","2042","<p>I am trying to refactor some code where I am currently mixing a Combine publisher with a callback closure.</p>

<p>The code does a login request to a REST endpoint. On failure, I want the caller of the function to receive the error payload (a challenge), on success, the caller doesn't need to do anything. So it's a bit of a weird situation where the caller is ONLY interested in the error.</p>

<p>Currently I am doing it like this (simplified code):</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

struct Challenge {
  let id: Int
}

struct MyError: Error {
  let challenge: Challenge?
}

class UserManager {
  @Published var user: String?

  private func doRequest(username: String, password: String) -&gt; AnyPublisher&lt;String, MyError&gt; {
    // In the real world this does a request to a REST API, returning either a User object or an error containing a Challenge.
    return Fail(outputType: String.self, failure: MyError(challenge: Challenge(id: 1)))
      .eraseToAnyPublisher()
  }

  func login(username: String, password: String, next: @escaping (Challenge) -&gt; ()) -&gt; AnyCancellable {
    doRequest(username: username, password: password)
      .catch { error -&gt; AnyPublisher&lt;String, Never&gt; in
        if let challenge = error.challenge {
          next(challenge)
        }
        return Empty().eraseToAnyPublisher()
      }
      .sink(
        receiveValue: { [weak self] user in
          self?.user = user
        }
      )
  }
}

let userManager = UserManager()
var anyCancellables = Set&lt;AnyCancellable&gt;()

userManager.login(username: ""hello"", password: ""world"") { challenge in
  print(""received challenge!"")
}
.store(in: &amp;anyCancellables)
</code></pre>

<p>As you can see, the <code>login</code> function takes a parameter called <code>next</code>, and the publisher itself handles the value inside the <code>sink</code> operator. It doesn't feel good to combine a publisher with a closure like this, ideally I'd like the <code>login</code> function to have this signature:</p>

<pre class=""lang-swift prettyprint-override""><code>func login(username: String, password: String) -&gt; AnyPublisher&lt;Challenge, Never&gt;
</code></pre>

<p>But when I want to write such a function I am running into the problem where I can't use a <code>sink</code> within the <code>login</code> function itself, since that transforms the return type into a <code>AnyCancellable</code>. Basically I want to turn the error into the publisher's output, and also handle the actual value inside the <code>login</code> function. How is this possible?</p>
","403425","","","","","2020-04-28 14:31:07","Swift Combine: turn error into the publisher's output","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"61520841","1","61521049","","2020-04-30 10:04:23","","2","1585","<p>Sometimes my viewmodel uses a <code>@Published</code> property or a <code>PassthroughSubject</code>, but I don't want this to be writeable to the outside world. Easy enough, turn it into a public <code>AnyPublisher</code> and keep the writable one private, like this:</p>

<pre class=""lang-swift prettyprint-override""><code>class ViewModel {
  @Published private var _models = [""hello"", ""world""]

  var models: AnyPublisher&lt;[String], Never&gt; {
    return $_models.eraseToAnyPublisher()
  }
}

let viewModel = ViewModel()
viewModel.models.sink { print($0) }
</code></pre>

<p>But what if you want to be able to read the value ""on demand"" as well? For example for this situation:</p>

<pre class=""lang-swift prettyprint-override""><code>extension ViewController: UICollectionViewDelegate {
  func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
    print(viewModel.models[indexPath.row])
  }
}

</code></pre>

<p>Obviously, the above code doesn't work. </p>

<p>I thought about using a <code>CurrentValueSubject</code>, but its value is writable too, plus I'm having a hard time turning a Publisher into a CurrentValueSubject anyway. </p>

<p>My current solution is to add something like this on the viewmodel:</p>

<pre class=""lang-swift prettyprint-override""><code>class ViewModel {
  @Published private var _models = [""hello"", ""world""]
  @Published var selectedIndex: Int?

  var models: AnyPublisher&lt;[String], Never&gt; {
    return $_models.eraseToAnyPublisher()
  }

  var selectedModel: AnyPublisher&lt;String, Never&gt; {
    return models.combineLatest($selectedIndex.compactMap { $0 }).map { value, index in
      value[index]
    }.eraseToAnyPublisher()
  }
}

let viewModel = ViewModel()
viewModel.models.sink { print($0) }

viewModel.selectedModel.sink { print($0) }
viewModel.selectedIndex = 1
</code></pre>

<p>But it's a bit of a chore to add the <code>selectedIndex</code> property, the <code>selectedModel</code> publisher, set the selectedIndex and subscribe to the publisher.. all because I want to be able to read the current value of <code>viewModel.models</code> (and not have it writable).</p>

<p>Any better solutions?</p>
","403425","","","","","2020-04-30 10:15:53","Swift Combine: turn a publisher into a read-only CurrentValueSubject","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"61538410","1","","","2020-05-01 07:22:24","","0","145","<p>I am exploring SwiftUI+Combine with a demo app BP Management.</p>

<p>Homescreen has a provision to take bp readings(systolicBP, diastolicBP, pulse &amp; weight).
Button ""Next"" is enabled only when all 4 fields are filled.
control should fall to the next textfield when a valid input is entered. (input is valid when it falls between the range specified by the placeholder - refer the image below)</p>

<p>On tapping next, on the detail screen user can edit the bp values (taken in the HomeScreen), additionally he can add recorded date, notes...</p>

<p>Thought enums would be best model this so I proceeded like</p>

<pre><code>enum SBPInput: CaseIterable {
//name is a Text to indicate the specific row
    typealias Field = (name: String, placeholder: String)

    case spb, dbp, pulse, weight, note, date
    var field: Field {
        switch self {
        case .dbp: return (""DBP"", ""40-250"")
        case .spb: return (""SBP"", ""50-300"")
        case .pulse: return (""Pulse"", ""40-400"")
        case .weight: return (""Weight"", ""30-350"")
        case .note: return (""Note"", """")
        case .date: return ("""", Date().description)
        }
    }

// Here I am getting it wrong, - I can't bind a read only property
    var value: CurrentValueSubject&lt;String, Never&gt; {
        switch self {
        case .date:
            return CurrentValueSubject&lt;String, Never&gt;(Date().description)
        case .spb:
            return CurrentValueSubject&lt;String, Never&gt;("""")
        case .dbp:
            return CurrentValueSubject&lt;String, Never&gt;("""")
        case .pulse:
            return CurrentValueSubject&lt;String, Never&gt;("""")
        case .weight:
            return CurrentValueSubject&lt;String, Never&gt;(""70"")
        case .note:
            return CurrentValueSubject&lt;String, Never&gt;("""")
        }
    }
}
</code></pre>

<pre><code>class HomeViewModel: ObservableObject {

    @Published var aFieldsisEmpty: Bool = true
    var cancellable: AnyCancellable?
    var dataSoure = BPInput.allCases

    init() {

        var bpPublishers = (0...3).map{ BPInput.allCases[$0].value }
        //If a field is empty, we need to disable ""Next"" button
        cancellable = Publishers.CombineLatest4(bpPublishers[0], bpPublishers[1], bpPublishers[2], bpPublishers[3]).map { $0.isEmpty || $1.isEmpty || $2.isEmpty || $3.isEmpty }.assign(to: \.aFieldsisEmpty, on: self)
    }
}
</code></pre>

<p>The idea is to create HStacks for each datasorce(sbp,dbp,pulse,weight) to look like this <a href=""https://i.stack.imgur.com/aR3bX.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/aR3bX.png"" alt=""HomeScreen""></a></p>

<pre><code>struct HomeScreen: View {
    @ObservedObject var viewModel = HomeViewModel()
    var body: some View {
        VStack {
            ForEach(Range(0...3)) { index -&gt; BPField in
                BPField(input: self.$viewModel.dataSoure[index])
            }
            Button(""Next"", action: {
                print(""Take to the Detail screen"")
            }).disabled(self.viewModel.aFieldsisEmpty)
        }.padding()
    }
}

struct BPField: View {
    @Binding var input: BPInput
    var body: some View {
        //implicit HStack
        Text(input.field.name)
        BPTextField(text: $input.value, placeHolder: input.field.name)//Error:- Cannot assign to property: 'value' is a get-only property
        // input.value being read only I can't bind it. How to modify my model now so that I can bind it here?

    }
}

</code></pre>

<p>And my custom TextField</p>

<pre><code>struct BPTextField: View {
    let keyboardType: UIKeyboardType = .numberPad
    var style: some TextFieldStyle = RoundedBorderTextFieldStyle()
    var text: Binding&lt;String&gt;
    let placeHolder: String
    //    var onEdingChanged: (Bool) -&gt; Void
    //    var onCommit: () -&gt; ()
    var background: some View = Color.white
    var foregroundColor: Color = .black
    var font: Font = .system(size: 14)
    var body: some View {
        TextField(placeHolder, text: text)
            .background(background)
            .foregroundColor(foregroundColor)
            .textFieldStyle(style)
    }
}
</code></pre>
","10025683","","10025683","","2020-05-02 04:43:32","2020-05-02 04:43:32","Efficient way to model the data for SwiftUI","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61540210","1","61545671","","2020-05-01 09:51:29","","-1","829","<p>I have a Boolean property with published, then I subscribe to that publisher, every time the boolean value changed, my publisher sends a new value</p>

<pre><code>@Published var booleanProperty: Bool = false
let subscription = $booleanProperty
     .sink { newBool in
        print(newBool)
     }
</code></pre>

<p>my question is, is there an <strong>operator</strong> to ignoring the publishing value if it was similar to the latest one.</p>

<p>like publisher send [true,true, false, false]
I just get [true,false]</p>
","13446911","","","","","2020-05-01 15:37:51","Ignore last value if it was similar to one before in, Operator Combine framework","<ios><swift><combine>","1","3","","","","CC BY-SA 4.0"
"61540292","1","61540669","","2020-05-01 09:58:31","","1","483","<p>I've got a <code>URLSession.shared.dataTaskPublisher</code>, which I store in a Set of <code>AnyCancellable</code>-s. When I receive a value and after that the completion, I want this AnyCancellable to be removed from the Set.</p>

<p>How do I identify this certain AnyCancellable and how do I remove it? Or what is the best way to handle these cases? I checked and it doesn't automatically get removed from the bag once I receive a completion value.</p>

<pre><code>class RandomClass {
    private var cancellableBag: Set&lt;AnyCancellable&gt;()

    func someMethod() {
        let request = URLRequest(...)
        URLSession.shared.dataTaskPublisher(for: request)
            .sink(...)
            .store(in: &amp;self.cancellableBag)
    }
}
</code></pre>
","7761488","","","","","2020-05-01 10:23:48","How do I cancel one certain AnyCancellable in a Set<AnyCancellable>?","<ios><swift><macos><combine>","1","0","","","","CC BY-SA 4.0"
"61553264","1","61579804","","2020-05-02 01:18:09","","24","8481","<p>I'm just learning how to use Combine. I have experience with Rx (RxSwift and RxJava) and I'm noticing that it's quite similar.</p>

<p>However, one thing that is quite different (and kind of annoying) is that the <code>Publisher</code> protocol doesn't use generics for its <code>Output</code> and <code>Failure</code> types; it uses associated types instead.</p>

<p>What this means is that I can't specify a polymorphic <code>Publisher</code> type (such as <code>Publisher&lt;Int, Error&gt;</code>) and simply return any type that conforms to <code>Publisher</code> with those types. I need to use <code>AnyPublisher&lt;Int, Error&gt;</code> instead, and I am forced to include <code>eraseToAnyPublisher()</code> all over the place.</p>

<p>If this is the only option, then I'll put up with it. However, I also recently learned about opaque types in Swift, and I'm wondering if I might be able to use them to get around this.</p>

<p>Is there a way for me to have, say, a function that returns <code>some Publisher</code> and use specific types for <code>Output</code> and <code>Failure</code>?</p>

<p>This seems like a perfect case for opaque types, but I can't figure out if there's a way for me to both use an opaque type and specify the associated types.</p>

<p>I'm picturing something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>func createPublisher() -&gt; some Publisher where Output = Int, Failure = Error {
    return Just(1)
}
</code></pre>
","1234443","","77567","","2020-05-03 18:47:11","2022-08-27 23:07:18","Is there a way to avoid using AnyPublisher/eraseToAnyPublisher all over the place?","<swift><combine><opaque-types>","4","2","9","","","CC BY-SA 4.0"
"61557327","1","61572405","","2020-05-02 09:45:38","","4","2167","<p>Fairly new to Combine.
A common scenario using access tokens and refresh token.</p>

<p>You get a 401 and you need to handle it (call some service to refresh the token) before retrying the initial call again </p>

<pre><code>func dataLoader(backendURL: URL) -&gt; AnyPublisher&lt;Data, Error&gt; {
    let request = URLRequest(url: backendURL)
    return dataPublisher(for: request)
        // We get here when a request fails
        .tryCatch { (error) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), URLError&gt; in
          guard error.errorCode == 401 else {  // UPS - Unauthorized request
                throw error
            }

          // We need to refresh token and retry -&gt; HOW?
          // And try again 
          // return dataPublisher(for: request) 
        }
        .tryMap { data, response -&gt; Data in
            guard let httpResponse = response as? HTTPURLResponse,
                httpResponse.statusCode == 200 else {

                throw CustomError.invalidServerResponse
            }
            return data
        }
        .eraseToAnyPublisher()
}
</code></pre>

<p>How would I go about wrapping this ""token refresh service""?</p>
","7544918","","7544918","","2020-05-02 22:18:59","2020-05-03 09:41:41","401 retry mechanism using Combine Publishers","<ios><swift><networking><mobile><combine>","1","2","2","","","CC BY-SA 4.0"
"61560644","1","","","2020-05-02 14:05:56","","1","1279","<p>How can I get a Publisher for an enum value in Combine?</p>

<p>I want to get notified when a enum property get updated to process the value using combine and create a new Publisher for the elaborated value.</p>

<p>I created a working sample of what I want using hardcoded strings for tags &amp;co. that you can find here <a href=""https://gist.github.com/alessionossa/543a18a55423d98fc415be9edebbddb5"" rel=""nofollow noreferrer"">https://gist.github.com/alessionossa/543a18a55423d98fc415be9edebbddb5</a> . In this sample I can simply use <code>highlightedPanel</code> without any Combine code, but in my real project there is a more complex logic that requires Combine to be used. Now I want to accomplish this using enums to identify NavigationLinks.</p>

<p>Here is a sample of the code:</p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {

    enum SectionPane: Equatable, Identifiable, CustomStringConvertible {

        case servers
        case snippets

        var description: String {
            switch self {
            case .servers:
                return ""server""
            case .snippets:
                return ""snippet""
            }
        }

        var id: SectionPane { self }
    }

    @State var selectedPane: SectionPane? = nil

    // BUG workaround, suggested at https://stackoverflow.com/questions/61003652/selection-in-navigationlink-is-not-working
    @State var highlightedPane: SectionPane? = nil

    // Subscribe to highlightedPane update to update active var
    private var isActivePublisher: AnyPublisher&lt;String, Never&gt; {
        // SPOILER: Value of type 'ContentView.SectionPane' has no member 'publisher'
        return highlightedPane?.publisher
            .map { $0.description }
            .eraseToAnyPublisher() ??
                Just("""").eraseToAnyPublisher()
    }

    @State private var active: String = """"

    var body: some View {
        NavigationView {
            VStack(alignment: .leading) {
                // Current selection label
                Text(""Selected: \(active)"")

                NavigationLink(destination: Text(""first view"").onAppear{ self.highlightedPane = SectionPane.servers }, tag: SectionPane.servers, selection: $selectedPane) {
                    Text(""First"")
                }
                NavigationLink(destination: Text(""second view"").onAppear{ self.highlightedPane = SectionPane.snippets }, tag: SectionPane.snippets, selection: $selectedPane) {
                    Text(""Second"")
                }

                Spacer()
            }.onReceive(isActivePublisher, perform: { selection in
                self.active = selection
            })
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
","5928873","","","","","2020-05-02 14:30:29","Get enum Publisher with Combine","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61565418","1","","","2020-05-02 19:52:08","","1","645","<p>I've got existing code where a <code>UITableView</code> monitors changes to its data source using a delegate (in order to react to taps on section headers to expand / collapse rows).</p>

<p>I'd like to use Combine instead use a subscriber and monitor changes to the data source. The data source is an array, where I'd like to monitor changes to a property of a class. So:</p>

<pre><code>public class SectionViewModel: ObservableObject, Identifiable, Equatable {
  public static func == (lhs: SectionViewModel, rhs: SectionViewModel) -&gt; Bool {
    return lhs.id == rhs.id
  }

  public var id: Int = 0

  @Published var isExpanded = true

  public init(id: Int, isExpanded: Bool = true) {
    self.id = id
    self.isExpanded = isExpanded
  }
}

// Data source
var models = [
  SectionViewModel(id: 0, isExpanded: true),
  SectionViewModel(id: 1, isExpanded: true),
  SectionViewModel(id: 2, isExpanded: true),
  SectionViewModel(id: 3, isExpanded: true),
]
</code></pre>

<p>The model is passed to each of the <code>UITableViewHeaderFooterView</code>s which would then toggle <code>isExpanded</code> when tapped. Do I need to create and maintain an array of subscribers (via <code>sink</code>) and cancel them as and when the contents of the array change? Would the following be the correct approach?</p>

<pre><code>let allModelSubscription = models.map { model in
  model.$isExpanded.sink { (expanded) in
    print(""Model changed: \(model.id)"")
  }
}
</code></pre>

<p>This works but I understandably get bombarded with published changes when the view controller loads the first time. How can I avoid that?</p>
","3900270","","","","","2020-05-04 09:27:07","Observe change in Published property within an array using Combine","<swift><combine>","1","4","2","","","CC BY-SA 4.0"
"61568086","1","61568671","","2020-05-03 00:20:11","","1","184","<p>I've got a situation where I'm trying to determine if an arbitrary number of boolean checks (user defined conditionals) are <code>true</code>. It seems like a job for CombineLatest combined with AllSatisfy... the problem being that CombineLatest only supports a fixed number of elements (2, 3 or 4). Is there some pattern other than using repeated 2-element CombineLatest publishers which combine each result with another of the publishers?</p>

<p>Ideally, I'd like something along the lines of:</p>

<p><code>Publishers.CombineLatestMany(arrayOfPublishers).allSatisfy { ... }</code></p>

<p>and not:</p>

<p><code>Publishers.CombineLatest(pubA, pubB).combineLatest(pubC).combineLatest(pubD) ...</code></p>
","630517","","","","","2020-05-03 23:14:26","How to perform an ""all"" operation on an arbitrary number of Bool Publishers in Combine?","<ios><swift><combine>","1","3","","","","CC BY-SA 4.0"
"61599817","1","61601624","","2020-05-04 19:11:16","","2","509","<p>After scouring a few different resources on Combine, including Joseph Heck and Donny Wals's books, I'm close to understanding chaining of DataTaskPublishers but failing in connecting them together into one series of chained operators.  I seem to be getting hung up on the fact that the errors between the output of the first publisher doesn't match the expected input of the second.  Both Publisher extensions work when not connected, so I am sure it is a lack of ability in joining the two.  I would have thought mapError() would have worked but it does not want to compile.</p>

<p>Here's the setup:</p>

<p>Given two custom publishers:</p>

<pre><code>extension Publisher where Output == MKCoordinateRegion, Failure == URLError {

func toRegionDataTask() -&gt; AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLError&gt; {
    return self
        .flatMap({ region -&gt; URLSession.DataTaskPublisher in
                  ...
                  ... 
                  ...
                  return URLSession.shared.dataTaskPublisher(for: request)       
                  })
        .eraseToAnyPublisher()
    }
}
</code></pre>

<p>and </p>

<pre><code>extension Publisher where Output == [String], Failure == Never {

func toGeographiesDataTask() -&gt;  AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLError {
    return self
        .setFailureType(to: URLError.self)
        .flatMap({ ids -&gt; URLSession.DataTaskPublisher in
                   ...
                   ...
                   ...
                  return URLSession.shared.dataTaskPublisher(for: request)
                 })
         .eraseToAnyPublisher()
}
</code></pre>

<p>}</p>

<p>I then have a function that tries to chain the two together like so:</p>

<pre><code>   let passthroughSubj = PassthroughSubject&lt;MKCoordinateRegion,URLError&gt;()

    passthroughSubj
    .toRegionDataTask()                                         // returns &lt;DataTaskPublisher, URLError&gt;
    .map { $0.data }                                            // returns &lt;FlatMap, ?&gt;
    .decode(type: ApiResponse.self, decoder:JSONDecoder())      // returns &lt;ApiResonse, ?&gt;
    .map {$0.body.data(using: .utf8)! }                         // returns &lt;Data, ?&gt;
    .decode(type: AmznResponse.self, decoder: JSONDecoder())    // returns &lt;AmznResponse, ?&gt;
    .map ({ response -&gt; [AmznItem] in                           //
                return response.contents                        // returns &lt;[AmznItem], ?&gt;
    })
    .map ({ items -&gt; [String] in                                // returns &lt;[String], Never&gt; ?
            var ids = [String]()
            for item in items {
                    ids.append(item.geoid)
            }
            return ids
            })
//
//        .toGeographiesDataTask()                                  // get error ""Referencing instance method
//        .map { $0.data }                                          // 'toGeographiesDataTask()' on 'Publisher'
//        .decode(type: ApiResponse.self, decoder:JSONDecoder())    // requires the types 'Error' and 'Never'
//        .map {$0.body.data(using: .utf8)! }                       // be equivalent""
//        .decode(type: AmznResponse.self, decoder: JSONDecoder())
//        .map { $0.contents }
//
    .sink(receiveCompletion: { (completion) in
        switch completion {
        case .failure(let error):
            print(error)
        case .finished:
            print(""DONE"")
        }
        }, receiveValue: { data in
           print(data)
        })
    .store(in: &amp;cancellables)

passthroughSubj.send(region1)
</code></pre>

<p>If I uncomment the second custom publisher, I get the error message shown on the right.  My understanding was that the .map was returning &lt;[String],Never> but eventually because the DataTaskPublisher could fail I need to map it to URLError instead.  But no combination of .mapError seems to compile either.</p>

<p>Am I missing something fundamental here?  Seems like an easy problem to fix but I'm not finding anything sticking out.</p>

<p>I have seen examples where you use .flatMap to chain these together but since I am transforming the output of one into an input for the second custom publisher that didn't seem possible.</p>

<p>Any help or pointers would be very welcome!  Thanks.</p>
","1569095","","1569095","","2020-05-04 20:20:51","2020-05-04 21:08:05","How to successfully match Failure mappings between two Publishers (Never and URLError)","<combine>","2","0","1","","","CC BY-SA 4.0"
"61604322","1","61627939","","2020-05-05 01:34:26","","0","1258","<p>I have an app that needs to check a status on a server:</p>

<ul>
<li>every 30 seconds</li>
<li>whenever the app enters the foreground</li>
</ul>

<p>I'm doing this by merging two publishers, then calling <code>flatMap</code> the merged publisher's output to trigger the API request.</p>

<p>I have a function that makes an API request and returns a publisher of the result, also including logic to check the response and throw an error depending on its contents.</p>

<p>It seems that once a <code>StatusError.statusUnavailable</code> error is thrown, the <code>statusSubject</code> stops getting updates. How can I change this behavior so the <code>statusSubject</code> continues getting updates after the error? I want the API requests to continue every 30 seconds and when the app is opened, even after there is an error.</p>

<p>I also have a few other points where I'm confused about my current code, indicated by comments, so I'd appreciate any help, explanation, or ideas in those areas too.</p>

<p>Here's my example code:</p>

<pre><code>import Foundation
import SwiftUI
import Combine

struct StatusResponse: Codable {
    var response: String?
    var error: String?
}

enum StatusError: Error {
    case statusUnavailable
}

class Requester {

    let statusSubject = CurrentValueSubject&lt;StatusResponse,Error&gt;(StatusResponse(response: nil, error: nil))

    private var cancellables: [AnyCancellable] = []

    init() {
        // Check for updated status every 30 seconds
        let timer = Timer
            .publish(every: 30,
                      tolerance: 10,
                      on: .main,
                      in: .common,
                      options: nil)
            .autoconnect()
            .map { _ in true } // how else should I do this to be able to get these two publisher outputs to match so I can merge them?

        // also check status on server when the app comes to the foreground
        let foreground = NotificationCenter.default
            .publisher(for: UIApplication.willEnterForegroundNotification)
            .map { _ in true }

        // bring the two publishes together
        let timerForegroundCombo = timer.merge(with: foreground)

        timerForegroundCombo
            // I don't understand why this next line is necessary, but the compiler gives an error if I don't have it
            .setFailureType(to: Error.self)
            .flatMap { _ in self.apiRequest() }
            .subscribe(statusSubject)
            .store(in: &amp;cancellables)
    }

    private func apiRequest() -&gt; AnyPublisher&lt;StatusResponse, Error&gt; {
        let url = URL(string: ""http://www.example.com/status-endpoint"")!
        var request = URLRequest(url: url)
        request.httpMethod = ""GET""
        request.setValue(""application/json"", forHTTPHeaderField: ""Content-Type"")

        return URLSession.shared.dataTaskPublisher(for: request)
            .mapError { $0 as Error }
            .map { $0.data }
            .decode(type: StatusResponse.self, decoder: JSONDecoder())
            .tryMap({ status in
                if let error = status.error,
                    error.contains(""status unavailable"") {
                    throw StatusError.statusUnavailable
                } else {
                    return status
                }
            })
            .eraseToAnyPublisher()
    }
}
</code></pre>
","241163","","","","","2020-05-06 05:30:09","How can I continue URLSession dataTaskPublisher or another Publisher after error?","<ios><swift><combine>","2","2","","","","CC BY-SA 4.0"
"61611522","1","","","2020-05-05 10:58:23","","2","886","<p>I'm struggling with combine two requests. I need <code>id</code> from the first one, then start the second one with this first <code>id</code> from the received list. I can't find a nice solution to do this with Swift Combine. </p>

<p>my first request looks like that <code>CarSerview.shared.getCategories() -&gt; AnyPublisher&lt;[Category], CarError&gt;</code> :</p>

<pre><code> private func getCategories() {
    CarSerview.shared.getCategories()
        .receive(on: DispatchQueue.main)
        .map { car in
           return car.id
        }
        .replaceError(with: [])
        .assign(to: \.carsIds, on: self)
        .store(in: &amp;cancellable)
}
</code></pre>

<p>and the second one looks like that <code>CarSerview.shared.getCar() -&gt; AnyPublisher&lt;Car, CarError&gt;</code>:</p>

<pre><code>private func getCar(_ category: CategoryObject) {
    SPService.shared.getExcursions(category)
        .receive(on: DispatchQueue.main)
        .map { car in
            return car.cars.compactMap { $0.name }
        }
    .sink(receiveCompletion: { error in
        print(error)
    }, receiveValue: { [weak self] result in
        self?.cars = result
    })
}
</code></pre>

<p>how can in chain this two request in one?</p>
","5692398","","4667835","","2020-05-05 11:11:12","2020-05-05 11:11:12","Chaining Request in Combine","<swift><publish-subscribe><combine>","1","8","","","","CC BY-SA 4.0"
"61641077","1","61641411","","2020-05-06 17:09:37","","0","1162","<p>I was trying to create a dynamic Form using SwiftUI and Combine, that loads options of an input (in the example, <code>number</code>) based on another input (in the example, <code>myString</code>).</p>

<p>The problem is that the Combine stack get executed continuously, making lots of network requests (in the example, simulated by the delay), even if the value is never changed. </p>

<p>I think that the expected behavior is that <code>$myString</code> publishes values only when it changes.</p>

<pre><code>class MyModel: ObservableObject {

    // My first choice on the form
    @Published var myString: String = ""Jhon""

    // My choice that depends on myString
    @Published var number: Int?

    var updatedImagesPublisher: AnyPublisher&lt;Int, Never&gt; {
        return $myString
            .removeDuplicates()
            .print()
            .flatMap { newImageType in
                return Future&lt;Int, Never&gt; { promise in

                    print(""Executing..."")

                    // Simulate network request
                    DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                        let newNumber = Int.random(in: 1...200)
                        return promise(.success(newNumber))
                    }
                }
        }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
    }
}

struct ContentView: View {

    @ObservedObject var model: MyModel = MyModel()

    var body: some View {
        Text(""\(model.number ?? -100)"")
            .onReceive(model.updatedImagesPublisher) { newNumber in
                self.model.number = newNumber
            }
    }
}
</code></pre>
","5928873","","","","","2020-05-06 17:27:45","Combine @Published property send values also when not updated","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"61653848","1","61653980","","2020-05-07 09:01:54","","1","757","<p>I'm passing to TextField published variable </p>

<pre><code>TextField(""First name"", text: $state.firstName)
</code></pre>

<p>I want to control imputes: Ignore spaces, if it's entered from the left</p>

<p>Where and how can I do it?</p>
","1752613","","","","","2020-05-07 09:29:41","Ignore left whitespaces on imput in TextField SwiftUI Combine","<swift><swiftui><textfield><combine>","2","0","2","","","CC BY-SA 4.0"
"61656529","1","","","2020-05-07 11:21:59","","0","56","<p>I have a command line app that does the following:</p>

<ul>
<li>downloads an RSS feed with torrent links</li>
<li>stores it in a sqlite database and tags them as ""added"" or ""ignored""</li>
<li>connects to a transmission server (in my local network)</li>
<li>loads items from sqlite marked as ""added"" and adds to transmission server</li>
</ul>

<p>The above works fine in debug mode. However, when I build for release and try to run directly or from launchd, it always times out. The most relevant code is in <code>main.swift</code> which goes below.</p>

<pre class=""lang-swift prettyprint-override""><code>private func getTransmissionClient() -&gt; Transmission? {
        let client = Transmission(
            baseURL: serverConfig.server,
            username: serverConfig.username,
            password: serverConfig.password)

        var cancellables = Set&lt;AnyCancellable&gt;()

        let group = DispatchGroup()
        group.enter()
        print(""[INFO] Connecting to client"")
        client.request(.rpcVersion)
            .sink(
                receiveCompletion: { _ in group.leave() },
                receiveValue: { rpcVersion in
                    print(""[INFO]: Successfully Connected! RPC Version: \(rpcVersion)"")
            })
            .store(in: &amp;cancellables)
        let wallTimeout = DispatchWallTime.now() +
            DispatchTimeInterval.seconds(serverConfig.secondsTimeout ?? 15)
        let res = group.wait(wallTimeout: wallTimeout)

        if res == DispatchTimeoutResult.success {
            return client
        } else {
            return nil
        }

    }

    public func updateTransmission() throws {

        print(""[INFO] [\(Date())] Starting Transmission Update"")

        let clientOpt = getTransmissionClient()
        guard let client = clientOpt else {
            print(""[ERROR] Failed to connect to transmission client"")
            exit(1)
        }

        var cancellables = Set&lt;AnyCancellable&gt;()

        let items = try store.getPendingDownload()
        print(""[INFO] [\(Date())] Adding \(items.count) new items to transmission"")

        let group = DispatchGroup()
        for item in items {

            let linkComponents = ""\(item.link)"".components(separatedBy: ""&amp;"")
            assert(linkComponents.count &gt; 0, ""Link seems wrong"")

            group.enter()
            client.request(.add(url: item.link))
                .sink(receiveCompletion: { completion in
                    if case let .failure(error) = completion {
                        print(""[Failure] \(item.title)"")
                        print(""[Failure] Details: \(error)"")

                    }
                    group.leave()
                }, receiveValue: { _ in
                    print(""[Success] \(item.title)"")
                    do {
                        try self.store.update(item: item, with: .downloaded)

                    } catch {
                        print(""[Error] Couldn't save new status to DB"")
                    }
                })
                .store(in: &amp;cancellables)
        }


        let wallTimeout = DispatchWallTime.now() +
            DispatchTimeInterval.seconds(serverConfig.secondsTimeout ?? 15)
        let res = group.wait(wallTimeout: wallTimeout)
        if res == DispatchTimeoutResult.success {
            print(""Tasks successfully submitted"")
        } else {
            print(""Timed out"")
            exit(1)
        }
    }
</code></pre>

<p>Oddly enough, the code seemed to work fine before I added the database. The DispatchGroup was already there, as well as the Transmission-Swift client. I guess something that I did is being ""optimized away"" by the compiler? This is just speculation though after seeing some other questions on StackOverflow, but I am still not clear on it.</p>

<p>I am using macOS 10.15 and Swift 5.2.2.</p>

<p>Full code available in <a href=""https://github.com/ataias/TorrentRSS/tree/f0f0166d0aac887aaa7bf5a4245f34913c2dc927"" rel=""nofollow noreferrer"">github</a> (link to specific commit that has the bug)</p>
","2304697","","","","","2020-05-11 12:15:37","Not connecting to RPC server in release mode, but works fine in debug mode","<swift><rpc><combine><transmission-daemon>","1","0","","","","CC BY-SA 4.0"
"61696274","1","","","2020-05-09 11:51:55","","1","458","<p>Trying to learn the Combine framework and this operator is popping up: \.</p>

<pre><code>Subscribers.Assign(object: lastPostLabel, keyPath: \.text)
</code></pre>

<p>I don't know what to call it to search for it. Anyone have a reference?</p>
","1839307","","","","","2020-05-09 11:56:49","\. operator in Swift","<swift><combine>","1","2","","2020-05-09 13:01:10","","CC BY-SA 4.0"
"61699032","1","61956883","","2020-05-09 15:16:27","","3","185","<p>I don't understand how implementing in SwiftUI a simple picker showing a list of values that retain the selected value switching between different views. I'm able to use the selected value to update the Model via Combine framework by the way.</p>

<p>here's the code, but the <code>onAppear{}</code>/<code>onDisappear{}</code> doesn't work as expected:</p>

<pre><code>struct CompanyView: View {

    @ObservedObject var dataManager: DataManager = DataManager.shared

    @State var selTipoAzienda = 0

    var body: some View {
        VStack {
            companyPhoto
            Text(""Company view"")
            Form {
                Picker(selection: $selTipoAzienda, label: Text(""Tipo Azienda"")) {
                    ForEach(0 ..&lt;  self.dataManager.company.tipoAziendaList.count) {
                        Text(self.dataManager.company.tipoAziendaList[$0])
                    }
                }
            }

            Button(action:  {self.dataManager.cambiaTipoAzienda(tipoAzienda: self.dataManager.company.tipoAziendaList[self.selTipoAzienda]) }) {
                Image(systemName: ""info.circle.fill"")
                    .font(Font.system(size: 28))
                    .padding(.horizontal, 16)
            }
        }
//        .onAppear{
//            self.selTipoAzienda = self.dataManager.company.tipoAziendaList.firstIndex(of: self.dataManager.company.tipoAzienda) ?? 0
//        }
//        .onDisappear{
//            self.dataManager.cambiaTipoAzienda(tipoAzienda: self.dataManager.company.tipoAziendaList[self.selTipoAzienda])
//        }
    }

</code></pre>

<p>I think binding and didSet would be the answer but I don't know how they have to be implemented</p>
","1937003","","12456741","","2020-05-27 00:35:46","2020-05-27 00:35:46","persistent value in a picker changing views in SwiftUI","<swift><forms><picker><combine>","1","1","","","","CC BY-SA 4.0"
"61702864","1","61746224","","2020-05-09 19:55:54","","2","1099","<p>I am trying to use Combine to perform a POST request. When doing my http request that I used before, my Credentials object comes back with status code 200, so all good. But when I am trying to use the Combine framework, it just returns an error. </p>

<pre><code>finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled""
</code></pre>

<p>How to solve this issue to make my Combine POST request works as expected?</p>

<p>My Combine request that doesn't work and need to be fixed:</p>

<pre><code>func demoLogin() -&gt; AnyPublisher&lt;Credentials, Error&gt; {
  let url = URL(string: ""https://web-api/auth/create-demo-account"")!

  var urlRequest = URLRequest(url: url)
  urlRequest.httpMethod = ""POST""

  return URLSession.shared
    .dataTaskPublisher(for: urlRequest)
    .receive(on: DispatchQueue.main)
    .map(\.data)
    .decode(
      type: Credentials.self,
      decoder: JSONDecoder())
    .eraseToAnyPublisher()
}
</code></pre>

<p>So this is where I sink the value:</p>

<pre><code>final class OnboardingViewModel: ObservableObject {

  private var subscriptions = Set&lt;AnyCancellable&gt;()

  func demoLogin() {
    AuthRequest.shared.demoLogin()
      .sink(
        receiveCompletion: { print($0) },
        receiveValue: {
          print(""Receive value:\nLogin: \($0.login)\nToken: \($0.token)"") })
      .store(in: &amp;subscriptions)
  }
}
</code></pre>

<p>This is the SwiftUI view where the button asks for the call:</p>

<pre><code>struct CredentialsButtons: View {

  @ObservedObject var viewModel = OnboardingViewModel()

  var body: some View {
    VStack {
      Button(action: { self.viewModel.demoLogin() }) {
        Text(""Try demo"")
          .font(.subheadline)
          .fontWeight(.medium)
          .foregroundColor(.blue)
      }
    }
  }
}
</code></pre>

<p>My request that works normally:</p>

<pre><code>  func demoLogin(completion: @escaping (NetworkResult&lt;Credentials&gt;) -&gt; Void) {
    let url = URL(string: ""https://web-api/auth/create-demo-account"")!

    var urlRequest = URLRequest(url: url)
    urlRequest.httpMethod = ""POST""

    let dataTask = authSession.dataTask(with: urlRequest) { data, response, error in
      guard let httpResponse = response as? HTTPURLResponse,
        httpResponse.statusCode == 200,
        let jsonData = data else {
          completion(.failure)
          return
      }
      do {
        let credentials = try JSONDecoder().decode(Credentials.self, from: jsonData)
        completion(.success(credentials))
      }
      catch {
        completion(.failure)
      }
    }
    dataTask.resume()
  }
</code></pre>
","10408494","","10408494","","2020-05-10 08:12:16","2020-05-12 07:37:46","Why is my Combine httpMethod post request not working?","<swift><httprequest><combine>","2","6","","","","CC BY-SA 4.0"
"61705304","1","61705737","","2020-05-09 23:43:51","","1","11292","<p>I'm using Combine and it happens to me many times that I have the need to emit Publishers with single values.</p>

<p>For example when I use flat map and I have to return a Publisher with a single value as an error or a single object I use this code, and it works very well:</p>

<pre><code>return AnyPublisher&lt;Data, StoreError&gt;.init(
           Result&lt;Data, StoreError&gt;.Publisher(.cantDownloadProfileImage)
        )
</code></pre>

<p>This creates an AnyPublisher of type <code>&lt;Data, StoreError&gt;</code> and emits an error, in this case: <code>.cantDownloadProfileImage</code></p>

<p>Here a full example how may usages of this chunk of code.</p>

<pre><code>func downloadUserProfilePhoto(user: User) -&gt; AnyPublisher&lt;UIImage?, StoreError&gt; {
        guard let urlString = user.imageURL,
            let url = URL(string: urlString)
            else {
                return AnyPublisher&lt;UIImage?, StoreError&gt;
                    .init(Result&lt;UIImage?, StoreError&gt;
                        .Publisher(nil))
        }
        return NetworkService.getData(url: url)
            .catch({ (_) -&gt; AnyPublisher&lt;Data, StoreError&gt; in
                return AnyPublisher&lt;Data, StoreError&gt;
                    .init(Result&lt;Data, StoreError&gt;
                        .Publisher(.cantDownloadProfileImage))
            })
            .flatMap { data -&gt; AnyPublisher&lt;UIImage?, StoreError&gt; in
                guard let image = UIImage(data: data) else {
                    return AnyPublisher&lt;UIImage?, StoreError&gt;
                        .init(Result&lt;UIImage?, StoreError&gt;.Publisher(.cantDownloadProfileImage))
                }
                return AnyPublisher&lt;UIImage?, StoreError&gt;
                    .init(Result&lt;UIImage?, StoreError&gt;.Publisher(image))
        }
        .eraseToAnyPublisher()
    }
</code></pre>

<p>Is there an easier and shorter way to create an AnyPublisher with a single value inside?</p>

<p>I think I should use the <code>Just()</code> object in somehow, but I can't understand how, because the documentation at this stage is very unclear.</p>
","6747915","","6747915","","2020-05-10 00:03:02","2021-04-10 16:26:25","iOS Swift Combine: Emit Publisher with single value","<ios><swift><combine>","2","1","3","","","CC BY-SA 4.0"
"61716602","1","61716820","","2020-05-10 18:08:30","","3","1413","<p>I have a button that triggers my view state. As I have now added a network call, I would like my view model to replace the @State with its @Publihed variable to perform the same changes. </p>

<p>How to use my @Published in the place of my @State variable?</p>

<p>So this is my SwiftUI view:</p>

<pre><code>struct ContentView: View {

  @ObservedObject var viewModel = OnboardingViewModel()

  // This is the value I want to use as @Publisher
  @State var isLoggedIn = false

  var body: some View {
    ZStack {
      Button(action: {
        // Before my @State was here
        // self.isLoggedIn = true
        self.viewModel.login()
      }) {
        Text(""Log in"")
      }

      if isLoggedIn {
        TutorialView()
      }
    }
  }
}
</code></pre>

<p>And this is my model: </p>

<pre><code>final class OnboardingViewModel: ObservableObject {

  @Published var isLoggedIn = false

  private var subscriptions = Set&lt;AnyCancellable&gt;()

  func demoLogin() {
    AuthRequest.shared.login()
      .sink(
        receiveCompletion: { print($0) },
        receiveValue: {
          // My credentials
          print(""Login: \($0.login)\nToken: \($0.token)"")
          DispatchQueue.main.async {
            // Once I am logged in, I want this
            // value to change my view.
            self.isLoggedIn = true } })
      .store(in: &amp;subscriptions)
  }
}
</code></pre>
","10408494","","","","","2021-07-28 21:15:19","How to swap my @State of my SwiftUI view for my view model @Published variable?","<swiftui><combine><observableobject>","2","0","1","","","CC BY-SA 4.0"
"61718329","1","61718990","","2020-05-10 20:31:25","","1","180","<p>I have a test which verifies that a message is being published when a new device is available: </p>

<pre class=""lang-swift prettyprint-override""><code>let deviceConnectedPublisher = NotificationCenter.default.publisher(for: .deviceAdded)
            .compactMap { $0.object as AnyObject as? ConnectableDevice }

let sink = deviceConnectedPublisher.sink { _ in
    expectation.fulfill()
}
</code></pre>

<p>this works just fine but I have a compiler warning: </p>

<blockquote>
  <p>Initialization of immutable value 'sink' was never used; consider replacing with assignment to '_' or removing it</p>
</blockquote>

<p>However if I take the compiler's advice and change it to</p>

<pre class=""lang-swift prettyprint-override""><code>let _ = deviceConnectedPublisher.sink { _ in
    expectation.fulfill()
}
</code></pre>

<p>then my test times out, and subsequently fails. Is there a better way to be declaring my sink? Is there some way to tell the compiler it's wrong? Should this be filed as a bug? I understand why the compiler thinks that the variable is unused, but it seems like there should be a way to disable the warning in this case --or more likely-- I'm doing something not-as-intended.</p>
","601830","","","","","2020-05-10 21:30:02","Compiler warning for unused immutable sink, but using _ causes test to fail","<swift><swift5><combine>","2","0","","","","CC BY-SA 4.0"
"61726214","1","","","2020-05-11 09:17:08","","3","908","<h1>Overview</h1>

<p>My app has the feature of favorit-ing objects. There are multiple views that require access to <code>[Favorite]</code> to render UI as well as adding and removing them. </p>

<p>I would like to have a single source of <code>[Favorite]</code> where:</p>

<ol>
<li>all views render UI based on it</li>
<li>updating this source signals all views subscribed to it and rerender based on the updated value</li>
<li>on each update, the source is persisted in <code>UserDefaults</code></li>
<li>updating favorites from UI also updates the Singleton's source, therefore signally other views to update</li>
</ol>

<hr>

<h1>Attempt 1</h1>

<p>I attempted to use <code>@Binding</code> to link the the source but it does not update UI when the source is changed.</p>

<pre><code>class Singleton {
    static let shared = Singleton()

    var favorites = CurrentValueSubject&lt;[Favorite], Never&gt;(someFavorites)
}


class ViewModel: ObservableObject {
    @Binding var favorites: [Favorite]

    init() {
        _favorites = Binding&lt;[Favorite]&gt;(get: { () -&gt; [Favorite] in
            Singleton.shared.favorites.value
        }, set: { newValue in
            Singleton.shared.favorites.send(newValue)
        })
    }
}
</code></pre>

<hr>

<h1>Attempt 2</h1>

<p>I've also attempted creating the binding using <code>Publishers</code> and <code>Subscribers</code> but that ends up in an infinite loop.</p>

<hr>

<p>Thanks in advance</p>
","13516511","","13516511","","2020-05-13 10:04:51","2020-05-13 10:04:51","Singleton publisher with binding to multiple views","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"61730821","1","","","2020-05-11 13:25:16","","1","471","<p>I have a problem with deallocating <code>SecondVM</code> each time when I push to new View from my <code>ContentView</code> and <code>ContentVM</code> finishes his work.</p>

<p><strong>Description</strong></p>

<p>After pushing to <code>Second</code> View, the <code>ObservableObject</code> is deallocated after task in <code>ContentVM</code> is done. </p>

<p>My example code bellow <code>ContentView</code> and `ContentVM:</p>

<pre><code>final class ContentVM: ObservableObject {

@Published var title = ""Start""

init() {
    DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
        self.title = ""Changed""
    }
  }
}

struct ContentView: View {

  @ObservedObject var vm = ContentVM()

  var body: some View {
    NavigationView {
        VStack {
            NavigationLink(destination: Second()) {
                Text(""Go To second"")
            }
            Spacer()
                .frame(height: 40)
            Text(vm.title)
        }
      }   
   }
}
</code></pre>

<p>and <code>Second</code> and <code>SecondVM</code></p>

<pre><code>final class SecondVM: ObservableObject {

  @Published var name: String = """"

  func getName() {
    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
        self.name = ""TEST""
    }
  }
}

struct Second: View {

  @ObservedObject var vm = SecondVM()

  var body: some View {
    Text(vm.name)
    .padding(50)
        .background(vm.name.isEmpty ? Color.white : Color.black)
        .foregroundColor(Color.white)
        .onAppear {
            self.vm.getName()
    }
  }
}
</code></pre>

<p>As you can see on the video bellow problem appears only, when I push to <code>Second</code> View. The Black rectangle appears correctly and after task from <code>ContentVM</code> is done then, this black rectangle disappears because of deallocating <code>SecondVM</code>. How to avoid this kind of behaviour?</p>

<p><a href=""https://i.stack.imgur.com/F1iOe.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/F1iOe.gif"" alt=""enter image description here""></a></p>
","5692398","","","","","2020-05-11 14:05:34","NavigationLink deinit ObservedObject after background task is done","<swiftui><combine><swiftui-navigationlink>","1","0","","","","CC BY-SA 4.0"
"61732121","1","","","2020-05-11 14:28:42","","0","77","<p>I have a simple Loader that performs a loading animation when its @Publisher is set to true. This publisher is set to true on a ViewModel when making a network request. I would like this value to change my view, which it doesn't. The ContentView shown is more complex with many views inside each other, but it is the root view of them all. 
And the loader is a Lottie view that works perfectly when everything is set to true manually. The Loader is a stand-alone @ObservableObject as I want to use it in many others ViewModels.</p>

<p>Why is my <code>@ObservedObject var loader</code> not performing any change in my view state when set from a ViewModel?</p>

<p>My loader:</p>

<pre><code>final class Loader: ObservableObject {
  @Published var isLoading = false
}
</code></pre>

<p>My view model which trigger the loader:
(In the console, the values of the loader are changing accordingly)</p>

<pre><code>final class OnboardingViewModel: ObservableObject {

  @ObservedObject var loader = Loader()

  func demoLogin() {
    loaderIsLoading(true)  // loader set to true
    AuthRequest.shared
      .demoLogin()
      .sink(
        receiveCompletion: {
          self.loaderIsLoading(false) }, // loader set to false
        receiveValue: {
          self.enterDemoAction()
          print(""Login: \($0.login)\nToken: \($0.token)"") })
      .store(in: &amp;subscriptions)
  }

  func loaderIsLoading(_ action: Bool) {
    DispatchQueue.main.async {
      self.loader.isLoading = action
    }
  }
}
</code></pre>

<p>This is the SwiftUI view where I want the magic happens:
(It is much more complicated than this with subviews and components inside each other)</p>

<pre><code>struct ContentView: View {

  @EnvironmentObject var onboardingViewModel: OnboardingViewModel

  @ObservedObject var loader = Loader()

  var body: some View {
    ZStack {
    if loader.isLoading {  // this is where it is not updated
      LottieView(named: .loading,
                 loop: loader.isLoading,
                 width: 220, height: 220)
     }
    }
  }
}
</code></pre>
","10408494","","","","","2020-05-11 14:43:52","Why is my @ObservedObject not performing changes in my view?","<swiftui><combine><observableobject>","1","0","","","","CC BY-SA 4.0"
"61742146","1","61742903","","2020-05-12 01:18:53","","8","3506","<p>I'm starting to experiment with SwiftUI and I have a situation where I want the latest combination of 5 sliders. I had everything working with 4 sliders, using <code>CombineLatest4</code>, then realized I need another slider, but there's no <code>CombineLatest5</code>.</p>
<p>Any help appreciated.</p>
<p>To clarify the working 4-slider version:</p>
<pre><code>Publishers
    .CombineLatest4($slider1, $slider2, $slider3, $slider4)
    .debounce(for: 0.3, scheduler: DispatchQueue.main)
    .subscribe(subscriber)
</code></pre>
","4321521","","1974224","","2021-10-26 06:12:05","2022-01-24 17:30:35","SwiftUI and CombineLatest with more than 4 values","<swiftui><combine>","4","0","","","","CC BY-SA 4.0"
"61753570","1","61758399","","2020-05-12 13:55:22","","3","501","<p>In the code below, an array of app objects is used to create an array of publishers which are merged into an array release objects.</p>

<pre class=""lang-swift prettyprint-override""><code>apps.map { latestRelease(app: $0) }.merge()
</code></pre>

<p>Here is how latest release is done.</p>

<pre class=""lang-swift prettyprint-override""><code>func latestRelease(app: App) -&gt; AnyPublisher&lt;Release, Error&gt; {
    do {
        let request = try requestFactory.make(.get, ""apps/\(app.owner.name)/\(app.name)/releases/latest"")

        return publisherFactory.make(for: request)
            .mapError{ $0 as Error }
            .map { data, _ in data }
            .decode(type: Release.self, decoder: decoder)
            .eraseToAnyPublisher()
    } catch {
        return Fail(error: error)
            .eraseToAnyPublisher()
    }
}
</code></pre>

<p>The network requests are done with a factory.</p>

<pre class=""lang-swift prettyprint-override""><code>struct AppCenterPublisherFactory: DataTaskPublisherFactory {
    let session: URLSession

    init(session: URLSession = .shared) {
        session.configuration.httpMaximumConnectionsPerHost = 1
        self.session = session
    }

    func make(for request: URLRequest) -&gt; URLSession.DataTaskPublisher {
        return session.dataTaskPublisher(for: request)
    }
}
</code></pre>

<p>The problem is the release publishers make network requests immediately. This causes the server to return 429 Too Many Requests. How can I queue up URLSession.DataTaskPublisher requests so that only one is made at a time <strong><em>with a delay between each request</em></strong>?</p>
","1298400","","","","","2020-05-12 17:43:09","How can I queue up URLSession.DataTaskPublisher requests so that only one is made at a time?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"61762410","1","61766270","","2020-05-12 21:35:54","","1","156","<p>I am trying to create a DataModel for my SwiftUI Screen.
The problem I am facing is that I use Core NFC to scan a NFCTag (perform some tasks) and then I want to update the SwiftUI Screen. The data fetch/manipulation occurs asynchronous.</p>

<p><strong>View</strong></p>

<pre><code>struct NFCTest: View {

    @EnvironmentObject var nfcController: NFCController


    var body: some View {
        VStack {
            Button(action: {
                self.nfcController.beginScanning()
            }) {
                Text(""Button"")
            }
</code></pre>

<p><strong>NFCController</strong></p>

<pre><code>final class NFCController: UIViewController, ObservableObject {

@Published var someObject :ObjectStruct //someObject contains a @Published var someVar    
//Tag detected
    func doSomeAsyncCalls {
    //calling functions in other swift files. runs async on another thread. Should change someVar at the end of the calculation
    }
</code></pre>

<p>Now the problem is that nested Observable Objects to do not work in SwiftUI. I tried to make an observable var in NFCController and inside that var I created a published var. But the change is not triggered in SwiftUI.</p>

<p>Are there any concepts to solve this async data flow problem?</p>
","558801","","","","","2020-05-13 04:09:02","How to connect asyc data fetch using Core NFC and Swift UI?","<swift><swiftui><combine><core-nfc>","1","1","","","","CC BY-SA 4.0"
"61782590","1","","","2020-05-13 18:52:02","","1","1088","<p>What I'm trying to do is to resend a request for specific kinds of errors. Let's say for the timeout error specifically I want to retry the request after 3 seconds delay. Obviously, I don't want any delays if the request executed successfully.</p>

<p>I'm using the approach suggested <a href=""https://stackoverflow.com/a/60637050/4933617"">here</a></p>

<pre class=""lang-swift prettyprint-override""><code>var cancellables = Set&lt;AnyCancellable&gt;()

let url = URL(string: ""https://www.apple.com"")!
let sessionConfiguration = URLSessionConfiguration.default
sessionConfiguration.timeoutIntervalForRequest = 1
sessionConfiguration.requestCachePolicy = .reloadIgnoringLocalAndRemoteCacheData

let publisher = URLSession(configuration: sessionConfiguration).dataTaskPublisher(for: url).share()

let head = publisher.print().tryCatch { error -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), URLError&gt; in
    switch error {
    case URLError.timedOut:
        print(""I'm in URLError.timedOut case"")
        return publisher.delay(for: 3, scheduler: DispatchQueue.main).eraseToAnyPublisher()

    default:
        print(""I'm in default case"")
        throw error
    }
}.retry(3)

head.map { data, response in
    return data
}.sink(receiveCompletion: {
    print(""completion \($0)"")
}, receiveValue: {
    print(""value \($0)"")
}).store(in: &amp;cancellables)
</code></pre>

<p>For the test purpose I set 1 second timeout interval for the URLSession and throttle my network connection expecting to see 4 failed requests when the whole pipeline finishes in about 10 seconds. But what I actually see is just one failed request and printed completion with a failure after some time. To me it seems like I do return <code>publisher</code> from <code>tryCatch</code> operator every three seconds but for some reason it doesn't happen to send a new request. </p>

<p>What am I missing? Are there any alternative solutions to this problem?</p>

<p>UPDATED 14/05/2020</p>

<p>I added <code>print()</code> operator right before <code>tryCatch</code>, and some printing inside closure. What I see in console is this</p>

<pre><code>receive subscription: (Multicast)
request unlimited
receive error: (URLError(_nsError: Error Domain=NSURLErrorDomain Code=-1001 ""The request timed out.""...))
I'm in URLError.timedOut case
receive subscription: (Multicast)
request unlimited
receive error: (URLError(_nsError: Error Domain=NSURLErrorDomain Code=-1001 ""The request timed out."" ...))
I'm in URLError.timedOut case
receive subscription: (Multicast)
request unlimited
receive error: (URLError(_nsError: Error Domain=NSURLErrorDomain Code=-1001 ""The request timed out."" ...))
I'm in URLError.timedOut case
receive subscription: (Multicast)
request unlimited
receive error: (URLError(_nsError: Error Domain=NSURLErrorDomain Code=-1001 ""The request timed out."" ...))
I'm in URLError.timedOut case
completion failure(Foundation.URLError(_nsError: Error Domain=NSURLErrorDomain Code=-1001 ""The request timed out.""...))
</code></pre>

<p>But what I see in my Charles http proxy is exactly one request, the one that's sent before retries</p>
","4933617","","4933617","","2020-05-14 11:04:20","2020-05-14 12:37:58","URLSession dataTaskPublisher retry after delay on specific errors","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"61785359","1","64642330","","2020-05-13 21:41:29","","3","910","<p>I have an AccountService class that holds a User object. The user object gets set async from a network request.
In my UI I'm displaying the user and want to keep changes up to date. I'm using the Swift Combine  Framework to do this.</p>

<h1>Question: Is there a way to avoid nested subscribers on an object?</h1>

<p>I wrote some test code to illustrate this:</p>

<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Combine

class User: ObservableObject, CustomDebugStringConvertible {
    @Published
    var name: String

    init(name: String) {
        self.name = name
    }

    var debugDescription: String {
        return self.name
    }
}

class AccountService {

    @Published
    var user: User? = nil

    var userCancel: AnyCancellable?
    var userContentCancel: AnyCancellable?
    init() {
        self.userCancel = self.$user.sink { (user) in
            print(""Set user: \(String(describing: user))"")

            guard let user = user else { return }
            self.userContentCancel = user.$name.sink { _ in
                print(""new name: \(String(describing: self.user))"")
            }
        }
    }

    func setUseru(user: User) {
        self.user = user
    }

    func changeUserName(name: String) {
        self.user?.name = name
    }
}

let x = AccountService()
x.setUseru(user: User(name: ""Philipp""))
x.changeUserName(name: ""Tom"")
x.setUseru(user: User(name: ""Anna""))
</code></pre>

<p><em>Run in Playgroud Xcode Version 11.4.1, Swift 5</em></p>

<h2>Output</h2>

<pre><code>Set user: nil
Set user: Optional(Philipp)
new name: nil
new name: Optional(Philipp)
Set user: Optional(Anna)
new name: Optional(Tom)
</code></pre>

<p>Ideally I'd like only to listen to <code>self.$user.sink</code> for when the object is set <strong>AND</strong> for when the content of the object changes. 
I've played around with <code>self.objectWillChange.send()</code> when setting the username, but I'm not able to trigger the outer publisher.</p>

<p>I'm looking for a way to get rid of</p>

<pre class=""lang-swift prettyprint-override""><code>guard let user = user else { return }
self.userContentCancel = user.$name.sink { _ in
    print(""new name: \(String(describing: self.user))"")
}
</code></pre>

<p>in my implementation and just drive everything from the same <code>self.$user.sink { (user) in</code> implementation.</p>
","366967","","","","","2020-11-02 08:46:35","Swift Combine, Avoid nested subscribers on optionals","<ios><swift><swift5><combine>","1","4","0","","","CC BY-SA 4.0"
"61802005","1","61802360","","2020-05-14 16:05:16","","3","126","<p>I am currently trying to learn Swift+Combine, but I even fail at replicating a simple tutorial.</p>

<p>My current playground project looks as follows:</p>

<pre><code>import Combine
import Foundation

let future = Future&lt;Int, Never&gt; { promise in
    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
        print(""hello"")
        promise(.success(1))
    }
}

future.sink(receiveCompletion: { print($0) },
            receiveValue: { print($0) })

print(""end"")

DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    print(future)
}
</code></pre>

<p>I would have expected as output:</p>

<pre><code>end
hello
1
finished
Combine.Future&lt;Swift.Int, Swift.Never&gt;
</code></pre>

<p>But when I run this code, the output only displays:</p>

<pre><code>end
hello
Combine.Future&lt;Swift.Int, Swift.Never&gt;
</code></pre>

<p>It seems to swallow the whole sink. At first I thought maybe the future was already deleted by the time the DispatchQueue fired its callback, but this does not seem to be the case.</p>

<p>Can someone explain to me what I am doing wrong?</p>
","11936252","","","","","2020-05-14 16:22:14","Future with asynchronous resolve does not fire","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"61803003","1","61803807","","2020-05-14 16:55:42","","4","1863","<p>I would like to have one <code>Subject</code> (similar to <code>CurrentValueSubject</code>) I can publish into, but that validates the value I'm sending. For example, I would like to validate that the input is forced between a range of values, like 1 and 10. If higher than the max, pass the maximum, if lower then the min, pass the minimum.</p>

<p>Please don't tell me to filter the result on the subscribing code because that's what I'm trying to avoid. That duplication.</p>

<p>Pseudo code would be: </p>

<pre class=""lang-swift prettyprint-override""><code>let intSubject = ValidatedValueSubject&lt;Int&gt;(value: 5, min: 1, max: 10)

intSubject.sink { value in  print(value) }

intSubject.send(-10)
intSubject.send(5)
intSubject.send(15)
</code></pre>

<p>I would like this to produce: </p>

<pre><code>5
1
5
10
</code></pre>

<p>Obviously with <code>CurrentValueSubject</code> I can't achieve that effect. 
I tried to create my own custom Subject but I can't seem to make it work. </p>

<p>Something tells me I should look at my problem differently because I guess this is too easy to need a custom <code>Subject</code>.</p>

<p>The use case: </p>

<p>I have a settings class which is updated on a Settings screen, and everywhere else, when the value change I want the screens to react accordingly. The <code>ValidatedValueSubject</code> lives inside this Settings object. </p>

<p>The Settings need to expose the <code>Subject</code> so any screens can react upon changes to the property. </p>

<p>My approach to the custom <code>Subject</code>is as follows:</p>

<pre class=""lang-swift prettyprint-override""><code>final class QualitySubject: Subject {

    public typealias Output = Int
    public typealias Failure = Never

    public private(set) var value: Output
    private let max: Output
    private let min: Output

    init(value: Output, max: Output, min: Output) {
        self.min = min
        self.max = max
        self.value = value
        self.value = validated(value)
    }

    private func validated(_ value: Output) -&gt; Int {
        return max(min, min($0, max))
    }

    var subscription: [???? QualitySubscription ?????] = []

    public func send(_ value: Output) {
        self.value = validated(value)
        subscription.subscriber.receive(value)
    }

    public func send(completion: Subscribers.Completion&lt;Failure&gt;) {
        print(""completion"")
    }

    public func send(subscription: Subscription) {
        print(""send subscription"")
    }


    public func receive&lt;S&gt;(subscriber: S) where S : Subscriber, S.Failure == Failure, S.Input == Output {
        let qualitySubscription = QualitySubscription(value: value, subscriber: subscriber)
        subscriber.receive(subscription: qualitySubscription)

        // I think I should save a reference to the subscription so I could forward new values afterwards (on send method) but I can't because of generic constraints.
    }
}

</code></pre>
","919445","","919445","","2020-05-14 20:52:32","2021-03-25 12:31:25","Swift Combine create a custom Subject","<swift><combine>","2","0","2","","","CC BY-SA 4.0"
"61808451","1","","","2020-05-14 22:23:27","","0","42","<p>I'm trying to think in terms of API Design because ultimately I want to ship code to myself or others.</p>

<p>Let's make some assumptions in order to get a succinct scenario. We will assume I have some Code that authenticates with my server and returns a user object. Defined simply like this:</p>

<pre class=""lang-swift prettyprint-override""><code>public struct User: Codable {
    public let id: UUID
    public let email: String
    public let name: String
}
</code></pre>

<p>I'm writing this code as an SDK I would ship to myself or a third party where all the guts of AUTH are handled. Using Apples new Combine framework I might expose a publisher for the consumer of my SDK like this.</p>

<pre class=""lang-swift prettyprint-override""><code>public enum CurrentUserError: Error {
    case loggedOut
    case sessionExpired
}

public struct MyAuthFrameworkPublishers {
    static let currentUser: CurrentValueSubject&lt;User?, CurrentUserError&gt; = CurrentValueSubject&lt;User?, CurrentUserError&gt;(nil)
}
</code></pre>

<p>Now, my private auth could accomplish it's task and retrieve a user then publish that to anything outside the SDK that it listening like so:</p>

<pre class=""lang-swift prettyprint-override""><code>class AuthController {
    func authenticate() {
        ///Get authenticated user.
        let user = User.init(id: UUID(), email: ""some@some.com"", name: ""some"")
        MyAuthFrameworkPublishers.currentUser.send(user)
    }
}
let authController = AuthController.init()
authController.authenticate()
</code></pre>

<p>Is there a way to keep or stop the user of this SDK from sending it's own <code>User</code> object to the publisher? Like a private or access controller <code>.send()</code> function in combine?</p>
","4576323","","3418066","","2020-05-14 22:55:44","2020-05-15 01:06:26","Access modification Apple Combine","<ios><swift><swiftui><combine>","1","6","","","","CC BY-SA 4.0"
"61816898","1","61816964","","2020-05-15 10:16:49","","1","63","<p>I'm trying to update a view with a simple Observable pattern, but it doesn't happen for some reason. The Publisher gets updated, but the subscriber doesn't. I've simplified to the code below. When you click the Add button, the view doesn't get updated and also the variable.</p>

<p>I'm using this function (NetworkManager.shared.saveNew()), because I update after a CloudKit notification. If you know a workaround, I'd be pleased to know!</p>

<pre><code>import SwiftUI
import Combine

public class NetworkManager: ObservableObject {
    static let shared = NetworkManager()

    @Published var list = [DataSource]()

    init() {
        self.list = [DataSource(id: ""Hello"", action: [1], link: ""http://hello.com"", year: 2020)]
    }

    func saveNew(item: DataSource) {
        self.list.append(item)

    }
}

struct DataSource: Identifiable, Codable {

    var id: String
    var action: [Int]
    var link: String
    var year: Int

    init(id: String, action: [Int], link: String, year: Int) {
        self.id = id
        self.action = action
        self.link = link
        self.year = year
    }
}


struct ContentView: View {

    @ObservedObject var list = NetworkManager()

    var body: some View {
        VStack {
            Button(""Add"") {
                NetworkManager.shared.saveNew(item: DataSource(id: ""GoodBye"", action: [1], link: ""http://goodbye"", year: 2030))

            }
            List(list.list, id:\.id) { item in
                Text(item.id)
            }
        }

    }
}
</code></pre>
","11144632","","","","","2020-05-15 10:21:38","@ObservedObject does not get updated","<ios><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61821575","1","","","2020-05-15 14:24:56","","2","1845","<p>Currently, I am trying to parse a single object and decode it ready for an Output into a Text() in my SwiftUI view, but I cannot create an instance without parameters. </p>

<p>I have found many resources for dynamically creating lists, but this is just one standalone object. 
A lot of resources have shown how to create a @Published variable using arrays, but I only want one object. </p>

<ul>
<li>The error I am getting is 'Cannot invoke initializer for type 'Welcome' with no arguments'</li>
<li>The URL is <a href=""https://beta.ourmanna.com/api/v1/get/?format=json"" rel=""nofollow noreferrer"">https://beta.ourmanna.com/api/v1/get/?format=json</a>.</li>
</ul>

<p>The decoding structs I have built are: </p>

<pre class=""lang-swift prettyprint-override""><code>// MARK: - Welcome
struct Welcome: Codable {
    let verse: Verse
}

// MARK: - Verse
struct Verse: Codable {
    let details: Details
    let notice: String
}

// MARK: - Details
struct Details: Codable {
    let text, reference, version: String
    let verseurl: String
}
</code></pre>

<p>I created the following fetcher: </p>

<pre class=""lang-swift prettyprint-override""><code>public class VerseFetcher: ObservableObject {
    @Published var verse = Welcome()

    init(){
        load()
    }

    func load() {
        let url = URL(string: ""https://beta.ourmanna.com/api/v1/get/?format=json"")!

        URLSession.shared.dataTask(with: url) {(data,response,error) in
            do {
                if let d = data {
                    let webData = try JSONDecoder().decode(Verse.self, from: d)
                    DispatchQueue.main.async {
                        self.verse = webData
                    }
                }else {
                    print(""No Data"")
                }
            } catch {
                print (""Error here"")
            }

        }.resume()
    }
}
</code></pre>

<p>I have tried this solution to get an Output: </p>

<pre class=""lang-swift prettyprint-override""><code>struct DailyVerseView: View {
    @ObservedObject var fetcher = VerseFetcher()

    var body: some View {

        Text(self.fetchVerse.todos.verse.details.text)
            .fontWeight(.semibold)
            .font(.caption)
            .foregroundColor(.secondary)
            .padding(.leading, 16)
            .padding(.trailing, 16)
            .padding(.top, 8)
            .padding(.bottom, 8)
    }
}
</code></pre>

<p>The JSON I am reading from the URL at <a href=""https://beta.ourmanna.com/api/v1/get/?format=json"" rel=""nofollow noreferrer"">https://beta.ourmanna.com/api/v1/get/?format=json</a> is: </p>

<pre><code>{
  ""verse"": {
    ""details"": {
      ""text"": ""The world and its desires pass away, but the man who does the will of God lives forever."",
      ""reference"": ""1 John 2:17"",
      ""version"": ""NIV"",
      ""verseurl"": ""http://www.ourmanna.com/""
    },
    ""notice"": ""Powered by OurManna.com""
  }
}
</code></pre>

<p>How can I create the Verse struct without parameters, as it is dynamic from the URL response? </p>
","13549430","","506441","","2020-05-16 10:21:44","2020-05-26 15:57:05","How to parse single JSON object from URL in SwiftUI using combine?","<json><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61827121","1","61827238","","2020-05-15 19:42:07","","1","48","<p>In my application, I have the need to reinstantiate an <code>@EnvironmentObject</code> at the tap of a button. Where is the right spot to do that?</p>

<p>Here's a screenshot of my view - in the Archived Objects list, I want to have immutable objects. So, when I tap <code>Archive Object</code>, I want to add the current object to the array and create a new current object.</p>

<p><a href=""https://i.stack.imgur.com/myoh1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/myoh1.png"" alt=""enter image description here""></a></p>

<p>A simplified version of the app looks as follows.</p>

<p>I instantiate the object in the <code>SceneDelegate</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    var myObject = MyObject()
    let myObjects = MyObjects()

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

        let contentView = ContentView()
            .environmentObject(myObject)
            .environmentObject(myObjects)

        if let windowScene = scene as? UIWindowScene {
            let window = UIWindow(windowScene: windowScene)
            window.rootViewController = UIHostingController(rootView: contentView)
            self.window = window
            window.makeKeyAndVisible()
        }
    }

    //.....
}
</code></pre>

<p>Here's my models:</p>

<pre class=""lang-swift prettyprint-override""><code>class MyObject: ObservableObject, Identifiable {
    @Published var id = UUID()
}

class MyObjects: ObservableObject {
    @Published var values: [MyObject] = [
        MyObject(),
        MyObject()
    ]
}
</code></pre>

<p>In my view, I have the need to put my current object to an (archive) array and then create a new current object to work with. Here's what I'm trying:</p>

<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {

    @EnvironmentObject var currentObject: MyObject
    @EnvironmentObject var objects: MyObjects

    var sceneDelegate: UISceneDelegate {
        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
            let sd = windowScene.delegate as? SceneDelegate else { fatalError() }
        return sd
    }

    var body: some View {
        VStack {
            Form {
                Section(header: Text(""Current Object"")) {
                    Text(currentObject.id.uuidString)
                }
                Section(header: Text(""Archived Objects"")) {
                    List(objects.values, id: \.id) { object in
                        Text(object.id.uuidString)

                    }
                    Button(action: {
                        self.objects.values.append(self.currentObject)

// as the environment object is get only, I cannot reinstantiate it here...
//                        self.currentObject = MyObject()
                    }) {
                        Text(""Archive Object"")
                    }
                }
            }

            Spacer()
        }
    }
}
</code></pre>
","3855266","","","","","2020-05-17 07:22:28","Reinstantiate an @EnvironmentObject in a view","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61841254","1","61968621","","2020-05-16 17:57:32","","17","6324","<p>I'm having a bit of a mental block using the iOS Combine framework.</p>

<p>I'm converting some code from ""manual"" fetching from a remote API to using Combine. Basically, the API is SQL and REST (in actual fact it's Salesforce, but that's irrelevant to the question). What the code used to do is call a REST query method that takes a completion handler. What I'm doing is replacing this everywhere with a Combine Future. So far, so good.</p>

<p>The problem arises when the following scenario happens (and it happens a lot):</p>

<ol>
<li><p>We do a REST query and get back an array of ""objects"".</p></li>
<li><p>But these ""objects"" are not completely populated. Each one of them needs additional data from some related object. So for each ""object"", we do another REST query using information from that ""object"", thus giving us <em>another</em> array of ""objects"".</p></li>
<li><p>This might or might not allow us to finish populating the first ""objects"" — or else, we might have to do <em>another</em> REST query using information from each of the <em>second</em> ""object"", and so on.</p></li>
</ol>

<p>The result was a lot of code structured like this (this is pseudocode):</p>

<pre><code>func fetchObjects(completion: @escaping ([Object] -&gt; Void) {
    let restQuery = ...
    RESTClient.performQuery(restQuery) { results in
        let partialObjects = results.map { ... }
        let group = DispatchGroup()
        for partialObject in partialObjects {
            let restQuery = ... // something based on partialObject
            group.enter()
            RESTClient.performQuery(restQuery) { results in
                group.leave()
                let partialObjects2 = results.map { ... }
                partialObject.property1 = // something from partialObjects2
                partialObject.property2 = // something from partialObjects2
                // and we could go down yet _another_ level in some cases
            }
        }
        group.notify {
            completion([partialObjects])
        }
    }
}
</code></pre>

<p>Every time I say <code>results in</code> in the pseudocode, that's the completion handler of an asynchronous networking call.</p>

<p>Okay, well, I see well enough how to chain asynchronous calls in Combine, for example by using Futures and <code>flatMap</code> (pseudocode again):</p>

<pre><code>let future1 = Future...
future1.map {
    // do something
}.flatMap {
    let future2 = Future...
    return future2.map {
        // do something
    }
}
// ...
</code></pre>

<p>In that code, the way we form <code>future2</code> can depend upon the value we received from the execution of <code>future1</code>, and in the <code>map</code> on <code>future2</code> we can modify what we received from upstream before it gets passed on down the pipeline. No problem. It's all quite beautiful.</p>

<p>But that doesn't give me what I was doing in the pre-Combine code, namely <em>the loop</em>. Here I was, doing <em>multiple</em> asynchronous calls in a <em>loop</em>, held in place by a DispatchGroup before proceeding. The question is:</p>

<p><em>What is the Combine pattern for doing that?</em></p>

<p>Remember the situation. I've got an <em>array</em> of some object. I want to <em>loop</em> through that array, doing an asynchronous call for <em>each</em> object in the loop, fetching new info asynchronously and modifying that object on that basis, before proceeding on down the pipeline. And each loop might involve a further <em>nested</em> loop gathering even <em>more</em> information asynchronously:</p>

<pre><code>Fetch info from online database, it's an array
   |
   V
For each element in the array, fetch _more_ info, _that's_ an array
   |
   V
For each element in _that_ array, fetch _more_ info
   |
   V
Loop thru the accumulated info and populate that element of the original array 
</code></pre>

<p>The old code for doing this was horrible-looking, full of nested completion handlers and loops held in place by DispatchGroup <code>enter</code>/<code>leave</code>/<code>notify</code>. <em>But it worked</em>. I can't get my Combine code to work the same way. How do I do it? Basically my pipeline output is an array of something, I feel like I need to split up that array into individual elements, do something <em>asynchronously</em> to each element, and put the elements back together into an array. How?</p>

<hr>

<p>The way I've been solving this works, but doesn't scale, especially when an asynchronous call needs information that arrived several steps <em>back</em> in the pipeline chain. I've been doing something like this (I got this idea from <a href=""https://stackoverflow.com/a/58708381/341994"">https://stackoverflow.com/a/58708381/341994</a>):</p>

<ol>
<li><p>An array of objects arrives from upstream.</p></li>
<li><p>I enter a <code>flatMap</code> and <code>map</code> the array to an array of publishers, each headed by a Future that fetches further online stuff related to <em>one</em> object, and followed by a pipeline that produces the <em>modified</em> object.</p></li>
<li><p>Now I have an array of pipelines, each producing a single object. I <code>merge</code> that array and produce that publisher (a MergeMany) from the <code>flatMap</code>.</p></li>
<li><p>I <code>collect</code> the resulting values back into an array.</p></li>
</ol>

<p>But this still seems like a lot of work, and even worse, it doesn't scale when each sub-pipeline itself needs to spawn an array of sub-pipelines. It all becomes incomprehensible, and information that used to arrive easily into a completion block (because of Swift's scoping rules) no longer arrives into a subsequent step in the main pipeline (or arrives only with difficulty because I pass bigger and bigger tuples down the pipeline).</p>

<p>There must be some simple Combine pattern for doing this, but I'm completely missing it. Please tell me what it is.</p>
","341994","","341994","","2020-05-23 20:43:38","2020-08-18 16:48:45","Combine framework: how to process each element of array asynchronously before proceeding","<ios><swift><combine>","2","7","8","","","CC BY-SA 4.0"
"61846563","1","61848870","","2020-05-17 03:23:08","","8","2353","<p>How to convert:</p>

<pre><code>func getResults(completion: ([Result]?, Error) -&gt; Void)
</code></pre>

<p>Into</p>

<pre><code>var resultsPublisher: AnyPublisher&lt;[Result], Error&gt;
</code></pre>

<p>Just a scheme how I see it is (this syntax doesn't exist):</p>

<pre><code>var resultsPublisher: AnyPublisher&lt;[Result], Error&gt; {
  let publisher: AnyPublisher = ... // init
  getResults { results, error in
     guard let results = results else {
       publisher.produce(error: error) // this syntax doesn't exist
       return
     }

     publisher.produce(results: results)  // this syntax doesn't exist

  }

  return publisher
}
</code></pre>

<p>I need that because some 3d party SDKs use <code>completion closures</code> and I want to write extensions to them that return <code>Publishers</code>.</p>
","1328838","","","","","2020-05-17 10:45:45","Combine: Convert Closure into Publisher","<ios><closures><swiftui><combine><publisher>","1","3","3","","","CC BY-SA 4.0"
"61850457","1","","","2020-05-17 10:39:32","","0","339","<p>I'm developing a quiz app for tvOS with <em>Swift</em> and <em>SwiftUI</em> framework. I have a <strong>QuestionBank</strong> class and <strong>Question</strong> struct to set my questions and I made a <strong>QuizManager</strong> class that interacts with the game View coded with SwiftUI. So I'll pass data using <em>Combine</em> framework.</p>

<p>But it's getting tricky when in QuizManager, I want to declare <strong>@Published</strong> variables whereas some of these variables need another #Published variable to be computed. Indeed I have 3 @Published variables at the moment: </p>

<ul>
<li>questionNumber</li>
<li>questionText</li>
<li>answers</li>
</ul>

<p>This is my code for QuizManager :</p>

<pre><code>import Combine
import Foundation

class QuizManager: ObservableObject {
    var questionBank: QuestionBank

    @Published var questionNumber = 0
    @Published var questionText: String
    @Published var answers: [String]

    func updateQuestion() {
        self.questionNumber += 1
    }

    init() {
        self.questionNumber = 0
        self.questionBank = QuestionBank()
        self.questionText = questionBank.questions[questionNumber].questionText
        self.answers = questionBank.questions[questionNumber].answers
    }

}
</code></pre>

<p>As you can see I must init questionNumber before using it to init the other @Published variables.</p>
","11169590","","","","","2020-05-17 12:23:25","'self' used in property access 'questionNumber' before all stored properties are initialized (Combine)","<swift><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"61851184","1","61853563","","2020-05-17 11:41:03","","0","606","<p>I would like to use the <code>collect</code> method of Combine to split an array of objects into Array of multiples Arrays which would correspond to Rows in a Collection View (eg: <code>[Item, Item, Item, Item, Item]</code> would become <code>[[Item, Item, Item], [Item, Item]]</code> and so on)</p>

<p>My data is coming from two publisher that I'm chaining to merge my data into a single type consumed by my view.</p>

<p>Here is my code :</p>

<pre><code>APIClient().send(APIEndpoints.searchMovies(for: text)).flatMap { response -&gt; AnyPublisher&lt;APIResponseList&lt;TVShow&gt;, Error&gt; in
            movies = response.results.map { SearchItemViewModel(movie: $0)}
            return APIClient().send(APIEndpoints.searchTVShows(for: text))
        }
        .map { response -&gt; [SearchItemViewModel] in
            tvShows = response.results.map { SearchItemViewModel(tvShow: $0)}
            let concatItems = tvShows + movies
            return concatItems.sorted { $0.popularity &gt; $1.popularity }
        }
        .collect(3)
        .sink(receiveCompletion: { (completion) in
            switch completion {
            case .failure:
                self.state = .error
                self.items = []
            case .finished:
                break
            }
        }, receiveValue: { (response) in
            self.state = .data
            self.items = response
        })
            .store(in: &amp;disposables)
</code></pre>

<p>My problem currently is that inside my <code>sink</code> <code>receiveValue</code> closure, the <code>response</code> parameter doesn't equal the expected result, it just group all my items into an array like this : <code>[Item, Item, Item, Item, Item]</code> -> <code>[[Item, Item, Item, Item, Item]]</code>
It seems that the <code>collect</code> method is not working as expected, any idea about how I could fix this ? </p>
","8324584","","","","","2020-05-17 15:13:30","How to use Combine collect method after a map","<swift><combine>","2","6","","","","CC BY-SA 4.0"
"61851434","1","61851744","","2020-05-17 12:00:59","","4","1169","<p>I have 3d party library (<code>Firestore</code>) that has this method</p>

<pre><code>func listenToEvents(handler: ([Result], Error) -&gt; Void)
</code></pre>

<p><code>handler</code> in this method is called many times (after any updates of the data). I want to convert it to <code>Publisher</code> </p>

<p>Here is my code now:</p>

<pre><code>var resultsPublisher: AnyPublisher&lt;[Result], Error&gt; {
    Deferred { 
        Future { promise in
           libraryObject.listenToEvents { results, error in // called multiple times
              guard let results = results else {
                 promise(.failure(error))
                 return
              }

              // this can't be called several times,
              // because Future's promise is supposed to be called only once
              promise(.success(results))
           }
         }
    }
    .eraseToAnyPublisher()
}
</code></pre>

<p>So my <code>Publisher</code> produces value only once, because <code>Future</code> works this way. Are there any other <code>Publishers</code> (or may be a different approach) to accomplish that?</p>
","1328838","","506441","","2020-05-18 01:08:09","2022-08-23 14:47:36","Combine: Publisher like Future but with multiple values","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61888111","1","","","2020-05-19 09:52:27","","1","348","<p>I'm trying to use <code>CombineLatest</code> to publish a value whenever one of two publishers change. It just happens that one of these publishers is an <em>objectWillChange</em> property of an <em>ObservedObject</em> (<code>PassthroughSubject&lt;Void, Never&gt;</code>).</p>

<pre class=""lang-swift prettyprint-override""><code>Publishers.CombineLatest(
    settings.objectWillChange,
    $aPublishedProperty)
    .sink(receiveValue: { _, _ in
        // Do something…
    })
    .store(in: &amp;subscriptions)
</code></pre>

<p>The issue here is as long as this object don't change, <em>CombineLatest</em> will never emit. And I actually don't care about its <em>void</em> value. I'm just putting it here so that if it ever changes in the future, then my <em>sink</em> will get called again.</p>

<p>How can I trigger CombineLatest without an initial value? i.e: only with the change of <code>aPublishedProperty</code>? </p>
","4802021","","4667835","","2020-05-19 10:15:20","2020-05-19 10:15:20","How to make combineLatest send a value when one of its publishers haven't emitted yet?","<swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"61889158","1","61889295","","2020-05-19 10:46:53","","6","4100","<p>I have ViewModel with disposable Set defined this way </p>

<pre><code>class ViewModel { 


 private var disposables = Set&lt;AnyCancellable&gt;()

 func sync() { 
    repo.syncObjects()
            .handleEvents(receiveCancel: {
                print(""Synced objects: CANCELED!"")
            })
            .sink(receiveCompletion: { completion in
                switch completion {
                case .failure(let error):
                    print(""Synced objects: \(error)"")
                case .finished:
                    print(""Synced objects: finished"")
                }
            }) { objects in
                print(""Synced objects: \(objects)"")
            }.store(in: &amp;disposables)
 }

  deinit { print(""ViewModel deinit"") }
}
</code></pre>

<p>I am calling sync() in onAppear in SwiftUI view. Then I am fast switching screens and ViewModel referenced from SwiftUI view is deallocated by ARC like deinit is called but subscriptions seems to remain alive and disposable reference does not cancel subscription it fetches data from Network and saved them in Core Data and prints Synced objects: objects, Synced objects: finished. And keeps being alive even when I stop switching screens for several seconds to complete old requests. </p>

<p>Should I manually cancel AnyCancellable? shouldn't it be cancelled automagically?</p>
","4415642","","","","","2022-06-02 22:05:10","Swift Combine how Set<AnyCancellable> works?","<swift><subscription><combine><disposable>","1","1","","","","CC BY-SA 4.0"
"61898505","1","61898814","","2020-05-19 18:48:01","","0","131","<p>I'm trying to download a text file that has fixed width data elements and create
an array of data (eventually I would store this in Core Data).</p>

<p>This is an example of the data in this file:</p>

<p>USC00054542  37.2000 -103.4833 1770.9 CO KIM 5 SW<br>
USC00054546  37.1150 -103.2986 1602.3 CO KIM 10SSE<br>
USC00054584  39.2833 -104.4333 1937.0 CO KIOWA 5 SE<br>
USC00054585  39.3000 -104.5167 1998.0 CO KIOWA 4 SW<br>
USC00054592  39.6167 -102.5833 1220.1 CO KIRK<br>
USC00054603  38.7658 -102.8031 1311.2 CO KIT CARSON</p>

<p>I created a struct for the object that would be on each line:                                  </p>

<pre><code>struct RawStation: Codable, Identifiable {
    var id = UUID()
    var station: String
    var lat: String
    var long: String
    var elevation: String
    var name: String
    var region: String
    var postal: String
}
</code></pre>

<p>I tried several ways of decoding this file but have had no success. Here is the 
attempt to use the PropertyListDecoder       </p>

<pre><code>class Webservice {
    func fetchTextFile() {
        let stationURL = URL(string: ""https://www1.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt"")!
        var s: [RawStation]?

        if let data = try? Data(contentsOf: stationURL) {
          let decoder = PropertyListDecoder()
          s = try? decoder.decode([RawStation].self, from: data)
        }

        do {
            let data = try Data(contentsOf: stationURL)
            let decoder = PropertyListDecoder()
            s = try decoder.decode([RawStation].self, from: data)
        } catch {
            // Handle error
            print(error)
        }
        print(s as Any)
    } 
}
</code></pre>

<p>The error message: 
dataCorrupted(Swift.DecodingError.Context(codingPath: [], debugDescription: ""The given data was not a valid property list."", underlyingError: Optional(Error Domain=NSCocoaErrorDomain Code=3840 ""Unexpected character A at line 1"" UserInfo={NSDebugDescription=Unexpected character A at line 1, kCFPropertyListOldStyleParsingError=Error Domain=NSCocoaErrorDomain Code=3840 ""Expected ';' or '=' after key at line 1"" UserInfo={NSDebugDescription=Expected ';' or '=' after key at line 1}})))</p>

<p>The url for the file is ""<a href=""https://www1.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt"" rel=""nofollow noreferrer"">https://www1.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt</a>""</p>

<p>Sadly, the data does not appear to be available as a JSON file.</p>

<p>Xcode 11.4.1 Any guidance would be appreciated.</p>
","2698617","","12299030","","2020-05-19 18:51:25","2020-05-20 11:32:42","Swift Fetch and Parse Fixed Width Text File","<ios><xcode><combine>","1","0","","","","CC BY-SA 4.0"
"61911559","1","","","2020-05-20 11:08:22","","2","324","<p>I have such example ViewModel and what I can see in Instruments is that such and similar ViewModel is leaking memory </p>

<pre><code>class SearchViewModel&lt;T&gt;: ObservableObject {

    @Published var searchTerm : String = """"
    @Published var results: [T] = []

    private var disposables = Set&lt;AnyCancellable&gt;()

    init() {

        _searchTerm.projectedValue
        //$searchTerm
            .debounce(for: .milliseconds(350), scheduler: DispatchQueue.global())
            .flatMap { [weak self] term -&gt; AnyPublisher&lt;[T], Never&gt; in

                 self?.search(by: term) ?? Empty().eraseToAnyPublisher()
            }
            .print(""searching"")
            .receive(on: DispatchQueue.main)
            .assignNotRetain(to: \.results, on: self)
            //.assign(to: \.results, on: self)
            .store(in: &amp;disposables)

    }

    open func search(by term: String) -&gt; AnyPublisher&lt;[T], Never&gt; {
        fatalError()
    }
}
</code></pre>

<p>I've added [weak self] in flatMap and .assign(to) changed to custom .assignNotRetain(to) which uses sink with [weak self] it leaks less (there are deinit calls) but there is more init calls then deinit calls! This causes disposables: Set to be not deallocated/cancelled subscriptions </p>

<p>It just example view model similar approach with calling serivce and then observing output via sink, assign and updating @Published all happens to leak memory and disposables usually are not deallocated so, should I cancell AnyCancellable manually in View onDisappear?</p>
","4415642","","","","","2020-05-20 11:08:22","SwiftUI and ObservableObject ViewModels causes memory leaks, any example how should I use Combine in ObservableObject","<memory-leaks><swiftui><combine><observableobject>","0","0","","","","CC BY-SA 4.0"
"61935071","1","","","2020-05-21 12:59:37","","1","239","<p>I did this but the print statement is never called. What I am missing?</p>

<pre><code>final class TestObservableObject: ObservableObject {
    @Published
    private (set) var publishedProperty: Int = 0
    var objectWillChange: AnyPublisher&lt;Int, Never&gt;? = Empty().eraseToAnyPublisher()
    init() {
        self.objectWillChange = $publishedProperty.handleEvents(receiveSubscription: { (_) in
            print(""receiveSubscription"")
        }).eraseToAnyPublisher()
    }
}

struct TestView: View {
    @ObservedObject
    private var test: TestObservableObject
    init() {
        test = TestObservableObject()
    }
    var body: some View {
        return Group {
            if test.publishedProperty == 0 {
                Text(""0"")
            } else {
                Text(""100"")
            }
        }
    }
}
</code></pre>
","1256701","","","","","2020-05-21 13:01:56","How to check when SwiftUI subscribed to published property of ObservableObject?","<swiftui><observable><combine>","1","0","","","","CC BY-SA 4.0"
"61939348","1","","","2020-05-21 16:35:13","","-1","184","<p>I'm working on an app that utilizes Core Motion. During the initial onboarding of the app, it asks the user for permission, and we basically want to update the UI based on the response of that popup (Allowed/Denied). Where for notifications and location services this seems easy to do, it doesn't like a request permission API exists for Core Motion, instead it just triggers the popup when starting updating on a manager like we do now:</p>

<pre><code>let motionManager = CMMotionActivityManager()
motionManager.startActivityUpdates(to: OperationQueue.main) {
    // do stuff
}
</code></pre>

<p>Ideally I want to be able to detect a change in CMMotionActivityManager.authorizationStatus(), but so far haven't been able to come up with a working solution other than implement a timer that checks this property, which I don't feel is a particularly nice solution.</p>

<p>I tried making either authorizationStatus() or the manager as a whole an observable using Combine but that doesn't seem to trigger any updates.</p>
","9267610","","","","","2020-05-22 06:22:05","How to detect result from authorization dialog Core Motion?","<ios><swift><core-motion><combine>","1","0","","","","CC BY-SA 4.0"
"61951039","1","","","2020-05-22 08:41:30","","1","638","<p>So I've been following Log-In SwiftUI tutorials for Firebase and it's doing what it's supposed to for the most part: An error pops up when one or more of the input fields are left blank. </p>

<p>The problem occurs however, when I fill in the username + password fields with random gibberish. The view changes rather than popping up an error saying that the username is invalid (which I see in my console).</p>

<p>I've done some research and found that the problem might be due to the asynchronous behavior of Firebase and I haven't necessarily connected the error toggle to the sign-In result. But as a noob, I don't know how to implement the trailing closure in my code, and unsure where to go from here.</p>

<p>What change do I need to make exactly to ensure that upon failure of signing in with firebase, the view does not change and error pops up?</p>

<p>Here's my Sign-In function: </p>

<pre><code>    func signIn(){
    error = false
    session.signIn(email: user_account, password: password){
        (result, error) in
        if let errornew = error {
            self.inputerror = errornew.localizedDescription
            print(""\(String(describing:error))"")
            self.error = true
            self.alert.toggle()

        } else {
            self.user_account = """"
            self.password = """"
        }
    }
}
</code></pre>

<p>Parent View: </p>

<pre><code>struct ContentView: View {
@EnvironmentObject var session:SessionStore
@State var setUp = false


func getUser(){
    session.listen()
}

    var body: some View {
    Group{
        if(session.session != nil){

            Text(""App Home Page"")
            Text(""Welcome"")
            Text(""Email: \(session.session?.email ?? """")"")
        } else {
            OpeningView() // Sign-In function is in a child view under OpeningView() 
        }
    }.onAppear(perform: self.getUser)
}
</code></pre>

<p>Session Class: </p>

<pre><code>class SessionStore: ObservableObject{
@Published var isSetUp:Bool?
var didChange = PassthroughSubject&lt;SessionStore, Never&gt;()
var session: User? {didSet {self.didChange.send(self)}}
var handle: AuthStateDidChangeListenerHandle?
let user = Auth.auth().currentUser

//checks to see whether or not we have a user
func listen(){
    // monitor authentication changes using firebase
    handle = Auth.auth().addStateDidChangeListener({ (auth, user) in
        if let user = user {
            //if we have a user, create a new user model
            print(""Got the user: \(user)"")
            self.session = User(uid: user.uid, email: user.email!)
        } else {
            //if not, then session is nil
            self.session = nil
        }
    })
}
func signUp(email: String, password: String, handler: @escaping AuthDataResultCallback){
    Auth.auth().createUser(withEmail: email, password: password, completion: handler)
}

func signIn(email: String, password: String, handler: @escaping AuthDataResultCallback){
    Auth.auth().signIn(withEmail: email, password: password, completion: handler)
}

func login(withEmail email: String, password: String, _ callback: ((Error?) -&gt;())? = nil){
    Auth.auth().signIn(withEmail: email, password: password){(user, error) in
        if let e = error{
            callback?(e)
            return
        }
        callback?(nil)
        print(""Login Successful"")
    }
}

func signOut(){
    do{
        try Auth.auth().signOut()
        self.session = nil
    } catch {
        print(""Error Signing Out."")
    }
}

func unbind(){
    if let handle = handle {
        Auth.auth().removeStateDidChangeListener(handle)
    }

}

deinit{
    unbind()

   }
</code></pre>

<p>} </p>

<pre><code>struct User {
var uid : String
var email : String?

init(uid: String, email: String?){
    self.uid = uid
    self.email = email
}
</code></pre>

<p>}</p>
","13557643","","13557643","","2020-05-22 09:37:40","2020-05-22 09:37:40","How to use Firebase Auth + Combine to Sign-In and prevent Sign-In","<swift><firebase><firebase-authentication><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"61959647","1","61960839","","2020-05-22 16:31:39","","7","2742","<p>I'm working on an iOS application adopting the MVVM pattern, using SwiftUI for designing the Views and Swift Combine in order to glue together my Views with their respective ViewModels.
In one of my ViewModels I've created a <code>Publisher</code> (type <code>Void</code>) for a button press and another one for the content of a <code>TextField</code> (type <code>String</code>). 
I want to be able to combine both Publishers within my ViewModel in a way that the combined Publisher only emits events when the button Publisher emits an event while taking the latest event from the String publisher, so I can do some kind of evaluation on the <code>TextField</code> data, every time the user pressed the button. So my VM looks like this:</p>

<pre><code>import Combine
import Foundation

public class MyViewModel: ObservableObject {
    @Published var textFieldContent: String? = nil
    @Published var buttonPressed: ()

    init() {
        // Combine `$textFieldContent` and `$buttonPressed` for evaulation of textFieldContent upon every button press... 
    }
}
</code></pre>

<p>Both publishers are being pupulated with data by SwiftUI, so i will omit that part and let's just assume both publishers receive some data over time.</p>

<p>Coming from the RxSwift Framework, my goto solution would have been the <a href=""https://rxmarbles.com/#withLatestFrom"" rel=""noreferrer"">withLatestFrom</a> operator to combine both observables.
Diving into the Apple Documentation of <a href=""https://developer.apple.com/documentation/combine/publisher"" rel=""noreferrer"">Publisher</a> in the section ""Combining Elements from Multiple Publishers"" however, I cannot find something similar, so I expect this kind of operator to be missing currently.</p>

<p>So my question: Is it possible to use the existing operator-API of the Combine Framework to get the same behavior in the end like <code>withLatestFrom</code>? </p>
","7210997","","","","","2021-08-02 16:28:29","Swift Combine operator with same functionality like `withLatestFrom` in the RxSwift Framework","<ios><swift><swiftui><combine>","3","10","2","","","CC BY-SA 4.0"
"61962936","1","","","2020-05-22 19:57:36","","0","784","<p>It's a common scenario to want to upload image data to something like S3 and then write the reference object to a DB. I have been learning Apple's Combine framework and am stuck trying to come up with a pattern to accomplish this. </p>

<p>Let's say I have an object that holds the info about my image and a publisher to start the pipeline.</p>

<pre class=""lang-swift prettyprint-override""><code>struct ObjectWithImage: Encodable {
    let id: UUID
    let name: String
    let imageData: Data
    let imageURL: String

    enum CodingKeys: CodingKey {
        case id
        case name
        case imageURL
    }
}

extension Publishers {
    static let uploadObjectQueue: PassthroughSubject&lt;ObjectWithImage, Never&gt; = PassthroughSubject&lt;ObjectWithImage, Never&gt;()
}
</code></pre>

<p>I also have a legacy image uploader that would be using the S3 SDK or something. The definition is kept short and contrived for the example.</p>

<pre class=""lang-swift prettyprint-override""><code>struct LegacyImageUpload {
    //https://heckj.github.io/swiftui-notes/#patterns-future
    public func upload(imageData: Data) -&gt; Future&lt;Bool, Error&gt; {
        let future = Future&lt;Bool, Error&gt; { promise in
            self.upload(data: imageData) { (p_error) in
                guard let error = p_error else {
                    return promise(.success(true))
                }
                return promise(.failure(error))
            }
        }
        return future
    }

    private func upload(data: Data, completion: @escaping((_ error: Error?) -&gt; Void)) {
        //Code not here to keep example short
        completion(nil)
    }
}
</code></pre>

<p>I have a struct that could live at the <code>AppDelegate</code> which would be subscribing to the publisher.</p>

<pre class=""lang-swift prettyprint-override""><code>struct ObjectUploadPipeline {

    var subscription: AnyCancellable

    init() {
        self.subscription = Publishers.uploadObjectQueue.tryMap({ (object) -&gt; Future&lt;Bool, Error&gt; in
            let legacyImageUplaod = LegacyImageUpload()
            return legacyImageUplaod.upload(imageData: object.imageData)
        }).map({ (future) -&gt; Bool in
            //How do I switch back to the origional object so that I can now upload the Encoded JSON or write to my DB?
            return true
        }).sink(receiveCompletion: { (pipelineCompletion) in
            switch pipelineCompletion {
            case .finished:
                break
            case .failure(_):
                break
            }
        }, receiveValue: { (endValue) in

        })
    }
}
</code></pre>

<p>Then finally tie it all together.</p>

<pre class=""lang-swift prettyprint-override""><code>struct ObjectGenerator {
    init(numberOfObjects: Int) {
        for item in 0..&lt;numberOfObjects {
            let object = ObjectWithImage.init(id: UUID(), name: ""Object \(item)"", imageData: Data.init(), imageURL: ""path/to/image"")
            Publishers.uploadObjectQueue.send(object)
        }
    }
}

let uploadPipeline = ObjectUploadPipeline()
let objectGenerator = ObjectGenerator.init(numberOfObjects: 10)
</code></pre>

<p>How to I ensure that the image uploading succeeds first? If it succeeds how to I get the next operator to know about the <code>ObjectWithImage</code> so I can encode it as data and then send it up to my cloud? Preferably using the built in <code>URLSession</code> publisher?</p>

<p>I like combine and see the power but am having trouble stringing all the concepts together to complete this pipeline.</p>
","4576323","","","","","2020-05-27 05:51:10","Upload image data then reference object Swift Combine pattern?","<ios><json><swift><file-upload><combine>","1","2","","","","CC BY-SA 4.0"
"61976783","1","61977019","","2020-05-23 18:29:42","","0","49","<p>I have two dictionaries - one is a dictionary of nouns identified in sentences by a classifier; the other is a dictionary of noun phrases identified by a regex parser. The keys of both dictionaries are the strings of the sentence numbers.
I want to substitute the noun phrases for the nouns if they coincide.</p>

<p>output_classifier looks like this:</p>

<pre><code>{'47': ['staff_7', 'food_11', 'portion_17', 'portobello_25', 'gorgonzola_27', '/_28',  'sausage_29', 'appetizer_30', 'lobster_33', 'risotto_34']}
</code></pre>

<p>output regex parser looks like this:</p>

<pre><code>{'47': ['portion_17 size_18', 'sausage_29 appetizer_30', 'lobster_33 risotto_34']}
</code></pre>

<p>i want to keep the individual words if they are not in the regex parser, and substitue the phrases - getting rid of the original single words. </p>

<p>intended output:</p>

<pre><code>{'47': ['staff_7', 'food_11', 'portion_17 size_18', 'portobello_25', 'gorgonzola_27', '/_28',  'sausage_29 appetizer_30', 'lobster_33 risotto_34']}
</code></pre>

<p>I can't seem to get rid of the individual words after I have substituted. </p>
","12997669","","","","","2020-05-23 19:05:52","How do I substitute one value for another in dictionaries when there is a partial match: python","<python><dictionary><combine>","2","0","","","","CC BY-SA 4.0"
"61976941","1","","","2020-05-23 18:41:08","","1","263","<p>Is there an equivalent of the <a href=""https://rxjs-dev.firebaseapp.com/api/index/function/race"" rel=""nofollow noreferrer"">race</a> operator in Combine? It's different from <code>CombineLatest</code> in that it doesn't wait for all publishers to emit at least once. A workaround I am using right now is to add <code>startWith</code> to each publishers and filter those initial values</p>
","3808183","","","","","2021-02-11 10:48:54","Race operator in Combine framework","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"61999061","1","62002695","","2020-05-25 08:59:33","","4","1042","<p>I have this simple subscription where my <code>subject</code> is eminting strings. Just for curiosity I would like to know if my subscription is cancelled. </p>

<p>Afaik a pipeline that has been cancelled will not send any completions.
Are there some ways do achieve this? </p>

<p>The use case would be that I can cancel all subscriptions and receive a completion on this. Where I can clean up stuff a reflect this probably. </p>

<pre><code>PlaygroundPage.current.needsIndefiniteExecution = true

var disposeBag: Set&lt;AnyCancellable&gt; = .init()

let subject = PassthroughSubject&lt;String, Never&gt;()

subject.sink(receiveCompletion: { completion in
    switch completion {
    case .failure(let error):
        print(""Failed with: \(error.localizedDescription)"")
    case .finished:
        print(""Finished"")
    }
}) { string in
    print(string)
}.store(in: &amp;disposeBag)

subject.send(""A"")
disposeBag.map { $0.cancel() }
subject.send(""B"")
</code></pre>
","4142753","","","","","2022-08-23 14:26:33","Get status of cancellation of my subscription in Combine iOS","<ios><swift><combine>","1","5","2","","","CC BY-SA 4.0"
"61999575","1","61999769","","2020-05-25 09:29:52","","0","570","<p>I have 2 asynchronous return values from 2 different classes, one from HealthKit, the other from MotionManager. My goal is to combine these values and output them in a swiftui View, where it refreshes every second. I know I have to look at the combine framework here, but I don't know where to start. I can't find a lot of tutorials which describe Swiftui + Combine. I know I have to look at .combineLatest but do I have to write my own Publisher and Subscriber, or can I use @Published property wrapper I have here (@Published var motionData = MotionData() and @Published var heartRateValue: Double  = 0.0) ? </p>

<p><em>My MotionManager Class:</em></p>

<pre><code>struct MotionValues {
    var rotationX: Double = 0.0
    var rotationY: Double = 0.0
    var rotationZ: Double = 0.0
    var pitch: Double = 0.0
    var roll: Double = 0.0
    var yaw: Double = 0.0
}


class MotionManager: ObservableObject {

    @Published var motionValues = MotionValues()

    private let manager = CMMotionManager()

    func startMotionUpdates() {
        manager.deviceMotionUpdateInterval = 1.0
        manager.startDeviceMotionUpdates(to: .main) { (data, error) in

            guard let data = data, error == nil else {
                print(error!)
                return
            }

            self.motionValues.rotationX = data.rotationRate.x
            self.motionValues.rotationY = data.rotationRate.y
            self.motionValues.rotationZ = data.rotationRate.z

            self.motionValues.pitch = data.attitude.pitch
            self.motionValues.roll = data.attitude.roll
            self.motionValues.yaw = data.attitude.yaw
        }
    }

    func stopMotionUpdates() {
        manager.stopDeviceMotionUpdates()
        resetAllMotionData()
    }

    func resetAllMotionData() {
        self.motionValues.rotationX = 0.0
        self.motionValues.rotationY = 0.0
        self.motionValues.rotationZ = 0.0
        self.motionValues.pitch = 0.0
        self.motionValues.roll = 0.0
        self.motionValues.yaw = 0.0
    }
}
</code></pre>

<p><em>My HealthKitManager Class:</em></p>

<pre><code>class HealthKitManager: ObservableObject {

    private var healthStore = HKHealthStore()
    private var heartRateQuantity = HKUnit(from: ""count/min"")
    private var activeQueries = [HKQuery]()

    @Published var heartRateValue: Double  = 0.0

    func autorizeHealthKit() {

        let heartRate = HKObjectType.quantityType(forIdentifier: .heartRate)!
        let heartRateVariability = HKObjectType.quantityType(forIdentifier: .heartRateVariabilitySDNN)!

        let HKreadTypes: Set = [heartRate, heartRateVariability]

        healthStore.requestAuthorization(toShare: nil, read: HKreadTypes) { (success, error) in
            if let error = error {
                print(""Error requesting health kit authorization: \(error)"")
            }
        }
    }

    func fetchHeartRateData(quantityTypeIdentifier: HKQuantityTypeIdentifier ) {

        let devicePredicate = HKQuery.predicateForObjects(from: [HKDevice.local()])
        let updateHandler: (HKAnchoredObjectQuery, [HKSample]?, [HKDeletedObject]?, HKQueryAnchor?, Error?) -&gt; Void = {
        query, samples, deletedObjects, queryAnchor, error in
            guard let samples = samples as? [HKQuantitySample] else {
                return
            }
            self.process(samples, type: quantityTypeIdentifier)
        }
        let query = HKAnchoredObjectQuery(type: HKObjectType.quantityType(forIdentifier: quantityTypeIdentifier)!, predicate: devicePredicate, anchor: nil, limit: HKObjectQueryNoLimit, resultsHandler: updateHandler)
        query.updateHandler = updateHandler
        healthStore.execute(query)
        activeQueries.append(query)
    }

    private func process(_ samples: [HKQuantitySample], type: HKQuantityTypeIdentifier) {
        for sample in samples {
            if type == .heartRate {
                DispatchQueue.main.async {
                    self.heartRateValue = sample.quantity.doubleValue(for: self.heartRateQuantity)
                }
            }
        }
    }

    func stopFetchingHeartRateData() {
        activeQueries.forEach { healthStore.stop($0) }
        activeQueries.removeAll()
        DispatchQueue.main.async {
            self.heartRateValue = 0.0
        }

    }  
}
</code></pre>

<p>I started with creating a combinedViewModel but I'm stuck here and don't know if this is the way to go: </p>

<pre><code>class CombinedViewModel: ObservableObject {

    @Published var motionManager: MotionManager = MotionManager()
    @Published var healthManager: HealthKitManager = HealthKitManager()

    var anyCancellable: AnyCancellable?

    init() {
        anyCancellable = Publishers
            .CombineLatest(motionManager.$motionValues,healthManager.$heartRateValue)
            .sink(receiveValue: {
                // Do something
            }
        })
    }
}
</code></pre>

<p>Where do I need to focus ? Do I need to learn the combine framework completely to write my own publishers and subscribers, or is there something available with @Published that can do the job ? Or do I need to go for another approach with my CombinedViewModel?</p>

<p>added contentView for reference:</p>

<pre><code>struct ContentView: View {

    @State var isActive: Bool = false

    private var motion = MotionManager()
    private var health = HealthKitManager()

    @ObservedObject var combinedViewModel = CombinedViewModel(managerOne: motion, managerTwo: health)

    private var motionValues: MotionValues {
        return combinedViewModel.combinedValues.0
    }

    private var heartRateValue: Double {
        return combinedViewModel.combinedValues.1
    }


    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                Indicator(title: ""X:"", value: motionValues.rotationX)
                Indicator(title: ""Y:"", value: motionValues.rotationY)
                Indicator(title: ""Z:"", value: motionValues.rotationZ)
                Divider()
                Indicator(title: ""Pitch:"", value: motionValues.pitch)
                Indicator(title: ""Roll:"", value: motionValues.roll)
                Indicator(title: ""Yaw:"", value: motionValues.yaw)
                Divider()
                Indicator(title: ""HR:"", value: heartRateValue)
            }
            .padding(.horizontal, 10)
            Button(action: {
                self.isActive.toggle()
                self.isActive ? self.start() : self.stop()
            }) {
                Text(isActive ? ""Stop"" : ""Start"")
            }
            .background(isActive ? Color.green : Color.blue)
            .cornerRadius(10)
            .padding(.horizontal, 5)
        }.onAppear {
            self.health.autorizeHealthKit()
        }
    }

    private func start() {
        self.motion.startMotionUpdates()
        self.health.fetchHeartRateData(quantityTypeIdentifier: .heartRate)
    }

    private func stop() {
        self.motion.stopMotionUpdates()
        self.health.stopFetchingHeartRateData()
    }

}
</code></pre>
","4795917","","4795917","","2020-05-25 10:39:07","2020-05-25 10:39:07","Combine asynchronous return values in SwiftUI","<swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"62002597","1","62003459","","2020-05-25 12:41:20","","3","1364","<p>I am trying to build a publisher that emits true when any of 5 other publisher emits true. I've managed to build a working version but it feels very icky, with the CombineLatest4 + CombineLatest and especially all the <code>$0.0 || $0.1 || $0.2 || $0.3</code> code.</p>

<p>I've tried Merge5, but that simply returns the value of the last value that was set it seems.</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class Test {
  @Published var one = false
  @Published var two = false
  @Published var three = false
  @Published var four = false
  @Published var five = false
}

let test = Test()

var anyTrue = Publishers.CombineLatest4(test.$one, test.$two, test.$three, test.$four)
  .map { $0.0 || $0.1 || $0.2 || $0.3 }
  .combineLatest(test.$five)
  .map { $0.0 || $0.1 }

anyTrue.sink {
  print($0)
}

test.three = true
test.one = false
</code></pre>

<p>Is there a cleaner less repetitive way to do this?</p>
","403425","","","","","2020-05-25 13:30:48","Swift Combine: merge multiple publishers and emit `true` when any of them emits `true`","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62014417","1","62014533","","2020-05-26 03:56:21","","1","284","<p>i am trying to use a publisher, but i got this error: ""Escaping closure captures non-escaping parameter 'promise'"" in the Timer. line.
How can i solve this?   </p>

<pre><code> extension OperationQueue {

        func publisher&lt;Output, Failure: Error&gt;(_ block: @escaping (Future&lt;Output, Failure&gt;.Promise) -&gt; Void) -&gt; AnyPublisher&lt;Output, Failure&gt; {
            Future&lt;Output, Failure&gt; { promise in
                self.addOperation {
                    block(promise)
                }
            }.eraseToAnyPublisher()
        }
    }

    struct ContentView: View {


        func getDataViaPublisher()-&gt;AnyPublisher&lt;String,Error&gt; {

            OperationQueue.main.publisher { promise in

                Timer.scheduledTimer(withTimeInterval: Double.random(in: 1...3), repeats: false) { (timer) in. // &lt;&lt;&lt;&lt;&lt; error here
                    promise(.success(""Chris""))
                }
            }
        }
</code></pre>
","8457280","","","","","2020-05-26 04:09:31","Escaping closure captures non-escaping parameter 'promise'","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62014524","1","62014863","","2020-05-26 04:07:56","","1","2973","<p>In Combine how do you make a publisher that sends one value but never completes?</p>

<p>In the following code receiveCompletion gets called but I don't want it to:</p>

<pre class=""lang-swift prettyprint-override""><code>Just(1)
    .sink(
        receiveCompletion: {
            print(""Completion: \($0)"")
    },
        receiveValue: {
            print(""Value: \($0)"")
    }
)
</code></pre>

<p>How can I emit just one value but not complete...?</p>
","12587089","","","","","2020-05-26 08:32:24","In Combine how do you make a publisher that sends one value but never completes?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"62016745","1","","","2020-05-26 07:27:47","","1","213","<p>Below is my working code:</p>

<pre><code>struct ReaderView: View {
    @State var presentingSettingsSheet = false
    @State var currentDate = Date()

private let timer = Timer.publish(every: 1.0, on: .main, in: .common)
    .autoconnect()
    .eraseToAnyPublisher()

var body: some View {
    let filter = ""Showing all stories""

    return NavigationView {
        List {
            Section(header: Text(filter).padding(.leading, -10)) {
                VStack(alignment: .leading, spacing: 10) {
                    TimeBadge(time: 20.0)

                    Text(""Title"")
                        .frame(minHeight: 0, maxHeight: 100)
                        .font(.title)

                    PostedBy(time: 30.0, user: ""Author"", currentDate: self.currentDate)
                    }
                .padding()
            }
        }
        .sheet(isPresented: self.$presentingSettingsSheet, content: {
            SettingsView()
        })
        .navigationBarTitle(Text(""Stories""))
        .navigationBarItems(trailing:
            Button(""Settings"") {
                self.presentingSettingsSheet = true

            }
        )
    }
    .onReceive(timer) {
        print($0)
        self.currentDate = $0
    }
}}
</code></pre>

<p>But if I add onReceive after <code>List</code> Scope it does not work, it starts working if I add it after the declaration of <code>navigationBarItems</code>. So my question is why does onReceive behave differently when placed differently inside code. I am aware that the sequence of modifiers changes the final resulting UI but is it the same for <code>onReceive</code>. 
I am looking for a possible explanation for this.</p>

<p>I am using:
Xcode 11.5
Simulator iPhone SE (2nd generation), 13.5.</p>
","8023700","","","","","2020-05-26 09:31:54","onReceive not Triggered in some cases","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"62029382","1","62030142","","2020-05-26 18:57:04","","6","1892","<p>I am trying to observe changes of a <code>bool</code> value contained in an <code>ObservableObject</code> which is a value in an <code>enum</code> case. Here is an example of what I am trying to achieve but with the current approach I receive the error <code>Use of unresolved identifier '$type1Value'</code>.</p>

<pre><code>import SwiftUI
import Combine

class ObservableType1: ObservableObject {
    @Published var isChecked: Bool = false
}

enum CustomEnum {
    case option1(ObservableType1)
}

struct Parent: View {
    var myCustomEnum: CustomEnum
    var body: AnyView {
        switch myCustomEnum {
        case .option1(let type1Value):
            AnyView(Child(isChecked: $type1Value.isChecked)) // &lt;- error here
        }
    }
}

struct Child: View {
    @Binding var isChecked: Bool
    var body: AnyView {
        AnyView(
            Image(systemName: isChecked ? ""checkmark.square"" : ""square"")
            .onTapGesture {
                self.isChecked = !self.isChecked
        })
    }
}
</code></pre>

<p>I am trying to update the value of <code>isChecked</code> from the interface but since I want to have the <code>ObservableObject</code> which contains the property in an <code>enum</code> like <code>CustomEnum</code> not sure how to do it or if it is even possible. I went for an enum because there will be multiple enum options with different <code>ObservableObject</code> values and the <code>Parent</code> will generate different subviews depending on the <code>CustomEnum</code> option. If it makes any relevance the <code>Parent</code> will receive the <code>myCustomEnum</code> value from an <code>Array</code> of <code>CustomEnum</code> values. Is this even possible? If not, what alternatives do I have? Thank you!</p>
","1310984","","","","","2022-08-23 15:01:22","SwiftUI two-way binding to value inside ObservableObject inside enum case","<ios><swift><binding><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"62037727","1","62048039","","2020-05-27 07:35:00","","9","4823","<p>I know in general a publisher is more powerful than a closure, however I want to ask and discuss a specific example:</p>

<pre><code>func getNotificationSettingsPublisher() -&gt; AnyPublisher&lt;UNNotificationSettings, Never&gt; {
   let notificationSettingsFuture = Future&lt;UNNotificationSettings, Never&gt; { (promise) in
      UNUserNotificationCenter.current().getNotificationSettings { (settings) in
         promise(.success(settings))
      }
   }
   return notificationSettingsFuture.eraseToAnyPublisher()
}
</code></pre>

<p>I think this is a valid example of a Future publisher and it could be used here instead of using a completion handler. Let's do something with it:</p>

<pre><code>func test() {
    getNotificationSettingsPublisher().sink { (notificationSettings) in
       // Do something here        
    }
}
</code></pre>

<p>This works, however it will tell me that the result of sink (<code>AnyCancellable</code>) is unused. So whenever I try to get a value, I need to either store the cancellable or assign it until I get a value.</p>

<p>Is there something like sinkOnce or an auto destroy of cancellables? Sometimes I don't need tasks to the cancelled. I could however do this:</p>

<pre><code>func test() {
   self.cancellable = getNotificationSettingsPublisher().sink { [weak self] (notificationSettings) in
      self?.cancellable?.cancel()
      self?.cancellable = nil
   }
}
</code></pre>

<p>So once I receive a value, I cancel the subscription. (I could do the same in the completion closure of sink I guess).</p>

<p>What's the correct way of doing so? Because if I use a closure, it will be called as many times as the function is called, and if it is called only once, then I don't need to cancel anything.</p>

<p>Would you say normal completion handlers could be replaced by Combine and if so, how would you handle receiving one value and then cancelling?</p>

<p>Last but not least, the completion is called, do I still need to cancel the subscription? I at least need to update the cancellable and set it to nil right? I assume storing subscriptions in a set is for long running subscriptions, but what about single value subscriptions?</p>

<p>Thanks</p>
","1582047","","","","","2020-05-27 16:28:24","Swift Combine publishers vs completion handler and when to cancel","<swift><combine>","1","2","2","","","CC BY-SA 4.0"
"62049153","1","","","2020-05-27 17:23:36","","0","141","<p>While implementing the Google Interactive Media Ads (IMA) SDK protocols, my mediaPlayer/audioManager, which is an AVPlayer object, is not pausing during the adsManagerDidRequestContentPause delegate method. My mediaPlayer conforms to ObservableObject, which is where I think the problem is coming from but i'm not 100% positive. </p>

<p>When I press the play button, I play the audio and request the ads from my adsManager class. The issue is the preroll video plays but the audio from the content player plays over the preroll. The audio from the content player is supposed to pause when the preroll is playing and resume after it finishes. As you'll see in the code, AudioManager is also a singleton class.</p>

<p>Here's the code for when a user presses play.</p>

<pre><code>@ObservedObject var manager = AudioManager.sharedInstance

func didTapPlayButton(){
    isPlaying.toggle()
    if isPlaying {
        audioManager.playLiveStream(with: pageInfo.tritonMount)
        adManager.requestAds()
    } else {
        audioManager.pause()
    }
}
</code></pre>

<p>And here's the adManager class with the Google IMA delegate methods. After setting breakpoints at each delegate method, I found that each call to audioManager is being called successfully, however, the audio from the audioManager doesn't actually pause. </p>

<pre><code>@ObservedObject var manager = AudioManager.sharedInstance

func setUpContentPlayer() {
    contentPlayhead = IMAAVPlayerContentPlayhead(avPlayer: player)
    // Create a player layer for the player.
    playerLayer = AVPlayerLayer(player: player)
    playerLayer!.frame = videoView.underlyingView.layer.bounds
    videoView.underlyingView.layer.addSublayer(playerLayer!)
}

func setUpAdsLoader() {
    adsLoader = IMAAdsLoader(settings: nil)
    adsLoader!.delegate = self
}

func requestAds() {
    // Create an ad display container for ad rendering.
    let adDisplayContainer = IMAAdDisplayContainer(adContainer: videoView.underlyingView, companionSlots: nil)

    // Create an ad request with our ad tag, display container, and optional user context.
    let request = IMAAdsRequest(
        adTagUrl: kLivePrerollVastTag,
        adDisplayContainer: adDisplayContainer,
        contentPlayhead: contentPlayhead,
        userContext: nil)

    adsLoader!.requestAds(with: request)
}

func adsLoader(_ loader: IMAAdsLoader!, adsLoadedWith adsLoadedData: IMAAdsLoadedData!) {
    // Grab the instance of the IMAAdsManager and set ourselves as the delegate
    adsManager = adsLoadedData.adsManager
    adsManager!.delegate = self

    // Create ads rendering settings and tell the SDK to use the in-app browser.
    let adsRenderingSettings = IMAAdsRenderingSettings()

    adsRenderingSettings.webOpenerPresentingController = viewController

    // Initialize the ads manager.
    adsManager!.initialize(with: adsRenderingSettings)
}

//Ads Manager recieved ad request and is loading and starting ad
func adsManager(_ adsManager: IMAAdsManager!, didReceive event: IMAAdEvent!) {
    if (event.type == IMAAdEventType.LOADED) {
        // When the SDK notifies us that ads have been loaded, play them.
        adsManager.start()
    }
}

//Ads manager failed to receive ad request
func adsLoader(_ loader: IMAAdsLoader!, failedWith adErrorData: IMAAdLoadingErrorData!) {
    print(""Error loading ads: \(String(describing: adErrorData.adError.message))"")
    audioManager.resume()
}

func adsManager(_ adsManager: IMAAdsManager!, didReceive error: IMAAdError!) {
    // Something went wrong with the ads manager after ads were loaded. Log the
    // error and play the content.
    NSLog(""AdsManager error: \(String(describing: error.message))"")
    audioManager.resume()
}

/*Ads manager received request, initiated avplayer and is now
requesting player be paused in order or the Ads manager to play preroll*/
func adsManagerDidRequestContentPause(_ adsManager: IMAAdsManager!) {
    // The SDK is going to play ads, so pause the content.
    audioManager.pause()
}
/*Ads manager received request, played the preroll and is now
 requesting avplayer to resume live stream*/
func adsManagerDidRequestContentResume(_ adsManager: IMAAdsManager!) {
    // The SDK is done playing ads (at least for now), so resume the content.
    audioManager.resume()
}
</code></pre>

<p>AudioManagerClass: </p>

<pre><code>    /// Upon setting this property any observers for 'currentItem' as well as any time observers will
/// be removed from the old value where applicable and added to the new value where applicable.
var player: AVPlayer? {
    didSet {
        oldValue?.removeObserver(self, forKeyPath: ""currentItem"", context: &amp;AudioManager.ObserveAVPlayerCurrentItem)
        oldValue?.removeObserver(self, forKeyPath: ""rate"", context: &amp;AudioManager.ObserveAVPlayerRate)
        guard let player = self.player else { return }

        player.addObserver(self, forKeyPath: ""currentItem"", options: [.initial, .new], context: &amp;AudioManager.ObserveAVPlayerCurrentItem)
        player.addObserver(self, forKeyPath: ""rate"", options: [.initial, .new], context: &amp;AudioManager.ObserveAVPlayerRate)
        player.automaticallyWaitsToMinimizeStalling = false
        if let tmpObs = timeObserver {
            print(""Already have timeobserver, removing it"")
            oldValue?.removeTimeObserver(tmpObs)
            timeObserver = nil
        }

        timeObserver = player.addPeriodicTimeObserver(forInterval: CMTimeMakeWithSeconds(1,preferredTimescale: 1),
            queue: nil,
            using: timeObserverCallback) as AnyObject?
    }

}
</code></pre>
","9362600","","9362600","","2020-05-28 15:49:20","2020-05-28 15:49:20","ObservedObject class function not being called when protocol fires","<swift><swiftui><combine><google-ima>","0","2","","","","CC BY-SA 4.0"
"62071908","1","62079390","","2020-05-28 18:25:13","","0","416","<p>All of my API endpoints return a response which looks something like this in Postman:</p>

<pre><code>{
    ""statusCode"": 401,
    ""error"": ""Unauthorized"",
    ""message"": ""Missing authentication""
}
</code></pre>

<p>What I would like to do is make the request, and have access to these properties in Swift. There will be some cases where I use the error message property's value in the front of the app. This will be determined by the statusCode returned.</p>

<p>What I have right now is this:</p>

<pre><code>    private var cancellable: AnyCancellable?
    let url = URL(string: ""http://abc336699.com/create"")
    self.cancellable = URLSession.shared.dataTaskPublisher(for: url!)
      .map { $0.data }
</code></pre>

<p>Prior to this, I tried tryMap, but the type of error it returned didn't give me the flexibility I wanted. I then moved on and tried Almofire, but it seemed like an over kill for what I want to do.</p>

<p>I wanted to check what is being returned in the response I get, but I get the following error:</p>

<pre><code>Cannot assign value of type 'Publishers.Map&lt;URLSession.DataTaskPublisher, Data&gt;' to type 'AnyCancellable'
</code></pre>

<p>I want simple access to my response errors so I can integrate the API throughout the app using combine.</p>
","439688","","","","","2020-05-29 20:34:53","How do I read the property values of a JSON error object using Combine in Swift?","<swift><swiftui><combine>","1","6","1","","","CC BY-SA 4.0"
"62077556","1","62077753","","2020-05-29 02:08:41","","0","113","<p>I recently discovered that usage of the new Combine SDK in a macOS necessitates a minimum deployment target of 10.15. </p>

<p>Admittedly, I am new to macOS development. It is surprising to me that a library of this nature would have strict dependencies on the latest OS version.</p>

<p>My mental model (which is apparently missing key information) tells me either (a) the SDK uses new syscalls introduced in 10.15 or (b) macOS binaries are dynamically-linked and not statically-linked as I had assumed.</p>

<p>Is it some other (c)?</p>
","13538737","","","","","2020-05-29 16:45:12","Why does Combine require macOS 10.15 and above?","<swift><macos><appkit><combine>","1","0","","","","CC BY-SA 4.0"
"62090286","1","62095757","","2020-05-29 16:13:58","","6","935","<p>I am trying to set up a publisher that will publish a set of integers and at some point may fail. It's slightly contrived but hopefully illustrates principle. Example below.</p>

<pre><code>enum NumberError: Int, Error {
   case isFatal, canContinue
}

struct Numbers {
    let p = PassthroughSubject&lt;Int, NumberError&gt;()

    func start(max: Int) {

        let errorI = Int.random(in: 1...max)
        for i in (1...max) {
            if errorI == i {
                p.send(completion: .failure(NumberError.canContinue))
            } else {
                p.send(i)
            }
        }
        p.send(completion: .finished)

    }
}
</code></pre>

<p>I then subscribe using:</p>

<pre><code>let n = Numbers()
let c = n.p
    .catch {_ in return Just(-1)}

    .sink(receiveCompletion: {result in
        switch result {
        case .failure:
            print(""Error"")
        case .finished:
            print(""Finished"")
        }
    }, receiveValue: {
        print($0)
    })

n.start(max: 5)
</code></pre>

<p>This works in that it replaces errors with -1 but I would then like to continue receiving values. Does anyone know if this is possible?
Having read and looked around it seems that flatMap may be the way to go but I can't work out what publisher to use in the closure? Any help much appreciated.</p>
","11302366","","","","","2020-05-29 22:59:33","How to continue subscribing to publisher after error?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62095182","1","62095636","","2020-05-29 21:57:36","","7","3882","<p>If you use Combine for network requests with <code>URLSession</code>, then you need to save the <code>Subscription</code> (aka, the <code>AnyCancellable</code>) - otherwise it gets immediately deallocated, which cancels the network request. Later, when the network response has been processed, you want to deallocate the subscription, because keeping it around would be a waste of memory. </p>

<p>Below is some code that does this. It's kind of awkward, and it may not even be correct. I can imagine a race condition where network request could start and complete on another thread before <code>sub</code> is set to the non-nil value.</p>

<p>Is there a nicer way to do this?</p>

<pre><code>class SomeThing {
    var subs = Set&lt;AnyCancellable&gt;()
    func sendNetworkRequest() {
        var request: URLRequest = ...
        var sub: AnyCancellable? = nil            
        sub = URLSession.shared.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: MyResponse.self, decoder: JSONDecoder())
            .sink(
                receiveCompletion: { completion in                
                    self.subs.remove(sub!)
                }, 
                receiveValue: { response in ... }
            }
        subs.insert(sub!)
</code></pre>
","327572","","","","","2021-11-10 05:23:27","With Combine, how to deallocate the Subscription after a network request","<swift><combine><urlsession>","3","0","2","","","CC BY-SA 4.0"
"62096858","1","62096938","","2020-05-30 01:47:19","","1","884","<p>I’m trying to change a view based on a selection made with a button. I’m using Combine and SwiftUI.</p>

<p>I create a view router class with a <code>@Published</code> var:</p>

<pre class=""lang-swift prettyprint-override""><code>import Foundation
import SwiftUI
import Combine

class ViewRouter: ObservableObject {

    @Published var currentView = ""folder""

}
</code></pre>

<p>I have my button struct:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct MultiButton: View {
    @ObservedObject var viewRouter = ViewRouter()
    @State var showButton = false

    var body: some View {
        GeometryReader { geometry in
            ZStack{

                // open multi button
                Button(action: {

                    withAnimation {
                        self.showButton.toggle()
                    }
                }) {
                    Image(systemName: ""gear"")
                        .resizable()
                        .frame(width: 40, height: 40, alignment: .center)
                }
                if self.showButton {

                    Multi()
                    .offset(CGSize(width: -30, height: -100))
                }
            }


        }
    }
}

struct MultiButton_Previews: PreviewProvider {
    static var previews: some View {
        MultiButton()
    }
}

struct Multi: View {

 @ObservedObject var viewRouter = ViewRouter()

    var body: some View {
        HStack(spacing: 10) {
            ZStack {

                Button(action: {
                    self.viewRouter.currentView = ""folder""
                     debugPrint(""\(self.viewRouter.currentView)"")
                }) {
                    ZStack{

                    Circle()
                        .foregroundColor(Color.blue)
                        .frame(width: 70, height: 70)
                    Image(systemName: ""folder"")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .padding(20)
                        .frame(width: 70, height: 70)
                        .foregroundColor(.white)
                    }.shadow(radius: 10)
                }
            }

            Button(action: {
                self.viewRouter.currentView = ""setting""
                debugPrint(""\(self.viewRouter.currentView)"")
            }, label: {
                ZStack {
                    Circle()
                        .foregroundColor(Color.blue)
                        .frame(width: 70, height: 70)
                    Image(systemName: ""gear"")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .padding(20)
                        .frame(width: 70, height: 70)
                        .foregroundColor(.white)
                }.shadow(radius: 10)
            })
        }
            .transition(.scale)
    }
}
</code></pre>

<p>And the <code>contentView</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct ContentView: View {
    @ObservedObject var viewRouter = ViewRouter()
    var body: some View {
        VStack{

            MultiButton()

            if viewRouter.currentView == ""folder"" {
                Text(""folder"")
            } else if viewRouter.currentView == ""setting""{
                Text(""setting"")
            }
        }
    }
}
</code></pre>

<p>Why is my text is not changing from the folder to setting the base when the button is pressEd?</p>

<p>The var is <code>@Published</code>; it should publish the change and update the main view.</p>

<p>Did I miss something?</p>
","9962676","","3025856","","2020-05-30 07:32:45","2020-05-30 07:32:45","SwiftUI: changing view using ""if else""","<swift><xcode><swiftui><observable><combine>","1","0","","","","CC BY-SA 4.0"
"62108591","1","62109143","","2020-05-30 20:57:17","","3","896","<p>When attempting to send a background request with <code>URLSession</code>'s <code>dataTaskPublisher</code> method:</p>

<pre class=""lang-swift prettyprint-override""><code>URLSession(configuration: URLSessionConfiguration.background(withIdentifier: ""example"")) 
     .dataTaskPublisher(for: URL(string: ""https://google.com"")!) 
     .map(\.data) 
     .sink(receiveCompletion: { print($0) }) { print($0) }
</code></pre>

<p>I receive the error</p>

<pre><code>Completion handler blocks are not supported in background sessions. Use a delegate instead.
</code></pre>

<p>This makes sense to me, <code>sink</code> is a bunch of completion handlers. So, I tried to build a <code>Subscriber</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>class ExampleSubscriber: Subscriber {
    typealias Input = Data

    typealias Failure = URLError

    func receive(subscription: Subscription) {
        subscription.request(.max(1))
    }

    func receive(_ input: Data) -&gt; Subscribers.Demand {
        print(input)

        return Subscribers.Demand.none
    }

    func receive(completion: Subscribers.Completion&lt;URLError&gt;) {}

}
</code></pre>

<p>and subscribe with the <code>Subscriber</code>:</p>

<pre class=""lang-swift prettyprint-override""><code>URLSession(configuration: URLSessionConfiguration.background(withIdentifier: ""example""))
    .dataTaskPublisher(for: URL(string: ""https://google.com"")!)
    .map(\.data)
    .subscribe(ExampleSubscriber())
</code></pre>

<p>and I receive the same error:</p>

<pre><code>Completion handler blocks are not supported in background sessions. Use a delegate instead.
</code></pre>

<p>Is it possible to perform a background request using <code>dataTaskPublisher</code> or do I <em>have</em> to use a delegate to <code>URLSession</code>?</p>
","1352094","","","","","2020-05-31 09:17:29","Background URLSession + Combine?","<swift><combine>","1","3","1","","","CC BY-SA 4.0"
"62116329","1","62116825","","2020-05-31 12:36:41","","3","526","<p>Let's say I have:</p>

<ul>
<li>structure <code>Document</code>, which represents text document.</li>
<li><code>EditorView</code>  — an <code>NSTextView</code>, wrapped with Combine, which binds to <code>Document.content&lt;String&gt;</code>. </li>
</ul>

<p><code>Document</code> is a part of complex <code>store:ObservableObject</code>, so it can be bouneded to <code>EditorView</code> instance.</p>

<p>When I first create binding, it works as expected — editing NSTextView changes value in <code>Document.content</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>let document1 = Document(...)
let document2 = Document(...)
var editor = EditorView(doc: document1)
</code></pre>

<p>But if change binding to another Document...</p>

<pre class=""lang-swift prettyprint-override""><code>editor.doc = document2
</code></pre>

<p>...then <code>updateNSView</code> can see new <code>document2</code>. But inside Coordiantor's <code>textDidChange</code>  has still refrence to <code>document1</code>.</p>

<pre class=""lang-swift prettyprint-override""><code>func textDidChange(_ notification: Notification) {
    guard let textView = notification.object as? NSTextView else {
        return
    }

    self.parent.doc.content = textView.string
    self.selectedRanges = textView.selectedRanges
}
</code></pre>

<p>So, initially, when i set new bindint, NSTextView changes it content to <code>document2</code>, but as I type, coordinator sends changes to <code>document1</code>.</p>

<p>Is it true, that Coordiantor keeps it's own copy of <code>parent</code>, and even if parent changes (<code>@Binding doc</code> is updated), it still references to old one?</p>

<p>How to make Coordinator reflect parent's bindings changes?</p>

<p>Thank you!</p>

<pre class=""lang-swift prettyprint-override""><code>struct Document: Identifiable, Equatable {
    let id: UUID = UUID()
    var name: String
    var content: String
}

struct EditorView: NSViewRepresentable {
    @Binding var doc: Document

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }

    func makeNSView(context: Context) -&gt; CustomTextView {
        let textView = CustomTextView(
            text: doc.content,
            isEditable: isEditable,
            font: font
        )
        textView.delegate = context.coordinator

        return textView
    }

    func updateNSView(_ view: CustomTextView, context: Context) {
        view.text = doc.content
        view.selectedRanges = context.coordinator.selectedRanges

    }
}


// MARK: - Coordinator

extension EditorView {

    class Coordinator: NSObject, NSTextViewDelegate {
        var parent: EditorView
        var selectedRanges: [NSValue] = []

        init(_ parent: EditorView) {
            self.parent = parent
        }

        func textDidBeginEditing(_ notification: Notification) {
            guard let textView = notification.object as? NSTextView else {
                return
            }

            self.parent.doc.content = textView.string
            self.parent.onEditingChanged()
        }

        func textDidChange(_ notification: Notification) {
            guard let textView = notification.object as? NSTextView else {
                return
            }

            self.parent.doc.content = textView.string
            self.selectedRanges = textView.selectedRanges
        }

        func textDidEndEditing(_ notification: Notification) {
            guard let textView = notification.object as? NSTextView else {
                return
            }

            self.parent.doc.content = textView.string
            self.parent.onCommit()
        }
    }
}

// MARK: - CustomTextView

final class CustomTextView: NSView {
    private var isEditable: Bool
    private var font: NSFont?

    weak var delegate: NSTextViewDelegate?

    var text: String {
        didSet {
            textView.string = text
        }
    }
    // ...
</code></pre>
","1275294","","1275294","","2020-05-31 16:34:17","2020-05-31 16:34:17","How to make Swift Coordinator reflect parent's bindings changes?","<swift><swiftui><appkit><combine>","1","0","","","","CC BY-SA 4.0"
"62123055","1","","","2020-05-31 22:07:04","","0","132","<p>I've reworked this question after further research and in response to comments that it was too long.</p>

<p>I am downloading and decoding data, in CSV format using CodableCSV, from three URLs and I've been able to confirm that I am receiving all the data I expect (as of today, 35027 lines). As the data is decoded, I am injecting a NSManagedObjectContext in to the decoded object. Here is my managed object class:</p>

<pre><code>import Foundation
import CoreData

@objc(MacListEntry)
class MacListEntry: NSManagedObject, Decodable {

  //var id = UUID()
  @NSManaged var registry: String?
  @NSManaged var assignment: String?
  @NSManaged var org_name: String?
  @NSManaged var org_addr: String?

  required convenience init(from decoder: Decoder) throws {

    guard let keyManObjContext = CodingUserInfoKey.managedObjectContext,
      let context = decoder.userInfo[keyManObjContext] as? NSManagedObjectContext,
      let entity = NSEntityDescription.entity(forEntityName: ""MacListEntry"", in: context) else {
        fatalError(""Failed to receive managed object context"")
    }

    self.init(entity: entity, insertInto: context)

    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.registry = try container.decode(String.self, forKey: .registry)
    self.assignment = try container.decode(String.self, forKey: .assignment)
    self.org_name = try container.decode(String.self, forKey: .org_name)
    self.org_addr = try container.decode(String.self, forKey: .org_addr)
  }

  private enum CodingKeys: Int, CodingKey {
    case registry = 0
    case assignment = 1
    case org_name = 2
    case org_addr = 3
  }
}

public extension CodingUserInfoKey {
  static let managedObjectContext = CodingUserInfoKey(rawValue: ""managedObjectContext"")
}
</code></pre>

<p>I then attempt to save the context using <code>try context.save()</code> but before doing so, examine the numbers of records I am trying to insert using:</p>

<pre><code>print(""Deleted objects: (self.persistentContainer.viewContext.deletedObjects.count)"")
print(""Inserted objects: (self.persistentContainer.viewContext.insertedObjects.count)"")
print(""Has changes: \(self.persistentContainer.viewContext.hasChanges)"")
</code></pre>

<p>and get a different number of inserted records every time the code runs - always short, by around 0.5%. I am struggling to understand under what circumstances objects added to a managed object context in this way simply don't appear in the list of inserted objects and don't make it in to the saved database. Is there a practical limit on the number of records inserted in one go?</p>

<p>Can anyone suggest where else I should be looking - the error is tiny enough that it looks like the program is running fine, but it isn't.</p>

<p>Many thanks.</p>
","4248407","","4248407","","2020-06-03 21:09:31","2020-06-03 21:45:27","Swift CoreData - objects not being inserted in to managed object context","<swift><core-data><nsurlrequest><combine>","1","1","","","","CC BY-SA 4.0"
"62123938","1","","","2020-06-01 00:09:13","","1","317","<p>I'm trying to learn how to use an API with SwiftUI using Combine and MVVM. I'm super new to this so this may seem like a dumb question but I've got my WebService and it seems to check out but my ViewModel is asking for stuff that I don't know if it should. </p>

<p>I'd like to be able to search for a game by it's name and it pull from the API.</p>

<p>Here's my Game.swift Model:</p>

<pre><code>struct Game: Codable, Identifiable {
    let id: Int
    let name: String
}
</code></pre>

<p>Simple enough.</p>

<p>Here's my handy WebService: GameService.swift</p>

<pre><code>class GameService {
    func getGames(name: String, completion: @escaping (Game?) -&gt; ()) {
        guard let url = URL(string: ""https://api-v3.igdb.com/games/"") else { return }

        var request = URLRequest(url: url)
        request.setValue(""HIDDEN SO YOU CAN'T GET ME IN TROUBLE"", forHTTPHeaderField: ""user-key"")
        request.httpBody = ""fields id,name"".data(using: .utf8, allowLossyConversion: false)
        request.httpMethod = ""POST""
        request.setValue(""application/json"", forHTTPHeaderField: ""Accept"")

        URLSession.shared.dataTask(with: request) { data, response, error in

            guard let data = data, error == nil else {
                print(""No data in response: \(error?.localizedDescription ?? ""Unknown Error"")."")
                return
            }

            if let gameResponse = try? JSONDecoder().decode(Game.self, from: data) {
                print(""Yay"")
            } else {print(""Shit"")}

        }.resume()
    }
}

</code></pre>

<p>I'm getting a yellow warning of Value 'gameResponse' was defined but never used... on if let gameResponse = try? JSON decoder blah blah blah.</p>

<p>Ok now the messy boy, I present GameViewModel.swift to you:</p>

<pre><code>class GameViewModel: ObservableObject {

    private var gameService: GameService!

    @Published var game = Game()

    init() {
        self.gameService = GameService()
    }

    var gameName: String = """"

    func searchGames() {
        if let game = self.gameName.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) {
            getGames(by: name)
        }
    }

    private func getGames(by name: String) {
        self.gameService.getGames(name: name) { game in
            if let game = game {
                DispatchQueue.main.async {
                    self.game = game
                }
            }
        }
    }
}

</code></pre>

<p>BIG QUESTION: The @Published var game = Game() is saying that there are is a missing parameter 'from' in call. I haven't implemented from anywhere.</p>

<p>The find searchGames() function is giving me an unresolved identifier error with getGames(by: name). Any ideas?</p>
","7485407","","7485407","","2020-06-01 19:07:57","2020-06-01 19:07:57","Missing Argument for Parameter JSONDecoder URLSession with SwiftUI MVVM","<ios><json><mvvm><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"62124297","1","62124578","","2020-06-01 01:05:51","","0","65","<p><a href=""https://rxjs-dev.firebaseapp.com/api/index/function/iif"" rel=""nofollow noreferrer"">iif</a> is a useful operator that can decide which Observable to subscribe to at runtime. Is there an equivalent in Swift Combine framework with publisher? If not, what's a good workaround?</p>
","3808183","","","","","2020-06-01 01:48:17","Combine equivalent of RxJS iif","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62131257","1","62141356","","2020-06-01 11:36:09","","1","2064","<p>I may be going about this the wrong way, but I have a function with which I want to emit multiple values over time. But I don’t want it to start emitting until something is subscribed to that object. I’m coming to combine from RxSwift, so I’m basically trying to duplicated Observable.create() in the RxSwift world. The closest I have found is returning a Future, but futures only succeed or fail (so they are basically like a Single in RxSwift.) </p>

<p>Is there some fundamental thing I am missing here? My end goal is to make a function that processes a video file and emits progress events until it completes, then emits a URL for the completed file. </p>
","11017643","","","","","2022-09-16 02:44:51","Swift Combine Future with multiple values?","<swift><rx-swift><combine>","2","1","","","","CC BY-SA 4.0"
"62139342","1","62139427","","2020-06-01 19:12:43","","5","1910","<p>I'm trying to perform side effect on <code>Publisher</code>, and I can't find any operator which will allow me to do something like this. To be precise, I'm looking for a concept similar to RxSwift's <code>do(on:)</code>.</p>

<p>Here's what I'm trying to do.
I'm writing a reactive wrapper for a delegate provided by a 3rd party SDK. It's and SDK for interacting with BLE devices. I have methods like <code>startScanning</code> and <code>stopScanning</code> and what I want to achieve is to react to signals and call <code>stopScanning</code> as a side effect of any error or complete events. So far, I have something like this:</p>

<pre class=""lang-swift prettyprint-override""><code>newDeviceFoundPublisher
            .timeout(.seconds(timeout), scheduler: DispatchQueue.global())
            .eraseToAnyPublisher()
</code></pre>

<p>and what I want to achieve is something like:</p>

<pre class=""lang-swift prettyprint-override""><code>newDeviceFoundPublisher
            .timeout(.seconds(timeout), scheduler: DispatchQueue.global())
            .doOnError {
                manager.stopScanning()
            }
            .doOnComplete {
                manager.stopScanning()
            }
            .eraseToAnyPublisher()
</code></pre>

<p>Is there already something like this or maybe I'm missing something, and there's something in Combine I can use and get the result?</p>
","1911042","","","","","2020-06-01 19:18:14","Performing side effects on Publisher","<ios><swift><combine><frp>","1","0","1","","","CC BY-SA 4.0"
"62158279","1","62160035","","2020-06-02 17:53:11","","2","446","<p>I have a function that returns a publisher. This publisher gives the results of a background process. I only want to trigger the background process when the publisher would be subscribed, so that no results are lost. The background process can update its results many times, so the variant with <code>Future</code> is not suitable.</p>

<pre><code>private let passthroughSubject = PassthroughSubject&lt;Data, Error&gt;()

// This function will be used outside.
func fetchResults() -&gt; AnyPublisher&lt;Data, Error&gt; {
     return passthroughSubject
     .eraseToAnyPublisher()
     .somehowTriggerTheBackgroundProcess()
}

extension MyModule: MyDelegate {
     func didUpdateResult(newResult: Data) {
          self.passthroughSubject.send(newResult)
     }
}
</code></pre>

<p>What have I tried?</p>

<p>Future:</p>

<pre><code>Future&lt;Data, Error&gt; { [weak self] promise in
     self?.passthroughSubject
          .sink(receiveCompletion: { completion in
               // My logic
          }, receiveValue: { value in
               // My logic    
          })
          .store(in: &amp;self.cancellableSet)
      self?.triggerBackgroundProcess()
}.eraseToAnyPublisher()
</code></pre>

<p>Works the way I want but the subscriber is called only once (logical).</p>

<p>Deffered:</p>

<pre><code>Deferred&lt;AnyPublisher&lt;Data, Error&gt;&gt;(createPublisher: { [weak self] in
   defer {
      self?.triggerBackgroundProcess()
   }
   return passthroughSubject.eraseToAnyPublisher()
}
</code></pre>

<p>Debugger shows that everything is correct: first <code>return</code> then <code>trigger</code> but the subscriber is not called for the first time.</p>

<p><code>receiveSubscription</code>:</p>

<pre><code>passthroughSubject
.handleEvents(receiveSubscription: { [weak self] subscription in 
   self?.triggerBackgroundProcess()
})
.eraseToAnyPublisher()
</code></pre>

<p>The same effect as with <code>Deffered</code>.</p>

<p>Is it even possible what I want to achieve? 
Or, it is better to create a public publisher subscribe it and receive results from background process. And the <code>fetchResults()</code> function doesn't return anything?</p>

<p>Thanks in advance for your help.</p>
","11837681","","","","","2020-06-02 19:40:56","How can I trigger a process after a returned publisher would be subscribed?","<swift><combine>","2","4","1","","","CC BY-SA 4.0"
"62164578","1","62164627","","2020-06-03 03:08:51","","0","204","<p>In my app, I want to store an object in Environment to perform network queries from various views. However, during development I'd like to use a mock instead, and retrieve the payload (in JSON format) from the app's bundle. These are the steps I've taken:</p>

<ol>
<li>Specify the protocol</li>
</ol>

<pre><code>    typealias Token = String

    protocol MyAPIConforming {
        func signIn(username: String, password: String, completion: @escaping (Token?, Error?) -&gt; Void)
    }
</code></pre>

<ol start=""2"">
<li>Implement the two classes I need</li>
</ol>

<pre><code>    class MockMyAPIManager: MyAPIConforming, ObservableObject {
        func signIn(username: String, password: String, completion: @escaping (Token?, Error?) -&gt; Void) {
            // Read the JSON document from the app's bundle
        }
    }

    class MyAPIManager: MyAPIConforming, ObservableObject {
        func signIn(username: String, password: String, completion: @escaping (Token?, Error?) -&gt; Void) {
            // Perform the network request
        }
    }
</code></pre>

<ol start=""3"">
<li>Inject the mock object in the Environment</li>
</ol>

<pre><code>    let myManager = MockMyAPIManager()

    // Create the SwiftUI view that provides the window contents.
    let contentView = LoginView().environmentObject(myManager)
</code></pre>

<ol start=""4"">
<li>Declare the @Environment object in the view</li>
</ol>

<pre><code>    struct LoginView: View {
    @EnvironmentObject var myManager: MyAPIConforming
    ...
</code></pre>

<p>I did declare <code>myManager</code> to be <code>MyAPIConforming</code> because I could be passing an object of type <code>MockMyAPIManager</code> or <code>MyAPIManager</code>.</p>

<p>However, in step #4 I get the following error:</p>

<blockquote>
  <p>Property type 'MyAPIConforming' does not match that of the 'wrappedValue' property of its wrapper type 'EnvironmentObject'</p>
</blockquote>

<p>I'm not sure if the error means that there is no guarantee that the object adopting to <code>MyAPIConforming</code> will be also adopting the <code>ObservableObject</code> protocol.</p>

<p>So what do I need to do to store either <code>MockMyAPIManager</code> or <code>MyAPIManager</code> in the environment? Is this even possible?</p>
","686765","","","","","2020-06-03 04:45:06","Store a mock object in the Environment","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62179405","1","62180833","","2020-06-03 17:49:01","","0","1092","<p>I have this code in lrvViewModel.swift</p>

<pre><code>func getVerificationID (phoneNumber: String) -&gt; Future&lt;String?, Error&gt; {

        return Future&lt;String?, Error&gt; { promise in
            PhoneAuthProvider.provider().verifyPhoneNumber(phoneNumber, uiDelegate: nil) { (verificationID, error) in
                if let e = error {
                    promise(.failure(e))
                    return
                }
                print(""verification worked"")
                self.defaults.set(verificationID, forKey: ""authVerificationID"")
                return promise(.success(verificationID))
            }
        }
    }
</code></pre>

<p>and then i call and subscribe to the Publisher in another file like this</p>

<pre><code>let _ = lrvViewModel.getVerificationID(phoneNumber: (lrvViewController?.textField.text)!)
                .sink(receiveCompletion: {
                    print(""Error worked"")
                    // does a bunch of stuff
                }, receiveValue: {
                    print(""completion worked"")
                    // does a bunch of stuff
                })
</code></pre>

<p>I don't get any buildtime errors, but whenever I run the app the GetVerificationID function runs fine (prints ""Verification worked""), but the code within .sink doesn't run (I don't get any print statements). What's going on?</p>

<hr>

<p>Edit:</p>

<p>My solution was to give up on combine and go back to RXSwift where the code is simply:</p>

<pre><code> var validateObs = PublishSubject&lt;Any&gt;()

    func getVerificationID (phoneNumber: String) {

        PhoneAuthProvider.provider().verifyPhoneNumber(phoneNumber, uiDelegate: nil) { (verificationID, error) in
            if let e = error {
                print(""v error"")
                self.validateObs.onError(e)
                return
            }
            self.defaults.set(verificationID, forKey: ""authVerificationID"")
            self.validateObs.onCompleted()
            }
    }
</code></pre>

<p>and </p>

<pre><code>lrvViewModel.getVerificationID(phoneNumber: (lrvViewController?.textField.text)!)

            let _ = lrvViewModel.validateObs.subscribe(onError: {
                let e = $0
                print(e.localizedDescription)
                // do stuff
            }, onCompleted: {
                // do stuff

                })
</code></pre>

<p>Was hoping to not rely on a dependency but RxSwift implementation was much easier. </p>

<p>If someone knows the solution to the Combine Future problem please post! I would still like to know wtf is happening. It's very possible (and likely) I'm just using combine wrong. </p>

<hr>

<p>Edit 2:</p>

<p>Was using combine wrong. I can duplicate the code I had with RXSwift like this:</p>

<pre><code>let verifyPub = PassthroughSubject&lt;Any, Error&gt;()

func getVerificationID (phoneNumber: String) {

    PhoneAuthProvider.provider().verifyPhoneNumber(phoneNumber, uiDelegate: nil) { (verificationID, error) in
            if let e = error {
                self.verifyPub.send(completion: .failure(e))
                return
            }
            print(""verification worked"")
            self.defaults.set(verificationID, forKey: ""authVerificationID"")
        self.verifyPub.send(completion: .finished)
        }
    }
</code></pre>

<p>and </p>

<pre><code>let subs = Set&lt;AnyCancellable&gt;()
let pub = lrvViewModel.verifyPub
                .sink(receiveCompletion: { completion in
                    if case let .failure(error) = completion {
                        print(""Error worked"")
                       // do stuff
                    } else {
                        print(""completion worked"")
                        // do stuff
                    }
                    }, receiveValue: { _ in
                        print(""this will never happen"")
                    }).store(in: &amp;subs)
</code></pre>

<p>I didnt' understand that in combine there are only two results to a sink, a completion or a value, and that completion is split up into multiple cases. Whereas in RxSwift you have OnNext, OnComplete, and OnError. </p>

<p>Shoutout to the book on Combine from raywanderlich.com. Good stuff. </p>
","12728118","","12728118","","2020-06-04 16:13:30","2020-06-04 16:13:30",".sink is not returning the promise values from a Future Publisher","<swift><xcode><reactive-programming><ios13><combine>","1","3","","","","CC BY-SA 4.0"
"62191269","1","62193426","","2020-06-04 09:28:44","","0","2372","<p>I need to implement a handler for a timeout function in Combine. Let's consider the following code structure:</p>

<pre class=""lang-swift prettyprint-override""><code>SomeKindOfPublisher&lt;Bool, Never&gt;()
   .timeout(timeoutInterval, scheduler: backgroundQueue,
      customError: { [weak self] () -&gt; Never in
         ...
         while true {} // This block should not return because of Never
      }
</code></pre>

<p>My question is how to avoid a weird line <code>while true {}</code>? I would prefer not to change Never to Error type. </p>
","6305934","","","","","2020-06-04 11:23:58","Swift Combine. What is a correct way to return from a block of a timeout handler?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"62192104","1","","","2020-06-04 10:10:30","","-1","231","<p>I have a textfield in SwiftUI  where the user inputs a word.  I capture the characters entered using Combine and want to search a list of word and list words in which the characters are found.<br>
Eg user inputs d - list shows dan das dat den dev die din div
user inputs de - list shows den dev
user inputs dev - list shows dev</p>

<pre><code>.onReceive(Just(textSearch.text)) { 
newString in if self.usedWords.contains(newString) {
 self.mySearch(searchWord: newString) } } 
</code></pre>

<p>mySearch func is only called when there is a complete match of newString in an element of usedWords ... I need the partial matched </p>

<p>The last use-case works with string.contains(""dev""), but does not work with string.contains(""de"").  Clearly contains cannot do the job of matching a substring and returning all that contains that substring.  Is there another swift utility that I could use ?</p>

<p>Thank you for any help</p>
","3238267","","3238267","","2020-06-04 12:42:52","2020-06-04 13:57:20","Swift - Speed Search on list of words","<arrays><swift><string><swiftui><combine>","2","3","","","","CC BY-SA 4.0"
"62202516","1","62202984","","2020-06-04 19:17:58","","0","91","<p>I'm trying to wrap my mind around how Combine works.  I believe I'm doing something wrong when I use the .assign operator to mutate the @Published property I'm operating on.  I've read the documentation on Publishers, Subscribers, and Operators.  But I'm a bit loose on where exactly to create the Publisher if I don't want it to be a function call.</p>
<pre><code>import SwiftUI
import Combine

struct PhoneNumberField: View {
    
    let title: String
    @ObservedObject var viewModel = ViewModel()
    
    var body: some View {
        TextField(title,text: $viewModel.text)
    }
    
    class ViewModel: ObservableObject {
        @Published var text: String = &quot;&quot;
        private var disposables = Set&lt;AnyCancellable&gt;()
        
        init() {
            $text.map { value -&gt; String in
                    self.formattedNumber(number: value)
            }
            //something wrong here
            .assign(to: \.text, on: self)
            .store(in: &amp;disposables)
            
        }
        
        func formattedNumber(number: String) -&gt; String {
                let cleanPhoneNumber = number.components(separatedBy: CharacterSet.decimalDigits.inverted).joined()
                let mask = &quot;+X (XXX) XXX-XXXX&quot;

                var result = &quot;&quot;
                var index = cleanPhoneNumber.startIndex
                for ch in mask where index &lt; cleanPhoneNumber.endIndex {
                    if ch == &quot;X&quot; {
                        result.append(cleanPhoneNumber[index])
                        index = cleanPhoneNumber.index(after: index)
                    } else {
                        result.append(ch)
                    }
                }
                return result
            }
    }
}

struct PhoneNumberParser_Previews: PreviewProvider {
    static var previews: some View {
        PhoneNumberField(title: &quot;Phone Number&quot;)
    }
}
</code></pre>
","6768221","","8697793","","2020-07-14 15:01:05","2020-07-14 15:01:05","Using Combine to parse phone number String","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62212563","1","62229053","","2020-06-05 09:51:08","","1","242","<p>I found a lot of SwiftUI-related topics about this which didn't help (eg <a href=""https://stackoverflow.com/questions/57459727/why-an-observedobject-array-is-not-updated-in-my-swiftui-application"">Why an ObservedObject array is not updated in my SwiftUI application?</a>)</p>

<p>This doesn't work with Combine in Swift (specifically <strong>not</strong> using Swift<strong>UI</strong>):</p>

<pre class=""lang-swift prettyprint-override""><code>class SomeTask {
  @Published var progress = Progress(totalUnitCount: 5) // Progress is a Class
  [...]
}
var task = SomeTask()
let cancellable = task.$progress.sink { print($0.fractionCompleted) }
task.progress.completedUnitCount = 2
</code></pre>

<p>This is not SwiftUI-related so no <code>ObservableObject</code> inheritance to get <code>objectWillChange</code>, but even if I try to use <code>ObservableObject</code> and <code>task.objectWillChange.send()</code> it doesn't do anything, also trying to add <code>extension Progress: ObservableObject {}</code> doesn't help.
Since the publisher emits values through the var's <code>willSet</code> and since <code>Progress</code> is itself class-type nothing happens.</p>

<p><strong>Looks like there is no real decent way to manually trigger it?</strong></p>

<p>Only <strong>solution</strong> I found is to just re-assign itself which is quite awkward:</p>

<p><code>let pr = progress
progress = pr</code></p>

<p>(writing <code>progress = progress</code> is a compile-time error).</p>

<p>Only other way which might be working is probably by using <strong>Key-value-observing/KVO</strong> and/or writing a new <code>@PublishedClassType</code> property wrapper?</p>
","3078330","","3078330","","2020-06-06 07:11:14","2020-06-08 12:37:23","`@Published var name: ClassType` doesn't work _outside_ of SwiftUI / manual trigger?","<swift><key-value-observing><combine><reference-type>","3","5","","","","CC BY-SA 4.0"
"62220327","1","","","2020-06-05 16:46:42","","1","283","<p>I want to create a Swift Combine publisher that transmits a value and always gives the latest value when someone subscribes to it. However I want to only transmit a value once I have one - from an asynchronous call that’s triggered by the first subscriber. Pass through subject doesn’t work for that need, is there any good way to accomplish this?</p>
","3810942","","","","","2022-03-22 16:58:05","PassthroughSubject with no initial value","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"62233246","1","62233543","","2020-06-06 14:37:35","","-1","126","<p>I have this class in LRVDetails.swift</p>

<pre><code>class LRVDetails {
    var heading = CurrentValueSubject&lt;String, Never&gt;(K.LRV.Register)
    // other publishers
}
</code></pre>

<p>I have this assign in LRVViewController.swift</p>

<pre><code>private var details = LRVDetails()
private var subs = Set&lt;AnyCancellable&gt;()

override func viewDidLoad() {
    super.viewDidLoad()

    details
        .heading
        .assign(to: \.text!, on: heading)
        .store(in: &amp;subs)
}
</code></pre>

<p>and in LRVCoordinator.swift I have</p>

<pre><code>private var details = LRVDetails()

func UserDidPressButton() { // this is a delegate method from the VC
    details.heading.send(""New Heading"")
}
</code></pre>

<p>I thought that because LRVDetails is a class, it only stores a reference. so if I simply instantiate it in each file and then call send() on it, the publisher should update, and then emit the value to the LRVViewController subscription and update the heading.</p>

<p>But it does nothing. The subscriber never receives a value ( I checked with a .print() operator ). When i call lrvController?.details.send() -- without the private tag -- in the coordinator, it works fine.</p>

<p>Is this because the subscriber is stored in the 'subs' variable in LRVCoordinator, and thus it has to be updated with the subscriber in LRVViewController? That's my best bet. </p>

<p>If not, why doesn't this work?.</p>

<p>Thanks!</p>

<p>Edit:</p>

<p>If they are different instances, why does this code print two?</p>

<pre><code>class myClass {
 var int = 1
}

let test1 = myClass()
let test2 = myClass()

test1.int = 2
print(test2.int)
// prints 2
</code></pre>
","12728118","","12728118","","2020-06-06 15:36:16","2020-06-06 15:36:16","Why can't I call .send on a publisher in a class from a second class and have it update the subscription in third class?","<ios><swift><xcode><reactive-programming><combine>","1","1","","","","CC BY-SA 4.0"
"62233553","1","","","2020-06-06 15:01:30","","1","1496","<pre><code>extension CLGeocoder {
    func reverseGeocodeLocationPublisher(_ location: CLLocation, preferredLocale locale: Locale? = nil) -&gt; AnyPublisher&lt;CLPlacemark, Error&gt; {
        Future&lt;CLPlacemark, Error&gt; { promise in
            self.reverseGeocodeLocation(location, preferredLocale: locale) { placemarks, error in
                guard let placemark = placemarks?.first else {
                    return promise(.failure(error ?? CLError(.geocodeFoundNoResult)))
                }
                return promise(.success(placemark))
            }
        }.eraseToAnyPublisher()
    }
}

$stations.flatMap(maxPublishers: .max(1)) { (station) -&gt; AnyPublisher&lt;CLPlacemark, Error&gt; in
            let location = CLLocation(latitude: station.latitude, longitude: station.longitude)
            self.geocoder.reverseGeocodeLocationPublisher(location)

        }.eraseToAnyPublisher().sink(receiveCompletion: { completion in
            print(""done"")
        }, receiveValue: { placemark in
            print(""placemark:"", placemark)
        }).store(in: &amp;cancellableSet)
</code></pre>

<p>error:
<code>Instance method 'flatMap(maxPublishers:_:)' requires the types 'Published&lt;[Station]&gt;.Publisher.Failure' (aka 'Never') and 'Error' be equivalent</code></p>

<p>What I am trying to achieve is i have a list of stations which contains <code>location</code> and I want to <code>reverseGeocodeLocation</code> sequentially </p>
","3165940","","968155","","2020-06-07 03:06:26","2020-06-07 03:06:26","swift combine flatmap sequential operation","<swift><combine><flatmap>","1","1","","","","CC BY-SA 4.0"
"62242073","1","62242125","","2020-06-07 07:17:26","","3","3300","<p>I have been playing around a timer publisher for a while in playground. below is my code</p>

<pre><code>let timer = Timer
    .publish(every: 1.0, on: .main, in: .common)
.autoconnect()

var counter = 0
let subscriber = timer
    .map({ (date) -&gt; Void in
        counter += 1
    })
    .sink { _ in

        print(""I am printing the counter \(counter)"")
}

if counter &gt; 5 {
    timer.upstream.connect().cancel() //1.nothing happened
    subscriber.cancel() //2. nothing happened too. :(
}
</code></pre>

<p>But i could not stop the timer by using both line 1 and line 2.
What am i actually missing?</p>
","3172726","","","","","2020-06-07 07:23:46","how to stop a timer publisher?","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"62252592","1","62252655","","2020-06-07 22:40:12","","1","757","<p>The logic that I want to apply is: </p>

<p>If we have already imported the users we just fetch them otherwise import first the users and then fetch them. Here is my attempt :</p>

<pre><code>import Combine

struct User {
    let name: String
}

var didAlreadyImportUsers = false

// Import the users and return true of false 
var importUsers: Future&lt;Bool, Never&gt; {
    Future { promise in
        promise(.success(true))
    }
}

var fetchUsers: Future&lt;[User], Error&gt; {
    Future { promise in
        promise(.success([User(name: ""John""), User(name: ""Jack"")]))
    }
}

var users: Future&lt;[User], Error&gt; {
    if didAlreadyImportUsers {
        return fetchUsers
    } else {
        return importUsers.setFailureType(to: Error.self)
            .combineLatest(fetchUsers)
            .map { $0.1 }
    }
}
</code></pre>

<p>I get an error:</p>

<pre><code>Cannot convert return expression of type
'Publishers.Map&lt;Publishers.CombineLatest&lt;Publishers.SetFailureType&lt;Future&lt;Bool, Never&gt;, Error&gt;, Future&lt;[User], Error&gt;&gt;, [User]&gt;' 
to return type 'Future&lt;[User], Error&gt;'
</code></pre>

<p>Any idea how to get the result of chaining as Future&lt;[User], Error> ?</p>
","2305342","","","","","2020-06-07 22:47:42","Simple Future chaining that have different value types using Combine","<ios><swift><future><combine>","1","0","1","","","CC BY-SA 4.0"
"62253436","1","62258970","","2020-06-08 00:42:52","","2","2879","<p>I have 2 publishers where I want to perform an action based on either response. I don't care about the values. I'm trying to do something like this:</p>

<pre><code>var hasChangedPublisher: AnyPublisher&lt;(Void, Void), Never&gt; {
    Publishers.CombineLatest(
        preferences.publisher,
        state.$permissionStatus
    ).eraseToAnyPublisher()
}
</code></pre>

<p>If <code>preferences.publisher</code> fires first but not the other, I want to fire. If <code>state.$permissionStatus</code> fires but not the other, I want to fire. I don't really want to <code>CombineLatest</code>, but not sure how to fire if either emit.</p>

<p>Is there a way to produce an even if either fire but more elegantly erase its values?</p>
","235334","","","","","2022-02-26 16:42:02","How to combine 2 publishers and erase values to Void?","<swift><combine>","3","0","","","","CC BY-SA 4.0"
"62264214","1","62264351","","2020-06-08 14:20:37","","3","1992","<p>When using a Future I'm not able to receive the cancel event. </p>

<pre><code>Future&lt;String, Never&gt; { promise in
    promise(.success(""Hello Stackoverflow""))
}
.eraseToAnyPublisher()
    .handleEvents(receiveCancel: {
        print(""Cancel event received here"")
    })
    .sink(receiveValue: { value in
        print(value)
    })
    .store(in: &amp;disposeBag)

disposeBag.map { $0.cancel() }
</code></pre>

<p>Interestingly using a subject it's working and I'm getting the event.</p>

<pre><code>let subject = PassthroughSubject&lt;String, Never&gt;()

subject.send(""Hello Stackoverflow"")

    subject.eraseToAnyPublisher()
    .handleEvents(receiveCancel: {
        print(""Cancel event received here"")
    })
    .sink(receiveValue: { value in
        print(value)
    })
    .store(in: &amp;disposeBag)

disposeBag.map { $0.cancel() }
</code></pre>

<p>So why is Combine behaving that way and how I can resolve this?</p>
","4142753","","","","","2020-06-08 14:27:54","Receiving cancel event using Future in Combine","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"62264708","1","62265368","","2020-06-08 14:46:23","","4","2207","<p>If you run this on a Playground:</p>

<pre><code>import Combine
import Foundation

struct User {
    let name: String
}

var didAlreadyImportUsers = false

var importUsers: Future&lt;Bool, Never&gt; {
    Future { promise in
        sleep(5)
        promise(.success(true))
    }
}

var fetchUsers: Future&lt;[User], Error&gt; {
    Future { promise in
        promise(.success([User(name: ""John""), User(name: ""Jack"")]))
    }
}

var users: AnyPublisher&lt;[User], Error&gt; {
    if didAlreadyImportUsers {
        return fetchUsers
            .receive(on: DispatchQueue.global(qos: .userInitiated))
            .eraseToAnyPublisher()
    } else {
        return importUsers
            .receive(on: DispatchQueue.global(qos: .userInitiated))
            .setFailureType(to: Error.self)
            .combineLatest(fetchUsers)
            .map { $0.1 }
        .eraseToAnyPublisher()

    }
}

users
    .receive(on: DispatchQueue.global(qos: .userInitiated))
    .sink(receiveCompletion: { completion in
    print(completion)
}, receiveValue: { value in
    print(value)
})

print(""run"")

</code></pre>

<p>the output will be: </p>

<pre><code>[User(name: ""John""), User(name: ""Jack"")]
run
finished
</code></pre>

<p>But I was expecting to get:</p>

<pre><code>run
[User(name: ""John""), User(name: ""Jack"")]
finished
</code></pre>

<p>Because the sink should run the code in background thread. What I'm missing here. 
Do I need to rin the code:</p>

<pre><code> sleep(5)
 promise(.success(true))
</code></pre>

<p>in a background thread ? then what's the purpose of </p>

<pre><code>.receive(on: DispatchQueue.global(qos: .userInitiated))
</code></pre>
","2305342","","","","","2021-08-28 08:57:26","Execute Combine Future in background thread is not working","<ios><grand-central-dispatch><future><combine>","2","0","1","","","CC BY-SA 4.0"
"62268309","1","62268560","","2020-06-08 17:55:20","","3","3265","<p>I'd like to have a worker task update a SwiftUI view. </p>

<p>The worker task is busy doing the procedural work of the application - playing sounds, and firing timer-based events. I'd like to to flash several icons in a SwiftUI view during those timer events. So I want to trigger a view refresh in those icon views.</p>

<p>So, I created an environmentObject called Settings. It's instantiated in the App Delegate, and attached to the root view in the SceneDelegate.</p>

<p>The Settings object works just fine inside the SwiftUI View hierarchy. </p>

<p>The problem is the dreaded:</p>

<pre><code>Fatal error: No ObservableObject of type Settings found. A View.environmentObject(_:) for Settings may be missing as an ancestor of this view.
</code></pre>

<p>I think that the problem is that the worker class is instantiated in the AppDelegate, and Settings is not yet an ObservableObject yet when it's instantiated. But I'm confused.</p>

<p>The environment object is straightforward:</p>

<pre><code>import SwiftUI
import Combine

final class Settings: ObservableObject {
   @Published var showMenu: Bool = true
   @Published var lessonNum: Int = 0

   @Published var arrowsOn: Bool = false {
       willSet {
           willChange.send(self)
       }
   }
}

let willChange = PassthroughSubject&lt;Settings, Never&gt;()

</code></pre>

<p>It's instantiated, along with the worker class, in the AppDelegate:</p>

<pre><code>let settings = Settings()
...
var workerClass  = WorkerClass()
var leftArrow = LeftArrowView()

</code></pre>

<p>And it's passed to the SceneDelegate:</p>

<pre><code>            window.rootViewController = UIHostingController(rootView: contentView
                .environmentObject(settings)
</code></pre>

<p>The sub view that uses settings looks at the environment object to draw the icon in either the on or off state:</p>

<pre><code>import SwiftUI

struct LeftArrowView: View {
@EnvironmentObject var settings: Settings

    let leftArrowOnImage = Image(""Arrow Left On"").renderingMode(.original)
    let leftArrowOffImage = Image(""Arrow Left Off"").renderingMode(.original)

    var body: some View {
        ZStack {
            if settings.arrowsOn {
                leftArrowOnImage
            } else {
                leftArrowOffImage
            }
        }
    }
}

</code></pre>

<p>The worker class is called as a Button action from higher up in the SwiftUI view hierarchy.</p>

<p>Inside the worker class I attempt to attach to the settings environment object:</p>

<pre><code>import Combine

public class WorkerClass : NSObject, ObservableObject {

    @EnvironmentObject var settings: Settings
</code></pre>

<p>and inside a method that's invoked via a timer, I attempt to update a variable in the environment object:</p>

<pre><code>       settings.arrowsOn = !settings.arrowsOn
        print(""Arrows are \(settings.arrowsOn)"")
</code></pre>

<p>... which is when I discover that I failed to actually attach properly to the environment object.</p>

<p>What did I miss?</p>

<p>Thanks in advance for any insights...</p>
","4277085","","","","","2020-06-08 18:10:14","Setting a SwiftUI @EnvironmentObject from outside a view","<ios><swiftui><observable><combine>","1","0","2","","","CC BY-SA 4.0"
"62278466","1","","","2020-06-09 08:43:02","","2","129","<p>I have to use a 3rd party SDK in my app, so I thought it's an excellent opportunity also to use Combine in real life and wrap this SDK in a thin layer of Combine helpers. I was able to cover everything reasonably easy, but now I'm facing the issue that some of my <code>send</code> methods are never delivered. I'll share some of my code to draw a better picture of what I have.</p>

<pre><code>final class Manager: NSObject {
    private let sdkManager: BleManager

    // Private Publishers
    private let newDeviceFoundPublisher = PassthroughSubject&lt;Device, Error&gt;()
    private let connectedToDevicePublisher = PassthroughSubject&lt;Device, Error&gt;()
    private let deviceDataPublisher = PassthroughSubject&lt;DeviceData, Never&gt;()

    init(manager: BleManager = BleManager.shareInstance()) {
        self.vvBleManager = manager
        super.init()
        self.sdkManager.delegate = self
    }

    func startScanning(deviceType: DeviceType) -&gt; AnyPublisher&lt;Device, Error&gt; {
        sdkManager.startScan(deviceType)

        return newDeviceFoundPublisher
            .map { Device.init }
            .timeout(.seconds(10), scheduler: DispatchQueue.main, customError: { .scanningTimeout })
            .eraseToAnyPublisher()
    }

    func stopScanning() {
        sdkManager.stopScan()
    }

    func connect(to device: Device) -&gt; AnyPublisher&lt;Device, Error&gt; {
        sdkManager.connect(device)
        return connectedToDevicePublisher.eraseToAnyPublisher()
    }

    func disconnect(device: DeviceType) {
        sdkManager.disconnect(device)
    }

    func deviceData() -&gt; AnyPublisher&lt;DeviceData, Never&gt; {
        return deviceDataPublisher.eraseToAnyPublisher()
    }
}

extension VivalnkManager: BLEDelegate {
    func onDeviceFound(_ device: Device!) {
        newDeviceFoundPublisher.send(device)
    }

    func onConnected(_ device: Device!) {
        connectedToDevicePublisher.send(device)
        connectedToDevicePublisher.send(completion: .finished)
    }

    func onReceiveData(_ data: Any!) {
        if let newData = try? DeviceData(from: data!) {
            deviceDataPublisher.send(newData)
        }
    }
}
</code></pre>

<p>There's nothing crazy going on here and when I check logs from the SDK all methods are being executed correctly and the delegate is being triggered on new data etc. This is how I know there must be something wrong with my code. Now, what I'm trying to achieve and can't get it to work is presented the following code sample:</p>

<pre><code>manager
    .startScanning(deviceType: .swiftometr)
    .filter { $0.deviceId == id }
    .handleEvents(receiveOutput: { _ in environment.manager.stopScanning() })
    .flatMap { environment.manager.connect(to: $0) }
    .sink(receiveCompletion: { _ in print(""Completion"") },
            receiveValue: { _ in print(""Value"") })
    .store(in: &amp;cancellables)
</code></pre>

<p>As a result, I can only see <code>Completion</code> after some time being printed in my console, but I suspect this is from the <code>timeout</code> I have inside <code>scanning</code> method. I've tried many different approaches and nothing worked. Then, I thought, maybe <code>flatMap</code> doesn't work like this, so I've tried nesting a couple of <code>URLSession.shared.dataTaskPublisher</code>s together and they worked just fine!</p>

<hr>

<p>More digging and I'm in the state where I understand why this is all happening. It looks like <code>sdkManager.connect(device)</code> is happening so fast, that my application isn't able to subscribe, so that's the reason why I'd never receive any value. What helped my was simply wrapping this in a delayed block like this:</p>

<pre><code>func connect(to device: Device) -&gt; AnyPublisher&lt;Device, Error&gt; {
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
        sdkManager.connect(device)
    }

    return connectedToDevicePublisher.eraseToAnyPublisher()
}
</code></pre>

<p>Now <code>connect</code> is able to return <code>AnyPublisher</code> and allow subscribers to subscribe before the <code>send</code> happens. Even though it works, it feels like a hacky way of doing things and I'm not really happy with it. Looking for some better approaches.</p>
","1911042","","1911042","","2020-06-09 10:13:25","2021-10-17 22:14:27","Writing Combine wrapper around 3rd party SDK","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62288568","1","62290125","","2020-06-09 17:34:20","","1","437","<p>If you try this code in Playgroud:</p>

<pre><code>import Combine
import Foundation

struct User {
    let name: String
}

private var subscriptions = Set&lt;AnyCancellable&gt;()
var didAlreadyImportUsers = false
var users = [User]()

func importUsers() -&gt; Future&lt;Bool, Never&gt; {
    Future { promise in
        DispatchQueue.global(qos: .userInitiated).async {
            sleep(5)
            users = [User(name: ""John""), User(name: ""Jack"")]
            promise(.success(true))
        }
    }
}

func getUsers(age: Int? = nil) -&gt;Future&lt;[User], Error&gt; {
    Future { promise in
        promise(.success(users))
    }
}

var usersPublisher: AnyPublisher&lt;[User], Error&gt; {
    if didAlreadyImportUsers {
        return getUsers().eraseToAnyPublisher()
    } else {
        return importUsers()
            .setFailureType(to: Error.self)
            .combineLatest(getUsers())
            .map { $0.1 }
            .eraseToAnyPublisher()
    }
}

usersPublisher
    .sink(receiveCompletion: { completion in
    print(completion)
}, receiveValue: { value in
    print(value)
}).store(in: &amp;subscriptions)
</code></pre>

<p>It will print: </p>

<pre><code>[]
finished
</code></pre>

<p>but I expect: </p>

<pre><code>[User(name: ""John""), User(name: ""Jack"")]
finished

</code></pre>

<p>If I remove the line with <code>sleep(5)</code> then it prints the result correctly. It seems like an issue with asynchronicity. It seems like <code>.combineLatest(getUsers())</code> is not waiting for <code>importUsers()</code> I thought that <code>combineLatest</code> is taking care of that ? what I'm missing here ? </p>

<p>(in my real code there is a long running Core Data operations instead of <code>sleep</code>)</p>
","2305342","","","","","2020-06-09 19:08:33","Combine combineLatest is not waiting for the previous operation to fire","<ios><swift><combine><combinelatest>","1","0","","","","CC BY-SA 4.0"
"62307192","1","62307707","","2020-06-10 15:22:29","","0","720","<p>I am requesting a single value from a publisher and would like to terminate after I get the response. Below I'm just deallocating the cancel token after the first time, is there a better way to do this?</p>

<pre><code>extension MyInteractor {
    private static var locationPermissionToken: Cancellable?

    func requestLocationPermission(completion: @escaping (Result&lt;Void, LocationError&gt;) -&gt; Void) {
        Self.locationPermissionToken = locationProxy.authorizationPublisher
            .sink { status in
                Self.locationPermissionToken = nil
                status ? completion(.success(())) : completion(.failure(.deniedLocationServices))
            }

        locationProxy.requestAuthorization()
    }
}
</code></pre>
","235334","","","","","2020-06-10 15:47:55","How to terminate Swift Combine response after first emit?","<swift><reactive-programming><combine>","1","2","","","","CC BY-SA 4.0"
"62307501","1","62319762","","2020-06-10 15:37:15","","1","433","<p>I'm trying to create a <code>LocationManager</code> wrapper for Combine. I have a publisher and some functions that trigger the publisher. However, I'd like to combine them in one with a custom command.</p>

<p>Here's what I got so far:</p>

<pre><code>@available(OSX 10.15, iOS 13, tvOS 13, watchOS 6, *)
public class LocationProxy: NSObject {
    private lazy var manager = CLLocationManager()

    private static let authorizationSubject = PassthroughSubject&lt;Bool, Never&gt;()
    public private(set) lazy var authorizationPublisher: AnyPublisher&lt;Bool, Never&gt; = Self.authorizationSubject.eraseToAnyPublisher()

    var isAuthorized: Bool { CLLocationManager.isAuthorized }

    func isAuthorized(for type: LocationAPI.AuthorizationType) -&gt; Bool {
        guard CLLocationManager.locationServicesEnabled() else { return false }

        #if os(macOS)
        return type == .always &amp;&amp; CLLocationManager.authorizationStatus() == .authorizedAlways
        #else
        return (type == .whenInUse &amp;&amp; CLLocationManager.authorizationStatus() == .authorizedWhenInUse)
            || (type == .always &amp;&amp; CLLocationManager.authorizationStatus() == .authorizedAlways)
        #endif
    }

    func requestAuthorization(for type: LocationAPI.AuthorizationType = .whenInUse) {
        // Handle authorized and exit
        guard !isAuthorized(for: type) else {
            Self.authorizationSubject.send(true)
            return
        }

        // Request appropiate authorization before exit
        defer {
            #if os(macOS)
            if #available(OSX 10.15, *) {
                manager.requestAlwaysAuthorization()
            }
            #elseif os(tvOS)
            manager.requestWhenInUseAuthorization()
            #else
            switch type {
            case .whenInUse:
                manager.requestWhenInUseAuthorization()
            case .always:
                manager.requestAlwaysAuthorization()
            }
            #endif
        }

        // Handle mismatched allowed and exit
        guard !isAuthorized else {
            // Process callback in case authorization dialog not launched by OS
            // since user will be notified first time only and ignored subsequently
            Self.authorizationSubject.send(false)
            return
        }

        // Handle denied and exit
        guard CLLocationManager.authorizationStatus() == .notDetermined else {
            Self.authorizationSubject.send(false)
            return
        }
    }

    public func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        guard status != .notDetermined else { return }
        Self.authorizationSubject.send(isAuthorized)
    }
}
</code></pre>

<p>To use it, I have to subscribe first, then call the request authorization function:</p>

<pre><code>cancellable = locationProxy.authorizationPublisher
    .sink { status in
        print(status)
    }

locationProxy.requestAuthorization()
</code></pre>

<p>Is there a way to structure the code to subscribe and request authorization in one call, something like this:</p>

<pre><code>cancellable = locationProxy.authorizationPublisher
    .sink { status in
        print(status)
    }
    .requestAuthorization()
</code></pre>
","235334","","235334","","2020-06-10 15:59:03","2020-06-11 08:05:27","How to create a custom chain in Swift Combine?","<swift><location><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"62316440","1","62319791","","2020-06-11 03:14:41","","0","304","<p>I have an <code>AnyPublisher</code> property that emits values. When someone subscribes to it, is there a way to emit the last value immediately and let it listen for future values from there?</p>
","235334","","","","","2020-06-11 08:07:04","Fire last value when subscribing to publisher?","<swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"62331914","1","","","2020-06-11 19:17:51","","1","39","<p>I have a Pipeline which is waiting for a message and handle it afterwards. When I'm done I would like to restart the Pipeline and wait again for an incoming InitialMessage. What is the best practice for doing this? Feedback is highly appreciated.</p>

<pre class=""lang-swift prettyprint-override""><code>        self.incomingInitialMessage()
            .flatMap { self.handleTransmission(for: $0, transmissionProvider: $1) }
            .subscribe(on: self.transmissionQueue)
            .sink(receiveCompletion: { [weak self] completion in
                   ....
                }, receiveValue: { _ in })
            .store(in: &amp;self.disposeBag)

</code></pre>
","4142753","","","","","2020-06-11 19:17:51","Best practice subscribing to pipeline again after completion in Combine","<ios><swift><combine>","0","0","","","","CC BY-SA 4.0"
"62369535","1","","","2020-06-14 07:16:36","","3","713","<p>I would like to be able to run a block of code no matter what the outcome of the publishing chain is. Is there something similar in Combine + Swift?</p>

<p>Something like this:</p>

<pre><code>func doSomeLongRunningTask() -&gt; AnyPublisher&lt;Void, Error&gt; {
  return Future&lt;Void, Error&gt; {
    showSpinner()
  }.tryMap {
    longRunningTaskCanThrowError()
  }.ensure {
    hideSpinner()
  }.eraseToAnyPublisher()
}
</code></pre>
","2750088","","","","","2020-06-14 10:17:46","Is there a function in Swift + Combine similar to PromiseKit's ""ensure""?","<swift><promise><combine><finally>","1","0","2","2020-06-14 17:06:16","","CC BY-SA 4.0"
"62372478","1","62372581","","2020-06-14 12:25:40","","2","1314","<p>I have a publisher that my view's <code>onReceive</code> is subscribed to. Instead of duplicating logic in <code>onAppear</code> as well, I'd like the publisher in the <code>onReceive</code> to fire on first subscribe.</p>

<p>Is there a way to convert a publisher to a <code>CurrentValueSubject</code>? Here's what I'm trying to do:</p>

<pre><code>var myPublisher: CurrentValueSubject&lt;Void, Never&gt; {
    Just(()) // Error: Cannot convert return expression of type 'Just&lt;()&gt;' to return type 'CurrentValueSubject&lt;Void, Never&gt;'
}
</code></pre>

<p>Is this possible or a better way to do this?</p>
","235334","","","","","2021-10-27 04:05:12","How to convert a publisher to a CurrentValueSubject?","<swift><reactive-programming><combine>","2","0","","","","CC BY-SA 4.0"
"62372908","1","62374081","","2020-06-14 13:03:53","","3","2118","<p>I'm trying to pass in an optional publisher to my view's <code>.onReceive</code>. I don't want to force wrap it like this:</p>

<pre><code>let refreshPublisher: AnyPublisher&lt;Void, Never&gt;?

var body: some View {
    Group {
        ...
    }
    .onReceive(refreshPublisher!) {...}
}
</code></pre>

<p>So I'm passing an empty default value like this:</p>

<pre><code>var body: some View {
    Group {
        ...
    }
    .onReceive(refreshPublisher ?? Empty&lt;Void, Never&gt;().eraseToAnyPublisher()) {...}
}
</code></pre>

<p>This is really verbose and want to add an extension on <code>Optional</code> publishers something like this:</p>

<pre><code>extension Optional where Wrapped == Publisher { // Incorrect syntax, doesn't compile
    func orEmpty() -&gt; AnyPublisher&lt;Void, Never&gt; { ... }
}
</code></pre>

<p>This way, I can end or doing something like this: </p>

<pre><code>var body: some View {
    Group {
        ...
    }
    .onReceive(refreshPublisher.orEmpty()) {...}
}
</code></pre>

<p>Is something like this possible or a better way to handle optional publishers in non-optional chains?</p>
","235334","","","","","2020-06-14 15:09:27","Extension for default empty value for optional publisher?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62406372","1","62415523","","2020-06-16 10:28:35","","1","532","<p>Is there any way to get the subscriptions by accessing the publisher?</p>

<p>In the below example, I created a publisher, and had it subscribed by two subscribers and had the publisher send a value.</p>

<p>Here in this simple scenario, all works are thrown together in a couple of lines of code. It is easy to notice who subscribed the publisher. In real world application, however, each work is compartmentalized and hard to notice the subscribers from the publisher's standpoint.</p>

<p>So, does a publisher has properties to get access to the subscribers or subscriptions?
Or, do you suggest a design pattern to make publisher-subscriber data flow more obvious?</p>

<pre><code>final class IntSubscriber: Subscriber {

  typealias Input = Int
  typealias Failure = Never

  func receive(subscription: Subscription) {
      print(""receive subscription"")
    subscription.request(.max(3))
  }

  func receive(_ input: Int) -&gt; Subscribers.Demand {
    print(""Received value"", input)
    return .none
  }

  func receive(completion: Subscribers.Completion&lt;Never&gt;) {
    print(""Received completion"", completion)
  }
}

let subject = PassthroughSubject&lt;Int, Never&gt;()
let subscriber1 = IntSubscriber()
let subscriber2 = IntSubscriber()
subject.subscribe(subscriber1)
subject.subscribe(subscriber2)

// send a value without knowing who might get the value?
subject.send(3)
</code></pre>
","5007422","","","","","2020-06-16 18:45:37","How to access the subscriptions from the given publisher? (combine kit)","<ios><swift><combine><publisher><subscriber>","1","0","","","","CC BY-SA 4.0"
"62408526","1","62433711","","2020-06-16 12:29:16","","0","2265","<p>I want to display multiple text fields, representing scores of each part of a match.</p>

<p>Example : For a volleyball match, we have 25/20, 25/22, 25/23. The global score is 3/0.</p>

<p>The global components architecture :</p>

<pre><code>&gt;&gt; ParentComponent
    &gt;&gt; MainComponent
        &gt;&gt; X TextFieldsComponent (2 text fields, home/visitor score)
</code></pre>

<p>The lowest component, TextFieldsComponent, contains basic bindings :</p>

<pre><code>struct TextFieldsComponent: View {
    @ObservedObject var model: Model

    class Model: ObservableObject, Identifiable, CustomStringConvertible {
        let id: String
        @Published var firstScore: String
        @Published var secondScore: String

        var description: String {
            ""\(firstScore) \(secondScore)""
        }

        init(id: String, firstScore: String = .empty, secondScore: String = .empty) {
            self.id = id
            self.firstScore = firstScore
            self.secondScore = secondScore
        }
    }

    var body: some View {
        HStack {
            TextField(""Dom."", text: $model.firstScore)
                .keyboardType(.numberPad)
            TextField(""Ext."", text: $model.secondScore)
                .keyboardType(.numberPad)
        }
    }
}
</code></pre>

<p><strong>The parent component needs to show the total score of all parts of the match. And I wanted to try a Combine binding/stream to get the total score.</strong></p>

<p>I tried multiple solutions and I ended up with this non-working code (the reduce seems to not be take all the elements of the array but internally stores a previous result) :</p>

<pre><code>struct MainComponent: View {
    @ObservedObject var model: Model
    @ObservedObject private var totalScoreModel: TotalScoreModel

    class Model: ObservableObject {
        @Published var scores: [TextFieldsComponent.Model]

        init(scores: [TextFieldsComponent.Model] = [TextFieldsComponent.Model(id: ""main"")]) {
            self.scores = scores
        }
    }

    private final class TotalScoreModel: ObservableObject {
        @Published var totalScore: String = """"
        private var cancellable: AnyCancellable?

        init(publisher: AnyPublisher&lt;String, Never&gt;) {
            cancellable = publisher.print().sink {
                self.totalScore = $0
            }
        }
    }

    init(model: Model) {
        self.model = model
        totalScoreModel = TotalScoreModel(
            publisher: Publishers.MergeMany(
                model.scores.map {
                    Publishers.CombineLatest($0.$firstScore, $0.$secondScore)
                        .map { ($0.0, $0.1) }
                        .eraseToAnyPublisher()
                }
            )
            .reduce((0, 0), { previous, next in
                guard let first = Int(next.0), let second = Int(next.1) else { return previous }
                return (
                    previous.0 + (first == second ? 0 : (first &gt; second ? 1 : 0)),
                    previous.1 + (first == second ? 0 : (first &gt; second ? 0 : 1))
                )
            })
            .map { ""[\($0.0)] - [\($0.1)]"" }
            .eraseToAnyPublisher()
        )
   }

    var body: some View {
        VStack {
            Text(totalScoreModel.totalScore)
            ForEach(model.scores) { score in
                TextFieldsComponent(model: score)
            }
        }
    }
}
</code></pre>

<p>I'm searching for a solution to get an event on each binding change, and merge it in a single stream, to display it in MainComponent.</p>

<p>N/B: The TextFieldsComponent needs to be usable in standalone too.</p>
","10785142","","","","","2020-09-04 00:49:56","SwiftUI / Combine : Listening array items value change","<swift><swiftui><reactive><combine>","1","0","","","","CC BY-SA 4.0"
"62452048","1","62461722","","2020-06-18 14:15:11","","2","1696","<p>I have 3 observables namely source, source1 and source2. What I want is whenever source emits distinct event get the value of source1 and source2. This is the code I've come up with, obviously it won't compile since withLatestFrom expects only one observable.</p>

<pre><code>source.distinctUntilChanged()
        .withLatestFrom(source1, source2) { ($0, $1.0, $1.1) }
        .subscribe(onNext: { (A, B, C) in
            print(""OnNext called"")
        })
        .disposed(by: bag)
</code></pre>
","3490203","","","","","2020-06-19 01:02:19","RxSwift Use withLatestFrom operator with multiple sources","<ios><swift><rx-swift><reactive><combine>","2","0","","","","CC BY-SA 4.0"
"62469222","1","62469820","","2020-06-19 11:24:25","","0","2335","<p>I've been successfully using <a href=""https://github.com/Thomvis/BrightFutures"" rel=""nofollow noreferrer"">BrightFutures</a> in my apps mainly for async network requests. I decided it was time to see if I could migrate to <a href=""https://developer.apple.com/documentation/combine"" rel=""nofollow noreferrer"">Combine</a>. However what I find is that when I combine two <a href=""https://developer.apple.com/documentation/combine/future"" rel=""nofollow noreferrer"">Futures</a> using <a href=""https://developer.apple.com/documentation/combine/future/3333364-flatmap"" rel=""nofollow noreferrer"">flatMap</a> with two subscribers my second <a href=""https://developer.apple.com/documentation/combine/future"" rel=""nofollow noreferrer"">Future</a> code block is executed twice. Here's some example code which will run directly in a playground:</p>

<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation

extension Publisher {
    func showActivityIndicatorWhileWaiting(message: String) -&gt; AnyCancellable {
        let cancellable = sink(receiveCompletion: { _ in Swift.print(""Hide activity indicator"") }, receiveValue: { (_) in })
        Swift.print(""Busy: \(message)"")
        return cancellable
    }
}

enum ServerErrors: Error {
    case authenticationFailed
    case noConnection
    case timeout
}

func authenticate(username: String, password: String) -&gt; Future&lt;Bool, ServerErrors&gt; {
    Future { promise in
        print(""Calling server to authenticate"")
        DispatchQueue.main.async {
            promise(.success(true))
        }
    }
}

func downloadUserInfo(username: String) -&gt; Future&lt;String, ServerErrors&gt; {
    Future { promise in
        print(""Downloading user info"")
        DispatchQueue.main.async {
            promise(.success(""decoded user data""))
        }
    }
}

func authenticateAndDownloadUserInfo(username: String, password: String) -&gt; some Publisher {
    return authenticate(username: username, password: password).flatMap { (isAuthenticated) -&gt; Future&lt;String, ServerErrors&gt; in
        guard isAuthenticated else {
            return Future {$0(.failure(.authenticationFailed)) }
        }
        return downloadUserInfo(username: username)
    }
}

let future = authenticateAndDownloadUserInfo(username: ""stack"", password: ""overflow"")
let cancellable2 = future.showActivityIndicatorWhileWaiting(message: ""Please wait downloading"")
let cancellable1 = future.sink(receiveCompletion: { (completion) in
    switch completion {
    case .finished:
        print(""Completed without errors."")
    case .failure(let error):
        print(""received error: '\(error)'"")
    }
}) { (output) in
    print(""received userInfo: '\(output)'"")
}
</code></pre>

<p>The code simulates making two network calls and <code>flatmap</code>s them together as a unit which either succeeds or fails.
The resulting output is:</p>

<blockquote>
  <p><code>Calling server to authenticate</code><br>
  <code>Busy: Please wait downloading</code><br>
  <code>Downloading user info</code><br>
  <code>Downloading user info</code> &nbsp;&nbsp;&nbsp;&nbsp;&lt;---- unexpected second network call <br>
  <code>Hide activity indicator</code><br>
  <code>received userInfo: 'decoded user data'</code><br>
  <code>Completed without errors.</code></p>
</blockquote>

<p>The problem is <code>downloadUserInfo((username:)</code> appears to be called twice. If I only have one subscriber then <code>downloadUserInfo((username:)</code> is only called once. I have an ugly solution that wraps the <code>flatMap</code> in another <code>Future</code> but feel I missing something simple. Any thoughts?</p>
","848808","","848808","","2020-06-19 11:36:50","2020-06-19 13:52:37","Combine Future block called multiple times when using Flatmap and multiple subscribers","<ios><combine>","1","6","","","","CC BY-SA 4.0"
"62474871","1","62476194","","2020-06-19 16:41:54","","12","2311","<p>I am having some trouble with memory management in SwiftUI and Combine.</p>

<p>For example, if I have a NavigationView and then navigate to a detail view with a TextField, and enter a value in the TextField and tap on the back button, next time I go to that view the TextField has the previously entered value.</p>

<p>I noticed that the view-model is still in memory after the detail view is dismissed, and that's probably why the TextField still holds a value.</p>

<p>In UIKit, when dismissing a ViewController, the view-model will be deallocated and then created again when the ViewController is presented. This seems to not be the case here.</p>

<p>I attach some minimum reproductible code for this issue.</p>

<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    var body: some View {
        NavigationView {
            NavigationLink(destination: OtherView()) {
                Text(""Press Here"")
            }
        }
    }
}

struct OtherView: View {

    @ObservedObject var viewModel = ViewModel()

    var body: some View {
        VStack {
            TextField(""Something"", text: $viewModel.enteredText)
                .textFieldStyle(RoundedBorderTextFieldStyle())

            Button(action: {
                print(""Tap"")
            }) {
                Text(""Tapping"")
            }.disabled(!viewModel.isValid)
        }
    }
}

class ViewModel: ObservableObject {

    @Published var enteredText = """"
    var isValid = false

    var cancellable: AnyCancellable?

    init() {
        cancellable = textValidatedPublisher.receive(on: RunLoop.main)
            .assign(to: \.isValid, on: self)
    }

    deinit {
        cancellable?.cancel()
    }

    var textValidatedPublisher: AnyPublisher&lt;Bool, Never&gt; {
        $enteredText.map {
            $0.count &gt; 1
        }.eraseToAnyPublisher()
    }


}
</code></pre>

<p>I also noticed that, if for example, I add another view, let's say SomeOtherView after OtherView, then each time I type in the TextField from OtherView, then the deinit from SomeOtherView's view-model is called. Can anyone please also explain why this happens?</p>
","11974137","","11974137","","2020-06-19 16:56:01","2022-08-23 14:02:15","ObservedObject view-model is still in memory after the view is dismissed","<ios><swift><swiftui><combine>","2","4","2","","","CC BY-SA 4.0"
"62480033","1","","","2020-06-19 23:50:50","","2","293","<p>I am trying to plug a memory leak. I have the following class that fetches API requests:</p>

<pre><code>public struct Service {

  public let baseURL: URL
  public let session: URLSession

  public init (baseURL: URL, session: URLSession) {
    self.baseURL = baseURL
    self.session = session
  }

  public struct Response {
    public let data: Data
    public let response: URLResponse
  }



  public enum ServiceError: Error {
    case api(title: String, messages: [String])
    case other(Error)
  }



  struct ServiceErrorResponse: Decodable {
    let response: ErrorResponse

    enum CodingKeys: String, CodingKey {
      case response = ""error""
    }
  }



  struct ErrorResponse: Decodable {
    let title: String
    let messages: [String]
  }



  public enum HTTPMethod: String {
    case get = ""GET""
    case put = ""PUT""
    case post = ""POST""
    case patch = ""PATCH""
    case delete = ""DELETE""
  }



  public func run(_ request: URLRequest) -&gt; AnyPublisher&lt;Response, ServiceError&gt; {
    return session
      .dataTaskPublisher(for: request)
      .tryMap { data, response in
        guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
          let error = try JSONDecoder().decode(ServiceErrorResponse.self, from: data)
          let title = error.response.title
          let messages = error.response.messages

          print(error.response)

          throw ServiceError.api(title: title, messages: messages)
        }

        return Response(data: data, response: response)
      }
      .mapError { err in
        let error = err is ServiceError ? err : ServiceError.other(err)
        return error as! Service.ServiceError
      }
      .eraseToAnyPublisher()
  }



  public func fetch(
    _ path: String,
    method: HTTPMethod = .get,
    params: Data? = nil
  ) -&gt; AnyPublisher&lt;Response, ServiceError&gt; {

    let url: URL

    if let params = params, method == .get {
      url = buildGetURLWithParams(path: path, params: params)!
    }
    else {
      url = baseURL.appendingPathComponent(path)
    }


    var request = URLRequest(url: url)
    request.httpMethod = method.rawValue
    request.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")


    if let params = params, method != .get {
      request.httpBody = params
    }

    return run(request)
  }


  private func buildGetURLWithParams(path: String, params: Data) -&gt; URL? {
    if let json = try? JSONSerialization.jsonObject(with: params, options: []) as? [String: String] {
      var urlComponents = URLComponents(
        url: baseURL.appendingPathComponent(path),
        resolvingAgainstBaseURL: false
      )
      urlComponents?.queryItems = json.map { URLQueryItem(name: $0, value: $1) }

      return urlComponents?.url
    }
    else { return nil }
  }
}
</code></pre>

<p>I then make requests from the app using the following:</p>

<pre><code>typealias ServiceResponse = Service.Response
typealias ServiceError = Service.ServiceError
typealias ServiceMethod = Service.HTTPMethod

    enum MyAPI {

      static let service = Service(
        baseURL: URL(string: ""http://127.0.0.1:3000/api"")!,
        session: URLSession(configuration: URLSessionConfiguration.default)
  )

  static func login(email: String, password: String) -&gt; AnyPublisher&lt;ServiceResponse, ServiceError&gt; {
    let params = [""email"": email, ""password"": password]
    let json = try! JSONEncoder().encode(params)

    return service.fetch(""/login"", method: .post, params: json)
  }
}
</code></pre>

<p>The <code>login</code> function fetches a response and returns an <code>AnyPublisher</code> which is consumed as follows: </p>

<pre><code>enum UserAction {
  case login
  case loginSuccess(UserResponse)
  case loginFailure
  case logout



  static func login(email: String, password: String) -&gt; Dispatch&lt;AppAction&gt; {
    return { dispatch in
      dispatch(.userAction(action: .login))


      return MyAPI.login(email: email, password: password)
        .map(\.data)
        .decode(type: UserResponse.self, decoder: JSONDecoder())
        .receive(on: DispatchQueue.main)
        .sink(
          receiveCompletion: { completion in
            if case .failure(let err) = completion {
              print(""--------------------------"")
              print(""Retrieving data failed with error \(err)"")
            }
          },
          receiveValue: { result in
            dispatch(.userAction(action: .loginSuccess(result))) // Here I have a memory leak

          }
      )
    }
  }
}
</code></pre>

<p>I am mimicking something like Redux where a dispatch actions to change state, so I return an 'effect' from the UserAction login that gets the dispatch function. Everything works nicely but at the <code>receiveValue</code>  line I get a memory leak with the following description:</p>

<p><a href=""https://i.stack.imgur.com/G4zhB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/G4zhB.png"" alt=""enter image description here""></a></p>

<p>Any ideas what could be causing it or how I can find out? Im fairly new to Xcode and Swift.</p>
","2217750","","","","","2020-06-19 23:50:50","Swift Combine Memory Leak from CFNetwork","<swift><xcode><swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"62491875","1","","","2020-06-20 21:25:51","","1","104","<p>I have a class that conforms to <code>ObservableObject</code>, and for testing purposes, I'd like to listen to when the object changes. However, I am getting an issue. Here is the smallest fragment that I am able to reproduce the issue from:</p>
<pre><code>import Combine
import XCTest

class FooTests: XCTestCase {
    func testListen() {
        let object = Foo()
        var count = 0
        let sub = object.objectWillChange.sink {
            count += 1
        }     
        object.objectWillChange.send()
        XCTAssertEqual(count, 1)
        sub.cancel()
    }
}

fileprivate final class Foo: ObservableObject {}
</code></pre>
<p>When I run this test locally, it passes fine. However, it fails when it is run on my CI server (I am using Travis CI) because <code>count</code> is <code>0</code> rather than <code>1</code>. I cannot figure out any reason why the different environments would cause this to happen. Could I be using an incorrect version of Combine, and its behavior has changed? Or could there be some sort of an environment variable that would affect this behavior? Or is there another way to listen to changes on <code>object</code> other than doing <code>object.objectWillChange.sink {}</code> that will work? I'm at a complete loss to explain it, so any help would be greatly appreciated.</p>
","3128464","","12299030","","2020-06-21 06:51:40","2020-06-21 06:51:40","Listen to changes on ObservableObject (with Travis CI)","<ios><swift><swiftui><travis-ci><combine>","0","3","","","","CC BY-SA 4.0"
"62493246","1","","","2020-06-21 00:34:57","","0","976","<p>I've created a Combine publisher chain that looks something like this:</p>
<pre><code>let pub = getSomeAsyncData()
           .mapError { ... }
           .map { ... }
           ...
           .flatMap { data in 
               let wsi = WebSocketInteraction(data, ...)
               return wsi.subject
           }
           .share().eraseToAnyPublisher()
</code></pre>
<p>It's a flow of different possible network requests and data transformations. The calling code wants to subscribe to <code>pub</code> to find out when the whole asynchronous process has succeeded or failed.</p>
<p>I'm confused about the design of the <code>flatMap</code> step with the <code>WebSocketInteraction</code>. That's a helper class that I wrote. I don't think its internal details are important, but its purpose is to provide its <code>subject</code> property (a <code>PassthroughSubject</code>) as the next Publisher in the chain. Internally the <code>WebSocketInteraction</code> uses <code>URLSessionWebSocketTask</code>, talks to a server, and publishes to the <code>subject</code>. I like <code>flatMap</code>, but how do you keep this piece alive for the lifetime of the Publisher chain?</p>
<p>If I store it in the outer object (no problem), then I need to clean it up. I could do <em>that</em> when the <code>subject</code> completes, but if the caller <em>cancels</em> the entire publisher chain then I won't receive a completion event. Do I need to use <code>Publisher.handleEvents</code> and listen for cancellation as well? This seems a bit ugly. But maybe there is no other way...</p>
<pre><code>.flatMap { data in 
    let wsi = WebSocketInteraction(data, ...)
    self.currentWsi = wsi  // store in containing object to keep it alive.
    wsi.subject.sink(receiveCompletion: { self.currentWsi = nil })
    wsi.subject.handleEvents(receiveCancel: {
        wsi.closeWebSocket()
        self.currentWsi = nil
    })
</code></pre>
<p>Anyone have any good &quot;design patterns&quot; here?</p>
<p>One design I've considered is making my own <code>Publisher</code>. For example, instead of having <code>WebSocketInteraction</code> vend a <code>PassthroughSubject</code>, it could conform to <code>Publisher</code>. I may end up going this way, but making a custom Combine <code>Publisher</code> is more work, and the documentation steers people toward using a subject instead. To make a custom Publisher you have to implement some of things that the <code>PassthroughSubject</code> does for you, like respond to demand and cancellation, and keep state to ensure you complete at most once and don't send events after that.</p>
<p>[Edit: to clarify that <code>WebSocketInteraction</code> is my own class.]</p>
","327572","","327572","","2020-06-21 15:08:58","2020-06-22 04:05:19","In a Combine Publisher chain, how to keep inner objects alive until cancel or complete?","<swift><combine>","1","7","","","","CC BY-SA 4.0"
"62521797","1","","","2020-06-22 19:10:03","","1","144","<p>In the following code sub1 and sub2 subscribe to the shared increment publisher one after another and then both cancel. Later sub3 subscribes to the publisher but it now receives no values at all. How could I add a timeout so that sub3 will receive values so long as it subscribes before the timeout expires?</p>
<pre><code>import Combine
import Foundation
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

let everySecPublisher = Timer.TimerPublisher(interval: 1.0, runLoop: .main, mode: .default).autoconnect()
let incrementPublisher = everySecPublisher.scan(0, {x, _ in x + 1})
let shared = incrementPublisher.share()


let sub1 = shared.sink(receiveValue: { value in print(&quot;1:\(value)&quot;) })
RunLoop.main.run(until: Date(timeIntervalSinceNow: 2))


let sub2 = shared.sink(receiveValue: {value in print(&quot;2:\(value)&quot;) })
RunLoop.main.run(until: Date(timeIntervalSinceNow: 2))


sub1.cancel()
sub2.cancel()
let sub3 = shared.sink(receiveValue: {value in print(&quot;3:\(value)&quot;) })
RunLoop.main.run(until: Date(timeIntervalSinceNow: 2))

print(&quot;finished&quot;)
</code></pre>
<p>output</p>
<pre><code>1:1
1:2
1:3
2:3
1:4
2:4
finished
</code></pre>
","162337","","","","","2020-06-23 21:36:21","Timeout on shared() operator","<swift><combine>","0","10","","","","CC BY-SA 4.0"
"62526745","1","62526823","","2020-06-23 03:17:40","","4","3411","<p>I want to return the publisher for a function if there is error in input params for it but its giving some compilation error.</p>
<p>Below is the function for the same.</p>
<pre><code>func fetchList(input: String) -&gt; AnyPublisher&lt;List, Error&gt; {
    guard let url = URL(string: input)  else {            
        return AnyPublisher(URLError(.cannotParseResponse))
    }
    //some call for to get the List which returns publisher
}
</code></pre>
<p><strong>Error</strong></p>
<p><code>Cannot invoke initializer for type 'AnyPublisher&lt;_, _&gt;' with an argument list of type '(URLError)'</code></p>
<p><strong>Summary</strong></p>
<p>How to create our publisher to return the error?</p>
<p>Thanks for any hint in the right direction.</p>
","248014","","3641812","","2021-06-24 16:13:13","2021-06-24 16:13:13","Swift Combine return Publisher from func","<swift><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"62585953","1","62586157","","2020-06-25 23:48:10","","3","352","<p>I've got an @EnvironmentObject that's updated in a worker thread, and several SwiftUI views subscribe to changes to the published values.</p>
<p>This all works quite nicely.</p>
<p>But I'm struggling to get a UIView to subscribe to changes in the @EnvironmentObject.</p>
<p>Given</p>
<pre><code>@EnvironmentObject var settings: Settings 

where Settings is:

final class Settings {
    @Published var bar: Int = 0
    @Published var beat: Int = 1
    etc.
}

</code></pre>
<p>SwiftUI views update based on published value changes rather nicely.</p>
<p>But now, I want to declare a sink that receives the published values inside a UIView that conforms to UIViewRepresentable.</p>
<p>I've been working through the Combine book, and thought that I could declare a .sink closure with something like:</p>
<pre><code>   func subscribeToBeatChanges() {
        settings.$bar
            .sink(receiveValue: {
                bar in
                self.bar = bar
                print(&quot;Bar = \(bar)&quot;)
            } )
        settings.$beat
            .sink(receiveValue: {
                beat in
                self.beat = beat
                print(&quot;Beat = \(beat)&quot;)
                self.setNeedsDisplay()
            } )
    }
 
</code></pre>
<p>Unfortunately, the closure is only called once, when subscribeToBeatChanges() is called. What I want is for the closure to be called every time a @Published property in the @EnvironmentObject value changes.</p>
<p>I've also tried to subscribe inside the UIViewRepresentable wrapper, with something inside the makeUIView method, but was unsuccessful.</p>
<p>I'm obviously doing some rather simple and fundamental wrong, and would sure appreciate a push in the right direction, because I'm getting cross-eyed trying to puzzle this out!</p>
<p>Thanks!</p>
","4277085","","","","","2020-06-26 19:02:18","UIView as a subscriber to @EnvironmentObject","<ios><swift><swiftui><publish-subscribe><combine>","1","0","","","","CC BY-SA 4.0"
"62588595","1","","","2020-06-26 05:33:25","","1","609","<p>I writing a Bluetooth LE library using combine, that I'd like to release on Github. This is my first project using combine and I'm a tittle bit overwhelmed by the syntax, because sometimes is a little bit ugly.<br>
In these case I'm trying to add and optional timeout parameter to a function that makes a scan looking for peripheral nearby. Since it is optional the only way I've found to create a chain like this one (see the <code>flatMap</code>), but is really ugly. Is there any suggestion to improve it?<br></p>
<pre><code>    /// Starts scanning for `PeripheralDiscovery`
    /// - parameter services: Services for peripheral you are looking for
    /// - parameter options: Scanning options same as  CoreBluetooth  central manager option.
    /// - parameter timeout: An optional timeout, when triggered send and error `.scanTimeout`
    /// - returns: A publisher with stream of disovered peripherals.
    public func startDiscovery(withServices services: [CBUUID]?, options: [String : Any]? = nil, timeout: TimeInterval? = nil) -&gt; AnyPublisher&lt;PeripheralDiscovery, LittleBluetoothError&gt; {
        let scan = ensureBluetoothState()
        .flatMap {_ -&gt; AnyPublisher&lt;Void, LittleBluetoothError&gt; in
                let just = Just(()).setFailureType(to: LittleBluetoothError.self)
                if let time = timeout {
                    return just.timeout(RunLoop.SchedulerTimeType.Stride(time), scheduler: RunLoop.current, customError: {.scanTimeout}).eraseToAnyPublisher()
                } else {
                    return just.eraseToAnyPublisher()
                }
        }
        .map { (_) -&gt; Void in
            self.cbCentral.scanForPeripherals(withServices: services, options: options)
        }
        .flatMap {
            self.centralProxy.centralDiscoveriesPublisher.setFailureType(to: LittleBluetoothError.self)
        }
        .eraseToAnyPublisher()
        return scan
    }
</code></pre>
","395897","","","","","2020-06-26 05:33:25","Combine timeout chaining","<ios><swift><xcode><core-bluetooth><combine>","0","5","","","","CC BY-SA 4.0"
"62600312","1","62600640","","2020-06-26 17:53:02","","0","142","<p>I've built this small demo view where I have two <code>NoteRow</code>s and my goal is to be able to press the return key to create a new row and for it to become the first responder. <strong>This works, however, the first time around, the new row is created but it doesn't become the first responder.</strong> Subsequent taps of the return key both create the row and become first responder.</p>
<p>Any ideas what's going wrong here? Thanks!</p>
<pre><code>import SwiftUI
import Combine

struct FirstResponderDemo: View {
    
    @State private var rows: [NoteRow] = [
        .init(parentNoteId: &quot;1&quot;, text: &quot;foo&quot;),
        .init(parentNoteId: &quot;1&quot;, text: &quot;bar&quot;),
    ]
    
    @State private var activeRowId: String?
    
    var body: some View {
        ScrollViewReader { proxy in
            ScrollView {
                VStack {
                    ForEach(rows, id: \.id) { row in
                        ResponderTextView(
                            row: row,
                            text: $login,
                            activeRowId: $activeRowId,
                            returnPressed: returnPressed
                        )
                        .frame(width: 300, height: 44)
                    }
                }.padding(.horizontal, 12)
            }
        }
        .onAppear {
            self.activeRowId = rows[0].id
        }
    }
    
    private func returnPressed() {
        guard let id = activeRowId else { return }
        
        let newRow = NoteRow(parentNoteId: &quot;1&quot;, text: &quot;&quot;)
        print(&quot;new row id&quot;, newRow.id)
        
        if let index = rows.firstIndex(where: { $0.id == id }) {
            rows.insert(newRow, at: index + 1)
            activeRowId = newRow.id
        }
    }
}

struct FirstResponderDemo_Previews: PreviewProvider {
    static var previews: some View {
        FirstResponderDemo()
    }
}


struct ResponderView&lt;View: UIView&gt;: UIViewRepresentable {
    
    let row: NoteRow
    
    @Binding var activeRowId: String?
    
    var configuration = { (view: View) in }

    func makeUIView(context: Context) -&gt; View { View() }

    func makeCoordinator() -&gt; Coordinator {
        Coordinator(row: row, activeRowId: $activeRowId)
    }

    func updateUIView(_ uiView: View, context: Context) {
        context.coordinator.view = uiView
        
//        print(activeRowId)
        _ = activeRowId == row.id ? uiView.becomeFirstResponder() : uiView.resignFirstResponder()
        
        configuration(uiView)
    }
}

// MARK: - Coordinator

extension ResponderView {
    
    final class Coordinator {
    
        @Binding private var activeRowId: String?
        
        private var anyCancellable: AnyCancellable?
        
        fileprivate weak var view: UIView?

        init(row: NoteRow, activeRowId: Binding&lt;String?&gt;) {
            _activeRowId = activeRowId
            
            self.anyCancellable = Publishers.keyboardHeight.sink(receiveValue: { [weak self] keyboardHeight in
                guard let view = self?.view, let self = self else { return }
                
                DispatchQueue.main.async {
                    if view.isFirstResponder {
                        self.activeRowId = row.id
                        print(&quot;active row id is:&quot;, self.activeRowId)
                    }
                }
            })
        }
    }
    
}

// MARK: - keyboardHeight

extension Publishers {
    
    static var keyboardHeight: AnyPublisher&lt;CGFloat, Never&gt; {
        let willShow = NotificationCenter.default.publisher(for: UIApplication.keyboardWillShowNotification)
            .map { ($0.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect)?.height ?? 0 }

        let willHide = NotificationCenter.default.publisher(for: UIApplication.keyboardWillHideNotification)
            .map { _ in CGFloat(0) }

        return MergeMany(willShow, willHide)
            .eraseToAnyPublisher()
    }
    
}

struct ResponderView_Previews: PreviewProvider {
    static var previews: some View {
        ResponderView&lt;UITextView&gt;.init(row: .init(parentNoteId: &quot;1&quot;, text: &quot;Hello world&quot;), activeRowId: .constant(nil)) { _ in
        }.previewLayout(.fixed(width: 300, height: 40))
    }
}

struct ResponderTextView: View {
    
    let row: NoteRow
    
    @State var text: String
    
    @Binding var activeRowId: String?
    
    private var textViewDelegate: TextViewDelegate

    init(row: NoteRow, text: Binding&lt;String&gt;, activeRowId: Binding&lt;String?&gt;, returnPressed: @escaping () -&gt; Void) {
        self.row = row
        self._text = State(initialValue: row.text)
        self._activeRowId = activeRowId
        self.textViewDelegate = TextViewDelegate(text: text, returnPressed: returnPressed)
    }

    var body: some View {
        ResponderView&lt;UITextView&gt;(row: row, activeRowId: $activeRowId) {
            $0.text = self.text
            $0.delegate = self.textViewDelegate
        }
    }
}

// MARK: - TextFieldDelegate

private extension ResponderTextView {
    
    final class TextViewDelegate: NSObject, UITextViewDelegate {
        
        @Binding private(set) var text: String
        
        let returnPressed: () -&gt; Void

        init(text: Binding&lt;String&gt;, returnPressed: @escaping () -&gt; Void) {
            _text = text
            self.returnPressed = returnPressed
        }
        
        func textViewDidChange(_ textView: UITextView) {
            DispatchQueue.main.async {
               self.text = textView.text
            }
        }
        
        func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -&gt; Bool {
            if (text == &quot;\n&quot;) {
                returnPressed()
                return false
            }
            
            return true
        }
    }

}
</code></pre>
<p>And the definition of <code>NoteRow</code>:</p>
<pre><code>final class NoteRow: ObservableObject, Identifiable {
    
    let id: String = UUID().uuidString
    
    let parentNoteId: String

    let text: String
   
    init(parentNoteId: String, text: String) {
        self.parentNoteId = parentNoteId
        self.text = text
    }
 
}

extension NoteRow: Equatable {
    
    static func == (lhs: NoteRow, rhs: NoteRow) -&gt; Bool {
        lhs.id == rhs.id &amp;&amp;
        lhs.parentNoteId  == rhs.parentNoteId
    }
    
}
</code></pre>
<p><strong>Edit:</strong> Debugging this more</p>
<p>active row id is: Optional(&quot;71D8839A-D046-4DC5-8E02-F124779309E6&quot;) // first default row
active row id is: Optional(&quot;5937B1D0-CBB0-4BE4-A235-4D57835D7B0F&quot;) // second default row</p>
<p>// I hit return key:
new row id F640D1F9-0708-4099-BDA4-2682AF82E3BD
active row id is: Optional(&quot;5937B1D0-CBB0-4BE4-A235-4D57835D7B0F&quot;) <strong>// ID for 2nd row is set as active for some reason</strong></p>
<p>// After that, new row id and active row ID follow the expected path:</p>
<p>new row id 9FDEB548-E19F-4572-BAD3-00E6CBB951D1
active row id is: Optional(&quot;9FDEB548-E19F-4572-BAD3-00E6CBB951D1&quot;)</p>
<p>new row id 4B5C1AA3-15A1-4449-B1A2-9D834013496A
active row id is: Optional(&quot;4B5C1AA3-15A1-4449-B1A2-9D834013496A&quot;)</p>
<p>new row id 22A61BE8-1BAD-4209-B46B-15666FF82D9B
active row id is: Optional(&quot;22A61BE8-1BAD-4209-B46B-15666FF82D9B&quot;)</p>
<p>new row id 95DD6B33-4421-4A32-8478-DCCBCBB1824E
active row id is: Optional(&quot;95DD6B33-4421-4A32-8478-DCCBCBB1824E&quot;)</p>
","602210","","602210","","2020-06-26 18:15:35","2020-06-26 18:15:38","SwiftUI: Custom UITextView UIViewRepresentable requires double tap on the first action to work, works fine with single taps thereafter","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62603020","1","","","2020-06-26 21:23:23","","0","113","<p>I'm trying to create a simple list view of <code>People</code> witch a search bar on top.</p>
<p>I got the UI laid down but editing the search bar doesn't call the <code>didSet</code> function of <code>@State var searchText: String</code>.</p>
<p>I believe I may have misunderstood how <code>@State</code> and <code>Binding</code>s work? Seems like binding the <code>viewModel.$searchText</code> in the <code>SearchBar</code> never causes the <code>@State var searchText</code> to update.</p>
<p>What is wrong?</p>
<pre><code>struct ListView: View {
    @Environment(\.managedObjectContext) var context: NSManagedObjectContext
    
    @ObservedObject var viewModel: PeopleListViewModel
    
    var body: some View {
        VStack {
            SearchBar(text: viewModel.$searchText, showsCancelButton: .constant(false))
                .padding(Edge.Set(arrayLiteral: .top, .bottom), 0)
                .padding(Edge.Set(arrayLiteral: .leading, .trailing), 8)
            List(viewModel.people, id: \.id) { (person) in
                PersonCell(person: person)
            }
        }
    }
}

extension ListView {
    final class PeopleListViewModel: NSObject, NSFetchedResultsControllerDelegate, ObservableObject {
        private let peopleController: NSFetchedResultsController&lt;Person&gt;
        private let sortDescriptors = [NSSortDescriptor(keyPath: \Person.name, ascending: true)]
        
        @State var searchText: String = &quot;&quot; {
            didSet {
                updatePeople() // Never gets called! Maybe this shouldn't be a @State, but passed to the ViewModel in a different way?
            }
        }

        init(managedObjectContext: NSManagedObjectContext) {
            peopleController = Person.resultsController(context: managedObjectContext, sortDescriptors: sortDescriptors)
            super.init()
            peopleController.delegate = self
            try? peopleController.performFetch()
        }
        
        func controllerWillChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
            objectWillChange.send()
        }
        
        var people: [Person] {
            return peopleController.fetchedObjects ?? []
        }
        
        func updatePeople() {
            var predicate: NSPredicate?
            
            if !searchText.isEmpty {
                predicate = NSPredicate(format: &quot;name CONTAINS[cd] %@&quot;, argumentArray: [searchText])
            }
            
            peopleController.fetchRequest.predicate = predicate
            try? peopleController.performFetch()
        }
    }
}

extension Person {
    static func resultsController(context: NSManagedObjectContext, sortDescriptors: [NSSortDescriptor] = []) -&gt; NSFetchedResultsController&lt;Person&gt; {
        let request = NSFetchRequest&lt;Person&gt;(entityName: &quot;Person&quot;)
        request.sortDescriptors = sortDescriptors.isEmpty ? nil : sortDescriptors
        return NSFetchedResultsController(fetchRequest: request, managedObjectContext: context, sectionNameKeyPath: nil, cacheName: nil)
    }
}
</code></pre>
","481983","","","","","2020-06-26 21:43:12","ObservableObject with NSPredicate and a SearchBar in SwiftUI","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"62615951","1","","","2020-06-27 21:53:03","","2","162","<p>What's the Combine's equivalent to <a href=""https://rxjs-dev.firebaseapp.com/api/operators/concatMap"" rel=""nofollow noreferrer"">concatMap</a>? I want to keep the order of downstream items to be the same as the original upstream items</p>
<pre><code>[1,2,3].publisher.flatMap { self.getItem($0) } // This does not guarantee [Item1, Item2, Item3]
</code></pre>
","3808183","","","","","2020-06-27 21:53:03","Swift Combine equivalent to concatMap","<swift><combine>","0","2","","2020-06-28 00:42:39","","CC BY-SA 4.0"
"62620683","1","","","2020-06-28 09:32:12","","0","156","<p>I am writing an app that pulls data from a website and displays it using SwiftUI.</p>
<p>My main view has an <code>@ObservedObject</code> which is of type <code>DataStore()</code>, and which is used in the view:</p>
<pre><code>struct ContentView: View {
    @ObservedObject var store = DataStore()
    
    var body: some View {
        List(store.zones) { zone in
...
</code></pre>
<p>The data model is defined as:</p>
<pre><code>class DataStore: ObservableObject {
    @Published var zones: [SonosZone] = []
        
    init() {
        getZones()
    }
    
    func getZones() {
        Api().getZones { (zones) in
            self.zones = zones
        }
    }
}
</code></pre>
<p>I want to call <code>getZones()</code> every 30 seconds. How do I do this?</p>
<p>I'm guessing that I use code like this somewhere, but I don't know where to put it, or how to call the function in the closure:</p>
<pre><code>        _ = Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { _ in
            getZones()
        }
</code></pre>
","9057425","","","","","2020-06-28 09:40:28","Using @observable in Swift, I want to periodically refresh the ObservedObject using a timer. How do I do this?","<swift><swiftui><combine><observedobject>","1","0","","","","CC BY-SA 4.0"
"62627660","1","62627882","","2020-06-28 20:04:43","","1","623","<p>It is possible to receive progress updates about a <code>URLSessionTask</code> by implementing the <code>URLSessionDataDelegate.urlSession(_:dataTask:didReceive:)</code> delegate method, and using the delegate-style &quot;task, task.resume()&quot; style of invocation.</p>
<p>With the Combine flavor of the API, this does not appear to be possible. Using <code>URLSession.dataTaskPublisher(for:)</code> returns a publisher that publishes the <code>(Data, URLResponse)</code> tuple upon completion, but never invokes the delegate method. In that way, it is very similar to the <code>URLSession.dataTask(with:completionHandler:)</code> method, which invokes <code>completionHandler</code> with the final result, and not in-process <code>Progress</code> reports.</p>
<p>Am I missing any API or pattern to allow progress reporting, or does the Combine flavor of URLSession task handling not offer a way to retrieve progress?</p>
","603369","","","","","2020-06-28 20:29:19","Receive task progress from `URLSession.dataTaskPublisher`","<ios><nsurlsession><combine>","1","0","1","","","CC BY-SA 4.0"
"62633728","1","62633945","","2020-06-29 08:07:02","","26","13666","<p>I think this error message is new to SwiftUI in Xcode 12 since it gave 0 hits in Google while the message itself is fairly generic:</p>
<blockquote>
<p>Accessing State's value outside of being installed on a View. This will result in a constant Binding of the initial value and will not update.</p>
</blockquote>
<p>I have the following code (removed some fluff):</p>
<pre class=""lang-swift prettyprint-override""><code>public struct ContentView: View {
    @ObservedObject var model: RootViewModel

    public var body: some View {
        VStack(alignment: .center, content: {
            Picker(selection: model.$amount, label: Text(&quot;Amount&quot;)) {
                Text(&quot;€1&quot;).tag(1)
                Text(&quot;€2&quot;).tag(2)
                Text(&quot;€5&quot;).tag(5)
                Text(&quot;€10&quot;).tag(10)
            }.pickerStyle(SegmentedPickerStyle())
            Text(&quot;Donating: €\(model.amount)&quot;).font(.largeTitle)
        }).padding(.all, 20.0)
    }
}

public class RootViewModel: ObservableObject {
    @State public var amount: Int = 1
}
</code></pre>
<p>I used to have the <code>field</code> right in the <code>ContentView</code> and that worked alright. Now the UI does not update anymore and I got that run-time warning instead.</p>
","2804585","","1033581","","2020-06-30 06:23:40","2022-04-08 17:12:15","Accessing ViewModel field in SwiftUI using Xcode 12: ""Accessing State's value outside of being installed on a View""","<swift><swiftui><combine><xcode12>","2","1","6","","","CC BY-SA 4.0"
"62639120","1","65395653","","2020-06-29 13:24:01","","3","1465","<p>I am trying to build a prototype app to evaluate the usage of AWS-Amplify (DataStore) in our next App. I am facing an issue when trying to sync 2 Clients. I set up my AWS-DataStore as explained by the tutorial here: <a href=""https://docs.amplify.aws/lib/datastore/getting-started/q/platform/ios"" rel=""nofollow noreferrer"">https://docs.amplify.aws/lib/datastore/getting-started/q/platform/ios</a> by using Cocoapods. Regarding Cocoapods everything is working as expected. I tried some testing which can also be seen under the link above with &quot;manipulating data&quot;. I also did the &quot;syncing data to cloud&quot; section. I can see my data in dynamoDB in the AWS console. When I am adding an entry I can see it in the console everything is working as expected but i have a problem in two scenarios:</p>
<p>Let's say i have 2 clients A and B (both running iOS 13 - it doesn't matter here if it is a real device or on simulator) and I want to these clients to stay in sync. For this purpose I added a PostStore (I am using the example schema from the AWS-link above atm) which looks like this:</p>
<pre><code>import Foundation
import Combine
import SwiftUI
import Amplify

class PostStore: ObservableObject {
    
    @Published private(set) var posts: [Post] = []
    
    var postSubscription: AnyCancellable?
    
    init() {
        self.getAllPostsFromDataStore()
    }
    
    deinit {
        self.unsubscribeFromDataStore()
    }
    
    func getAllPostsFromDataStore() {
        
        Amplify.DataStore.query(Post.self) { (result) in
            switch result {
            case .success(let posts):
                DispatchQueue.main.async {
                    print(&quot;Got \(posts.count) Posts from DataStore initially&quot;)
                    self.posts = posts
                }
            case .failure(let error):
                print(&quot;Error getting Posts from DataStore: \(error.localizedDescription)&quot;)
            }
        }
    }
    
    func addRandomPostToDataStore() {
        
        let post = Post.getRandomPost()
        self.addPostToArray(post)
        
        print(&quot;Fire: \(post.id)&quot;)
        
        Amplify.DataStore.save(post) {
            
            switch $0 {
            case .success(let post):
                print(&quot;Added post with id: \(post.id)&quot;)
            case .failure(let error):
                print(&quot;Error adding post with title: \(post.title) Error: \(error.localizedDescription)&quot;)
            }
        }
    }
    
    func deletePostFromDataStore(for indexSet: IndexSet) {
        
        let postsToDelete = indexSet.map { self.posts[$0] }
        
        self.posts.remove(atOffsets: indexSet)
        
        for post in postsToDelete {
            
            Amplify.DataStore.delete(post) { (result) in
                switch result {
                case .success():
                    print(&quot;Deleted Post from DataStore&quot;)
                case .failure(let error):
                    print(&quot;Error deleting Post From DataStore: \(error)&quot;)
                }
            }
        }
    }
        
    func subscribeToDataStore() {
        
        postSubscription = Amplify.DataStore.publisher(for: Post.self)
            .sink(receiveCompletion: { (completion) in

                print(&quot;Completion!&quot;)

                if case .failure(let error) = completion {
                    print(&quot;Subscription received Error: \(error.localizedDescription)&quot;)
                }

            }, receiveValue: { (changes) in
                
                
                //print(&quot;Subscription received mutation: \(changes)&quot;)
                print(&quot;\n\n\n&quot;)
                print(&quot;\(try! changes.toJSON())&quot;)
                print(&quot;\n\n\n&quot;)
//                print(&quot;Changes!&quot;)
                let newPost = try! changes.decodeModel(as: Post.self)

                DispatchQueue.main.async {

                    switch changes.mutationType {
                    case &quot;create&quot;:
//                        print(&quot;Create Subscription&quot;)
                        self.addPostToArray(newPost)
                        break
                    case &quot;update&quot;:
                        print(&quot;Update Subscription&quot;)
                        self.updatePostInArray(newPost)
                        break
                    case &quot;delete&quot;:
                        print(&quot;Delete Subscription&quot;)
                        self.deletePostFromArray(newPost)
                        break
                    default:
                        print(&quot;AnotherType?&quot;)
                        print(changes.mutationType)
                        break
                    }
                }
                print(&quot;\n&quot;)
            })
    }
    
    func unsubscribeFromDataStore() {
        postSubscription?.cancel()
    }
    
    private func addPostToArray(_ post: Post) {
        
        if !self.posts.contains(post) {
            self.posts.append(post)
        }
    }
    
    private func deletePostFromArray(_ post: Post) {
        
        if let index = self.posts.firstIndex(of: post) {
            self.posts.remove(at: index)
        }
    }
    
    private func updatePostInArray(_ post: Post) {
        print(&quot;update?&quot;)
    }
}
</code></pre>
<p>The <code>subscribeToDataStore</code> method is triggered via the SwiftUI-View (in <code>onAppear</code>) and is the key thing in here. If I am adding some Posts with Client A (slowly) then Client B receives every change and is adding it to the store (I visualized this with a SwiftUI View but that doesn't matter in this example). No Problems here everything is working as expected.</p>
<p>But</p>
<ol>
<li>When I am adding new entries (Posts) very fast with Client A then some of the new entries are not getting fetched by B.</li>
<li>When I am adding more than 1 entry while Client B is offline (in Flight Mode) and I turn Flight Mode off only the latest entry is fetched per subscription.</li>
</ol>
<p>In both cases when I trigger <code>getAllPostsFromDataStore</code> every single entry is fetched and we are good to go again.</p>
<p>So my question is: Why is the subscription not fetching every single entry?</p>
<p>There is an interesting fact when doing scenario 1: A common log message when receiving an entry per subscription looks like this:</p>
<pre><code>WebsocketDidReceiveMessage - {MyObject}
</code></pre>
<p>Then I am logging the object in the sink 'receiveValue' completion again:</p>
<pre><code>{MyObject}
</code></pre>
<p>But when adding a few entries fast (in a short time) the log message from Amplify sometimes looks like that: (And this is where the first &quot;Object&quot; is missing in the subscription fetch):</p>
<pre><code>WebsocketDidReceiveMessage - {MyObject}
WebsocketDidReceiveMessage - {MyObject2}
</code></pre>
<p>Then I am logging the object in the sink 'receiveValue' completion again and there is only the last object getting logged:</p>
<pre><code>{MyObject2}
</code></pre>
<p>Seems like that <code>{MyObject}</code> got cancelled or something when adding more than one entries fast. Like mentioned above, when B is in Flight Mode or has no connection only the last added entry is fetched. (But I also receive only the last log message for <code>WebsocketDidReceiveMessage</code>).</p>
<p>Am I missing a thing here or is this a bug in the Amplify-DataStore SDK?</p>
<p>Excuse my bad english please. I am not a native speaker and sometimes it is hard to tell exactly what is the problem. If you have any questions regarding this problem or need more information just comment and I will edit my question providing everything you need.</p>
<p>Best Regards</p>
","5650076","","","","","2020-12-21 15:39:48","AWS Amplify - sync DataStore","<ios><swift><swiftui><aws-amplify><combine>","1","0","1","","","CC BY-SA 4.0"
"62640585","1","","","2020-06-29 14:41:50","","0","217","<p>I created a SwiftUI-based, HUD class (based on <a href=""https://github.com/antranapp/SwiftyHUDView"" rel=""nofollow noreferrer"">SwiftyHUDView</a>):</p>
<pre class=""lang-swift prettyprint-override""><code>struct ActivityIndicatorView&lt;Content&gt;: View where Content: View {
    @Binding var isShowing: Bool
   
    var content: () -&gt; Content

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .center) {
                self.content()
                    .disabled(self.isShowing)
                    .blur(radius: self.isShowing ? 3 : 0)

                VStack {
                    Text(&quot;Loading...&quot;)
                    ActivityIndicator(isAnimating: .constant(true), style: .large)
                }
                .frame(width: geometry.size.width / 2,
                       height: geometry.size.height / 5)
                .background(Color.secondary.colorInvert())
                .foregroundColor(Color.primary)
                .cornerRadius(20)
                .opacity(self.isShowing ? 1 : 0)
            }
        }
    }
}
</code></pre>
<p>The first time I use this:</p>
<pre class=""lang-swift prettyprint-override""><code>@ObservedObject var serviceManager = ServiceManager()

ActivityIndicatorView(isShowing: .constant(serviceManager.loading)) {
            NavigationView {
                ZStack {
                    ...
                }
            }
        }.onAppear(perform: self.serviceFetch)

    private func serviceFetch() {
        serviceManager.loadSomeData()
    }
}

class ServiceManager: ObservableObject {
    @Published var someData: [String] = []
    @Published var loading = false
    
    init() {
        loading = true
    }

    public func loadSomeData() {
       go get some data ...

       self.loading = false
    }
}

</code></pre>
<p>The HUD class works fine, it disappears once the service call has returned data.</p>
<p>However, if I attempt to use the ActivityIndicatorView a second time in a different screen, the HUD screen stays up, even after the service call returns data and the @Published loading value is set to false.</p>
<p>My question is this.  Because I am using <em>ActivityIndicatorView</em> a second time, is the publish/observable link, ie. the <strong>loading</strong> property which is marked @Published is changed once the data is returned, the view that has the <em>ActivityIndicatorView</em> and @ObservedObject ServiceManager that should update its view and is not, somehow broken or do I have to initialize <em>ActivityIndicatorView</em> a certain way because it is used multiple times?</p>
","768419","","","","","2020-06-29 14:41:50","Using SwiftUI with a HUD","<swift><swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"62647224","1","62647285","","2020-06-29 21:51:35","","1","729","<p>Hi I am using SwiftUI and trying to create an ObservableObject for one of my views.</p>
<pre><code>class ResponseModelObject: ObservableObject {
    @Published var response = SongLinkAPIResponse()
}
</code></pre>
<p>The SongLinkAPIResponse looks like:</p>
<pre><code>public struct SongLinkAPIResponse: Codable, Equatable {
    public var entityUniqueId: String
    public var userCountry: String
    public var pageUrl: URL
    public var entitiesByUniqueId: [EntityUniqueId:Entity]
    public var linksByPlatform: [Platform.RawValue:PlatformInfo]
}
</code></pre>
<p>However my problem is that I am getting an error <code>Missing argument for parameter 'from' in call</code> on the @Published property. The from property is a Decoder but I have not defined an init for SongLinkAPIResponse so I am not sure what to do?</p>
<p>I'm sure I am missing something simple.</p>
","9682666","","","","","2020-06-29 22:00:27","Swift Custom Struct missing argument ""from: Decoder""","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62654278","1","62655093","","2020-06-30 09:25:35","","1","85","<p>I'm trying to understand Combine a little bit and have an issue and can't wrap my head around it:</p>
<p>I got this data-source</p>
<pre><code>class NoteManager: ObservableObject, Identifiable {
  @Published var notes: [Note] = []
  var cancellable: AnyCancellable?
  init() {
    cancellable = $notes.sink(receiveCompletion: { completion in
      print(&quot;receiveCompletion \(completion)&quot;)
    }, receiveValue: { notes in
      print(&quot;receiveValue \(notes)&quot;)
    })
  }
}
</code></pre>
<p>which is used here:</p>
<pre><code>struct ContentView: View {
  @State var noteManager: NoteManager
    
      var body: some View {
        
        VStack {
          NavigationView {
            VStack {
              List {
                ForEach(noteManager.notes) { note in
                  NoteCell(note: note)
                }
              }
...
</code></pre>
<p>And I can change the values here:</p>
<pre><code>    struct NoteCell: View {
      @State var note: Note
      
      var body: some View {
        NavigationLink(destination: TextField(&quot;title&quot;, text: $note.title)
...
</code></pre>
<p>Anyways - I'm not receiving the <code>receiveValue</code> event after changing the value (which is also correctly reflected in the ui). <code>receiveValue</code> is only called initially when setting it - is there some other way to receive an event for updated fields?</p>
<p>Add on:</p>
<pre><code>struct Note: Identifiable, Codable {
  var id = UUID()
  var title: String
  var information:  String
}
</code></pre>
","2906041","","2906041","","2020-06-30 09:36:50","2020-06-30 10:11:29","Not receiving event for updated @Published","<swift><swiftui><combine>","1","5","1","","","CC BY-SA 4.0"
"62677203","1","","","2020-07-01 12:47:05","","3","468","<p>I have simple View that is observing an object through the @ObservedObject property.
Something like this:</p>
<pre class=""lang-swift prettyprint-override""><code>struct BrowserView: View {
    @ObservedObject var fs: FileStore

    var body: some View {
        List(fs.files) { file in
            NavigationLink(destination: BrowserView(fs: self.fs) {
                FileRow(item: file)
            }
        }
        .onAppear(perform: loadFiles)
    }

    private func loadFiles() {
        fs.loadFiles()
    }
}
</code></pre>
<p>So what happens is that when a row is tapped I navigate to the next View which is still the same BrowserView using the same dataset (in the real code it's also passing other values as it's like a file browser andc the current path gets passed as an argument, too, but for the sake of the example it's really not relevant).</p>
<p>The problem is that when the next BrowserView appears, the dataset changes and those changes trigger an update of the previous View which is no longer visible and trying to update its UITableView is actually crashing the app.</p>
<p>Is there any way to tell a View to disable its bindings in onDisappear or something like that?
If not, what's the correct pattern when there's just a single model (storage) that is shared between different views?</p>
<p><strong>Update</strong></p>
<p>Here is the crashlog of what happens when the new view gets pushed onto the stack and the new data has been retrieved:</p>
<pre><code>Thread 1 Queue : com.apple.main-thread (serial)
#0  0x00000001b9a4643c in AG::Graph::import_attribute(AG::Subgraph*, AG::Graph&amp;, AG::attribute_t, AGTypeID, AG::ClosureFunctionVV&lt;void&gt;, AG::ClosureFunctionFV&lt;void, AG::ClosureFunctionVV&lt;void&gt; &gt;) ()
#1  0x00000001b9a4c76c in AGGraphImportAttribute ()
#2  0x00000001c52b8280 in ViewGraph.import&lt;A&gt;(_:as:from:) ()
#3  0x00000001c53a9a20 in static StyleType.makeViewList&lt;A&gt;(view:style:inputs:) ()
#4  0x00000001c53a9200 in static ResolvedList._makeViewList(view:inputs:) ()
#5  0x00000001c5203544 in closure #2 in static ModifiedContent&lt;&gt;._makeViewList(view:inputs:) ()
#6  0x00000001c51e723c in specialized static MultiViewModifier._makeViewList(modifier:inputs:body:) ()
#7  0x00000001c51e8274 in protocol witness for static ViewModifier._makeViewList(modifier:inputs:body:) in conformance ButtonActionModifier ()
#8  0x00000001c52020d8 in static ModifiedContent&lt;&gt;._makeViewList(view:inputs:) ()
#9  0x00000001c5203544 in closure #2 in static ModifiedContent&lt;&gt;._makeViewList(view:inputs:) ()
#10 0x00000001c51e81dc in static ViewModifier&lt;&gt;._makeViewList(modifier:inputs:body:) ()
#11 0x00000001c52020d8 in static ModifiedContent&lt;&gt;._makeViewList(view:inputs:) ()
#12 0x00000001c51795c0 in static View.makeViewList(view:inputs:) ()
#13 0x00000001c516b42c in static View._makeViewList(view:inputs:) ()
#14 0x00000001c542524c in AnyViewStorage.makeViewList(view:inputs:) ()
#15 0x00000001c54268a8 in closure #1 in AnyViewList.update(context:) ()
#16 0x00000001c5426648 in AnyViewList.update(context:) ()
#17 0x00000001c54289a0 in partial apply for protocol witness for static UntypedAttribute._update(_:graph:attribute:) in conformance AnyViewList ()
#18 0x00000001b9a3b88c in AG::Graph::UpdateStack::update() ()
#19 0x00000001b9a3bd48 in AG::Graph::update_attribute(unsigned int, bool) ()
#20 0x00000001b9a40cb0 in AG::Subgraph::update(unsigned int) ()
#21 0x00000001c52be0f4 in ViewGraph.runTransaction(in:) ()
#22 0x00000001c52bdea8 in closure #1 in ViewGraph.flushTransactions() ()
#23 0x00000001c52bdb20 in ViewGraph.flushTransactions() ()
#24 0x00000001c52bdc98 in closure #1 in closure #1 in ViewGraph.asyncTransaction&lt;A&gt;(_:mutation:style:) ()
#25 0x00000001c55759c0 in ViewRendererHost.updateViewGraph&lt;A&gt;(body:) ()
#26 0x00000001c52bdc60 in closure #1 in ViewGraph.asyncTransaction&lt;A&gt;(_:mutation:style:) ()
#27 0x00000001c52d9a30 in thunk for @escaping @callee_guaranteed () -&gt; () ()
#28 0x00000001c514ff64 in static NSRunLoop.flushObservers() ()
#29 0x00000001c514fed4 in closure #1 in static NSRunLoop.addObserver(_:) ()
#30 0x00000001c5150004 in @objc closure #1 in static NSRunLoop.addObserver(_:) ()
#31 0x000000018d7acee8 in __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ ()
#32 0x000000018d7a7b78 in __CFRunLoopDoObservers ()
#33 0x000000018d7a8018 in __CFRunLoopRun ()
#34 0x000000018d7a78f4 in CFRunLoopRunSpecific ()
#35 0x0000000197bbe604 in GSEventRunModal ()
#36 0x000000019197b358 in UIApplicationMain ()
</code></pre>
","443136","","443136","","2020-07-01 14:06:36","2020-07-01 14:06:36","SwiftUI View keeps updating even when no longer shown","<ios><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"62678977","1","62679430","","2020-07-01 14:21:20","","3","1972","<p>Normally, I would use an optional variable to hold my <code>Timer</code> reference, as it's nice to be able to <strong>invalidate</strong> and set it to <code>nil</code> before recreating.</p>
<p>I'm trying to use <code>SwiftUI</code> and want to make sure I'm correctly doing so...</p>
<p>I declare as:</p>
<pre><code>@State var timer:Publishers.Autoconnect&lt;Timer.TimerPublisher&gt;? = nil
</code></pre>
<p>Later I:</p>
<pre><code>self.timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
</code></pre>
<p>To drive a UI text control I use:</p>
<pre><code>.onReceive(timer) { time in
    print(&quot;The time is now \(time)&quot;)
}
</code></pre>
<p>What is the right way with this <code>Combine</code> typed <code>Timer</code> to invalidate and recreate?</p>
<p>I've read one should call:</p>
<p><code>self.timer.upstream.connect().cancel()</code></p>
<p>However, do I also need to <strong>invalidate</strong> or simply then <code>nil</code> out?</p>
","1784011","","4667835","","2020-07-01 14:44:25","2020-07-01 14:55:37","SwiftUI - Optional Timer, reset and recreate","<ios><swift><swiftui><nstimer><combine>","1","0","4","","","CC BY-SA 4.0"
"62679300","1","62683025","","2020-07-01 14:37:14","","0","1876","<p>I have a button that's connected to a <code>PassthroughSubject</code> that triggers a network load. The problem I'm having is that if the network request fails (or if pre-flight validation fails) the <code>PassthroughSubject</code> is completed:</p>
<pre class=""lang-swift prettyprint-override""><code>private let createListSubject = PassthroughSubject&lt;Void, Never&gt;()
</code></pre>
<p>When the button is tapped, I send a new event to this subject via <code>send(())</code>.</p>
<pre class=""lang-swift prettyprint-override""><code>// Later on, in some function I set up the subject
    private func setupCreateListSubject() {
        self.createListSubject
            .combineLatest(self.$listName, self.$selectedClients)
            .tryMap { [weak self] (_, listName, selectedClients) -&gt; (String, [String]) in
                let clients = Array(selectedClients)
                try self?.validate(listName: listName, selectedClients: clients)
                return (listName, clients)
            }
            .flatMap { [clientListCreator] (listName, selectedClients) -&gt; AnyPublisher&lt;Result&lt;ClientListMembersDisplayable, Error&gt;, Error&gt; in
                return clientListCreator.createClientList(listName: listName, listMemberIds: selectedClients)
            }
            .catch { error  in
                return Future&lt;Result&lt;ClientListMembersDisplayable, Error&gt;, Error&gt; { // &lt;-- One of the problems is that Future completes after 1 event
                    $0(.success(.failure(error)))
                }
            }
            .sink(receiveCompletion: { [weak self] completion in
                switch completion {
                case .failure(let error):
                    self?.errorAlertContext = AlertContext(title: error.localizedDescription)
                case .finished:
                    break
                }
            }, receiveValue: { [weak self] result in
                switch result {
                case .failure(let error):
                    self?.errorAlertContext = AlertContext(title: error.localizedDescription)
                case .success:
                    self?.errorAlertContext = nil
                }
            }).store(in: &amp;self.disposeBag)
    }
</code></pre>
<p>There are two problems:</p>
<ul>
<li>When validation fails in the <code>tryMap</code>, the <code>catch</code> is invoked</li>
<li>When the API call fails, the same as above happens.</li>
</ul>
<p>I can fix both of these problems with a <code>replaceError</code> but what I want is to transform the publisher's error into a success with a <code>Result</code> error <em>and</em> for the <code>createListSubject</code> to not receive any completion events (because the user will still want to tap that button in the future.</p>
<p>What's the Combine way to do this?
I think what I want is something similar to <code>replaceError()</code> but that received the old error and returns a successful result.</p>
","1027644","","","","","2020-07-01 20:33:01","Swift Combine completing button tap","<ios><swift><swiftui><reactive><combine>","2","0","","","","CC BY-SA 4.0"
"62693605","1","","","2020-07-02 09:52:22","","1","2741","<p>So, from what I could gather, on Alamofire with Combine we can now do this:</p>
<p><code>AF.request(...).publishDecodable(type: DecodableType.self)</code></p>
<p>which, if we want to map the error to a custom type other than AFError, means we'll end up with a method like this:</p>
<pre class=""lang-swift prettyprint-override""><code>enum DifferentError: Error {
    case alamofire(wrapped: AFError)
    case malformedURL

func requestSomeStuff(url: String) -&gt; AnyPublisher&lt;DecodableType, DifferentError&gt; {
    
    guard self.validateUrl(url) else {
        return Fail(error: DifferentError.malformedURL).eraseToAnyPublisher()
    }

    return AF.request(...)
             .publishDecodable(type: DecodableType.self)
             .value()
             .mapError { DifferentError.alamofire(wrapped: $0) }
             .eraseToAnyPublisher()
}
</code></pre>
<p>That <code>Fail</code> publisher doesn't seem right to me; Am I missing something here, or is this the correct way of doing it?</p>
<p>Should this be returning a <code>Future</code> instead and can that <code>publishDecodable</code> be mapped into a <code>Future</code>?</p>
","1108199","","1108199","","2020-07-02 13:50:18","2020-07-02 15:23:19","Alamofire + Combine publishDecodable to Future","<swift><alamofire><combine>","1","5","","","","CC BY-SA 4.0"
"62705576","1","","","2020-07-02 21:53:42","","0","489","<p>I'm learning swift and combine framework.</p>
<p>I have a text field (<em>textField</em>) and a button (<em>button</em>).</p>
<p>Using combine framework i make sth when <em>UITextField.textDidChangeNotification</em> appear in <em>NotificationCenter</em>.</p>
<pre><code>let publisher = NotificationCenter.default.publisher(for:
   UITextField.textDidChangeNotification, object: self.textField)
//more code
</code></pre>
<p>...and everything works fine.</p>
<p><strong>I added a functionality to button - when clicked it should change text in the textField, and i can see that text has been changed, but nothing  happen, like if there is no <em>textDidChangeNotification</em></strong></p>
<p>How can i force to send UITextField.textDidChangeNotification? When i changed text with other fucntion/button there is no textDidChangeNotification (text was not changed by a user =&gt; there was no textDidChangeNotification).</p>
","8040928","","8040928","","2020-07-02 23:19:14","2020-07-03 07:24:50","How can i send textDidChangeNotification to NotificationCenter?","<swift><swift3><combine>","2","0","","","","CC BY-SA 4.0"
"62736445","1","","","2020-07-05 03:12:41","","1","1828","<p>In RxSwift I can ignore errors like
<code>.catchError { _ in Observable.never() }</code></p>
<p>Why does this not work in combine (eg. it still completes)
<code>.catch { _ in Empty(completeImmediately: false) }</code></p>
<pre><code>struct SimpleError: Error {}
let numbers = [5, 4, 3, 2, 1, 0, 9, 8, 7, 6]
let cancellable = numbers.publisher
    .tryFilter { int -&gt; Bool in
        guard int != 0 else {throw SimpleError()}
        return true
    }
    .catch { _ in Empty(completeImmediately: false) }
    .sink {
        print(&quot;\($0)&quot;)
    }
</code></pre>
<p>finishes on the throw. The output is:</p>
<pre><code>5
4
3
2
1
</code></pre>
","5528004","","5528004","","2020-07-05 05:23:15","2021-03-16 18:55:38","Ignoring errors in Combine","<ios><swift><rx-swift><combine>","2","10","","","","CC BY-SA 4.0"
"62738611","1","62739489","","2020-07-05 08:44:55","","0","1126","<p>iOS 13, Swift 5.x</p>
<p>I am trying to get the syntax right on a combine subscription/publisher. I got a working example and I have tried to copy it, but I missing something; and I cannot see the wood for the trees. Here is my code.</p>
<pre><code>import Foundation
import Combine

class SwiftUIViewCModel: ObservableObject {
  @Published var state : SwiftUIViewCModelState = .page1

  static let shared = SwiftUIViewCModel()

  private var stateUpdatingSubscriber: AnyCancellable?

  init() {
    self.stateUpdatingSubscriber = nil
    self.stateUpdatingSubscriber = SwiftUIViewCModel.shared.$state
      .map(modelCTomodelD(modelState:))
      .receive(on: RunLoop.main)
      .assign(to: \.state, on: self)
  

  }

 private func modelCTomodelD(modelState: SwiftUIViewCModelState) -&gt; SwiftUIViewEModelState {
    switch modelState {
      case .page1:
      return .page1
    case .page2:
      return .page2
    default:
      break
 }
}

}

enum SwiftUIViewEModelState {
 case page1
 case page2
}

enum SwiftUIViewCModelState {
 case page1
 case page2
}
</code></pre>
<p>I am getting a syntax error on the compile, but I don't understand what exactly I need to do to fix it.</p>
<p>Cannot convert value of type '(SwiftUIViewCModelState) -&gt; SwiftUIViewEModelState' to expected argument type 'KeyPath&lt;Published.Publisher.Output, SwiftUIViewCModelState&gt;' (aka 'KeyPath&lt;SwiftUIViewCModelState, SwiftUIViewCModelState&gt;')</p>
<p>How do I get the format it needs here into this code?</p>
<p>Thanks</p>
","3069232","","","","","2020-07-05 10:27:44","Setting up a combine publisher in swift using map","<swift><dictionary><subscription><assign><combine>","1","0","","","","CC BY-SA 4.0"
"62745755","1","","","2020-07-05 20:04:09","","3","789","<p>I'm trying to find a simple way to use CoreData with combine.</p>
<p>In short, I've been using combine really successfully with plain old Swift objects that are <code>ObservableObjects</code>. I can build pipelines off <code>@Published</code> properties, and I can do all the swift-y and combine-y things with them.</p>
<p>Now I want to do the same with CoreData objects.</p>
<p>I've run into the following:</p>
<ol>
<li><code>@NSManaged</code> properties cannot be declared <code>@Published</code>. That's a bummer.</li>
<li>I read about <code>ObjectWillChange</code> publisher on <code>NSManagedObject</code> but I can't find an example that's meaningful - all examples I can find do a <code>.sink { print }</code>. I wanted to be able to discover what property changed, whether it changed in the background (due to an iCloud sync) or due to a user interaction, etc.</li>
<li>I read about a technique which replaces all <code>@NSManaged</code> properties with Swift properties and then being able to leverage property observers - <code>didSet</code> and <code>didGet</code>. This doesn't seem great as it's not scalable (changing every object by hand ...). It also seems like a hack and I'm afraid of places where it would fall over. Furthermore, it doesn't seem like you can use <code>@Published</code> in this way. So I would potentially need to have this core data property handle <code>didSet</code> and write to another property that is <code>@Published</code> for the sole purpose of using combine ... seems like a hack.</li>
<li>I can do the old school <code>NSNotificationCenter</code> but that just seems unswift-y and uncombine-y.</li>
</ol>
<p>Has anyone gotten this to work in the way that it probably should work - that is, combine on CoreData objects is as natural as it is on plain old swift objects?</p>
","1708376","","","","","2020-07-05 20:04:09","Using CoreData with Combine","<swift><core-data><combine>","0","1","","","","CC BY-SA 4.0"
"62756051","1","62756153","","2020-07-06 12:25:04","","1","499","<p>Swift 5, iOS 13</p>
<p>I want to use passthroughSubject publisher; but I my gut tells me its a global variable and as such very poor practice. How can make this global variable less global, while still being usable. Here's some code to show what I talking about.</p>
<p>I know there are a dozen other ways to do this, but I wanted to create some simple code to illustrate the issue.</p>
<pre><code>import SwiftUI
import Combine

let switcher = PassthroughSubject&lt;Void,Never&gt;()

struct SwiftUIViewF: View {
@State var nextPage = false
var body: some View {

  VStack {
    Text(&quot;Switcher&quot;)
    .onReceive(switcher) { (_) in
      self.nextPage.toggle()
    }
    if nextPage {
      Page1ViewF()
    } else {
      Page2ViewF()
    }
  }

 }
}

struct Page1ViewF: View {
  var body: some View {
    Text(&quot;Page 1&quot;)
    .onTapGesture {
        switcher.send()
    }
  }
}

struct Page2ViewF: View {
  var body: some View {
    Text(&quot;Page 2&quot;)
    .onTapGesture {
      switcher.send()
    }
  }
}

struct SwiftUIViewF_Previews: PreviewProvider {
  static var previews: some View {
    SwiftUIViewF()
  }
}
</code></pre>
","3069232","","","","","2020-07-17 05:44:58","Making a combine passthrough publisher less global","<ios><swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"62764954","1","62765016","","2020-07-06 21:41:00","","-1","531","<p>I have a list of objects.</p>
<pre><code>let arr = [[1, 2, 3, 4, 5]]
</code></pre>
<p>It lives in a repository.</p>
<pre><code>class ArrayRepository: ObservableObject { 
     @Published let arr = [1,2,3,4,5]
} 
</code></pre>
<p>I have a class with a property that needs it assigned at initialization.</p>
<pre><code>class MyClass: ObservableObject { 
    var id: String = &quot;&quot;
    var myProperty: Int? 
}
</code></pre>
<p>My class is created through an asynchronous process that is itself a repository.</p>
<pre><code>class myClassRepository { 
   
    func buildClass -&gt; MyClass { 
        myClassInstance = MyClass()
        self.arrayRepository.$arr.map { arr in 
            arr.filter{ $0 == someOther.Value }
        }.assign(to: \.myProperty, on: myClassInstance).store(in: &amp;subscriptions)
       return myClassInstance
    }
} 
</code></pre>
<p>The problem is my pattern returns an array of elements that I cant make conform to to the singular property on the class? Whats the best way to get it out?</p>
<p>The error I get is essentially</p>
<pre><code>Declared closure result '[Int]' is incompatible with contextual type 'Int??'
</code></pre>
","4397682","","4397682","","2020-07-06 21:55:27","2020-07-06 21:55:27","Swift/Combine- Assign a filtered object to a property on a class","<ios><swift><swiftui><ios11><combine>","1","0","","","","CC BY-SA 4.0"
"62769304","1","62771126","","2020-07-07 06:27:59","","1","1096","<p><code>didSelectItemAt</code> causes UI to reflow/redraw every time value for <code>lastSelectedIndex</code> is changed, causing performance issue. I'm not sure if I have used <code>@State</code> properly to propagate value from child to parent.</p>
<p>P.S. I need to use UICollectionView for a reason instead of swiftui <code>List</code> or <code>ScrollView</code>.</p>
<pre><code>import Foundation
import SwiftUI

struct ContentView: View {
    @State var lastSelectedIndex : Int = -1
    var body: some View {
        ZStack {
            CustomCollectionView(lastSelectedIndex: $lastSelectedIndex)
            Text(&quot;Current Selected Index \(lastSelectedIndex)&quot;)
        }
    }
}

struct CustomCollectionView: UIViewRepresentable {
    @Binding var lastSelectedIndex : Int
    
    func makeUIView(context: Context) -&gt; UICollectionView {
        let flowLayout = UICollectionViewFlowLayout()
        flowLayout.itemSize = CGSize(width: 400, height: 300)
        let collectionView = UICollectionView(frame: .zero, collectionViewLayout: flowLayout)
        collectionView.register(CustomCollectionViewCell.self, forCellWithReuseIdentifier: CustomCollectionViewCell.reuseId)
        collectionView.delegate = context.coordinator
        collectionView.dataSource = context.coordinator
        collectionView.backgroundColor = .systemBackground
        collectionView.isDirectionalLockEnabled = true
        
        collectionView.backgroundColor = UIColor.black
        collectionView.showsVerticalScrollIndicator = false
        collectionView.showsHorizontalScrollIndicator = false
        collectionView.alwaysBounceVertical = false
        return collectionView
    }

    func updateUIView(_ uiView: UICollectionView, context: Context) {
        uiView.reloadData()
    }

    func makeCoordinator() -&gt; CustomCoordinator {
        CustomCoordinator(self)
    }
}

class CustomCoordinator: NSObject, UICollectionViewDataSource, UICollectionViewDelegate {
    let parent:CustomCollectionView
    
    init(_ parent:CustomCollectionView) {
        self.parent = parent
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {
        100
    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {

        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CustomCollectionViewCell.reuseId, for: indexPath) as! CustomCollectionViewCell
        cell.backgroundColor = UIColor.red
        cell.label.text = &quot;Current Index is \(indexPath.row)&quot;
        NSLog(&quot;Called for Index \(indexPath.row)&quot;)
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        parent.lastSelectedIndex = indexPath.row
    }
}

class CustomCollectionViewCell: UICollectionViewCell {
    static let reuseId = &quot;customCell&quot;
    let label = UILabel()

    override init(frame: CGRect) {
        super.init(frame: frame)
        label.numberOfLines = 0
        contentView.addSubview(label)
        label.translatesAutoresizingMaskIntoConstraints = false
        label.topAnchor.constraint(equalTo: contentView.topAnchor).isActive = true
        label.leadingAnchor.constraint(equalTo: contentView.leadingAnchor).isActive = true
        label.trailingAnchor.constraint(equalTo: contentView.trailingAnchor).isActive = true
        label.bottomAnchor.constraint(equalTo: contentView.bottomAnchor).isActive = true
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

</code></pre>
","362510","","","","","2020-07-08 15:27:22","Prevent reflow/redraw every time @State is changed","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"62769689","1","62771131","","2020-07-07 06:59:14","","8","1735","<p>I created a <a href=""https://www.hackingwithswift.com/books/ios-swiftui/triggering-events-repeatedly-using-a-timer"" rel=""noreferrer"">timer via combine</a> which emits <code>Date</code> and ignores errors using this code:</p>
<pre><code>let timer: AnyPublisher&lt;Date, Never&gt; = Timer.publish(every: 5, on: .main, in: RunLoop.Mode.common)
  .autoconnect()
  .map { _ in Date() }
  .replaceError(with: Date())
  .eraseToAnyPublisher()
</code></pre>
<p>(I'm sure there are better ways than mapping and replacing the error, but for this example, I wanted to keep the type simple, <code>AnyPublisher&lt;Date, Never&gt;</code>.)</p>
<p>The timer fires correctly, but there is a delay between when the timer is created to when it fires the first time (i.e. it waits 5 seconds). With <a href=""https://stackoverflow.com/questions/10764168/how-to-trigger-nstimer-right-away"">NSTimer, we can invoke timer.fire()</a> to force it to fire immediately.</p>
<p>Is there an equivalent way to force a timer to post immediately when using <code>Timer.publish()</code>?</p>
<hr />
<p>Alternatively, is there a way to merge <code>Just(Date())</code> with the above <code>Timer.publish</code> so that it fires immediately and every 5 seconds, while still keeping the <code>AnyPublisher&lt;Date, Never&gt;</code> type?</p>
","35690","","","","","2022-05-31 09:12:38","How to trigger Timer.publish() right away?","<swift><combine>","3","0","1","","","CC BY-SA 4.0"
"62785020","1","62799868","","2020-07-07 22:48:21","","1","574","<p>Consider:</p>
<pre><code>let test = [(1,true), (2,false), (3,false), (4,true), (5,true), (6,true)]
test.publisher.removeDuplicates { $0.1 != $1.1 }
    .sink { print($0.0) }
</code></pre>
<p>This is a sequence of (Int,Bool) pairs. What I'm trying to say in my <code>removeDuplicates</code> filter is: &quot;Do not let through any pairs where the Bool changed from the previous Bool.&quot;</p>
<p>So what I expect is:</p>
<ul>
<li><p><code>2</code> won't get through, because its <code>false</code> is different from the previous <code>true</code></p>
</li>
<li><p><code>4</code> won't get through, because its <code>true</code> is different from the previous <code>false</code></p>
</li>
</ul>
<p>All the others should get through, so the result should be <code>1,3,5,6</code>.</p>
<p>But it isn't. It's <code>1,4,5,6</code>.</p>
<p>Can anyone explain why? What reasoning is <code>removeDuplicates</code> using here?</p>
<p>I <em>think</em> I know the answer; I think it is comparing the current value from upstream with the previous value <em>that was permitted to pass through the filter</em>. Thus, <code>1</code> gets through with its <code>true</code>, and then <code>2</code> and <code>3</code> are suppressed because their <code>false</code> is different from <em>that</em>.</p>
<p>But surely that's not right? Surely we should be comparing to the previous value <em>that came from upstream</em>?</p>
<p>[The docs are in fact oddly coy about this. They say &quot;Publishes only elements that don’t match the previous element&quot;. I assumed that this meant &quot;the previous element that arrived from upstream.&quot; But it seems instead that it means &quot;the previous element that we actually published to the downstream&quot;?]</p>
","341994","","","","","2020-07-08 17:00:24","curious behavior of Combine framework removeDuplicates","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"62786278","1","","","2020-07-08 01:39:07","","0","213","<p>In the documentation for <code>assign</code> it says the following...</p>
<blockquote>
<p>The Subscribers/Assign instance created by this operator maintains a
strong reference to object, and sets it to nil when the upstream
publisher completes (either normally or with an error).</p>
</blockquote>
<p>In the <code>ViewModifier</code> below the <code>assign</code> method in <code>subscribeToKeyboardChanges()</code> refers to self but self is a struct here so there's no way it can create a strong reference</p>
<ul>
<li>Why doesn't the subscription in <code>subscribeToKeyboardChanges()</code> get immediately deallocated?</li>
<li>What is the actually happening here behind the scenes?</li>
</ul>
<pre><code>struct KeyboardHandler: ViewModifier {

    @State private var keyboardHeight: CGFloat = 0

    func body(content: Content) -&gt; some View {
        content
            .padding(.bottom, self.keyboardHeight)
            .animation(.default)
            .onAppear(perform: subscribeToKeyboardChanges)
    }

    private let keyboardWillShow = NotificationCenter.default
        .publisher(for: UIResponder.keyboardWillShowNotification)
        .compactMap { $0.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect }
        .map { $0.height }

    private let keyboardWillHide =  NotificationCenter.default
        .publisher(for: UIResponder.keyboardWillHideNotification)
        .map { _ in CGFloat.zero }

    private func subscribeToKeyboardChanges() {
        _ = Publishers.Merge(keyboardWillShow, keyboardWillHide)
            .subscribe(on: DispatchQueue.main)
            .assign(to: \.self.keyboardHeight, on: self)
    }
}
</code></pre>
","2105498","","","","","2020-07-10 07:38:15","Why does this combine subscription not deallocate in custom ViewModifier?","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62794530","1","62794886","","2020-07-08 12:11:02","","0","1102","<p>I am adding a simple login system to my SwiftUI project. Only I can't quite figure it out.</p>
<p>What the problem is, when a user wants to login and it works. I get this response from the server:</p>
<pre><code>    &quot;user&quot;: {
        &quot;id&quot;: 6,
        &quot;name&quot;: &quot;test&quot;,
        &quot;email&quot;: &quot;test@test.com&quot;,
        &quot;email_verified_at&quot;: null,
        &quot;created_at&quot;: &quot;2020-07-02T09:37:54.000000Z&quot;,
        &quot;updated_at&quot;: &quot;2020-07-02T09:37:54.000000Z&quot;
    },
    &quot;assessToken&quot;: &quot;test-token&quot;
} 
</code></pre>
<p>But when something isn't right, the server displays an error message like this:</p>
<pre><code>    &quot;message&quot;: &quot;The given data was invalid.&quot;,
    &quot;errors&quot;: {
        &quot;email&quot;: [
            &quot;The email field is required.&quot;
        ],
        &quot;password&quot;: [
            &quot;The password field is required.&quot;
        ]
    }
}
</code></pre>
<p>How can I make sure I parse this information into a structure. At the moment it looks like this.</p>
<pre><code>// This file was generated from JSON Schema using quicktype, do not modify it directly.
// To parse the JSON, add this file to your project and do:
//
//   let welcome = try? newJSONDecoder().decode(Welcome.self, from: jsonData)

import Foundation

// MARK: - Welcome
struct Login: Codable {
    let user: User
    let assessToken: String
}

// MARK: - User
struct User: Codable {
    let id: Int
    let name, email: String
    let emailVerifiedAt: JSONNull?
    let createdAt, updatedAt: String
    
    enum CodingKeys: String, CodingKey {
        case id, name, email
        case emailVerifiedAt = &quot;email_verified_at&quot;
        case createdAt = &quot;created_at&quot;
        case updatedAt = &quot;updated_at&quot;
    }
}

// MARK: - Encode/decode helpers

class JSONNull: Codable, Hashable {
    
    public static func == (lhs: JSONNull, rhs: JSONNull) -&gt; Bool {
        return true
    }
    
    public var hashValue: Int {
        return 0
    }
    
    public init() {}
    
    public required init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if !container.decodeNil() {
            throw DecodingError.typeMismatch(JSONNull.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: &quot;Wrong type for JSONNull&quot;))
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encodeNil()
    }
}

</code></pre>
<p>This is how i do it now:</p>
<pre><code>class HttpAuth: ObservableObject{
    var didChange = PassthroughSubject&lt;HttpAuth, Never&gt;()
    
    var authenticated = false{
        didSet{
            didChange.send(self)
        }
    }
    
    func checkDetails(email: String, password: String){
        guard let url = URL(string: &quot;https://test.ngrok.io/api/login&quot;) else {
            return
        }
        
        let body : [String : String] = [&quot;email&quot; : email, &quot;password&quot;: password]
        
        let finalBody = try! JSONSerialization.data(withJSONObject: body)
        
        
        var request = URLRequest(url: url)
        request.httpMethod = &quot;POST&quot;
        request.httpBody = finalBody
        
        request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        
        URLSession.shared.dataTask(with: request) { (data, response, error) in
            
            
            guard let data = data else {return}
            let finalData = try! JSONDecoder().decode(Login.self, from: data)
                
            
            
            print(finalData)
        }.resume()
    }
}

</code></pre>
<p>Do I have to create a new struct named like <code>LoginError</code> for example, or do I need it inside the existing login struct?</p>
","12621025","","4995828","","2020-07-09 06:33:09","2020-07-09 11:52:27","Swift struct optional values","<ios><json><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"62805941","1","","","2020-07-09 01:20:39","","1","135","<p>In my app I use <code>EnvironmentObject</code> which I use to store data objects and the user profile, I use this to make changes throughout the app via various settings.</p>
<p>I also have a <code>ViewModel</code> <code>ObservableObject</code> for passing data between views.</p>
<p>I am trying to set data values from one <code>Observable Object</code> to another in a child view of a <code>NavigationView</code>, one which is in the environment of the app.</p>
<p>However when doing the following it keeps to dismissing to the root <code>NavigationView</code>. Does anybody know why this might be ?</p>
<p><strong>ObservableObject</strong></p>
<pre><code>class UserStore : ObservableObject {

   var didChange = PassthroughSubject&lt;Void, Never&gt;()

   //MARK: Properties
   @Published var profile: User? {didSet{didChange.send() }}
   @Published var editingNote: Note? {didSet{didChange.send() }}

}
</code></pre>
<p><strong>ObservableObject</strong></p>
<pre><code>class NoteViewModel: ObservableObject {

  var didChange = PassthroughSubject&lt;Void, Never&gt;()

  @Published var note: Note? {didSet{didChange.send() }}

}
</code></pre>
<p><strong>View</strong></p>
<pre><code>@EnvironmentObject var userStore: UserStore
@ObservedObject var model: NoteViewModel 

var body: some View {
    VStack {
        Button(action: {
          self.userStore.editingNote = self.model.note
        }) {
          Text(&quot;Edit note&quot;)
        }
    }
 }
</code></pre>
","3144671","","3144671","","2020-07-09 01:34:35","2020-07-10 21:40:54","Updating ObservableObject value dismisses view","<swift><swiftui><combine><navigationview>","0","1","","","","CC BY-SA 4.0"
"62807992","1","62808497","","2020-07-09 05:28:24","","2","749","<p>I have simple <code>viewModel</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>final class EmployeeListViewModel: ObservableObject {
 @Published var list = [Employee]()
 init() {
  // some request
  self.list = [Employee, Employee]
 }
}
</code></pre>
<p>And have a <code>view</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>struct EmployeeView: View {
 @ObservedObject var viewModel = EmployeeListViewModel()
 @State private var showContents: [Bool] = Array(repeating: false, count: viewModel.list.count)// &lt;- error throws here
 var body: some View {
        GeometryReader { fullView in
            ScrollView {
                VStack(spacing: 40) {
                  ForEach(self.viewModel.list) { employee in
                     Text(employee.firstName).foregroundColor(.black)
                  }
                }
            }
        }
 }
}
</code></pre>
<p>Error text:</p>
<blockquote>
<p>Cannot use instance member 'viewModel' within property initializer; property initializers run before 'self' is available</p>
</blockquote>
<p>I tried change it with <code>init</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>struct EmployeeView: View {
 @ObservedObject var viewModel = EmployeeListViewModel()
 @State private var showContents: [Bool]

 init() {
        _showContents = State(initialValue: Array(repeating: false, count: viewModel.list.count)) // &lt;- error
    }

 var body: some View {
        GeometryReader { fullView in
            ScrollView {
                VStack(spacing: 40) {
                  ForEach(self.viewModel.list) { employee in
                     Text(employee.firstName).foregroundColor(.black)
                  }
                }
            }
        }
 }
}
</code></pre>
<p>But it also throws error:</p>
<blockquote>
<p>'self' used before all stored properties are initialized</p>
</blockquote>
<p>this throws on I call <code>viewModel</code> on <code>init()</code></p>
<p>How to solve it? @State i use for card view. There I simplified views for easy understand.</p>
","12882723","","12882723","","2020-07-09 05:49:35","2020-07-09 06:13:25","swiftui @State value depends on @ObservedObject ViewModel init error","<swift><swiftui><combine>","2","4","","","","CC BY-SA 4.0"
"62818767","1","62818856","","2020-07-09 15:49:34","","1","541","<p>I have a two tests for a username, I want two so I can have different messages for the length of the username and one for the validity of a username.</p>
<p>Fine so far,  but I want to combine them to make sure that I can enable my register UIButton</p>
<pre><code>@Published var username: String = &quot;&quot;

var validLengthUsername: AnyPublisher&lt;Bool, Never&gt; {
    return $username.debounce(for: 0.2, scheduler: RunLoop.main)
        .removeDuplicates()
        .map{$0.count &gt; 6 ? true : false}
        .eraseToAnyPublisher()
}

var formattedUserName: AnyPublisher&lt;Bool, Never&gt; {
    return $username
        .removeDuplicates()
        .map{$0.isValidEmail() ? true : false}
        .eraseToAnyPublisher()
}
</code></pre>
<p>I'm trying to map them -but this gives me an array of AnyPublisher. This isn't what I want - I want to combine validLengthUsername &amp;&amp; formattedUserName - I tried just that but I can't simply AND the two <code>AnyPublisher</code>.</p>
","11076699","","","","","2020-07-09 15:53:49","Combine two AnyPublisher in Combine","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"62841572","1","","","2020-07-10 20:05:54","","1","50","<p>I have a view model which handles the loading of new data once the app launches and when a new item is added. I have an issue when it comes to showing new items when are added from a new view, for example, a <code>sheet</code> or even a <code>NavigationLink</code>.</p>
<p>View Model</p>
<pre><code>class GameViewModel: ObservableObject {
    //MARK: - Properties
    @Published var gameCellViewModels = [GameCellViewModel]()
    var game = [GameModel]()
    
    init() {
        loadData()
    }
    
    func loadData() {
        if let retrievedGames = try? Disk.retrieve(&quot;games.json&quot;, from: .documents, as: [GameModel].self) {
            game = retrievedGames
        }
        
        self.gameCellViewModels = game.map { game in
            GameCellViewModel(game: game)
        }
        print(&quot;Load---&gt;&quot;,gameCellViewModels.count)
    }
    
    func addNew(game: GameModel){
        self.game.append(game)
        saveData()
        loadData()
    }
    
    private func saveData() {
        do {
            try Disk.save(self.game, to: .documents, as: &quot;games.json&quot;)
        }
        catch let error as NSError {
            fatalError(&quot;&quot;&quot;
                Domain: \(error.domain)
                Code: \(error.code)
                Description: \(error.localizedDescription)
                Failure Reason: \(error.localizedFailureReason ?? &quot;&quot;)
                Suggestions: \(error.localizedRecoverySuggestion ?? &quot;&quot;)
                &quot;&quot;&quot;)
        }
    }
}
</code></pre>
<p>View to load the ViewModel data, <code>leading</code> add button is able to add and show data but the <code>trailing</code> which opens a new View does not update the view. I have to kill the app to get the new data.</p>
<pre><code>    NavigationView{
        List {
            ForEach(gameList.gameCellViewModels) { gameList in
                CellView(gameCellViewModel: gameList)
            }
        }.navigationBarTitle(&quot;Games Played&quot;)
            .navigationBarItems(leading: Text(&quot;Add&quot;).onTapGesture {
                let arr:[Int] = [1,2,3]
                self.gameList.addNew(game: GameModel(game: arr))
                }, trailing: NavigationLink(destination: ContentView()){
                    Text(&quot;Play&quot;)
            })
    }
</code></pre>
<p>Play View sample</p>
<pre><code>@State var test = &quot;&quot;
var body: some View {
    VStack(){
        TextField(&quot;Enter value&quot;, text: $test)
            .keyboardType(.numberPad)
        
        Button(action: {
            var arr:[Int] = []
            arr.append(Int(self.test)!)
            self.gameList.addNew(game: GameModel(game: arr))
        }) {
            Text(&quot;Send&quot;)
        }
    }
}
</code></pre>
","5525626","","5525626","","2020-07-10 23:08:13","2020-07-10 23:08:13","SwiftUI ObservedObject does not updated when new items are added from a different view","<swift><swiftui><observable><combine><publisher>","1","1","","","","CC BY-SA 4.0"
"62843897","1","","","2020-07-11 00:19:59","","1","987","<p>I have an array of Int plublishers being changed via network and I'd like to assign the sum of it to a variable.
So far I came up to this:</p>
<pre><code>cancellable = Publishers.MergeMany(items.map { $0.$count } ).sink { value in
           print(value) 
        }
</code></pre>
<p>It is printing all the values, but what I really want is to reduce all of them into a single value and then assign to somewhere else. But when I try to do a reduce, something like:</p>
<pre><code>   cancellable = Publishers.MergeMany(items.map { $0.$count } )
            .reduce(0){ counter, value in
                counter + value
            }.sink { value in
                print (value)
            }
</code></pre>
<p>it doesn't work anymore, the value is never printed. What am I doing wrong?
Thanks</p>
<p>Edit:</p>
<p>This seems to work, but it doesn't look very efficient</p>
<pre><code>cancellable = Publishers.MergeMany(items.map { $0.$count })
      .sink { _ in
          let value = self.items.map { $0.count}.reduce(0) { counter, newValue in
              counter + newValue
          }
          print(value)
      }
</code></pre>
","3931494","","3931494","","2020-07-11 00:43:38","2020-07-11 15:24:37","How to reduce an array of Int Publishers on Combine?","<swift><combine>","2","5","","","","CC BY-SA 4.0"
"62846257","1","","","2020-07-11 07:15:32","","1","2278","<p>My Network Manager With Alamofire is Like this for get all API  (<strong>NetworkManager.swift)</strong></p>
<pre><code>@Published var games = GamesDataList(results: [])
   @Published var loading = false
   private let api_url_base = &quot;https://api.rawg.io/api/games&quot;
</code></pre>
<p>And I want to go to navigation when I retrieve data based on ID LIst sent: <strong>(HomeView.swift)</strong></p>
<pre><code> List(networkManager.games.results) { game in
                        NavigationLink(destination: GameDetailView(game: game)){
                            GamesRowView(game: game)
                        }
                    }
</code></pre>
<p>And if I want to switch pages, <strong>NetworkDetail.swift</strong> has to be like that so that the Alamofire takes away from the ID details dynamic.</p>
<pre><code>  private func loadDetailData() {
        let parameters = &quot;12&quot;
        AF.request(&quot;\(api_url_detail)/\(id)&quot;,)
            .responseJSON{ response in
                guard let data = response.data else { return }
                let gamesDetail = try! JSONDecoder().decode(GamesDetail.self, from: data)
                print(gamesDetail)
                DispatchQueue.main.async {
                    self.gamesDetail = gamesDetail
                    self.loading = false
            }
        }
        
</code></pre>
<p>And this my <strong>GameDetailView.swift</strong></p>
<pre><code> var game: Games
    @ObservedObject var networkDetail = NetworkDetail()
    var body: some View {
        VStack {
            URLImage(URL(string:  &quot;\(networkDetail.gamesDetail.background_image)&quot;)!, delay: 0.25) {proxy in
                proxy.image.resizable()
                    
                    .frame(width: 120, height: 80)
                    .aspectRatio(contentMode: .fill)
                    .clipped()
            }
            HStack {
                Text(&quot;Description&quot;).foregroundColor(.gray)
                Spacer()
            }
            Text(networkDetail.gamesDetail.description).lineLimit(nil)
            Spacer()
        }.navigationBarTitle(Text(game.slug), displayMode: .inline)
            .padding()
    }
</code></pre>
<p>I want when to click Item in List it will passing ID and make Request from Alamofire:</p>
<p><a href=""https://i.stack.imgur.com/Nu9O0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Nu9O0.png"" alt=""View"" /></a></p>
<p><a href=""https://i.stack.imgur.com/rSGOU.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rSGOU.png"" alt=""enter image description here"" /></a></p>
<p>Please help me thanks. Right now the detailed API is still static.</p>
","10301357","","10301357","","2020-07-11 07:28:17","2020-07-11 07:28:17","How To Get Detail Api In Swift UI with Alamofire And Combine?","<ios><swift><swiftui><alamofire><combine>","0","5","","","","CC BY-SA 4.0"
"62856674","1","62862531","","2020-07-12 03:08:17","","7","4782","<p>I'm wrapping async requests in Combine publishers so they can easily be used across different pipelines.</p>
<p>A consumer might hold on to these publishers as follows:</p>
<pre><code>struct Dependencies {
  var loadImageRequest: AnyPublisher&lt;UIImage, Never&gt;
  var saveToDatabaseRequest: AnyPublisher&lt;Void, Never&gt;
  var saveToUserDefaultsRequest: AnyPublisher&lt;Never, Never&gt;
}
</code></pre>
<p>Two of the more common types of requests are:</p>
<ol>
<li><strong>Fire and forget (complete immediately)</strong>: For example, saving a value to User Defaults, could be modeled as a fire and forget. So far it seems like <code>AnyPublisher&lt;Never, Never&gt;</code> is a good way to express this type. This can easily be constructed via <code>Empty&lt;Never, Never&gt;(completeImmediately: true)</code>.</li>
<li><strong>Fire, wait, and ignore result</strong>: An example of this is saving a value to the database (and ignoring the result), but still wanting to wait until the save is complete before continuing the pipeline. I've been using <code>AnyPublisher&lt;Void, Never&gt;</code> to model these request types. An easy way to construct these is via a <code>Future&lt;Void, Never&gt;() { promise in promise(.success(()))}</code>.</li>
</ol>
<p>Both of these have the common theme of ignoring the result. Therefore, when handing these off to the consumers, it's sometimes useful to convert between these two data types: <code>AnyPublisher&lt;Never, Never&gt;</code> and <code>AnyPublisher&lt;Void, Never&gt;</code>.</p>
<p>There are three potential ways to convert between the two:</p>
<ol>
<li><p><code>Never -&gt; Void</code>, complete immediately</p>
<p>One way to convert this is with some forced casting:</p>
<pre><code>let neverPublisher: AnyPublisher&lt;Never, Never&gt; = ...
let voidPublisher: AnyPublisher&lt;Void, Never&gt; = neverPublisher
  .map { _ in () }
  .append(Just(()))
  .eraseToAnyPublisher()
</code></pre>
</li>
<li><p><code>Void -&gt; Never</code>, wait until Void completes</p>
<p>Since there is a bulit-in operator for this one, the conversion is easy:</p>
<pre><code>let voidPublisher: AnyPublisher&lt;Void, Never&gt; = ...
let neverPublisher: AnyPublisher&lt;Never, Never&gt; = voidPublisher
  .ignoreOutput()
  .eraseToAnyPublisher()
</code></pre>
</li>
<li><p><code>Void -&gt; Never</code>, complete immediately</p>
<p>I'm not sure the best way to do this conversion. The solution I came up with has two major downsides: using <code>handleEvents</code>, and needing <code>cancellables</code> defined somewhere:</p>
<pre><code>let cancellables: Set&lt;AnyCancellable&gt; = []
let voidPublisher: AnyPublisher&lt;Void, Never&gt; = ...
let neverPublisher: AnyPublisher&lt;Never, Never&gt; = Empty&lt;Never, Never&gt;(completeImmediately: true)
  .handleEvents(receiveCompletion: { _ in voidPublisher.sink(receiveValue: { _ in }).store(in: &amp;cancellables) })
  .eraseToAnyPublisher()
</code></pre>
</li>
</ol>
<p>Questions:</p>
<ol>
<li>Is there a better way to do conversion #1 (<code>Never -&gt; Void</code>, complete immediately) without needing to invoke both <code>map</code> and <code>append</code>? (E.g. similar to how <code>ignoreOutput</code> was used to solve the second conversion?)</li>
<li>Is there a better way to do the third conversion (<code>Void -&gt; Never</code>, complete immediately) which doesn't need <code>cancellables</code>?</li>
</ol>
","35690","","","","","2020-07-12 15:03:38","How to convert to/from AnyPublisher<Void, Never> and AnyPublisher<Never, Never>?","<swift><combine>","1","3","2","","","CC BY-SA 4.0"
"62870847","1","62871604","","2020-07-13 07:08:50","","1","57","<p>It is required to dynamically render messages list in a SwiftUI body block:</p>
<pre><code> var chatSpace: some View {
        List(self.viewModel.getMessages(), id: \.self) { message in
            message
        }
 }
</code></pre>
<p>where view model, is the instance of the following class:</p>
<pre><code>class MessagesListViewModel: ObservableObject {
    
    @ObservedObject var messageService: MessageService
    
    init(messageService: MessageService) {
        self.messageService = messageService
    }
    
    func getMessages() -&gt; [MessageView] {
        return self.messageService.messages.map {
            return MessageView(message: $0)
        }
    }
    
    
}
</code></pre>
<p>I want to reflect changes when I update MessageService <code>message</code> property, how can I achieve that? Can I somehow subscribe to the changes? Right now, I'm basically adding a message by updating <code>messages</code> published var, however, it does not trigger re-drawing</p>
<pre><code>class MessageService: ObservableObject
{
    @Published var messages: [Message] = [Message]()
    
    func addMessage(_ sender: String, _ text: String, _ time: String) {
        self.messages.append(Message(sender: sender, text: text, time: time))
    }
}
</code></pre>
","2095257","","2095257","","2020-07-13 07:14:24","2020-07-13 08:03:27","how to subscribe to a function, which observes @Published?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62871391","1","62871726","","2020-07-13 07:48:56","","1","690","<p>I'm using an API (Firebase) that exposes an async interface for most of its method calls. For every request I make through my own API, I want to add a user's token as a header, if such a token exists. I'm trying to make the entire process part of the same pipeline in Combine.</p>
<p>I have the following code:</p>
<pre><code>struct Response&lt;T&gt; {
    let value: T
    let response: URLResponse
}

...

func makeRequest&lt;T: Decodable&gt;(_ req: URLRequest, _ decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;T, Error&gt; {
    var request = req
    return Future&lt;String?, Error&gt; { promise in
        if let currentUser = Auth.auth().currentUser {
            currentUser.getIDToken() { (idToken, error) in
                if error != nil {
                    promise(.failure(error!))
                } else {
                    promise(.success(idToken))
                }
            }
        } else {
            promise(.success(nil))
        }
    }
    .map { idToken -&gt; URLSession.DataTaskPublisher in
        if idToken != nil {
            request.addValue(&quot;Bearer \(idToken!)&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
        }
        return URLSession.shared.dataTaskPublisher(for: request)
    }
    .tryMap { result -&gt; Response&lt;T&gt; in
        let value = try decoder.decode(T.self, from: result.data)
        return Response(value: value, response: result.response)
    }
    .receive(on: DispatchQueue.main)
    .map(\.value)
    .eraseToAnyPublisher()
}
</code></pre>
<p>I get an error inside tryMap operator when trying to JSON decode the response data:</p>
<blockquote>
<p>Value of type 'URLSession.DataTaskPublisher' has no member 'data'</p>
</blockquote>
<p>I'm still wrapping my head around Combine, but can't understand what I'm doing wrong here. Any help would be greatly appreciated!</p>
","13920975","","13920975","","2020-07-13 08:08:06","2020-07-13 08:11:59","Using Combine operators to transform Future into Publisher","<swift><generics><combine>","1","0","","","","CC BY-SA 4.0"
"62885416","1","62886150","","2020-07-13 22:43:48","","0","392","<p>Imagine I have an API for a class that uses a <code>PassthroughSubject</code> to receive its input:</p>
<pre><code>class Logger {
  let log: PassthroughSubject&lt;String, Never&gt;
}
</code></pre>
<p>Normally I can emit a value by invoking <code>logger.log.send(&quot;test&quot;)</code>.</p>
<p>Now say I want to have my own logger that sits between this generic logger and my code:</p>
<pre><code>class MyLogger {
  let log: PassthroughSubject&lt;String, Never&gt;
}
</code></pre>
<p>This should prefix the string, and then send any updates to Logger. Is there a way to chain the output from one PassthroughSubject (e.g. MyLogger) to another (e.g. Logger)?</p>
<p>I know I can do it this way:</p>
<pre><code>let cancellable = myLogger.log.sink { 
  logger.log.send(&quot;[MyApp] &quot; + $0)
}
</code></pre>
<p>However, that doesn't seem like the Combine-way of chaining things together. I was hoping there was an API I could use more similar to this one:</p>
<pre><code>logger.log.subscribe(myLogger.log.map { &quot;[MyApp] &quot; + $0 })
</code></pre>
<p>However, that doesn't compile since I think the map is causing it to turn into a publisher instead of a subject:</p>
<blockquote>
<p>Instance method 'subscribe' requires that 'Publishers.Map&lt;PassthroughSubject&lt;String, Never&gt;, String&gt;' conform to 'Subject'</p>
</blockquote>
<p>Is there a more declarative API for making one PassthroughSubject subscribe to updates from another (with support for mutations in between) besides relying on <code>sink</code>?</p>
","35690","","","","","2020-07-14 00:08:30","How to forward send calls from one PassthroughSubject to another (i.e. PassthroughSubject chaining)?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62895539","1","62896763","","2020-07-14 12:45:41","","4","1098","<p>I have majority of the functionality working and returning exactly what I want. However, I'm having bit of a brain fart when it comes to taking the <code>photos</code> array in the <code>response</code> and assigning them to appropriate <code>employees</code> to be able to render them. Here's what's going on:</p>
<ol>
<li>There are 4x Codable structs: <code>Response</code>, <code>Company</code>, <code>Employee</code>, and <code>ProfileImages</code>. <code>Response</code> is the main object returned by the API and then decoded into <code>Company</code> having an array of <code>[Employee]</code>, each have 3x <code>ProfileImages</code> (small, medium, and large in size)</li>
<li>There's a <code>companyPublisher</code> that fetches the <code>company</code> details along with an array of <code>employees</code></li>
<li>Then there's a <code>photosPublisher</code> which takes <code>employees</code> array from the previous step and sequences them to be able to retrieve their <code>profileImages.large</code> profile image</li>
<li>At last, I have a <code>Publishers.Zip(companyPublisher, photosPublisher)</code> that sets up the publisher's <code>.sink()</code> to respond with completion once everything requested has been fetched.</li>
</ol>
<p>Can someone advise what would be the appropriate steps I need to take to be able to assign the correct employee image to the actual employee? I was thinking about setting up an optional <code>UIImage</code> type <code>property</code> inside the <code>Employee</code> codable struct but am still unsure on how I would go about assigning the appropriate Future object to that employee.</p>
<p>Any help would be greatly appreciated. Thanks in advance!</p>
<p><code>Response.JSON</code>:</p>
<pre class=""lang-js prettyprint-override""><code>{
  &quot;success&quot;: true,
  &quot;company&quot;: {
    &quot;id&quot;: 64,
    &quot;name&quot;: &quot;XYZ (Birmingham, AL)&quot;,
    &quot;enabled&quot;: true
  },
  &quot;employees&quot;: [{
    &quot;id&quot;: 35,
    &quot;name&quot;: &quot;Chad Hughes&quot;,
    &quot;email&quot;: &quot;chad.hughes@company.com&quot;,
    &quot;profileImages&quot;: {
      &quot;small&quot;: &quot;https://via.placeholder.com/150/09f/fff.png&quot;,
      &quot;medium&quot;: &quot;https://via.placeholder.com/300/09f/fff.png&quot;,
      &quot;large&quot;: &quot;https://via.placeholder.com/600/09f/fff.png&quot;
    }
  }, {
    &quot;id&quot;: 36,
    &quot;name&quot;: &quot;Melissa Martin&quot;,
    &quot;email&quot;: &quot;melissa.martin@company.com&quot;,
    &quot;profileImages&quot;: {
      &quot;small&quot;: &quot;https://via.placeholder.com/150/F2A/fff.png&quot;,
      &quot;medium&quot;: &quot;https://via.placeholder.com/300/F2A/fff.png&quot;,
      &quot;large&quot;: &quot;https://via.placeholder.com/600/F2A/fff.png&quot;
    }
  }]
}
</code></pre>
<p><code>Models.swift</code> (Codable Structs):</p>
<pre class=""lang-swift prettyprint-override""><code>struct Response: Codable {
  let success: Bool
  let company: Company
  let employees: [Employee]
  let message: String?
}

struct Company: Codable, Identifiable {
  let id: Int
  let name: String
  let enabled: Bool
}

struct Employee: Codable, Identifiable {
  let id: Int
  let name: String
  let email: String
  let profileImages: ProfileImage
  let profileImageToShow: SomeImage?
}

struct SomeImage: Codable {
  let photo: Data
  init(photo: UIImage) {
    self.photo = photo.pngData()!
  }
}

struct ProfileImage: Codable {
  let small: String
  let medium: String
  let large: String
}
</code></pre>
<p><code>CompanyDetails.swift</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>class CompanyDetails: ObservableObject {
  private let baseURL = &quot;https://my.api.com/v1&quot;
  
  @Published var company: Company = Company()
  @Published var employees: [Employee] = []
  
  var subscriptions: Set&lt;AnyCancellable&gt; = []
  
  func getCompanyDetails(company_id: Int) {
    let url = URL(string: &quot;\(baseURL)/company/\(company_id)&quot;)
    
    // Company Publisher that retrieves the company details and its employees
    let companyPublisher = URLSession.shared.dataTaskPublisher(for url: url)
      .map(\.data)
      .decode(type: Response.self, decoder: JSONDecoder())
      .eraseToAnyPublisher()
    
    // Photo Publisher that retrieves the employee's profile image in large size
    let photosPublisher = companyPublisher
      .flatMap { response -&gt; AnyPublisher&lt;Employee, Error&gt; in
        Publishers.Sequence(sequence: response.employees)
          .eraseToAnyPublisher()
      }
      .flatMap { employee -&gt; AnyPublisher&lt;UIImage, Error&gt; in
        URLSession.shared.dataTaskPublisher(for url: URL(string: employee.profileImages.large)!)
          .compactMap { UIImage(data: $0.data) }
          .mapError { $0 as Error }
          .eraseToAnyPublisher()
      }
      .collect()
      .eraseToAnyPublisher()
    
    // Zip both Publishers so that all the retrieved data can be .sink()'d at once
    Publishers.Zip(companyPublisher, photosPublisher)
      .receive(on: DispatchQueue.main)
      .sink(
        receiveCompletion: { completion in
          print(completion)
        },
        receiveValue: { company, photos in
          print(company)
          print(photos)
        }
      )
      .store(in: &amp;subscriptions)
  }
}
</code></pre>
","230578","","230578","","2020-07-14 15:26:18","2020-07-14 19:18:21","Swift Combine URLSession retrieving Dataset/Photos using 2x Publishers","<ios><swift><combine><urlsession>","1","2","1","","","CC BY-SA 4.0"
"62902028","1","62902237","","2020-07-14 18:47:43","","2","165","<p>If the user clicks the button while editing the TextField (cursor flashing) in DataPtView, the app crashes.</p>
<p>In a list cell, I have the button, which impacts the view that is also shown in the cell.
Here's a snippet, iPad specific.</p>
<p>CellView:</p>
<pre><code>VStack{
  Button(&quot;TagOut&quot;){
    self.tagOut.toggle()
  }
  
  if self.tagOut {
    TagOutView(question: question)
  }
  
  if !self.tagOut{
    if question.type == &quot;Y/N&quot;{
      YesOrNoView(question: question)
    } else if question.type == &quot;DataPt&quot;{
      DataPtView(question: question)
    } else {
      RecordEntryView()
  }
  ...
</code></pre>
<p>DataPtView:</p>
<pre><code>...
TextField(&quot;Data: &quot;, text: $collectedData)
       .onReceive(Just(collectedData)) {value in
         let filtered = value.filter {&quot;01234567890-&quot;.contains($0)}
         if filtered != value{
           self.invalidCollectedData = true
         } else {
           self.invalidCollectedData = false
         }
 }
 ...
</code></pre>
<p>I'm also using an AdaptsToKeyboard ViewModifier for when CellView is covered by the keyboard.
<a href=""https://stackoverflow.com/questions/56491881/move-textfield-up-when-the-keyboard-has-appeared-in-swiftu"">move-textfield-up-when-the-keyboard-has-appeared-in-swiftu</a></p>
<p>How do I prevent this from happening?  If user hides the keyboard before clicking the button, everything is fine, but that isn't intuitive.</p>
","12282938","","","","","2020-07-14 19:03:15","SwiftUI Prevent user from tapping button while entering data","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"62902789","1","62903191","","2020-07-14 19:37:29","","2","713","<p>I'm looking to create a Combine publisher/subscriber/subscription that behaves like this:</p>
<pre class=""lang-swift prettyprint-override""><code>struct Change&lt;Value&gt; {
  let new: Value
  let previous: Value?
}

let pub = PassthroughSubject&lt;Int, Never&gt;()

let cancellable = pub
  .change()
  .sink { (change: Change&lt;Int&gt;) -&gt; Void in
    print(change)
  }

pub.send(1) // prints Change(new: 1, previous: nil)
pub.send(2) // prints Change(new: 2, previous: 1)
pub.send(3) // prints Change(new: 3, previous: 2)
</code></pre>
<p>Having trouble coming up with the right implementation. I've made my own Publisher/Subscription to wrap external API calls and the sort, but can't come up with the right combination when some state needs to be retained, like the previous value in this example (I think this means you need a custom Subscriber?)</p>
<p>An alternate syntax with the same semantics would also be acceptable, if for some reason the <code>.change()</code> syntax is unworkable.</p>
","652141","","","","","2020-07-14 20:04:49","Custom change operator using Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62942222","1","62996649","","2020-07-16 19:31:06","","1","209","<p>usually I organize my code (in a simplified way) like that :</p>
<p>Presenter Subscribe to my Model (via Managers)</p>
<pre><code>myManager.getItems(...).subscribe { .... }.disposed()
</code></pre>
<p>The Manager call getItems from a Provider and transform DTO -&gt; BO :</p>
<pre><code>func getItems(...) -&gt; Single&lt;myObectBO&gt; {
    myProvider.getItems(...).map { myDTO in
        return MyObjectBO(withDTO: myDTO)
    }
}
</code></pre>
<p>The Provider return a Single of DTO:</p>
<pre><code>func getItems(...) -&gt; Single&lt;myObectDTO&gt; {
    ...
    return Single.just(myObectDTO)
}
</code></pre>
<p>I tried different thing but for the moment I've found nothing to implement that in Combine, is there a simple way to do this?
Thank you for your help.</p>
<hr />
<p>To be more clear I want to do something like that :</p>
<pre><code>func getSomething() {
    getManagerFuture()
        .sink { result in
            print(result)
        }
}

func getManagerFuture() -&gt; Future&lt;[MyBO], ManagerError&gt; {
    
    Future { promise in
    getProviderFuture()
        .flatMap { dtoList -&gt; ([MyBO], ManagerError) in
            
            let boList = dtoList.map { dto in
                return MyBO(id: dto.id, name: dto.name)
            }
            
            return promise(.success(boList))
        }
    }
}

func getProviderFuture() -&gt; Future&lt;[MyDTO], ProviderError&gt; {

    // should be a webservice call
    
    let dto1 = MyDTO(id: 1, name: &quot;one&quot;)
    let dto2 = MyDTO(id: 2, name: &quot;two&quot;)
    
    return Future { promise in promise(.success([dto1, dto2])) }
}
</code></pre>
<p>I have this errors on getManagerProvider :</p>
<blockquote>
<p>Instance method 'flatMap(maxPublishers:_:)' requires the types
'([MyBO], ManagerError).Failure' and 'Never' be equivalent</p>
<p>Type '([MyBO], ManagerError)' cannot conform to 'Publisher'; only
struct/enum/class types can conform to protocols</p>
</blockquote>
","8247388","","8247388","","2020-07-17 08:58:26","2020-07-20 13:39:02","How to implement my MVP / Rxswift with Combine","<swift><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"62945956","1","","","2020-07-17 01:58:09","","6","2093","<p>I'm stuck with <a href=""https://developer.apple.com/documentation/combine/publishers/throttle"" rel=""nofollow noreferrer""><code>Throttle</code></a> publisher. I don't understand the way it picks intervals. <a href=""https://developer.apple.com/documentation/combine/publishers/debounce"" rel=""nofollow noreferrer""><code>Debounce</code></a> publisher is much easier to understand, it picks an interval after each published value and checks whether new values are posted during the interval or not. I've seen some <code>Throttle</code> examples even <a href=""https://developer.apple.com/documentation/combine/future/throttle(for:scheduler:latest:)"" rel=""nofollow noreferrer"">from Apple</a>, but they are very very simple.</p>
<p>Let's say we have some upstream which produces values and we know when all the values were produced (<code>input: [Time]</code>). <code>Throttle</code> publisher consumes these values, throttles them and produces values at some other times (<code>output: [Time]</code>). Is there a way to write a function which produces the correct expected <code>output</code>?</p>
<pre class=""lang-swift prettyprint-override""><code>func output&lt;Time&gt;(interval: Time, input: [Time]) -&gt; [Time] {
  //
}
</code></pre>
<p>Btw, I believe <code>latest</code> parameter doesn't play any role while picking the interval, does it? I belive it just picks values from intervals provided.</p>
","1292099","","442427","","2021-04-21 10:18:57","2021-04-21 10:18:57","How does the Throttle publisher work in Swift Combine?","<swift><throttling><combine><frp><debounce>","1","1","1","","","CC BY-SA 4.0"
"62966690","1","","","2020-07-18 09:06:50","","2","882","<p>I am writing a Hacker News iOS application using SwiftUI/Combine. They have an API call for getting the ids of top posts and then you are supposed to request each story by itself. For this I have created <code>storyIds(:) -&gt; AnyPublisher&lt;[Int], Error&gt;</code> and <code>story(for:) -&gt; AnyPublisher&lt;Post, Error&gt;</code> for those calls.</p>
<p>Now I want to combine them into one function, <code>getStories()</code> which first download the identifiers and then goes through them fetching the stories one by one. I suppose you can use <code>MergeMany</code> or something else in the API for achieving this but I am not sure</p>
<p>The last thing I need is a function that combine these into <code>stories() -&gt; AnyPublisher&lt;[Post], Error&gt;</code>. I found <a href=""https://stackoverflow.com/questions/56958539/how-can-i-loop-over-the-output-of-a-publisher-with-combine"">another question</a> doing almost that. What I miss however, is a way to report progress of the task. I would like to update a counter for each fetched story to show the user how much is left of the download. How can I do this?</p>
<pre class=""lang-swift prettyprint-override""><code>struct Agent {
    struct Response&lt;T&gt; {
        let value: T
        let response: URLResponse
    }
    
    func run&lt;T: Decodable&gt;(_ request: URLRequest, _ decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;Response&lt;T&gt;, Error&gt; {
        return URLSession.shared
            .dataTaskPublisher(for: request)
            .tryMap { result -&gt; Response&lt;T&gt; in
                let value = try decoder.decode(T.self, from: result.data)
                return Response(value: value, response: result.response)
            }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}

enum HackerNewsAPI {
    static let agent = Agent()
    static let base = URL(string: &quot;https://hacker-news.firebaseio.com/v0/&quot;)!
}

extension HackerNewsAPI {
    static func storyIds() -&gt; AnyPublisher&lt;[Int], Error&gt; {
        let request = URLRequest(url: base.appendingPathComponent(&quot;topstories.json&quot;))
        return agent.run(request)
            .print()
            .map(\.value)
            .eraseToAnyPublisher()
    }
}

extension HackerNewsAPI {
    static func story(for id: Int) -&gt; AnyPublisher&lt;Post, Error&gt; {
        let request = URLRequest(url: base.appendingPathComponent(&quot;item/\(id).json&quot;))
        return agent.run(request)
            .map(\.value)
            .eraseToAnyPublisher()
    }
}

extension HackerNewsAPI {
    static func stories() -&gt; AnyPublisher&lt;[Post], Error&gt; {
        HackerNewsAPI.storyIds()
            .flatMap { storyIDs -&gt; AnyPublisher&lt;[Post], Error&gt; in
                let stories = storyIDs.map { story(for: $0) }
                return Publishers.MergeMany(stories)
                    .collect()
                    .eraseToAnyPublisher()
            }
            .eraseToAnyPublisher()
    }
}

</code></pre>
","8522840","","13812420","","2020-07-18 10:39:54","2020-07-18 18:21:48","Reporting progress on list of Publishers in Combine","<swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"62972404","1","62972445","","2020-07-18 18:39:57","","16","4360","<pre><code>let myPassthrough = PassthroughSubject&lt;String, Error&gt;()
</code></pre>
<p>I know I can send a value to a passthrough subject using <code>send</code>:</p>
<pre><code>myPassthrough.send(&quot;abc&quot;)
</code></pre>
<p>How do I send a failure?</p>
<hr />
<p>I tried:</p>
<pre><code>myPassthrough.send(Fail(error: error))
myPassthrough.send(completion: Fail(error: error))
myPassthrough.send(completion: Just(error))
myPassthrough.send(completion: error)
</code></pre>
<p>None of them compile</p>
","35690","","","","","2020-07-18 18:43:28","How do I send an error to a PassthroughSubject?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"62979426","1","62985159","","2020-07-19 11:06:16","","1","80","<p>I have a Auth store (an ObservableObject) which stores whether a user has authenticated into the application. I manage the auth store when the user logs in, essentially changing the authentication state from notAuthenticated to authenticated. I use the same state variable in a ViewModel another ObservableObject, which refers to the Auth store singleton object. I think there might be a simpler way to do this than sinking the variable and updating it on the ViewModel (like directly embedding the Auth variable in the ViewModel).</p>
<p>This is a simplified code for the auth store model</p>
<pre><code>class Auth: ObservableObject {
    
    static let shared = Auth()

    @Published var currentState: AuthState = .notAuthenticated

    enum AuthState {
        case notAuthenticated
        case authenticated
    }
}
</code></pre>
<p>This is the simplified view model</p>
<pre><code>class SampleViewModel: ObservableObject {

    @Published var authState = Auth.shared.currentState

    init() {
    
        Auth.shared.$currentState.sink { newAuthState in
             self.authState = newAuthState
        } // Is there any simple way in which I can skip sinking the publishr
    }
}
</code></pre>
","3970488","","","","","2020-07-19 20:10:44","Is there a way to embed a Published var in one ObservableObject into another ObservableObject?","<swift><observer-pattern><combine>","1","1","","","","CC BY-SA 4.0"
"62986052","1","","","2020-07-19 21:45:29","","3","1222","<p>I'm struggling to form a strongly-typed error object (the <code>ApiErrorResponse</code> object in my example below)  from URLSession's <code>.dataTaskPublisher(for:)</code> publisher, but couldn't find a clue for that. Here I'm creating a class that fetches a joke object from a remote API and then I handle the result and error as follows (the class can be compiled as is in Xcode Playgrounds):</p>
<pre><code>class DadJokes {
        
        struct Joke: Codable {
            let id: String
            let joke: String
        }
        
        enum Error: Swift.Error {
            case network
            case parsing(apiResponse: ApiErrorResponse)
            case unknown(urlResponse: URLResponse)
        }
        
        struct ApiErrorResponse: Codable {
            let code: Int
            let message: String
        }
        
    func getJoke(id: String) -&gt; AnyPublisher&lt;Joke, Error&gt; {
            let url = URL(string: &quot;https://myJokes.com/\(id)&quot;)!
            var request = URLRequest(url: url)
            request.allHTTPHeaderFields = [&quot;Accept&quot;: &quot;application/json&quot;]
            return URLSession.shared
            .dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: Joke.self, decoder: JSONDecoder())
                .mapError { error -&gt; DadJokes.Error in
                    switch error {
                    case is DecodingError:
                        //(1) &lt;--- here I want to get the URLResponse.data from the upstream dataTaskPublisher to decode an object of type ApiErrorResponse (which is returned by the remote API) and pass it to the parsing error case
                        return .parsing(apiResponse: ApiErrorResponse(code: 1, message: &quot;test&quot;))
                    case is URLError:
                        return .network
                    default:
                        //(2) &lt;---- here I want to get the URLResponse object that is emitted from the upstream  dataTaskPublisher and pass it to the .unknown error case
                        // I need the URLResponse to read the underlying error info for debugging purposes
                        return .unknown(urlResponse: URLResponse())
                    }
            }
            .eraseToAnyPublisher()
        }
    }

</code></pre>
<p>I have three questions, two of them are commented in the code above. The third one is: what should I do in order to return a never failing publisher from <code>getJoke</code> function ? i.e. I need the return type of the function to be <code>AnyPublisher&lt;Result&lt;Joke, Error&gt;, Never&gt;</code></p>
","1056118","","","","","2020-07-20 00:32:31","iOS Combine: get a strongly typed error from URLSession's dataTaskPublisher","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"62986929","1","62988407","","2020-07-19 23:57:23","","8","3448","<p>Suppose I have a data model in my SwiftUI app that looks like the following:</p>
<pre><code>class Tallies: Identifiable, ObservableObject {
  let id = UUID()
  @Published var count = 0
}

class GroupOfTallies: Identifiable, ObservableObject {
  let id = UUID()
  @Published var elements: [Tallies] = []
}
</code></pre>
<p>I want to add a computed property to <code>GroupOfTallies</code> that resembles the following:</p>
<pre><code>// Returns the sum of counts of all elements in the group
var cumulativeCount: Int {
  return elements.reduce(0) { $0 + $1.count }
}
</code></pre>
<p>However, I want SwiftUI to update views when the <code>cumulativeCount</code> changes. This would occur either when <code>elements</code> changes (the array gains or loses elements) or when the <code>count</code> field of any contained <code>Tallies</code> object changes.</p>
<p>I have looked into representing this as an <code>AnyPublisher</code>, but I don't think I have a good enough grasp on Combine to make it work properly. This was mentioned in <a href=""https://stackoverflow.com/questions/58203531/an-equivalent-to-computed-properties-using-published-in-swift-combine"">this answer</a>, but the AnyPublisher created from it is based on a published <code>Double</code> rather than a published <code>Array</code>. If I try to use the same approach without modification, <code>cumulativeCount</code> only updates when the elements array changes, but not when the <code>count</code> property of one of the elements changes.</p>
","2035473","","","","","2020-07-21 12:14:58","Published computed properties in SwiftUI model objects","<swift><swiftui><combine>","3","0","2","","","CC BY-SA 4.0"
"62989199","1","62989372","","2020-07-20 05:34:34","","1","84","<p>This is an oversimplification of what I'm trying to achieve using combine.<br>
I need to inject a value into a shared publisher if something happen.
Here you see that if the number 2 is received by map I use the send command on the original publisher to inject the number 3.<br>
I would expect to receive a sequence of number but instead I receive the number 3 before the event that triggered it.<br></p>
<pre><code>let pub = PassthroughSubject&lt;Int, Never&gt;()

let pubSharered = pub.share().eraseToAnyPublisher()

let anyCanc = pubSharered
.map { value -&gt; Int in
        switch value {
        case 2:
            pub.send(3)
            return value
        default:
            return value
        }
}.sink { (value) in
    print(&quot;Sink: \(value)&quot;)
}

pub.send(0)
pub.send(1)
pub.send(2)
pub.send(4)
</code></pre>
<p>The output is: <code>0,1,3,2,4</code> what I was expecting is <code>0,1,2,3,4</code>.<br>
Can someone explain it?</p>
","395897","","","","","2020-07-20 05:53:10","Trying to inject values into a publisher, but receiving unordered values","<ios><swift><macos><reactive-programming><combine>","1","2","","","","CC BY-SA 4.0"
"62996575","1","63000127","","2020-07-20 13:34:20","","3","767","<p>So I have a value of type <code>AnyPublisher&lt;Foo, Error&gt;</code> and I need to transform it to <code>Published&lt;Foo&gt;.Publisher</code> so that I can use it as @Published</p>
<p>so the idea is that I have a MVVM architecture</p>
<pre><code>struct SwiftUIView: View {
  @ObservedObject var viewModel: MyViewModel
  var body: some View {
    Text(/*Foo has a title, how do I access it? */)
  }
  
}
class MyViewModel: ObservableObject {
  var cellModels: AnyPublisher&lt;Foo, Error&gt;
  // so the idea is to have and then access it in swiftUI view via viewModel.cellModels2.title
  @Published cellModels2 = convert_somehow_to_publisher(cellModels)
}
</code></pre>
<p>Apparently I cannot use viewModel.cellModels</p>
<p>Is that possible?</p>
","919348","","919348","","2020-07-20 14:44:43","2020-08-13 16:40:55","Can I transform AnyPublisher to Published.Publisher?","<combine>","1","3","","","","CC BY-SA 4.0"
"62998695","1","62998845","","2020-07-20 15:23:24","","1","724","<p>I'm trying to observe a value in macOS AppDelegate but I got an Error</p>
<blockquote>
<p>ContentView.swift:14:6: Generic struct 'ObservedObject' requires that 'NSApplicationDelegate?' conform to 'ObservableObject'</p>
</blockquote>
<p>when I try to cast the object into <code>ObservedObject</code> with <code>as! ObservedObject</code> I have another Error</p>
<blockquote>
<p>ContentView.swift:14:6: Generic struct 'ObservedObject' requires that 'ObservedObject' conform to 'ObservableObject'</p>
</blockquote>
<p>Inside <code>AppDelegate.swift</code> file</p>
<pre><code>import Cocoa
import SwiftUI
import Combine

@NSApplicationMain
class AppDelegate: NSObject, ObservableObject, NSApplicationDelegate  {
    var isFocused = true
    
    // Other code app life-cycle functions
}
</code></pre>
<p>Inside the <code>ContentView.swift</code> file</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @ObservedObject var appDelegate = NSApplication.shared.delegate
    
    // Other UI code
}
</code></pre>
","2226315","","","","","2022-05-19 07:24:58","How to confirm ObservableObject for an AppDelegate?","<macos><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63006246","1","","","2020-07-21 01:53:42","","1","580","<p>I have a List with several items, that open a DetailView which in turn holds a viewmodel. The viewmodel is supposed to have a service class that gets initialized when the detail view appears and should be deinitialized when navigating back.</p>
<p>However, the first problem is that in my example below, all 3 ViewModel instances are created at the same time (when ContentView is displayed) and <strong>never</strong> get released from memory (<code>deinit</code> is never called).</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    var body: some View {
        NavigationView {
            List {
                NavigationLink(destination: DetailView()) {
                    Text(&quot;Link&quot;)
                }
                NavigationLink(destination: DetailView()) {
                    Text(&quot;Link&quot;)
                }
                NavigationLink(destination: DetailView()) {
                    Text(&quot;Link&quot;)
                }
            }
        }
    }
}

struct DetailView: View {
    @ObservedObject var viewModel = ViewModel()

    var body: some View {
        Text(&quot;Hello \(viewModel.name)&quot;)
    }
}

class ViewModel: ObservableObject {

    @Published var name = &quot;John&quot;

    private let heavyClient = someHeavyService()

    init() { print(&quot;INIT VM&quot;) }

    deinit { print(&quot;DEINIT VM&quot;) }
}
</code></pre>
<p>This is probably just how SwiftUI works, but I have a hard time thinking of a way to handle class objects that are part of a detail view's state, but are not supposed to instantiate until the detail view actually appears. An example would be video conferencing app, with rooms, where the room client that establishes connections etc. should only get initialized when actually entering the room and deinitialize when leaving the room.</p>
<p>I'd appreciate any suggestions on how to mange this. should I initialize the <code>heavyClient</code> at <code>onAppear</code> or something similar?</p>
","2064473","","","","","2020-07-21 02:13:39","SwiftUI @ObservedObject viewmodel in detail-view of List never released","<swift><swiftui><combine>","1","0","1","2020-07-21 03:25:07","","CC BY-SA 4.0"
"63009228","1","","","2020-07-21 07:11:38","","1","232","<p>Given a TextField which should receive a phone, format the number with XX-XX-XXXX pattern, and this specific input field should not allow input over 8 symbols, and only alphanumeric and so on.
I'm trying to use @ObservableObject with @Published var, however, when the value is updated with suffix, the text input position does not jump to the end of the input field:</p>
<pre><code>class SignupModel: ObservableObject {
    @Published var phoneNumber: String = &quot;&quot; {
        didSet {
            if (self.phoneNumber.count == 3 || self.phoneNumber.count == 5) {
                if (self.phoneNumber.count == 3) {
                    self.phoneNumber.insert(&quot;-&quot;, at: String.Index(encodedOffset: 3))
                } else if self.phoneNumber.count == 5 {
                    self.phoneNumber.insert(&quot;-&quot;, at: String.Index(encodedOffset: 5))
                }
            }
            print(self.phoneNumber)
        }
    }
}

...


@ObservedObject var formModel: SignupModel = SignupModel()

...

TextField(&quot;12 3333 123&quot;, text: self.$formModel.phoneNumber)
</code></pre>
<p>What would be the valid approach to achieve validation and formatting using combine?</p>
","2095257","","","","","2020-07-21 19:44:13","how to properly format string in swift @Published didSet attached to the TextField?","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"63012201","1","","","2020-07-21 10:09:24","","1","350","<p>Am trying to implement like and unlike button, to allow a user to like a card and unlike. When a user likes a button the <code>id</code> is saved and the icon changes from line heart to filled heart. I can save the <code>id</code> correctly but the issue is that at times the icon does not switch to filled one to show the user the changes especially after selecting the first one. The subsequent card won't change state but remain the same, while it will add save the <code>id</code> correctly. To be able to see the other card I have to, unlike the first card it cand display both like at the same time. I have tried both <code>Observable</code> and <code>Environmental</code>.</p>
<p>My Class to handle like and unlike</p>
<pre><code>import Foundation
import Disk

class FavouriteRest: ObservableObject {
    @Published private var fav = [Favourite]()
    
    init() {
        getFav()
    }
    
    func getFav(){
        if let retrievedFav = try? Disk.retrieve(&quot;MyApp/favourite.json&quot;, from: .documents, as: [Favourite].self) {
            fav = retrievedFav
        } else {
            print(&quot;&quot;)
        }
    }
    
    
    //Get single data
    func singleFave(id: String) -&gt; Bool {
        for x in fav {
            if id == x.id {
               return true
            }
            return false
        }
        return false
    }
    
    func addFav(favourite: Favourite){
        if singleFave(id: favourite.id) == false {
            self.fav.append(favourite)
            self.saveFave()
        }
    }
    
    //Remove Fav
    func removeFav(_ favourite: Favourite) {
        if let index = fav.firstIndex(where: { $0.id == favourite.id }) {
            fav.remove(at: index)
            saveFave()
        }
    }
    
    //Save Fav
    func saveFave(){
        do {
            try Disk.save(self.fav, to: .documents, as: &quot;SmartParking/favourite.json&quot;)
        }
        catch let error as NSError {
            fatalError(&quot;&quot;&quot;
                Domain: \(error.domain)
                Code: \(error.code)
                Description: \(error.localizedDescription)
                Failure Reason: \(error.localizedFailureReason ?? &quot;&quot;)
                Suggestions: \(error.localizedRecoverySuggestion ?? &quot;&quot;)
                &quot;&quot;&quot;)
        }
    }
    
}
</code></pre>
<p>Single Card</p>
<pre><code>@EnvironmentObject var favourite:FavouriteRest

            HStack(alignment: .top){
                VStack(alignment: .leading, spacing: 4){
                    Text(self.myViewModel.myModel.title)
                        .font(.title)
                        .fontWeight(.bold)
                    Text(&quot;Some text&quot;)
                        .foregroundColor(Color(&quot;Gray&quot;))
                        .font(.subheadline)
                        .fontWeight(.bold)
                }
                Spacer()
                VStack{
                    self.favourite.singleFave(id: self.myViewModel.myModel.id) ? Heart(image: &quot;suit.heart.fill&quot;).foregroundColor(Color.red) : Heart(image: &quot;suit.heart&quot;).foregroundColor(Color(&quot;Gray&quot;))
                }
                .onTapGesture {
                    if self.favourite.singleFave(id: self.myViewModel.myModel.id) {
                        self.favourite.removeFav(Favourite(id: self.myViewModel.myModel.id))
                    } else {
                        self.favourite.addFav(favourite: Favourite(id: self.myViewModel.myModel.id))
                    }
                }
            }
</code></pre>
","5525626","","968155","","2020-07-21 12:27:54","2020-07-23 09:11:36","State not updating correctly in SwiftUI","<ios><swift><swiftui><state><combine>","1","4","","","","CC BY-SA 4.0"
"63020426","1","63020580","","2020-07-21 18:01:05","","2","281","<p>I've always used delegation in UIKit and WatchKit to communicate between objects as far as passing around data from e.g. a WorkoutManager ViewModel that receives delegate callbacks from HealthKit during an HKworkout for calories, heart rates, to an InterfaceController.</p>
<p>I'm now trying to use Combine and SwiftUI to pass around the same data and am a little lost. I'm using a WorkoutManager class as an environment object that I initialize in my ContentView:</p>
<pre><code>class WorkoutManager: NSObject, HKWorkoutSessionDelegate, HKLiveWorkoutBuilderDelegate, ObservableObject  {

    @Published var totalEnergyBurned: Double = 0

    //How to subscribe to the changes? 

//Omitted HealthKit code that queries and pushes data into totalEnergyBurned here

}



struct ContentView: View {
    
    let healthStore = HKHealthStore()
    @StateObject var workoutManager = WorkoutManager()
    
    var sessionTypes = [SessionType.Game, SessionType.Practice, SessionType.Pickup]
    
    var body: some View {
        
        List {
            ForEach(sessionTypes) { sessionType  in
                NavigationLink(destination: LiveWorkoutView(sessionType: sessionType)) {
                    SessionTypeRow(name: sessionType.stringValue)
                }
            }
        }
        .navigationTitle(&quot;Let's Go!&quot;)
        .onAppear {
            let authorizationStatus = healthStore.authorizationStatus(for: HKSampleType.workoutType())
            switch authorizationStatus {
            case .sharingAuthorized:
                print(&quot;sharing authorized&quot;)
            case .notDetermined:
                print(&quot;not determined&quot;)
                HealthKitAuthManager.authorizeHealthKit()
            case .sharingDenied:
                print(&quot;sharing denied&quot;)
                HealthKitAuthManager.authorizeHealthKit()
            default:
                print(&quot;default in healthStore.authorizationStatus in ContentView&quot;)
                HealthKitAuthManager.authorizeHealthKit()
            }
        }
    }
}
</code></pre>
<p>My goal is to Publish the changes to all of the children of ContentView but I'm not sure how to subscribe to the changes?</p>
<pre><code>import SwiftUI

struct LiveWorkoutView: View {

@State var sessionType: SessionType
    
    @StateObject var workoutManager = WorkoutManager()
    
    var body: some View {
        VStack {
            Text(&quot;\(workoutManager.totalEnergyBurned)&quot;)
            Button(action: {
                workoutManager.stopWorkout()
            }) {
                Text(&quot;End Workout&quot;)
            }
        }
        .onAppear {
            workoutManager.startWorkout()
            workoutManager.sessionType = sessionType
        }
        .navigationTitle(sessionType.stringValue)
    }
}
</code></pre>
","4625622","","","","","2020-07-21 18:09:37","Using Combine's Publishers and Subscribers to publish real time HealthKit data?","<swift><swiftui><healthkit><combine><watchos>","1","0","","","","CC BY-SA 4.0"
"63030923","1","","","2020-07-22 09:20:08","","0","204","<p>I've got a generic &quot;perform&quot; method to download some data from the network (Some code omitted):</p>
<pre><code>   func perform&lt;D: Decodable&gt;(_ endPoint: EndPoint) -&gt; AnyPublisher&lt;D, APIProviderError&gt; {
      do {
         let request = try requestBuilder.build(with: endPoint)

         return try configurateSession(urlRequest: request, stub: endPoint.testData)
            .dataTaskPublisher(for: request)
            .decode(type: D.self, decoder: JSONDecoder())
      catch {
            fatalError(error.localizedDescription)
      }
}

</code></pre>
<ol>
<li>Initially I load the main page structure. json example:</li>
</ol>
<pre><code>{
   &quot;layout&quot;: {
      &quot;id&quot;: &quot;10&quot;,
      &quot;slots&quot;: [
         {
            &quot;slotNumber&quot;: 1,
            &quot;widgets&quot;: [
               {
                  &quot;id&quot;:&quot;10&quot;,
                  &quot;type&quot;: &quot;booking&quot;
               },
               {
                  &quot;id&quot;: &quot;11&quot;,
                    &quot;type&quot;: &quot;banners&quot;
               },
               {
                  &quot;id&quot;:&quot;12&quot;,
                  &quot;type&quot;: &quot;chips&quot;
               },
               {
                  &quot;id&quot;:&quot;13&quot;,
                  &quot;type&quot;: &quot;products&quot;
               },
               {
                  &quot;id&quot;: &quot;15&quot;,
                    &quot;type&quot;: &quot;banners&quot;
               }
   ]
}
</code></pre>
<p>and parse it into an array of structures</p>
<pre><code>struct Container: Decodable {
   let layout: Layout
}

struct Layout: Decodable {
   let slots: [Slot]
}

struct Slot: Decodable {
   let widgets: [Section]
}

struct Section: Decodable  {
   private enum CodingKeys: String, CodingKey {
      case id, type
   }

   let id: String
   let type: SectionType
   var items: [Item]?
}

enum SectionType: String, Decodable {
   case banners, brands, products, orders, coupons, map, card, booking, chips
}
</code></pre>
<ol start=""2"">
<li>For each widget(Section), depending on its type, I need to load its items and mutate widget. Item examples:</li>
</ol>
<pre><code>
{
   &quot;data&quot;: [
      {
         &quot;offerPrice&quot;: &quot;59.99&quot;,
         &quot;name&quot;: &quot;ss&quot;,
         &quot;id&quot;: &quot;60461&quot;
      },
      {
         &quot;offerPrice&quot;: &quot;79.99&quot;,
         &quot;name&quot;: &quot;www&quot;,
         &quot;id&quot;: &quot;60750&quot;
      }]
}

{
   &quot;data&quot;: [
      {
         &quot;image&quot;: &quot;url&quot;
      },
      {
         &quot;image&quot;: &quot;url&quot;,
         &quot;categoryId&quot;: &quot;3074457345616766223&quot;
      }
      ]
   }
</code></pre>
<p>to</p>
<pre><code>struct ItemContainer&lt;T: Decodable&gt;: Decodable {
   let id: String
   let items: [T]
}

class Banner: Item, Decodable {
   let categoryID: String?
   let infoID: String?
   let imageURL: String?
}

class Product: Item, Decodable {
   let id: String
   let name: String
   let offerPrice: String
}
</code></pre>
<p><strong>I think For each widget it is necessary to create a publisher. I don't understand what to do next. Zip does not work with collections</strong></p>
<p>I wrote the following:</p>
<pre><code>      provider.perform(.structMain)
         .map { (container: Container) in
            container.layout.slots.first?.widgets
         }.eraseToAnyPublisher()
         .sink(receiveCompletion: { _ in

         }, receiveValue: { result in
          ????????
         })
         .store(in: &amp;self.cancellableset)
</code></pre>
<p><strong>Or do I need something else</strong></p>
","4137436","","4137436","","2020-07-22 15:32:03","2020-07-22 15:32:03","Combine framework (URLSession.DataTaskPublisher): Mutate first publisher result with publishers array","<swift><reactive-programming><combine>","0","4","1","","","CC BY-SA 4.0"
"63034377","1","63034708","","2020-07-22 12:38:15","","2","2125","<p>My understanding is a CurrentValueSubject publisher in Combine is good for accessing on demand, as opposed to a regular Publisher that emits a value once. So I'm trying to use one here in an Environment Object to store the total energy burned in an HKWorkout so that I can access it after the workout is finished in a SwiftUI View.  With the code below I get the compiler error <code>Cannot convert return expression of type 'AnyCancellable' to return type 'Double'</code> so I think I need to do some type of casting but can't figure it out?</p>
<pre><code>class WorkoutManager: NSObject, HKWorkoutSessionDelegate, HKLiveWorkoutBuilderDelegate, ObservableObject  {
    
    var finishedWorkoutTotalEnergyBurned = CurrentValueSubject&lt;Double, Never&gt;(0.0)
    
    func stopWorkout() {
        self.finishedWorkoutTotalEnergyBurned.value = unwrappedWorkout.totalEnergyBurned!.doubleValue(for: .kilocalorie())
    }
}

struct SummaryView: View {

    @StateObject var workoutManager = WorkoutManager()
    
    var body: some View {
        Text(&quot;\(getFinishedWorkoutTotalEnergyBurned())&quot;)
            .navigationBarHidden(true)
        //.navigationTitle(&quot;Workout Complete&quot;)
    }
    
    func getFinishedWorkoutTotalEnergyBurned() -&gt; Double {
        workoutManager.finishedWorkoutTotalEnergyBurned.sink(receiveValue: { $0 })
    }
}
</code></pre>
","4625622","","968155","","2020-07-22 12:42:53","2020-10-15 11:39:02","How to use Combine's CurrentValueSubject and access it in a SwiftUI View?","<ios><swift><swiftui><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"63039749","1","63040386","","2020-07-22 17:16:31","","3","631","<p>I was playing around with Combine and I realised that instead of calling <code>.cancel()</code> on an <code>AnyCancellable</code>,  making the <code>AnyCancellable</code> an <code>Optional</code> and setting it to <code>nil</code> also stops the stream of values.</p>
<p>Is setting an <code>AnyCancellable?</code> to <code>nil</code> instead of calling <code>.cancel()</code> on an <code>AnyCancellable</code> a bad thing? Does it have any negative consequences such as leaking memory or something?</p>
<p>For reference, this is the code:</p>
<pre><code>class Test: ObservableObject {
    var canceller: AnyCancellable?
    
    func start() {
        let timerPublisher = Timer
            .publish(every: 1, on: .main, in: .common)
            .autoconnect()
        
        self.canceller = timerPublisher.sink { date in
            print(&quot;the date is \(date)&quot;)
        }
    }
    func stop1() {
        canceller?.cancel()
    }
    func stop2() {
        canceller = nil
    }
}
</code></pre>
<pre><code>struct ContentView: View {
    @ObservedObject var test = Test()
    
    var body: some View {
        VStack(spacing: 20) {
            Button(&quot;Start&quot;) {
                self.test.start()
            }
            
            Button(&quot;Stop1&quot;) {
                self.test.stop1()  // Both buttons stop the stream of values
            }

            Button(&quot;Stop2&quot;) {
                self.test.stop2()  // Is there any difference between using this and stop1?
            }
        }
    }
}
</code></pre>
","13299183","","","","","2020-07-22 17:54:12","Is there a difference between calling .cancel() on an AnyCancellable vs. making an AnyCancellable? = nil in SwiftUI?","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"63047679","1","","","2020-07-23 05:49:04","","0","137","<p>I have two Published state in my viewmodel one is for <code>source</code> and another one is for <code>destination</code></p>
<p>Based on the solution <a href=""https://stackoverflow.com/a/57878202/213532"">here</a> to detect live changes on textfield. I have implemented like this</p>
<pre><code>TextField(&quot;&quot;, text: $viewModel.source)
TextField(&quot;&quot;, text: $viewModel.destination)
</code></pre>
<p>Problem, here is i need to update the either fields whenever user enter some value. For example - If user enter on <code>source</code> then i need to update <code>destination</code> with source inputs. And if user input <code>destination</code> then need to update <code>source</code>.</p>
<pre><code>@Published var source: Double = 0 {
        didSet {
            destination = source / rate
        }
    }
</code></pre>
<p>This is just one solution. I have to repeat it same for destination then it will create deadlock</p>
<pre><code>@Published var destination: Double = 0 {
        didSet {
            source = destination * rate
        }
    }
</code></pre>
<p>How to solve this problem ? Only solution i imagine if there is any way i can get live changes in the form of callback then i can update the either field but i don't know if it is possible</p>
","213532","","","","","2020-07-23 07:30:45","How to solve deadlock on multiple Published on 2 TextField in SwiftUI?","<ios><swiftui><textfield><publish><combine>","1","0","","","","CC BY-SA 4.0"
"63049647","1","63053648","","2020-07-23 08:05:35","","0","99","<p>I have the following code running in a playground that supposed to print an array of 4 clues based on a random category ID. The category ID and the Correct URL used to get the clues are always printed correctly However, the clue results are printed intermittently sometimes its successful other times. Can anyone help me figure out why it sometimes does not print the array of clues yet the URL is correct?</p>
<pre><code>import Foundation
import Combine

// MARK: - ClueElement
struct ClueElement: Codable {
  let id: Int
  let answer, question: String
  let value: Int
  let categoryID: Int
  let category: Category

  enum CodingKeys: String, CodingKey {
    case id, answer, question, value
    case categoryID = “category_id”
    case category
  }
}


// MARK: - Category
struct Category: Codable {
  let id: Int
  let title: String
  let cluesCount: Int

  enum CodingKeys: String, CodingKey {
    case id, title
    case cluesCount = “clues_count”
  }
}


enum HTTPError: LocalizedError {
  case statusCode
  case post
}



typealias Clue = [ClueElement]

var cancellable: AnyCancellable?

func loadData() {
  let url1 = URL(string: “http://www.jservice.io/api/random”)!
  cancellable = URLSession.shared.dataTaskPublisher(for: url1)
    .map { $0.data }
    .decode(type: Clue.self, decoder: JSONDecoder())
    .tryMap { category in
      guard let categoryID = category.first?.categoryID else { throw HTTPError.post}
      guard let cluesCount = category.first?.category.cluesCount else { throw HTTPError.post}
      print(“\(categoryID)“)
      return (categoryID,cluesCount)
  }
  .flatMap { (categoryID,cluesCount) in
    return getClues(for: categoryID, cluesCount: cluesCount)
  }
  .receive(on: DispatchQueue.main)
  .sink(receiveCompletion: { completion in

  }) { clues in
    print(clues)
  }
}

func getClues(for id: Int, cluesCount: Int) -&gt; AnyPublisher&lt;Clue, Error&gt; {
  let url = URL(string: “http://www.jservice.io/api/clues?category=\(id)&amp;offset=\(cluesCount - 4)“)!
  print(url)
  return URLSession.shared.dataTaskPublisher(for: url)
    .map { $0.data }
    .decode(type: Clue.self, decoder: JSONDecoder())
    .receive(on: DispatchQueue.main)
    .eraseToAnyPublisher()
}

loadData()
</code></pre>
","3369207","","","","","2020-07-23 11:53:56","intermittent results using URLSession with Combine","<swift><nsurlsession><combine>","1","0","","","","CC BY-SA 4.0"
"63051356","1","","","2020-07-23 09:44:03","","0","58","<p>Can I use the time interval in Alamofire to reload an API for a set time of period? For example, I have an API which changes but does not publish the changes I have to call the <code>.get</code> request, again and again, to get new updates. Can <code>timeInterval</code> help in reloading the API to watch for changes? Which will only push update the array when there is an update</p>
<pre><code>@Published var myArray = [MyModel]()

init() {
    fetchData()
}

func fetchData(){
    AF.request(myRouter.getData)
        .responseData{ (response) in
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601
            let result: AFResult&lt;[MyModel]&gt; = decoder.decodeResponse(from: response)
            switch result {
            case let .success(value):
                self.myArray.append(contentsOf: value)
            case let .failure(error):
                print(error)
            }
    }
}
</code></pre>
","5525626","","","","","2020-07-23 09:44:03","Time Interval in alamofire to watch for changes in an API","<swift><swiftui><alamofire><combine>","0","2","","","","CC BY-SA 4.0"
"63082722","1","63082907","","2020-07-24 23:31:22","","0","1634","<p>Ok, so I am using the last version of Swift with Combine.
My goal is to combine 3 <code>CurrentValueSubject</code> or <code>PassthroughSubject</code> into one Sequence by waiting for all of them to emit once.</p>
<p>Let's take the following example:</p>
<pre><code>var var1 = CurrentValueSubject&lt;[String], Never&gt;)([])
var var2 = CurrentValueSubject&lt;Int, Never&gt;(0)
var var3 = CurrentValueSubject&lt;Date?, Never&gt;(nil)
</code></pre>
<p>I want to have all value in one when they each emit a new sequence.</p>
<p>So I could do something like that:</p>
<pre><code>Publishers
    .CombineLatest3(var1, var2, var3)
    .sink(receivedValue: { var1, var2, var3 in
        print(&quot;Printed!&quot;)
    })
    .store(in: &amp;subscriptions)
</code></pre>
<p>Alright, so that kind of works, but it will print <code>Printed!</code> 3 times on the second pass.
Let's say, if I do the following code, it will do it only once.</p>
<pre><code>var1.send([&quot;test&quot;,&quot;test1&quot;])
var2.send(0)
var3.send(Date())
</code></pre>
<p>but I add this</p>
<pre><code>var1.send([&quot;test&quot;,&quot;test1&quot;])
var2.send(0)
var3.send(Date())
var1.send([&quot;test&quot;,&quot;test1&quot;])
</code></pre>
<p>It will trigger again my Combined Publishers. And I want to trigger it again only if I have the following scenario:</p>
<pre><code>var1.send([&quot;test&quot;,&quot;test1&quot;])
var2.send(0)
var3.send(Date())
var1.send([&quot;test2&quot;,&quot;test3&quot;])
var2.send(2)
var3.send(Date())
</code></pre>
<p>I hope this makes sense, let me know if you have an idea of how to tackle this issue!</p>
","5899647","","77567","","2020-07-25 01:25:04","2020-07-25 01:25:04","Swift Combine - Multiple Observable (CurrentValueSubject or PassthroughSubject) into one but wait for update from all","<swift><reactive-programming><combine>","1","3","","","","CC BY-SA 4.0"
"63120089","1","","","2020-07-27 17:05:12","","0","408","<p>I'm new to WebSocket and SwiftUI and am trying to subscribe to more than one ticker at the same time using Finnhub, so I can receive real-time stock market price. However, when I subscribe to one ticker manually by sendMessage method (&quot;{&quot;type&quot;:&quot;subscribe&quot;,&quot;symbol&quot;:&quot;BINANCE:BTCUSDT&quot;}&quot;), and try to add another ticker, let's say BINANCE:ETHUSDT for instance, it worked only by duplicating the code below, and the return of the API comes with the two tickers at the same position in the array. When I add to the row in the UI, both tickers share the same row. Here's the API documentation: <a href=""https://finnhub.io/docs/api"" rel=""nofollow noreferrer"">https://finnhub.io/docs/api</a></p>
<p>Any idea on how to solve this?</p>
<p>Thanks in advance</p>
<pre><code>
private func sendMessage()
    {
        let string = &quot;{\&quot;type\&quot;:\&quot;subscribe\&quot;,\&quot;symbol\&quot;:\&quot;BINANCE:BTCUSDT\&quot;}&quot;
        
        
        let message = URLSessionWebSocketTask.Message.string(string)
        webSocketTask?.send(message) { error in
            if let error = error {
                print(&quot;WebSocket couldn’t send message because: \(error)&quot;)
            }
        }
    }


</code></pre>
<pre><code>    @Published var tickerPrice = [StockMarketModel.LastPrice]()


    private func receiveMessage() {
        webSocketTask?.receive {[weak self] result in
            
            switch result {
            case .failure(let error):
                print(&quot;Error in receiving message: \(error)&quot;)
            case .success(.string(let str)):
                
                do {
                    let decoder = JSONDecoder()
                    let result = try decoder.decode(StockMarketModel.APIData.self, from: Data(str.utf8))
                    DispatchQueue.main.async{

                        self?.tickerPrice = result.data

                        
                        print(result.data[0].p)

                    }
                } catch  {
                    print(&quot;error is \(error)&quot;)
                }
                
                self?.receiveMessage()
                
            default:
                print(&quot;default&quot;)
            }
        }
    }
</code></pre>
","12853668","","","","","2020-07-27 17:05:12","How to properly subscribe to more than 1 stock market ticker using WebSocket, SwiftUI and Combine?","<swift><websocket><swiftui><combine>","0","4","","","","CC BY-SA 4.0"
"63143578","1","63144806","","2020-07-28 22:16:11","","2","1429","<p>I have the following model:</p>
<pre><code>struct Response: Decodable {
    let message: String
}

struct ErrorResponse: Decodable {
    let errorMessage: String
}

enum APIError: Error {
    case network(code: Int, description: String)
    case decoding(description: String)
    case api(description: String)
}
</code></pre>
<p>I'm trying to fetch an url and parse the JSON response using this flow:</p>
<pre><code>func fetch(url: URL) -&gt; AnyPublisher&lt;Response, APIError&gt; {
    URLSession.shared.dataTaskPublisher(for: URLRequest(url: url))

        // #1 URLRequest fails, throw APIError.network
        .mapError { .network(code: $0.code.rawValue, description: $0.localizedDescription) }

        // #2 try to decode data as a `Response`
        .tryMap { JSONDecoder().decode(Response.self, from: $0.data) }

        // #3 if decoding fails, decode as an `ErrorResponse`
        //    and throw `APIError.api(description: errorResponse.errorMessage)`

        // #4 if both fail, throw APIError.decoding
        
        // #5 return
        .eraseToAnyPublisher()
}
</code></pre>
<p>I have a problem with <code>#3</code>: how can I decode the original data after the <code>tryMap</code> part?</p>
<p>It seems like the only value I can access there is the error coming from <code>tryMap</code> but I need the original data to decode an <code>ErrorRepsonse</code>.</p>
<p>Note: unfortunately the error response comes with the 200 status and the only way to differentiate them is to decode them.</p>
","8697793","","","","","2020-07-29 14:20:54","Decode another response if first decoding failed using Combine and Swift","<json><swift><combine><decodable>","1","0","","","","CC BY-SA 4.0"
"63149864","1","63158713","","2020-07-29 08:52:52","","0","207","<p>I am trying to use the <code>URLSession.dataTaskPublisher</code> to create a retrying Publisher, which connects to a MJPEG stream.</p>
<p>Unfortunately my Subscriber never really receives any data, although I can see that data is transferred and the RAM consumption slowly increases. So the stream is open and data is received but not on the Subscriber. I had a version which received data once, but then closed the stream immediately.</p>
<p>I have tried many different configurations but the following seems to be closest to the goal:</p>
<p>What am I missing? Has someone encountered this kind of memory leak before?</p>
<p>I am mostly interested in a <code>timeout</code> error but also want to retry when something else is not working properly.</p>
<pre class=""lang-swift prettyprint-override""><code>var cancellables: Set&lt;AnyCancellable&gt; = []
let url = URL(string: &quot;http://mjpeg.stream&quot;)!
let configuration = URLSessionConfiguration.ephemeral
configuration.timeoutIntervalForRequest = 1
configuration.requestCachePolicy = .reloadIgnoringLocalAndRemoteCacheData
let datataskpublisher = URLSession(configuration: configuration)
    .dataTaskPublisher(for: url)

let catcher = datataskpublisher
    .tryCatch { (error) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), URLError&gt; in
        print(&quot;ERROR: \(error.code)&quot;)
        throw error
    }.eraseToAnyPublisher()

let retryer = catcher
    .catch { (error) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), Error&gt; in
        print(&quot;RETRYING&quot;)
        return catcher.delay(for: 0.5, scheduler: DispatchQueue.global()).eraseToAnyPublisher()
    }
    .eraseToAnyPublisher()


retryer
    .sink(receiveCompletion: { result in
          print(&quot;COMPLETED&quot;)
          switch result {
          case .failure(let fail):
               print(&quot;FAIL \(fail)&quot;)
          case .finished:
               print(&quot;FINISHED&quot;)
          }
     }, receiveValue: { value, response in
          print(&quot;DATA&quot;)
          let data = value
                    // parsing data
    })
    .store(in: &amp;self.cancellables)
</code></pre>
","5981293","","","","","2020-07-29 16:57:23","URLSession dataTaskPublisher with retry as MJPEG stream","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63150648","1","63157768","","2020-07-29 09:35:36","","0","468","<p>Given I have an SDK which provides the functionality below</p>
<pre><code>class SDK {
    static func upload(completion: @escaping (Result&lt;String, Error&gt;) -&gt; Void) {
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            completion(.success(&quot;my_value&quot;))
        }
    }
}
</code></pre>
<p>I am able to a create a wrapper around to make its usage more functional</p>
<pre><code>class CombineSDK {
    func upload() -&gt; AnyPublisher&lt;String, Error&gt; {
        Future { promise in
            SDK.upload { result in
                switch result {
                case .success(let key):
                    promise(.success(key))
                case .failure(let error):
                    promise(.failure(error))
                }
            }
        }.eraseToAnyPublisher()
    }
}
</code></pre>
<p>Now I'm trying to understand how my CombineSDK.upload method should look like if the SDK upload method also provides a progress block like below:</p>
<pre><code>class SDK {
    static func upload(progress: @escaping (Double) -&gt; Void, completion: @escaping (Result&lt;String, Error&gt;) -&gt; Void) {
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            progress(0.5)
        }

        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            progress(1)
        }

        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            completion(.success(&quot;s3Key&quot;))
        }
    }
}
</code></pre>
","1044591","","","","","2020-07-30 02:01:04","Publisher emitting progress of operation and final value","<swift><combine>","3","0","","","","CC BY-SA 4.0"
"63157636","1","","","2020-07-29 15:57:41","","1","712","<p>I am newer to SwiftUI and am not sure how I should architect my app.</p>
<p>I am building a stocks app that will display a list of stocks and I am wanting to use SocketIO to connect to my backend to update the stocks list with real-time prices.</p>
<p>Here is what I have so far:</p>
<pre><code>import Combine
import SocketIO
import SwiftUI

struct RealtimePriceResponse: Codable {
    let quotes: [RealtimeQuote]
}

struct RealtimeQuote: Codable {
    let ticker, last, previousClose: String?
}


class SocketConnection: ObservableObject {
    @Published var realtimeQuotes: [RealtimeQuote] = []
    @Published var isConnected: Bool = false
    
    let socketManager = SocketManager(socketURL: URL(string: &quot;https://api.myapp.com&quot;)!, config: [.log(true), .compress])
    var socket: SocketIO.SocketIOClient

    init(tickers: [String]) {
        socket = socketManager.defaultSocket
        socket.connect()
        
        socket.on(clientEvent: .connect) { data, ack in
            self.isConnected = true
            print(&quot;Socket has connected&quot;)
            self.socket.emit(&quot;priceListen&quot;, [&quot;userId&quot;: &quot;121212&quot;, &quot;symbols&quot;: tickers])
        }

        socket.on(&quot;userid&quot;) { [unowned self]  data, ack in
            let decoder = JSONDecoder()
            let jsonData = try? JSONSerialization.data(withJSONObject: data[0])
            let priceUpdates = try? decoder.decode(RealtimePriceResponse.self, from: jsonData!)
            if let decoded = priceUpdates {
                self.realtimeQuotes = decoded.quotes
                print(&quot;Real-time Prices: \(String(describing: decoded))&quot;)
            }
        }
        
        socket.on(clientEvent: .disconnect) { data, ack in
            self.isConnected = false
            print(&quot;Socket has disconnected&quot;)
        }
    }
}

struct StocksView: View {
    var tickers: [String] = [&quot;TSLA&quot;, &quot;SNAP&quot;, &quot;DIS&quot;, &quot;AMZN&quot;]
    
    @ObservedObject var socket: SocketConnection
    
    init() {
        self.socket = SocketConnection(tickers: self.tickers)
    }
    
    var body: some View {
        return List(tickers, id: \.self) { ticker in
            Stock(ticker: ticker, quote: self.socket.realtimeQuotes.first(where: { $0.ticker == ticker }) ?? RealtimeQuote?.none)
        }
    }
}

struct Stock: View {
    var ticker: String
    var price: String
    
    init(ticker: String, quote: RealtimeQuote?) {
        self.ticker = ticker
        if let quote = quote {
            price = quote.last!
        } else {
            self.price = &quot;--.--&quot;
        }
    }
    
    var body: some View {
        HStack {
            Text(ticker).bold()
            Spacer()
            Text(&quot;$\(price)&quot;)
        }
    }
}

</code></pre>
<p>This does not work as I would expect it to. Should my view hold onto an instance of this SocketConnection class? That seems risky and not the best way. Also, how should I update just the Text() view in the HStack that holds the price?</p>
","999340","","999340","","2020-07-29 16:58:30","2020-08-20 18:57:51","SwiftUI update a list with socket payload","<ios><swift><socket.io><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63190381","1","","","2020-07-31 10:44:31","","3","663","<p>I have an app with minimum deployment target of <strong>iOS 12.0</strong>. There are parts written in <code>SwiftUI</code> and <code>Combine</code>. All methods and types using the two libraries are marked with <code>@available(iOS 13.0, *)</code>. The app has been running in this mixed setup since January without problems.</p>
<p>To take advantage of ABI stability and reduce the app size I want to set the new minimum deployment target to <strong>iOS 12.2</strong>.</p>
<p>When I do that the app crashes on launch (iOS 12.4 simulator) with the following printed to the console:</p>
<blockquote>
<p>dyld: lazy symbol binding failed: can't resolve symbol
<strong>_$s7Combine9PublishedVMa</strong> in /Users/YYYYYYYYY/Library/Developer/CoreSimulator/Devices/UUD-UUD-UUD-UUD/data/Containers/Bundle/Application/UUD/XXXXXXX.app/XXXXXXX
because dependent dylib #29 could not be loaded dyld: can't resolve
symbol <strong>_$s7Combine9PublishedVMa</strong> in
/Users/YYYYYYYYY/Library/Developer/CoreSimulator/Devices/UUD-UUD-UUD-UUD/data/Containers/Bundle/Application/UUD-UUD-UUD-UUD/XXXXXXXapp/XXXXXXX
because dependent dylib #29 could not be loaded</p>
</blockquote>
<p>The app also crashes when attempting to launch on iPhone running iOS 12.4.</p>
<p>If I remove all <code>@Published</code> from the code but leave all other <code>Combine</code> and <code>SwiftUI</code> related bits  the app can be used on iOS 12.</p>
<p>Even though all the classes containing <code>@Published</code> are marked with <code>@available(iOS 13.0, *)</code> I have tried wrapping them additionally in #<code>if canImport(Combine)</code> or applying <code>#if canImport(Combine)</code> to each <code>@Published</code> variable. This does not help.</p>
<p>I know I could change</p>
<pre><code>@Published var name = &quot;&quot;
</code></pre>
<p>to</p>
<pre><code>var name = &quot;&quot; {
    willSet {
        objectWillChange.send()
    }
}
</code></pre>
<p>But that seems like a nasty workaround.</p>
<p>How can I increase deployment target to <strong>iOS 12.2</strong> and keep using <code>@Published</code> when device is running <strong>iOS 13.0</strong> or higher?</p>
","7948372","","","","","2020-08-31 17:11:08","How to conditionally use Combine @Published when minimum deployment target is set to iOS 12.2?","<ios><swift><combine>","2","3","1","","","CC BY-SA 4.0"
"63197832","1","63198186","","2020-07-31 19:12:54","","1","138","<p>I'm trying to observe change of an NSMutableOrderedSet in my ViewModel with combine.
I want to know when some element is added or removed of NSMutableOrderedSet</p>
<p>Some code of my ViewModel :</p>
<pre><code>    class TrainingAddExerciceViewModel: ObservableObject {
        
        @Published var exercice: Exercice?
        @Published var serieHistories = NSMutableOrderedSet()
    
    ...
      init(...) {
        ...
        
//Where i'm trying to observe 
        $serieHistories
            .sink { (value) in
                print(value)
        }
        .store(in: &amp;self.cancellables)
    }
    
    }
</code></pre>
<p>This is the function I use in my ViewModel to add element to NSMutableOrderedSet :</p>
<pre><code>func add(managedObjectContext: NSManagedObjectContext) {
        let newSerieHistory = ExerciceSerieHistory(context: managedObjectContext)
        self.serieHistories.add(newSerieHistory)
        self.updateView()
    }
</code></pre>
<p>I have some other publisher working well with an other type (custom class).</p>
<p>Did I miss something ?</p>
","3596283","","","","","2020-07-31 19:42:13","Detect change in NSMutableOrderedSet with Swift Combine","<swift><xcode><swiftui><combine><nsmutableset>","1","2","","","","CC BY-SA 4.0"
"63202303","1","63202346","","2020-08-01 06:02:32","","0","714","<p>Given an existing <code>CurrentValueSubject</code> instance, the goal is to create a new <code>Publisher</code> that will take the subject's stream of Strings, and in turn will output Ints.</p>
<p>My approach is to map the subject to <code>AnyPublisher</code>:</p>
<pre><code>let subject: CurrentValueSubject&lt;String, Never&gt; = ...

func intPublisher() -&gt; AnyPublisher&lt;Int, Never&gt;
{
    return subject.map { string in
        let value = Int(string) ?? 0
        return AnyPublisher&lt;Int, Never&gt;(value) // Error: Generic parameter P could not be inferred.
    }
}
</code></pre>
<p>However, I cannot create a new <code>AnyPublisher</code> this way. Clearly, my understanding of Publishers is flawed. Could someone please enlighten me?</p>
","1452758","","466862","","2020-08-01 06:13:08","2020-08-01 06:13:08","Convert Subject/Publisher to another Publisher","<swift><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"63202555","1","63202608","","2020-08-01 06:46:19","","2","3920","<p>I have the following code and Im getting the message error:</p>
<blockquote>
<p>'wrappedValue' is unavailable: @Published is only available on
properties of classes</p>
</blockquote>
<pre><code>//*
/**
Chat
Created on 29/07/2020
*/

import SwiftUI

let lightGreyColor = Color(red: 239.0/255.0, green: 243.0/255.0, blue: 244.0/255.0, opacity: 1.0)

struct ConnectionView: View {
    @ObservedObject var keyboardResponder = KeyboardResponder()
    @ObservedObject var viewModel = ConnectionVM()
//    @State var uuid1: String = &quot;&quot;
//    @State var uuid2: String = &quot;&quot;
    @State var authenticationDidFail: Bool = false
    
    var body: some View {
        return VStack {
            WelcomeText()
            LogoImage()
            UUIDTextField(uuid: viewModel.uuid1)
            UUIDTextField(uuid: viewModel.uuid2)
            if authenticationDidFail {
                Text(&quot;Information not correct. Try again.&quot;)
                .offset(y: -10)
                .foregroundColor(.red)
            }
            Button(action: {
                print(&quot;Button tapped&quot;)
            }) {
               LoginButtonContent()
            }
        }
        .padding()
        .offset(y: -keyboardResponder.currentHeight*0.5)
    }
    struct WelcomeText : View {
        var body: some View {
            return Text(&quot;Welcome!&quot;)
                .font(.largeTitle)
                .fontWeight(.semibold)
                .padding(.bottom, 20)
        }
    }
    struct LogoImage : View {
        var body: some View {
            return Image(&quot;logo&quot;)
                .resizable()
                .aspectRatio(contentMode: .fill)
                .frame(width: 150, height: 150)
                .clipped()
                .cornerRadius(150)
                .padding(.bottom, 75)
        }
    }
    struct UUIDTextField : View {
        @Published var uuid: String
        var body: some View {
        return TextField(&quot;UUID&quot;, text: $uuid)
                    .padding()
                    .background(lightGreyColor)
                    .cornerRadius(5.0)
                    .padding(.bottom, 20)
            }
    }
    struct LoginButtonContent : View {
        var body: some View {
            return Text(&quot;LOGIN&quot;)
                .font(.headline)
                .foregroundColor(.white)
                .padding()
                .frame(width: 220, height: 60)
                .background(Color.green)
                .cornerRadius(15.0)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ConnectionView()
    }
}
</code></pre>
<h1>My question is</h1>
<p>how can I pass @Published var by parameter to a subview .</p>
<p><a href=""https://i.stack.imgur.com/OKTBR.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OKTBR.png"" alt=""enter image description here"" /></a></p>
<h1>Update Question</h1>
<p>If i use Binding instead of published I get this error:</p>
<blockquote>
<p>Cannot convert value of type 'String' to expected argument type 'Binding'</p>
</blockquote>
<p><a href=""https://i.stack.imgur.com/F0HBl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/F0HBl.png"" alt=""enter image description here"" /></a></p>
","2139691","","2139691","","2020-08-01 06:59:05","2022-08-27 23:34:49","SwiftUI Combine: @Published is only available on properties of classes","<ios><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"63216302","1","","","2020-08-02 13:00:40","","1","463","<p>I am having a hard time managing the data that I want to pass to a
wrapped NSTableView View with SwiftUI. I tried using an <code>NSViewControllerRepresentable</code> but the problem is that my info is not getting updated as it should be.</p>
<p>I have a huge list (hundreds of thousands of items) of an <code>ObservableObject</code>:</p>
<pre><code>class FileObject: ObservableObject, Identifiable {
    var id : String
    @Published var line : String
    
    init(id : String, line : String) {
        self.id = id
        self.line = line
    }
}
</code></pre>
<p>This is how I am calling my <code>NSViewControllerRepresentable</code> inside SwiftUI:</p>
<pre><code>struct NSLinesList: View {
    @Binding var lines: [FileObject]
    
    var body: some View {
        LinesListTableRepresentable(objects: self.$lines)
    }
}
</code></pre>
<p>And this is the implementation of the NSViewController which contains a table view.</p>
<p>I have made the <code>Coordinator</code> to be the dataSource and the delegate of the tableView which is inside the NSViewController.</p>
<pre><code>private let kColumnIDContentId = &quot;number&quot;
private let kColumnIdContent = &quot;content&quot;


struct LinesListTableRepresentable: NSViewControllerRepresentable {
    typealias NSViewControllerType = LinesListViewController
    @Binding var objects : [FileObject]
    

    func makeCoordinator() -&gt; Coordinator {
        return Coordinator(self)
    }

    func makeNSViewController(context: Context) -&gt; LinesListViewController {
        let storyboard = NSStoryboard.init(name: .init(&quot;Main&quot;), bundle: nil)
        let controller = storyboard.instantiateController(withIdentifier: &quot;LinesListViewController&quot;) as! LinesListViewController
        return controller
    }

    func updateNSViewController(_ nsViewController: NSViewControllerType, context: Context) {
        nsViewController.tableView.dataSource = context.coordinator
        nsViewController.tableView.delegate = context.coordinator
    
        log.info(&quot;update the table view with \(self.objects.count) items&quot;)
        nsViewController.refresh()
    }
}

extension LinesListTableRepresentable {
    class Coordinator : NSObject, NSTableViewDelegate, NSTableViewDataSource {
        private let parent: LinesListTableRepresentable

        
        init(_ representable : LinesListTableRepresentable) {
            parent = representable
            super.init()
        }


        @objc public func numberOfRows(in tableView: NSTableView) -&gt; Int {
            log.info(&quot;current object count inside table view: \(self.parent.objects.count)&quot;)
            return self.parent.objects.count
        }

        @objc func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -&gt; NSView? {

            guard let columnId = tableColumn?.identifier else { return nil }
            let currentLine = self.parent.objects[row]

            switch columnId {
            case .init(kColumnIDContentId):
                let tableCellView = tableView.makeView(withIdentifier: NSUserInterfaceItemIdentifier(rawValue: &quot;lineNumbercell&quot;), owner: self) as! LogNumberTableCell
                tableCellView.contentField.stringValue = &quot;\(row)&quot;
                tableCellView.wantsLayer = true
                return tableCellView
            case .init(kColumnIdContent):
                let tableCellView = tableView.makeView(withIdentifier: NSUserInterfaceItemIdentifier(rawValue: &quot;lineContentCell&quot;), owner: self) as! LogContentTableCell
                tableCellView.contentField.stringValue = currentLine.line
            default:
                break
            }

            return nil
        }
    }
}

</code></pre>
<p>I am putting some objects inside the <code>objects</code>, and although the <code>LinesListTableRepresentable</code> is getting the <code>objects</code> updated, the <code>Coordinator</code> always has 0 items!</p>
<p>My console output is this one:</p>
<pre><code>2020-08-02T15:56:21+0300 info: update the table view with 2275 items
2020-08-02T15:56:21+0300 info: current object count inside table view: 0
</code></pre>
<p>So it seems that the <code>self.parent.objects.count</code> is always zero.</p>
<p>Can someone help with this?</p>
","737457","","737457","","2020-08-02 15:44:05","2020-08-02 15:44:05","Wrapping NSTableView with Swift UI: How to use Bindings?","<ios><macos><swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"63227995","1","","","2020-08-03 10:44:17","","0","486","<p>I wish to observe an ongoing series of values, and process each value as it is received. The act of handling the value may cause a new value to be generated and posted. This is the cause of reentrancy problems.</p>
<p>The original code was written in <code>RxSwift</code> and the reentrancy problem was dealt with by the use of an async scheduler:</p>
<pre><code>eventSubject
    .asObservable()
    .observeOn(MainScheduler.asyncInstance)
    .subscribe(onNext: { [weak self] event in
        self?.handleEvent(event)
    })
    .disposed(by: disposeBag)
</code></pre>
<p>I would like to do the same with <code>Combine</code>, but am confused as to my options.</p>
<pre><code>enum Event { case foo, bar, baz }

@Published var eventFlow: Event = .foo

...

$eventFlow
    .receive(on: RunLoop.main)
    .sink { [weak self] event in
        DispatchQueue.main.async { [weak self] in
            self?.handleEvent(event)
        }
    }
    .store(in: &amp;cancelBag)
</code></pre>
<p>Q. is this a valid approach? Is the '<code>receive(on: RunLoop.main)</code>' required?</p>
<p>And/or should I be subscribing on a queue, such as <code>DispatchQueue.global()</code>, and foregoing the <code>DispatchQueue.main.async</code> call?</p>
<p>Any suggestions are welcome.</p>
","1452758","","","","","2020-08-03 10:48:06","Swift Combine: handle async at subscription level or receive level?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63236727","1","","","2020-08-03 20:44:50","","1","301","<p>I have some code that makes a request to the net when the count value changes</p>
<pre><code>@Published var count: Float = 0

init(data: SomeData) {
///
   $count
      .debounce(for: .seconds(1), scheduler: RunLoop.main)
      .filter { return $0 != self.product.quantity }
      .setFailureType(to: APIProviderError.self)
      .flatMap { val -&gt; AnyPublisher&lt;Cart, APIProviderError&gt; in
            return self.cartService.update(item: params)
         }
      }
      .sink { result in
         print(result)
      } receiveValue: { cart in
         print(cart)
      }
      .store(in: &amp;cancellable)
///
}
</code></pre>
<p>The cartService.update return dataTaskPublisher.</p>
<p><strong>When any error is returned, the flatmap is never called again.</strong>
Can I restart it?</p>
","4137436","","","","","2020-08-03 20:54:14","How to restart dataTaskPublisher after failure?","<ios><swift><reactive-programming><combine>","1","1","","","","CC BY-SA 4.0"
"63237595","1","63254603","","2020-08-03 22:08:17","","1","1225","<p>I have an API that may return a JSON array of JSON objects or a single JSON object.</p>
<p>How do I write a combine publisher pipeline that handles this case?</p>
<p>I normally hard-code the type of the JSON-response when I add my combine decode operator to my pipeline:</p>
<pre><code>.decode(type: [MyArrayType].self, decoder: JSONDecoder())
.decode(type: MyObjectType.self, decoder: JSONDecoder())
</code></pre>
","3572929","","","","","2020-08-05 14:14:30","Combine JSON decoding pipeline, when response can be an array or an object at runtime","<json><swift><combine>","1","4","","","","CC BY-SA 4.0"
"63239813","1","63239902","","2020-08-04 03:27:19","","2","367","<p>I want to try <code>Combine</code> framework, very simple usage, press a <code>UIButton</code>, and update <code>UILabel</code>.</p>
<p>My idea is:</p>
<ol>
<li>Add a publisher</li>
</ol>
<p><code>@Published var cacheText: String?</code></p>
<ol start=""2"">
<li>Subscribe</li>
</ol>
<p><code>$cacheText.assign(to: \.text, on: cacheLabel)</code></p>
<ol start=""3"">
<li>assign a value when button pressed.</li>
</ol>
<p><code>cacheText = &quot;testString&quot;</code></p>
<p>Then the label's text should be updated.</p>
<p>The problem is when the button pressed, the <code>@Published</code> value is updated, but the <code>UILabel</code> value doesn't change.
e.g the <code>cacheLabel1</code> was assigned <code>123</code> initially but not <code>789</code> when button pressed.</p>
<p>Here's the full code:</p>
<p><strong>ViewModel.swift</strong></p>
<pre><code>import Foundation
import Combine

class ViewModel {
    @Published var cacheText: String?

    func setup(_ text: String) {
        cacheText = text
    }

    init() {
        setup(&quot;123&quot;)
    }
}
</code></pre>
<p><strong>ViewController.swift</strong></p>
<pre><code>  class ViewController: UIViewController {
    @IBOutlet weak var cacheLabel: UILabel!

    var viewModel = ViewModel()

    @IBAction func buttonPressed(_ sender: Any) {
        viewModel.setup(&quot;789&quot;)
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        viewModel.$cacheText.assign(to: \.text, on: cacheLabel)
    }
}
</code></pre>
<p>Not sure if I missed something, thanks for the help.</p>
","291240","","","","","2020-08-04 03:37:38","Combine Framework Update UI doesn't work properly","<ios><swift><combine>","1","0","1","","","CC BY-SA 4.0"
"63246040","1","63247810","","2020-08-04 11:35:04","","1","359","<p>I am trying to make a UITextView that edits a value <code>currentDisplayedAddress</code>. The value is also changed by other views, and I want the UITextView to update its text when that occurs.</p>
<p>The view initializes correctly, and I can edit <code>currentDisplayedAddress</code> from <code>AddressTextField</code> with no problem and trigger relevant view updates. However, when the value is changed by other views, the textField's text does not change, even though <code>textField.text</code> prints the correct updated value inside <code>updateUIView</code> and other views update accordingly.</p>
<p>I have no idea what may have caused this. Any help is extremely appreciated.</p>
<pre><code>struct AddressTextField: UIViewRepresentable {
    private let textField = UITextField(frame: .zero)
    var commit: () -&gt; Void
    @EnvironmentObject var userData: UserDataModel

    func makeUIView(context: UIViewRepresentableContext&lt;AddressTextField&gt;) -&gt; UITextField {
        textField.text = self.userData.currentDisplayedAddress
        textField.delegate = context.coordinator
        return textField
    }

    func updateUIView(_ uiView: UITextField, context: UIViewRepresentableContext&lt;AddressTextField&gt;) {
        if self.textField.text != self.userData.currentDisplayedAddress {
        DispatchQueue.main.async {
            self.textField.text = self.userData.currentDisplayedAddress
            }
        }
    }

   (...)

    func makeCoordinator() -&gt; Coordinator { Coordinator(self) }

    class Coordinator: NSObject, UITextFieldDelegate {
        var addressTextField: AddressTextField

        func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {   //delegate method
            textField.resignFirstResponder()
            addressTextField.userData.currentDisplayedAddress = textField.text ?? String()
            addressTextField.commit()
            return true
        }
    }
}
</code></pre>
","7857053","","","","","2020-08-04 13:20:50","UITextField not updating to change in ObservableObject (SwiftUI)","<swiftui><combine><observableobject>","1","0","","","","CC BY-SA 4.0"
"63256563","1","63257257","","2020-08-04 23:51:41","","0","237","<p>My testbed looks like this:</p>
<pre><code>var storage = Set&lt;AnyCancellable&gt;()
override func viewDidLoad() {
    let pub = Timer.publish(every: 0.2, on: .main, in: .common).autoconnect()
        .scan(0) {i,_ in i+1}
        .buffer(size: 4, prefetch: .keepFull, whenFull: .dropNewest)
        .flatMap(maxPublishers:.max(1)) {
            Just($0).delay(for: 2, scheduler: DispatchQueue.main)
        }
    pub.sink{print($0)}.store(in:&amp;storage)
}
</code></pre>
<p>The result is just a slow steady stream of numbers in succession: 1 2 3 4 5 6 ...</p>
<p>But that is the same result you would get if you just deleted the <code>.buffer</code> line entirely. So what purpose does the buffer serve? To put it another way: can someone make me an example where a buffer with a <code>.keepFull</code> prefetch policy makes a difference?</p>
","341994","","","","","2021-05-11 03:16:28","Combine framework buffer operator with keepFull strategy: what does it do?","<ios><combine>","1","2","","","","CC BY-SA 4.0"
"63257185","1","","","2020-08-05 01:33:36","","0","387","<p>I am scratching my head since two days, but the new SwiftUI navigation part is kind of weird to me.</p>
<p>Short description of my issue:
I have a ViewA, it contains 3 subviews (Subview1,Subview2,Subview3). In each of them I have 2 or 3 buttons (Subview1ButtonA, Subview1ButtonB, Subview1ButtonC).
I wanna push different view depending on which button is tapped.
Before, we needed to be in the ViewA to be able to push a view by using a callback, notifications, whatever to notify ViewA that we want to push a ViewB for example.
Here, with SwiftUI, I don't understand at all what it expect us to do with <code>NavigationLink</code>.</p>
<p>Here's is my sample code for demonstrate my use case.</p>
<pre><code>// MainView.swift

final class State: ObservableObject {
    // Close allow me to close my ViewA, it is a modal and I have a button X integrated
    // in Subview1ButtonA
    @Published var closePressed: Bool = false
    @Published var isView2Presented: Bool = false
}

struct ViewA: View {
    @ObservedObject var state = State()

    var body: some View {
        NavigationView {
            VStack(content: {
                 NavigationLink(destination: View2(isPresented: self.$state.isView2Presented),
                                isActive: self.$state.isView2Presented) {
                                ViewB(closePressed: self.$state.closePressed,
                                      view2Pressed: self.$state.isView2Presented)
                 }
            })
        }
    }
}

</code></pre>
<p>If I have a third button in ViewB how does it work since it is only one <code>NavigationLink</code> here..?
It is really confusing to me to be honest.</p>
<p>Thank you for any further help!</p>
<p>Edit:</p>
<p>I have a MainView, I have a couple subview in this MainView (lets say block of view pulled together to form the MainView) In this blocks, I have a couple buttons, and each button needs to open a different View. I am not sure to understand how to implement my navigation stuff here.</p>
","5899647","","5899647","","2020-08-05 18:28:44","2020-08-05 18:28:44","SwiftUI Push multiple View with button clicked in embedded subviews","<swift><xcode><navigation><swiftui><combine>","0","3","1","","","CC BY-SA 4.0"
"63263824","1","63263859","","2020-08-05 11:04:31","","0","24","<p>from this link <a href=""https://developer.apple.com/documentation/combine/publishers/merge/share()"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/combine/publishers/merge/share()</a></p>
<pre><code>let pub = (1...3).publisher
.delay(for: 1, scheduler: DispatchQueue.main)
.map( { _ in return Int.random(in: 0...100) } )
.print(&quot;Random&quot;)
.share()

cancellable1 = pub
.sink { print (&quot;Stream 1 received: \($0)&quot;)}
cancellable2 = pub
.sink { print (&quot;Stream 2 received: \($0)&quot;)}

// Prints:
// Random: receive value: (20)
// Stream 1 received: 20
// Stream 2 received: 20
// Random: receive value: (85)
// Stream 1 received: 85
// Stream 2 received: 85
// Random: receive value: (98)
// Stream 1 received: 98
// Stream 2 received: 98
</code></pre>
<p>but if I do like this below, share doesn't work as I expected</p>
<pre><code>var pub: Publishers.Share&lt;AnyPublisher&lt;Int, Never&gt;&gt; {
    (1...3).publisher
        .delay(for: 1, scheduler: DispatchQueue.main)
        .map( { _ in return Int.random(in: 0...100) } )
        .print(&quot;Random&quot;)
        .eraseToAnyPublisher()
        .share()
}
cancellable1 = pub
.sink { print (&quot;Stream 1 received: \($0)&quot;)}
cancellable2 = pub
.sink { print (&quot;Stream 2 received: \($0)&quot;)}

// Prints:    
// Random: receive value: (99)
// Stream 1 received: 99
// Random: receive value: (56)
// Stream 1 received: 56
// Random: receive value: (38)
// Stream 1 received: 38
// Random: receive finished
// Random: receive value: (98)
// Stream 2 received: 98
// Random: receive value: (11)
// Stream 2 received: 11
// Random: receive value: (32)
// Stream 2 received: 32
</code></pre>
<p>Why share doesn't work with the second case?</p>
","12208004","","4667835","","2020-08-05 11:07:38","2020-08-05 11:07:38","Is this a normal behavior about Publisher.Share","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63269415","1","63286820","","2020-08-05 16:22:01","","0","154","<p>To show my the content from my root view after successful login, I tried with <code>ObservedObject</code>, and with <code>EnvironmentObject</code>, to no avail.</p>
<p>E.g. as follows:</p>
<pre class=""lang-swift prettyprint-override""><code>struct RootView: View {

    @EnvironmentObject var loginManager: LoginManager

    var body: some View {
        Group {
            if loginManager.isLoggedIn {
                SegmentedView()
            }
            else {
                WelcomeView()
            }
        }
    }
}

class LoginManager: ObservableObject {
    
    static let shared = LoginManager()
    var cancellable = Set&lt;AnyCancellable&gt;()
    @Published var isLoggedIn = false

    ...
    
    func login(...) {
        ...
        // on success
        self.isLoggedIn = true
    }
</code></pre>
<p>The <code>LoginManager</code> is retained in the <code>SceneDelegate</code> and put into the environment:</p>
<pre><code>class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?
    var loginManager = LoginManager.shared
    ...

    // the view passed to window.rootUiewController via UIHostingController
    let contentView = RootView().environmentObject(loginManager)
</code></pre>
<p>After logging in, it goes right back to my <code>WelcomeView</code>. What am I missing?</p>
<p><strong>EDIT</strong></p>
<p>Here is a new aspect. I have a view model for the <code>LoginView</code> to manage the data in date fields. When the login button is pressed, I call a <code>login()</code> method in this view model.</p>
<p>I need to two <code>.sink</code> callbacks in the view model, because I have to dismiss the loading indicator by setting a <code>loading</code> flag to false.</p>
<p>So I cannot call <code>self.isLoggedIn = true</code> directly because I am in the view model, not the <code>LoginManager</code>. Instead I call</p>
<pre><code>self.loginManager.isLoggedIn = true 
</code></pre>
<p>and I suspect that this line is not working.</p>
<p>The connection between view model and login manager is done like this</p>
<pre><code>@ObservedObject var loginManager = LoginManager.shared
</code></pre>
<p>However, after shifting this to the <code>LoginManager</code>, I am indeed calling <code>self.isLoggedIn</code> from there. It is still not working.</p>
<p>I have two theses:</p>
<ol>
<li><p>It could be that the view is not set up correctly with <code>Group</code> etc. I also tried to use <code>@ViewBuilder</code> etc, no difference.</p>
</li>
<li><p>It could be that somehow there are two instances of <code>LoginManager</code>, or the <code>RootView</code> somehow get's reinitialised with a new instance where <code>isLoggedIn</code> is false. But I have been creating Swift singletons like this for ages:</p>
<p>static let shared = LoginManager()</p>
</li>
</ol>
<p>and never had any problems.</p>
<p>As mentioned in the comments, there is another error I encountered when switching all to <code>@EnvironmentObject</code>:</p>
<blockquote>
<p><code>Fatal error: No ObservableObject of type LoginManager found. A View.environmentObject(_:) for LoginManager may be missing as an ancestor of this view.: file SwiftUI, line 0</code></p>
</blockquote>
","427083","","427083","","2020-08-06 13:58:15","2020-08-06 15:24:58","SwiftUI ObservedObject not updating view after successful login","<swift><swiftui><combine><observedobject>","1","11","","","","CC BY-SA 4.0"
"63273416","1","","","2020-08-05 21:00:14","","0","771","<p>I have a function which access data from my server. The server can either return a JSON object of type <code>Player</code>:</p>
<pre><code>{&quot;id&quot;:&quot;6B38EF76-6BBC-4423-BCB6-FD9F9B5E7A6F&quot;,&quot;ign&quot;:&quot;Shard&quot;,&quot;region&quot;:&quot;eu&quot;,&quot;rating&quot;:1000}
</code></pre>
<p>or of type <code>Standard Response</code>:</p>
<pre><code>{&quot;statusCode&quot;:4,&quot;description&quot;:&quot;Invalid Arguments&quot;}
</code></pre>
<p>I have a function with the following pattern:</p>
<pre><code>fetch&lt;T: Decodable&gt;(from endpoint: Endpoint) -&gt; AnyPublisher&lt;T, DatabaseError&gt;
</code></pre>
<p>This function access the server via a data task publisher and decodes the result into a generic T using combine's built in decode operator:</p>
<pre><code>.decode(type: T.self, decoder: JSONDecoder())
</code></pre>
<p>I have the two types of response I showed above modelled as structs with the relevant coding keys etc and this part of the code works fine.</p>
<p>I use the fetch function inside a different function which passes it the relevant endpoint</p>
<pre><code>func getPlayerDetails(of id: UUID) -&gt; AnyPublisher&lt;Player, DatabaseError&gt; {
    return fetch(from: .getDetails(of: id, isTeam: false))
}
</code></pre>
<p>As you can see this function returns the publisher with <code>Player</code> as the output. My question is how can I check the generic output of <code>fetch(from:)</code> and if it is a player object, pass that through, and if not return my custom error <code>DatabaseError</code>?</p>
<p>Thanks</p>
","9682666","","","","","2020-08-06 22:28:01","Check type of generic Combine Publisher Output Swift","<swift><reactive-programming><combine>","1","4","","","","CC BY-SA 4.0"
"63282377","1","63289139","","2020-08-06 11:14:32","","36","23817","<p>When trying to compile the following code:</p>
<pre><code>class LoginViewModel: ObservableObject, Identifiable {
    @Published var mailAdress: String = &quot;&quot;
    @Published var password: String = &quot;&quot;
    @Published var showRegister = false
    @Published var showPasswordReset = false

    private let applicationStore: ApplicationStore

    init(applicationStore: ApplicationStore) {
        self.applicationStore = applicationStore
    }

    var passwordResetView: some View {
        PasswordResetView(isPresented: $showPasswordReset) // This is where the error happens
    }
}
</code></pre>
<p>Where PasswordResetView looks like this:</p>
<pre><code>struct PasswordResetView: View {
    @Binding var isPresented: Bool
    @State var mailAddress: String = &quot;&quot;
    
    var body: some View {
            EmptyView()
        }
    }
}
</code></pre>
<p>I get the error compile error</p>
<pre><code>Cannot convert value of type 'Published&lt;Bool&gt;.Publisher' to expected argument type 'Binding&lt;Bool&gt;'
</code></pre>
<p>If I use the published variable from outside the LoginViewModel class it just works fine:</p>
<pre><code>struct LoginView: View {
    @ObservedObject var viewModel: LoginViewModel

    init(viewModel: LoginViewModel) {
      self.viewModel = viewModel
    }
    
    var body: some View {
            PasswordResetView(isPresented: self.$viewModel.showPasswordReset)
    }
}
</code></pre>
<p>Any suggestions what I am doing wrong here? Any chance I can pass a published variable as a binding from inside the owning class?</p>
<p>Thanks!</p>
","14059662","","","","","2022-02-12 11:51:30","Cannot convert value of type 'Published<Bool>.Publisher' to expected argument type 'Binding<Bool>'","<ios><swift><swiftui><combine>","5","3","","","","CC BY-SA 4.0"
"63307322","1","","","2020-08-07 18:23:48","","2","77","<p>I have a Swift publisher like the following</p>
<pre><code>let item = PassthrogutSubject&lt;String, Never&gt;()
</code></pre>
<p>Upon receiving the String I want to make a network request</p>
<p>For that, I'm using <code>flatMap</code></p>
<p>My network request signature looks like this:</p>
<pre><code>func loadDetails(_ code: String) -&gt; AnyPublisher&lt;CustomType, ErrorAlert&gt;
</code></pre>
<p>How can I do the following:</p>
<pre class=""lang-swift prettyprint-override""><code>$item
 .filter { !$0.isEmpty }
 .flatMap { [unowned self] (string) in
    self.viewModel.loadDetails(string) }
 .receive(on: DispatchQueue.main)
 .sink(receiveCompletion: { _ in
     ...
  }) {  ... }
 .store(in: &amp;subscriptions)
</code></pre>
<p>error:</p>
<p><code>Instance method 'flatMap(maxPublishers:_:)' requires the types 'Published&lt;Value&gt;.Publisher.Failure' (aka 'Never') and 'Alert' be equivalent</code></p>
","3526949","","8697793","","2020-08-07 18:42:49","2020-08-07 18:42:49","`flatMap` publishers with different Errors","<ios><swift><networking><functional-programming><combine>","1","0","","","","CC BY-SA 4.0"
"63307920","1","","","2020-08-07 19:14:01","","1","456","<p>How would I use swift combine to get the key of the first TrailVideo object who's site is &quot;YouTube&quot;. I feel like I need a flatMap somewhere but I'm not entirely sure.</p>
<pre><code>struct TrailerVideoResult: Codable {
   let results : [TrailerVideo]
}

struct TrailerVideo: Codable {
    let key: String
    let site: String
}

class Testing{
    //Should output the key of the first TrailVideo object who's site is &quot;YouTube&quot;

    func getYoutubeKey()-&gt; AnyPublisher&lt;String, Error&gt;{
        return URLSession.shared.dataTaskPublisher(for: URL(string: &quot;&quot;)!)
            .map(\.data)
            .decode(type: TrailerVideoResult.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .map(\.results)
            .map(\.sites)
            .eraseToAnyPublisher()
    }
}
</code></pre>
","10830089","","","","","2020-08-07 20:46:06","Reduce an array to a single value with Combine","<swift><combine>","2","1","","","","CC BY-SA 4.0"
"63312902","1","63317429","","2020-08-08 07:35:12","","0","733","<p>If I have a Subject and subscribe it from many places like below, should I use .share()? Or .share() does nothing in this case?</p>
<pre><code>let sampleSubject = CurrentValueSubject&lt;String, Never&gt;(&quot;&quot;)
sampleSubject.sink { print($0) }
sampleSubject.sink { print($0) }
sampleSubject.sink { print($0) }
sampleSubject.sink { print($0) }
  
</code></pre>
<pre><code>let sharedSampleSubject = sampleSubject.share()
sharedSampleSubject.sink { print($0) }
sharedSampleSubject.sink { print($0) }
sharedSampleSubject.sink { print($0) }
sharedSampleSubject.sink { print($0) }
</code></pre>
","12208004","","","","","2021-05-11 17:14:56","How to use .share() with Subject [Swift Combine]","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63315649","1","","","2020-08-08 12:54:26","","2","534","<p>How to replace closure or delegation callback which get called when user tap on a button of a table view cell with <strong>Combine framework</strong> ?</p>
<p>problem - if Subscriber is added from the view controller and store returned AnyCancellable in a Set ; 1. storage of anyCancellable is getting heigh as cell return .2. many subscribers receive value when user tap on one button of a cell</p>
<p>I used built in subscriber <strong>Sink</strong></p>
<p><strong>In ViewController</strong></p>
<pre><code> var myAnyCancellableSet: Set&lt;AnyCancellable&gt; = []

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;mycell&quot;)
        cell.doSomethingSubject.sink { 
print(&quot;user tap button on cell&quot;)
                            }.store(in: &amp;myAnyCancellableSet)
        return cell
                    }
</code></pre>
<p><strong>In tableview cell</strong></p>
<pre><code>import UIKit
import Combine

class MyTableViewCell: UITableViewCell {
   
    private lazy var myDoSomethingSubject = PassthroughSubject&lt;Void, Never&gt;()
    lazy var doSomethingSubject = myDoSomethingSubject.eraseToAnyPublisher()
    
   @IBAction func buttonTapped(_ sender: UIButton) {
        myDoSomethingSubject.send()
    }

}
</code></pre>
","9440709","","9440709","","2020-08-08 16:28:32","2020-08-08 20:22:48","Combine Migration?","<ios><swift><combine>","1","4","2","","","CC BY-SA 4.0"
"63321923","1","63322147","","2020-08-09 02:22:10","","2","1014","<p>I have the following SwiftUI view which contains a subview that fades away after five seconds. The fade is triggered by receiving the result of a Combine TimePublisher, but changing the value of <code>showRedView</code> in the <code>sink</code> publisher's sink block is causing a memory leak.</p>
<pre><code>import Combine
import SwiftUI

struct ContentView: View {
    @State var showRedView = true

    @State var subscriptions: Set&lt;AnyCancellable&gt; = []
    
    var body: some View {
        ZStack {
            if showRedView {
                Color.red
                    .transition(.opacity)
            }
            Text(&quot;Hello, world!&quot;)
                .padding()
        }
        .onAppear {
            fadeRedView()
        }
    }
    
    func fadeRedView() {
        Timer.publish(every: 5.0, on: .main, in: .default)
            .autoconnect()
            .prefix(1)
            .sink { _ in
                withAnimation {
                    showRedView = false
                }
            }
            .store(in: &amp;subscriptions)
    }
}
</code></pre>
<p>I thought this was somehow managed behind the scenes with the <code>AnyCancellable</code> collection. I'm relatively new to SwiftUI and Combine, so sure I'm either messing something up here or not thinking about it correctly. What's the best way to avoid this leak?</p>
<p>Edit: Adding some pictures showing the leak.</p>
<p><a href=""https://i.stack.imgur.com/2izeq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2izeq.png"" alt=""Memory leak pic 1"" /></a></p>
<p><a href=""https://i.stack.imgur.com/nWYZB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nWYZB.png"" alt=""Memory leak pic 2"" /></a></p>
","1306952","","1306952","","2020-08-11 04:20:03","2020-08-12 14:50:19","How can I avoid this SwiftUI + Combine Timer Publisher reference cycle / memory leak?","<ios><swiftui><combine><xcode12>","2","3","","","","CC BY-SA 4.0"
"63330229","1","63331266","","2020-08-09 19:03:17","","1","262","<p>I am using a class to store a @Published variable but when I try to pass the value chosen on my custom DatePicker to the @ObservedObject in the class I receive the following error:</p>
<pre><code>TimePicker(time: self.$time.**timeSelected**)
</code></pre>
<blockquote>
<p>Cannot convert value of type 'Binding' (aka
'Binding') to expected argument type 'TimeModel'</p>
</blockquote>
<p>How do I update the @ObservedObject with the picker value?</p>
<p>Full code:</p>
<pre><code>struct ContentView: View {
    
    @ObservedObject var time = TimeModel()

    var body: some View {

        ZStack{
            VStack{
                TimePicker(time: self.$time.timeSelected)
                
                Text(&quot;You chose \(time.timeSelected/60) minutes&quot;)
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

class TimeModel: ObservableObject{
     @Published var timeSelected: TimeInterval = 1.0
}
    

struct TimePicker: UIViewRepresentable {
    
    @ObservedObject var time = TimeModel()
    
    func makeUIView(context: Context) -&gt; UIDatePicker {
        let datePicker = UIDatePicker()
        datePicker.datePickerMode = .countDownTimer
        datePicker.addTarget(context.coordinator,
                             action: #selector(Coordinator.updateTime),
                             for: .valueChanged)
        return datePicker
    }
    
    func updateUIView(_ datePicker: UIDatePicker, context: Context) {
        datePicker.minuteInterval = 5
        datePicker.countDownDuration = time.timeSelected
    }
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject {
        let parent: TimePicker
        
        init(_ parent: TimePicker) {
            self.parent = parent
        }
        
        @objc func updateTime(datePicker: UIDatePicker) {
            parent.time.timeSelected = datePicker.countDownDuration
        }
    }
}
</code></pre>
","12349248","","8697793","","2020-09-19 18:26:58","2020-09-19 18:26:58","Swift UI DatePicker won't update @ObservedObject value","<swift><datepicker><swiftui><combine><observedobject>","1","0","","","","CC BY-SA 4.0"
"63343693","1","63351794","","2020-08-10 15:57:55","","0","328","<p>I'm building a UI where in the view I want to either show an &quot;Enable&quot; button or a green check mark based on whether HealthKit has been authorized or not.  I also want the view to be reactive so that as soon as you authorize HealthKit the view dynamically changes from the button to the check mark, but I can't figure out how to get this two way communication right and which property wrapper to use:</p>
<pre><code>struct SetUpWatchView: View {

    let healthKitAuthManager = HealthKitAuthManager()
@ViewBuilder
    var body: some View {
            VStack(alignment: .leading) {
                HStack {
                     Image(systemName: &quot;heart.circle.fill&quot;)
                     .foregroundColor(.red)
                      .font(.system(size: 56.0, weight: .bold))
                      .frame(width: 65, height: 65)
                    VStack(alignment: .leading) {
                        Text(&quot;Health Integration&quot;)
                            .fontWeight(.bold)
                        Text(&quot;Enable in Order to Track your Speed, Distance, and Heart Rate.&quot;)
                    }
                    Spacer()
                    if healthKitAuthManager.healthKitIsAuthorized {
                        Image(systemName: &quot;checkmark.circle.fill&quot;)
                            .foregroundColor(.green)
                            .font(.system(size: 30.0, weight: .bold))
                             .padding(.horizontal)
                    } else {
                        Button(action: {
                            healthKitAuthManager.authorizeHealthKit()
                        }) {
                            Text(&quot;ENABLE&quot;)
                                .fontWeight(.bold)
                                .foregroundColor(Color.black)
                        }
                        .padding(.horizontal)
                    }
                }
                .padding([.leading, .bottom])
            }.onAppear {
                healthKitAuthManager.checkWhetherHealthKitDatAvailableAndIfAuthorized()
            }
        }
    }
}



class HealthKitAuthManager: ObservableObject {
    
    let healthStore = HKHealthStore()
    
    @Published var healthKitIsAuthorized = false
    
     public func checkWhetherHealthKitDatAvailableAndIfAuthorized()  {
        
        if HKHealthStore.isHealthDataAvailable() {
            
            let authorizationStatus = healthStore.authorizationStatus(for: HKSampleType.workoutType())
            switch authorizationStatus {
            case .sharingAuthorized:
                
                healthKitIsAuthorized = true
                
            case .sharingDenied: ()
             healthKitIsAuthorized = false
            default:()
              healthKitIsAuthorized = false
            }
            
        }
        else {
            healthKitIsAuthorized = false 
        }
    }

    public func authorizeHealthKit() {

        let healthKitTypesToWrite: Set&lt;HKSampleType&gt; = [
            HKObjectType.workoutType(),
            HKSeriesType.workoutRoute(),
            HKObjectType.quantityType(forIdentifier: .activeEnergyBurned)!,
            HKObjectType.quantityType(forIdentifier: .heartRate)!,
            HKObjectType.quantityType(forIdentifier: .restingHeartRate)!,
            HKObjectType.quantityType(forIdentifier: .bodyMass)!,
            HKObjectType.quantityType(forIdentifier: .vo2Max)!,
            HKObjectType.quantityType(forIdentifier: .stepCount)!,
            HKObjectType.quantityType(forIdentifier: .distanceWalkingRunning)!]

        let healthKitTypesToRead: Set&lt;HKObjectType&gt; = [
            HKObjectType.workoutType(),
            HKSeriesType.workoutRoute(),
            HKObjectType.quantityType(forIdentifier: .activeEnergyBurned)!,
            HKObjectType.quantityType(forIdentifier: .heartRate)!,
            HKObjectType.quantityType(forIdentifier: .restingHeartRate)!,
            HKObjectType.characteristicType(forIdentifier: .dateOfBirth)!,
            HKObjectType.quantityType(forIdentifier: .bodyMass)!,
            HKObjectType.quantityType(forIdentifier: .vo2Max)!,
            HKObjectType.quantityType(forIdentifier: .stepCount)!,
            HKObjectType.quantityType(forIdentifier: .distanceWalkingRunning)!]

        let authorizationStatus = HKHealthStore().authorizationStatus(for: HKSampleType.workoutType())

        switch authorizationStatus {

        case .sharingAuthorized:

            print(&quot;Sharing Authorized&quot;)
            healthKitIsAuthorized = true

        case .sharingDenied: print(&quot;sharing denied&quot;)

        //Success does NOT necessarily mean we are authorized, only that the request was successfully delivered.  Also if a user chooses not to authorize, if you call .requestAuthorization again you won't get the action sheet
        HKHealthStore().requestAuthorization(toShare: healthKitTypesToWrite, read: healthKitTypesToRead) { (success, error) in
            if !success {
                print(&quot;failed HealthKit Authorization from iPhone SetUpWatchVC \(String(describing: error?.localizedDescription))&quot;)
            }

            print(&quot;Successful HealthKit Authorization from iPhone&quot;)
            }

        default: print(&quot;not determined&quot;)

        HKHealthStore().requestAuthorization(toShare: healthKitTypesToWrite, read: healthKitTypesToRead) { (success, error) in
            if !success {
                print(&quot;failed HealthKit Authorization from iPhone SetUpWatchVC \(String(describing: error?.localizedDescription))&quot;)
            }

            print(&quot;Successful HealthKit Authorization from iPhone SetUpWatchVC&quot;)

            }

        }



    }

}
</code></pre>
","4625622","","","","","2020-08-11 05:03:58","Using SwiftUI and Combine to conditionally display a view based on authorization status?","<ios><swift><swiftui><healthkit><combine>","1","0","1","","","CC BY-SA 4.0"
"63346175","1","","","2020-08-10 18:43:45","","2","2479","<p>I want to be able to pass a reference to a @Published property in as a parameter so that other objects can use, edit, and view the data on the property, and I want to do it while keeping the functionality of Property wrappers in Swift</p>
<p>Here is my example. I create a MainStore object. It has an array of names which is @Published. I can use this object all across my app, I can change the data in <code>names</code> and anywhere that subscribes will get the update.</p>
<pre><code>class MainStore {
    @Published var names: [String]
    
    init(names: [String]) {
        self.names = names
    }
}
</code></pre>
<p>Now I want to create a second Store. This has a bit of additional functionality, and it needs to be more focused but I want it to reference the <code>names</code> property from the MainStore. When MainStore.names is updated, I want SecondStore.names to be updated as well. When SecondStore.names is updated, I want MainStore.names to be updated as well.</p>
<pre><code>class SecondStore {
    
    @Published var names: [String]
    
    init(@Published names: [String]) {
        self.names = names
    }
}
</code></pre>
<p>I want the syntax of a @Published property wrapper as well</p>
<p>eg <code>SecondStore.names.append(&quot;Billy&quot;)</code> and <code>SecondStore.$names.sink() { }</code></p>
<p>Is there a way to do this, if not what is the recommended practice to accomplish my general direction?</p>
","3786510","","","","","2020-08-10 19:03:19","@Published as a function argument with Swift Combine","<swift><combine>","1","1","1","","","CC BY-SA 4.0"
"63348777","1","","","2020-08-10 22:19:30","","0","248","<p>Let's say we have:</p>
<pre><code>Array&lt;AnyPublisher&lt;T,Never&gt;&gt;
</code></pre>
<p>And we want to convert it into</p>
<pre><code>AnyPublisher&lt;Array&lt;t&gt;,Never&gt;&gt;
</code></pre>
<p>What approach would you take to solve this?</p>
","6276472","","","","","2020-08-10 22:19:30","How to convert an array of publishers to one publisher of an array","<swift><combine>","0","5","","","","CC BY-SA 4.0"
"63387000","1","","","2020-08-13 01:51:54","","0","82","<p>I use combine with code:</p>
<pre><code>Publishers.CombineLatest($schoolId, $offset)
        .filter { $0.0 &gt; 0 &amp;&amp; $0.1 &gt;= 0 }
        .removeDuplicates(by: { (prev, current) -&gt; Bool in
            prev.0 == current.0 &amp;&amp; prev.1 == current.1
        })
        .debounce(for: .seconds(0.3), scheduler: DispatchQueue.main)
        .map { APIClient.default.request(forRoute: GetMoreCommentRouter(params: [&quot;schoolId&quot;: String($0.0), &quot;offset&quot;: String($0.1)], method: .get), forType: [CommentModel].self)
            .receive(on: DispatchQueue.main)
            .replaceError(with: [])
            .handleEvents(receiveSubscription: { [weak self] _ in
                self?.isLoading = true
                }, receiveCompletion: { [weak self] _ in
                    self?.isLoading = false
                    self?.currentText = &quot;No comment here.&quot;
                }, receiveCancel: { [ weak self] in
                    self?.isLoading = false
                    self?.currentText = &quot;Error from server!&quot;
            }) }
        .switchToLatest()
        .receive(on: DispatchQueue.main)
        .assign(to: \.commentList, on: self)
        .store(in: &amp;disposeStore)
</code></pre>
<p>when I change offset, the API call again. I want to append new data from server to commentList.
But I don't get any way. I'm a newbie in combine. please help me!</p>
","4098240","","","","","2020-08-13 01:51:54","How to append when get more data from server using combine in swiftui","<swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"63389986","1","","","2020-08-13 07:17:08","","-1","145","<p>I have a database. I want to display the content of the database.
The most obvious solution:</p>
<pre><code>@State var items = Array(1...100)

List(items, id: \.self) {
     Text(&quot;Item \($0)&quot;)
 }
</code></pre>
<p>But what if I have tens/hundreds of thousands of records? What is the base approach for lazy loading?</p>
","1979882","","","","","2020-08-13 09:02:28","Database lazy load using SwiftUI+Combine","<swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"63404750","1","","","2020-08-14 00:00:54","","0","52","<p>I have the following <code>loadData()</code>:</p>
<pre><code>func loadData() -&gt; Future&lt;Void, Error&gt; {
        return Future { promise in
            self.clearResults()
            self.session.request(baseUrl + &quot;/api/v1/pins&quot;)
                .responseDecodable(of: [Pin].self) { (response: DataResponse) in
                    switch response.result {
                    case .success(let pins):
                        self.pins = pins
                        promise(.success(()))
                    case .failure(let error):
                        promise(.failure(error))
            }
        }
    }
</code></pre>
<p>I am using it as such, and I'm wondering how I can know whether is successful or failure:</p>
<pre><code>self.parent.state
  .loadData()
  .sink(receiveCompletion: { completion in
    // completion is always invalid when debugging
    switch completion {
    case .failure(let error):
        print(&quot;error&quot;)
    case .finished:
        print(&quot;finish&quot;)
    }
}, receiveValue: { value in
    print(&quot;Hello&quot;)
})
</code></pre>
","1354934","","1354934","","2020-08-14 00:41:32","2020-08-14 00:41:32","How to know if a Future result in a success or failure?","<swift><combine>","0","7","","2020-08-14 04:01:34","","CC BY-SA 4.0"
"63406177","1","63406303","","2020-08-14 03:41:09","","1","1249","<p>I want to make a picker use SwiftUI, when I change the value in ChildView, it will not change and called ChildView init.</p>
<pre><code>class ViewModel: ObservableObject {
    @Published var value: Int
    
    init(v: Int) {
        self.value = v
    }
}

struct ChildView: View {
    @Binding var value: Int
    @ObservedObject var vm = ViewModel(v: 0)
    
    init(value: Binding&lt;Int&gt;) {
        self._value = value
        print(&quot;ChildView init&quot;)
    }
    
    var body: some View {
        VStack {
            Text(&quot;param value: \(value)&quot;)
            Text(&quot;@ObservedObject bar: \(vm.value)&quot;)
            Button(&quot;(child) bar.value++&quot;) {
                self.vm.value += 1
            }
        }
        .onReceive(vm.$value) { value = $0 }
    }
}

struct ContentView: View {
    @State var value = 0
    
    var body: some View {
        VStack {
            Text(&quot;(parent) \(self.value)&quot;)
            ChildView(value: $value)
        }
    }
}
</code></pre>
<p>But when I remove <code>Text(&quot;(parent) \(self.value)&quot;)</code> in ContentView, it seems to be normal.</p>
","12666655","","","","","2020-08-14 03:56:59","SwiftUI @Binding value can not change and called init","<swift><swiftui><combine><publisher>","2","0","","","","CC BY-SA 4.0"
"63412373","1","63414811","","2020-08-14 11:59:54","","1","274","<p>My API returns this format, where <code>data</code> can contain all kinds of responses.</p>
<pre><code>{
    status: // http status
    error?: // error handle
    data?:  // your response data
    meta?:  // meta data, eg. pagination
    debug?: // debuging infos
}
</code></pre>
<p>I have made a <code>Codable</code> Response type with a generic for the optional data, of which we do not know the type.</p>
<pre><code>struct MyResponse&lt;T: Codable&gt;: Codable {
    let status: Int
    let error: String?
    let data:  T?
    let meta: Paging?
    let debug: String?
}
</code></pre>
<p>I am now trying to write API convenience methods <strong>as concisely as possible</strong>. So I have a function to return a generic publisher that I can use for all these responses, i.e. one that pre-parses the response and catches any errors upfront.</p>
<p>First, I get a <code>dataTaskPublisher</code> that processes the parameter inputs, if any. <code>Endpoint</code> is just a convenience <code>String</code> <code>enum</code> for my endpoints, <code>Method</code> is similar. <code>MyRequest</code> returns a <code>URLRequest</code> with some necessary headers etc.</p>
<p>Notice the way I define the parameters: <code>params: [String:T]</code>. This is standard JSON so it could be strings, numbers etc.<br />
<strong>It seems this <code>T</code> is the problem somehow.</strong>.</p>
<pre><code>static fileprivate func publisher&lt;T: Encodable&gt;(
        _ path: Endpoint,
        method: Method,
        params: [String:T] = [:]) throws
        -&gt; URLSession.DataTaskPublisher
    {
        let url = API.baseURL.appendingPathComponent(path.rawValue)
        var request = API.MyRequest(url: url)
        if method == .POST &amp;&amp; params.count &gt; 0 {
            request.httpMethod = method.rawValue
            do {
                let data = try JSONEncoder().encode(params)
                request.httpBody = data
                return URLSession.shared.dataTaskPublisher(for: request)
            }
            catch let err {
                throw MyError.encoding(description: String(describing: err))
            }
        }
        return URLSession.shared.dataTaskPublisher(for: request)
    }
</code></pre>
<p>Next, I am parsing the response.</p>
<pre><code>static func myPublisher&lt;T: Encodable, R: Decodable&gt;(
        _ path: Endpoint,
        method: Method = .GET,
        params: [String:T] = [:])
        -&gt; AnyPublisher&lt;MyResponse&lt;R&gt;, MyError&gt;
    {
        do {
                
            return try publisher(path, method: method, params: params)
            .map(\.data)
            .mapError { MyError.network(description: &quot;\($0)&quot;)}
            .decode(type: MyResponse&lt;R&gt;.self, decoder: self.agent.decoder)
            .mapError { MyError.encoding(description: &quot;\($0)&quot;)}             //(2)
            .tryMap {
                if $0.status &gt; 204 {
                    throw MyError.network(description: &quot;\($0.status): \($0.error!)&quot;)
                }
                else {
                    return $0 // returns a MyResponse
                }
            }
            .mapError { $0 as! MyError }
                                                                            //(1)
            .eraseToAnyPublisher()
        }
        catch let err {
            return Fail&lt;MyResponse&lt;R&gt;,MyError&gt;(error: err as? MyError ??
                MyError.undefined(description: &quot;\(err)&quot;))
            .eraseToAnyPublisher()
        }
    }
</code></pre>
<p>Now I can write an endpoint method easily. Here are two examples.</p>
<pre><code>static func documents() -&gt; AnyPublisher&lt;[Document], MyError&gt; {
    return myPublisher(.documents)
        .map(\.data!)
        .mapError { MyError.network(description: $0.errorDescription) }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher() as AnyPublisher&lt;[Document], MyError&gt;
}
</code></pre>
<p>and</p>
<pre><code>static func user() -&gt; AnyPublisher&lt;User, MyError&gt; {
    return myPublisher(.user)
        .map(\.data!)
        .mapError { MyError.network(description: $0.errorDescription) }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher() as AnyPublisher&lt;User, MyError&gt;
}
</code></pre>
<p>All this is working well. Please note that each time, I have to specify my exact return type twice. I think I can live with that.</p>
<p>I should be able to simplify this so that I do not have to repeat the same three operators (map, mapError, receive) in exactly the same way each time.</p>
<p>But when I insert <code>.map(\.data!)</code> at the location <code>//(1)</code> above I get the error <code>Generic parameter T could not be inferred.</code> at the location <code>//(2)</code>.</p>
<p>This is really confusing. Why does the generic type in the <strong>input</strong> parameters play any role here? This must be related to the call to the <code>.decode</code> operator just above, where the generic in question is called <code>R</code>, not <code>T</code>.</p>
<p>Can you explain this? How can I refactor these operators upstream?</p>
","427083","","427083","","2020-08-14 12:10:18","2020-08-14 14:54:37","Swift Combine: Cannot refactor repetitive code","<swift><dictionary><generics><combine>","1","9","","","","CC BY-SA 4.0"
"63426017","1","63426179","","2020-08-15 12:26:14","","3","307","<p>I have a Game-object that may hold an image. Whenever an image URL is found for a game a new instance of GameImage-object should be created. It will then fetch the image and populate the UIImage property. When this happens the UI should be updated presenting the image.</p>
<pre><code>class Game: ObservableObject {
    @Published var image: GameImage?
} 

class GameImage: ObservableObject {
    let url: URL
    @Published var image: UIImage?
    
    private var cancellable: AnyCancellable?
    
    init(url: URL) {
        self.url = url
    }
    
    func fetch() {
        self.cancellable = URLSession.shared.dataTaskPublisher(for: self.url)
            .map { UIImage(data: $0.data) }
            .replaceError(with: nil)
            .receive(on: DispatchQueue.main)
            .sink(receiveValue: { [weak self] (image) in
                guard let self = self else { return }
                self.image = image
                print(self.url)
                print(self.image)
            })
    }
    
    func cancel() {
        cancellable?.cancel()
    }
    
    deinit {
        cancel()
    }
}

struct ContentView: View {
    
    @StateObject var game = Game()

    var body: some View {
        VStack {
            if let image = game.image?.image {
                Image(uiImage: image)
            } else {
                Text(&quot;No image.&quot;)
            }
        }
        .onAppear(perform: {
            guard let gameImageURL = URL(string: &quot;https://cf.geekdo-images.com/itemrep/img/oVEpcbtyWkJjIjk1peTJo6hI1yk=/fit-in/246x300/pic4884996.jpg&quot;) else { return }
            game.image = GameImage(url: gameImageURL)
            game.image!.fetch()
        })
    }
}
</code></pre>
<p>The problem is. After fetch is done the debug console will show that image contains an UIImage. However the UI does not update to show the image. What am I missing here?</p>
","174655","","174655","","2020-08-15 12:34:58","2020-08-15 12:43:57","How to chain ObservableObject?","<asynchronous><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"63437061","1","","","2020-08-16 12:46:52","","0","217","<p>I have a function that create collection of Publishers:</p>
<pre><code>func publishers(from text: String) -&gt; [AnyPublisher&lt;SignalToken, Never&gt;] {
     let signalTokens: [SignalToken] = translate(from: text)
     var delay: Int = 0
     let signalPublishers: [AnyPublisher&lt;SignalToken, Never&gt;] = signalTokens.map { token in
         let publisher = Just(token)
                           .delay(for: .milliseconds(delay), scheduler: DispatchQueue.main)
                           .eraseToAnyPublisher()
         delay += token.delay
         return publisher
     }
     return signalPublishers
}
</code></pre>
<p>In service class I have to method, one for <code>play()</code>:</p>
<pre><code>func play(signal: String) {
     anyCancellable = signalTokenSubject.sink(receiveValue: { token in print(token) }

     anyCancellable2 = publishers(from: signal)
         .publisher
         .flatMap { $0 }
         .subscribe(on: DispatchQueue.global())
         .sink(receiveValue: { [weak self] token in
            self?.signalTokenSubject.send(token)
         })
}
</code></pre>
<p>and one for <code>stop()</code>:</p>
<pre><code>func stop() {
     anyCancellable?.cancel()
     anyCancellable2?.cancel()
}
</code></pre>
<p>I've had problem with memory. When collection of publishers is large and I <code>stop()</code> before whole <code>Publishers.Sequence</code> is <code>.finshed</code> memory increase and never release.</p>
<p>Is there a way to <code>completed</code> <code>Publishers.Sequence</code> earlier, before Combine iterate over whole collection?</p>
","3949632","","3949632","","2020-08-16 13:38:37","2020-08-16 13:46:40","Memory leak when using `Publishers.Sequence`","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"63448377","1","63492773","","2020-08-17 09:46:30","","5","2299","<p>I have a following class:</p>
<pre><code>struct PriceFormatter {
    @AppStorage(UserDefaultsKey.savedCurrency)
    var savedCurrency: String?

    let price: Float
    
    init(price: Float) {
        self.price = price
    }
    
    var formatted: String {
        return &quot;\(savedCurrency) \(price)&quot;
    }
}
</code></pre>
<p>And the following view:</p>
<pre><code>struct PriceText: View {
    let price: Float
    
    var body: some View {
        Text(PriceFormatter(price: self.price).formatted)
    }
}
</code></pre>
<p>I want the view to get rerendered after <code>savedCurrency</code> from <code>UserDefaults</code> changes.</p>
<p>I made it work easily, when <code>@AppStorage</code> was  a part of the view, but I'm not sure what to do in this case. I tried to use <code>@ObservableObject</code> with <code>@Published</code> or tried to make a Combine <code>Publisher</code> and subscribe to it but also had no success.</p>
","6898849","","","","","2022-05-26 21:52:42","How to update SwiftUI view after @AppStorage in a separate struct gets updated","<swift><swiftui><combine>","1","11","1","","","CC BY-SA 4.0"
"63449209","1","63449516","","2020-08-17 10:40:40","","0","692","<p>Given this publisher where i handle response with body. Than I can decode to a User struct. It works well.</p>
<pre><code>// Wrapped Request, return with an URLRequest object with POST method
let request = RequestWithModel(networkMethod: .post, path: PathBuilder().user().build(), model: User(userId: 1, title: &quot;fokora&quot;, body: &quot;baroka&quot;)).urlRequest()

let addUser : AnyPublisher&lt;User, Error&gt; = URLSession.shared.dataTaskPublisher(for: request)
.map{ $0.data }
.decode(type: User.self, decoder: JSONDecoder())
.receive(on: DispatchQueue.main)
.eraseToAnyPublisher()
</code></pre>
<p>How can I handle response when it comes empty json body, but I want to know about its success (status code is 200)? What kind of publisher do I need to use?</p>
<pre><code>// Wrapped Request, return with an URLRequest object with DELETE method
let request = RequestWithoutModel(networkMethod: .delete, path: PathBuilder().user().id(id: &quot;1&quot;).build()).urlRequest()
let deleteUser : AnyPublisher&lt;... no need this ..., Error&gt; = URLSession.shared.dataTaskPublisher(for: request)
.map{ $0.data }
.decode(type: ... no need this ..., decoder: JSONDecoder()) // no need to decode anything at all
.receive(on: DispatchQueue.main)
.eraseToAnyPublisher()
</code></pre>
<p>Thank you in advance for any help you can provide.</p>
","2645599","","","","","2020-08-17 10:59:33","How could I handle empty json body with Combine (AnyPublisher)?","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"63454753","1","63465939","","2020-08-17 16:17:34","","0","1283","<p>My API usually returns a certain format in JSON (simplified notation):</p>
<pre><code>{
   status: // http status
   error?: // error handle
   data?:  // the response data
   ...
}
</code></pre>
<p>In my Combine operators, I take the <code>data</code> from a URLSession <code>dataTaskPublisher</code> and parse the response into a <code>Decodable</code> object that reflects the above schema. That works great.</p>
<p>However, I have an endpoint that returns the HTTP status code <code>201</code> (operation successful), and has <strong>no data</strong> at all. How would I chain this with my operators <strong>without throwing an error</strong>?</p>
<p>This is what I have:</p>
<pre><code>publisher
.map { (data, response) in
    guard data.count &gt; 0 else {
       let status = (response as! HTTPURLResponse).statusCode
       return Data(&quot;{\&quot;status\&quot;: \(status), \&quot;data\&quot;: \&quot;\&quot;}&quot;.utf8)
    }
    return data
}
.mapError { CustomError.network(description: &quot;\($0)&quot;)}
.decode(type: MyResponse&lt;R&gt;.self, decoder: self.agent.decoder)
.mapError { err -&gt; CustomError in CustomError.decoding(description: &quot;\(err)&quot;) }
...
</code></pre>
<p>As you can see, I simply construct an appropriate response, where the response's &quot;data&quot; is an empty string. However, this is ugly and a bit hacky, and I do not see the reason, why the pipeline should continue with parsing, etc, when I already have all I need. How can I interrupt it and finish the pipeline successfully for its final subscriber?</p>
","427083","","427083","","2020-08-18 11:02:33","2020-08-18 11:02:33","Swift Combine: handle no data before decode without an error","<swift><operator-keyword><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"63456569","1","63466274","","2020-08-17 18:22:27","","0","780","<p>I have a publisher wrapper struct where I can handle response status code. If the status code is not range in 200..300 it return with an object, otherwise it throws an Error. It works well.</p>
<pre><code>public func anyPublisher&lt;T:Decodable&gt;(type: T.Type) -&gt; AnyPublisher&lt;T, Error&gt; {
    return URLSession.shared.dataTaskPublisher(for: urlRequest)
        .tryMap { output in
            guard let httpResponse = output.response as? HTTPURLResponse, 200..&lt;300 ~= httpResponse.statusCode else {
                throw APIError.unknown
            }
            return output.data
    }
    .decode(type: T.self, decoder: JSONDecoder())
    .receive(on: DispatchQueue.main)
    .eraseToAnyPublisher()
}
</code></pre>
<p>Using:</p>
<pre><code>let sendNewUserPublisher = NetworkPublisher(urlRequest: request).anyPublisher(type: User.self)

cancellationToken = sendNewUserPublisher.sink(receiveCompletion: { completion in
    if case let .failure(error) = completion {
        NSLog(&quot;error: \(error.localizedDescription)&quot;)
    }
}, receiveValue: { post in
    self.post = post
})
</code></pre>
<p>As above, I would like to handle the error even if the response data does not contain an object to be decoded.</p>
<pre><code>public func anyPublisher() -&gt; AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt; {
    return URLSession.shared.dataTaskPublisher(for: urlRequest)
        // I'd like to handle status code here, and throw an error, if needed
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>Thank you in advance for any help you can provide.</p>
","2645599","","968155","","2020-08-17 19:01:59","2020-08-18 10:00:27","How could I throw an Error when response data does not contain an object to decode with Combine?","<swift><combine><throw>","1","4","","","","CC BY-SA 4.0"
"63457868","1","63458602","","2020-08-17 20:03:19","","0","448","<p>I'm trying to implement MVVM in my SwiftUI app in a way that decouples the view from the view model itself. In my research I came across this article outlining one strategy: <a href=""https://quickbirdstudios.com/blog/swiftui-architecture-redux-mvvm/"" rel=""nofollow noreferrer"">https://quickbirdstudios.com/blog/swiftui-architecture-redux-mvvm/</a></p>
<p>Here's a summary of how it works:</p>
<pre><code>// ViewModel.swift

protocol ViewModel: ObservableObject where ObjectWillChangePublisher.Output == Void {
    associatedtype State
    associatedtype Event

    var state: State { get }
    func trigger(_ event: Event)
}
</code></pre>
<pre><code>// AnyViewModel.swift

final class AnyViewModel&lt;State, Event&gt;: ObservableObject {
    private let wrappedObjectWillChange: () -&gt; AnyPublisher&lt;Void, Never&gt;
    private let wrappedState: () -&gt; State
    private let wrappedTrigger: (Event) -&gt; Void

    var objectWillChange: some Publisher {
        wrappedObjectWillChange()
    }

    var state: State {
        wrappedState()
    }

    func trigger(_ input: Event) {
        wrappedTrigger(input)
    }

    init&lt;V: ViewModel&gt;(_ viewModel: V) where V.State == State, V.Event == Event {
        self.wrappedObjectWillChange = { viewModel.objectWillChange.eraseToAnyPublisher() }
        self.wrappedState = { viewModel.state }
        self.wrappedTrigger = viewModel.trigger
    }
}
</code></pre>
<pre><code>// MyView.swift

extension MyView {
    enum Event {
        case onAppear
    }

    enum ViewState {
        case loading
        case details(Details)
    }

    struct Details {
        let title: String
        let detail: String
    }
}

struct MyView: View {
    @ObservedObject var viewModel: AnyViewModel&lt;ViewState, Event&gt;

    var body: some View { ... }
}
</code></pre>
<pre><code>// ConcreteViewModel.swift

class ConcreteViewModel: ViewModel {
    @Published var state: MyView.ViewState = .loading

    func trigger(_ event: MyView.Event) {
        ...
        state = .details(...) // This gets called by my app and the state is updated.
        ...
    }
}
</code></pre>
<pre><code>// Constructing MyView

let view = MyView(viewModel: AnyViewModel(ConcreteViewModel))
</code></pre>
<p>This succeeds in separating the view from the view model (using AnyViewModel as a wrapper), but the issue is updates to the <code>state</code> property in <code>ConcreteViewModel</code> are not reflected in <code>MyView</code>.</p>
<p>My suspicion is that the problem lies in <code>AnyViewModel</code> and the <code>wrappedObjectWillChange</code> closure, but I am having difficulty debugging it. Do I need to do something with the <code>objectWillChange</code> publisher explicitly, or should <code>@Published</code> handle it automatically?</p>
<p>Any help is much appreciated.</p>
","797767","","","","","2020-08-17 21:01:54","SwiftUI MVVM AnyViewModel not propagating state changes","<ios><swift><mvvm><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63460286","1","63460456","","2020-08-18 00:32:56","","0","253","<p>I've created a property wrapper that I want to insert some logic into and the &quot;set&quot; value is doing the right thing, but the textfield isn't updating with all uppercase text. Shouldn't the text field be showing all uppercase text or am I misunderstanding how this is working?</p>
<p>Also this is a contrived example, my end goal is to insert a lot more logic into a property wrapper, I'm just using the uppercase example to get it working. I've searched all over the internet and haven't found a working solution.</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @StateObject var vm = FormDataViewModel()

    var body: some View {
        Form {
            TextField(&quot;Name&quot;, text: $vm.name)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

class FormDataViewModel: ObservableObject {
    @Capitalized var name: String = &quot;&quot;
}

@propertyWrapper
public class Capitalized {
    @Published var value: String

    public var wrappedValue: String {
        get { value }
        set { value = newValue.uppercased() } //Printing this shows all caps
    }

    public var projectedValue: AnyPublisher&lt;String, Never&gt; {
        return $value
            .eraseToAnyPublisher()
    }

    public init(wrappedValue: String) {
        value = wrappedValue
    }
}
</code></pre>
","4984384","","","","","2020-08-18 03:55:36","Custom property wrapper not accurately reflecting the state of my TextField in SwiftUI, any idea why?","<ios><swiftui><combine><property-wrapper>","2","0","","","","CC BY-SA 4.0"
"63467916","1","","","2020-08-18 11:44:14","","1","41","<p>There is an equivalent for URL Session in URLSession.shared.dataTaskPublisher(for:&gt;) and simlairily for handling' error sand decoding But how to go about handling the return type of discardableResult?  There is an equivalent for URL Session in URLSession.shared.dataTaskPublisher(for:&gt;) and simlairily for handling' error sand decoding</p>
<pre><code>@discardableResult class func taskForGETRequest&lt;ResponseType: Decodable&gt;(url: URL, responseType: ResponseType.Type, completion: @escaping (ResponseType?, Error?) -&gt; Void) -&gt; URLSessionTask {
    let task = URLSession.shared.dataTask(with: url) { data, response, error in
        guard let data = data else {
            DispatchQueue.main.async {
                completion(nil, error)
            }
            return
        }
        let decoder = JSONDecoder()
       
        do {
            let responseObject = try decoder.decode(ResponseType.self, from: data)
            DispatchQueue.main.async {
                completion(responseObject, nil)
            }
        } catch {
            do {
                let errorResponse = try decoder.decode(TMDBResponse.self, from: data)
                completion(nil,errorResponse)
                
            } catch {
                DispatchQueue.main.async {
                    completion(nil, error)
                }
            }
            
        }
    }
    task.resume()
    return task
}

class func taskForPOSTRequest&lt;RequestType: Encodable, ResponseType: Decodable&gt;(url: URL, responseType: ResponseType.Type, body: RequestType, completion: @escaping (ResponseType?, Error?) -&gt; Void) {
    var request = URLRequest(url: url)
    request.httpMethod = &quot;POST&quot;
    request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
    request.httpBody = try! JSONEncoder().encode(body)
    let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
        guard let data = data else {
            completion(nil, error)
            return
        }
        let decoder = JSONDecoder()
        do {
            let responseObject = try decoder.decode(ResponseType.self, from: data)
            completion(responseObject, nil)
        } catch {
            do {
                let errorResponse = try decoder.decode(TMDBResponse.self, from: data)
                completion(nil,errorResponse)
                
        } catch {
            DispatchQueue.main.async {
                completion(nil, error)
            }
        }
    }
}
task.resume()
</code></pre>
<p>}</p>
","9649343","","9649343","","2020-08-18 11:50:09","2020-08-18 11:50:09","What will be the Apple Combine Equivalent of the following two methods?","<ios><swift><combine>","0","0","","","","CC BY-SA 4.0"
"63470324","1","63473375","","2020-08-18 14:01:58","","2","4313","<p>In the example below, I’m making a network request to load different movie genres, then using that to load all the movies. The sink only returns the movie results. How could I receive both the genres and movies?</p>
<pre><code>struct Genre: Codable, Identifiable{
    let id: Int
    let name: String
    var movies: [Movie]?
}

struct Movie: Codable, Hashable, Identifiable {
    let title: String
    let id: Int
    let posterPath: String?
    let backdropPath : String?
    var tagline: String?
}

loadGenres() is AnyPublisher&lt;[Genre], Error&gt; 
fetchMoviesIn() is AnyPublisher&lt;[Movie], Error&gt;

class GenresViewModel: ObservableObject{
    @Published var genres = [Genre]()
    @Published var movies = [Movie]()
    var requests = Set&lt;AnyCancellable&gt;()
    
    init(){
        NetworkManager.shared.loadGenres()
            .flatMap{ genres in
                genres.publisher.flatMap{ genre in
                    NetworkManager.shared.fetchMoviesIn(genre)
                }
            }
            .collect()
            .retry(1)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                switch completion{
                case .finished:
                    print(&quot;Finished loading all movies in every genre&quot;)
                case .failure(let error):
                    print(&quot;Error: \(error)&quot;)
                }
            }, receiveValue: { [self] values in
                let allMovies = values.joined()
                self.movies = allMovies.map{$0}
            })
            .store(in: &amp;self.requests)
    }
}
</code></pre>
","10830089","","10830089","","2020-08-18 19:07:10","2020-08-19 09:49:36","Chaining swift combine publishers and receiving each result","<swift><combine>","1","4","3","","","CC BY-SA 4.0"
"63474846","1","","","2020-08-18 18:46:04","","1","114","<p>MacOS Swift Project, but would for iOS.  I am targeting 10.14</p>
<p>I have an OperationQueue.  I want to schedule an operation to run later.  Easy enough...</p>
<pre><code>func schedule(after date: OperationQueue.SchedulerTimeType, interval: OperationQueue.SchedulerTimeType.Stride, tolerance: OperationQueue.SchedulerTimeType.Stride, options: OperationQueue.SchedulerOptions?, _ action: @escaping () -&gt; Void) -&gt; Cancellable
</code></pre>
<p>Available 10.9</p>
<pre><code>        operQ.schedule(after: .init(restartDate), interval: .zero, tolerance: .zero, options: nil){self.restart(&quot;&quot;)}
</code></pre>
<p>I get the error <code>'schedule(after:interval:tolerance:options:_:)' is only available in macOS 10.15 or newer</code></p>
<p>Which I tracked down to combine, which seems to be masking the default implementation.</p>
<p><a href=""https://i.stack.imgur.com/iMN9L.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iMN9L.png"" alt=""Screen Shot of the Xcode doc"" /></a></p>
","3324220","","3324220","","2020-08-19 03:10:20","2020-08-19 03:10:20","Available but Not Available functions on OperationQueue in Swift","<swift><combine><operationqueue>","0","1","","","","CC BY-SA 4.0"
"63475985","1","","","2020-08-18 20:14:59","","0","696","<p>I am using Combine with Swift5; I have a <code>CurrentValueSubject</code> that I am combining with a <code>@Published</code> dictionary variable.</p>
<p>The problem is that when the current value is updated, map never gets called! This is specifically an issue with <code>@Published</code> variable since it works with other streams that are not using <code>@Published</code>.</p>
<pre><code>@Published var userModels: [String: UserModel] = [:]
var chatModels: CurrentValueSubject&lt;[ChatModelFirebase], Never&gt; = CurrentValueSubject([])

chatModels
    .combineLatest(userModels.publisher)
    .map({ (chatModels, userModels) -&gt; [ChatViewModel] in
        print(&quot;Hello&quot;) // Never gets called! 😢
        return []
        })
.assign(to: \.chatViewModels, on: self)
.store(in: &amp;cancellableSet)


// Update chat model's value, and notice that map never gets called!
chatModels.values = []
</code></pre>
<p>There are no errors, code compiles and runs, but I never get the results of stream updates. <strong>The problem will be fixed if I update <code>userModels</code> to also be <code>CurrentValueSubject</code>, but the question is why is <code>combineLatest(..)</code> breaking with <code>@Published</code>?</strong></p>
","577878","","","","","2020-08-19 00:30:36","combineLatest on CurrentValueSubject doesn't emit when combining with @Published property","<ios><swift><swift5><combine>","1","4","","","","CC BY-SA 4.0"
"63479425","1","63479523","","2020-08-19 03:05:55","","3","1630","<p>I am trying to get one object to listen to changes in the property of another object. I have it working as shown below, but I would prefer the observing object knew nothing of the Model, just the property.</p>
<pre><code>class Model : ObservableObject{
    @Published var items: [Int] = []
}

class ObjectUsingItems{
    var itemObserver: AnyCancellable?
    var items: [Int] = []
    
    func observeItems(model: Model){
        itemObserver = model.$items
            .sink{ newItems in
                self.items = newItems
                print(&quot;New Items&quot;)
        }
    }
}
</code></pre>
<p>At the moment I begin observing the model.items as follows - which works:</p>
<pre><code>let model = Model()
let itemUser = ObjectUsingItems()
        
itemUser.observeItems(model: model)
model.items.append(1) // itemUser sees changes
</code></pre>
<p>Unfortunately I can’t seem to figure out just what is required as the parameter to the observeItems method so that it works without knowing anything about the Model - like this:</p>
<pre><code>class ObjectUsingItems{
    var itemObserver: AnyCancellable?
    var items: [Int] = []
    
    func observeItems(propertyToObserve: WhatGoesHere?){
        itemObserver = propertyToObserve
            .sink{ newItems in
                // etc.
        }
    }
}
</code></pre>
<p>And then call it like so:</p>
<pre><code>itemUser.observeItems(XXX: model.$items)
</code></pre>
<p>Can anyone explain what I need to do? Thanks!</p>
","2234184","","","","","2020-08-19 03:21:48","Observing a @Published var from another Object","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63492910","1","","","2020-08-19 18:25:42","","1","1466","<p>I am trying to fetch initial value of <code>EventDetailsModel</code> and subscribe to all future updates.</p>
<p>When I call <code>eventDetails(..)</code>, all the publishers already have some current value in them (i.e. <code>chatModels</code> and <code>userModels</code> have 10+ items); the problem is that because there are no new updates, the resulting pipe never returns <code>EventDetailModels</code> since <code>.map(...)</code> never gets called.</p>
<p><strong>How can I make the combine pipe do at least one pass through the existing values when I am constructing it so my sink has some initial value?</strong></p>
<pre><code>var chatModels: Publishers.Share&lt;CurrentValueSubject&lt;[ChatModel], Never&gt;&gt; = CurrentValueSubject([]).share()
var userModels: CurrentValueSubject&lt;[String: UserModel], Never&gt; = CurrentValueSubject([:])

func eventDetails(forChatId chatId: String) -&gt; AnyPublisher&lt;EventDetailsModel?, Never&gt; {
    return chatModels
        .combineLatest(userModels)
        .map({ (chatList, userModels) -&gt; EventDetailsModel? in
            // Never gets called, even if chatModels and userModels has some existing data 😢
            if let chatModel = (chatList.first { $0.id == chatId}) {
                return EventDetailsModel(chatModel, userModels)
            }
            return nil
        })
        .eraseToAnyPublisher()
}
</code></pre>
","577878","","577878","","2020-08-19 19:13:08","2020-08-19 19:28:53","How to force an initial value when creating a pipe with CurrentValueSubject in Combine in Swift 5?","<ios><swift><swift5><combine>","1","6","","","","CC BY-SA 4.0"
"63493839","1","","","2020-08-19 19:35:37","","0","72","<p>I am new to programming and am building an app with SwiftUI and want to learn Ruby on Rails for the backend and skip Core Data ( I heard it is not necessary and could use MySQL)</p>
<p>Does Combine inter-operate with MySQL / Ruby on Rails? Does it need to?</p>
<p>I am just trying to establish the simplest tech stack to learn and want to make sure everything works together.</p>
<p>Thank you!</p>
","13673800","","","","","2020-08-19 19:51:40","IOS Combine Interoperability With MySQL & Ruby on Rails?","<ios><mysql><ruby-on-rails><swift><combine>","1","1","","","","CC BY-SA 4.0"
"63511459","1","63527650","","2020-08-20 18:48:59","","2","6257","<p>I have an HTTP request publisher that when a 401 error is returned, I want to stop execution and display my sign in screen.</p>
<p>Here's part of my code:</p>
<pre><code>cancellable = fetcher.hello(helloRequest: HelloRequest(name: self.name))
            .print(&quot;fetcher.hello&quot;)
            .catch { _ in
                // TODO: how to handle errors with request?
                Just(HelloResponse.placeHolder)
            }
            .flatMap { response -&gt; AnyPublisher&lt;HelloResponse, Never&gt; in
                if response.imageUrl == nil || response.imageUrl == &quot;&quot; {
                    // If there's no image to download just return the response
                    return Just(response).eraseToAnyPublisher()
                }
                else {
                    // Chain together request and download image
                    return fetcher.downloadImage(url: response.imageUrl!)
                        .print(&quot;fetcher.hello.downloadImage&quot;)
                        .catch { _ in
                            // If there was an error downloading the image, replace it with a placeholder
                            Just(UIImage(named: &quot;placeholder_square&quot;)!)
                        }
                        .map {
                            // Add image to response
                            HelloResponse(message: response.message, visitCount: response.visitCount, imageUrl: response.imageUrl, image: $0)
                        }
                        .eraseToAnyPublisher()
                }
            }
            .sink(receiveCompletion: { _ in }, receiveValue: { self.response = $0.self })
</code></pre>
<p>So part of the problem is the following flatMap that will download an image if necessary. The output type is AnyPublisher&lt;HelloResponse, Never&gt; (I couldn't think of another way to do that). Right now the catch returns a placeholder model and worked fine. But now I've swallowed the error. I thought maybe Empty() publisher would work but it didn't seem right. I tried Fail() but apparently catch is a Never (makes sense). Thanks!</p>
","510199","","510199","","2020-08-21 17:42:36","2020-08-21 17:42:36","Swift Combine - How to throw an error and stop execution","<swift><combine>","1","7","","","","CC BY-SA 4.0"
"63542092","1","63542512","","2020-08-22 23:39:13","","1","975","<h2>Problem</h2>
<p>When my model housed inside a store class is updated on the main thread asynchronously, a SwiftUI view does not automatically render the slice of the model provisioned by the ViewModel.</p>
<h2>Assumed Solution</h2>
<p>A custom publisher / promise is needed to link the View/ViewModel/Factory/Store together, as a reference doesn't fire updates on asynchronous updates.</p>
<h2>Block</h2>
<p>How do I write that? I've tried adding a promise to the Store class, but Xcode warns the Result of call to sink(receiveValue:) is unused. I clearly don't understand promises / publishers and most tutorials use URLSession and its dataTaskPublisher (not my case).</p>
<p>I tried the example <a href=""https://developer.apple.com/forums/thread/133907"" rel=""nofollow noreferrer"">in this Apple Dev Forums thread</a> on the factory and store classes, but no dice. I clearly don't understand it. <a href=""https://stackoverflow.com/questions/59452113/publisher-inside-a-publisher-does-not-trigger-swiftui-re-render"">In this answer, @Asperi suggested the View listen to a publisher</a> and update an @State variable, but since my model is private I lack a target for that approach.</p>
<h2>Abbreviated Code</h2>
<ul>
<li>A factory instantiates a ContactStore class with dependencies; a reference is passed to ViewModels.</li>
<li>The VMs gate access to the private store with computed variables. The view calls functions in the ViewModel that modify state, which works well if synchronous.</li>
</ul>
<p><strong>Factory.swift</strong></p>
<pre class=""lang-swift prettyprint-override""><code>
import SwiftUI
import Combine

class MainFactory {

    init() {
        ...
        self.contactStore = ContactStore()
    }

    private var preferences: Preferences
    private var contactStore: ContactStore

 ...

    func makeOnboardingVM() -&gt; OnboardingVM {
        OnboardingVM(preferences: preferences, contactStore: contactStore)
    }

}

</code></pre>
<p><strong>ContactStore.swift</strong></p>
<pre class=""lang-swift prettyprint-override""><code>final class ContactStore {

    private(set) var authorizationStatus: CNAuthorizationStatus = .notDetermined
    private(set) var contacts: [Contact] = [Contact]()
    private(set) var errors: [Error] = [Error]()

    private lazy var initialImporter = CNContactImporterForiOS14(converter: CNContactConverterForiOS14(),
                                                                 predictor: UnidentifiedSelfContactFavoritesPredictor())
}

// MARK: - IMPORT

extension ContactStore {
    /// Full import during app onboarding. Work conducted on background thread.
    func requestAccessAndImportPhoneContacts(completion: @escaping (Bool) -&gt; Void) {
        CNContactStore().requestAccess(for: .contacts) { [weak self] (didAllow, possibleError) in
            guard didAllow else {
                DispatchQueue.main.async { completion(didAllow) }
                return
            }
            DispatchQueue.main.async { completion(didAllow) }
            self?.importContacts()
        }
    }

    private func importContacts() {
        initialImporter.importAllContactsOnUserInitiatedThread { [weak self] importResult in
            DispatchQueue.main.async {
               switch importResult {
               case .success(let importedContacts):
                
                   self?.contacts = importedContacts
               case .failure(let error):
                   self?.errors.append(error)
               }
            }
        }
    }
}
</code></pre>
<p><strong>OnboardingViewModel.swift</strong></p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Contacts

class OnboardingVM: ObservableObject {

    init(preferences: Preferences, contactStore: ContactStore) {
        self.preferences = preferences
        self.contactStore = contactStore
    }

    @Published private var preferences: Preferences
    @Published private var contactStore: ContactStore

    var contactsAllImported: [Contact] { contactStore.contacts }

    func processAddressBookAndGoToNextScreen() {
        contactStore.requestAccessAndImportContacts() { didAllow in
            DispatchQueue.main.async {
                if didAllow {
                    self.go(to: .relevantNewScreen)
                else { self.go(to: .relevantOtherScreen) }
            }
        }
    }

    ...
}
       
</code></pre>
<p><strong>View.swift</strong></p>
<pre class=""lang-swift prettyprint-override""><code>struct SelectEasiestToCall: View {
    @EnvironmentObject var onboarding: OnboardingVM

    var body: some View {
        VStack {
            ForEach(onboarding.allContactsImported) { contact in 
                SomeView(for: contact)
            }
        }

</code></pre>
","11420986","","","","","2020-08-23 01:14:05","How to fire a publisher after async update in SwiftUI?","<ios><swift><asynchronous><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"63543450","1","63549194","","2020-08-23 04:39:25","","2","812","<p>Combine subscription sample code snippet all store the resulting subscription into the <code>subscriptions</code> set</p>
<pre><code>private var subscriptions = Set&lt;AnyCancellable&gt;()
</code></pre>
<p>Why do we need to do it?</p>
<pre><code>future
  .sink(receiveCompletion: { print($0) }, receiveValue: { print($0) }) 
  .store(in: &amp;subscriptions)
</code></pre>
","2226315","","","","","2020-08-23 16:09:04","What is the reason to store subscription into a subscriptions set?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"63546298","1","63549014","","2020-08-23 11:17:23","","1","363","<p>I'm getting to know Swift + Swift's Combine framework and wanted to check that my attempt at implementing a <code>retryIf(retries:, shouldRetry:)</code> operator makes sense. In particular, I'm curious if all the <code>.eraseToAnyPublisher</code>s are expected/idiomatic.</p>
<pre class=""lang-swift prettyprint-override""><code>extension Publisher {
    func retryIf(retries: Int, shouldRetry: @escaping (Self.Failure) -&gt; Bool) -&gt; AnyPublisher&lt;Self.Output, Self.Failure&gt; {
        self.catch { error -&gt; AnyPublisher&lt;Self.Output, Self.Failure&gt; in
            guard shouldRetry(error) &amp;&amp; retries &gt; 0 else {
                return Fail(error: error).eraseToAnyPublisher() 
            }
            return self.retryIf(retries: retries - 1, shouldRetry: shouldRetry).eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
</code></pre>
<p>Assuming that all the <code>AnyPublisher</code>s are ok, when do you want to make your own <code>Publisher</code> struct? For example, the regular Combine operator <code>retry</code> returns a <code>Retry&lt;Upstream&gt;</code> struct rather than an <code>AnyPublisher</code>, but I imagine you could implement it along the same lines as the code above, something like:</p>
<pre class=""lang-swift prettyprint-override""><code>extension Publisher {
    func doOver(tries: Int) -&gt; AnyPublisher&lt;Self.Output, Self.Failure&gt; {
        self.catch { error -&gt; AnyPublisher&lt;Self.Output, Self.Failure&gt; in
            guard tries &gt; 0 else { return Fail(error: error).eraseToAnyPublisher() }
            return self.doOver(tries: tries - 1).eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
</code></pre>
","238624","","","","","2020-08-23 15:53:20","Writing a retryIf operator with Swift's Combine framework","<swift><generics><combine>","1","3","","","","CC BY-SA 4.0"
"63554713","1","63557912","","2020-08-24 04:25:40","","2","1682","<p>I need to use .publishDecodable together with Result, I followed the <a href=""https://github.com/Alamofire/Alamofire/blob/master/Documentation/AdvancedUsage.md#using-alamofire-with-combine"" rel=""nofollow noreferrer"">instructions</a>, but I ran into this error: &quot;generic parameter 't' could not be inferred closure&quot;</p>
<p><a href=""https://i.stack.imgur.com/hn4Eo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hn4Eo.png"" alt=""enter image description here"" /></a></p>
<pre><code>@Published var loginModel: [LoginModel] = [LoginModel]()

var cancellation: AnyCancellable?

func request&lt;T: Codable&gt;(_ url: String, method: HTTPMethod = .get, headers: HTTPHeaders? = nil, parameters: Codable? = nil) -&gt; AnyPublisher&lt;Result&lt;T, AFError&gt;, Never&gt; {
    let publisher = AF.request(url, method: method, headers: headers)
        .validate()
        .publishDecodable(type: T.self)
    return publisher.result()
}

 func login(email: String, password: String) {
    let parameters = LoginParameters(
        email: email,
        password: password
    )

    cancellation = request(serverURL + &quot;login&quot;, method: .post, parameters: parameters)
        .sink { [self] response in
            switch response {
            case .success:
                loginModel = response.value()
            case .failure(error):
                print(error)
            }
        }
}
</code></pre>
","12245359","","","","","2020-08-24 09:18:52","Using Alamofire with .publishDecodable","<swift><alamofire><combine>","1","0","","","","CC BY-SA 4.0"
"63556828","1","63558156","","2020-08-24 07:52:40","","-1","305","<p>I have 2 type date from api. I need to decode together. But I didn't find any solution. I need to add <code>&quot;yyyy-MM-dd'T'HH:mm:ssZ&quot;</code> format in this code. How can I do this?</p>
<pre><code>    func run&lt;T: Decodable&gt;(_ request: URLRequest, _ decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;Response&lt;T&gt;, Error&gt; {
    return URLSession.shared
        .dataTaskPublisher(for: request)
        .receive(on: DispatchQueue.main)
        .tryMap { result -&gt; Response&lt;T&gt; in
            self.dateFormatter.dateFormat = &quot;yyyy-MM-dd'T'HH:mm:ss&quot;
            decoder.dateDecodingStrategy = .formatted(self.dateFormatter)
            let value = try decoder.decode(T.self, from: result.data)
            return Response(value: value, response: result.response)
        }
        .eraseToAnyPublisher()
}
</code></pre>
","14139338","","2229783","","2020-08-24 11:27:49","2020-08-24 11:27:49","JSONDecoder with multiple date formats?","<swift><request><combine><dateformatter>","2","6","","","","CC BY-SA 4.0"
"63596807","1","","","2020-08-26 11:36:12","","0","71","<p>I have a dropdown that on selection shows some options. I want to create a publisher that emits the option that is then tapped.</p>
<p>I have a property indicating the selectedDropdown</p>
<pre><code>@Published var selectedDropdown: DropdownViewModel?
</code></pre>
<pre><code>struct DropdownViewModel {
  var options: [DropdownOption]
  ...
}
</code></pre>
<pre><code>struct DropdownOption {
    var select = PassthroughSubject&lt;Void, Never&gt;()
    ...
}
</code></pre>
<p>Here's where I've got to</p>
<pre><code>  var optionTap: AnyPublisher&lt;DropdownOption, Never&gt; {
        let selectedDropdown = $selectedDropdown.compactMap { $0 }
        let options = selectedDropdown.map { $0.options }
        let selectStream = options.map {
            $0.map { option in option.select.flatMap { Just(option) } }
        }.eraseToAnyPublisher()
        return selectStream
    }
</code></pre>
<p>I want a stream of <code>DropdownOption</code> being emitted when there is a select.send(()) but here I map over a map which isn't going to work - is there an operator I can use here?</p>
<p>Edit:</p>
<p>This is how I did the actual dropdown taps...</p>
<pre><code>  var dropdownTaps: AnyPublisher&lt;DropdownViewModel?, Never&gt; {
        Publishers.Merge3(
            tap(on: dropdown1),
            tap(on: dropdown2),
            tap(on: dropdown3)
        ).eraseToAnyPublisher()
    }
</code></pre>
<pre><code>  private func tap(on dropdown: DropdownViewModel) -&gt; AnyPublisher&lt;DropdownViewModel?, Never&gt; {
        dropdown.tap.map { dropdown }.eraseToAnyPublisher()
    }
</code></pre>
<pre><code>dropdownTaps.assign(to: &amp;$selectedDropdown)
</code></pre>
<p>I'd like to acheive something similar if possible</p>
","2105498","","2105498","","2020-08-26 12:36:41","2020-08-26 12:36:41","How to create a combine pipeline that emits the option tapped","<swift><reactive-programming><combine>","0","2","","","","CC BY-SA 4.0"
"63601995","1","","","2020-08-26 16:36:25","","0","113","<p>Having a SwiftUI project generated by Xcode, and adding a custom <code>MyView</code> with a <code>MyViewModel</code>.
The <code>ContentView</code> just renders <code>MyView</code>.</p>
<p>The problem:</p>
<ol>
<li>When the <code>ContentView</code> gets reloaded (the reload button changes its state), <code>MyViewModel</code> gets somehow disconnected from <code>MyView</code> (the <code>MyView</code> counter stops incrementing in the UI when the button is clicked), but the console logs show the incrementation works.</li>
<li>If the model subscribes to a publisher, it does not get unsubscribed because the instance is not released. Therefore, the instances still process incoming messages and alter the app's data and state.</li>
</ol>
<p>Looking at the instance counters and memory addresses in the console:</p>
<ol>
<li>Every time the <code>ContentView</code> gets refreshed, a new <code>MyView</code> and <code>MyViewModel</code> instances get created. However, the counter incrementation uses the original first-created model instance.</li>
<li>Some model instances did not get released.</li>
</ol>
<p><em>EDIT:</em> The model needs to be recreated every time <code>MyView</code> is recreated.</p>
<pre><code>import SwiftUI

struct ContentView: View {
    @State
    private var reloadCounter = 0

    var body: some View {
        VStack {
            Button(action: { self.reloadCounter += 1 },
                   label: { Text(&quot;Reload view&quot;) })

            Text(&quot;Reload counter: \(reloadCounter)&quot;)

            MyView().environmentObject(MyViewModel())
        }
    }
}
</code></pre>
<pre><code>import SwiftUI

struct MyView: View {
    @EnvironmentObject
    private var model: MyViewModel

    var body: some View {
        VStack {
            Button(action: { self.model.counter += 1 },
                   label:  { Text(&quot;Increment counter&quot;) })

            Text(&quot;Counter value: \(model.counter)&quot;)
        }
        .frame(width: 480, height: 300)
    }

    init() { withUnsafePointer(to: self) { print(&quot;Initialising MyView struct instance \(String(format: &quot;%p&quot;, $0))&quot;) }}
}
</code></pre>
<pre><code>import Combine

class MyViewModel: ObservableObject {
    private static var instanceCount: Int = 0 { didSet {
        print(&quot;SettingsViewModel: \(instanceCount) instances&quot;)
    }}

    @Published
    var counter: Int = 0 { didSet {
        print(&quot;Model counter: \(counter), self: \(Unmanaged.passUnretained(self).toOpaque())&quot;)
    }}

    init() { print(&quot;Initialising MyViewModel class instance \(Unmanaged.passUnretained(self).toOpaque())&quot;); Self.instanceCount += 1 }
    deinit { print(&quot;Deinitialising MyViewModel class instance \(Unmanaged.passUnretained(self).toOpaque())&quot;); Self.instanceCount -= 1 }
}
</code></pre>
<p>Any clue what did I do wrong?</p>
<p>The image below depicts the app's UI after all the actions in the logs were performed.</p>
<p><a href=""https://i.stack.imgur.com/fToYE.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fToYE.png"" alt=""enter image description here"" /></a></p>
","1379273","","1379273","","2020-08-26 19:07:04","2020-08-26 19:07:04","SwiftUI not releasing model instances","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63602063","1","","","2020-08-26 16:40:33","","3","661","<p>I would like two separate <code>ObjservableObject</code> to share a single @Published var.
Ideally something like the below. That does not compile due to <code>Cannot assign to property: '$bar' is immutable</code>. I would like foo and bar to be in sync if a change is made to one or the other.</p>
<pre><code>class FooState: ObservableObject {
    @Published var foo: Bool = false
}

class BarState: ObservableObject {
    @Published var bar: Bool

    init(fooState: FooState) {
        self.$bar = fooState.$foo // compile error
    }
}

let fooState = FooState()
let barState = BarState(fooState: fooState)

print(fooState.foo) // false
print(barState.bar) // false

fooState.foo = true
print(fooState.foo) // true
print(barState.bar) // true
</code></pre>
","1684508","","","","","2020-08-26 17:22:23","SwiftUI map @Published var from one ObservableObject to another","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63605073","1","64896955","","2020-08-26 20:09:50","","2","604","<p>This problem has been haunting me for months and I believe it comes down to my using the wrong structure and procedure.</p>
<p>I'm trying to do an API call to Yelp's API and passing in the variables for the user's lat/long. I'm able to grab the lat/long based on my current LocationManager, however when it seems as though the lat/long only becomes available AFTER the API call has been made, so the API is getting default 0.0 values for both lat/long.</p>
<p>I'm very much a beginner when it comes to this, but is there a way that I could set up a loading screen that grabs the lat/long in the background and by the time my ExploreView shows, the real location information has been established?</p>
<p>Below is my LocationManager and ExploreView</p>
<p>LocationManager</p>
<pre><code>import Foundation
import CoreLocation

class LocationManager: NSObject, ObservableObject {

private let locationManager = CLLocationManager()
let geoCoder = CLGeocoder()

@Published var location: CLLocation? = nil
@Published var placemark: CLPlacemark? = nil

override init() {
    super.init()
    self.locationManager.delegate = self
    self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
    self.locationManager.distanceFilter = kCLDistanceFilterNone
    self.locationManager.requestWhenInUseAuthorization()
    self.locationManager.startUpdatingLocation()
    
}

func geoCode(with location: CLLocation) {
    geoCoder.reverseGeocodeLocation(location) { (placemark, error) in
        if error != nil {
            print(error!.localizedDescription)
        } else {
            self.placemark = placemark?.first
        }
    }
}

func startUpdating() {
    self.locationManager.delegate = self
    self.locationManager.requestWhenInUseAuthorization()
    self.locationManager.startUpdatingLocation()
    }
}

extension LocationManager: CLLocationManagerDelegate {

func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
    guard let location = locations.first else {
        return
    }
    self.location = location
    self.geoCode(with: location)
    }
}
</code></pre>
<p>ExploreView (The first view that shows upon launch)</p>
<pre><code>import SwiftUI
import CoreLocation
import Foundation


struct ExploreView: View {
    @ObservedObject  var location = LocationManager()
    @ObservedObject var fetcher: RestaurantFetcher


init() {
    let location = LocationManager()
    self.location = location
    self.fetcher = RestaurantFetcher(locationManager: location)
    self.location.startUpdating()
}

var body: some View {
        ScrollView (.vertical) {
            VStack {
                HStack {
                    Text(&quot;Discover &quot;)
                        .font(.system(size: 28))
                        .fontWeight(.bold)
                  +  Text(&quot; \(location.placemark?.locality ?? &quot;&quot;)&quot;)
                        .font(.system(size: 28))
                        .fontWeight(.bold)
                    Spacer()                       
                }
                HStack {
                    SearchBar(text: .constant(&quot;&quot;))
                }.padding(.top, 16)                
                HStack {
                    Text(&quot;Featured Restaurants&quot;)
                        .font(.system(size: 24))
                        .fontWeight(.bold)
                    Spacer()                       
                    NavigationLink(
                        destination: FeaturedView(),
                        label: {
                            Text(&quot;View All&quot;)
                        })                        
                }.padding(.vertical, 30)                 
                HStack {
                    Text(&quot;All Cuisines&quot;)
                        .font(.system(size: 24))
                        .fontWeight(.bold)
                    Spacer()
                }                
                Spacer()
            }.padding()
        }      
    }
}

public class RestaurantFetcher: ObservableObject {
    @Published var businesses = [RestaurantResponse]()
    @ObservedObject var locationManager: LocationManager
    let location = LocationManager()

var lat: String {
    return &quot;\(location.location?.coordinate.latitude ?? 0.0)&quot;
}

var long: String {
    return &quot;\(location.location?.coordinate.longitude ?? 0.0)&quot;
}

init(locationManager: LocationManager) {
    let location = LocationManager()
    self.locationManager = location
    self.location.startUpdating()
    
    load()
}

func load() {
    print(&quot;\(location.location?.coordinate.latitude ?? 0.0)&quot;)
    print(&quot;user latitude top of function&quot;)
    //Returns default values of 0.0
    let apikey = &quot;APIKEY Here&quot;
    let url = URL(string: &quot;https://api.yelp.com/v3/businesses/search?latitude=\(lat)&amp;longitude=\(long)&amp;radius=40000&quot;)!
    var request = URLRequest(url: url)
    request.setValue(&quot;Bearer \(apikey)&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
    request.httpMethod = &quot;GET&quot;
    
    URLSession.shared.dataTask(with: request) { (data, response, error) in
        do {
            if let d = data {
                print(&quot;\(self.location.location?.coordinate.longitude ?? 0.0)&quot;)
                let decodedLists = try JSONDecoder().decode(BusinessesResponse.self, from: d)
               
                // Returns actual location coordinates
                DispatchQueue.main.async {
                    self.businesses = decodedLists.restaurants
                }
            } else {
                print(&quot;No Data&quot;)
            }
        } catch {
            print (&quot;Caught&quot;)
        }
    }.resume()
    }
}
</code></pre>
","1336383","","12299030","","2020-11-18 16:16:21","2020-11-18 16:16:21","SwiftUI - Get User's coordinates to pass in API call","<swift><swiftui><core-location><combine><clplacemark>","1","1","2","","","CC BY-SA 4.0"
"63611009","1","63611282","","2020-08-27 07:18:22","","1","150","<p>Given an AuthenticationView swiftui struct contains a UserLoginView. The UserLoginView has a UserLoginViewModel class for handle the login button actions.</p>
<p>In the AuthenticationView I would like to know when the value of the variable changes in the inner UserLoginView (if the tutorialScreenIsShowable is true in AuthenticationView, the NavigationLink navigate to next slide).</p>
<pre><code>struct AuthenticationView: View {
    @State private var tutorialScreenIsShowable = false
    var body: some View {
        NavigationView {
            ZStack {
                NavigationLink(destination: TutorialView(), isActive: $tutorialScreenIsShowable) {
                    EmptyView()
                }
                UserLoginView(tutorialScreenIsShowable: self.$tutorialScreenIsShowable)
            }
        }
    }
}
</code></pre>
<p>,</p>
<pre><code>struct UserLoginView: View {
    @Binding var tutorialScreenIsShowable: Bool
    @ObservedObject var userLoginViewModel = UserLoginViewModel()
    var body: some View {
        Button(action: {
            self.userLoginViewModel.loginButtonAction() // it not works but I need this way
//            self.tutorialScreenIsShowable = self.userLoginViewModel.loginButtonActionWithReturn() // it works, but its not good in this case
        }) {
            Text(&quot;Log in&quot;)
        }
    }
}
</code></pre>
<p>,</p>
<pre><code>class UserLoginViewModel: NSObject, ObservableObject {
    @Published var tutorialScreenIsShowable = false
    
    func loginButtonAction() {
        self.tutorialScreenIsShowable = true
    }
    
    func loginButtonActionWithReturn() -&gt; Bool {
        return true
    }
}
</code></pre>
<p>As I know if the function would have a return value that could be work, but in this case there is a delegate method running where I can handle the variable.</p>
<p>I'd like to avoid @EnvironmentObject as it possible, I hope there is another solution.</p>
<p>Could you help me with this?</p>
<p>Edit: I simplified the example. And uploaded a example project here: <a href=""https://www.dropbox.com/s/paosp6iom9oks9p/InnerViewPropBind.zip"" rel=""nofollow noreferrer"">https://www.dropbox.com/s/paosp6iom9oks9p/InnerViewPropBind.zip</a></p>
","2645599","","2645599","","2020-08-27 09:15:14","2020-08-27 10:36:31","In parent swiftui view how could I know when a state changes in an inner views viewmodel void method?","<swift><binding><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63633284","1","63634213","","2020-08-28 11:53:12","","0","485","<p>This code crashes (&quot;Unexpectedly found nil while unwrapping an Optional value&quot;)</p>
<pre><code>import Combine

class Receiver {
    var value: Int!
    var cancellables = Set&lt;AnyCancellable&gt;([])
    
    init(_ p: AnyPublisher&lt;Int,Never&gt;) {
        p.assign(to: \.value, on: self).store(in: &amp;cancellables)
    }
}

let receiver = Receiver(Just(5).eraseToAnyPublisher())
</code></pre>
<p>It does not crash if I use <code>p.sink { self.value = $0 }.store(in: &amp;cancellables)</code> instead of the assign, and it does not crash if I do not use an optional for the <code>value</code>-property.</p>
<p>To me this looks like a bug in Swift's constructor code, but maybe I am overlooking something?</p>
","15745","","","","","2021-10-31 14:36:19","Why does Combine assign crash when writing to an optional property?","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"63669884","1","63670000","","2020-08-31 11:25:02","","8","6838","<p>I have a view with a view model, and actions in this view can change the view model. To be able to break out logic into reusable pieces, I have part of the view as its own view, with a @Binding to the values it needs to have. Now, I want to be able to perform some logic based on the value changes, not necessarily only view changes. How can I do that? If it was a regular property, I'd implement a didSet, but that gets me nowhere. I wanted to use Combine to and treat the @Binding as a publisher, but I couldn't find a way to do that either. Suggestions?</p>
<p>Here's the code:</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {
    @Published var counter: Int = 0
}

struct Greeter: View {
    @Binding var counter: Int {
        didSet {
            // this isn't printed....
            print(&quot;Did set -&gt; \(counter)&quot;)
        }
    }
    
    init(counter: Binding&lt;Int&gt;) {
        self._counter = counter
        
        // ...so how about setting up a subscription to the @Binding counter above here?
    }
    
    var body: some View {
        Text(&quot;Hello, world #\(counter)!&quot;)
            .padding()
    }
}

struct ContentView: View {
    
    @ObservedObject var viewModel: ViewModel
    
    var body: some View {
        VStack {
            Greeter(counter: $viewModel.counter)
            Button(&quot;Go!&quot;) {
                viewModel.counter += 1
            }
        }
    }
}
</code></pre>
<p>So I want to retain the structure where the data is in a ViewModel, and that only parts of it is being passed down to the subview. And it is in the subview (Greeter) I want to be able to do something (let's say print the value like in the didSet)</p>
","80246","","","","","2022-08-23 13:41:03","SwiftUI/Combine: subscribe to value change of @Binding","<swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63678438","1","63682272","","2020-08-31 21:30:52","","3","1691","<p>I'm trying to update the main view with high frequency data coming from separate background thread.
I've created two tabviews and in case of slow update rate I can change the view. But in another case the UI doesn't react. I've observed this behavior only on real device, in the simulator works everything fine.</p>
<p>The while loop is still representing an imu, just to keep it simple.</p>
<p>Did someone any idea how to fix this issue?</p>
<p>Many thanks!</p>
<pre><code>import SwiftUI

struct ContentView: View {
    
    @EnvironmentObject var loop : Loop
    
    var body: some View {
        
        TabView{
        
            VStack {
                Text(&quot;Content View&quot;)
                LoopView()
            }.tabItem{
                  VStack{
                      Text(&quot;tab1&quot;)
                      Image(systemName: &quot;car&quot;)
                }
                
            }
            
            Text(&quot;second view&quot;).tabItem{
                                    VStack{
                                        Text(&quot;tab2&quot;)
                                        Image(systemName: &quot;star&quot;)
                }
            }
        }
    }
}


class Loop : ObservableObject {
    
    @Published var i : Int
    
    func startLoop() {
        while true {
            print(&quot;i = \(self.i)&quot;)
            DispatchQueue.main.async {
                self.i += 1
            }

            //sleep(1) // comment out to simulate worst case
        }
    }
    
    init() {
        DispatchQueue.global(qos: .background).async {
            self.startLoop()
        }
    }
}


struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
","6108653","","12299030","","2020-09-01 06:10:00","2020-09-01 10:30:50","SwiftUI updating UI with high frequency data","<mvvm><swiftui><observable><grand-central-dispatch><combine>","2","3","4","","","CC BY-SA 4.0"
"63691034","1","","","2020-09-01 15:41:34","","0","58","<p>I am trying to load HealthKit data and display a total distance and last workout date in a SwiftUI view (for a Widget).  I am getting the data in the print statement but it's not getting updated in the HTWidgetView below:</p>
<pre><code>     class WidgetViewModel: ObservableObject {
        
        @Published var workoutDate: Date = Date()
        @Published var totalDistance: Double = 0.0
        
        func getWorkoutDataForWidget() {
            WorkoutManager.loadWorkouts { (workouts, error) in
                DispatchQueue.main.async {
                    guard let unwrappedWorkouts = workouts else { return }
                    
                    if let first = unwrappedWorkouts.first {
                        self.workoutDate = first.startDate
                    }
                
                    let distancesFromWorkouts = unwrappedWorkouts.compactMap {$0.totalDistance?.doubleValue(for: .foot())}
                    
                    let total = distancesFromWorkouts.sum()
                
                    self.totalDistance = total
                    print(&quot;TOtal Distance = \(total)&quot;)
                    
                }
                
            }
            
        }
    }
    
    extension Sequence where Element: AdditiveArithmetic {
        func sum() -&gt; Element { reduce(.zero, +) }
    } 


struct HTWidgetView: View {

@ObservedObject var viewModel: WidgetViewModel

    var body: some View {
        VStack {
            Text(&quot;Last Workout = \(viewModel.workoutDate)&quot;)
        Text(&quot;Total Distance&quot;)
        Text(&quot;\(viewModel.totalDistance)&quot;)
        }
        .onAppear {
            viewModel.getWorkoutDataForWidget()
        }
    }
}
</code></pre>
","4625622","","","","","2020-09-01 16:42:53","Async call not getting updated using publisher in SwiftUI","<ios><swift><swiftui><combine><publisher>","0","2","","","","CC BY-SA 4.0"
"63696446","1","63696674","","2020-09-01 22:50:01","","3","946","<pre><code>class ObservableFormViewModel: ObservableObject {
  @Published var isSubmitAllowed: Bool = true
  @Published var username: String = &quot;&quot;
  @Published var password: String = &quot;&quot;
  var somethingElse: Int = 10
}

var form = ObservableFormViewModel()

let formSubscription = form.$isSubmitAllowed.sink { _ in
    print(&quot;Form changed: \(form.isSubmitAllowed) \&quot;\(form.username)\&quot; \&quot;\(form.password)\&quot;&quot;)
}


form.isSubmitAllowed = false
form.isSubmitAllowed = false
form.isSubmitAllowed = false
</code></pre>
<p>The output is:</p>
<pre class=""lang-swift prettyprint-override""><code>Form changed: true &quot;&quot; &quot;&quot;
Form changed: true &quot;&quot; &quot;&quot;
Form changed: false &quot;&quot; &quot;&quot;
Form changed: false &quot;&quot; &quot;&quot;
</code></pre>
<p>My question is:</p>
<ul>
<li>why <code>true</code> output comes 2 while <code>false</code> only 2?</li>
<li>any better way to remove duplicate?</li>
</ul>
","1861935","","8697793","","2020-09-02 08:10:43","2020-09-02 08:10:43","Swift Combine Publish Twice","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63701195","1","63701338","","2020-09-02 08:02:39","","0","652","<p>Lets say I want to create an asynchronous function that calls some random API and returns a random Int. I want wrap it using a future</p>
<pre><code>func createFuture() -&gt; Future&lt;Int, Never&gt; {
  return Future { promise in
    promise(.success(Int.random(1...10))
  }
}
</code></pre>
<p>This would return me the same output everytime. Instead i want to return AnyPublisher.</p>
<pre><code>func createAnyPublisher() -&gt; AnyPublisher&lt;Int, Never&gt; {  //This is invalid
    return AnyPublisher&lt;Int, Never&gt; { seed in
        seed.success(Int.random(in: 1...10))
    }
}
</code></pre>
<p>A better example:</p>
<pre><code>func guessNumber(num: Int) -&gt; AnyPublisher&lt;Bool, Never&gt; {
    asyncRandomNumber { winner in
        if num == winner {
            // return true
        } else {
            // return false
        }
    }
}

private func asyncRandomNumber(completion: (Int) -&gt; Void) {
    completion(Int.random(in: 1...10))
}
</code></pre>
<p>How do you wrap that asyncRandomNumber ?</p>
","588125","","4667835","","2020-09-02 08:31:05","2020-09-02 08:41:40","How to wrap an async function inside AnyPublisher?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"63701483","1","","","2020-09-02 08:21:55","","1","142","<p>I'm using the Amplify framework for my auth on the combine framework.</p>
<p>I want to check if the user is currently logged in. This is done by the following function</p>
<pre><code>Amplify.Auth.fetchAuthSession()
</code></pre>
<p>This returns:</p>
<pre><code>AnyPublisher&lt;AuthSession,AuthError&gt;
</code></pre>
<p>I've put it in a function, so I can call it from my AuthenticationViewModel, which deals with the business login for auth.</p>
<pre><code>enum AuthenticationsFunctions {
    static func fetchCurrentAuthSession() -&gt; AnyPublisher&lt;AuthSession, AuthError&gt; {
        Amplify.Auth.fetchAuthSession().resultPublisher
    }
}
</code></pre>
<p>For my view model, it has states and events. In the code below, I want to call the authentication function and return the appropriate events. Such as .onAlreadyLoggedIn. Because the auth function returns a different publisher, I can't figure out how to return the appropriate event to AnyPublisher&lt;Event, Never&gt;</p>
<p>AuthSession has a function .isSignedIn which is a boolean.</p>
<pre><code>    static func fetchCurrentLogin() -&gt; Feedback&lt;State, Event&gt; {
    Feedback { (state: State) -&gt; AnyPublisher&lt;Event, Never&gt; in
        guard case .loading = state else { return Empty().eraseToAnyPublisher() } //Checks if the state is loading (When the app first opens)
        AuthenticationsFunctions.fetchCurrentAuthSession().allSatisfy { (AuthSession) -&gt; Bool in
            if (AuthSession.isSignedIn) {
                return true
            }
            else {
                return false
            }
        }
    }
}
</code></pre>
<p>Amazon on their docs provide this:</p>
<pre><code>func fetchCurrentAuthSession() -&gt; AnyCancellable {
    Amplify.Auth.fetchAuthSession().resultPublisher
        .eraseToAnyPublisher()
        .sink {
            if case let .failure(authError) = $0 {
                print(&quot;Fetch session failed with error \(authError)&quot;)
            }
        }
        receiveValue: { session in
            print(&quot;Is user signed in - \(session.isSignedIn)&quot;)
        }
}
</code></pre>
","12405722","","4667835","","2020-09-02 08:42:11","2020-09-02 08:42:11","Combine: converting one publisher to another in func","<ios><swift><combine>","0","0","","","","CC BY-SA 4.0"
"63706844","1","","","2020-09-02 13:41:56","","3","328","<p>First-time poster, long-time reader ... I've wrapped an async call to the Firebase Authorization API. I'm calling it from inside a SwiftUI View function.</p>
<pre><code>func authenticateFirebaseEmail(email: String, password: String) -&gt; 
    Future&lt;String, Error&gt; {
        return Future&lt;String,Error&gt; {  promise in
                Auth.auth().signIn(withEmail: email, password: password) { result, error in
            if let error=error {
                print(&quot;failure detected&quot;)
                promise(.failure(error))
            }
            
            if let result=result {
                print(&quot;result detected - returning success promise&quot;)
                promise(.success(result.user.email!))
            }
            
        }
    }
}
...

func logMeInFuncInView() {
        var cancellable : AnyCancellable?
        cancellable = authenticateFirebaseEmail(email: self.userEmail, password: self.password).map( {
            value in return value
        })
        .sink(receiveCompletion: { (completion) in
            print(&quot;completion received&quot;)
        }, receiveValue: { user in
            print(&quot;value received&quot;)
            self.errorMessage = user
            })
    }
</code></pre>
<p>The console output is as follows, but never reaches the &quot;completion received&quot; or &quot;value received&quot; calls:
<code>
result detected - returning successful promise
</code></p>
<p>Is the issue with the wrapped callback, the future, the way I'm using the future, or something that I'm not seeing entirely?</p>
","14178593","","","","","2020-09-02 14:06:47","Combine: Wrapped async call with Future, but Future.sink doesn't appear to complete","<firebase><swiftui><future><combine>","1","0","","","","CC BY-SA 4.0"
"63716390","1","","","2020-09-03 03:31:47","","1","269","<p>I have a API call that returns a Future and I need to combine it with another Future which I get from executing a query on a local DB and reconcile both. I am trying to find a more elegant way to do this without having to create another Future, because I do not want to type erase to AnyPublisher. This is a simplified code sample below.</p>
<pre><code>func fetchLocalDB() -&gt; Future&lt;[Result], Error&gt; {
    
    return Future&lt;[Result], Error&gt; {
        
        promise in
        self.managedObjectContext.publisher(for: Result.self)
            .sink { completion in /*promise(.failure())*/ }
            receiveValue: { results in
                
                promise(.success(results))
            }
            .store(in: &amp;self.anyCancellables)
    }
}

func fetchRemote() throws -&gt; Future&lt;[ResultData], Error&gt; {
    
    return Future&lt;[ResultData], Error&gt; {
        promise in
        
        APICall()
            .sink { completion in /*promise(.failure())*/ }
            .receiveValue: { resultsData in
                
                //process resultData, promise(.failure(error))
                promise(.success(processedResultsData))
            }
            .store(in: &amp;self.anyCancellables)
    }
}

func reconcile() {
    
    fetchRemote()
        .combineLatest(fetchLocalDB())
        .tryMap({/*reconcile data here*/})
}
</code></pre>
<p>I could use the map operator and type erase to AnyPublisher like below, but I would prefer having a Future to work with instead.</p>
<pre><code>func fetchLocalDB() -&gt; AnyPublisher&lt;[Result], Error&gt; {
    self.managedObjectContext.publisher(for: Result.self)
        .eraseToAnyPublisher()
}

func fetchRemote() throws -&gt; AnyPublisher&lt;[ResultData], Error&gt; {
   APICall()
       .tryMap: { resultsData throws -&gt; [ResultData] in

            //process resultData, throw error
            return processedResultsData
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>Any help is appreciated.</p>
","3970488","","","","","2020-09-03 03:31:47","Is there an elegant way to type erase a Publisher to Future in Combine?","<swift><combine>","0","3","","","","CC BY-SA 4.0"
"63717505","1","","","2020-09-03 05:39:54","","1","1100","<p>I have a bottom navigation view in my main View that I want to hide in some of the inner views by a <code>@published</code> variable that defined in ViewModel, but when I change the value of the variable all of the body refreshes in the main view and cause some problems(losing data). I want just to refresh the state of the bottom navigation, not the entire body. here is my code:</p>
<p><strong>MainView</strong></p>
<pre><code>struct MainView: View {
@ObservedObject var viewModel = MainViewModel()


var body: some View {
    ZStack {
        VStack{
            content
        }
        
            VStack {
                Spacer()
                BottomNavigationView(mainViewModel: self.viewModel)
                        .padding(.horizontal)
            }.opacity(viewModel.isBottomNavigationVisible ? 1 : 0)


    }
}

var content: some View {
    switch self.viewModel.currentView {
    case .plan:
        return PlanMainView(mainViewModel: viewModel).eraseToAnyView()
    case .me:
        return MeMainView(mainViewModel: viewModel).eraseToAnyView()
    case .onBoarding:
        return OnBoardingHome(mainViewModel: viewModel).eraseToAnyView()
}}
</code></pre>
<p><strong>MainViewModel</strong></p>
<pre><code>class MainViewModel: ObservableObject {
@Published private(set) var currentView: Modules = .main
@Published var isBottomNavigationVisible: Bool = true


func hideBottomBar() {
    self.isBottomNavigationVisible = false
}

func showBottomBar() {
    self.isBottomNavigationVisible = true
}

func GoToView(view: Modules) {
    self.currentView = view
}}
</code></pre>
<p><strong>MeMainView</strong></p>
<p>this is the view that I want to hide the bottom navigation in onAppear</p>
<pre><code>struct MeMainView: View {
@ObservedObject var mainViewModel:MainViewModel


var body: some View {
    ZStack {
       Text(&quot;MewView&quot;)
    }.onAppear{
        self.mainViewModel.hideBottomBar()
    }
}}
</code></pre>
","5892896","","","","","2022-02-28 16:24:53","how to prevent other views refreshing in state change swiftUI","<swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63723976","1","63724127","","2020-09-03 12:44:51","","2","35","<p>I try do achieve something simple. In AppDelegate I need <code>var vertices: [SCNVector3] = []</code>. In <code>@IBAction func getVertices(_ sender: Any)</code> I can read file and assign new value to <code>vertices</code>. Simple and works. But when I try to pass value to SwiftUI View I have problems.
If I define</p>
<pre><code>@State var vertices: [SCNVector3] = []

func applicationDidFinishLaunching(_ aNotification: Notification) {
    ....
    let contentView = CloudView(data: $vertices)
    ....
    window.contentView = NSHostingView(rootView: contentView)
    ...
}

@IBAction func getVertices(_ sender: Any) {
    ...
    do {
        let readVertices: [SCNVector3] = try... // read file and convert to [SCNVector3]
        vertcices = readVertices // assign or not to assign, this is a question
        print (readVertices.count, vertices.count)
    }
    ...
}
</code></pre>
<p>and it prints:</p>
<pre><code>3500 0
</code></pre>
<p>so, it never updates <code>CloudView</code>, <code>vertices</code> is always an empty array.</p>
<p>Could somebody explain me how I should do it in proper way?</p>
","1238267","","","","","2020-09-03 12:54:13","Swift Combine and SwiftUI understanding needs corrections","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63736373","1","","","2020-09-04 07:03:50","","0","585","<p>I have a model class which holders a few publishers as the source of truth. And I also have a few classes that processes data. I need to process data depending on a publisher from the model class.</p>
<pre><code>class Model: ObservableObject {
    @Published var records = [Record]()
    let recordProcessor: RecordProcessor

    init() {
        ...
    }
}

class RecordProcessor: ObservableObject {
    @Published var results = [Result]()
}

struct RootView: View {
    var body: some View {
        MyView()
            .environmentObject(Model())
    }
}

struct MyView: View {
    @EnvironmentObject var model: Model
    var body: some View {
        ForEach(model.recordProcessor.results) { ... }
    }
}
</code></pre>
<p><code>RecordProcessor</code> does a lot of work on records so the work is encapsulated into a class, but the input is the <code>records</code> stored on the <code>Model</code>. What is a proper way of passing in the <code>records</code> to the <code>RecordProcessor</code>?</p>
","359532","","","","","2020-09-05 06:55:38","How to pass a Publisher to a class","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"63769262","1","","","2020-09-06 21:59:33","","0","609","<p>I am trying to use an @ObservableObject viewModel which is declared as @ObservedObject inside my view struct. The problem is that when the viewModel changes it's &quot;domains&quot; property @Published var, the UI is not updating. Also, I change domains inside getDomains() function which is called inside init() {}. Looks like it is called twice, why is that happening? Here's my code for viewModel:</p>
<pre><code>import Combine

class DomainsViewModel: ObservableObject {

    @Published var domains: [InterestDomain] = [InterestDomain]()
    
    init() {
        self.getDomains { (response) in
            print(response)
        }
    }
    
    func getDomains(completion: @escaping (Bool) -&gt; Void) {
        NetworkEngine.shared.appNetwork.getInterestDomains { result in
            self.domains.removeAll()
            switch result {
            case .success(let domainsOfInterest):
                if let domainsList = domainsOfInterest {
                    self.domains = domainsList
                }
                completion(true)
            case .failure(_):
                completion(false)
            }
        }
    }

}
</code></pre>
<p>Code for the view:
import Foundation
import SwiftUI
import Combine</p>
<pre><code>struct DomainsOfInterestView: View {

    @ObservedObject var viewModel: DomainsViewModel = DomainsViewModel()
    
    @State var isActive = true
    
    var body: some View {
            VStack(alignment: .center) {
                HStack {
                    Text(&quot;Choose domains of interest for your profile&quot;)
                        .font(.headline)
                    Spacer()
                }.padding(.bottom, 16)
                
                ForEach(viewModel.domains.indices) { index in
                    DomainOfInterestElement(isActive: self.$isActive, domain: self.viewModel.domains[index].name)
                }

                OrangeButton(action: {
                }) {
                    Text(&quot;Save&quot;)
                }.padding(.top, 30)
                    .padding([.leading, .trailing], 30)
                Spacer()
            }.padding([.leading, .trailing], 12)
            .navigationBarTitle(&quot;Domains of interest&quot;)
    }
}

struct DomainsOfInterestView_Previews: PreviewProvider {
    static var previews: some View {
    DomainsOfInterestView()
    }
}

struct DomainOfInterestElement: View {
    @Binding var isActive: Bool
    var domain: String
    var body: some View {
        Button(action: {
            self.isActive.toggle()
        }) {
            VStack {
                Divider().padding(.bottom, 12)
                HStack {
                    checkBoxView()
                        .frame(width: 36, height: 36)
                    textView().font(.custom(&quot;SFProDisplay-Regular&quot;, size: 16))
                    Spacer()
                }
            }
        }
    }
    
    func checkBoxView() -&gt; Image {
        switch isActive {
        case true:
            return Image(uiImage: #imageLiteral(resourceName: &quot;check-box-active-2-1&quot;)).renderingMode(.original)
        case false:
            return Image(uiImage: #imageLiteral(resourceName: &quot;check-box-active-1&quot;)).renderingMode(.original)
        }
    }
    func textView() -&gt; Text {
        switch isActive {
        case true:
            return Text(domain)
                .foregroundColor(.black)
        case false:
            return Text(domain)
                .foregroundColor(Color.orGrayColor)
        }
    }
}
</code></pre>
<p>Could anyone help me please? Thanks.</p>
","13637073","","","","","2020-10-08 11:42:06","How should the viewModel object be declared in SwiftUI?","<swift><swiftui><reactive-programming><combine>","2","1","","","","CC BY-SA 4.0"
"63784003","1","","","2020-09-07 20:44:21","","0","467","<p>I am able to &quot;subscribe&quot; to a publisher as long as I don't include the keyword <code>subscribe</code></p>
<pre><code>var somePublisher: AnyPublisher&lt;(), Never&gt; { get }
...
cancellable = somePublisher
   .receive(on: DispatchQueue.global(qos: .background))
   .sink(receiveValue: { _ in
       Log.d(&quot;This works... isMainThread=\(Thread.isMainThread)&quot;)
   })

prints &quot;This works... isMainThread=false
</code></pre>
<p>But if I add a subscriber, so that I can use modifiers like map {}, on the background thread (or any thread for that matter, I tried main), sink never runs.</p>
<pre><code>var somePublisher: AnyPublisher&lt;(), Never&gt; { get }
...
cancellable = somePublisher
   .subscribe(on: DispatchQueue.global(qos: .background))
   .receive(on: DispatchQueue.global(qos: .background))
   .sink(receiveValue: { _ in
       Log.d(&quot;This DOES NOT work... isMainThread=\(Thread.isMainThread)&quot;)
   })
OR
var somePublisher: AnyPublisher&lt;(), Never&gt; { get }
...
cancellable = somePublisher
   .subscribe(on: DispatchQueue.main)
   .receive(on: DispatchQueue.global(qos: .background))
   .sink(receiveValue: { _ in
       Log.d(&quot;This DOES NOT work... isMainThread=\(Thread.isMainThread)&quot;)
   })
Nothing prints, the breakpoint is never hit. Sink never executes
</code></pre>
<p>What am I missing here? What about the subscribe is causing my subscriber to fail?</p>
","6352333","","","","","2020-09-07 20:44:21","Combine - receiveOn works, subscribeOn doesn't, regardless of thread","<ios><swift><iphone><combine>","0","5","","","","CC BY-SA 4.0"
"63784923","1","63786860","","2020-09-07 22:19:48","","1","2854","<p>Using Combine and UIKit, I am trying to update my tableview when the array contained in the viewModel changes. My tableview's datasource is separate because I would like to reuse the file (Different objects all have a name var, so the tableviews will display a list of names).</p>
<p>The viewModel:</p>
<pre><code>class ViewModel {
  @Published var items = [ItemViewModel]()
  let service = NetworkService()

  init() {
    fetchItems()
  }
    
  func fetchItems() {
    service.fetchItems { items in {
    self.items = items.map { ItemViewModel($0) }
  }
}
</code></pre>
<p>The datasource:</p>
<pre><code>class GenericDataSource: UITableViewDataSource {
   var list = [String]()

   func setList(_ list: [String]) {
       self.list = list
   }

  // then the usual tableView datasource boilerplate
}
</code></pre>
<p>The viewController:</p>
<pre><code>class ViewController: UIViewController {
  let viewModel = ViewModel()
  let tableDataSouce = GenericDataSource()
  var subscriptions = Set&lt;AnyCancellable&gt;()

  func setupBinding() {
    // I want to: 1) map over viewModel.$items to get [item.name]
    //            2) assign the list of names to tableDataSource.list
    //            3) reload the tableview so the new values are displayed
  }
</code></pre>
<p>I'm not sure what Combine functions to use. My current (working) code is as follows:</p>
<pre><code>func setupBinding() {
     viewModel.$items.handleEvents(receiveOutput: { [weak self] items in
         self?.dataSource.setList(items.map { $0.name })
         
            // dispatch called because I get yelled at for not being on main thread
            DispatchQueue.main.async { 
                 self?.itemsTableView.reloadData()
            }
        })
           .sink { _ in }
           .store(in: &amp;subscriptions)
 }
</code></pre>
<p>It works, but I feel like I'm brute forcing it. Is there a cleaner way to perform the binding with the current setup?</p>
<p>Is there a cleaner way to setup the code so the binding will be easier?</p>
","8767479","","","","","2020-09-08 03:52:01","Swift UIKit Combine - How to reload tableview when handling publisher events?","<swift><mvvm><uikit><tableview><combine>","1","0","1","","","CC BY-SA 4.0"
"63788210","1","63788656","","2020-09-08 06:28:04","","1","8276","<p>I started using combine and it's really cool but currently I have no idea how to fix it. I want to make a POST Request using combine so I have to decode Data, create my request, send it and after that return an</p>
<pre><code>AnyPublisher&lt;Void, Error&gt;
</code></pre>
<p>Currently my code looks like this:</p>
<pre><code>func postData&lt;T&gt;(withURL urlRequest: URLRequest, object: T) -&gt; AnyPublisher&lt;Void, Error&gt; where T: Encodable {

        return Just(object)
        .encode(encoder: JSONEncoder())
        .mapError {
            let error = self.classifyError($0)
            return error
        }
        .map { data -&gt; URLRequest in
            var request = urlRequest
            //BUILD REQUEST
            return request
        }
        .flatMap { request in
            let dataTaskPublisher: AnyPublisher&lt;URLSession.DataTaskPublisher.Output, URLSession.DataTaskPublisher.Failure&gt; = URLSession.DataTaskPublisher(request: request, session: .shared)

            return dataTaskPublisher
            .tryMap { try self.throwErrorOrContinue(data: $0, basedOnResponse: $1) }
            .decode(type: T.self, decoder: JSONDecoder())
            .mapError { return self.handle(error: $0, from: urlRequest, object: T.self) }
        }
        .eraseToAnyPublisher()
    }
</code></pre>
<p>And he tells me:</p>
<pre><code>Cannot convert return expression of type 'AnyPublisher&lt;Publishers.FlatMap&lt;_, Publishers.Map&lt;Publishers.MapError&lt;Publishers.Encode&lt;Just&lt;T&gt;, JSONEncoder&gt;, _&gt;, URLRequest&gt;&gt;.Output, Publishers.FlatMap&lt;_, Publishers.Map&lt;Publishers.MapError&lt;Publishers.Encode&lt;Just&lt;T&gt;, JSONEncoder&gt;, _&gt;, URLRequest&gt;&gt;.Failure&gt;' (aka 'AnyPublisher&lt;_.Output, _&gt;') 
to return type 'AnyPublisher&lt;Void, Error&gt;'
</code></pre>
<p>I tried some mapping but it didn't work and I have no idea what he wants from me. Maybe one of you knows the problem? Thanks :)</p>
","4906484","","","","","2020-09-08 07:00:50","Swift Combine return AnyPublisher<Void, Error> with FlatMap (POST Request)","<ios><swift><post><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"63793261","1","64212326","","2020-09-08 11:47:35","","6","3288","<p>My data model property is declared in my table view controller, and the SwiftUI view is modally presented. I'd like the presented <code>Form</code> input to manipulate the data model. The resources I've found on data flow are just between SwiftUI views, and the resources I've found on UIKit integration are on embedding UIKit in SwiftUI rather than the other way around.</p>
<p>Furthermore, is there a good approach for a value type (in my case struct) data model, or would it be worth remodeling it as a class so that it's a reference type?</p>
","1294854","","1294854","","2020-10-03 21:48:24","2022-08-23 14:18:05","How do you share a data model between a UIKit view controller and a SwiftUI view that it presents?","<swift><swiftui><uikit><combine>","2","6","","","","CC BY-SA 4.0"
"63794722","1","63794873","","2020-09-08 13:14:14","","0","785","<p>Here is a pseudo code of what I need to achieve:</p>
<pre><code>func apiRequest1() -&gt; Future&lt;ResultType1, Error&gt; { ... }
func apiRequest2() -&gt; Future&lt;ResultType2, Error&gt; { ... }
func transform(res1: ResultType1, res2: ResultType2) -&gt; ResultType3 { ... }

func combinedApiRequests() -&gt; Future&lt;ResultType3, Error&gt; {
    (resultType1, resultType2) = execute apiRequest1() and apiRequest2() asynchronously
    resultType3 = transform(resultType1, resultType2)
    return a Future publisher with resultType3
}
</code></pre>
<p>How would <code>combinedApiRequests()</code> look?</p>
","945711","","","","","2020-09-08 13:23:00","Swift Combine framework multiple async request responses into one","<swift><zip><combine>","1","0","","","","CC BY-SA 4.0"
"63797060","1","63797546","","2020-09-08 15:28:08","","0","570","<p>I am trying to save Checkin time preferences of a user (to send them notification reminders). So far I've been able to save a Bool and string to UserDefaults but I'm unable to figure out how to save the <strong>time</strong> preference. Here's my UserSettings class to store the preferences.</p>
<pre><code>public class UserSettings: ObservableObject {
    
    
    @Published var eveningCheckin: Bool {
        didSet{
            UserDefaults.standard.set(eveningCheckin, forKey: &quot;eveningCheckin&quot;)
            print(&quot;Evening checkin toggle value in didSET to \(self.eveningCheckin)&quot;)
            
        }
    }
    
    @Published var eveningCheckinTime: Date {
        didSet{
            UserDefaults.standard.set(eveningCheckinTime, forKey: &quot;eveningCheckinTime&quot;)
            print(&quot;Evening checkin didSet to \(self.eveningCheckinTime)&quot;)
        }
    }
    
    
    init() {

        self.eveningCheckin = UserDefaults.standard.object(forKey: &quot;eveningCheckin&quot;) as? Bool ?? false
        self.eveningCheckinTime = UserDefaults.standard.object(forKey: &quot;eveningCheckinTime&quot;) as? Date ?? Date(timeIntervalSince1970: 64800)
        print(&quot;Evening checkin time init to \(self.eveningCheckinTime)&quot;)// --&gt; To debug
        print(&quot;Evening checkin toggle value in init to \(self.eveningCheckin)&quot;)
    }
}
</code></pre>
<p>I want to set this Evening checkin time up with a Time picker that SwiftUI provides like this. Here are my Settings and Timepicker views.</p>
<pre><code>import SwiftUI

struct SettingsMain: View {
    @ObservedObject var userSettings = UserSettings()
    @State private var showTimepickerEvening = false

    var body: some View {
        NavigationView{
            ScrollView {
                VStack {
                    //Evening checkins
                    Button(action: {
                        //Show 🌙 Evening time picker sheet
                        self.showTimepickerEvening.toggle()
                    }) {
                        HStack {
                            Text(&quot;\(userSettings.eveningCheckinTime.hour12):\(userSettings.eveningCheckinTime.minute0x) \(userSettings.eveningCheckinTime.amPM.lowercased()) &quot;)
                            Text(&quot;Change &gt;&quot;)
                        }
                    }
                    .sheet(isPresented: $showTimepickerEvening) {
                        //Sheet view with the Timepicker
                        TimePickerView(pickedTime: self.$userSettings.eveningCheckinTime)
                    }
                }
                .buttonStyle(PlainButtonStyle())
            }
            .navigationBarTitle(&quot;Preferences&quot;, displayMode: .inline)
        }
    }
}

struct TimePickerView: View {
    @Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;
    @Binding var pickedTime: Date
    
    var body: some View {
        VStack {
            DatePicker(&quot;Checkin time&quot;, selection: $pickedTime, displayedComponents: .hourAndMinute)
            .labelsHidden()
            
            Button(action: {
                    //Dimiss. Should I actually update my UserDefaults here as well?
                self.presentationMode.wrappedValue.dismiss()
                }) {
                    ZStack {
                        ColorManager.buttonGrey
                        Text(&quot;Save time&quot;)
                            .font(.system(size: 20))
                            .fontWeight(.semibold)
                    }
                    .frame(height: 64)
                }
            .padding(.all)
            .buttonStyle(PlainButtonStyle())
        }
        .background(Color.white)
    }
}
</code></pre>
<p><strong>My problem is that the Time picker does setup the time into the @Published var BUT it get's reset with the init statement. It does not happen with the Bool value. Why??</strong></p>
<p>Here's the output from the print() statements above: Basically means that every time I'm trying to use the Datepicker to set the time -&gt; didSet does choose the new time but init() resets it back to default.</p>
<blockquote>
<p>Evening checkin didSet to 1970-01-01 12:12:00 +0000</p>
<p>Evening checkin time init to 1970-01-01 18:00:00 +0000</p>
<p>Evening checkin toggle value in init to true</p>
<p>Evening checkin didSet to 1970-01-01 12:13:00 +0000</p>
<p>Evening checkin time init to 1970-01-01 18:00:00 +0000</p>
<p>Evening checkin toggle value in init to true</p>
</blockquote>
","1441582","","4667835","","2020-09-08 15:57:47","2020-09-08 16:08:02","Saving Date/Time to UserDefaults through didSet on @Published var (from TimePicker component of SwiftUI)","<swift><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"63799351","1","","","2020-09-08 18:03:38","","1","146","<p>I'm learning Combine in Swift. I'm trying to load some data from an URL. Let's call it <code>Key</code>.</p>
<pre><code>class Key: Decodable {
    let name: String
}
</code></pre>
<p>The data has to be stored in this <code>KeyContainer</code> in this example. It's a third party tool in my actual app. I'm just using a simplified version for this example.</p>
<pre><code>class KeyContainer {
    var keys = [Key]()
    func store(key: Key) -&gt; Self {
        keys.append(key)
        return self
    }
}
</code></pre>
<p>I have created a <code>KeyLoader</code> which has a function <code>fetchOrUseExisting</code>. The goal is either downloaded a key or use the previously downloaded key from a specific URL. I want to store the URL that I used to download the key and on subsequent calls, use the previously downloaded key.</p>
<p>My issue is with how I'm storing that key in the chain of calls. <code>self.completedUrls.insert(url)</code>.</p>
<ol>
<li>It references self which I think creates a retain cycle</li>
<li>It doesn't seem, for lack of a better word, &quot;reactive&quot; in this chain of transformations.</li>
</ol>
<p>Is there a more &quot;reactive&quot; way to store the URL that was used so that I don't download it again?</p>
<pre><code>class KeyLoader {
    var completedUrls = Set&lt;URL&gt;()
    private let _container = KeyContainer()
    
    func fetchOrUseExisting(from url: URL) -&gt; AnyPublisher&lt;KeyContainer, Error&gt; {
        //Using a local var so that I don't retain a reference to self in the publisher
        let theContainer = _container
        //If we previously fetched the key, don't do it again
        guard !completedUrls.contains(url) else {
            return Just(_container).tryMap({ $0 }).eraseToAnyPublisher()
        }
        //We didn't fetch it, fetch it now
        return URLSession.shared
            .dataTaskPublisher(for: URLRequest(url: url))
            .map(\.data)
            .decode(type: Key.self, decoder: JSONDecoder())
            .map({ theContainer.store(key: $0) })
            .map({
                //Store URL used to download key
                // :( Referencing self and performing a side effect unrelated to the transform
                self.completedUrls.insert(url)
                return $0
            })
            .eraseToAnyPublisher()
    }
}
</code></pre>
","251420","","","","","2020-09-08 18:03:38","Storing a value when using Combine","<swift><reactive><combine>","0","2","0","","","CC BY-SA 4.0"
"63806177","1","","","2020-09-09 06:47:26","","4","1527","<p>I'm using Alamofire and its Combine helpers to do a simple network request as follows:</p>
<pre><code>class AlamofireClient {
    func getData&lt;T: Decodable&gt;(request: URLRequestConvertible) -&gt; AnyPublisher&lt;T, APIError&gt; {
         AF.request(request)
            .validate()
            .publishDecodable(type: T.self)
            .value()
            .mapError(APIError.init(error:))
            .eraseToAnyPublisher()
    }
}

enum APIError: Error {
    init(error: AFError) {
        self = .network
    }
    
    case network
    case custom(Int, String, String)
    
    var message: String {
        switch self {
        case .network:
            return &quot;Network Error&quot;
        case .custom(let code, let message, let technicalMessage):
            return &quot;Custom error info are: \(code) -- \(message) -- \(technicalMessage)&quot;
        }
    }
}
</code></pre>
<p>I'm stuck at extracting the custom error info that is returned from the server, which's in my case has 3 items: code, message and technicalMessage.</p>
","1056118","","","","","2021-03-11 22:06:00","Alamofire+Combine: how to get custom error type out of AFError","<ios><swift><alamofire><combine>","1","4","2","","","CC BY-SA 4.0"
"63818675","1","","","2020-09-09 19:52:32","","2","1240","<p>I have a <code>CurrentValueSubject</code> that's an array of <code>ChatModelFirebase</code>. What I want to do is remove all <code>ChatModelFirebase</code> models that have a status field of &quot;canceled&quot;. The issue is that when I apply <code>.filter(..)</code> operator it's acting on the entire array and not the individual items.</p>
<pre><code>var chatFirebaseModels: CurrentValueSubject&lt;[ChatModelFirebase], Never&gt; = CurrentValueSubject([])

chatFirebaseModels
    .filter({ (chatModelFireBaseArray) -&gt; Bool in
        // I want individual array items, not chatModelFireBaseArray
        return false
    })
</code></pre>
<p>Here is what code completion looks like:</p>
<p><a href=""https://i.stack.imgur.com/QyAm0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QyAm0.png"" alt=""enter image description here"" /></a></p>
<p>You can see that <code>.filter(..)</code> is being applied to the <code>[ChatModelFirebase]</code> array and not the individual <code>ChatModelFirebase</code> models.</p>
<p>Is the answer here to just use <code>.flatMap(..)</code>? I am curious if there is a right way of using <code>.filter(...)</code>, hence my question.</p>
","577878","","","","","2020-09-09 23:53:27","How to apply .filter operator on individual elements of a CurrentValueSubject that's an array in Swift Combine?","<swift><swift5><combine>","1","4","","","","CC BY-SA 4.0"
"63821754","1","63821841","","2020-09-10 01:56:16","","2","333","<p>I don't understand why this doesn't compile. It does if I remove the <code>where</code> restriction from the <code>P</code> type.</p>
<pre><code>import Combine

protocol Foo {
    associatedtype P: Publisher where P.Output == Int
    var publisher: P { get }
}

struct Bar: Foo {
    var publisher: some Publisher {
        Just(1)
    }
}
</code></pre>
<p>The error says that <code>Type 'Bar' does not conform to protocol 'Foo'</code>. I guess it's because <code>publisher</code> return type is not just any <code>some Publisher</code>. But in SwiftUI, the <code>View</code> uses a similar approach, just that it doesn't have restrictions over the <code>View</code> type.</p>
<p>Is there any way I can make this code to compile?</p>
","737419","","5133585","","2020-09-10 02:27:05","2020-09-10 02:27:05","""some Protocol"" causes type to not conform to protocol","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63828838","1","","","2020-09-10 11:34:52","","0","153","<p>I was wondering why is that <code>Published</code> property wrapper fires in <code>willSet</code> and not in <code>didSet</code>. For the UI this probably doesn't make a difference, but for a lot of other places a property wrapper that reacts to <code>didSet</code> would make more sense because we can read new value when reacting to the change. I used to work with a custom <code>property wrapper</code> that wraps <code>CurrentValueSubject</code>, and then I have this kind of behavior. Just wondering why it is designed this way. Does it have some puropse?</p>
","4528716","","","","","2020-09-10 11:34:52","Why does SwiftUI react to willSet in Published","<swift><swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"63850101","1","","","2020-09-11 15:33:02","","2","1106","<p>I have always placed the DisposeBag in ViewController in MVVM with RxSwift like it said in this topic:</p>
<p><a href=""https://stackoverflow.com/questions/50382711/on-ios-for-the-disposebag-in-mvvm-can-it-be-placed-in-viewmodel"">On iOS, for the DisposeBag in MVVM, can it be placed in ViewModel?</a></p>
<p>But with combine, since the View is a struct and cancelable can't be placed in this, I am stuck with solution.</p>
<p>How to manage subscription between View and VM in Combine without add cancelable in ViewModel</p>
<p>Or maybe, in SwiftUI / Combine, there is no choice to place cancelables in VM.</p>
<p>There is an example of implementation in SiwftUI / Combine :</p>
<p>The ViewModel</p>
<pre><code>
class EquityViewModel: ObservableObject {
    
    @Injected private var api: AlphaVantageAPI
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private let code: String
    @Published private var result: Quote?
    @Published var price: String = &quot;&quot;
    
    init(code: String) {
        self.code = code
        self.$result
            .map {
                return &quot;\($0?.price ?? 0) €&quot;
            }.assign(to: &amp;$price)
    }
    
    
    func addToPortfolio(){
        
    }
    
    func onAppear() {
        self.api.quote(symbol: self.code).share()
            .sink { completion in }
                receiveValue: { quote in
                    self.result = quote.quote
                }
            .store(in: &amp;cancellables)
    }
    
}
</code></pre>
<p>The View</p>
<pre><code>struct EquityView: View {
    
    @ObservedObject  var viewModel: EquityViewModel
    
    init(viewModel: EquityViewModel) {
        self.viewModel = viewModel
    }
    
    var body: some View {
        ZStack {
            Color(&quot;primary&quot;).edgesIgnoringSafeArea(.all)
            VStack {
                Text(&quot;Stock Price&quot;)
                    .foregroundColor(.white)
                    .frame(minWidth: 0,
                           maxWidth: .infinity,
                           alignment: .topLeading)
                    .padding()
                HStack {
                    Text(self.viewModel.price)
                        .foregroundColor(.white)
                    Text(&quot;+4.75 %&quot;)
                        .foregroundColor(.white)
                        .padding(.leading, 20)
                }.frame(minWidth: 0,
                        maxWidth: .infinity,
                        alignment: .topLeading)
                .padding()
                Button(action: self.viewModel.addToPortfolio, label: {
                    Text(&quot;Add to portfolio&quot;)
                        .foregroundColor(.white)
                        .frame(minWidth: 0,
                                maxWidth: .infinity,
                                maxHeight: 30,
                                alignment: .center)
                        .background(Color.blue)
                        .cornerRadius(5)
                }).padding()
                Spacer()
            }
        }.frame(alignment: .leading)
        .onAppear(perform: self.viewModel.onAppear)
    }
}
</code></pre>
","2611161","","","","","2022-09-02 17:56:04","With SwiftUI / Combine, How to avoid to put cancellables in ViewModel","<mvvm><swiftui><reactive-programming><rx-swift><combine>","2","2","1","","","CC BY-SA 4.0"
"63857853","1","63858028","","2020-09-12 07:13:00","","1","392","<p>I'm trying to share the output of a sequence. Why I don't have any values in the second subscription after I add the <code>share</code> operator?</p>
<pre><code>import Combine

var cancellables = Set&lt;AnyCancellable&gt;()

let test = [1,2,3].publisher.print().share()

test.sink { value in
    print(&quot;Go&quot;)
}.store(in: &amp;cancellables)

test.sink { value in
    print(&quot;no go ?&quot;)
}.store(in: &amp;cancellables)
</code></pre>
<p>The output is:</p>
<pre><code>receive subscription: ([1, 2, 3])
request unlimited
receive value: (1)
Go
receive value: (2)
Go
receive value: (3)
Go
receive finished
</code></pre>
","588125","","","","","2020-09-12 07:33:42","Swift Combine share operator not working?","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"63863645","1","63864562","","2020-09-12 18:31:17","","1","1240","<p>With a Combine <code>Publisher</code>, I can use the following to call a closure whenever a value changes:</p>
<pre><code>let cancellable = x.sink { value in … }
</code></pre>
<p>How can I achieve the same behaviour with a variable marked <code>@State</code> or <code>@Binding</code>?</p>
","11636607","","","","","2022-04-13 21:05:36","How to attach subscriber to State or Binding in SwiftUI/Combine?","<swift><binding><state><combine><publisher>","1","3","","","","CC BY-SA 4.0"
"63894805","1","","","2020-09-15 03:52:21","","0","277","<p>Here is my code. If i remove/commment out debounce, it works. Not sure why?</p>
<pre><code>URLSession.shared.dataTaskPublisher(for: url)
            .debounce(for: .milliseconds(500), scheduler: RunLoop.main)
            .map {
                $0.data
            }
            .decode(type: [Course].self, decoder: JSONDecoder())
            .replaceError(with: [])
            .receive(on: RunLoop.main)
            .print()
            .eraseToAnyPublisher()
            .sink(receiveValue: { posts in
                self.courses = posts
            })
            .store(in: &amp;bag)
</code></pre>
","1861935","","","","","2020-09-15 04:00:23","Debounce in Combine Stop Publishing","<swift><combine>","0","3","","","","CC BY-SA 4.0"
"63905441","1","63907976","","2020-09-15 15:46:30","","2","818","<p>I have the following SwiftUI View:</p>
<pre><code>struct ProductView: View {
@ObservedObject var productViewModel: ProductViewModel


var body: some View {
    VStack {
        ZStack(alignment: .top) {
            if(self.productViewModel.product != nil) {
                URLImage(url: self.productViewModel.product!.imageurl, itemColor: self.productViewModel.selectedColor)
            }
            else {
                Image(&quot;loading&quot;)
            } 
        }
    }
}
</code></pre>
<p>that observes a ProductViewModel</p>
<pre><code>class ProductViewModel: ObservableObject {

@Published var selectedColor: UIColor = .white

@Published var product: Product?


private var cancellable: AnyCancellable!

init(productFuture: Future&lt;Product, Never&gt;) {

    self.cancellable = productFuture.sink(receiveCompletion: { comp in
            print(comp)
        }, receiveValue: { product in
            
            self.product = product
            print(self.product)  // this prints the expected product. The network call works just fine


        })


}
</code></pre>
<p>The Product is a Swift struct that contains several string properties:</p>
<pre><code>struct Product {
    let id: String
    let imageurl: String
    let price: String

}
</code></pre>
<p>It is fetched from a remote API. The service that does the fetching returns a Combine future and passes it to the view model like so:</p>
<pre><code>let productFuture = retrieveProduct(productID: &quot;1&quot;)
let productVM = ProductViewModel(productFuture: productFuture)
let productView = ProductView(productViewModel: productViewModel)


func retrieveProduct(productID: String) -&gt; Future&lt;Product, Never&gt;{
    
    let future = Future&lt;Product, Never&gt; { promise in

    //  networking logic that fetches the remote product,  once it finishes the success callback is invoked


        promise(.success(product))
    }

    return future
}
</code></pre>
<p>For the sake of brevity, I've excluded the networking and error handling logic since it is irrelevant for the case at hand. To reproduce this as quickly as possible, just initialize a mock product with some dummy values and pass it to the success callback with a delay like this:</p>
<pre><code>let mockproduct = Product(id: &quot;1&quot;, imageurl: &quot;https://exampleurl.com&quot;, price: &quot;$10&quot;)

DispatchQueue.main.asyncAfter(deadline: .now() + 2.0, execute: {
    promise(.success(mockproduct))
})
</code></pre>
<p>Once the product arrives over the network, it is assigned to the published product property.
The fetching works and the correct value is assigned to the published property. Obviously this happens after the view has been created since the network call takes some time. However, the View never updates even though the published object is changed.</p>
<p>When I pass the product directly through the View Model initializer rather than the future, it works as expected and the view displays the correct product.</p>
<p>Any suggestions on why the view does not react to changes in the state of the view model when it is updated asynchronously through the combine future?</p>
<p>EDIT: When I asked this question I had the ProductViewModel + ProductView nested inside another view. So basically the productview was only a part of a larger CategoryView. The CategoryViewmodel initialized both the ProductViewModel and the ProductView in a dedicated method:</p>
<pre><code>func createProductView() -&gt; AnyView {
    let productVM = productViewModels[productIndex]
    return AnyView(ProductView(productViewModel: productVM))
}
</code></pre>
<p>which was then called by the CategoryView on every update. I guess this got the Published variables in the nested ProductViewModel to not update correctly because the view hierarchy from CategoryView downwards got rebuilt on every update. Accordingly, the method createProductView got invoked on every new update, resulting in a completely new initialization of the ProductView + ProductViewModel.</p>
<p>Maybe someone with more experience with SwiftUI can comment on this.</p>
<p>Is it generally a bad idea to have nested observable objects in nested views or is there a way to make this work that is not an antipattern?</p>
<p>If not, how do you usually solve this problem when you have nested views that each have their own states?</p>
","4572811","","4572811","","2020-09-21 08:11:00","2020-09-21 08:11:00","SwiftUI View not updating on async change to published properties of Observed Object","<swiftui><combine><observedobject>","1","4","","","","CC BY-SA 4.0"
"63909394","1","63912928","","2020-09-15 20:27:34","","1","285","<p>I'm trying to bind properties together in the view and couldn't find anything better specifically for it. This is what I'm doing:</p>
<pre><code>struct ContentView: View {
    @ObservedObject var model: MyModel
    @State var selectedID: Int

    var body: some View {
        Picker(&quot;Choose&quot;, selection: $selectedID) {
              Text(&quot;Abc&quot;).tag(0)
              Text(&quot;Def&quot;).tag(1)
              Text(&quot;Ghi&quot;).tag(2)
        }
        .onChange(of: model.item?.selectedID) {
            selectedID = $0
        }
    }
}
</code></pre>
<p>Is there a better way to bind properties together?</p>
","235334","","","","","2020-09-16 04:01:36","Assign property values together in SwiftUI view?","<swift><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"63926305","1","63927445","","2020-09-16 18:52:44","","9","4977","<p>How can I rewrite <code>ReactiveSwift/ReactiveCocoa</code> code using <code>Combine</code> framework? I attached screenshot what <code>combinePrevious</code> mean from docs.</p>
<pre><code>let producer = SignalProducer&lt;Int, Never&gt;([1, 2, 3]).combinePrevious(0)
producer.startWithValues { value in
    print(value) // print: (0, 1), (1, 2), (2, 3)
}
</code></pre>
<p><a href=""https://i.stack.imgur.com/EvfdN.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/EvfdN.png"" alt=""enter image description here"" /></a></p>
","11079607","","11079607","","2020-09-17 13:02:27","2022-08-25 13:38:47","Combine previous value using Combine","<swift><reactive-cocoa><combine><reactive-swift>","3","0","1","","","CC BY-SA 4.0"
"63938304","1","","","2020-09-17 12:44:03","","1","454","<p>I am trying to create a custom SwiftUI View but I am getting problem in updating value through ObservedObject.</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @ObservedObject var model:InfoViewModel = InfoViewModel()
    var body: some View {
        VStack(alignment: .leading){
            CustomView(value: self.model.title)
                .frame(width: 200, height: 200, alignment: .center)
        }
        .background(Color.green)
        .frame(minWidth: 0,
               maxWidth: .infinity,
               minHeight: 0,
               maxHeight: .infinity,
               alignment: .topLeading)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

struct CustomView: UIViewRepresentable {
    typealias UIViewType = UIView
    var value:String
    var lblTitle:UILabel = UILabel()
    func makeUIView(context: Context) -&gt; UIView {
        let view:UIView = UIView()
        view.addSubview(lblTitle)
        lblTitle.text = value
        lblTitle.frame = CGRect(x: 0, y: 0, width: 100, height: 100)
        lblTitle.backgroundColor = UIColor.red
        lblTitle.textColor = UIColor.black
        return view
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
        self.lblTitle.text = value
        print(&quot;LBLTitle:\(self.lblTitle.text!)\nTitleValue:\(self.value)&quot;)
    }
}


class InfoViewModel: ObservableObject, Identifiable {
    @Published var title = &quot;Title&quot;
    private var count = 0
    init() {
        _ = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(fireTimer), userInfo: nil, repeats: true)
    }
    
    @objc func fireTimer() {
        count += 1
        
        self.title = &quot;\(self.count)&quot;
        print(&quot;Timer fired!\n\(self.title)&quot;)
    }
}
</code></pre>
<p><a href=""https://www.dropbox.com/s/zwnpm4r9ffy6nrn/UIViewRepresentableDemo.zip?dl=0"" rel=""nofollow noreferrer"">Project can be download from here</a></p>
<p>Edit:
I changed code after @Asperi answer now it is updating value. but as  Dávid Pásztor suggested it is not right to create @ObservedObject inside struct then how I will pass the value to CustomView with creating @ObservedObject and link that David provided is old and code in that thread now seems not working.</p>
<p>Here is the code that is working</p>
<pre><code>struct CustomView: UIViewRepresentable {
    typealias UIViewType = UIView
    var value:String
    
    func makeUIView(context: Context) -&gt; UIView {
        let view:UIView = UIView()
        let lblTitle:UILabel = UILabel()
        view.addSubview(lblTitle)
        lblTitle.text = value
        lblTitle.frame = CGRect(x: 0, y: 0, width: 100, height: 100)
        lblTitle.backgroundColor = UIColor.red
        lblTitle.textColor = UIColor.black
        return view
    }
    
    func updateUIView(_ uiView: UIView, context: Context) {
        for view in uiView.subviews
        {
            if(view.isKind(of: UILabel.self))
            {
                (view as! UILabel).text = value
                print(&quot;LBLTitle:\((view as! UILabel).text!)\nTitleValue:\(self.value)&quot;)
            }
        }
        
        
    }
}
</code></pre>
","3851580","","3851580","","2020-09-17 13:11:31","2020-09-17 13:11:31","UIViewRepresentable view not updating value","<ios><swift><swiftui><combine><uiviewrepresentable>","1","1","","","","CC BY-SA 4.0"
"63938627","1","","","2020-09-17 13:02:24","","0","753","<pre><code>func reqAuth(serviceParams: AuthServiceParams) -&gt; AnyPublisher&lt;AuthResponse, Error&gt; {
    
    var subject = PassthroughSubject&lt;Any,Error&gt;()
    
    AlamofireService.auth(serviceParams: serviceParams).responseObject { (response : DataResponse&lt;AuthResponse&gt;) in
        
        if (response.error != nil ) {
            
            print(&quot;❌⭕️❌ Auth login hatalı bir dönüş aldı sorun var.&quot;)
            
            subject.send(response.error!)
            
            
            return
            
        } else {
            
            if let data = response.result.value {
                guard let token = data.data?.token else {
                 print(&quot;TOKEN BULUNAMADI&quot;)
                let authResponse = AuthResponse(
                result: &quot;fault&quot;,
                success: false,
                data: nil,
                message: &quot;Kullanıcı adı veya şifre hatalı&quot;,
                errCode: &quot;E0000&quot;
               )
                    subject.send(response)
                    return
                
                
                
            }
                print(&quot;AuthLogin Token -------&gt;   \(token)&quot;)
                ApplicationVariables.token = token
                ApplicationVariables.customer = data.data?.customer
                ApplicationVariables.config = data.data?.store?.config
                ApplicationVariables.logo = data.data?.store?.logo
                subject.send(data)
            }else {
                let error = NSError(domain: &quot;Bir sorun oluştu. Lütfen yöneticinize başvurunuz.&quot;, code: 1001, userInfo: nil)
                subject.send(error)
            }
        }
    }
}
</code></pre>
<p>This is my code base , the problem is I couldn't find the right return , what should I return in this function or how ? I tried subject.eraseToAnyPublisher() but its not match with return type.</p>
","9923824","","12299030","","2020-09-17 13:08:44","2020-09-22 12:55:10","SwiftUI Combine function -> any publisher return type","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"63939436","1","63950917","","2020-09-17 13:44:07","","7","3625","<p>Let’s say you are using the built-in <code>.store(in:)</code> method on AnyCancellable like so:</p>
<pre><code>private var subscriptions = Set&lt;AnyCancellable&gt;()

let newPhotos = photos.selectedPhotos
newPhotos
  .map { [unowned self] newImage in
    return self.images.value + [newImage]
  }
  .assign(to: \.value, on: images)
  .store(in: &amp;subscriptions)
</code></pre>
<p>If you have an app that does this a lot - are these removed when the publishers complete?</p>
<p>Also, If i decide to go with this approach instead:</p>
<pre><code>private var newPhotosSubscription: AnyCancellable?

self.newPhotosSubscription = newPhotos
  .map { [unowned self] newImage in
    self.images.value + [newImage]
  }
  .assign(to: \.value, on: images)
</code></pre>
<p>Everytime I call the method again, it override the AnyCancellable, what happens to the previous one? Does it still complete before being deallocated?</p>
","3457218","","3457218","","2020-09-17 14:01:39","2020-09-18 17:57:16","AnyCancellable.store(in:) with Combine","<swift><combine>","3","1","1","","","CC BY-SA 4.0"
"63951828","1","","","2020-09-18 08:15:41","","0","524","<p>i want to convert this function to write in Combine framework. I tried a couple way but it didnt work . Can anyone have an idea about this ?</p>
<pre><code>func requestAuth(serviceParams: AuthServiceParams) -&gt; Observable&lt;AuthResponse&gt; {
    
    return Observable.create{observer -&gt; Disposable in
        // buradaki işlemler rx 'te yapılacak.
        
        AlamofireService.auth(serviceParams: serviceParams).responseObject {
            (response:DataResponse&lt;AuthResponse&gt;) in
            if(response.error != nil ){
                print(&quot;❌⭕️❌ Auth login hatalı bir dönüş aldı sorun var.&quot;)
                observer.onError(response.error!)
                observer.onCompleted()
                return
            } else {
                if let data = response.result.value {
                    guard let token = data.data?.token else {
                        print(&quot;TOKEN BULUNAMADI&quot;)
                        let authResponse = AuthResponse(
                            result: &quot;fault&quot;,
                            success: false,
                            data: nil,
                            message: &quot;Kullanıcı adı veya şifre hatalı&quot;,
                            errCode: &quot;E0000&quot;
                        )
                        observer.onNext(authResponse)
                        return
                    }
                    print(&quot;AuthLogin Token -------&gt;   \(token)&quot;)
                    ApplicationVariables.token = token
                    ApplicationVariables.customer = data.data?.customer
                    ApplicationVariables.config = data.data?.store?.config
                    ApplicationVariables.logo = data.data?.store?.logo
                    observer.onNext(data)
                }else {
                    let error = NSError(domain: &quot;Bir sorun oluştu. Lütfen yöneticinize başvurunuz.&quot;, code: 1001, userInfo: nil)
                    observer.onError(error)
                }
                observer.onCompleted()
            }
        }
        return Disposables.create()
    }
}
</code></pre>
","9923824","","77567","","2020-09-18 16:07:50","2020-09-18 20:55:36","How can ı convert RxSwift to Combine Framework","<swift><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"63964776","1","64397436","","2020-09-19 02:39:55","","1","2527","<p>For a Store/Factory/ViewModel pattern using Combine and SwiftUI, I'd like a Store protocol-conforming class to expose a publisher for when specified model object(s) change internal properties. Any subscribed ViewModels can then trigger objectWillChange to display the changes.</p>
<p>(This is necessary because changes are ignored inside a model object <strong>that is passed by reference</strong>, so @Published/ObservableObject won't auto-fire for Factory-passed Store-owned models. It works to call objectWillChange in the Store and the VM, but that leaves out any passively listening VMs.)</p>
<p>That's a delegate pattern, right, extending @Published/ObservableObject to passed-by-reference objects? Combing through combine blogs, books, and docs hasn't triggered an idea to what's probably a pretty standard thing.</p>
<h2>Crudely Working Attempt</h2>
<p>I thought PassthroughSubject&lt;Any,Never&gt; would be useful if I exposed a VM's objectWillChange externally, but PassthroughSubject.send() will fire for every object within the model object. Wasteful maybe (although the ViewModel only fires its objectWillChange once).</p>
<p>Attaching a limiter (e.g., throttle, removeDuplicates) on <code>Ext+VM republishChanges(of myStore: Store)</code> didn't seem to limit the .sink calls, nor do I see an obvious way to reset the demand between the PassthroughSubject and the VM's sink... or understand how to attach a Subscriber to a PassthroughSubject that complies with the Protcols. Any suggestions?</p>
<p><strong>Store-Side</strong></p>
<pre class=""lang-swift prettyprint-override""><code>struct Library {
   var books: // some dictionary
}

class LocalLibraryStore: LibraryStore {
    private(set) var library: Library {
         didSet { publish() }
    }

    var changed = PassthroughSubject&lt;Any,Never&gt;()
    func removeBook() {}
}

protocol LibraryStore: Store { 
    var changed: PassthroughSubject&lt;Any,Never&gt; { get }
    var library: Library { get }
}


protocol Store {
    var changed: PassthroughSubject&lt;Any,Never&gt; { get }
}

extension Store {
    func publish() {
        changed.send(1)
        print(&quot;This will fire once.&quot;)
    }
}

</code></pre>
<p><strong>VM-Side</strong></p>
<pre class=""lang-swift prettyprint-override""><code>class BadgeVM: VM {
    init(store: LibraryStore) {
        self.specificStore = store
        republishChanges(of: jokesStore)
    }

    var objectWillChange = ObservableObjectPublisher() // Exposed {set} for external call
    internal var subscriptions = Set&lt;AnyCancellable&gt;()

    @Published private var specificStore: LibraryStore
    var totalBooks: Int { specificStore.library.books.keys.count }
}

protocol VM: ObservableObject {
    var subscriptions: Set&lt;AnyCancellable&gt; { get set }
    var objectWillChange: ObservableObjectPublisher { get set }
}

extension VM {
    internal func republishChanges(of myStore: Store) {
        myStore.changed
            // .throttle() doesn't silence as hoped
            .sink { [unowned self] _ in
                print(&quot;Executed for each object inside the Store's published object.&quot;)
                self.objectWillChange.send()
            }
            .store(in: &amp;subscriptions)
    }
}

class OtherVM: VM {
    init(store: LibraryStore) {
        self.specificStore = store
        republishChanges(of: store)
    }

    var objectWillChange = ObservableObjectPublisher() // Exposed {set} for external call
    internal var subscriptions = Set&lt;AnyCancellable&gt;()

    @Published private var specificStore: LibraryStore
    var isBookVeryExpensive: Bool { ... }
    func bookMysteriouslyDisappears() { 
         specificStore.removeBook() 
    }
}

</code></pre>
","11420986","","11420986","","2020-09-19 05:27:17","2020-10-17 00:18:55","When a Store's object is updated, auto-trigger objectWillChange.send() in ViewModel ObservableObjects","<swift><swiftui><delegates><reactive-programming><combine>","2","2","1","","","CC BY-SA 4.0"
"63973316","1","","","2020-09-19 20:56:39","","6","4329","<p>I use a form for a logging page in my app and I have a bind on the footer to display any error, as you can see below :</p>
<p>ContentView.Swift :</p>
<pre><code>Form { Section(footer: Text(self.viewModel.errorMessage))
</code></pre>
<p>ViewModel.swift</p>
<pre><code>init() {
    self.isCurrentNameValid
         .receive(on: RunLoop.main)
         .map { $0 ? &quot;&quot; : &quot;username must at least have 5 characters&quot; }
         .assign(to: \.errorMessage, on: self)
         .store(in: &amp;cancelSet)
}
</code></pre>
<p>The problem is the assign in the viewModel is perform in the init so when I launch my app it will display the message even though the user didn't try to write anything yet.</p>
<p>Is there a way to skip first event like in RxSwift where you would just .skip(1) in combine framework?</p>
","7061830","","506441","","2020-09-20 11:44:47","2020-09-20 11:44:47","Swift Combine how to skip an Event","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"63974677","1","63975650","","2020-09-20 01:02:08","","3","2382","<p>I'm experiencing this really weird issue/bug with SwiftUI. In the <code>setupSubscription</code> method, I'm creating a subscription to <code>subject</code> and inserting it into the <code>cancellables</code> Set. And yet, when I print the count of <code>cancellables</code>, I get zero. How can the set be empty if I just inserted an element into it?
This is presumably why the <code>handleValue</code> method is not called when I tap on the button. Here's the full output from the console:</p>
<pre><code>init
begin setupSubscription
setupSubscription subject sink: receive subscription: (CurrentValueSubject)
setupSubscription subject sink: request unlimited
setupSubscription subject sink: receive value: (initial value)
handleValue: 'initial value'
setupSubscription: cancellables.count: 0
setupSubscription subject sink: receive cancel
sent value: 'value 38'
cancellables.count: 0
sent value: 'value 73'
cancellables.count: 0
sent value: 'value 30'
cancellables.count: 0
</code></pre>
<p>What am I doing wrong? why Is my subscription to <code>subject</code> getting cancelled? Why is <code>handleValue</code> not getting called when I tap the button?</p>
<pre><code>import SwiftUI
import Combine

struct Test: View {
    
    @State private var cancellables: Set&lt;AnyCancellable&gt; = []
    
    let subject = CurrentValueSubject&lt;String, Never&gt;(&quot;initial value&quot;)
    
    init() {
        print(&quot;init&quot;)
        self.setupSubscription()
    }
    
    var body: some View {
        VStack {
            Button(action: {
                let newValue = &quot;value \(Int.random(in: 0...100))&quot;
                self.subject.send(newValue)
                print(&quot;sent value: '\(newValue)'&quot;)
                print(&quot;cancellables.count:&quot;, cancellables.count)
            }, label: {
                Text(&quot;Tap Me&quot;)
            })
        }
    }
    
    func setupSubscription() {
        print(&quot;begin setupSubscription&quot;)
        
        let cancellable = self.subject
            .print(&quot;setupSubscription subject sink&quot;)
            .sink(receiveValue: handleValue(_:))
        
        self.cancellables.insert(cancellable)
        
        print(&quot;setupSubscription: cancellables.count:&quot;, cancellables.count) 
        // prints &quot;setupSubscription: cancellables.count: 0&quot;
    
    }
    
    
    func handleValue(_ value: String) {
        print(&quot;handleValue: '\(value)'&quot;)
    }
    
    
}
</code></pre>
","12394554","","12394554","","2020-09-20 01:22:33","2021-01-13 05:46:55","SwiftUI - @State property not updating","<swift><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"63993196","1","63997654","","2020-09-21 13:23:25","","1","459","<p>I'm trying to mimic the Combine @Published property wrapper. My end goal is to create a new custom property wrapper (e.g. @PublishedAppStorage) of @Published with a nested @AppStorage.
So I've started just by trying to mimic the @Published.</p>
<p>My problem that it crashes when accessing the original value from within the sink block with the error:
<code>Thread 1: Simultaneous accesses to 0x600000103328, but modification requires exclusive access</code></p>
<p>I've spent days trying to find a way.</p>
<p>Here is my custom @DMPublished:</p>
<pre><code>@propertyWrapper
struct DMPublished&lt;Value&gt; {
    private let subject:CurrentValueSubject&lt;Value, Never&gt;
    
    init(wrappedValue: Value) {
        self.wrappedValue = wrappedValue
        self.subject = CurrentValueSubject(wrappedValue)
    }
    
    var wrappedValue: Value {
        willSet {
            subject.send(newValue)
        }
    }

    var projectedValue: AnyPublisher&lt;Value, Never&gt; {
        subject.eraseToAnyPublisher()
    }
}
</code></pre>
<p>The ObservableObject defining my properties:</p>
<pre><code>import Combine

public class DMDefaults: ObservableObject {
    
    static public let shared = DMDefaults()
    private init(){}
    
    @Published public var corePublishedString = &quot;dd&quot;
    @DMPublished public var customPublishedString = &quot;DD&quot;

}
</code></pre>
<p>And here is my test function:</p>
<pre><code>public func testSink()
{
    let gdmDefaults = DMDefaults.shared
    gdmDefaults.corePublishedString = &quot;ee&quot;; gdmDefaults.customPublishedString = &quot;EE&quot;
    
    gdmDefaults.corePublishedString = &quot;ff&quot;; gdmDefaults.customPublishedString = &quot;FF&quot;

    let coreSub = gdmDefaults.$corePublishedString.sink { (newVal) in
        print(&quot;coreSub: oldVal=\(gdmDefaults.corePublishedString) ; newVal=\(newVal)&quot;)
    }
    let custSub = gdmDefaults.$customPublishedString.sink { (newVal) in
        print(&quot;custSub: oldVal=\(gdmDefaults.customPublishedString) ; newVal=\(newVal)&quot;) // **Crashing here**
    }
    
    gdmDefaults.corePublishedString = &quot;gg&quot;; gdmDefaults.customPublishedString = &quot;GG&quot;

}
</code></pre>
<p>Will appreciate any help here... thanks...</p>
","14314783","","14314783","","2020-09-21 18:01:36","2022-07-19 17:30:46","Mimic Swift Combine @Published to create @PublishedAppStorage","<swift><combine>","1","2","1","","","CC BY-SA 4.0"
"64013558","1","","","2020-09-22 16:05:07","","2","2610","<p>I've seen a dozen or so tutorials on how to use Combine and receive a <code>Notification</code> of a task being completed.  It seems they all show linear code - the publisher and receiver all in the same place, one row after another.</p>
<p>Publishing a notification is as easy as the code below:</p>
<pre><code>// background download task complete - notify the appropriate views
DispatchQueue.main.async {
    NotificationCenter.default.post(name: .dataDownloadComplete, object: self, userInfo: self.dataCounts)
}

extension Notification.Name {
    static let dataDownloadComplete = Notification.Name(&quot;dataDownloadComplete&quot;)
}
</code></pre>
<p>SwiftUI has the <code>onReceive()</code> modifier, but I can't find any way to connect the above to a &quot;listener&quot; of the posted notification.</p>
<p>How does a <code>View</code> receive this <code>Notification</code></p>
","974781","","","","","2020-09-22 16:05:07","How to Receive NotificationCenter Post in SwiftUI","<swiftui><publish-subscribe><combine>","1","2","1","","","CC BY-SA 4.0"
"64037789","1","64039597","","2020-09-24 00:00:30","","1","1286","<p>Below is my code for a countdown timer and circular progress bar.</p>
<p>I coded a function <code>makeProgressIncrement()</code> that determines
the progress per second from the timer total of <code>timeSelected</code>.</p>
<p>What is the best way to to update the <code>ProgressBar</code> so it increases with the countdown timer publisher?</p>
<p>Should I use an <code>onReceive</code> method?</p>
<p>Any help is greatly appreciated.</p>
<p><strong>ContentView</strong></p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {

@StateObject var timer = TimerManager()
@State var progressValue : CGFloat = 0

var body: some View {
    
    ZStack{
        VStack {
            ZStack{
                
                ProgressBar(progress: self.$progressValue)
                    .frame(width: 300.0, height: 300)
                    .padding(40.0)
              
                VStack{
                    
                    Image(systemName: timer.isRunning ? &quot;pause.fill&quot; : &quot;play.fill&quot;)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 80, height: 80)
                        .foregroundColor(.blue)
                        .onTapGesture{
                            timer.isRunning ? timer.pause() : timer.start()
                        }
                }
            }

            Text(timer.timerString)
                .onAppear {
                    if timer.isRunning {
                        timer.stop()
                    }
                }
                .padding(.bottom, 100)
            
            
            Image(systemName: &quot;stop.fill&quot;)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: 35, height: 35)
                .foregroundColor(.blue)
                .onTapGesture{
                    timer.stop()


                }
            }
        }
    }
 }
</code></pre>
<p><strong>ProgressBar</strong></p>
<pre><code>struct ProgressBar: View {
    @Binding var progress: CGFloat
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(lineWidth: 20.0)
                .opacity(0.3)
                .foregroundColor(Color.blue)
            
            Circle()
                .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0)))
                .stroke(style: StrokeStyle(lineWidth: 20.0, lineCap: .round, lineJoin: .round))
                .foregroundColor(Color.blue)
                .rotationEffect(Angle(degrees: 270.0))
                .animation(.linear)
            
        }
    }
}
</code></pre>
<p><strong>TimerManager</strong></p>
<pre><code>class TimerManager: ObservableObject {
    
    /// Is the timer running?
    @Published private(set) var isRunning = false
    
    /// String to show in UI
    @Published private(set) var timerString = &quot;&quot;
    
    /// Timer subscription to receive publisher
    private var timer: AnyCancellable?
    
    /// Time that we're counting from &amp; store it when app is in background
    private var startTime: Date? { didSet { saveStartTime() } }
    
    var timeSelected: Double = 30
    var timeRemaining: Double = 0
    var timePaused: Date = Date()
    var progressIncrement: Double = 0
    
    init() {
        startTime = fetchStartTime()
        
        if startTime != nil {
            start()
        }
    }
}

// MARK: - Public Interface

extension TimerManager {

    func start() {
     
        timer?.cancel()               
        
        if startTime == nil {
            startTime = Date()
        }
        
        timerString = &quot;&quot;
        
        timer = Timer
            .publish(every: 0, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                guard
                    let self = self,
                    let startTime = self.startTime
                else { return }
                
                let now = Date()
                let elapsedTime = now.timeIntervalSince(startTime)
                      
                self.timeRemaining = self.timeSelected - elapsedTime
                                    
                guard self.timeRemaining &gt; 0 else {
                    self.stop()
                    return
                }
                self.timerString = String(format: &quot;%0.1f&quot;, self.timeRemaining)
            }
        isRunning = true
    }
    
    func stop() {
        timer?.cancel()
        timeSelected = 300
        timer = nil
        startTime = nil
        isRunning = false
        timerString = &quot; &quot;
    }
    
    func pause() {
        timeSelected = timeRemaining
        timer?.cancel()
        startTime = nil
        timer = nil
        isRunning = false
    }
    
    func makeProgressIncrement() -&gt; CGFloat{
        
        progressIncrement = 1 / timeSelected
        
        return CGFloat(progressIncrement)
        
    }        
}

private extension TimerManager {

    func saveStartTime() {
        if let startTime = startTime {
            UserDefaults.standard.set(startTime, forKey: &quot;startTime&quot;)
        } else {
            UserDefaults.standard.removeObject(forKey: &quot;startTime&quot;)
        }
    }
    
    func fetchStartTime() -&gt; Date? {
        UserDefaults.standard.object(forKey: &quot;startTime&quot;) as? Date
    }
}
</code></pre>
","12349248","","","","","2020-09-25 00:03:06","Circular progress bar for a countdown timer publisher SwiftUI","<timer><swiftui><progress-bar><combine>","1","2","","","","CC BY-SA 4.0"
"64043767","1","","","2020-09-24 09:43:19","","0","552","<p>I'm trying to subscribe to a Publisher created from a PassthroughSubject twice and only one of them is executed when PassthroughSubject fires a value.</p>
<p>Here is what I tried:</p>
<pre><code>class Worker {
   let stringGeneratorResultSubject: PassthroughSubject&lt;String, Error&gt;
  
   init(stringGeneratorResultSubject: PassthroughSubject&lt;String, Error&gt;) {
        self.stringGeneratorResultSubject = stringGeneratorResultSubject
   }

   func generateString() {
       stringGeneratorResultSubject.send(&quot;someValue&quot;)
   }
}

class A {
    let workerObj: Worker
    let workerObjPublisher: AnyPublisher&lt;String, Swift.Error&gt;
    init(workerObj: Worker, 
         workerObjPublisher: AnyPublisher&lt;String, Swift.Error&gt;) {
       self.workerObj = workerObj
       self.workerObjPublisher = workerObjPublisher
       super.init()
     
       getString()
    }

   func getString() {
      workerObjPublisher.sink { result in 
        // do something with result for
     }.store(in: &amp;cancellable)

     workerObj.generateString()
  }
}

class B {
    let workerObjPublisher: AnyPublisher&lt;String, Swift.Error&gt;
    init(workerObjPublisher: AnyPublisher&lt;String, Swift.Error&gt;) {
       self.workerObjPublisher = workerObjPublisher
       super.init()
     
       loadString()
    }

   func loadString() {
      workerObjPublisher.sink { result in 
        // do something with result
     }.store(in: &amp;cancellable)
   }

 }

class Parent {
   lazy var stringGeneratorResultSubject: PassthroughSubject&lt;String, Swift.Error&gt; = .init()
   lazy var workerObj: Worker = .init(stringGeneratorResultSubject: stringGeneratorResultSubject)
   lazy var aObj: A = .init(workerObj: workerObj, 
                            workerObjPublisher: stringGeneratorResultSubject.eraseToAnyPublisher())

   lazy var bObj: B = .init(workerObjPublisher: stringGeneratorResultSubject.eraseToAnyPublisher())
   
   _ = bObj

   aObj.getString()
}
</code></pre>
<p>Only <code>class A</code>'s subscription block in <code>getString()</code> is called. <code>class B</code>'s subscription block inside <code>loadString()</code> is not executed. Am I missing something?</p>
","1253102","","1253102","","2020-09-24 14:42:54","2020-09-24 14:42:54","Combine - subscribe to a publisher of PassthroughSubject twice","<ios><swift><combine>","0","2","","","","CC BY-SA 4.0"
"64044163","1","","","2020-09-24 10:05:48","","0","173","<p>Trying to change <code>isValid</code> after the user have chose from the <code>Menu</code> the right position.</p>
<p>It seems to work if I first choose a position and then typing the email and name at the textfields but not the other side.</p>
<p>I want to enable the <code>Button</code> when he chose position and fulfilled the other textfields.</p>
<pre><code>class EmployeeModel: ObservableObject{
    
    @Published var employee: Employee
    @Published var isValid = false
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(employee: Employee = Employee(uid: &quot;&quot;, affiliate: 0, employeeID: 1, email: &quot;&quot;, name: &quot;&quot;, shiftsConstIsApplied: false, position: nil, shiftConsts: nil, pushId: &quot;&quot;)){
        
        self.employee = employee
        
        self.$employee
            .debounce(for: 0.5, scheduler: RunLoop.main)
            
            .map({!$0.name.isEmpty &amp;&amp; !$0.email.isEmpty &amp;&amp; $0.position != nil})
            .sink{ input in
                print(input)
                self.isValid = input
            }
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>The view:</p>
<pre><code>
@State private var position: Positions?
@StateObject var employeeModel = EmployeeModel()

Menu(LocalizedStringKey(self.$position.wrappedValue?.rawValue ?? &quot;Choose position&quot;)) {
                        ForEach(Positions.employeeTypes, id:\.self){ p in
                            Button(LocalizedStringKey(p)){
                                let positionSelected = Positions(rawValue: p)
                                self.position = positionSelected
                                self.employeeModel.employee.position = positionSelected
                            }
                        }
                    }

Button(&quot;Confirm&quot;){
//do something
}
.disabled(!self.employeeModel.isValid)
</code></pre>
<p>Model Employee as ObservableObject:</p>
<pre><code>    @Published var uid: String?
    @Published var email: String
    @Published var name: String
    @Published var affiliate: Int?
    @Published var employeeId: Int?
    @Published var shiftsConstIsApplied: Bool? = true
    @Published var position: Positions?
    @Published var shiftConsts: [ShiftConst]?
</code></pre>
","9645137","","","","","2020-09-24 14:01:29","Get changes on button tapped using Combine and SwiftUI","<ios><swift><foreach><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64049516","1","","","2020-09-24 15:19:56","","3","537","<p>Have somebody faced the issue working with such flatMap chain (or even longer) when compiler went to infinite loop.</p>
<pre><code>let what = Future&lt;String, Error&gt;.init { (promise) in
    promise(.success(&quot;123&quot;))
}
.flatMap { (inStr) -&gt; AnyPublisher&lt;Int, Error&gt; in
    Future&lt;Int, Error&gt;.init { (promise) in
        promise(.success(Int(inStr)!))
    }.eraseToAnyPublisher()
} 
.flatMap { (inInt) -&gt; AnyPublisher&lt;String, Error&gt; in
    Just(String(inInt))
        .setFailureType(to: Error.self)
        .eraseToAnyPublisher()
}.eraseToAnyPublisher()
</code></pre>
<p>The type of Publisher Output and Failure are terrible!
<a href=""https://i.stack.imgur.com/jWNQx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jWNQx.png"" alt=""enter image description here"" /></a></p>
<p>I have flatMap chain with 7 steps and you can imagine the actual type.
Maybe somebody knows how to handle this correctly?
Any help appreciated.</p>
","2610638","","4667835","","2020-09-24 15:27:54","2020-09-24 17:47:10","Swift flatMap chain unwrap","<swift><combine>","1","5","","","","CC BY-SA 4.0"
"64054468","1","64056031","","2020-09-24 21:11:21","","1","78","<p>I have a class called SocialMealplan that looks like the following:</p>
<pre><code>public class SocialMealplan : Identifiable, ObservableObject {
    public var id : String {
        return owner.id
    }
    @Published public var owner : YKUser
    @Published public var mealplan : Mealplan
    
    init(owner : YKUser, mealplan : Mealplan) {
        self.owner = owner
        self.mealplan = mealplan
    }
}
</code></pre>
<p>I then have the following code:</p>
<pre><code>
struct MealPlanView: View {

    @ObservedObject var currentMealplan: SocialMealplan = SocialMealplan(owner: YKUser.none, mealplan: Mealplan.none)

    var body: some View {
    /* ... */

        ForEach(self.currentMealplan.mealplan.meals, id: \.self) { (meal) in
            VStack {
                NavigationLink(destination: SelectRecipeView(completion: self.updatedMealplan, date: meal.date)) {
                    MealplanRow(meal: .constant(meal))
                }
            }
        }.onAppear {
            self.refreshMealplan()
        }

    /* ... */
    }

    func refreshMealplan() {
        // Get the mealplan from the server
        self.currentMealplan.mealplan = newMealplan
    }
}
</code></pre>
<p>The problem is that when I run this code it gets the mealplan, but when it tries to assign the variable nothing happens. refreshMealplan is called and the variable is assigned, but nothing changes on the UI and the view doesn't refresh to reflect the new data.</p>
<p>(Neither does anything happen when I reassign the owner variable)</p>
","4464283","","","","","2020-09-25 00:15:51","SwiftUI - ObservableObject doesn't cause update","<swift><xcode><swiftui><state><combine>","1","0","","","","CC BY-SA 4.0"
"64066401","1","","","2020-09-25 14:45:28","","0","199","<h2>Background</h2>
<p>I have several publishers which need to be grouped together, in this example there is <code>varA</code> (Publisher A1), <code>varB</code> (Publisher B1) and <code>varC</code> (An array of Publishers C1..n). The array of publishers in C is dynamic, as in they are constantly changing. However, the list of <code>varC</code>'s publishers is only ever evaluated once at startup and the CombineLatest never truly subscribes to the list of publishers. When I add to the list or take away the <code>combiner</code> publisher doesn't pay attention to it.</p>
<p>Below is a very simplified version of the problem</p>
<pre class=""lang-swift prettyprint-override""><code>class GenericModel: ObservableObject {
    @Published var dynamicList: [Publishable] = []

    lazy let varA = Just(1)
    lazy let varB = Just(2)
    var varC: AnyPublisher&lt;[Int], Never&gt; {
        return Publishers.MergeMany(self.dynamicList.map{ $0.getPublisher })
            .collect()
            .eraseToAnyPublisher()
    }

    lazy var combiner: AnyPublisher&lt;Bool, Never&gt; = {
        Publishers.CombineLatest3(
            varA,
            varB,
            varC
        ).map { v1, v2, v3 in
            return v1 == 0 &amp;&amp; v2 == 0 &amp;&amp; v3.allSatisfy({ $0 == 0 })
        }.eraseToAnyPublisher()
    }()
}
</code></pre>
<p>In this case, I have a subscription to <code>combiner</code>. However whenever it is run, the total number of values in varC is 0. This is also confirmed by breaking on <code>varC</code>s closure, which only gets instantiated once.</p>
<p>I've tried a couple of things to make the subscription to <code>dynamicList</code> dynamic but it never seems to update.</p>
<p>Any help would be much appreciated</p>
","2202642","","","","","2020-09-25 14:45:28","Combine publishers from a dynamic list not updating","<swift><combine>","0","3","1","","","CC BY-SA 4.0"
"64076658","1","","","2020-09-26 10:40:54","","0","72","<p>I am trying to integrate the ORSSerialPort framework with Combine into SwiftUi. <a href=""https://github.com/armadsen/ORSSerialPort"" rel=""nofollow noreferrer"">ORSSerialPort GitHub</a></p>
<p>ORSSerialPort implements  Key-Value Observing(KVO) and a Delegate Pattern. In his example, he works with the Delegate Pattern and UIKit. I will use Combine and SwiftUI.  Not the Delegate Pattern.</p>
<p>Because the ORSSerialPort is a KVO Object, it should be possible ORSSerialPort variables to subscribe, but her is my Problem. It will not work.  I don't know why.</p>
<p>what i try:</p>
<pre><code>@Published var isOpen: String = &quot;&quot;
var orsSerialPort: ORSSerialPort = ORSSerialPort(path: &quot;/dev/cu.usbmodem146101&quot;)!
var publisher: NSObject.KeyValueObservingPublisher&lt;ORSSerialPort, Bool&gt;
var isOpenSub: AnyCancellable?

init(){
    publisher = orsSerialPort.publisher(for: \.isOpen)
    isOpenSub = publisher
        .map{ (x) -&gt; String in return &quot;Is \(x ? &quot;Opend&quot;:&quot;Close&quot; )&quot; }
        .assign(to: \.isOpen, on: self)
}
</code></pre>
<p>The publisher is trigger always one time, and that is by the init. If I close and open the port with my function, it will not trigger again.</p>
<pre><code>  func cloes(){
    orsSerialPort.close()
}

func open(){
    orsSerialPort.open()
}
</code></pre>
<p>For Debugging I try this to the the Stream. And I will see again that the Publisher will always trigger only one time. But the Port is closing and opining.</p>
<pre><code>    .sink(receiveCompletion: { completion in
    print(&quot;subScribeIsOpen complet&quot;)
    switch completion {
        case .finished:
            print(&quot;subScribeIsOpen complet&quot;)
        case .failure(let error):
            print(&quot;subScribeIsOpen fail&quot;)
            print(error.localizedDescription)
        }
    }, receiveValue: { value in
         print(&quot;subScribeIsOpen receive \(value)&quot;)
         self.isOpen = value
    })
</code></pre>
<p>My Demo Code</p>
<pre><code>import Foundation
import ORSSerial
import Combine
import SwiftUI
class ORSSerialPortCombine: ObservableObject {
    @Published var status: String = &quot;&quot;
    @Published var isOpen: String = &quot;&quot;
    var orsSerialPort: ORSSerialPort = ORSSerialPort(path: &quot;/dev/cu.usbmodem146101&quot;)!
    var publisher: NSObject.KeyValueObservingPublisher&lt;ORSSerialPort, Bool&gt;
    var isOpenSub: AnyCancellable?
    init(){
        publisher = orsSerialPort.publisher(for: \.isOpen)
        isOpenSub = publisher
            .map{ (x) -&gt; String in return &quot;Is \(x ? &quot;Opend&quot;:&quot;Close&quot; )&quot; }
//            .assign(to: \.isOpen, on: self)
            .sink(receiveCompletion: { completion in
                print(&quot;subScribeIsOpen complet&quot;)
                switch completion {
                    case .finished:
                        print(&quot;subScribeIsOpen complet&quot;)
                    case .failure(let error):
                        print(&quot;subScribeIsOpen fail&quot;)
                        print(error.localizedDescription)
                }
            }, receiveValue: { value in
                print(&quot;subScribeIsOpen receive \(value)&quot;)
                self.isOpen = value
            })
    }
    func cloes(){
        orsSerialPort.close()
    }
    func open(){
        orsSerialPort.open()
    }
    func updateStatus(){
        status = &quot;Serial port is \(orsSerialPort.isOpen ? &quot;Opend&quot;:&quot;Close&quot; )&quot;
    }
}
struct ORSSerialPortCombineView: View{
    @ObservedObject var model = ORSSerialPortCombine()
    var body: some View{
        VStack{
            Text( model.isOpen )
            HStack{
                Button(&quot;Close&quot;) { model.cloes() }
                Button(&quot;Open&quot;) { model.open() }
                Button(&quot;Staus&quot;) { model.updateStatus() }
            }
            Text( model.status )

        }
    }
}
</code></pre>
","12258077","","","","","2020-09-26 10:40:54","Use the ORSSerialPort Library with Combine and SwiftUi. Problem by trying to subscribe a Key-Value Observing(KVO) object","<swiftui><key-value-observing><combine><orsserialport>","0","2","","","","CC BY-SA 4.0"
"64093825","1","64094607","","2020-09-27 22:18:17","","0","389","<p>I am trying to implement Networking with Combine Framework and I am able to fetch data from server using following code but I am facing an issue when there is no data returned from the server but the request was successful.</p>
<pre><code>   return URLSession.shared.dataTaskPublisher(for: request)
      .tryMap { response in
         print(response)
        guard let httpURLResponse = response.response as? HTTPURLResponse, 200..&lt;299 ~= httpURLResponse.statusCode  else {
           throw CustomError.serverError
         }
         if response.data.isEmpty &amp;&amp; 200..&lt;299 ~= httpURLResponse.statusCode {
            //HOW TO HANDLE IF if there is no Data from server but request has been processed successfully
         }
         return response.data
        }
        .decode(type: R.self, decoder: decoder)
        .mapError{CustomError.map(error: $0)}
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>Can you please guide me on how to handle success response when there is no Data returned by the server.</p>
<p>Let me know if I have to elaborate on my question.</p>
","3173478","","","","","2020-09-28 00:48:10","Handle success response when there is no Data returned by the server with Combine","<ios><swift><combine>","1","6","","","","CC BY-SA 4.0"
"64103509","1","","","2020-09-28 13:48:20","","2","448","<p>In Combine there are (among others) these two publishers:</p>
<pre class=""lang-swift prettyprint-override""><code>let just = Just(&quot;Just&quot;)
let future = Future&lt;String, Never&gt;({ (promise) in
    DispatchQueue.main.async {
        promise(.success(&quot;Future&quot;))
    }
})
</code></pre>
<p>These two have a different output when put into a <code>combineLatest</code> publisher like in the following</p>
<pre class=""lang-swift prettyprint-override""><code>just.combineLatest([1,2,3].publisher).sink { (value) in
    print(value)
}.store(in: &amp;bin)
/* prints
(&quot;Just&quot;, 1)
(&quot;Just&quot;, 2)
(&quot;Just&quot;, 3)
*/

future.combineLatest([1,2,3].publisher).sink { (value) in
    print(value)
}.store(in: &amp;bin)
/* prints:
(&quot;Future&quot;, 3)
*/
</code></pre>
<p>Is there any way to modify (e.g. an operator) the <code>Future</code> publisher in a way so that it will behave like the <code>Just</code> publisher?</p>
","1857527","","","","","2020-09-28 13:55:27","combineLatest has different behaviour in Just vs Future","<swift><combine>","1","1","1","","","CC BY-SA 4.0"
"64114061","1","","","2020-09-29 06:29:29","","0","139","<p>Note to reader: This was a dumb mistake on my part... I was using <code>@Binding</code> in my subview when I should have used <code>@ObservedObject</code>. This lead me to think I needed to cast to <code>Binding&lt;ConcreteModel&gt;</code>..</p>
<p>I have a published var of type <code>Any?</code>, I would like to cast it and pass it to a <code>View</code> expecting <code>Binding&lt;ConcreteModel&gt;</code>... Is this supported?</p>
<p>Problem with my casting?</p>
<pre><code>// This cast doesn't seem to be working...
if let concreteModel = viewModel.item as? Binding&lt;ConcreteModel&gt; {}
</code></pre>
<p>I'm not having success with this:</p>
<pre><code>class ConcreteModel {
    public var count = 0
}

class MyViewModel: ObservableObject {
    @Published var item: Any?

    init() { item = ConcreteModel() }
}

// SwiftUI
struct MyView: View {
    @ObservedObject var viewModel = MyViewModel()

    var body: some View {
        // This cast doesn't seem to be working...
        if let concreteModel = viewModel.item as? Binding&lt;ConcreteModel&gt; {
            MySecondView(concreteModel: concreteModel)
        }   
    }
}

struct MySecondView: View {
    @Binding var concreteModel: ConcreteModel

    var body: some View {
        Text(&quot;\(concreteModel.count)&quot;)
    }
}
</code></pre>
","4102299","","4102299","","2020-09-29 23:22:30","2020-09-29 23:22:30","@Published var item: any? cast to concrete type and preserve binding","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"64115523","1","","","2020-09-29 08:14:10","","0","596","<p>I am using a <code>Publisher&lt;Int,Never&gt;</code> in combine, and I am trying to return a <code>Published&lt;Int&gt;.Publisher</code></p>
<p>It is possible in combine to transform an <code>AnyPublisher&lt;Int,Never&gt;</code> into a <code>Published&lt;Int&gt;.Publisher</code> ?</p>
","2611161","","","","","2020-09-29 12:39:40","Cast AnyPublisher to Publisher in Combine","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"64129799","1","","","2020-09-30 01:44:37","","1","1826","<p>I am new to combine.... I have a function that has a subscriber, and that function will return a value from the publisher, but the function will return an empty value before waiting for sink to complete.... is there a way I can wait for the sink and assign the value to the function return variable, then return the String back to the caller of this function.</p>
<pre><code> func getState() -&gt; String{
    
    var state = &quot;&quot;
    let statesub = API.getCheckedState(employeeId: &quot;342344&quot;, user: user!)
    statesub
        .mapError({ (error) -&gt; APIError in // 5
            NSLog(error.errorDescription!)
            return error
        })
        .sink(receiveCompletion: { _ in},
              receiveValue:{
                NSLog(&quot;State : \($0.state)&quot;)
                state = $0.state
              })
        .store(in: &amp;tokens)
    return state
</code></pre>
","12340665","","","","","2020-10-25 12:20:09","Swift Combine with Sync","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"64136585","1","","","2020-09-30 11:24:54","","0","1318","<p>Say I have a three layered architecture (Data, Domain and View) and I want to access and provide some data. The three layers are part of different targets and are initialised using dependency injection.</p>
<p>In the domain layer I have the following types:</p>
<pre class=""lang-swift prettyprint-override""><code>protocol BookListRepository: AnyObject {
    func getAll() -&gt; Future&lt;[Book], Error&gt;
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>final class BookService {
    private let repository: BookListRepository

    init(repository: BookListRepository) {
        self.repository = repository
    }

    func getAll() -&gt; Future&lt;[Book], Error&gt; {
        repository.getAll()
    }
}
</code></pre>
<p>In data I define the following:</p>
<pre class=""lang-swift prettyprint-override""><code>class BookApi: BookListRepository {
    func getAll() -&gt; Future&lt;[Book], Error&gt; {
        .init { promise in
            let cancellable = urlSession
                .dataTaskPublisher(for: url)
                .tryMap() { element -&gt; Data in
                    guard 
                        let httpResponse = element.response as? HTTPURLResponse,
                        httpResponse.statusCode == 200 
                    else { throw URLError(.badServerResponse) }
                    return element.data
                }
                .decode(type: [Book]].self, decoder: JSONDecoder())
                .sink(receiveCompletion: { completion in
                    guard case let .failure(error) = completion
                    promise(.failure(error))
                 },
                receiveValue: { books in 
                    promise(.success(books))
                }
    }
}
</code></pre>
<p>In my view layer I would access this in a similar way to this:</p>
<pre class=""lang-swift prettyprint-override""><code>let service: BookService = .init(repository: BookApi())
service
    .getAll()
    .receive(on: DispatchQueue.main)
    .sink(receiveCompletion: { print($0) }) { books in
        // Displau
    }
    .store(in: &amp;cancelables)
</code></pre>
<p>My question here is the following: Is this in any way a good practice and if not what is the correct/preferred way to achieve what I want.</p>
","5564263","","","","","2020-09-30 14:29:27","Swift Combine correct use of Future","<swift><future><combine>","1","3","","","","CC BY-SA 4.0"
"64145985","1","","","2020-09-30 21:28:19","","0","186","<p>Suppose we've three <code>Futures</code> each wrapping an asynchronous call &amp; each depends on the previous <code>Promise</code> to be fulfilled. Ideally, I'd like to have all these get executed only when the subscriber is attached. How do we get this going using Combine?</p>
<pre><code>    private func future1() -&gt; Future&lt;Bool, Error&gt; {
        return Future { [weak self] promise in
            self?.task1 { result in
                promise(result)
            }
        }
    }

    private func future2() -&gt; Future&lt;Bool, Error&gt; {
        return Future { [weak self] promise in
            self?.task2 { result in
                promise(result)
            }
        }
    }

    private func future3() -&gt; Future&lt;Bool, Error&gt; {
        return Future { [weak self] promise in
            self?.task3 { result in
                promise(result)
            }
        }
    }


    future1()..
    future2()..
    future3()..
    .sink {..}

</code></pre>
","295015","","","","","2020-09-30 22:57:45","Swift: Grouping Futures while making them wait util the previous Promise is fulfilled using Combine","<ios><swift><macos><combine>","1","2","","","","CC BY-SA 4.0"
"64151269","1","64152012","","2020-10-01 08:01:45","","0","891","<p>I'm very new to Swift and I am currently trying to learn by building a rent splitting app with SwiftUI + Combine. I want to follow the MVVM pattern and am trying to implement this. At the moment I have the following Model, ViewModel and View files:</p>
<p>Model:</p>
<pre><code>import Foundation
import Combine

struct InputAmounts {
    var myMonthlyIncome : Double
    var housemateMonthlyIncome : Double
    var totalRent : Double
}
</code></pre>
<p>ViewModel (where I have attempted to use the data from the Model to conform to the MVVM pattern, but I am not sure I have done this in the cleanest way/correct way so please correct me if wrong)</p>
<pre><code>import Foundation
import Combine

class FairRentViewModel : ObservableObject {
    
    private var inputAmounts: InputAmounts

    init(inputAmounts: InputAmounts) {
        self.inputAmounts = inputAmounts
    }
   
    var yourShare: Double {
        inputAmounts.totalRent = Double(inputAmounts.totalRent)
        inputAmounts.myMonthlyIncome = Double(inputAmounts.myMonthlyIncome)
        inputAmounts.housemateMonthlyIncome = Double(inputAmounts.housemateMonthlyIncome)
        let totalIncome = Double(inputAmounts.myMonthlyIncome + inputAmounts.housemateMonthlyIncome)
        let percentage = Double(inputAmounts.myMonthlyIncome / totalIncome)
        let value = Double(inputAmounts.totalRent * percentage)

        return Double(round(100*value)/100)
    }
}
</code></pre>
<p>And then am trying to pass this all to the View:</p>
<pre><code>import SwiftUI
import Combine

struct FairRentView: View {
    
    @ObservedObject private var viewModel: FairRentViewModel
    
    init(viewModel: FairRentViewModel){
        self.viewModel = viewModel
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Enter the total monthly rent:&quot;)) {
                    TextField(&quot;Total rent&quot;, text: $viewModel.totalRent)
                        .keyboardType(.decimalPad)
                }
                
                Section(header: Text(&quot;Enter your monthly income:&quot;)) {
                    TextField(&quot;Your monthly wage&quot;, text: $viewModel.myMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                
                Section(header: Text(&quot;Enter your housemate's monthly income:&quot;)) {
                    TextField(&quot;Housemate's monthly income&quot;, text: $viewModel.housemateMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                Section {
                    Text(&quot;Your share: £\(viewModel.yourShare, specifier: &quot;%.2f&quot;)&quot;)
                }
            }
            .navigationBarTitle(&quot;FairRent&quot;)
        }
    }
}

struct FairRentView_Previews: PreviewProvider {
    static var previews: some View {
        let viewModel = FairRentViewModel(inputAmounts: &lt;#InputAmounts#&gt;)
        FairRentView(viewModel: viewModel)
    }
}

</code></pre>
<p>I am getting the build errors with the View:
&quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'totalRent' using key path from root type 'FairRentViewModel'&quot;</p>
<p>&quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'myMonthlyIncome' using key path from root type 'FairRentViewModel'&quot;</p>
<p>&quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'housemateMonthlyIncome' using key path from root type 'FairRentViewModel'&quot;</p>
<p>My questions are:</p>
<ul>
<li>What does this error mean and please point me in the right direction to solve?</li>
<li>Have I gone completely the wrong way at trying to implement the MVVM pattern here?</li>
</ul>
<p>As I said I am a Swift beginner just trying to learn so any advice would be appreciated.</p>
<p><strong>UPDATE IN RESPONSE TO ANSWER</strong></p>
<pre><code>  var yourShare: String {
        inputAmounts.totalRent = (inputAmounts.totalRent)
        inputAmounts.myMonthlyIncome = (inputAmounts.myMonthlyIncome)
        inputAmounts.housemateMonthlyIncome = (inputAmounts.housemateMonthlyIncome)
        var totalIncome = Double(inputAmounts.myMonthlyIncome) 0.00 + Double(inputAmounts.housemateMonthlyIncome) ?? 0.00
        var percentage = Double(myMonthlyIncome) ?? 0.0 / Double(totalIncome) ?? 0.0
        var value = (totalRent * percentage)
        
        return FairRentViewModel.formatter.string(for: value) ?? &quot;&quot;
    }
</code></pre>
<p>I am getting errors here that &quot;Value of optional type 'Double?' must be unwrapped to a value of type 'Double'&quot; which I thought I was achieving with the ?? operands?</p>
","12145038","","12145038","","2020-10-01 09:38:49","2020-10-01 09:57:13","SwiftUI + Combine, using Models and ViewModels together","<swift><mvvm><swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"64155578","1","64157877","","2020-10-01 12:37:48","","0","617","<p>I am learning SwiftUI and Combine to make a simple rent-splitting app. I am trying to follow the MVVM pattern and therefore have a Model, ViewModel and View as follows:</p>
<p>Model:</p>
<pre><code>import Foundation
import Combine

struct Amounts {
    var myMonthlyIncome : String = &quot;&quot;
    var housemateMonthlyIncome : String = &quot;&quot;
    var totalRent : String = &quot;&quot;
}

</code></pre>
<p>ViewModel:</p>
<pre><code>import Foundation
import Combine

class FairRentViewModel : ObservableObject {
    
    var amount: Amounts
    
    init(_ amount: Amounts){
        self.amount = amount
    }
    
    var myMonthlyIncome : String { return amount.myMonthlyIncome }
    var housemateMonthlyIncome : String { return amount.housemateMonthlyIncome }
    var totalRent : String { return amount.totalRent }
    
    var yourShare: Double {
        guard let totalRent = Double(totalRent) else { return 0 }
        guard let myMonthlyIncome = Double(myMonthlyIncome) else { return 0 }
        guard let housemateMonthlyIncome = Double(housemateMonthlyIncome) else { return 0 }
        let totalIncome = Double(myMonthlyIncome + housemateMonthlyIncome)
        let percentage = myMonthlyIncome / totalIncome
        let value = Double(totalRent * percentage)

        return Double(round(100*value)/100)
    }
}

</code></pre>
<p>View:</p>
<pre><code>
import SwiftUI
import Combine

struct FairRentView: View {
    
    @ObservedObject private var viewModel: FairRentViewModel
    
    init(viewModel: FairRentViewModel){
        self.viewModel = viewModel
    }
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text(&quot;Enter the total monthly rent:&quot;)) {
                    TextField(&quot;Total rent&quot;, text: $viewModel.amount.totalRent)
                        .keyboardType(.decimalPad)
                }
                
                Section(header: Text(&quot;Enter your monthly income:&quot;)) {
                    TextField(&quot;Your monthly wage&quot;, text: $viewModel.amount.myMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                
                Section(header: Text(&quot;Enter your housemate's monhtly income:&quot;)) {
                    TextField(&quot;Housemate's monthly income&quot;, text: $viewModel.amount.housemateMonthlyIncome)
                        .keyboardType(.decimalPad)
                }
                Section {
                    Text(&quot;Your share: £\(viewModel.yourShare, specifier: &quot;%.2f&quot;)&quot;)
                }
            }
            .navigationBarTitle(&quot;FairRent&quot;)
        }
    }
}

struct FairRentView_Previews: PreviewProvider {
    static var previews: some View {
        FairRentView(viewModel: FairRentViewModel(Amounts()))
    }
}

</code></pre>
<p>The entry point:</p>
<pre><code>@main
struct FairRentCalculatorApp: App {
    var body: some Scene {
        WindowGroup {
            FairRentView(viewModel: FairRentViewModel(Amounts(myMonthlyIncome: &quot;&quot;, housemateMonthlyIncome: &quot;&quot;, totalRent: &quot;&quot;)))
        }
    }
}

</code></pre>
<p>I want the <code>yourShare</code> value to update as the other properties are entered by the user in the form. This is what I have been trying to achieve with the above code. Can anyone please help point me in the right direction? I'm very new to SwiftUI + Combine and am trying my best to code cleanly so any other pointers are also welcome.</p>
<p>Thanks</p>
","12145038","","","","","2020-10-01 14:51:03","Using Combine + SwiftUI to update values when form values are updated","<swift><mvvm><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64211507","1","","","2020-10-05 15:20:09","","0","47","<p>I have the following code:</p>
<pre><code>func myFunction() -&gt; AnyPublisher&lt;MyObject, MyError&gt; {
   return self.globalPublisher
      // FlatMap 1
      .flatMap { value1 -&gt; AnyPublisher&lt;Object1, Error1 &gt; in 
         return self.function1(value1)
      }
      // FlatMap 2
      .flatMap { value2 -&gt; AnyPublisher&lt;Object2, Error2 &gt; in 
         return self.function1(value2)
      }
      // FlatMap3
      .flatMap { value3 -&gt; AnyPublisher&lt;Object3, Error3 &gt; in 
         return self.function1(value3)
      }
      .eraseToAnyPublisher()
   })
}
</code></pre>
<p><code>myFunction</code> has only one subscriber (checked with debug). <code>globalPublisher</code> can be triggered multiple times and at any time. This triggers the whole <code>flatMap</code> logic.</p>
<p>When the <code>globalPublisher</code> is triggered for the first time, everything is fine: every function in every <code>flatMap</code> block is called once. But the second time happens something strange. The <code>globalPublisher</code> is triggered only once. The function in <code>FlatMap 1</code> is also triggered only once and returns only one value (checked with debug). But the function in <code>FlatMap 2</code> is suddenly triggered twice and returns two values. The function in <code>FlatMap 3</code> is then triggered 6 times.</p>
<p>The same thing happens for the third and further times: <code>globalPublisher</code> and the function in the <code>FlatMap 1</code> are triggered once and the <code>function1()</code> returns only one value. The rest is triggered several times and the number of triggers is getting bigger and bigger.</p>
<p>Could someone tell me what could be the reason for such strange behavior of FlatMaps? I have already gone through my code several times and debugged it. Actually, everything must work. I suppose it's possible that the global publisher is storing somehow the &quot;subscriptions&quot; of the FlatMaps? But I don't think it works that way. Do you have some ideas?</p>
<p>I suspect that the problem lies in the combination of a global publisher and all the FlatMaps.</p>
<p>Thanks in advance.</p>
","11837681","","11837681","","2020-10-05 15:36:10","2020-10-05 20:54:33","Why are the functions called several times within the FlatMaps?","<combine>","1","3","","","","CC BY-SA 4.0"
"64216690","1","","","2020-10-05 21:51:20","","0","169","<p>I noticed this was triggering the deinit block even without weak/unowned used. I simplified the code to show what is happening.</p>
<pre><code>final class ViewModel: ObservableObject {
    @Published var isLoading = false
    private var cancellables: [AnyCancellable] = []

    var randomPublisher: AnyPublisher&lt;Void, Never&gt; {
        Just(()).eraseToAnyPublisher()
    }

    func someAction() {
        randomPublisher.sink { completion in
            self.isLoading = false                
            switch completion {
                case .finished:
                break
            }
        } receiveValue: { _ in  }
        .store(in: &amp;cancellables)
    }
}

struct SampleView: View {
    @StateObject private var viewModel = ViewModel()
}
</code></pre>
<p>I would think there is a reference cycle when <code>someAction()</code> is called as self is captured inside the subscription and the viewmodel holds the subscription array. It's successfully accessing the deinit block when view is dismissed so why is that the case whereas in other viewmodels I need to make self weak in the same place?</p>
","2105498","","","","","2020-10-05 21:51:20","Why does this Combine subscription not cause a retain cycle?","<swiftui><automatic-ref-counting><combine>","0","3","","","","CC BY-SA 4.0"
"64230593","1","64230704","","2020-10-06 17:04:54","","0","176","<p>What is the correct syntax of calling the following fetchURL function?</p>
<pre><code>func fetchURL&lt;T: Decodable&gt;(_ url: URL) -&gt; AnyPublisher&lt;T, Error&gt; {
     URLSession.shared.dataTaskPublisher(for: url)
    .map(\.data)
    .decode(type: T.self, decoder: JSONDecoder())
    .eraseToAnyPublisher()
}
</code></pre>
<p>
I'm confused here. <br/>
<pre><code>let url = URL(string:&quot;http://apple.com&quot;)
let publisher = fetchURL&lt;[String].self&gt;(url)????
</code></pre>
","715747","","968155","","2020-10-06 17:13:05","2020-10-06 20:01:31","What is the correct syntax for calling a generic function that generates a publisher?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"64235494","1","","","2020-10-07 00:22:11","","0","79","<p>I have a type that vends a <code>Timer.TimerPublisher</code>, which you can see below:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation

struct TimerClient {

    // MARK: Properties

    var timerValueChange: () -&gt; AnyPublisher&lt;Date, Never&gt;

    // MARK: Initialization

    init(
        timerValueChange: @escaping () -&gt; AnyPublisher&lt;Date, Never&gt;
    ) {
        self.timerValueChange = timerValueChange
    }
}

extension TimerClient {

    // MARK: Properties

    static var live: Self {
        Self {
            return Timer
                .TimerPublisher(
                    interval: 1,
                    runLoop: .main,
                    mode: .common
                )
                .autoconnect()
                .share()
                .eraseToAnyPublisher()
        }
    }

}
</code></pre>
<p>I have a <code>View</code> that is used to save new events. It is injected with a view model that uses <code>TimerClient</code> so that I can disable the <code>Save</code> button if users attempt to save an event with a past date:</p>
<pre><code>import Combine

final class CountdownEventEntryViewModel: ObservableObject {

    // MARK: Properties

    private let nowSubject = CurrentValueSubject&lt;Date, Never&gt;(Date())

    private let calendar: Calendar
    private let timerClient: TimerClient

    private var cancellables = Set&lt;AnyCancellable&gt;()

    @Published var eventTitle = &quot;&quot;
    @Published var isAllDay = false
    @Published var eventDate = Date()
    @Published var eventTime = Date()
    @Published var shouldDisableSaveButton = true

    // MARK: Initialization
    
    init(
        calendar: Calendar = .autoupdatingCurrent,
        timerClient: TimerClient
    ) {
        self.calendar = calendar
        self.timerClient = timerClient
        observeTimer()
        observeCurrentDateChanges()
    }

    // MARK: UI Configuration

    private func disableSaveButton() -&gt; Bool {
        if eventTitle.trimmingCharacters(in: .whitespaces).isEmpty {
            return true
        }
        if isAllDay {
            let startOfToday = calendar.startOfDay(for: nowSubject.value)
            let startOfSelectedDate = calendar.startOfDay(for: eventDate)
            return startOfSelectedDate &lt;= startOfToday
        } else {
            return normalizedSelectedDate() &lt;= nowSubject.value
        }
    }

    private func observeTimer() {
        timerClient.timerValueChange().sink(receiveValue: { [weak self] newDate in
            self?.nowSubject.send(newDate)
        })
        .store(in: &amp;cancellables)
    }

    private func observeCurrentDateChanges() {
        nowSubject.sink(receiveValue: { [weak self] _ in
            self?.shouldDisableSaveButton = self?.disableSaveButton() ?? false
        })
        .store(in: &amp;cancellables)
    }

}
</code></pre>
<p>The view model works well, and it updates the <code>Save</code> button if an attempt is made to select a past date:</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct CountdownEventEntryView: View {

    // MARK: Properties
    
    @ObservedObject var viewModel: CountdownEventEntryViewModel

    var body: some View {
        Form {
            Section {
                TextField(
                    viewModel.eventTitlePlaceholderKey,
                    text: $viewModel.eventTitle
                )
        }
            Section {
                Toggle(
                    isOn: $viewModel.isAllDay.animation(),
                    label: {
                        Text(viewModel.isAllDayLabelTextKey)
                    }
                )
                DatePicker(
                    viewModel.eventDatePickerLabelTextKey,
                    selection: $viewModel.eventDate,
                    displayedComponents: [.date]
                )
                if !viewModel.isAllDay {
                    DatePicker(
                        viewModel.eventTimePickerLabelTextKey,
                        selection: $viewModel.eventTime,
                        displayedComponents: [.hourAndMinute]
                    )
                }
            }
        }
        .toolbar {
            ToolbarItem(placement: .confirmationAction) {
                Button {
                    presentationMode.wrappedValue.dismiss()
                } label: {
                    Text(viewModel.saveButtonTitleKey)
                }
                .disabled(viewModel.shouldDisableSaveButton)
            }
        }
    }

}
</code></pre>
<p>After the entry view is dismissed, the <code>List</code> that displays saved events is updated according to the following view model:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import CoreData

final class CountdownEventsViewModel: NSObject, ObservableObject, NSFetchedResultsControllerDelegate {

    // MARK: Properties

    private let calendar: Calendar
    private let timerClient: TimerClient

    private var cancellables = Set&lt;AnyCancellable&gt;()

    @Published var now = Date()
    @Published var countdownEvents = [CountdownEvent]()

    // MARK: Initialization

    init(
        calendar: Calendar = .autoupdatingCurrent,
        timerClient: TimerClient
) {
        self.calendar = calendar
        self.timerClient = timerClient
        super.init()
        observeTimer()
        fetchCountdownEvents()
    }

// MARK: Timer Observation

private func observeTimer() {
    timerClient.timerValueChange().sink(receiveValue: { [weak self] newDate in
        self?.now = newDate
    })
    .store(in: &amp;cancellables)
}

// MARK: Event Display

func formattedTitle(for event: CountdownEvent) -&gt; String {
    event.title ?? untitledLabelKey
}

func formattedDate(for event: CountdownEvent) -&gt; String {
    guard let date = event.date else {
        return dateUnknownLabelKey
    }
    if event.isAllDay {
        return DateFormatter.dateOnlyFormatter.string(from: date)
    }
    return DateFormatter.dateAndTimeFormatter.string(from: date)
}

func formattedTimeRemaining(from date: Date, to event: CountdownEvent) -&gt; String {
    guard let eventDate = event.date else {
        return dateUnknownLabelKey
    }
    let allowedComponents: Set&lt;Calendar.Component&gt; = [.year, .month, .day, .hour, .minute, .second]
    let dateComponents = calendar.dateComponents(allowedComponents, from: date, to: eventDate)
    guard let formatted = DateComponentsFormatter.eventTimeRemainingFormatter.string(from: dateComponents) else {
        return dateUnknownLabelKey
    }
    return formatted
}
</code></pre>
<p>}</p>
<p>The view model is used in a <code>View</code> that displays all saved items in a list:</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct CountdownEventsView: View {

    // MARK: Properties

    @ObservedObject private var viewModel: CountdownEventsViewModel

    @State private var showEventEntry = false
    @State private var now = Date()

    var body: some View {
        List {
            Section {
                ForEach(viewModel.countdownEvents) { event in
                    VStack(alignment: .leading) {
                        Text(viewModel.formattedTitle(for: event))
                        Text(viewModel.formattedDate(for: event))
                        Text(viewModel.formattedTimeRemaining(from: now, to: event))
                    }
                }
            }
        }
        .toolbar {
            ToolbarItem(placement: .navigation) {
                HStack(spacing: 30) {
                    Button(action: showSettings) {
                        Label(viewModel.settingsButtonTitleKey, systemImage: viewModel.settingsButtonImageName)
                    }
                    Button(action: {
                        showEventEntry = true
                    }, label: {
                        Label(
                            title: { Text(viewModel.addEventButtonTitleKey) },
                            icon: { Image(systemName: viewModel.addEventButtonImageName) }
                        )
                    })
            }
        }
        .sheet(
            isPresented: $showEventEntry,
            content: {
                NavigationView {
                    CountdownEventEntryView(
                        viewModel:
                            CountdownEventEntryViewModel(
                                timerClient: .live
                            )
                    )
                }
            }
        )
        .onReceive(viewModel.$now, perform: { now in
            self.now = now
        })
     
    }

    // MARK: Initialization

    init(viewModel: CountdownEventsViewModel) {
        self.viewModel = viewModel
    }
</code></pre>
<p>}</p>
<p>This works as expected, and the <code>Text</code> elements are updated with the expected values. Additionally, I am able to scroll the <code>List</code> and see the <code>Text</code> values update thanks to adding the <code>Timer</code> to the <code>main</code> runloop and <code>common </code>mode. However, when I navigate to the event-entry view, the view model seems to get reset when the timer fires.</p>
<p>Below, you can see that the entered text is reset with every fire of the timer:</p>
<img src=""https://i.stack.imgur.com/m7Y9u.gif"" width=""320""/>
<p>It seems that my view model is somehow being recreated, but both view models are <code>@ObservableObject</code>s, so I am not sure why I'm seeing the values reset after the timer fires. The <code>DatePicker</code>, <code>Toggle</code>, <code>TextField</code>, and <code>Button</code> values are all reset to their defaults when the timer fires.</p>
<p>What am I missing that is causing the text to clear when the timer fires?</p>
<p>If it helps, the project is located <a href=""https://github.com/nickkohrn/CountdownEvents"" rel=""nofollow noreferrer"">here</a>. Be sure to use the <code>save-countdown-events</code> branch. Additionally, I am modeling my client types after Point-Free's <a href=""https://www.pointfree.co/episodes/ep111-designing-dependencies-modularization#t911"" rel=""nofollow noreferrer"">teachings about dependency injection</a> (<a href=""https://github.com/pointfreeco/episode-code-samples/tree/main/0111-designing-dependencies-pt2"" rel=""nofollow noreferrer"">code</a>), if that helps provide more context.</p>
","3720634","","968155","","2020-10-07 00:34:04","2020-10-07 00:34:04","Why is @ObservableObject View Model Reset When Timer.TimerPublisher Fires?","<swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"64248641","1","","","2020-10-07 16:47:14","","1","84","<p>I'm working on <strong>MacOS</strong> and I try to make <code>NumberField</code> — something like TextField, but for numbers. In rather big tree of views at the top I had:</p>
<pre><code> ...
 VStack {
      ForEach(instances.indices, id:\.self) {index in
         TextField(&quot;&quot;,
            text: Binding( 
                get: {&quot;\(String(format: &quot;%.1f&quot;, instances[index].values[valueIndex]))&quot;},
                set: {setValueForInstance(index, valueIndex, $0)})
             )                   
       }
 }
 ...
</code></pre>
<p>And it worked well, but not nice:</p>
<ul>
<li>✔︎ when I changed value, all View structure was redrawn – good</li>
<li>✔︎ values was updated if they were changed by another part of Views structure – good</li>
<li>✖︎ it was updated after each keypresses, which was annoying, when I tried to input <code>1.2</code>, just after pressing <code>1</code> view was updated to <code>1.0</code>. Possible to input every number but inconvenient – bad</li>
</ul>
<p>So, I tried to build <code>NumberField</code>.</p>
<pre><code>    var format = &quot;%.1f&quot;
    struct NumberField : View {
        @Binding var number: Double {
            didSet {
                stringNumber = String(format: format, number)
            }
        }
        @State var stringNumber: String
        var body: some View {
            TextField(&quot;&quot; , text: $stringNumber, onCommit: {
                print (&quot;Commiting&quot;)
                if let v = Double(stringNumber) {
                    number = v
                } else {
                    stringNumber = String(format:format, number)
                }
                print (&quot;\(stringNumber) , \(number)&quot; )
            })
        }
        init (number: Binding&lt;Double&gt;) {
            self._number = number
            self._stringNumber = State(wrappedValue: String(format:format, number.wrappedValue))
        }
    }
</code></pre>
<p>And It's called from the same place as before:</p>
<pre><code> ...
 VStack {
      ForEach(instances.indices, id:\.self) {index in
         NumberField($instances[index].values[valueIndex])                  
       }
 }
 ...
</code></pre>
<p>But in this case it never updates <code>NumberField View</code> if values was changed by another part of View. Whats's wrong? Where is a trick?</p>
","1238267","","","","","2020-10-07 16:47:14","How to build NumberField in SwiftUI?","<swift><swiftui><combine>","0","1","1","","","CC BY-SA 4.0"
"64256851","1","64263595","","2020-10-08 06:22:20","","-1","190","<p>I have implemented the .OnReceive method in a SwiftUI view to be able to keep track of some variebles.</p>
<p><a href=""https://i.stack.imgur.com/qXqBG.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qXqBG.png"" alt=""onCreate"" /></a></p>
<p><a href=""https://i.stack.imgur.com/RsfWN.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RsfWN.png"" alt=""states"" /></a></p>
<p>But as you can see I have all the .onReceive's code is commented and the reason is that if I don't I get the following error on the canvas:</p>
<p><a href=""https://i.stack.imgur.com/2m50Q.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2m50Q.png"" alt=""canvas error"" /></a></p>
<p>This is my ContentView_Previews Struct:
<a href=""https://i.stack.imgur.com/wLSoF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/wLSoF.png"" alt=""enter image description here"" /></a></p>
<p>Could anyone help me to understand the error? I suspect that the ContentView_Previews Struct need some extra value to be able to interpret the view on the canvas.</p>
<p>Thanks for the help!</p>
","2327791","","","","","2020-10-08 13:30:27","Failed to update SwiftUI preview when using .OnReceive Method","<ios><swift><canvas><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"64267041","1","","","2020-10-08 16:43:09","","0","88","<p>I have a question, I want to get some information about the Alpha Vantage API in my app:</p>
<p><em><a href=""https://www.alphavantage.co/query?function=OVERVIEW&amp;symbol=IBM&amp;apikey=demo"" rel=""nofollow noreferrer"">https://www.alphavantage.co/query?function=OVERVIEW&amp;symbol=IBM&amp;apikey=demo</a></em></p>
<p>Now it is so that my code does not work I get no errors but in the result I don't get any outputs, so could someone tell me what the problem is and correct it if possible ?</p>
","14415229","","14415229","","2020-10-08 18:48:02","2020-10-08 18:48:02","Why does my Alpha Vantage api Call dosent work?","<api><swiftui><combine>","0","4","","","","CC BY-SA 4.0"
"64270761","1","64271270","","2020-10-08 21:19:23","","-1","122","<p>I am trying to make a GET from a REST API in swift. When I use the print statement (print(clubs)) I see the expected response in the proper format. But in the VC is gives me an empty array.</p>
<p>Here is the code to talk to the API</p>
<pre><code>extension ClubAPI {

    public enum ClubError: Error {
        case unknown(message: String)
    }

    func getClubs(completion: @escaping ((Result&lt;[Club], ClubError&gt;) -&gt; Void)) {
        let baseURL = self.configuration.baseURL
        let endPoint = baseURL.appendingPathComponent(&quot;/club&quot;)
        print(endPoint)
        API.shared.httpClient.get(endPoint) { (result) in
            switch result {
            case .success(let response):
                let clubs = (try? JSONDecoder().decode([Club].self, from: response.data)) ?? []
                print(clubs)
                completion(.success(clubs))
            case .failure(let error):
                completion(.failure(.unknown(message: error.localizedDescription)))
            }
        }
    }

}
</code></pre>
<p>and here is the code in the VC</p>
<pre><code>private class ClubViewModel {
    @Published private(set) var clubs = [Club]()
    @Published private(set) var error: String?

    func refresh() {
        ClubAPI.shared.getClubs { (result) in
            switch result {
            case .success(let club):
                print(&quot;We have \(club.count)&quot;)
                self.clubs = club
                print(&quot;we have \(club.count)&quot;)
            case .failure(let error):
                self.error = error.localizedDescription
            }
        }
    }
}
</code></pre>
<p>and here is the view controller code (Before the extension)</p>
<pre><code>class ClubViewController: UIViewController {
    private var clubs = [Club]()
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    private lazy var dataSource = makeDataSource()

    enum Section {
        case main
    }
    private var errorMessage: String? {
        didSet {

        }
    }
    private let viewModel = ClubViewModel()
    @IBOutlet private weak var tableView: UITableView!

    override func viewDidLoad() {
        super.viewDidLoad()

        self.subscriptions = [
            self.viewModel.$clubs.assign(to: \.clubs, on: self),
            self.viewModel.$error.assign(to: \.errorMessage, on: self)
        ]

        applySnapshot(animatingDifferences: false)
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.viewModel.refresh()
    }



}




extension ClubViewController {
    typealias DataSource = UITableViewDiffableDataSource&lt;Section, Club&gt;
    typealias Snapshot = NSDiffableDataSourceSnapshot&lt;Section, Club&gt;
    func applySnapshot(animatingDifferences: Bool = true) {
        // Create a snapshot object.
        var snapshot = Snapshot()
        // Add the section
        snapshot.appendSections([.main])
        // Add the player array
        snapshot.appendItems(clubs)
        print(clubs.count)

        // Tell the dataSource about the latest snapshot so it can update and animate.
        dataSource.apply(snapshot, animatingDifferences: animatingDifferences)
    }

    func makeDataSource() -&gt; DataSource {
        let dataSource = DataSource(tableView: tableView) { (tableView, indexPath, club) -&gt; UITableViewCell? in
            let cell = tableView.dequeueReusableCell(withIdentifier: &quot;ClubCell&quot;, for: indexPath)
            let club = self.clubs[indexPath.row]
            print(&quot;The name is \(club.name)&quot;)
            cell.textLabel?.text = club.name
            return cell
        }
        return dataSource
    }
}
</code></pre>
","9525218","","9525218","","2020-10-08 21:54:04","2020-10-08 22:04:49","Swift - How do I decode json from a REST API","<ios><swift><networking><combine><urlsession>","1","6","","","","CC BY-SA 4.0"
"64278780","1","64281609","","2020-10-09 11:04:33","","0","110","<p>I've got the publisher</p>
<pre class=""lang-swift prettyprint-override""><code>@Published var feedData = Feed()
</code></pre>
<p>And this piece of code, which listens to it</p>
<pre class=""lang-swift prettyprint-override""><code>// some View 
.onReceive(feed.$feedData) { feedData in
            if feedData.personalTasks.count &gt; 0 {
                withAnimation(.easeOut(duration: 0.3)) {
                    showCards = true
                }
            }
        }
</code></pre>
<p>The question is when .onRecieve will be executed? Every time feedData is accessed? Or every time any property of feedData is changed? How does this property wrapper know when <em>something</em> changes in feedData?</p>
","14346210","","4042366","","2020-10-09 11:11:05","2020-10-09 14:02:06","When the @Published publishes the value it wraps?","<swift><swiftui><publish-subscribe><combine><property-wrapper>","1","0","","","","CC BY-SA 4.0"
"64282506","1","","","2020-10-09 14:57:23","","2","276","<p>I'm struggling with this for a long time without finding where I'm wrong (I know I'm wrong).</p>
<p>I have one API call with the location of the phone (this one is working), but I want the same API call with a manual location entered by a textfield (using Geocoding for retrieving Lat/Long). The geocoding part is ok and updated but not passed in the API call.</p>
<p>I also want this API call to be triggered when the TextField is cleared by the dedicated button back with the phone location.</p>
<p>Please, what am I missing? Thanks for your help.</p>
<p>UPDATE: This works on Xcode 12.2 beta 2 and should work on Xcode 12.0.1</p>
<p>This is the code:</p>
<p><strong>My Model</strong></p>
<pre><code>import Foundation

struct MyModel: Codable {
    let value: Double
}
</code></pre>
<p><strong>My ViewModel</strong></p>
<pre><code>import Foundation
import SwiftUI
import Combine

final class MyViewModel: ObservableObject {
    
    @Published var state = State.ready
    @Published var value: MyModel = MyModel(value: 0.0)
    @Published var manualLocation: String {
        didSet {
            UserDefaults.standard.set(manualLocation, forKey: &quot;manualLocation&quot;)
        }
    }
    
    @EnvironmentObject var coordinates: Coordinates
    
    init() {
        manualLocation = UserDefaults.standard.string(forKey: &quot;manualLocation&quot;) ?? &quot;&quot;
    }
    
    enum State {
        case ready
        case loading(Cancellable)
        case loaded
        case error(Error)
    }
    
    private var url: URL {
        get {
            return URL(string: &quot;https://myapi.com&amp;lat=\(coordinates.latitude)&amp;lon=\(coordinates.longitude)&quot;)!
        }
    }
    
    let urlSession = URLSession.shared
    
    var dataTask: AnyPublisher&lt;MyModel, Error&gt; {
        self.urlSession
            .dataTaskPublisher(for: self.url)
            .map { $0.data }
            .decode(type: MyModel.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
    
    func load(){
        assert(Thread.isMainThread)
        self.state = .loading(self.dataTask.sink(
            receiveCompletion: { completion in
                switch completion {
                case .finished:
                    print(&quot;⚠️ API Call finished&quot;)
                    break
                case let .failure(error):
                    print(&quot;❌ API Call failure&quot;)
                    self.state = .error(error)
                }
            },
            receiveValue: { value in
                self.state = .loaded
                self.value = value
                print(&quot;👍 API Call loaded&quot;)
            }
        ))
    }
}
</code></pre>
<p><strong>The Location Manager</strong></p>
<pre><code>import Foundation
import SwiftUI
import Combine
import CoreLocation
import MapKit

final class Coordinates: NSObject, ObservableObject {
    
    @EnvironmentObject var myViewModel: MyViewModel
    
    @Published var latitude: Double = 0.0
    @Published var longitude: Double = 0.0
    
    @Published var placemark: CLPlacemark? {
        willSet { objectWillChange.send() }
    }
    
    private let locationManager = CLLocationManager()
    private let geocoder = CLGeocoder()
    
    override init() {
        super.init()
        self.locationManager.delegate = self
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
        self.locationManager.requestWhenInUseAuthorization()
        self.locationManager.startUpdatingLocation()
    }
    
    deinit {
        locationManager.stopUpdatingLocation()
    }
}

extension Coordinates: CLLocationManagerDelegate {
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        latitude = location.coordinate.latitude
        longitude = location.coordinate.longitude
        
        geocoder.reverseGeocodeLocation(location, completionHandler: { (places, error) in
            self.placemark = places?[0]
        })
        self.locationManager.stopUpdatingLocation()
    }
}

extension Coordinates {
    
    func getLocation(from address: String, completion: @escaping (_ location: CLLocationCoordinate2D?)-&gt; Void) {
        let geocoder = CLGeocoder()
        geocoder.geocodeAddressString(address) { (placemarks, error) in
            guard let placemarks = placemarks,
                  let location = placemarks.first?.location?.coordinate else {
                completion(nil)
                return
            }
            completion(location)
        }
    }
}
</code></pre>
<p><strong>The View</strong></p>
<pre><code>import Foundation
import SwiftUI

struct MyView: View {
    @EnvironmentObject var myViewModel: MyViewModel
    @EnvironmentObject var coordinates: Coordinates
    
    private var icon: Image { return Image(systemName: &quot;location.fill&quot;) }
    
    var body: some View {
        VStack{
            VStack{
                Text(&quot;\(icon) \(coordinates.placemark?.locality ?? &quot;Unknown location&quot;)&quot;)
                Text(&quot;Latitude: \(coordinates.latitude)&quot;)
                Text(&quot;Longitude: \(coordinates.longitude)&quot;)
            }
            VStack{
                Text(&quot;UV Index: \(myViewModel.value.value)&quot;)
                    .disableAutocorrection(true)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .padding()
            }
            HStack{
                TextField(&quot;Manual location&quot;, text: $myViewModel.manualLocation)
                if !myViewModel.manualLocation.isEmpty{
                    Button(action: { clear() }) { Image(systemName: &quot;xmark.circle.fill&quot;).foregroundColor(.gray) }
                }
            }
        }.padding()
    }
    
    func commit() {
        coordinates.getLocation(from: self.myViewModel.manualLocation) { places in
            coordinates.latitude = places?.latitude ?? 0.0
            coordinates.longitude = places?.longitude ?? 0.0
        }
        myViewModel.load()
    }
    
    func clear() {
        myViewModel.manualLocation = &quot;&quot;
        myViewModel.load()
    }
}
</code></pre>
","7729503","","7729503","","2020-10-10 22:26:51","2020-10-10 22:26:51","SwiftUI - Location in API call with CLLocationManager and CLGeocoder","<swiftui><combine><swiftui-environment>","0","0","1","","","CC BY-SA 4.0"
"64285386","1","64285634","","2020-10-09 18:22:16","","1","472","<p>I have a <code>CurrentValueSubject</code> in an object and I want another <code>CurrentValueSubject</code> to copy the changes of the first one.</p>
<p>I can't find a way of easily doing that without having to do something like this:</p>
<pre><code>subjectA.assign(to: \.value, on: subjectB).store(in: &amp;cancelables)
</code></pre>
<p>It would be nice to be able to initialize the <code>subjectB</code> using <code>subjectA</code>. Is there a way of doing something like that?</p>
<p>Edit:
For example I was thinking it would be great to be able to do something like:</p>
<pre><code>let subjectB = CurrentValueSubject(from: subjectA)
</code></pre>
","973242","","973242","","2020-10-09 18:25:48","2020-10-09 18:41:37","Create a CurrentValueSubject from another CurrentValueSubject","<ios><swift><combine>","1","10","","","","CC BY-SA 4.0"
"64286306","1","64287364","","2020-10-09 19:39:58","","4","4787","<p>I have a sink that needs to be canceled as soon as I receive the first value. I don't care about future values, just the first one published. Because without storing the <code>AnyCancelable</code> created by the sink, the garbage collector will delete the sink, I must store it. At the same time, I must also clean it up after the sink has completed, otherwise, I will have a memory leak.</p>
<p>I built one using a UUID → AnyCancelable map, but I am worried that this is more complex than it should be; is there another way of doing this? What's recommended by Combine?</p>
<pre><code>@Published var locationState: (location: CLLocation?, error: Error?)?
var requestLocationSinks: [String: AnyCancellable] = [:]

// 1. Generate ID to uniquely identify the current sink.
let sinkID = UUID().uuidString

// 2. Start the sink and store it in our ID → AnyCancellable dictionary.
requestLocationSinks[sinkID] = $locationState.sink { locationState in
    if let locationState = locationState {
        invokeCallbackWithLocationState(locationState)
    }
    // 3. Remove the stored AnyCancellable as soon as we received our first value!
    self.requestLocationSinks.removeValue(forKey: sinkID)
}
</code></pre>
","577878","","","","","2020-10-10 14:39:08","How to stop storing AnyCancellable after Swift Combine Sink has received at least one value?","<ios><swift><combine>","2","2","1","","","CC BY-SA 4.0"
"64289227","1","","","2020-10-10 01:54:15","","1","470","<p>I am using the <strong>MVVM architecture</strong> in <strong>Swift-UI</strong> with <strong>Combine Framework</strong> and <strong>Alamofire</strong>.
However the data is being returned to observable object and is printing means the Alamofire and published data from api layers but from obserable object its not going to view.
I print the response and its printing in publisher but not returning back to view.</p>
<p>Following is the observable object.</p>
<pre><code>import SwiftUI
import Combine

class CountryViewModel: ObservableObject {
    
    @Published var countryResponse:[CountryResponse] = []
    
    @Published var isLoggedIn = false
    @Published var isLoading = false
    
    @Published var shouldNavigate = false
    
    private var disposables: Set&lt;AnyCancellable&gt; = []
    
    var loginHandler = CountryHandler()
    
    @Published var woofUrl = &quot;&quot;
    
    private var isLoadingPublisher: AnyPublisher&lt;Bool, Never&gt; {
        loginHandler.$isLoading
            .receive(on: RunLoop.main)
            .map { $0 }
            .eraseToAnyPublisher()
    }
    
    private var isAuthenticatedPublisher: AnyPublisher&lt;[CountryResponse], Never&gt; {
        loginHandler.$countryResponse
            .receive(on: RunLoop.main)
            .map { response in
                guard let response = response else {
                    return []
                }
                print(response)
                return response
            }
        .eraseToAnyPublisher()
    }
    
    init() {
        countryResponse = []
        isLoadingPublisher
            .receive(on: RunLoop.main)
            .assign(to: \.isLoading, on: self)
            .store(in: &amp;disposables)
        
        isAuthenticatedPublisher.map([CountryResponse].init)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { [weak self] value in
              guard let self = self else { return }
              switch value {
              case .failure:
                self.countryResponse = []
              case .finished:
                break
              }
              }, receiveValue: { [weak self] weather in
                guard let self = self else { return }
                self.countryResponse = weather
            })
            .store(in: &amp;disposables)
           //        isAuthenticatedPublisher
          //            .receive(on: RunLoop.main)
         //            .assign(to: \.countryResponse, on: self)
        //            .store(in: &amp;disposables)
    }
        
    public func getAllCountries(){
        loginHandler.getCountryList()
    }
    
    public func getAllUnis(_ id:Int){
        loginHandler.getCountryList()
    }
}
</code></pre>
<p><strong>View Code</strong></p>
<pre><code>struct ContentViewCollection: View {
    
    @Binding var selectedCountryId:Int
    var axis : Axis.Set = .horizontal
    var viewModel:CountryViewModel
    @State var countries:[CountryResponse] = []
    
    var body: some View {
        ScrollView (.horizontal, showsIndicators: false) {
            HStack {
                ForEach(self.viewModel.countryResponse) { (postData) in
                    Button(action: {
                        self.selectedCountryId = postData.countryID ?? 0
                    }){
                        WebImage(url: self.imageURL(postData.countryName ?? &quot;&quot;))
                            .resizable()
                            .indicator(.activity)
                            .scaledToFit()
                            .frame(minWidth: 40,maxWidth: 40, minHeight: 40, maxHeight: 40, alignment: .center)
                    }
                    
                }
            }
        }.onAppear() {
            self.loadData()
        }
    }
}
</code></pre>
<p>Thanks in advance.</p>
","3322203","","8697793","","2020-10-10 10:08:19","2020-10-10 10:08:19","SwiftUI + Combine framework + MVVM Publisher return empty list","<mvvm><swiftui><observable><combine><swiftui-list>","0","5","","","","CC BY-SA 4.0"
"64290068","1","","","2020-10-10 04:45:39","","0","163","<p>Here's the <code>Publisher</code> protocol:</p>
<pre><code>public protocol Publisher {
  associatedtype Output
  associatedtype Failure: Error

  func receive&lt;S&gt;(subscriber: S) 
    where S: Subscriber, Self.Failure == S.Failure, Self.Output == S.Input
}
</code></pre>
<p>The <code>receive(subscriber:)</code> function requirement is meant to attach a subscriber to the publisher. However, in a protocol extension, there's a very similar function:</p>
<pre><code>extension Publisher {
  public func subscribe&lt;S&gt;(_ subscriber: S) 
    where S: Subscriber, Self.Failure == S.Failure, Self.Output == S.Input
}
</code></pre>
<p>Both <code>receive(subscriber:)</code> and <code>subscribe(_:)</code> have identical constraints on the functions. I'm wondering why there's a need for both</p>
","4211945","","4211945","","2020-10-10 05:03:48","2020-10-10 18:07:09","Why does the Combine Publisher protocol have receive<S> and subscribe<S> with identical constraints?","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"64290448","1","","","2020-10-10 05:54:20","","3","1690","<p>Combine seems to be built with type-erasure in mind. One reason is to avoid the complex types that are generated by many chained operators, such as the explanation defined in this <a href=""https://stackoverflow.com/questions/61553264/is-there-a-way-to-avoid-using-anypublisher-erasetoanypublisher-all-over-the-plac"">question</a>.</p>
<p>I'm curious about the cases where you would <strong>not</strong> want to call <code>eraseToAnyPublisher()</code>. I thought of a possible candidate:</p>
<pre><code>func fetchResource() -&gt; Future&lt;Model, Error&gt;
</code></pre>
<p>In this case, <code>fetchResource</code> isn't meant to emit more than once, and giving the return type of <code>Future</code> would add clarity to the functionality.</p>
<p>You could also return <code>AnyPublisher</code>:</p>
<pre><code>func fetchResource() -&gt; AnyPublisher&lt;Model, Error&gt;
</code></pre>
<p>This allows you to hide the implementation details from the consumer and protect against misuse. There is a tradeoff though... the consumer wouldn't know the semantics of the <code>Future</code>:</p>
<ul>
<li><code>Future</code> executes as soon as it's created, compared to some publishers that emit values <em>only</em> when there's a subscription</li>
<li><code>Future</code> retains their eventual result and shares/replays the value to any future subscribers</li>
</ul>
<p>Anyone know of any good examples of when you wouldn't <code>eraseToAnyPublisher()</code>?</p>
","4211945","","4211945","","2020-10-10 06:48:28","2020-10-10 18:23:25","When NOT to use eraseToAnyPublisher()","<swift><combine>","1","5","1","","","CC BY-SA 4.0"
"64311732","1","64311873","","2020-10-12 04:33:44","","0","58","<p>The following code produces the output that I expect:</p>
<p>
<pre><code>import UIKit
import Combine


    let myURL = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/Canada&quot;)

    // MARK: - Region
    struct Region: Codable {
        let country: String
        let subregions: [String]
    }


    let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
        .map { $0.data }
        .print(&quot;Hello Data&quot;)
        .decode(type: Region.self, decoder: JSONDecoder())

    let cancellableSink = remoteDataPublisher
        .sink(receiveCompletion: { completion in
                print(&quot;.sink() received the completion&quot;, String(describing: completion))
                switch completion {
                    case .finished:
                        break
                    case .failure(let anError):
                        print(&quot;received error: &quot;, anError)
                }
        }, receiveValue: { someValue in
            print(&quot;.sink() received \(someValue)&quot;)
        })


// =====================================================================================================
 
print(&quot;The End.&quot;)
</code></pre>
<p>
Here's the output as shown in the console. <br/>
As you can see, there is no 'cancel':
<p><a href=""https://i.stack.imgur.com/F8qbl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/F8qbl.png"" alt=""enter image description here"" /></a></p>
<p>
<hr/>
However when I wrap the code into a function(), 'combine' CANCELS the output. <br/>
The following code within <b>getRegionList()</b> doesn't produce an output.

Instead it receives a 'cancel' as shown in the console following the code below:
<p>
<pre><code>import UIKit
import Combine

var regionList = [String]()
let simplePublisher = PassthroughSubject&lt;String, Never&gt;()


func getRegionList() {
let myURL = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/Canada&quot;)

// MARK: - Region
struct Region: Codable {
    let country: String
    let subregions: [String]
}


let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: myURL!)
    .map { $0.data }
    .print(&quot;Hello Data&quot;)
    .decode(type: Region.self, decoder: JSONDecoder())

    let cancellableSink = remoteDataPublisher
    .sink(receiveCompletion: { completion in
            print(&quot;.sink() received the completion&quot;, String(describing: completion))
            switch completion {
                case .finished:
                    break
                case .failure(let anError):
                    print(&quot;received error: &quot;, anError)
            }
    }, receiveValue: { someValue in
        print(&quot;.sink() received \(someValue)&quot;)
    })
}
getRegionList()
print(&quot;The End.&quot;)
</code></pre>
<p>
<p>The function cancels as shown in the console:</p>
<p><a href=""https://i.stack.imgur.com/TKJF7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TKJF7.png"" alt=""enter image description here"" /></a></p>
<p>
Why?
<br/>
The only code difference is one <em>is wrapped in a simple function</em>.
<br/>
I suspect some 'lifespan' must have expired.
<p>
<b>Solution:</b> should I make <b>concellableSink</b> global?
<br> What is the correct solution/syntax? 
","715747","","715747","","2020-10-12 04:52:01","2020-10-12 17:26:01","Combine access to server retrieves data within a playground but not within a function. Why?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64316975","1","64322996","","2020-10-12 11:27:32","","1","675","<p>I'm determined to fully understand why this isn't causing a reference cycle. And in general what is happening at each stage of memory management here.</p>
<p>I have the following setup:</p>
<pre><code>struct PresenterView: View {
    @State private var isPresented = false
    var body: some View {
        Text(&quot;Show&quot;)
            .sheet(isPresented: $isPresented) {
                DataList()
            }
            .onTapGesture {
                isPresented = true
            }
    }
}

struct DataList: View {

    @StateObject private var viewModel = DataListViewModel()
    
    var body: some View {
        NavigationView {
            List(viewModel.itemViewModels, id: \.self) { itemViewModel in
                Text(itemViewModel.displayText)
            }.onAppear {
                viewModel.fetchData()
            }.navigationBarTitle(&quot;Items&quot;)
        }
    }
}

class DataListViewModel: ObservableObject {
    
    private let webService = WebService()

    @Published var itemViewModels = [ItemViewModel]()
    
    private var cancellable: AnyCancellable?
    
    func fetchData() {
        cancellable = webService.fetchData().sink(receiveCompletion: { _ in
            //...
        }, receiveValue: { dataContainer in
            self.itemViewModels = dataContainer.data.items.map { ItemViewModel($0) }
        })
    }
    
    deinit {
        print(&quot;deinit&quot;)
    }
    
}

final class WebService {
    
    var components: URLComponents {
        //...
        return components
    }

    func fetchData() -&gt; AnyPublisher&lt;DataContainer, Error&gt; {
        return URLSession.shared.dataTaskPublisher(for: components.url!)
            .map { $0.data }
            .decode(type: DataContainer.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>So when I create a PresenterView and then dismiss it I get a successful deinit print.</p>
<p>However I don't understand why they is no reference cycle here. <code>DataListViewModel</code> has <code>cancellables</code> which has a subscription that captures self. So <code>DataListViewModel</code> -&gt; subscription and subscription -&gt; <code>DataListViewModel</code>. How can <code>deinit</code> be triggered? In general is there a good approach to understanding whether there is a retain cycle in these kinds of situation?</p>
","2105498","","","","","2020-10-12 17:56:31","Why Is There No Retain Cycle In ReceiveValue Block Combine Subscription","<swiftui><combine><retain-cycle>","1","3","","","","CC BY-SA 4.0"
"64335093","1","64338062","","2020-10-13 12:16:05","","5","591","<p>I have a very strange crash that occurs <strong>on Release builds (App Store + TestFlight) and on Apple Watch Series 3 only.</strong> If I run it on debug on my Series 3 it works fine. On newer watches (Series 4+) the App Store and debug versions work fine.</p>
<p>My watch app uses SwiftUI. Does anybody know what is going on here? Is this a SwiftUI bug or am I doing something wrong?</p>
<p>This is the crash log that I'm getting from the Series 3 (symbolicated):</p>
<pre><code>Incident Identifier: B1210338-BE7E-4296-816B-5C07B3B2796A
Beta Identifier:     030172D5-8766-4A2C-B988-12A27F1DB754
Hardware Model:      Watch3,2
Process:             Thirstic [279]
Path:                /private/var/containers/Bundle/Application/8A4A4A35-2570-44BE-9767-E6B8EFE31369/ThirsticWatch.app/PlugIns/Thirstic.appex/Thirstic
Identifier:          co.tapcode.thirstic.watchkitapp.watchkitextension
Version:             24 (2020.2)
AppVariant:          1:Watch3,2:7
Beta:                YES
Code Type:           ARM (Native)
Role:                Foreground
Parent Process:      launchd [1]
Coalition:           co.tapcode.thirstic.watchkitapp [343]


Date/Time:           2020-10-13 11:12:41.5505 +0200
Launch Time:         2020-10-13 11:12:40.0000 +0200
OS Version:          Watch OS 7.0.2 (18R402)
Release Type:        User
Baseband Version:    5.02.01
Report Version:      104

Exception Type:  EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Triggered by Thread:  0

Application Specific Information:
abort() called

Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libsystem_kernel.dylib          0x416e8358 __pthread_kill + 8
1   libsystem_pthread.dylib         0x417638e2 pthread_kill + 170
2   libsystem_c.dylib               0x4166650e abort + 86
3   libswiftCore.dylib              0x6768dee6 swift_vasprintf+ 2506470 (char**, char const*, char*) + 0
4   libswiftCore.dylib              0x67697852 swift_initClassMetadata + 0
5   libswiftCore.dylib              0x6769789c _swift_initClassMetadataImpl+ 2545820 (swift::TargetClassMetadata&lt;swift::InProcess&gt;*, swift::ClassLayoutFlags, unsigned long, swift::TypeLayout const* const*, unsigned long*, bool) + 44
6   libswiftCore.dylib              0x67698416 swift_initClassMetadata2 + 22
7   Thirstic                        0x000e9950 _hidden#4114_ + 366928 (__hidden#304_:0)
8   libswiftCore.dylib              0x67696438 swift_getSingletonMetadata + 720
9   Thirstic                        0x000e9786 type metadata accessor for WaterNeedsTimeline + 366470 (__hidden#304_:0)
10  libswiftCore.dylib              0x676a4bf8 swift::Demangle::TypeDecoder&lt;(anonymous namespace)::DecodedMetadataBuilder&gt;::decodeMangledType+ 2599928 (swift::Demangle::Node*) + 2624
11  libswiftCore.dylib              0x676a4492 swift::Demangle::TypeDecoder&lt;(anonymous namespace)::DecodedMetadataBuilder&gt;::decodeMangledType+ 2598034 (swift::Demangle::Node*) + 730
12  libswiftCore.dylib              0x676a3c14 swift_getTypeByMangledNodeImpl(swift::MetadataRequest, swift::Demangle::Demangler&amp;, swift::Demangle::Node*, void const* const*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* + 2595860 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 250
13  libswiftCore.dylib              0x676a3ae6 swift::swift_getTypeByMangledNode(swift::MetadataRequest, swift::Demangle::Demangler&amp;, swift::Demangle::Node*, void const* const*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* + 2595558 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 310
14  libswiftCore.dylib              0x676a3e90 swift_getTypeByMangledNameImpl(swift::MetadataRequest, llvm::StringRef, void const* const*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* + 2596496 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 556
15  libswiftCore.dylib              0x676a24b4 swift::swift_getTypeByMangledName(swift::MetadataRequest, llvm::StringRef, void const* const*, std::__1::function&lt;swift::TargetMetadata&lt;swift::InProcess&gt; const* (unsigned int, unsigned int)&gt;, std::__1::function&lt;swift::TargetWitnessTable&lt;swift::InProcess&gt; const* + 2589876 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int)&gt;) + 310
16  libswiftCore.dylib              0x676c7870 (anonymous namespace)::getFieldAt+ 2742384 (swift::TargetMetadata&lt;swift::InProcess&gt; const*, unsigned int) + 378
17  libswiftCore.dylib              0x676c7d50 (anonymous namespace)::ClassImpl::childMetadata(long, char const**, void (**)+ 2743632 (char const*)) + 16
18  libswiftCore.dylib              0x676c7eae (anonymous namespace)::ClassImpl::recursiveChildMetadata(long, char const**, void (**)+ 2743982 (char const*)) + 56
19  libswiftCore.dylib              0x676c6b40 swift_reflectionMirror_recursiveChildMetadata + 360
20  libswiftCore.dylib              0x675399e4 _forEachField+ 1112548 (of:options:body:) + 112
21  Combine                         0x5de66dfa ObservableObject&lt;&gt;.objectWillChange.getter + 228
22  Thirstic                        0x0009a172 protocol witness for ObservableObject.objectWillChange.getter in conformance TodayViewModel + 41330 (&lt;compiler-generated&gt;:0)
23  Combine                         0x5de6894e dispatch thunk of ObservableObject.objectWillChange.getter + 10
24  SwiftUI                         0x44d7099a ObservedObjectPropertyBox.update+ 5437850 (property:phase:) + 118
25  SwiftUI                         0x44aa0448 static BoxVTable.update+ 2487368 (ptr:property:phase:) + 164
26  SwiftUI                         0x44aa015c _DynamicPropertyBuffer.update+ 2486620 (container:phase:) + 48
27  SwiftUI                         0x44c493d2 StateObject.Box.update+ 4228050 (property:phase:) + 110
28  SwiftUI                         0x44aa0448 static BoxVTable.update+ 2487368 (ptr:property:phase:) + 164
29  SwiftUI                         0x44aa015c _DynamicPropertyBuffer.update+ 2486620 (container:phase:) + 48
30  SwiftUI                         0x44e8c21e DynamicBody.updateValue+ 6599198 () + 402
31  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
32  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
33  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
34  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
35  AttributeGraph                  0x45106984 AGGraphGetValue + 170
36  SwiftUI                         0x44a878b4 SubscriptionView.ChildAttribute.view.getter + 50
37  SwiftUI                         0x44a879ea SubscriptionView.ChildAttribute.updateValue+ 2386410 () + 286
38  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
39  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
40  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
41  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
42  AttributeGraph                  0x45106984 AGGraphGetValue + 170
43  SwiftUI                         0x44e8b522 StaticBody.container.getter + 50
44  SwiftUI                         0x44e8be8c closure #1 in StaticBody.value.getter + 84
45  SwiftUI                         0x44e8bbd4 StaticBody.value.getter + 476
46  SwiftUI                         0x44e8c070 protocol witness for Rule.value.getter in conformance StaticBody&lt;A&gt; + 8
47  AttributeGraph                  0x45108cb8 dispatch thunk of Rule.value.getter + 10
48  SwiftUI                         0x4490609a implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 807066 (_:) + 42
49  SwiftUI                         0x44922270 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 922224 (_:) + 22
50  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
51  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
52  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
53  AttributeGraph                  0x45106984 AGGraphGetValue + 170
54  SwiftUI                         0x44e8c1cc DynamicBody.updateValue+ 6599116 () + 320
55  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
56  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
57  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
58  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
59  AttributeGraph                  0x45106984 AGGraphGetValue + 170
60  SwiftUI                         0x44cf133c GeometryReader.Child.view.getter + 26
61  SwiftUI                         0x44cf143c GeometryReader.Child.updateValue+ 4916284 () + 240
62  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
63  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
64  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
65  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
66  AttributeGraph                  0x45106984 AGGraphGetValue + 170
67  SwiftUI                         0x44e8c1cc DynamicBody.updateValue+ 6599116 () + 320
68  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
69  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
70  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
71  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
72  AttributeGraph                  0x45106984 AGGraphGetValue + 170
73  SwiftUI                         0x44c2fda2 EnvironmentReadingChild.updateValue+ 4124066 () + 214
74  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
75  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
76  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
77  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
78  AttributeGraph                  0x45106984 AGGraphGetValue + 170
79  SwiftUI                         0x44e7d20c IsAnimated.updateValue+ 6537740 () + 44
80  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
81  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
82  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
83  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
84  AttributeGraph                  0x45106984 AGGraphGetValue + 170
85  SwiftUI                         0x44a838e8 HostPreferencesTransform.updateValue+ 2369768 () + 252
86  SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
87  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
88  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
89  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
90  AttributeGraph                  0x45106984 AGGraphGetValue + 170
91  SwiftUI                         0x44cf217c PairPreferenceCombiner.value.getter + 56
92  SwiftUI                         0x44cf2220 protocol witness for Rule.value.getter in conformance PairPreferenceCombiner&lt;A&gt; + 20
93  AttributeGraph                  0x45108cb8 dispatch thunk of Rule.value.getter + 10
94  SwiftUI                         0x4490609a implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 807066 (_:) + 42
95  SwiftUI                         0x44922270 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 922224 (_:) + 22
96  AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
97  AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
98  AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
99  AttributeGraph                  0x45106984 AGGraphGetValue + 170
100 SwiftUI                         0x44a8382e HostPreferencesTransform.updateValue+ 2369582 () + 66
101 SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
102 AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
103 AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
104 AttributeGraph                  0x450fa104 AG::Graph::input_value_ref_slow+ 37124 (AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long) + 402
105 AttributeGraph                  0x45106984 AGGraphGetValue + 170
106 SwiftUI                         0x44a8382e HostPreferencesTransform.updateValue+ 2369582 () + 66
107 SwiftUI                         0x4493b906 partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;+ 1026310 (_:) + 20
108 AttributeGraph                  0x450f612e AG::Graph::UpdateStack::update+ 20782 () + 422
109 AttributeGraph                  0x450f64ee AG::Graph::update_attribute+ 21742 (AG::data::ptr&lt;AG::Node&gt;, bool) + 264
110 AttributeGraph                  0x450f9cc0 AG::Graph::value_ref+ 36032 (AG::AttributeID, AGSwiftMetadata const*, bool*) + 102
111 AttributeGraph                  0x451069c2 AGGraphGetValue + 232
112 SwiftUI                         0x44e24296 GraphHost.updatePreferences+ 6173334 () + 38
113 SwiftUI                         0x44c5f2a4 ViewGraph.updateOutputs+ 4317860 (at:) + 64
114 SwiftUI                         0x44e6a488 closure #1 in ViewRendererHost.render+ 6460552 (interval:updateDisplayList:) + 1176
115 SwiftUI                         0x44e6367c ViewRendererHost.render+ 6432380 (interval:updateDisplayList:) + 252
116 SwiftUI                         0x44f3ada4 _UIHostingView.layoutSubviews+ 7314852 () + 128
117 SwiftUI                         0x44f3adce @objc _UIHostingView.layoutSubviews+ 7314894 () + 18
118 UIKitCore                       0x5d082ce8 -[UIView+ 13118696 (CALayerDelegate) layoutSublayersOfLayer:] + 2002
119 QuartzCore                      0x46d0121e -[CALayer layoutSublayers] + 232
120 QuartzCore                      0x46d0644c CA::Layer::layout_if_needed+ 1213516 (CA::Transaction*) + 402
121 QuartzCore                      0x46d10af4 CA::Layer::layout_and_display_if_needed+ 1256180 (CA::Transaction*) + 62
122 QuartzCore                      0x46c7c120 CA::Context::commit_transaction+ 647456 (CA::Transaction*, double, double*) + 368
123 QuartzCore                      0x46c9d7e0 CA::Transaction::commit+ 784352 () + 712
124 UIKitCore                       0x5cca6768 __34-[UIApplication _firstCommitBlock]_block_invoke_2 + 72
125 CoreFoundation                  0x41a11cbe __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
126 CoreFoundation                  0x41a11164 __CFRunLoopDoBlocks + 362
127 CoreFoundation                  0x41a0c91c __CFRunLoopRun + 692
128 CoreFoundation                  0x41a0c18a CFRunLoopRunSpecific + 474
129 GraphicsServices                0x451f2eb6 GSEventRunModal + 134
130 UIKitCore                       0x5cc8df7e -[UIApplication _run] + 1044
131 UIKitCore                       0x5cc92afa UIApplicationMain + 114
132 WatchKit                        0x5333143c WKExtensionMain + 680
133 libdyld.dylib                   0x415b7c52 start + 2
</code></pre>
","1983667","","1983667","","2020-10-13 13:42:09","2020-10-16 12:14:32","SwiftUI Apple Watch app crash on release build (Series 3 only)","<swift><swiftui><watchkit><apple-watch><combine>","2","0","","","","CC BY-SA 4.0"
"64360711","1","64364775","","2020-10-14 20:01:37","","1","31","<p>On MacOS, I have a very simple <code>ContentView</code>:</p>
<pre><code>struct ContentView: View {
    
    @ObservedObject var environment: Environment
    
    var body: some View {
        
        if let glyph = environment.glyph {
            print (&quot;Content View \(glyph)&quot;)
            return AnyView {
                GlyphView(glyph: glyph)
            }
        } else {
            return AnyView {
                Text(&quot;no glyph&quot;)
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var environment = Environment()
    static var previews: some View {
        ContentView(environment: environment)
    }
}
</code></pre>
<p>When I run application, console gives:</p>
<pre><code>2020-10-14 21:50:42.065365+0200 ShapeSearch[94679:5992139] Metal API Validation Enabled
2020-10-14 21:50:42.093298+0200 ShapeSearch[94679:5992191] flock failed to lock maps file: errno = 35
2020-10-14 21:50:42.093688+0200 ShapeSearch[94679:5992191] flock failed to lock maps file: errno = 35
Content View Glyph &quot;k&quot; - 6 contours
</code></pre>
<p>and <code>ContentView</code> stays empty, no <code>GlyphView</code>, no <code>Text</code>.</p>
<p>But when I debug <code>GlyphView</code>, I can see very nice rendered glyph on canvas:</p>
<pre><code>struct GlyphView_Previews: PreviewProvider {
    
    static var glyph = Environment().glyph!
    static var previews: some View {
        GlyphView(glyph: glyph)
    }
}
</code></pre>
<p><code>environment.glyph</code> is taken from the same source in both cases. I'm sure.</p>
<p><strong>Edit:</strong></p>
<p>This way it works:</p>
<pre><code>struct ContentView: View {
    
    @ObservedObject var environment: Environment
    
    var body: some View {
        GlyphView(glyph: environment.glyph!)
    }
}
</code></pre>
<p>Where a mistake could be ?</p>
","1238267","","1238267","","2020-10-14 20:13:33","2020-10-15 04:15:00","Canvas renders View, Console gives right output, but View in app stays empty","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64379083","1","68518591","","2020-10-15 20:17:57","","3","604","<p>I've been working with RxSwift for a few years now, and am starting to explore Combine with SwiftUI and am having some trouble trying to replicate some functionality from RxSwift in Combine.</p>
<p>On the RxSwift <a href=""https://github.com/ReactiveX/RxSwift/blob/main/RxExample/RxExample/Services/ActivityIndicator.swift"" rel=""nofollow noreferrer"">GitHub</a> there is an example in a file called <code>ActivityIndicator.swift</code>.</p>
<p>Basic usage is as follows:</p>
<pre><code>class Foo {
  let activityIndicator = ActivityIndicator()

  lazy var activity = activityIndicator.asDriver()

  var disposeBag = DisposeBag()

  func doSomething() {
    Observable
      .just(&quot;this is something&quot;)
      .trackActivity(activityIndicator)
      .subscribe()
      .disposed(by: disposeBag)
  }
}
</code></pre>
<p>What this does is allow you to then drive off of the <code>activity</code> driver and it will emit boolean values every time something subscribes or a subscription completes.</p>
<p>You can then directly drive something like a UIActivityIndicatorView's isAnimating property using RxCocoa.</p>
<p>I've been trying to figure out how to create something similar to this in Combine but am not having any luck.</p>
<p>Say I have a viewModel that looks like this:</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {
  @Published var isActive = false

  func doSomething() -&gt; AnyPublisher&lt;Void, Never&gt; {
    Just(())
      .delay(for: 2.0, scheduler: RunLoop.main)
      .eraseToAnyPublisher()
  }
}
</code></pre>
<p>What I would like to do is create an operator for a <code>Publisher</code> that will function similarly to how the Rx operator worked where I can forward the events from the subscription through the chain, but change the <code>isActive</code> value every time something subscribes/completes/cancels.</p>
<p>In the SwiftUI View I would initiate the <code>doSomething</code> function and sink to it, while also being able to use the published <code>isActive</code> property to show/hide a <code>ProgressView</code></p>
<p>Something similar to this:</p>
<pre class=""lang-swift prettyprint-override""><code>struct SomeView: View {
  let viewModel = ViewModel()

  var body: some View {
    var cancelBag = Set&lt;AnyCancellable&gt;()

    VStack {
      Text(&quot;This is text&quot;)

      if viewModel.isActive {
        ProgressView()
      }
    }
    .onAppear(perform: {
      viewModel
        .doSomething()
        .sink()
        .store(in: &amp;cancelBag)
    })
  }
}
</code></pre>
<p>Is there something that works like this already that I am just completely missing?</p>
<p>If not, how can I go about replicating the RxSwift functionality in Combine?</p>
<p>Thank you in advance for the help.</p>
","4408483","","","","","2021-07-25 12:45:50","RxSwift `ActivityIndicator` Functionality in Combine","<swift><swiftui><observable><rx-swift><combine>","2","0","1","","","CC BY-SA 4.0"
"64380124","1","","","2020-10-15 21:47:28","","2","1971","<p>Is there a way in the following Combine chain to handle all errors at one place ?. If I don't handle the error in flatMap, the <code>$text</code> publisher will never emit again. Thank you.</p>
<pre class=""lang-swift prettyprint-override""><code>
    $text
          .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
          .flatMap {
            Repository().retrieve(query: $0)
              .receive(on: DispatchQueue.main)
              .catch { err -&gt; AnyPublisher&lt;[Beer], Never&gt; in
                self.serverError = err.displayValue
                return Just([]).eraseToAnyPublisher()
              }
          }
          .map { $0.map { ItemViewModel($0) } }
          .receive(on: DispatchQueue.main)
          .sink {[weak self] val in
            self?.items = val
          }.store(in: &amp;cancellables)

</code></pre>
","723056","","","","","2020-10-17 00:48:19","Swift Combine Handling Errors in Flatmap","<ios><swift><combine>","1","9","","2020-10-17 07:55:11","","CC BY-SA 4.0"
"64391848","1","64392074","","2020-10-16 15:11:45","","0","480","<p>I'm pretty sure this should be possible and I'm just searching for the wrong thing, but what I'm going to do is perform a 2 network requests in the same publisher chain.</p>
<p>Basically I'm trying to fetch a JSON Web token (from the web or locally) then perform the requested fetch using that JWT.</p>
<p>I've created a custom Subscription and Publisher for getting my JWT, and it stores the token locally and checks if it's valid so it can be reused, renewed or requested for the first time. However I'm having trouble working out how to then use this with the fetch.</p>
<p>This is where I am (please ignore the force unwrap for now):</p>
<pre class=""lang-swift prettyprint-override""><code>JWTState.publisher(JWTState.urlRequest!)
    .tryMap { (jwtState) -&gt; String in
        guard jwtState.isValid == true else {
            throw JWTError.invalidJWT
        }
        return jwtState.jwt
    }
    .map { (jwt) -&gt; URLRequest in
        URLRequest.jsonRequest(url: url, jwt: jwt)
    }
</code></pre>
<p>At that point I have a valid <code>URLRequst</code> for the fetch using a valid JWT, but I just can't work out how I call the next <code>URLSession.shared.dataTaskPublisher</code> or <code>URLSession.shared.dataTask</code> in the chain.</p>
<p>I'm hoping I've missed some publisher or function, or someone can steer me in the right direction. I'm also guessing I might have to create another custom Subscription and Publisher pair, but at the moment I can't see how doing that would help.</p>
<p>Thanks in advance. 😄</p>
","511495","","","","","2020-10-16 21:10:01","Perform multiple URLSessionDataTask in a single publisher chain","<ios><swift><swiftui><combine>","1","2","","2020-10-16 17:22:41","","CC BY-SA 4.0"
"64392029","1","64392848","","2020-10-16 15:23:08","","6","4590","<p>I'm observe a property on a view using the <code>onChange</code> modifier. However, I'd also like the same piece of code to run on the initial value as well because sometimes the data is injected in the initializer or asynchronously loaded later.</p>
<p>For example, I have a view that gets a model injected. Sometimes this model has data in it to begin with (like previews), or is asynchronously retrieved from the network.</p>
<pre><code>class MyModel: ObservableObject {
    @Published var counter = 0
}

struct ContentView: View {
    @ObservedObject var model: MyModel
    
    var body: some View {
        VStack {
            Text(&quot;Counter: \(model.counter)&quot;)
            Button(&quot;Increment&quot;) { model.counter += 1 }
        }
        .onChange(of: model.counter, perform: someLogic)
        .onAppear { someLogic(counter: model.counter) }
    }
    
    private func someLogic(counter: Int) {
        print(&quot;onAppear: \(counter)&quot;)
    }
}
</code></pre>
<p>In both <code>onAppear</code> and <code>onChange</code> cases, I'd like to run <code>someLogic(counter:)</code>. Is there a better way to get this behaviour or combine them?</p>
","235334","","","","","2022-06-10 09:23:23","Combine onChange and onAppear events in SwiftUI view?","<ios><swift><swiftui><combine>","3","1","1","","","CC BY-SA 4.0"
"64395899","1","","","2020-10-16 20:19:49","","1","39","<pre><code>private lazy var dispatchQueue = DispatchQueue(
        label: &quot;\(type(of: self))&quot;,
        attributes: .concurrent
    )

func makeArrayGreatAgain(elem0: SomeStruct, elem1: SomeStruct, elem2: SomeStruct, elem3: SomeStruct) {
[elem0 elem1, elem2, elem3]
.publisher
.receive(on: dispatchQueue)
.tryMap { print(&quot;R&quot;, $0) } // Void
.eraseToAnyPublisher() // just copy-pasted
.collect(4)
.sink { result in print(&quot;E&quot;, result) }
 receiveValue: { result in print(&quot;S&quot;, result) }
}
</code></pre>
<p>from time to time I see different logs.</p>
<p>For example:</p>
<pre><code>R
R
R
S [(), (), ()]
E
R
</code></pre>
<p>or</p>
<pre><code>R
R
R
R
S [(), (), (), ()]
E
</code></pre>
<p>Why? I want to obtain the whole result:</p>
<pre><code>    R
    R
    R
    R
    S [(), (), (), ()]
    E
</code></pre>
<p>How can I achieve this?</p>
<p><em><strong>Comment</strong></em></p>
<p>the same problem appears for <code>collect()</code> without arguments</p>
","1979882","","","","","2020-10-17 01:45:46","An unobvious behavior of collect() method","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64421297","1","64421357","","2020-10-19 04:46:10","","1","371","<p>Is there way we can cancel dataTaskPublisher while app is going in background in Combine framework?</p>
","2883875","","","","","2020-10-19 14:05:01","Canceling subscription Combine framework","<swiftui><combine>","2","0","3","","","CC BY-SA 4.0"
"64442725","1","64446387","","2020-10-20 09:55:54","","2","806","<p>I need a publisher that publish values from 1 to 360 continuously with a certain time interval between values.</p>
<p>I have this publisher that publish one value from 1 to 360 at every second, but once it reaches 360 it stops, basically <code>(1...360).publisher</code> stops providing values, but I need the publisher to keep publishing values starting again from 1</p>
<p>Probably it will work to add a condition if value == 360 then reset the publisher, but this would be inefficient since the condition will be put for every single value, any idea for a better solution?</p>
<pre><code>struct ContentView: View {

let delayedValuesPublisher = Publishers.Zip((1...360).publisher,
                                            Timer.publish(every: 1, on: .main, in: .default)
                                                .autoconnect())



  var body: some View {

        Text(&quot;&quot;)
            .onReceive(delayedValuesPublisher) { (output) in
                print(output.0)
            }

    }

}
</code></pre>
","10208552","","10208552","","2020-10-20 11:11:43","2020-10-20 13:39:41","How to make a Combine publisher that publish values continuously?","<swift><swiftui><combine><publisher>","1","1","1","","","CC BY-SA 4.0"
"64444966","1","","","2020-10-20 12:16:31","","10","4573","<p>Im moving my project to Combine from RxSwift
I have a logic where I want publisher to emit event every time I click button. Acrually clicking button executed <strong>pushMe.send()</strong></p>
<pre><code>pushMe
            .print(&quot;Debug&quot;)
            .flatMap { (res) -&gt; AnyPublisher&lt;Bool, Error&gt; in
                return Future&lt;Bool, Error&gt;.init { closure in
                    closure(.failure(Errors.validationFail))
                }.eraseToAnyPublisher()
            }
            .sink(receiveCompletion: { completion in
                print(&quot;Completion received&quot;)
            }, receiveValue: { value in
                print(&quot;Value = \(value)&quot;)
            })
            .store(in: &amp;subscriptions)
</code></pre>
<p>The console result</p>
<pre><code>Debug: receive value: (true)
Completion received
Debug: receive value: (true)
Debug: receive value: (true)
</code></pre>
<p>I do not understand why sink receive error only on first event. The rest clicks are ignored.</p>
","2610638","","","","","2021-09-01 07:36:36","Swift Combine sink stops receiving values after first error","<swift><error-handling><combine>","4","3","3","","","CC BY-SA 4.0"
"64454917","1","","","2020-10-21 00:11:17","","0","129","<p>I am trying to fetch AlphaVantage stock data by using combine, URLSession and decode it. I used a framework like the following. I used the same framework successfully fetched other AlphaVantage data such as Income statements and cash flow. however it does not work for Overview data. I could not find where the problem was. I have been struggling with this for sometime and really appreciate if someone can help.</p>
<pre><code>import Foundation
import Combine

var subscriptions = Set&lt;AnyCancellable&gt;()


let pub1 = getCompOverview()
    .sink(receiveCompletion: { completion in
        switch completion {
        case .finished:
            print(&quot;.sink completed&quot;)
            break
        case .failure(let anError):
            print(&quot;received error: &quot;, anError)
        }
    }, receiveValue: { receivedValue in
        print(&quot;.sink() received \(receivedValue)&quot;)
    })
    .store(in: &amp;subscriptions)

func getCompOverview() -&gt; AnyPublisher&lt;CompOverview, Error&gt; {
    guard let url = URL(string: &quot;https://www.alphavantage.co/query?function=OVERVIEW&amp;symbol=IBM&amp;apikey=demo&quot;) else {
        return Fail(error: FetchError.invalidURL).eraseToAnyPublisher()
    }
    return URLSession.shared.dataTaskPublisher(for: url)
        .retry(2)
        .tryMap { data, response in
            guard
                let httpURLResponse = response as? HTTPURLResponse,
                httpURLResponse.statusCode == 200
            else {
                throw URLError(.badServerResponse)
            }
            print(&quot;fetching data size = \(data)&quot;)
            return data
        }
        .decode(type: CompOverview.self, decoder: JSONDecoder())
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}


struct CompOverview: Codable {
    var symbol:                 String
    var name:                   String
    var description:            String
    var sector:                 String
    var industry:               String
    
    var peRatio:                String
    var pegRatio:               String
    var forwardPE:              String
    var eps:                    String
    
    var divPerShare:       String
    var divYield:          String
    var payoutRatio:            String
    
    var percentInsiders:        String
    var percentInstitutions:    String
    
    var priceToSalesRatioTTM:   String
    var marketCapitalization:   String
    var sharesOutstanding:      String
    
    enum CodingKeys: String, CodingKey {
        case symbol = &quot;Symbol&quot;
        case name = &quot;Name&quot;
        case description = &quot;Description&quot;
        case sector = &quot;Sector&quot;
        case industry = &quot;Industry&quot;
        case peRatio = &quot;PERatio&quot;
        case pegRatio = &quot;PEGRatio&quot;
        case forwardPE = &quot;ForwardPE&quot;
        case eps = &quot;EPS&quot;
        
        case divPerShare = &quot;DividendPerShare&quot;
        case divYield = &quot;DividendYield&quot;
        case payoutRatio = &quot;PayoutRatio&quot;
        
        case percentInsiders = &quot;PercentInsiders&quot;
        case percentInstitutions = &quot;PercentInstitutions&quot;
        
        case priceToSalesRatioTTM = &quot;PriceToSalesRatioTTM&quot;
        case marketCapitalization = &quot;MarketCapitalization&quot;
        case sharesOutstanding = &quot;SharesOutstanding&quot;
    }
    
}
enum FetchError: Error {
    case statusCode
    case decoding
    case invalidImage
    case invalidURL
    case other(Error)
    
    static func map(_ error: Error) -&gt; FetchError {
        return (error as? FetchError) ?? .other(error)
    }
</code></pre>
<p>when I test the code in the playground. it printed the line in the .tryMap closure. however,  .sink did not execute.</p>
","14488918","","14488918","","2020-10-23 02:12:00","2020-10-23 02:12:00","combine URLSession and Json Decoder AlphaVantage Overview data","<swift><decode><combine><urlsession>","0","5","","","","CC BY-SA 4.0"
"64457978","1","","","2020-10-21 06:42:32","","0","362","<p>I have a question about <a href=""https://developer.apple.com/documentation/foundation/timer/timerpublisher"" rel=""nofollow noreferrer"">TimerPublisher</a> in Apple's Combine framework. The docs say: <em>A publisher that repeatedly emits the current date on a given interval</em>. With non-Combine <code>Timer</code> objects, you can cancel them. How do you clean up after creating a <code>TimerPublisher</code> and connecting to it? Suppose I cancel all sinks and there is nothing subscribing to the timer publisher. Does the publisher still create some overhead in the system? If so, then how do I <em>cancel</em> the timer publisher?</p>
","473891","","","","","2020-10-21 06:46:28","Swift combine TimerPublisher without any subscribers","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"64468775","1","","","2020-10-21 17:31:17","","2","1712","<p>I have been playing with Apple's <code>Combine</code> framework, There I found couple of operators <code>map() &amp; tryMap()</code> or <code>allSatisfy() &amp; tryAllSatisfy</code></p>
<p>many operators in Combine follows this pattern, I wonder what does this meant for.</p>
<p>I gone through with many operator, most of them have prefixed <code>try</code>. If some one can let me know in most plain manner, that would really helpful.</p>
<p>Thanks</p>
","4260623","","4667835","","2020-10-21 19:24:52","2020-10-21 20:00:50","Combine, map() vs tryMap() operators","<swift><reactive-programming><combine>","2","0","","","","CC BY-SA 4.0"
"64489959","1","64492986","","2020-10-22 20:19:56","","0","707","<p>Here is my thought, I want to present the data when the user searching via <code>$artistName</code> then combine framework could help me to request the data from the server.</p>
<p>I don't know which step I'm wrong. When I try to fetch the data via the simulator. It will show the unknown error and the rest of these.</p>
<pre><code>2020-10-23 03:56:38.220523+0800 PodcastSearchV2[42967:667554] [] nw_protocol_get_quic_image_block_invoke dlopen libquic failed
Fetch failed: Unknown error
2020-10-23 03:56:40.114906+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.115071+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.115255+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.115360+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.115516+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_connected_local_endpoint [C2] Client called nw_connection_copy_connected_local_endpoint on unconnected nw_connection
2020-10-23 03:56:40.115613+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_connected_remote_endpoint [C2] Client called nw_connection_copy_connected_remote_endpoint on unconnected nw_connection
2020-10-23 03:56:40.115723+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_connected_path [C2] Client called nw_connection_copy_connected_path on unconnected nw_connection
2020-10-23 03:56:40.115924+0800 PodcastSearchV2[42967:667546] Connection 2: unable to determine interface type without an established connection
2020-10-23 03:56:40.116069+0800 PodcastSearchV2[42967:667546] Connection 2: unable to determine interface classification without an established connection
2020-10-23 03:56:40.116381+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_protocol_metadata [C2] Client called nw_connection_copy_protocol_metadata on unconnected nw_connection
2020-10-23 03:56:40.120441+0800 PodcastSearchV2[42967:667546] [connection] nw_connection_copy_metadata [C2] Client called nw_connection_copy_metadata on unconnected nw_connection
2020-10-23 03:56:40.120579+0800 PodcastSearchV2[42967:667546] Connection 2: unable to determine interface type without an established connection
2020-10-23 03:56:40.121823+0800 PodcastSearchV2[42967:667546] Connection 2: unable to determine interface type without an established connection
</code></pre>
<p>This is my response.</p>
<pre><code>struct DataResponseSpotify: Codable {
    var episodes: PodcastItemSpotify
}

struct PodcastItemSpotify: Codable {
    var items: [PodcastItemsDetailsSpotify]
}

struct PodcastItemsDetailsSpotify: Codable, Identifiable {
    let id: String
    let description: String
    let images: [Images]
    let name: String
    let external: String
    
    var externalURL: URL? {
        return URL(string: external)
    }
    
    enum CodingKeys: String, CodingKey {
        case id
        case description
        case images
        case name
        case external = &quot;external_urls&quot;
    }
}

struct Images: Codable {
    let url: String
    
    var imageURL: URL? {
        return URL(string: url)
    }
    
    enum CodingKeys: String, CodingKey {
        case url
    }
}

struct Token: Codable {
    let accessToken: String
    
    enum CodingKeys: String, CodingKey {
        case accessToken = &quot;access_token&quot;
    }
}
</code></pre>
<p>This is how I write in the model.</p>
<pre><code>class DataObserverSpotify: ObservableObject {
    
    @Published var artistName = &quot;&quot;
    @Published var token = &quot;&quot;
    @Published var fetchResult = [PodcastItemsDetailsSpotify]()
    var subscriptions: Set&lt;AnyCancellable&gt; = []
    let podsURLComponents = PodsFetcher()
    
    init() {
        getToken()
        $artistName
            .debounce(for: .seconds(2), scheduler: RunLoop.main)
            .removeDuplicates()
            .compactMap { query in
                let url = self.podsURLComponents.makeURLComponentsForSpotify(withName: query, tokenAccess: self.token)
                return URL(string: url.string ?? &quot;&quot;)
            }
            .flatMap(fetchDatatesting)
            .receive(on: DispatchQueue.main)
            .assign(to: \.fetchResult, on: self)
            .store(in: &amp;subscriptions)
    }
    
     
    func fetchDatatesting(url: URL) -&gt; AnyPublisher&lt;[PodcastItemsDetailsSpotify], Never&gt; {
        URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: DataResponseSpotify.self, decoder: JSONDecoder())
            .map(\.episodes.items)
            .replaceError(with: [])
            .eraseToAnyPublisher()
    }
    
    
    func getToken() {
        let parameters = &quot;grant_type=refresh_token&amp;refresh_token=[example-refresh-token]&quot;
        let postData =  parameters.data(using: .utf8)
        var request = URLRequest(url: URL(string: &quot;https://accounts.spotify.com/api/token&quot;)!,timeoutInterval: Double.infinity)
        request.addValue(&quot;Basic exampleBasicAuth=&quot;, forHTTPHeaderField: &quot;Authorization&quot;)
        request.addValue(&quot;application/x-www-form-urlencoded&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        request.addValue(&quot;inapptestgroup=; __Host-device_id=example_id; __Secure-example=; csrf_token=example&quot;, forHTTPHeaderField: &quot;Cookie&quot;)

        request.httpMethod = &quot;POST&quot;
        request.httpBody = postData

        URLSession.shared.dataTask(with: request) { data, response, error in
            if let data = data {
                let decoder = JSONDecoder()
                decoder.dateDecodingStrategy = .iso8601
                if let token = try? decoder.decode(Token.self, from: data) {
                    DispatchQueue.main.async {
                        self.token = token.accessToken
                    }
                    return
                }
            }
            print(&quot;Fetch failed: \(error?.localizedDescription ?? &quot;Unknown error&quot;)&quot;)
        }.resume()
    }
    

}
</code></pre>
","9318133","","","","","2020-10-23 02:24:43","Couldn't not fetching the data from Spotify API with Combine framework in SwiftUI","<api><swiftui><spotify><combine>","1","0","1","","","CC BY-SA 4.0"
"64509935","1","64510089","","2020-10-24 04:20:46","","1","1439","<p>I have a view(<code>MainView</code>) with another view(<code>FooGroupView</code>) inside. Each time I click the item in <code>FooGroupView</code> then pass the value changes to <code>MainView</code>.</p>
<p>Like below:</p>
<p>The white view is <code>MainView</code>, the red is <code>FooGroupView</code>. If click <code>foo1</code> then the text should <code>Current:foo1</code>, then if click <code>foo2</code> then <code>Current:foo2</code>.</p>
<p><a href=""https://i.stack.imgur.com/UMUjA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UMUjA.png"" alt=""enter image description here"" /></a></p>
<p>My code is here:</p>
<p><strong>Test.Playground</strong></p>
<pre><code>import SwiftUI
import PlaygroundSupport

struct FooRowView: View {

    var foo: Foo

    var body: some View {
        VStack {
            Color(.red)
            Text(foo.name)
        }
    }
}

class Foo: Identifiable, ObservableObject {
    var name: String
    var id: String

    init(name: String, id: String) {
        self.name = name
        self.id = id
    }
}

final class FooGroupViewModel: ObservableObject {

    var foos: [Foo] {
        didSet {
            self.selectedFoo = foos.first
        }
    }

    @Published var selectedFoo: Foo? {
        didSet {
            print(&quot;You selected: \(selectedFoo?.name)&quot;)
        }
    }

    init(foos: [Foo] = []) {
        self.foos = foos
        self.selectedFoo = foos.first
    }
}

struct FooGroupView: View {

    var viewModel: FooGroupViewModel

    var body: some View {
        ScrollView(.horizontal) {
            HStack(alignment: .center, spacing: 32, content: {

                // Error: error: Execution was interrupted, reason: signal SIGABRT.
                //The process has been left at the point where it was interrupted, use &quot;thread return -x&quot; to return to the state before expression evaluation.

                /*ForEach(viewModel.foos) { foo in
                    Text(foo.name)
                }*/


                Text(viewModel.foos[0].name).onTapGesture {
                    viewModel.selectedFoo = viewModel.foos[0]
                }
                Text(viewModel.foos[1].name).onTapGesture {
                    viewModel.selectedFoo = viewModel.foos[1]
                }
            })
        }
    }
}

final class MainViewModel: ObservableObject {
    @ObservedObject var fooGroupViewModel: FooGroupViewModel

    @Published var currentFoo: Foo?

    init() {
        fooGroupViewModel = FooGroupViewModel(foos: [Foo(name: &quot;foo1&quot;, id: &quot;1&quot;), Foo(name: &quot;foo2&quot;, id: &quot;2&quot;)])
        currentFoo = self.fooGroupViewModel.selectedFoo

    }
}

struct MainView: View {

    @ObservedObject var viewModel = MainViewModel()

    var body: some View {
        VStack {
            FooGroupView(viewModel: viewModel.fooGroupViewModel)
                .background(Color.red)
            Spacer()
            Text(&quot;Current:\(viewModel.currentFoo!.name)&quot;)
        }.frame(width: 200, height: 200)

    }
}


PlaygroundPage.current.liveView = UIHostingController(rootView: MainView())
</code></pre>
<p>In <code>MainViewModel</code> if <code>currentFoo</code> has changes, then the UI should be updated.</p>
<p>When click <code>foo1</code> or <code>foo2</code>, the <code>selectedFoo</code> in <code>FooGroupViewModel</code> was updated, then in <code>MainViewModel</code> should get the changes (as <code>@ObservedObject var fooGroupViewModel: FooGroupViewModel</code>)</p>
<p>My question is how to let <code>currentFoo</code> knows about the changes of <code>selectedFoo</code> in <code>fooGroupViewModel</code>? I was thought this line could observe the changes of the <code>selectedFoo</code> and if any update then trigger the <code>currentFoo</code> changes and update the UI.</p>
<pre><code>currentFoo = self.fooGroupViewModel.selectedFoo
</code></pre>
<p>But actually it doesn't work.</p>
<p>Any help? thanks!</p>
<p>I also have another question, its the comment in above code(Line 56 if paste my code into Playground)</p>
<pre><code>ForEach(viewModel.foos) { foo in
                    Text(foo.name)
                }
</code></pre>
<p>this code make the playground error:</p>
<pre><code>// Error: error: Execution was interrupted, reason: signal SIGABRT.
                //The process has been left at the point where it was interrupted, use &quot;thread return -x&quot; to return to the state before expression evaluation.
</code></pre>
<p>without any other information in console. Not sure why. Thanks for any help.</p>
","291240","","","","","2020-10-24 05:05:16","SwiftUI How to assign @Published to another @Published","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64511114","1","","","2020-10-24 07:41:41","","1","256","<p>I write code, don't have an error in Xcode, but I can't get fetching data with combine, why? without combine this API working, with combine no) why? maybe I have mistake somewhere</p>
<pre class=""lang-swift prettyprint-override""><code>class ModelView: ObservableObject {
  let baseURL = &quot;https://itunes.apple.com/search?term=taylor+swift&amp;entity=song&quot;
  private var task: AnyCancellable?
  @Published var result = [Result]()
  func fetchData() {
    guard let url = URL(string: &quot;https://itunes.apple.com/search?term=taylor+swift&amp;entity=song&quot;) else { 
      return 
    }
    task = URLSession.shared.dataTaskPublisher(for: url)
      .map{$0.data}
      .decode(type: Response.self, decoder: JSONDecoder())
      .map{$0.result}
      .replaceError(with: [Result]())
      .eraseToAnyPublisher()
      .receive(on: RunLoop.main)
      .assign(to: \ModelView.result, on: self)
  }
}
struct ContentView: View {
  @ObservedObject var model = ModelView()
  var body: some View {
    List {
      ForEach(model.result, id: \.self) { 
        i in VStack {
          Text(i.trackName)
        }
      }
    }.onAppear {
      self.model.fetchData()
    }
  }
}
</code></pre>
","13065117","","2312051","","2020-10-24 11:48:08","2020-10-24 16:27:39","swiftui combine can't fetch data","<api><swiftui><combine>","1","5","","2020-10-25 04:54:33","","CC BY-SA 4.0"
"64512868","1","64517234","","2020-10-24 11:30:25","","2","243","<p>I am trying to generate a Combine publisher off <code>didReceiveRemoteNotification </code></p>
<p>Similar to this code below:</p>
<pre><code>NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)
</code></pre>
<p>I want to use SwiftUI Lifecycle and don't want to use AppDelegate methods using <code>@UIApplicationDelegateAdaptor</code></p>
","7680493","","","","","2020-10-24 19:28:11","How to generate a Combine Publisher for didReceiveRemoteNotification?","<ios><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"64532998","1","64546061","","2020-10-26 07:31:56","","1","77","<p><strong>Scenario:</strong> I want to use a common function to access various endpoints.  So I'm trying to create boilerplate code to process various data models (struct.self) with their associated URLs.</p>
<p>Here are a couple of models that <em>share a common</em> URLSession + decode code:</p>
<pre><code>// MARK: - Region
struct Region: Codable {
    let country: String
    let subregions: [String]
}


// MARK: - SubRegion
struct SubRegion: Codable {
    let country: String
    let subregion: Sub
    let data: [Datum]
}
</code></pre>
<p>Here's one data vector (<code>Region</code>) that contains a URL with its associated data model:</p>
<pre><code>struct URLDataModel {
    var url = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/Canada&quot;)
    var dataModel: Any = Region.self
}
</code></pre>
<p>The following is the entire class that contains the shared <code>getRegionList()</code> using the <code>URLDataModel</code> struct:</p>
<pre><code>class CountryRegionListModelView: ObservableObject {
    @Published var countryRegionList = [String]()

    // Data Persistence:
    var cancellables: Set&lt;AnyCancellable&gt; = []

    // TODO: --- Get Region tag ---
    func getRegionList(urlDataModel: URLDataModel) {
        // MARK: - Region

        struct Country: Codable {
            let countries: [String]
        }
        struct Region: Codable {
            let country: String
            let subregions: [String]
        }
        print(&quot;url: &quot;, urlDataModel.url)

        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: urlDataModel.url!)
            // the dataTaskPublisher output combination is (data: Data, response: URLResponse)
            .map(\.data)
            .receive(on: DispatchQueue.main)
            .print(&quot;Hello Data&quot;)
            .decode(type: urlDataModel.dataModel, decoder: JSONDecoder())

        remoteDataPublisher
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case let .failure(anError):
                    Swift.print(&quot;received error: &quot;, anError)
                }
            }, receiveValue: { someValue in
                self.countryRegionList = someValue.subregions
                print(self.countryRegionList)

            }).store(in: &amp;cancellables)
    }
}
</code></pre>
<p>
<b>Problem:</b> I don't know how to make the JSON decoder work with a <em>variable</em> model type <b>'model'.self</b>.
<p>Should I use generics?  <br/>
How would that work?
","715747","","8697793","","2020-10-30 23:47:32","2020-10-31 00:15:58","Using a generic value for the model (vs a static model.self) to be parsed with JSONDecoder","<json><swift><swiftui><publish-subscribe><combine>","2","0","","","","CC BY-SA 4.0"
"64533899","1","64539537","","2020-10-26 08:48:06","","3","779","<p>in order to customise a <code>UISlider</code>, I use it in a <code>UIViewRepresentable</code>. It exposes a <code>@Binding var value: Double</code> so that my  view model (<code>ObservableObject</code>) view can observe the changes and update a <code>View</code> accordingly.</p>
<p>The issue is that the view is not updated when the <code>@Binding</code> value is changed. In the following example, I have two sliders. One native <code>Slider</code> and one custom <code>SwiftUISlider</code>.</p>
<p>Both pass a binding value to the view model that should update the view. The native <code>Slider</code> does update the view but not the custom one. In the logs, I can see that the <code>$sliderValue.sink { ... </code> is correctly called but the view is not updated.</p>
<p>I noticed this is happening when the presenting view has the <code>@Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;</code> property. If I comment it out, it works as expected.</p>
<p><a href=""https://i.stack.imgur.com/fj65K.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fj65K.gif"" alt=""enter image description here"" /></a></p>
<p>A complete sample code to reproduce this is</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @State var isPresentingModal = false

    // comment this out
    @Environment(\.presentationMode) var presentationMode: Binding&lt;PresentationMode&gt;

    var body: some View {
        VStack {
            Button(&quot;Show modal&quot;) {
                isPresentingModal = true
            }
            .padding()
        }
        .sheet(isPresented: $isPresentingModal) {
            MyModalView(viewModel: TempViewModel())
        }
    }
}

class TempViewModel: ObservableObject {
    @Published var sliderText = &quot;&quot;
    @Published var sliderValue: Double = 0
    private var cancellable = Set&lt;AnyCancellable&gt;()

        init() {
            $sliderValue
                .print(&quot;view model&quot;)
                .sink { [weak self] value in
                    guard let self = self else { return }
                    print(&quot;updating view  \(value)&quot;)
                    self.sliderText = &quot;\(value) C = \(String(format: &quot;%.2f&quot; ,value * 9 / 5 + 32)) F&quot;
                }
                .store(in: &amp;cancellable)
        }
}

struct MyModalView: View {
    @ObservedObject var viewModel: TempViewModel

    var body: some View {
        VStack(alignment: .leading) {
            Text(&quot;SwiftUI Slider&quot;)
            Slider(value: $viewModel.sliderValue, in: -100...100, step: 0.5)
                .padding(.bottom)

            Text(&quot;UIViewRepresentable Slider&quot;)
            SwiftUISlider(minValue: -100, maxValue: 100, value: $viewModel.sliderValue)
            Text(viewModel.sliderText)
        }
        .padding()
    }
}

struct SwiftUISlider: UIViewRepresentable {
    final class Coordinator: NSObject {
        var value: Binding&lt;Double&gt;
        init(value: Binding&lt;Double&gt;) {
            self.value = value
        }

        @objc func valueChanged(_ sender: UISlider) {
            let index = Int(sender.value + 0.5)
            sender.value = Float(index)
            print(&quot;value changed \(sender.value)&quot;)
            self.value.wrappedValue = Double(sender.value)
        }
    }

    var minValue: Int = 0
    var maxValue: Int = 0

    @Binding var value: Double

    func makeUIView(context: Context) -&gt; UISlider {
        let slider = UISlider(frame: .zero)
        slider.minimumTrackTintColor = .systemRed
        slider.maximumTrackTintColor = .systemRed
        slider.maximumValue = Float(maxValue)
        slider.minimumValue = Float(minValue)

        slider.addTarget(
            context.coordinator,
            action: #selector(Coordinator.valueChanged(_:)),
            for: .valueChanged
        )

        adapt(slider, context: context)
        return slider
    }

    func updateUIView(_ uiView: UISlider, context: Context) {
        adapt(uiView, context: context)
    }

    func makeCoordinator() -&gt; SwiftUISlider.Coordinator {
        Coordinator(value: $value)
    }

    private func adapt(_ slider: UISlider, context: Context) {
        slider.value = Float(value)
    }
}

struct PresentationMode_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
","677987","","677987","","2020-10-26 14:47:20","2020-10-26 19:43:08","UIViewRepresentable not working in a modally presented SwiftUI View","<swiftui><combine><observableobject>","2","0","2","","","CC BY-SA 4.0"
"64551792","1","64552734","","2020-10-27 09:46:51","","2","936","<p>I created a Model like this:</p>
<pre><code>class TestModel: ObservableObject {
    @Published var num: Int = 0
}
</code></pre>
<p>Model is be used in &quot;Home&quot; view and &quot;Home&quot;s child view &quot;HomeSub&quot;</p>
<pre><code>struct Home: View {
    
    @StateObject var model = TestModel()
    
    var body: some View {
        NavigationView(content: {
            NavigationLink(destination: HomeSub(model: model)) { Text(&quot;\(model.num)&quot;) }
        })
    }
}
</code></pre>
<pre><code>struct HomeSub: View {
   //1
    @StateObject var model = TestModel()
   //2
    @ObservedObject var model = TestModel()

    var body: some View {
        VStack {
            Text(&quot;\(model.num)&quot;)
                .padding()
                .background(Color.red)
            Button(&quot;Add&quot;) {
                model.num += 1
            }
        }
        .onChange(of: model.num, perform: { value in
            print(&quot;homeSub: \(value)&quot;)
        })
        
    }
}
</code></pre>
<p>In HomeSub view, what is the difference between 1 and 2?
When I run the project, they have exactly the same behavior.</p>
","14527688","","1630618","","2020-10-27 11:23:05","2020-10-27 11:28:11","What is the difference between @StateObject and @ObservedObject in child views in swiftUI","<swift><swiftui><combine><observedobject>","3","0","1","","","CC BY-SA 4.0"
"64582759","1","","","2020-10-28 23:23:00","","2","1312","<p>I have an existing flow implemented using <code>Operation</code> subclasses and an <code>OperationQueue</code>. I'm trying reimplement in Combine as a learning exercise.</p>
<p>The current version, simplified, looks like this:</p>
<pre class=""lang-swift prettyprint-override""><code>func testFunction(completionHandler: (Result) -&gt; Void) {
    let op = LongRunningOperation(object: self.stateObject)

    op.completionHandler = { [unowned op] in
        let result = op.result
        self.stateObject.update(with: result)

        completionHandler(result)
    }

    localSerialQueue.addOperation(op)
}
</code></pre>
<p>Some important aspects. <code>LongRunningOperation</code> is asynchronous. It may need to call out to the main queue to complete the login process, depending on <code>stateObject</code>. <code>stateObject</code> is only ever accessed on the <code>localSerialQueue</code>. Also, just to be really explicit, there could be other concurrent calls to <code>runOperation</code>, so the serialization provided by the queue+operation is essential.</p>
<p>The combination of <strong>mutable state</strong> and <strong>potential concurrent invocations</strong> is absolutely critical to the problem.</p>
<p>To illustrate the issue, I've produced an example which <strong>proves</strong> that Combine pipelines are not executed atomically. Any other result would have surprised me, but I just wanted to verify. Multiple threads can be executing various stages of the pipeline simultaneously, violating our precondition checks.</p>
<pre class=""lang-swift prettyprint-override""><code>class MyThreadUnsafeObject {
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private var inProcess = false

    private func testFunction() {
        Result&lt;Bool, Error&gt; {
            // begin our pipeline, checking our invariant
            // and mutating the state to start our process
            precondition(self.inProcess == false)

            self.inProcess = true

            // just pass some dummy data through
            return true
        }
        .publisher
        .flatMap { (result: Bool) -&gt; AnyPublisher&lt;Bool, Error&gt; in
            Future { (promise) in
                precondition(self.inProcess)

                // simulate a very simple long-running task here,
                // which is not even asynchronous, just to make things
                // really clear.

                // critically, change some mutable state only
                // when done

                precondition(self.inProcess)
                sleep(2)
                precondition(self.inProcess)

                promise(.success(true))
            }.eraseToAnyPublisher()
        }
        .sink(receiveCompletion: { completion in
            if case .failure = completion {
                fatalError(&quot;this isn't allowed to happen&quot;)
            }
        }, receiveValue: { result in
            precondition(result == true)
            precondition(self.inProcess)

            // back to the initial state
            self.inProcess = false
        })
        .store(in: &amp;self.cancellables)
    }

    func runTest() {
        let group = DispatchGroup()

        for _ in 0..&lt;20 {
            DispatchQueue.global().async(group: group, qos: .default, flags: .inheritQoS) {
                self.testFunction()
            }
        }

        group.wait()
    }
}
</code></pre>
<p>Just to be extremely clear, my question is not about how to build a Combine pipeline. It is about the semantics of Combine's synchronization primitives, and how I can protect mutable state that is accesses within a pipeline. And, it could be the solution is to use Combine with another form of synchronization (like a lock) to handle this kind of access pattern. That's totally fine! I'm just curious if others have run into this kind of issue, if there is a more idiomatic way, or if I can reframe the problem somehow.</p>
","288405","","288405","","2020-10-29 14:02:29","2022-02-25 13:10:46","Running a Combine chain in a thread-safe way","<swift><multithreading><nsoperationqueue><combine>","2","8","","","","CC BY-SA 4.0"
"64607968","1","64608071","","2020-10-30 11:59:33","","0","160","<p>I'd like to provide <code>Combine</code> counterparts to completion closures which is becoming very cumbersome. Is there a shorter way or extension that can convert the following:</p>
<pre><code>extension MyType {
    
    func send(with request: URLRequest, completion: @escaping (Result&lt;MyResponse, MyError&gt;) -&gt; Void) {
        // Logic
    }
    
    func send(with request: URLRequest) -&gt; Future&lt;MyResponse, MyError&gt; {
        Future&lt;MyResponse, MyError&gt; { promise in
            send(with: request) { result in
                switch result {
                case let .success(response):
                    promise(.success(response))
                case let .failure(error):
                    promise(.failure(error))
                }
            }
        }
    }
}
</code></pre>
<p>The <code>Future</code> method is just a wrapper to the completion closure method. I was hoping to do at least something like this:</p>
<pre><code>Future&lt;MyResponse, MyError&gt; { send(with:request, completion: $0) }
</code></pre>
<p>Is there a more elegant way to do this since this will be applied in a lot of places in my library.</p>
","235334","","","","","2020-10-30 12:09:36","Shorthand conversion from Result to Future in Swift?","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"64614122","1","64617001","","2020-10-30 18:46:02","","0","1935","<p>I'm trying to create a refresh event using CurrentValueSubject while making a network call. So whenever network request fails I can press the button to make the request again, but can't make it work as failure event will terminate publisher and it won't work again.</p>
<pre><code>import Combine
import SwiftUI

struct ContentView: View {

    @ObservedObject var viewModel: TestViewModel = TestViewModel()

    var body: some View {
        Button(&quot;Test&quot;, action: viewModel.test)
        Button(&quot;Refresh&quot;, action: viewModel.refresh)
    }
}

class TestViewModel: ObservableObject {

    var bag = Set&lt;AnyCancellable&gt;()
    private let changeSubject = CurrentValueSubject&lt;Void, Never&gt;(())

    func test() {
        changeSubject
            .flatMap { self.networkPublisher }
            .sink(
                receiveCompletion: {
                    switch $0 {
                        case .failure:
                            print(&quot;Failure&quot;)
                        case .finished:
                            print(&quot;Finished&quot;)
                    }
                },
                receiveValue: {
                    print(&quot;Value: \($0)&quot;)
                }
            )
            .store(in: &amp;bag)
    }

    func refresh() {
        changeSubject.send(())
    }

    var networkPublisher: AnyPublisher&lt;String, Error&gt; {
        var url = URLRequest(url: URLComponents(string: &quot;www.google.com&quot;)!.url!)
        url.httpMethod = &quot;GET&quot;
        return URLSession.shared
            .dataTaskPublisher(for: url)
            .tryMap { _ -&gt; String in &quot;Result&quot; }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>To fix this I could use <code>.tryCatch { _ -&gt; Just&lt;String&gt; in Just(&quot;Error&quot;) }</code> to catch the error and that would prevent the publisher from terminating. But why it wouldn't work when publisher terminates? And how can I make work after finish event?</p>
","2543013","","2543013","","2020-10-30 21:12:30","2020-10-30 23:35:39","Swift Combine publisher won't trigger in flatMap after finished event","<swift><combine>","2","1","","2020-11-01 15:42:15","","CC BY-SA 4.0"
"64617423","1","","","2020-10-31 00:53:47","","6","700","<p>Im seeing some memory leaks when using the memory graph debugger in xcode. The Backtrace is not linking directly to any of my code, but guessing by the trace its save to assume that its related to combine and some DataTaskPublisher.</p>
<p><a href=""https://i.stack.imgur.com/e5dDq.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/e5dDq.png"" alt=""enter image description here"" /></a></p>
<p>Next I checked inside Instruments, where I also see some memory leaks. All leaks mention &quot;specialized static UIApplicationDelegate.main()&quot; inside the stack trace, but its not really linking to something that can cause a memory leak.</p>
<p><a href=""https://i.stack.imgur.com/qj26M.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/qj26M.png"" alt=""enter image description here"" /></a></p>
<p>Removing the the ViewModel, that is responsible for loading Data from an API, gets rid of the leaks. The memory graph debugger was showing a dataTaskPublisher, so this kinda makes sense.</p>
<pre><code>import Foundation
import Combine

enum API {
    static func games() -&gt; AnyPublisher&lt;[GameResult], Error&gt; {
        let requestHeaderGames = gamesRequest()
        
        return URLSession.shared.dataTaskPublisher(for: requestHeaderGames)
            .map(\.data)
            .decode(type: [GameResult].self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
    
    private static func gamesRequest() -&gt; URLRequest {
        let url = URL(string: &quot;http://localhost:8080/api/games&quot;)!
        var requestHeader = URLRequest.init(url: url)
        requestHeader.httpBody =
            &quot;filter ...&quot;
            .data(using: .utf8, allowLossyConversion: false)

        requestHeader.httpMethod = &quot;POST&quot;
        requestHeader.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)

        return requestHeader
    }
}

struct GameResult: Decodable, Identifiable, Equatable, Hashable {
    let id: Int
    // ...
}

final class ViewModel: ObservableObject {
    @Published private(set) var games: [GameResult] = []
    
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    
    public func unsubscribe() -&gt; Void {
        subscriptions.forEach {
            $0.cancel()
        }
        subscriptions.removeAll()
    }
    
    func load() -&gt; Void {
        API.games()
            .sink(receiveCompletion: { _ in }, receiveValue: { [weak self] results in
                self?.games = results
            })
            .store(in: &amp;subscriptions)
    }
}
</code></pre>
<p>Im already put much time into figuring out whats causing this leak, but im more confused than anything else. CFString is nothing that im using. Also I cant find out why my code is seemingly causing this leak.
Is there something that im just simply missing, or could someone help me by giving me some advise how to go about this problem?</p>
","12233264","","","","","2020-10-31 03:20:36","Swift Combine - CFString (Storage) memory leak","<swift><memory-leaks><swiftui><combine>","1","1","2","","","CC BY-SA 4.0"
"64628120","1","64628292","","2020-11-01 02:16:38","","3","3594","<p>I'm trying to compose a nested publisher chain in combine with Swift and I'm stumped. My current code starts throwing errors at the .flatMap line, and I don't know why. I've been trying to get it functional but am having no luck.</p>
<p>What I'm trying to accomplish is to download a TrailerVideoResult and decode it, grab the array of TrailerVideo objects, transform that into an array of YouTube urls, and then for each YouTube URL get the LPLinkMetadata. The final publisher should return an array of LPLinkMetadata objects. Everything works correctly up until the LPLinkMetadata part.</p>
<p>EDIT: I have updated the loadTrailerLinks function. I originally forgot to remove some apart of it that was not relevant to this example.</p>
<p>You will need to import &quot;LinkPresentation&quot;. This is an Apple framework for to fetch, provide, and present rich links in your app.</p>
<p>The error &quot;Type of expression is ambiguous without more context&quot; occurs at the very last line (eraseToAnyPublisher).</p>
<pre><code>func loadTrailerLinks() -&gt; AnyPublisher&lt;[LPLinkMetadata], Error&gt;{    
    return URLSession.shared.dataTaskPublisher(for: URL(string: &quot;Doesn't matter&quot;)!)
        .tryMap() { element -&gt; Data in
            guard let httpResponse = element.response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                throw URLError(.badServerResponse)
            }
            return element.data
        }
        .decode(type: TrailerVideoResult.self, decoder: JSONDecoder(.convertFromSnakeCase))
        .compactMap{ $0.results }
        .map{ trailerVideoArray -&gt; [TrailerVideo] in
            let youTubeTrailer = trailerVideoArray.filter({$0.site == &quot;YouTube&quot;})
            return youTubeTrailer
        }
        .map({ youTubeTrailer -&gt; [URL] in
            return youTubeTrailer.compactMap{
                let urlString = &quot;https://www.youtube.com/watch?v=\($0.key)&quot;
                let url = URL(string: urlString)!
                return url
            }
        })
        .flatMap{ urls -&gt; [AnyPublisher&lt;LPLinkMetadata, Never&gt;] in
            return urls.map{ url -&gt; AnyPublisher &lt;LPLinkMetadata, Never&gt; in
                return self.getMetaData(url: url)
                    .map{ metadata -&gt; LPLinkMetadata in
                        return metadata
                    }
                    .eraseToAnyPublisher()
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<pre><code>func fetchMetaData(url: URL) -&gt; AnyPublisher &lt;LPLinkMetadata, Never&gt; {
    return Deferred {
        Future { promise in
            LPMetadataProvider().startFetchingMetadata(for: url) { (metadata, error) in
                promise(Result.success(metadata!))
            }
        }
    }.eraseToAnyPublisher()
}
</code></pre>
<pre><code>struct TrailerVideoResult: Codable {
    let results : [TrailerVideo]
}
</code></pre>
<pre><code>struct TrailerVideo: Codable {
    let key: String
    let site: String
}
</code></pre>
","10830089","","10830089","","2020-11-01 02:33:01","2020-11-01 03:10:21","Swift Combine Nested Publishers","<swift><combine>","2","9","1","","","CC BY-SA 4.0"
"64628393","1","64638634","","2020-11-01 03:22:58","","0","789","<p>I am starting on combine with swift, but having some hard time (had experience working in swiftui before).
So the question is how to perform certain operation:</p>
<ol>
<li>lets say i have vc1. and I go to vc2 from there
2.then i start asynchronos network closure and come back to vc1 (by popping out vc2).</li>
<li>Now say i want to ge just a string from vc2's asycnrhoss clousre to vc1 when i am back to vc1.
how can i achieve this?</li>
</ol>
<p>I want to use publisher of lets say &lt;String, Never&gt;
how can I subscribe in my vc1 and publish or send it from vc2 ?</p>
<p><strong>I am using this approach but its not working, it never comes to code under sink.....</strong></p>
<pre><code>public class Parent {
   public  static let shared = Parent()
   public var publisher = PassthroughSibject&lt;String,Never&gt;()
}

class vc1: ViewController {
   func viewdidLoad() {
     let subscription = Parent.shared.oublisehr.sink { (result) in
     print(result)
     }
  }
  func navigatetoVC1() {
  ///// some code to navigate to vc1
  }

  func button() {
    self.navigatetoVC1
  }

}


class vc2: ViewController {

   func viewDidload() {
   ///
   }
  func performsomeOperation() {
     someasyncoperation(completion: { result in
       switch result {
       case .success:
         //send some data to vc1
         Parent.shared.publisher.send(&quot;testdata&quot;)
       case .failure:
       //send some data to vc1
    })
  self.dismisVC2() //some method to pop out vc2
  } 
</code></pre>
<p>}</p>
","14556604","","","","","2020-11-02 01:14:52","Passing data between controllers using combine not working","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64638418","1","64638555","","2020-11-02 00:37:01","","1","145","<p>I'm new to combine, and trying to figure out how to chain Publishers. I have one publisher that returns a string value that I would like to use to build a URLRequest, which is in turn being passed to a DataTaskPublisher. Any help with the correct syntax would be appreciated!</p>
<p>sample code:</p>
<pre><code>struct ResultObject: Decodable {}

func getValueKey() -&gt; AnyPublisher&lt;String, Error&gt; {
    return Just(&quot;Test&quot;)
        .setFailureType(to: Error.self)
        .eraseToAnyPublisher()
}

func performSearch(_ searchTerm: String) -&gt; AnyPublisher&lt;[ResultObject], Error&gt; {
    return getValueKey().flatMap { valueKey in
        let request: URLRequest = URLRequest(url: URL(string: &quot;http://www.test.com/\(valueKey)&quot;)!)
        return URLSession.shared.dataTaskPublisher(for: request)
            .map { $0.data }
            .decode(type: [ResultObject].self, decoder: JSONDecoder())
    }
    .eraseToAnyPublisher() /* Error: Type of expression is ambiguous without more context */
}
</code></pre>
<p>note: I'm very unsure about the position of the last <code>eraseToAnyPublisher</code></p>
","1561702","","1561702","","2020-11-02 01:06:01","2020-11-02 01:06:01","How do I use the value from one publisher in a request for a dataTaskPublisher in the same chain?","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"64640159","1","","","2020-11-02 05:21:52","","1","358","<p>How to get for example selectedDate from FSCalendar?</p>
<pre><code>struct CalendarController: UIViewControllerRepresentable {
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }
    
    
    func makeUIViewController(context: UIViewControllerRepresentableContext&lt;CalendarController&gt;) 
        -&gt; calendars {
        let calendarViewController = calendars()
        return calendarViewController
    }
    
    func updateUIViewController(_ uiViewController: calendars, context: 
    UIViewControllerRepresentableContext&lt;CalendarController&gt;) {
    }

    
    func updateUIViewController(_ uiViewController: CalendarController, context: 
    UIViewControllerRepresentableContext&lt;CalendarController&gt;) {
    }

    class Coordinator: NSObject {
        var parent: CalendarController
        init(_ calendarViewController: CalendarController) {
            self.parent = calendarViewController
        }
    }
}

class calendars: UIViewController, FSCalendarDelegate, ObservableObject  {
    var calendar = FSCalendar()
    @Published var selectedData : Date?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        calendar.delegate = self
    }

    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        calendar.frame = CGRect(x: 0, y: 0, width: view.frame.size.width, height: 
    view.frame.size.width)
        view.addSubview(calendar)
    }
    
    func calendar(_ calendar: FSCalendar, didSelect date: Date, at monthPosition: 
    FSCalendarMonthPosition)  {
        print(&quot;didSelect date: \(date)&quot;)
        selectedData = date
    }
}

struct CalendarView: View {
  
    var body: some View{
        CalendarController().padding().frame(alignment: .top)
    }
    }


    struct Calendar_Previews: PreviewProvider {
    static var previews: some View {
        CalendarView()
        
    }
}
</code></pre>
<p>Later in another swift view I try to get the date, but it is never changed.
I use the</p>
<pre><code>@ObservedObject var calendarData = calendars()

//...

CalendarView().scaledToFit()
Text(&quot;\(self.calendarData.selectedData ?? Date())&quot;)
</code></pre>
","11834509","","968155","","2020-11-02 05:50:26","2020-11-02 10:10:05","how to use @published and @observed with FSCalendar?","<swiftui><combine><fscalendar>","1","2","1","","","CC BY-SA 4.0"
"64652247","1","","","2020-11-02 19:39:49","","-1","42","<p>Here's the View's Signature:</p>
<p><a href=""https://i.stack.imgur.com/1Q10h.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1Q10h.png"" alt=""enter image description here"" /></a></p>
<p>
Here's the attempt to create a preview:
<p><a href=""https://i.stack.imgur.com/L6BGy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/L6BGy.png"" alt=""enter image description here"" /></a></p>
<p>
I've been trying to satisfy the compiler. <p>
What am I doing wrong?
","715747","","","","","2020-11-02 20:56:53","Preview for a View isn't compiling for Binding<[String]>","<swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"64655133","1","","","2020-11-03 00:23:56","","1","70","<p><strong>Scenario:</strong> <br/></p>
<ol>
<li>Application is tab-based; one tab is a container view having a 'Picker (Data) View'.</li>
<li>Picker View: the Picker is initially loaded with data via @State -&gt; @Binder.</li>
<li>A 'Front Page' (Greetings) View is initially displayed over the Picker View within a ZStack{}.</li>
<li>User Acknowledges the front page which disappears to reveal the Picker View (#2).</li>
</ol>
<p>
<p><strong>Note:</strong> Data is <strong>received</strong> by the Picker per debug check. <br/>
The hidden Picker View shows the initial data.</p>
<p>
<p><strong>Problem:</strong> 
The revealed Picker View <strong>becomes empty</strong>; <em>after dismissing</em> the Front Page/View.</p>
<p>
The following is a debug listing via BreakPoint of data:
<p><a href=""https://i.stack.imgur.com/R43KD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/R43KD.png"" alt=""enter image description here"" /></a></p>
<p>
<p><strong>Observation:</strong> <br/>
I want to access the data source ASAP to populate the Picker View to avoid having the user wait for the data.  Hence the data is initially access prior to revealing the Picker View.</p>
<p>
However, 
the Picker View apparently gets re-rendered just prior to being displayed. 
<br/>
<p><strong>Note:</strong> I see the <strong>populated</strong> picker page if I comment-out the front-page code.</p>
<p>👉 I've added a boolean filter to avoid calling the Picker with an empty data payload.</p>
<p><strong>Question:</strong>
<br/>
How do I make the data more permanent; that is, stay until it is dismissed?</p>
<p>
Do I have to make a concrete copy of a @Binding variable?
","715747","","715747","","2020-11-03 03:08:48","2020-11-03 22:51:45","Picker View data disappears too quickly","<swiftui><picker><combine>","1","2","","","","CC BY-SA 4.0"
"64661345","1","","","2020-11-03 10:48:12","","1","189","<p>Like in a lot of apps, I have a list of items (populated by a Core Data fetch request), a sheet to create new items, and a sheet to edit an item when tapping on a row in my list. I'm trying to unify both forms to create and edit an update, and put the cancel / save logic in a superview of the form.</p>
<p>So I've something like this:</p>
<ul>
<li>ListView: a list with row populated by a Core Data fetch request</li>
<li>AddView: a NavigationView with the FormView embed + cancel and save button</li>
<li>EditView: a NavigationView with the FormView embed + cancel and save button</li>
<li>FormView: a TextField to update the name of the item</li>
</ul>
<p>In the init() for the AddView, I create a new NSManagedObject without any context (I do that because I don't want my ListView to be updated when I create a new item in the AddView, but only when I save this item -&gt; alternative could be to use a child context, or filter the fetch request results based on the isInserted or objectID.isTemporaryID of the return objects). AddView contains a NavigationView with the FormView embed, a cancel button, and a save button. This save button is disabled based on a computed property on the managed object (name for the object can't be nil).</p>
<p>In the EditView, I pass the item that was tapped from the ListView. This item is an existing NSManagedObject attached to the main viewContext of the app (coming from the fetch request of the ListView). EditView contains a NavigationView with the FormView embed, a cancel button and a save button (exactly like the AddView). This save button is also disabled based on the same computed property.</p>
<p>My issue is that when I update the name of the item from the TextField in my FormView, the condition to enable / disable the save button is not working for the AddView (this AddView is actually not refreshed when I change the item name from the FormView) but working for the EditView (this EditView is refreshed when I change the item name from the FormView). If I attach a context to the new NSManagedObject in the init() of the AddView, the condition is working like in the EditView.</p>
<p>So it appears that a NSManagedObject without any context is not observed by SwiftUI? Am I missing anything or is that a bug?</p>
","2681506","","","","","2020-11-03 14:27:13","@StateObject for a NSManagedObject without context not publishing changes","<core-data><combine><swiftui><observedobject>","2","2","","","","CC BY-SA 4.0"
"64661782","1","64662075","","2020-11-03 11:15:20","","1","268","<p>I am really new to Combine and I'm stuck with this issue. I have basic registration form, that returns empty response with 200 code if everything is ok and 442 if form has some registration failures.</p>
<p>That's the code that can handle empty response and works fine</p>
<pre><code>extension Route where ResultType: EmptyResult {
    func emptyResult() -&gt; AnyPublisher&lt;Void, APIError&gt; {
        return URLSession.shared.dataTaskPublisher(for: urlRequest)
            .print(&quot;EMPTY RESULT&quot;)
            .tryMap { data, response in
                guard let httpResponse = response as? HTTPURLResponse else { throw APIError.nonHttpResponse(description: &quot;Not http resp&quot;) }
                let statusCode = httpResponse.statusCode
                
                guard (200..&lt;300).contains(statusCode) else { throw APIError.nonHttpResponse(description: &quot;bad response&quot;)
                }
                    return Void()
            }.mapError { error in
                print(&quot;Error \(error)&quot;)
                return .network(description: error.localizedDescription)
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>However, how I could return publisher with other type? For example</p>
<pre><code>struct CustomError: Decodable {
    let usernameError: String
    let emailError: String
}
</code></pre>
<p>My network call:</p>
<pre><code>    API.registration(name: name, email: email, password: password, schoolID: selectedSchool?.id ?? 0)
        .print(&quot;Registration&quot;)
        .receive(on: DispatchQueue.main)
        .sink(receiveCompletion: { (completion) in
            switch completion {
            case let .failure(error):
                print(&quot;ERROR \(error)&quot;)
            case .finished: break
            }
        }, receiveValue: { value in
            print(value)
        })
        .store(in: &amp;disposables)
</code></pre>
","10064816","","10064816","","2020-11-03 12:47:26","2020-11-03 13:08:02","Combine handle different type of publishers","<swift><networking><combine>","1","2","","","","CC BY-SA 4.0"
"64674464","1","64674679","","2020-11-04 04:58:57","","2","78","<p>I'm studying Combine Scheduler and I have this example code from Raywenderlich book</p>
<pre><code>let queue = OperationQueue()

let subscription = (1...10).publisher
  .receive(on: queue)
  .sink { value in
    print(&quot;Received \(value) on thread \(Thread.current.number)&quot;)
  }

</code></pre>
<p>The book is explaining that OperationQueue uses all available threads so the print order and thread could be random. I understand that part but when I run this code in my playground, I see only 5 numbers out of 10.</p>
<pre><code>Received 1 on thread 7
Received 2 on thread 6
Received 3 on thread 5
Received 7 on thread 9
Received 6 on thread 4
</code></pre>
<p>Why that code doesn't show all 10 numbers??</p>
","10611907","","","","","2020-11-04 11:09:25","print 1 to 10 in OperationQueue don't print whole number","<swift><multithreading><combine><operationqueue>","1","0","","","","CC BY-SA 4.0"
"64675594","1","64682962","","2020-11-04 07:15:11","","1","421","<p>I need to create a generic struct that will hold any decodable type which is returned from the network, so I created something like this:</p>
<pre><code>struct NetworkResponse&lt;Wrapped: Decodable&gt;: Decodable {
    var result: Wrapped
}
</code></pre>
<p>so I can use the decoding method like this:</p>
<pre><code>struct MyModel: Decodable {
  var id: Int
  var name: String
  var details: String
}

func getData&lt;R: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;R, Error&gt;
    URLSession.shared
   .dataTaskPublisher(for: url)
   .map(\.data)
   .decode(type: NetworkResponse&lt;R&gt;.self, decoder: decoder)
   .map(\.result)
   .eraseToAnyPublisher()

//call site
let url = URL(string: &quot;https://my/Api/Url&quot;)!
let models: [MyModel] = getData(url: url)
  .sink {
   //handle value here
}
</code></pre>
<p>But, I noticed that some responses from the network contains the <code>result</code> key, and some others do not:</p>
<p>with result:</p>
<pre><code>{
&quot;result&quot;: { [ &quot;id&quot;: 2, &quot;name&quot;: &quot;some name&quot;, &quot;details&quot;: &quot;some details&quot;] }
}
</code></pre>
<p>without result:</p>
<pre><code>[ &quot;id&quot;: 2, &quot;name&quot;: &quot;some name&quot;, &quot;details&quot;: &quot;some details&quot; ]
</code></pre>
<p>this results in the following error from the <code>.map(\.result)</code> publisher because it can't find the <code>result</code> key in the returned json:</p>
<p><code>(typeMismatch(Swift.Dictionary&lt;Swift.String, Any&gt;, Swift.DecodingError.Context(codingPath: [], debugDescription: &quot;Expected to decode Dictionary&lt;String, Any&gt; but found an array instead.&quot;, underlyingError: nil)))</code></p>
<p>How can I handle either case in the <code>NetworkResponse</code> struct in order to avoid such error?</p>
","1056118","","1056118","","2020-11-04 10:09:09","2020-11-04 15:56:10","Decoding a generic decodable type","<swift><codable><combine><decodable>","1","2","1","","","CC BY-SA 4.0"
"64684769","1","","","2020-11-04 17:17:25","","0","370","<pre><code>class Room: ObservableObject { ... }

Contact: ObservableObject {
    var chatRoom: Room
}

class Account: ObservableObject {

    var rooms: Room { … }

    var contacts: [Contact] {
        return rooms.map {
            Contact(chatRoom: $0)
        }
     }

    func listenForRoomEvents() {
        // Called on instantiation of a Room, this fires self.objectWillChange on room updates and is working properly
    }
}

struct RoomView: View {
    @ObservedObject var room: Room
}
</code></pre>
<p>/
THIS IS WORKING
/</p>
<pre><code>struct ParentView: View {
    @EnvironmentObject account: Account

    var body: some View {
        RoomsView(account.rooms)
        .onAppear {
            self.account.listenForRoomEvents()
        }
    }
}

struct RoomsView: View {
    var rooms: [Room]

    var body: some View {
        ForEach(rooms) { room in
            NavigationLink(destination: RoomView(room: room)) {
                RoomListItemView(room: room)
            }
        }
    }
}
</code></pre>
<p>/
THIS IS NOT WORKING
/</p>
<pre><code>struct ParentView: View {
    @EnvironmentObject account: Account

    var body: some View {
        Child1(contacts: account.contacts)
        .onAppear {
            self.account.listenForRoomEvents()
        }
    }
}

struct Child1: View {
    @State var selectedContact: Contact?
    var contacts: [Contact]
    
    var body: some View {
        RoomView(selectedContact.chatRoom) 
        UserSelectorView(contacts: contacts, selectedUser: $selectedContact) // View allowing selection of a user
    }
}
</code></pre>
<p>I outlined my setup above; basically, I am instantiating a RoomView object with a Room instance containing all the chat events and other details. Child1 holds a selected contact state variable which is bound to two of its own subviews, one of which allows for the user to select a different contact and such.</p>
<p>What does not make sense to me is that the RoomView renders just fine with all it's events, but in the second solution I have it does not update when new messages come in or when one should be displayed after sending, for instance. I am passing a reference to the same Room object to it, but cannot for the life of me get it to update properly like it does in the first solution.</p>
<p>When I select a new user and go back to the previous one, the messages are all updated as expected.</p>
<p>Here is what I have tried so far:</p>
<ul>
<li>Making Contact.chatRoom a Published variable, and then calling self.objectWillChange.send() whenever chatRoom does</li>
</ul>
","4537802","","4537802","","2020-11-04 18:19:53","2020-11-05 17:53:20","SwiftUI ObservedObject not updating in View","<swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"64685325","1","","","2020-11-04 17:57:59","","2","1534","<p>This is a slightly more abstract version of <a href=""https://stackoverflow.com/questions/58406287/how-to-tell-swiftui-views-to-bind-to-nested-observableobjects"">this question</a>. In the app, these nested Observable Objects are indeed used in a view (so I'd rather use Observable Objects rather than straight Publishers). However, I would like to be able to simply subscribe to the view models in order to test them. The protocol is there so I can mock out Nested in tests.</p>
<p>This is the basic setup:</p>
<pre><code>protocol NestedProtocol: AnyObject {
  var string: String { get set }
}
class Nested: ObservableObject, NestedProtocol {
  @Published var string = &quot;&quot;
}
class Parent: ObservableObject {
  @Published var nested: NestedProtocol
  init(nested: NestedProtocol) {
    self.nested = nested
  }
}

var sinkHole = Set&lt;AnyCancellable&gt;()
let nested = Nested()
let parent = Parent(nested: nested)

parent.$nested.sink { newValue in
  print(&quot;NEW VALUE \(newValue.string)&quot;)
}.store(in: &amp;sinkHole)
</code></pre>
<p>Then this command
<code>nested.string = &quot;foo1&quot;</code> outputs &quot;NEW VALUE &quot;, which is expected as the initial value of <code>nested</code>. I would like it to output &quot;NEW VALUE foo1&quot;. (TIL published variables seem to be current value publishers.)</p>
<ol>
<li>Of course I could do</li>
</ol>
<pre><code>nested.string = &quot;foo1&quot;
parent.nested = nested
</code></pre>
<p>and I would get &quot;NEW VALUE foo1&quot;, but that's smelly.</p>
<ol start=""2"">
<li>I tried</li>
</ol>
<pre><code>protocol NestedProtocol: ObservableObject {
  var string: String { get set }
}
class Nested&lt;T&gt;: ObservableObject where T: NestedProtocol {
...

</code></pre>
<p>But in real life, I would like nested to declare some static constants, which is not allowed in generic types. So that doesn't work.</p>
<ol start=""3"">
<li>From the cited question/answer, I also tried combinations of</li>
</ol>
<pre><code>Parent
init() {
  nested.objectWillChange.sink { [weak self] (_) in
    self?.objectWillChange.send()
  }.store(in: sinkHole)
}

Nested
init() {
  string.sink { [weak self] (_) in
    self?.objectWillChange.send()
  }.store(in: sinkHole)
}
</code></pre>
<p>No dice. Those methods were getting called but that outer-level sink was still just returning &quot;NEW VALUE &quot;</p>
<ol start=""4"">
<li>I also tried calling</li>
</ol>
<pre><code>parent.nested.string = &quot;foo1&quot;
</code></pre>
<p>So now I'm modifying the parent, and that should work, right? Wrong.</p>
","1431615","","1431615","","2020-11-04 20:51:07","2020-11-04 23:24:15","Swift Combine - How to subscribe to nested Observable Objects","<swift><observable><combine>","2","5","","","","CC BY-SA 4.0"
"64685876","1","64687284","","2020-11-04 18:39:26","","1","527","<p>I have a <code>UIViewController</code> which using <code>UITableViewDiffableDataSource</code>. I have a view-model for this controller which looks something like:</p>
<pre><code>class ListViewModel {
    @Published private(set) var items: [Item] = []
    
    func load(params: [String: Any] = [:]) {
        WebRepo().index(params: params, completion: { [weak self] (items, error) in
            self?.items = items
        })
    }
    
    func deleteFirst() {
        self.items.remove(object: self.items.first)
    }
}
</code></pre>
<p>In my VC, I have a binding like:</p>
<pre><code>self.viewModel.$items.sink { [weak self] (scenes) in
    self?.update(items: items, animated: false)
}.store(in: &amp;self.subscriptions)
</code></pre>
<p>So, when I'm calling my view-model's <code>load</code> method - I want to do <code>self?.update(items: items, animated: false)</code>, but when I'm calling <code>deleteFirst</code> - I want <code>self?.update(items: items, animated: true)</code>.</p>
<p>I'm quite new to reactive and Combine, so not sure what is the proper way to handle this.
I can add <code>isReset</code> property to my view-model and change <code>load</code> method to something like:</p>
<pre><code>    func load(params: [String: Any] = [:]) {
        WebRepo().index(params: params, completion: { [weak self] (items, error) in
            self?.isReset = true
            self?.items = items
            self?.isReset = false
        })
    }
</code></pre>
<p>And inside <code>sink</code> just check this property, but it does not look as a proper way for me.</p>
","1246675","","","","","2020-11-04 20:42:22","Swift Combine two handlers for one property","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"64690518","1","64690738","","2020-11-05 02:48:23","","2","820","<p>I'm writing a Mock service to test login in a SwiftUI MVVM project. In my ViewModel:</p>
<pre><code>  func login() {
    self.cancellable = service.login(email: email, password: password)
      .sink(receiveCompletion: { [weak self] completion in
        switch completion {
          case .finished:
            break
          case .failure(let error):
            if let session = self?.session {
              session.currentUser = nil
            }
            print(error.localizedDescription)
        }
      }, receiveValue: { user in
        if let session = self.session {
          session.currentUser = user
        } 
      })
  }
</code></pre>
<p>My mock service code:</p>
<pre><code>func login(email: String, password: String) -&gt; AnyPublisher&lt;User, Error&gt; {
    
    let user = User(name: &quot;test&quot;, email: email, password: password)
    if email.lowercased() == &quot;test@mail.com&quot; &amp;&amp; password == &quot;Password!23&quot; {
      return Just(user)
        .setFailureType(to: Error.self)
        .eraseToAnyPublisher()
    } else {
      // ??? How to generate a failure here
    }
  }
</code></pre>
<p>My question is how to generate an error (failure) in my code? I only found some code sample regarding with error handling. But can't find how to generate an error in publisher.</p>
","118562","","","","","2020-11-05 03:19:45","Method to generate error (failure) for a SwiftUI Combine publisher","<ios><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64691746","1","64691942","","2020-11-05 05:37:15","","1","144","<p>How do I peer into the data portion of this publisher? <br/>
I want to decipher the data (via <strong>String(bytes: data, encoding: .utf8)</strong>) during debug.</p>
<pre><code>func getList&lt;Resource&gt;(urlDataModel: Resource) where Resource: URLResource {
        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: urlDataModel.url!)
            .map(\.data)
            .receive(on: DispatchQueue.main)
            .decode(type: Resource.DataModel.self, decoder: JSONDecoder())
            .print(&quot;getList: &quot;)
</code></pre>
","715747","","715747","","2020-11-05 06:47:52","2020-11-05 06:47:52","Debugging: How do I observe a publisher's data?","<ios><debugging><combine>","1","2","","","","CC BY-SA 4.0"
"64697969","1","64699777","","2020-11-05 13:13:50","","1","3083","<p>in my view controller I have a property <code>items</code> to which I have a subscription and rendering my view.</p>
<p>For this view controller I have a view model where I have load method like:</p>
<pre><code>    @Published private(set) var items: [Item] = []

    func load(params: [String: Any] = [:]) {
        self.isLoading = true
        
        self.subscription = WebRepo().index(params: params).sink(receiveCompletion: { [weak self] (completion) in
            switch completion {
            case .failure(let error):
                print(&quot;Error is: \(error.localizedDescription)&quot;)
            default: break
            }
            self?.isLoading = false
        }, receiveValue: { [weak self] (response) in
            self?.items = response.data
        })
    }
</code></pre>
<p>and my <code>WebRepo</code> looks like:</p>
<pre><code>final class WebRepo {
    func index(params: [String: Any]) -&gt; AnyPublisher&lt;MyResponse&lt;[Item]&gt;, Error&gt; {
        let url = URL(...)
        return AF.request(url, method: .get, parameters: params)
        .publishDecodable(type: MyResponse&lt;[Item]&gt;.self)
        .tryCompactMap { (response) -&gt; MyResponse&lt;[Item]&gt;? in
            if let error = response.error { throw error }
            return response.value
        }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p>My user can load multiple times and as you can see It will subscribe each time when <code>load</code> method is called, which I think should not be like this.</p>
<p>I tried to introduce property for my view model:</p>
<pre><code>private var indexResponse: AnyPublisher&lt;MyResponse&lt;[Item]&gt;, Error&gt;?

//And my load becomes

func load(params: [String: Any] = [:]) {
   self.isLoading = true
   self.indexResponse = WebRepo().index(params: params)
}
</code></pre>
<p>But in this case I can't make initial binding since initial value is <code>nil</code> hence it won't subscribe.</p>
<p>Another question is about handling error from load, do I need to have property for <code>error</code> inside view model or is there way I can rethrow an error for <code>$items</code>?</p>
","1246675","","","","","2020-11-08 13:46:36","Alamofire + Combine + MVVM request example","<ios><swift><alamofire><combine>","1","0","","","","CC BY-SA 4.0"
"64704817","1","","","2020-11-05 20:28:43","","0","72","<p><strong>Scenario:</strong> I've created a data-source engine that returns data of
<em>various formats</em> (depending on context) using <strong>Any</strong> as the return
type.</p>
<p>
 Here's the subscriber from remoteDataPublisher:<p>
<pre><code>   remoteDataPublisher
        .eraseToAnyPublisher()
        .sink(receiveCompletion: { completion in
            switch completion {
            case .finished:
                print(&quot;Publisher Finished&quot;)
            case let .failure(anError):
                Swift.print(&quot;\nReceived error: &quot;, anError)
            }
        }, receiveValue: { [self] someValue in
            DataSource.shared.rawData = someValue
        }).store(in: &amp;cancellables)
</code></pre>
<p>
<p>Here's the receiving DataSource:</p>
<pre><code>final class DataSource {
    ...

    static let shared = DataSource()
    ...
    var rawData: Any?
    ...
}
</code></pre>
<p>
Being that the data comes from many sources, depending of the context, the type is <b>Any</b>. 
<br/>
In this case, the data type is:
<pre><code>struct AppleSubRegions: Codable {
    let country, subregion: String
    let data: [AppleDatum]
}
</code></pre>
<p>
<pre><code>(lldb) po DataSource.shared.rawData!
▿ AppleSubRegions
  - country : &quot;Canada&quot;
  ▿ subregions : 20 elements
    - 0 : &quot;Alberta&quot;
    - 1 : &quot;Calgary&quot;
    - 2 : &quot;Edmonton&quot;
    - 3 : &quot;British Columbia&quot;
    - 4 : &quot;Vancouver&quot;
    - 5 : &quot;Manitoba&quot;
    - 6 : &quot;New Brunswick&quot;
    - 7 : &quot;Newfoundland and Labrador&quot;
    - 8 : &quot;Northwest Territories&quot;
    - 9 : &quot;Halifax&quot;
    - 10 : &quot;Nova Scotia&quot;
    - 11 : &quot;Ontario&quot;
    - 12 : &quot;Ottawa&quot;
    - 13 : &quot;Toronto&quot;
    - 14 : &quot;Prince Edward Island&quot;
    - 15 : &quot;Montreal&quot;
    - 16 : &quot;Quebec&quot;
    - 17 : &quot;Saskatchewan&quot;
    - 18 : &quot;All&quot;
    - 19 : &quot;Yukon Territory&quot;
</code></pre>
<p>
<p><strong>Goal:</strong> I want convert this '<strong>Any</strong>' data type <em>back into a the usable</em> '<strong>AppleSubRegions</strong>' type; ditto with other respective types {e.g., '[String]', etc.); depending on the context,</p>
<p>
Here's the raw output on console:
<pre><code>{&quot;country&quot;:&quot;Canada&quot;,&quot;subregions&quot;:[&quot;Alberta&quot;,&quot;Calgary&quot;,&quot;Edmonton&quot;,&quot;British Columbia&quot;,&quot;Vancouver&quot;,&quot;Manitoba&quot;,&quot;New Brunswick&quot;,&quot;Newfoundland and Labrador&quot;,&quot;Northwest Territories&quot;,&quot;Halifax&quot;,&quot;Nova Scotia&quot;,&quot;Ontario&quot;,&quot;Ottawa&quot;,&quot;Toronto&quot;,&quot;Prince Edward Island&quot;,&quot;Montreal&quot;,&quot;Quebec&quot;,&quot;Saskatchewan&quot;,&quot;All&quot;,&quot;Yukon Territory&quot;]}

(lldb) po type(of: DataSource.shared.rawData)
Swift.Optional&lt;Any&gt;
</code></pre>
<p>
I've tried to cast the 'Any' back into the Struct and failed:
<pre><code>(lldb) po DataSource.shared.rawData as AppleSubRegions
Fatal error: Unexpectedly found nil while unwrapping an Optional value: file __lldb_expr_50/&lt;EXPR&gt;, line 6
2020-11-05 12:21:44.108408-0800 Covid19[68513:2486483] Fatal error: Unexpectedly found nil while unwrapping an Optional value: file __lldb_expr_50/&lt;EXPR&gt;, line 6
</code></pre>
<p>
<p><strong>Question:</strong> How can I get the iOS objects back in their native types?</p>
","715747","","715747","","2020-11-05 20:36:24","2020-11-06 00:14:47","How do I convert raw data of type 'Any' into a concrete type?","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"64714131","1","","","2020-11-06 11:49:43","","0","307","<p>So, I have this sequence of API calls, where I fetch a employee details, then fetch the company and project details that the employee is associated with. After both fetching are complete, I combine both and publish a fetchCompleted event. I've isolated the relevant code below.</p>
<pre><code>func getUserDetails() -&gt; AnyPublisher&lt;UserDetails, Error&gt;
func getCompanyDetails(user: UserDetails) -&gt; AnyPublisher&lt;CompanyDetails, Error&gt;
func getProjectDetails(user: UserDetails) -&gt; AnyPublisher&lt;ProjectDetails, Error&gt;
</code></pre>
<p>If I do this,</p>
<pre><code>func getCompleteUserDetails() -&gt; AnyPublisher&lt;UserFetchState, Never&gt; {

  let cvs = CurrentValueSubject&lt;UserFetchState, Error&gt;(.initial)

  let companyPublisher = getUserDetails()
    .flatMap { getCompanyDetails($0) }
  let projectPublisher = getUserDetails()
    .flatMap { getProjectDetails($0) }
  
  companyPublisher.combineLatest(projectPublisher)
    .sink { cvs.send(.fetchComplete) }
  return cvs.eraseToAnyPublisher()
}
</code></pre>
<p>getUserDetails() will get called twice. What I need is fetch the userDetails once and with that, branch the stream into two, map it to fetch the company details and project details and re-combine both.
Is there a elegant(flatter) way to do the following.</p>
<pre><code>func getCompleteUserDetails() -&gt; AnyPublisher&lt;UserFetchState, Never&gt; {

  let cvs = CurrentValueSubject&lt;UserFetchState, Error&gt;(.initial)

    getUserDetails()
      .sink {
        let companyPublisher = getCompanyDetails($0)
        let projectPublisher = getProjectDetails($0)
        
        companyPublisher.combineLatest(projectPublisher)
          .sink { cvs.send(.fetchComplete) }
      }
  return cvs.eraseToAnyPublisher()
}
</code></pre>
","3970488","","","","","2020-11-06 15:10:59","How can I branch out multiple API calls from the result of one API call and collect them after all are finished with Combine?","<ios><swift><combine>","2","7","","","","CC BY-SA 4.0"
"64724312","1","","","2020-11-07 04:05:56","","-1","145","<p><strong>Scenario:</strong> <br/>
A function takes a generic parameter (<strong>CovidResource</strong>) to grab data from a server which returns a data in a particular format depending on the value of the function's parameter, <strong>CovidResource</strong>.</p>
<p>
The intent is to use one (1) function to grab data from assorted endpoints in a format/endpoint.
<p>The function returns a struct <strong>AppleSubRegions</strong> (in this example, one of any possible data types via generic value) in <strong>CovidResource</strong> format.</p>
<p>
<pre><code> let url = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/CANADA&quot;)!
        countryListViewModel.getList(urlDataModel: CovidResource&lt;AppleSubRegions&gt;(url: url))
</code></pre>
<p>
<pre><code>struct AppleSubRegions: Codable {
    let country, subregion: String
    let data: [AppleDatum]
}
</code></pre>
<p>
<pre><code>import Combine
import UIKit

protocol URLResource {
    associatedtype DataModel: Decodable
    var url: URL? { get }
}

struct CovidResource&lt;T: Decodable&gt;: URLResource {
    typealias DataModel = T
    var url = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/Canada&quot;)
}

// =====================================================================================================

class CountryRegionListModel: ObservableObject {
    @Published var countryRegionList: [String] = []

    // Data Persistence:
    var cancellables: Set&lt;AnyCancellable&gt; = []

    // ---------------------------------------------------------------------------

    func getList&lt;Resource&gt;(urlDataModel: Resource) where Resource: URLResource {
        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: urlDataModel.url!)
            .map(\.data)
            .handleEvents(receiveOutput: { data in
                print(String(data: data, encoding: .utf8)!)
              })
            .receive(on: DispatchQueue.main)
            .decode(type: Resource.DataModel.self, decoder: JSONDecoder())
        
            //.print(&quot;getList: &quot;)
        
        remoteDataPublisher
            .eraseToAnyPublisher()
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    print(&quot;Publisher Finished&quot;)
                case let .failure(anError):
                    Swift.print(&quot;\nReceived error: &quot;, anError)
                }
            }, receiveValue: { someValue in
                print(&quot;\n\n ---- Model: \(someValue)&quot;)
                DataSource.shared.countryName = (someValue as! AppleSubRegions).country
               
            }).store(in: &amp;cancellables)
    }
}
</code></pre>
<p>
<p>You can see the datatype returned is '<strong>AppleSubRegions</strong>':<br/>
(Notice the '<b>unknown context</b>...)?</p>
<p>
<pre><code>(lldb) po type(of: someValue)
Covid19.TabNavView.(unknown context at $10bb96490).(unknown context at $10bb96504).AppleSubRegions
</code></pre>
<p>
<p>I can see the country, '<strong>Canada</strong>' via the debugger:</p>
<pre><code>---- Model: AppleSubRegions(country: &quot;Canada&quot;, subregions: [&quot;Alberta&quot;, &quot;Calgary&quot;, &quot;Edmonton&quot;, &quot;British Columbia&quot;, &quot;Vancouver&quot;, &quot;Manitoba&quot;, &quot;New Brunswick&quot;, &quot;Newfoundland and Labrador&quot;, &quot;Northwest Territories&quot;, &quot;Halifax&quot;, &quot;Nova Scotia&quot;, &quot;Ontario&quot;, &quot;Ottawa&quot;, &quot;Toronto&quot;, &quot;Prince Edward Island&quot;, &quot;Montreal&quot;, &quot;Quebec&quot;, &quot;Saskatchewan&quot;, &quot;All&quot;, &quot;Yukon Territory&quot;])
(lldb) po someValue.country
&quot;Canada&quot;
</code></pre>
<p>I tried repeating what I did via the debugger in code:</p>
<p><a href=""https://i.stack.imgur.com/edbrp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/edbrp.png"" alt=""enter image description here"" /></a></p>
<p>... but as you can see, the <strong>DataModel</strong> isn't aware of '<strong>country</strong>':</p>
<p>
Yet I can't access its members.
<p>So I tried to cast 'someValue' to <strong>AppleSubRegions</strong> type:</p>
<p><a href=""https://i.stack.imgur.com/J6Dd4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/J6Dd4.png"" alt=""enter image description here"" /></a></p>
<p>Which crashed the compile.</p>
<p><strong>Question:</strong> How do I convert the <strong>CovidResource</strong> into <strong>AppleSubRegions</strong> proper (Swift data item)?</p>
<hr>
<b>Suggestions tried:</b> <br/>
1. Qualifying closure with 
<pre><code>...receiveValue { someValue: AppleSubRegions in
</code></pre>
<p>But I got a compiler syntax error: <br/></p>
<p><a href=""https://i.stack.imgur.com/rKW6K.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rKW6K.png"" alt=""enter image description here"" /></a></p>
<ol start=""2"">
<li>Adding an additional constraint: <br/></li>
</ol>
<p><a href=""https://i.stack.imgur.com/z3snc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/z3snc.png"" alt=""enter image description here"" /></a></p>
<p>But this causes another compiler error:</p>
<p><a href=""https://i.stack.imgur.com/blXe5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/blXe5.png"" alt=""enter image description here"" /></a></p>
","715747","","715747","","2020-11-07 18:45:18","2020-11-08 02:18:33","How do I resolve: Unable to Cast due to 'Unknown Context'?","<swift><generics><combine>","1","3","","","","CC BY-SA 4.0"
"64747566","1","","","2020-11-09 07:46:14","","2","107","<p>I am trying a very simple test to just combine a simple Just(&quot;JustValue&quot;) to a property.
But it did not work.<br />
↓ This is my code</p>
<pre><code>struct ResponseView: View {
    
    private var contentCancellable: AnyCancellable? = nil
    @State var content: String = &quot;InitialValue&quot;
    
    var body: some View {
        Text(content)
    }

    init() {
        contentCancellable = Just(&quot;JustValue&quot;).assign(to: \.content, on: self)
    }
}
</code></pre>
<p>Is there anyone know why the Text shows <code>&quot;InitialValue&quot;</code> instead <code>&quot;JustValue&quot;</code></p>
","8287098","","","","","2020-11-09 08:04:32","SwiftUI Combine Why can't bind data in init?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64764202","1","","","2020-11-10 06:57:55","","1","693","<p>I am trying to switch my app to use a Combine pipeline. My hope was to simplify thread management, yet got myself into an unexpected behavior of Combine.</p>
<p>I assumed that despite the fact I am subscribing on DispatchQueue.global(), canceling the main pipeline would cancel the nested subscription.</p>
<p>Here is my playground:</p>
<pre class=""lang-swift prettyprint-override""><code>import Cocoa
import Combine

let folders = [&quot;folder1&quot;, &quot;folder2&quot;, &quot;folder3&quot;, &quot;folder4&quot;]

class OneByOnePublisher: Publisher {
    typealias Output = String
    typealias Failure = Never
    
    let input: [String]
    init(input: [String]) {
        self.input = input
    }
  
    func receive&lt;Downstream: Subscriber&gt;(subscriber: Downstream) where Downstream.Input == Output, Downstream.Failure == Failure {
        let subject = PassthroughSubject&lt;String, Never&gt;()
        subject.receive(subscriber: subscriber)
        for value in input {
            subject.send(value)
        }
        subject.send(completion: .finished)
    }
}

func uppercase(_ character: Character) -&gt; String {
    print(&quot;Uppercasing \(character)&quot;)
    Thread.sleep(forTimeInterval: 0.5)
    return character.uppercased()
}

func uppercasePublisher(_ folder: String) -&gt; AnyPublisher&lt;String, Never&gt; {
    return folder.publisher
//        .handleEvents(receiveCancel: { print(&quot;Received cancel in nested&quot;) })
        .map{uppercase($0)}
        .collect()
        .map{$0.joined()}
        .eraseToAnyPublisher()
}


let stringPublisher = PassthroughSubject&lt;String, Never&gt;()
let oneByOnePublisher = OneByOnePublisher(input: folders)


let cancelable = oneByOnePublisher
    .subscribe(on: DispatchQueue.global())
    .handleEvents(receiveCancel: { print(&quot;Received cancel in main&quot;) })
    .flatMap{uppercasePublisher($0)}
    .receive(on: DispatchQueue.main)
    .sink { (completion) in
        print(&quot;Received completion: \(completion)&quot;)
    } receiveValue: { (value) in
        print(&quot;Received value: \(value)&quot;)
    }

Thread.sleep(forTimeInterval: 2)
cancelable.cancel()
Thread.sleep(forTimeInterval: 2)
print(&quot;Done&quot;)
</code></pre>
<p>The output of that</p>
<pre><code>Uppercasing f
Uppercasing o
Uppercasing l
Uppercasing d
Received cancel in main
Uppercasing e
Uppercasing r
Uppercasing 1
Done

</code></pre>
<p>However, if I uncomment the line with</p>
<pre><code>//        .handleEvents(receiveCancel: { print(&quot;Received cancel in nested&quot;) })
</code></pre>
<p>Then the output is what I would expect in the first place</p>
<pre><code>Uppercasing f
Uppercasing o
Uppercasing l
Uppercasing d
Received cancel in nested
Received cancel in main
Done
</code></pre>
<p>What am I missing? Why in the first case the nested subscription doesn't get immediately canceled? Why does adding handleEvents() changes the cancelation flow?</p>
","14610630","","","","","2020-11-19 10:30:45","Cancel a nested Combine publisher","<swift><combine>","1","7","","","","CC BY-SA 4.0"
"64764290","1","","","2020-11-10 07:05:40","","2","676","<p>I have recently started to dig into the wonderful world of SwiftUI, Combine, and property wrappers and am struggling to combine @ObservedObject with the @Injected property wrapper I wrote to inject dependencies into my views. Most of the time my @Injected wrapper works fine, but when paired with @ObservedObject to manage my viewmodels I received &quot;Property type does not match that of the 'wrappedValue' property&quot; errors.&quot;</p>
<p>Here's currently what my @Injected property wrapper looks like:</p>
<pre><code>@propertyWrapper
public struct Injected&lt;Service&gt; {

    private var service: Service

    public init() {
        self.service = assembler.resolver.resolve(Service.self)!
    }

    public init(name: String? = nil, container: Resolver? = nil) {
        // `assembler` here referring to my global Swinject assembler
        self.service = container?.resolve(Service.self, name: name) ??
            assembler.resolver.resolve(Service.self, name: name)!
    }

    public var wrappedValue: Service {
        get {
            return service
        }

        mutating set {
            service = newValue
        }
    }

    public var projectedValue: Injected&lt;Service&gt; {
        get {
            return self
        }

        mutating set {
            self = newValue
        }
    }
}
</code></pre>
<p>And here is my current usage:</p>
<pre><code>struct MyModalView: View {
    
    @ObservedObject @Injected var viewModel: MyModalViewModel
    
    var body: some View {
        Text(&quot;Hello World&quot;)
    }
}
</code></pre>
<p>Ordering the wrappers in this way, I receive: &quot;Property type 'MyModalViewModel' does not match that of the 'wrappedValue' property of its wrapper type 'ObservedObject'&quot;, while the MyModalViewModel class does extend from ObservableObject.</p>
<p>If I flip the wrappers around, it compiles, but Swinject tries to resolve a wrapped ObservedObject class, and because the container is just registering the original MyModalViewModel class, this resolution fails and the app crashes.</p>
<p>Meanwhile, assigning the @ObservedObject value through direct assignment works:</p>
<pre><code>@ObservedObject var viewModel: MyModalViewModel = assembler.resolver.resolve(MyModalViewModel.self)!
</code></pre>
<p>I would think the original code should compile, seeing @Injected will return a wrapped value that conforms to ObservableObject, like @ObservedObject expects, though all of this is still fairly new to me so there might be something I'm missing. Any input here would be greatly appreciated. Thanks!!</p>
","2466941","","","","","2021-11-23 21:44:20","Is it possible to nest property wrappers in Swift when using @ObservedObject?","<swift><swiftui><combine><property-wrapper>","2","3","","","","CC BY-SA 4.0"
"64770553","1","64824011","","2020-11-10 14:12:22","","0","116","<p>I'm new to SwiftUI and manual camera functionality, and I really need help.</p>
<p>So I trying to build a SwiftUI camera view that has a UIKit camera as a wrapper to control the focus lens position via SwiftUI picker view, display below a fucus value, and want to try have a correlation between AVcaptureDevice.lensPosition from 0 to 1.0 and feats that are displayed in the focus picker view. But for now, I only want to display that fucus number on screen.</p>
<p>And the problem is when I try to update focus via coordinator focus observation and set it to the camera view model then nothing happened. Please help 🙌</p>
<p>Here's the code:</p>
<pre><code>import SwiftUI
import AVFoundation
import Combine

struct ContentView: View {
    
    @State private var didTapCapture = false
    @State private var focusLensPosition: Float = 0
    @ObservedObject var cameraViewModel = CameraViewModel(focusLensPosition: 0)
    
    var body: some View {
        
        VStack {
            ZStack {
                CameraPreviewRepresentable(didTapCapture: $didTapCapture, cameraViewModel: cameraViewModel)
                    .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .center)
                
                VStack {
                    FocusPicker(selectedFocus: $focusLensPosition)
                    
                    Text(String(cameraViewModel.focusLensPosition))
                        .foregroundColor(.red)
                        .font(.largeTitle)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
            }
            .edgesIgnoringSafeArea(.all)
            
            Spacer()
            
            CaptureButton(didTapCapture: $didTapCapture)
                .frame(width: 100, height: 100, alignment: .center)
                .padding(.bottom, 20)
        }
        
        
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

struct CaptureButton: View {
    @Binding var didTapCapture : Bool
    
    var body: some View {
        Button {
            didTapCapture.toggle()
            
        } label: {
            Image(systemName: &quot;photo&quot;)
                .font(.largeTitle)
                .padding(30)
                .background(Color.red)
                .foregroundColor(.white)
                .clipShape(Circle())
                .overlay(
                    Circle()
                        .stroke(Color.red)
                )
        }
    }
}

struct CameraPreviewRepresentable: UIViewControllerRepresentable {
    
    @Environment(\.presentationMode) var presentationMode
    @Binding var didTapCapture: Bool
    @ObservedObject var cameraViewModel: CameraViewModel
    
    let cameraController: CustomCameraController = CustomCameraController()
    
    func makeUIViewController(context: Context) -&gt; CustomCameraController {
        cameraController.delegate = context.coordinator
        
        return cameraController
    }
    
    func updateUIViewController(_ cameraViewController: CustomCameraController, context: Context) {
        
        if (self.didTapCapture) {
            cameraViewController.didTapRecord()
        }
    }
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self, cameraViewModel: cameraViewModel)
    }
    
    class Coordinator: NSObject, UINavigationControllerDelegate, AVCapturePhotoCaptureDelegate {
        let parent: CameraPreviewRepresentable
        var cameraViewModel: CameraViewModel
        
        var focusLensPositionObserver: NSKeyValueObservation?
        
        init(_ parent: CameraPreviewRepresentable, cameraViewModel: CameraViewModel) {
            self.parent = parent
            self.cameraViewModel = cameraViewModel
            super.init()
            
            focusLensPositionObserver = self.parent.cameraController.currentCamera?.observe(\.lensPosition, options: [.new]) { [weak self] camera, _ in

                print(Float(camera.lensPosition))
                
                //announcing changes via Publisher
                self?.cameraViewModel.focusLensPosition = camera.lensPosition
            }
        }
        
        deinit {
            focusLensPositionObserver = nil
        }
        
        func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
            
            parent.didTapCapture = false
            
            if let imageData = photo.fileDataRepresentation(), let image = UIImage(data: imageData) {
                UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
            }
            
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

class CameraViewModel: ObservableObject {
    @Published var focusLensPosition: Float = 0

    init(focusLensPosition: Float) {
        self.focusLensPosition = focusLensPosition
    }
}

class CustomCameraController: UIViewController {
    
    var image: UIImage?
    
    var captureSession = AVCaptureSession()
    var backCamera: AVCaptureDevice?
    var frontCamera: AVCaptureDevice?
    var currentCamera: AVCaptureDevice?
    var photoOutput: AVCapturePhotoOutput?
    var cameraPreviewLayer: AVCaptureVideoPreviewLayer?
    
    //DELEGATE
    var delegate: AVCapturePhotoCaptureDelegate?
    
    func showFocusLensPosition() -&gt; Float {
//        guard let camera = currentCamera else { return 0 }
        
//        try! currentCamera!.lockForConfiguration()
//        currentCamera!.focusMode = .autoFocus
////        currentCamera!.setFocusModeLocked(lensPosition: currentCamera!.lensPosition, completionHandler: nil)
//        currentCamera!.unlockForConfiguration()
        
        return currentCamera!.lensPosition
    }
    
    func didTapRecord() {
        
        let settings = AVCapturePhotoSettings()
        photoOutput?.capturePhoto(with: settings, delegate: delegate!)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setup()
    }
    
    func setup() {
        
        setupCaptureSession()
        setupDevice()
        setupInputOutput()
        setupPreviewLayer()
        startRunningCaptureSession()
    }
    
    func setupCaptureSession() {
        captureSession.sessionPreset = .photo
    }
    
    func setupDevice() {
        let deviceDiscoverySession =
            AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInWideAngleCamera],
                                                                      mediaType: .video,
                                                                      position: .unspecified)
        for device in deviceDiscoverySession.devices {
            
            switch device.position {
            case .front:
                self.frontCamera = device
            case .back:
                self.backCamera = device
            default:
                break
            }
        }
        
        self.currentCamera = self.backCamera
    }
    
    func setupInputOutput() {
        do {
            
            let captureDeviceInput = try AVCaptureDeviceInput(device: currentCamera!)
            captureSession.addInput(captureDeviceInput)
            photoOutput = AVCapturePhotoOutput()
            captureSession.addOutput(photoOutput!)
            
        } catch {
            print(error)
        }
        
    }
    
    func setupPreviewLayer() {
        
        self.cameraPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
        self.cameraPreviewLayer?.videoGravity = AVLayerVideoGravity.resizeAspectFill
        
        let deviceOrientation = UIDevice.current.orientation
        cameraPreviewLayer?.connection?.videoOrientation = AVCaptureVideoOrientation(rawValue: deviceOrientation.rawValue)!
        
        self.cameraPreviewLayer?.frame = self.view.frame
//        view.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)
        self.view.layer.insertSublayer(cameraPreviewLayer!, at: 0)
    }
    
    func startRunningCaptureSession() {
        captureSession.startRunning()
    }
}


struct FocusPicker: View {
    
    var feets = [&quot;∞ ft&quot;, &quot;30&quot;, &quot;15&quot;, &quot;10&quot;, &quot;7&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3.5&quot;, &quot;3&quot;, &quot;2.5&quot;, &quot;2&quot;, &quot;1.5&quot;, &quot;1&quot;, &quot;0.5&quot;, &quot;Auto&quot;]
    
    @Binding var selectedFocus: Float
    
    var body: some View {
        
        Picker(selection: $selectedFocus, label: Text(&quot;&quot;)) {
            ForEach(0 ..&lt; feets.count) {
                Text(feets[$0])
                    .foregroundColor(.white)
                    .font(.subheadline)
                    .fontWeight(.medium)
                
            }
            .animation(.none)
            .background(Color.clear)
            .pickerStyle(WheelPickerStyle())
        }
        .frame(width: 60, height: 200)
        .border(Color.gray, width: 5)
        .clipped()
    }
}
</code></pre>
","14553245","","14553245","","2020-11-11 12:46:29","2020-11-13 15:56:38","SwiftUI doesn't update state to @ObservedObject cameraViewModel object","<swiftui><uikit><combine><foundation>","1","0","","","","CC BY-SA 4.0"
"64771431","1","","","2020-11-10 15:04:31","","0","72","<p>I was fooling around with SwiftUI and Combine on my iPad's Swift playgrounds and trying to print out the communication details between <code>Combine</code> publishers and subscribers to <code>MyConsole</code>.</p>
<p>At first, I put some placeholder text into <code>MyConsole</code> and showed it in a <code>ScrollView</code>, and it scrolled without any problem.</p>
<p><a href=""https://i.stack.imgur.com/FYs7j.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/FYs7j.jpg"" alt=""scroll view"" /></a></p>
<p>Then I tapped the &quot;Get Image&quot; button to fetch an image from the internet, and the network request was perfectly successful too:</p>
<p><a href=""https://i.stack.imgur.com/XljBg.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/XljBg.jpg"" alt=""image fetched"" /></a></p>
<p>But now comes the problem: my <code>ScrollView</code> stops to scroll, it suddenly freezes. If I tap the &quot;Reset&quot; button to reset my <code>ContentView</code>, the <code>ScrollView</code> functions normally, it is able to scroll again.</p>
<p>Could anyone take a look at my following code, and tell me what was wrong with my <code>ScrollView</code>? Thanks.</p>
<pre><code>import Combine
import SwiftUI
import PlaygroundSupport

class MyConsole: TextOutputStream, ObservableObject {
    
    @Published private(set) var text = &quot;&quot;
    
    // TextOutputStream
    public func write(_ string: String) { text += string }
    
    public static let shared = MyConsole()
    private init() {}
    
    public func clear(to text: String = &quot;&quot;) { self.text = text }
}

// long text for ScrollView
let string = (1...40)
    .map{ _ in &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n&quot; }
    .joined()

let url = URL(string: &quot;https://source.unsplash.com/random&quot;)!
let console = MyConsole.shared

// performs a network request to fetch a random image from Unsplash’s public API
func imagePub() -&gt; AnyPublisher&lt;Image?, Never&gt; {
    URLSession.shared
        .dataTaskPublisher(for: url)
        .map { data, _ in Image(uiImage: UIImage(data: data)!)}
        .print(&quot;image&quot;, to: console)  // print to MyConsole
        .replaceError(with: nil)
        .eraseToAnyPublisher()
}

// ViewModel
class ViewModel: ObservableObject {
    
    @Published var image: Image?
    let taps = PassthroughSubject&lt;Void, Never&gt;()  // simulate user taps on a button
    var subscriptions = Set&lt;AnyCancellable&gt;()
    
    init() {
        console.clear(to: string)
        taps
            .map { _ in imagePub() }  // map the tap to a new network request
            .switchToLatest()         // accept only the latest tap
            .assign(to: \.image, on: self)
            .store(in: &amp;subscriptions)
    }
    
    // user intent
    func getImage() { taps.send() }
}

// ContentView
struct ContentView: View {
    
    // view model
    @ObservedObject var viewModel = ViewModel()
    @ObservedObject var console = MyConsole.shared
    
    var body: some View {
        VStack {
            
            // image
            viewModel.image?
                .resizable().scaledToFit()
                .frame(height: 300).border(Color.black)
            
            // console
            ScrollView {
                Text(console.text)
            }// ScrollView
                .frame(height: 200).padding()
                .border(Color.black)
                .background(Color.purple)
            
            // button
            HStack {
                Button(action: {
                    self.viewModel.getImage()
                }, label: {
                    Text(&quot;Get Image&quot;)
                        .padding().foregroundColor(.white)
                        .background(Color.blue).cornerRadius(12)
                })
                Button(action: {
                    self.viewModel.image = nil
                    self.console.clear(to: string)
                }, label: {
                    Text(&quot;Reset&quot;)
                        .padding().foregroundColor(.white)
                        .background(Color.pink).cornerRadius(12)
                })
            }
            
        }.padding().background(Color.gray).shadow(radius: 8)
    }
}

PlaygroundPage.current.setLiveView(ContentView())
</code></pre>
","5409815","","","","","2020-11-10 15:04:31","ScrollView works fine until I've fetched an image and update my view","<swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"64774869","1","64776573","","2020-11-10 18:43:24","","1","97","<p>I am new to combine and struggling to understand how I can return the result of my fetch pins.</p>
<p>I can set the result as <code>@Published</code> but I want to just be able to call the fetch method and await the result or error.</p>
<pre><code>class PinService: NSObject, ObservableObject {
    private var session: Session
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    
    init(session: Session) {
        self.session = session
        super.init()
    }
    
    func fetchPins (categories: Set&lt;CategoryModel&gt;, coordinates: CLLocationCoordinate2D)  {
        _fetchPins(categories: categories, coordinates: coordinates)
            .sink(receiveCompletion: { completion in
                switch completion {
                case .failure:
                    print(&quot;fetchPins() error&quot;)
                case .finished:
                    print(&quot;fetchPins() complete&quot;)
                }
            }, receiveValue: { pins in
                /*
                    What to do here?
                 
                    I can add a @Published var pins: [Pin], and do
                    self.pins = pins
                 
                    But if I want to be able to return the value or the error, how can I do that?
                 */
            })
            .store(in: &amp;self.subscriptions)
    }
    

    private func _fetchPins(categories: Set&lt;CategoryModel&gt;, coordinates: CLLocationCoordinate2D) -&gt; Future&lt;[Pin], Error&gt; {
        return Future&lt;[Pin], Error&gt; { promise in
            let categoryIds = categories.map { return $0.id }.joined(separator: &quot;,&quot;)
            
            let radius = 15 //miles
            
            self.session.request(baseUrl + &quot;/api/v1/pinsRadius?latitude=\(coordinates.latitude)&amp;longitude=\(coordinates.longitude)&amp;radius=\(radius)&amp;categories=\(categoryIds)&quot;)
                .responseDecodable(of: [Pin].self) { (response: DataResponse) in
                    switch response.result {
                    case .success(let pins):
                        promise(.success((pins)))
                    case .failure(let error):
                        promise(.failure(error))
                    }
            }
        }
    }
}
</code></pre>
<p>Sorry if its a dumb question, thanks.</p>
","1354934","","100297","","2020-11-11 11:53:08","2020-11-11 11:53:08","How do I return the result of my fetch call using combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64779992","1","64780495","","2020-11-11 03:17:36","","-2","904","<p>I just want to do some test like this ↓</p>
<ol>
<li>Create one publisher from first view</li>
<li>Pass it to second view</li>
<li>Bind the publisher with some property in second view and try to show it on screen</li>
</ol>
<p>The code is ↓ (First View)</p>
<pre><code>struct ContentView: View {
    
    let publisher = URLSession(configuration: URLSessionConfiguration.default)
        .dataTaskPublisher(for: URLRequest(url: URL(string: &quot;https://v.juhe.cn/joke/content/list.php?sort=asc&amp;page=&amp;pagesize=&amp;time=1418816972&amp;key=aa73ebdd8672a2b9adc9dbb2923184c8&quot;)!))
        .map(\.data.description)
        .replaceError(with: &quot;Error!&quot;)
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
        
    
    var body: some View {
        NavigationView {
            List {
                NavigationLink(destination: ResponseView(publisher: publisher)) {
                    Text(&quot;Hello, World!&quot;)
                }
            }.navigationBarTitle(&quot;Title&quot;, displayMode: .inline)
        }
    }
}
</code></pre>
<p>(Second View)</p>
<pre><code>struct ResponseView: View {
    
    let publisher: AnyPublisher&lt;String, Never&gt;
    @State var content: String = &quot;&quot;
    
    var body: some View {
        HStack {
            VStack {
                Text(content)
                    .font(.system(size: 12))
                    .onAppear { _ = self.publisher.assign(to: \.content, on: self) }
                Spacer()
            }
            Spacer()
        }
        
    }
}
</code></pre>
<p>But the code is not working. The request failed with message blow ↓</p>
<pre><code>2020-11-11 11:08:04.657375+0800 PandaServiceDemo[83721:1275181] Task &lt;6B53516E-5127-4C5E-AD5F-893F1AEE77E8&gt;.&lt;1&gt; finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 &quot;cancelled&quot; UserInfo={NSErrorFailingURLStringKey=https://v.juhe.cn/joke/content/list.php?sort=asc&amp;page=&amp;pagesize=&amp;time=1418816972&amp;key=aa73ebdd8672a2b9adc9dbb2923184c8, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=https://v.juhe.cn/joke/content/list.php?sort=asc&amp;page=&amp;pagesize=&amp;time=1418816972&amp;key=aa73ebdd8672a2b9adc9dbb2923184c8}
</code></pre>
<p>Can someone tell me what happened and what is the right approach to do this?</p>
","8287098","","341994","","2020-11-12 11:55:54","2020-11-12 11:55:54","SwiftUI Why Can't pass a publisher between Views?","<swift><swiftui><combine>","4","1","0","","","CC BY-SA 4.0"
"64807758","1","","","2020-11-12 16:26:11","","1","1780","<p>I have a subject which sends/receives an array of Data like <code>PassthroughSubject&lt;[Int], Never&gt;()</code>. When a value is received I want to split the array in single values to manipulate them and afterwards collect them again.</p>
<p>I know that the issue is that the <code>flatMap</code> never sends the completion Event. But how can I solves this issue? Or is there a better way to manipulate every value in an array with combine?</p>
<p>Edit:
I don‘t want to complete the subject to collect. I want to collect the output of the sequencer.</p>
<p>Example:</p>
<pre><code>import Combine

var storage = Set&lt;AnyCancellable&gt;()
let subject = PassthroughSubject&lt;[Int], Never&gt;()

subject
    .flatMap { $0.publisher }
    .map { $0 * 10 }
    .collect()
    .sink {
        print($0) // Never called
    }
    .store(in: &amp;storage)

subject.send([1, 2, 3, 4, 5])
</code></pre>
","4243514","","4243514","","2020-11-12 16:50:00","2020-11-12 18:01:31","Swift Combine: collect after sequence publisher not called","<swift><combine>","3","0","1","","","CC BY-SA 4.0"
"64814655","1","","","2020-11-13 02:34:18","","0","917","<p>I'm trying to make an app using Combine with UIKit. and I want to implement MVVM architecture with Input/Output pattern</p>
<p>If something happens in the View/ViewController (like view life cycle events or button tapped etc..) it should trigger the API request and View/ViewController react these responses</p>
<p>This is my code below</p>
<p><em><code>ViewModelType</code> protocol</em></p>
<pre><code>protocol ViewModelType {
    associatedtype Input
    associatedtype Output
    
    var input: Input { get }
    var output: Output { get }
}
</code></pre>
<p><em><code>Response</code> model</em></p>
<pre><code>struct Response {
    let text: String?
}
</code></pre>
<p><em><code>ViewMode</code> class</em></p>
<pre><code>class ViewModel: ViewModelType {
    struct Input {
        let buttonDidTapped: PassthroughSubject&lt;Void, Never&gt;
    }
    
    struct Output {
        let text: AnyPublisher&lt;String?, Never&gt;
    }
    
    let input: Input
    let output: Output
    
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    
    init() {
        
        let buttonDidTappedSubject = PassthroughSubject&lt;Void, Never&gt;()
        
        let response = buttonDidTappedSubject.map { $0 }.flatMap(ViewModel.fetch).eraseToAnyPublisher() // ---- 1
        let text = response.map { $0?.text } // ---- 2
            
        input = Input(buttonDidTapped: buttonDidTappedSubject)
        output = Output(text: text) // ---&gt; Error! 
    }
    
    private static func fetch() -&gt; AnyPublisher&lt;Response?, Never&gt; {
        return Future&lt;Response?, Never&gt; { promise in
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                promise(.success(Response(text: &quot;Hello World&quot;)))
            }
        }.eraseToAnyPublisher()
    }
}
</code></pre>
<p>I tried to write every Combine's code chaining in ViewModel's <code>init</code> method. Let me explain code above</p>
<ol>
<li>mapping button tapped to trigger API request</li>
<li>mapping response to Output</li>
</ol>
<p>but <code>text</code> type is not <code>AnyPublisher&lt;String?, Never&gt;</code>. it looks weird</p>
<p><code>Publishers.Map&lt;AnyPublisher&lt;Publishers.FlatMap&lt;AnyPublisher&lt;Response?, Never&gt;, Publishers.Map&lt;PassthroughSubject&lt;Void, Never&gt;, ()&gt;&gt;.Output, Publishers.FlatMap&lt;AnyPublisher&lt;Response?, Never&gt;, Publishers.Map&lt;PassthroughSubject&lt;Void, Never&gt;, ()&gt;&gt;.Failure&gt;, String?&gt;</code></p>
<p>What's wrong with my code and how can I make Input/Output pattern using Combine and UIKit</p>
","6727030","","","","","2020-11-13 03:55:52","iOS MVVM using Combine with Input/Outut pattern in UIKit","<ios><mvvm><binding><uikit><combine>","1","2","","","","CC BY-SA 4.0"
"64817953","1","64818443","","2020-11-13 08:56:15","","0","1942","<p>I want to achieve this: A class <code>A</code>, which has a property <code>var c1: C</code> and <code>var b1: B</code>, if the property of <code>C</code> changes, then the property of <code>b1</code> should be updated.</p>
<p>Here is my code:</p>
<pre><code>import UIKit
import Combine

struct B {
    var b = &quot;b&quot;
}

class C: ObservableObject {
    @Published var c: String = &quot;c1&quot;
}

class A: ObservableObject {
    var b1 = B()
    var cancellables = Set&lt;AnyCancellable&gt;()
    @Published var c1 = C()

    init() {

        $c1.sink {
            print(&quot;new value is \($0.c)&quot;) //Only print once
            self.b1.b = $0.c
        }.store(in: &amp;cancellables)
    }

    func printMe() {
        print(&quot;b1.b: \(b1.b)&quot;)
        print(&quot;c1.c: \(c1.c)&quot;)
    }
}



let a = A()
a.c1.c = &quot;c2&quot;
a.printMe()


a.c1.c = &quot;c3&quot;
a.printMe()
</code></pre>
<p>The output is:</p>
<pre><code>new value is c1
b1.b: c1
c1.c: c2
b1.b: c1
c1.c: c3
</code></pre>
<p>Every time the <code>a.c1.c</code> was updated I expected <code>a.b1.b</code> should be updated automatically by <code>sink</code>, not sure if anything I missed, the <code>sink</code> closure body just was called once.</p>
<p>Any suggestion? thanks!</p>
","291240","","291240","","2020-11-13 09:20:45","2020-11-13 09:28:27","Swift Combine doesn't update value by sink","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"64831092","1","","","2020-11-14 05:02:25","","3","1276","<p>When using <a href=""https://developer.apple.com/documentation/combine"" rel=""nofollow noreferrer"">Combine</a> as below</p>
<pre><code>var cancellables: [AnyCancellable] = []

func loadItems(tuple : (name : String, imageURL : URL)) {
    URLSession.shared.dataTaskPublisher(for: tuple.imageURL)
        .sink(
            receiveCompletion: {
                completion in
                switch completion {
                case .finished:
                    break
                case .failure( _):
                    return
                }},
            receiveValue: { data, _ in DispatchQueue.main.async { [weak self] in self?.displayFlag(data: data, title: tuple.name) } })
        .store(in: &amp;cancellables)
}
</code></pre>
<p>We don't need to call <code>cancel</code> in the <code>deinit</code> as below</p>
<pre><code>deinit {
    cancellables.forEach {
        $0.cancel()
    }
}
</code></pre>
<p>Given that in <a href=""https://developer.apple.com/documentation/combine/anycancellable"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/combine/anycancellable</a>, it is stated:</p>
<blockquote>
<p><strong>An AnyCancellable instance automatically calls cancel() when deinitialized.</strong></p>
</blockquote>
<p>Given we don't need to release during deinit, can the Combine be used in <code>struct</code> instead of <code>class</code>?</p>
","3286489","","3641812","","2021-01-24 11:25:58","2021-01-24 11:25:58","Can Combine be used in struct (instead of class)?","<swift><combine>","2","6","","","","CC BY-SA 4.0"
"64831561","1","","","2020-11-14 06:40:37","","0","95","<p><strong>Scenario:</strong> An asynchronous session is used within a <strong>Class</strong> to access an off-line server. <br/>
There are several <strong>endpoints</strong> that are accessed via a <strong>class enum</strong> per context of the request from the container view. <br/>
The data accumulates in a <strong>Singleton class</strong> amongst other endpoints for quicker access via member views.</p>
<p>One member view is displayed per endpoint.</p>
<p><strong>Goal:</strong> to <em>notify the parent View</em> after the requested endpoint has returned data for display; which in turn populates a particular member view.</p>
<p>
<p><strong>Problem:</strong> Needless to say, the member view is always rendered <em><strong>before</strong></em> receiving the data. <br/>
That is, it's out-of-sync.</p>
<p>
In fact, the only way to have the data seen is via a button on the container view to display the member view with the data on demand.  This is NOT what I want. I want this to happen automatically upon data-source selection.
<p><strong>My Solution:</strong> to fire off a <strong>Notification</strong> <em>to the container view</em> once data is available so the container view can render the appropriate member view with the data.</p>
<p><strong>Problem:</strong> I'm using the <strong>publisher-subscribe</strong> scenario to wait for notification so I can display the data.  <br/>
But I'm confused at handling the subscriber within the container view.</p>
<p>
I was thinking of using the **NSNotification** use of a handler @Objc function vs publish/subscribe. <br/> 
But I'm mixing imperative with the subjective paradigm here.
<p>The following piece of code posts the notification upon receiving data:</p>
<pre><code>   case .AppleCountryProvince:
        let url = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries/Canada&quot;)!
        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .receive(on: DispatchQueue.main)
            .decode(type: DMAppleSubRegion.self, decoder: JSONDecoder())
            .print(&quot;AppleSubRegion: &quot;)

        remoteDataPublisher
            .eraseToAnyPublisher()
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    print(&quot;Publisher Finished&quot;)
                case let .failure(anError):
                    Swift.print(&quot;\nReceived error: &quot;, anError)
                }
            }, receiveValue: { someValue in
                SingletonData.shared.appleSubRegion = someValue
                NotificationCenter.default.post(name: noteName, object: DataModelType.AppleCountryProvince)
            }).store(in: &amp;cancellables)
</code></pre>
<p>
The following code snippet is within a function of a View to handle the Notification.  <br/> This isn't firing.
<pre><code>    _ = NotificationCenter.default
        .publisher(for: noteName)
        .sink { note in
            if let source = note.object as? DataSource.DataModelType {
                switch source {
                case .AppleCountries:
                    print(&quot;AppleCountries&quot;)
                case .AppleCountryProvince:
                    print(&quot;AppleCountryProvince&quot;)
                case .AppleSubRegions:
                    print(&quot;AppleSubRegions&quot;)
                case .ILINET:
                    print(&quot;ILINET&quot;)
                case .CDC:
                    print(&quot;CDC&quot;)
                case .PHL:
                    print(&quot;PHL&quot;)

                default:
                    print(&quot;Default&quot;)
                }
            }
        }
</code></pre>
<p><strong>Question:</strong> should I pass a publisher variable between the class &amp; the container view from which to launch the subscriber?</p>
<p>I understand the cause/affect of using @State &lt;--&gt; @Binding in <em>synchronous</em> time.<br />
But I need the have the view react <em>asynchronously</em> upon the conclusion of acquiring the server data.</p>
<p>
I'm not sure I can use the conventional NSNotification within the container view.
<p><strong>The bottom line:</strong> can I get the container view to react to the end of the network session?</p>
","715747","","","","","2020-11-14 06:40:37","What is the correct way to notify a SwiftUI parent/host View of the end a Class URLSession task?","<asynchronous><swiftui><combine>","0","2","1","","","CC BY-SA 4.0"
"64846013","1","","","2020-11-15 15:07:34","","14","6784","<p>I am learning Swift Combine now, found quite easy video tutorial, however for some reason I get error when I try to use my enum in PassthroughSubject&lt;Int, WeatherError&gt;()</p>
<p>Check this code:</p>
<pre><code>import Combine 

enum WeatherError: Error {
   case thingsJustHappen
   
}
let weatherPublisher = PassthroughSubject&lt;Int, WeatherError&gt;()


let subscriber = weatherPublisher
   .filter {$0 &gt; 10}
   .sink { value in
       print(&quot;\(value)&quot;)
   }

weatherPublisher.send(10)
weatherPublisher.send(30)
</code></pre>
<p>&quot;.filter&quot; is highlighted and the error is:</p>
<pre><code>Referencing instance method 'sink(receiveValue:)' on 'Publisher' 
requires the types 'Publishers.Filter&lt;PassthroughSubject&lt;Int, WeatherError&gt;&gt;.Failure' 
(aka 'WeatherError') and 'Never' be equivalent
</code></pre>
<p>Surprisingly this code works in the video tutorial. How can I make my WeatherError and Never to be equivalent???</p>
","1496972","","","","","2022-03-26 20:35:27","Swift combine error: method on 'Publisher' requires .Failure' (aka 'WeatherError') and 'Never' be equivalent","<ios><swift><xcode><combine>","2","0","","","","CC BY-SA 4.0"
"64849556","1","64851228","","2020-11-15 20:41:50","","0","1950","<p>I'm currently using Moya alpha 15 with Combine Framework for my SwiftUI project. With Moya, I have a provider that's responsible for creating requests.</p>
<p>What I want:</p>
<ol>
<li>Use getInstance(page: Int) to get my initial instanceResponseList object.</li>
<li>From that instanceResponseList object, check each instance if hasChildren == true</li>
<li>If hasChildren == true, call getInstanceChildren(id: String) using the instance's id</li>
<li>response from getInstanceChildren(id: String) will be mapped and assigned to the children: [Instance] property(response.data.instances)</li>
</ol>
<p>Is this possible? If not, is there a better way to do this?</p>
<p>What I'm trying to do:</p>
<p>I need to show a profile image using the profileURL from Instance in a tableView. The height of each cell will be dynamic and based on the aspect ratio of each image. Each cell could have 1 + children profile images arranged differently.</p>
<p>Some sample code of my service call and data models:</p>
<pre><code>    public struct InstanceResponseList: Codable {
        public var success: Bool
        public var data: InstanceResponse
    }

    public struct InstanceResponse: Codable {
        public var instances: [Instance]
        public var hasMore: Bool //for pagination
    }

    public struct Instance: Codable {
        public var id: String
        public var profileURL: String?
        public var hasChildren: Bool


        public var children: [Instance] // I want to make a request and append the children for each of my instances.

        enum CodingKeys: String, CodingKey {
            case id = &quot;instance_id&quot;
            case profileURL = &quot;profile_url&quot;
            case hasChildren = &quot;has_children&quot;
        }
    }

    public func getInstance(page: Int) -&gt; AnyPublisher&lt;InstanceResponseList, MoyaError&gt; {
        return instanceProvider
            .requestPublisher(.allInstances(page: page, show: 10)) // page &amp; show are parameters used for pagination, not relevant here
            .map(InstanceResponseList.self)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }

    public func getInstanceChildren(id: String) -&gt; AnyPublisher&lt;InstanceResponseList, MoyaError&gt; {
        return haptagramProvider
            .requestPublisher(.children(id: id))
            .map(InstanceResponseList.self)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }

</code></pre>
<p>My attempt:</p>
<pre><code>    public func getInstanceWithChildren(page: Int) -&gt; AnyPublisher&lt;[Instance], MoyaError&gt; {
        
        return getInstance(page: Int)
            .flatMap { instanceResponseList -&gt; AnyPublisher&lt;Instance, MoyaError&gt; in
                Publishers.Sequence(sequence: instanceResponseList.data.instances).eraseToAnyPublisher()
            }
            .flatMap { instance -&gt; AnyPublisher&lt;Instance, MoyaError&gt; in
                return getInstanceChildren(id: instance.id).map {
                    let instance = instance
                    instance.children = $0
                    return instance
                }
                .eraseToAnyPublisher()
                
            }
            .collect()
            .eraseToAnyPublisher()
    }

</code></pre>
<p>which returns <code>AnyPublisher&lt;[Instance], MoyaError&gt;</code>, but I'm looking to return <code>AnyPublisher&lt;InstanceResponseList, MoyaError&gt;</code>.</p>
","1221857","","1221857","","2020-11-15 23:46:36","2020-11-16 02:31:21","How to have multiple requests using Combine Framework","<ios><swift><reactive-programming><combine><moya>","1","4","","","","CC BY-SA 4.0"
"64854765","1","64855339","","2020-11-16 08:33:27","","2","3345","<p>I was looking for good solutions for loading images asynchronously from a remote server image URL. There were many solutions online. It's a shame Apple doesn't provide one natively for something that is so common. Anyways, I found <a href=""https://www.swiftbysundell.com/tips/constant-combine-publishers/"" rel=""nofollow noreferrer"">Sundell's blog</a> really interesting and took the good bits from it to create my own ImageLoader, as shown below:</p>
<pre><code>import Combine

class ImageLoader {

    private let urlSession: URLSession
    private let cache: NSCache&lt;NSURL, UIImage&gt;

    init(urlSession: URLSession = .shared,
         cache: NSCache&lt;NSURL, UIImage&gt; = .init()) {
        self.urlSession = urlSession
        self.cache = cache
    }

    func publisher(for url: URL) -&gt; AnyPublisher&lt;UIImage, Error&gt; {
        if let image = cache.object(forKey: url as NSURL) {
            return Just(image)
                .setFailureType(to: Error.self)
                .receive(on: DispatchQueue.main)
                .eraseToAnyPublisher()
        } else {
            return urlSession
                .dataTaskPublisher(for: url)
                .map(\.data)
                .tryMap { data in
                    guard let image = UIImage(data: data) else {
                        throw URLError(.badServerResponse, userInfo: [
                            NSURLErrorFailingURLErrorKey: url
                        ])
                    }
                    return image
                }
                .receive(on: DispatchQueue.main)
                .handleEvents(receiveOutput: { [cache] image in
                    cache.setObject(image, forKey: url as NSURL)
                })
                .eraseToAnyPublisher()
        }
    }
}
</code></pre>
<p>As you can see the publisher provides an instance of <code>AnyPublisher&lt;UIImage, Error&gt;</code>. I'm not entirely sure on how to use this <code>ImageLoader</code> in my <code>MyImageView</code> shown below:</p>
<pre><code>struct MyImageView: View {

    var url: URL
    var imageLoader = ImageLoader()

    @State private var image = #imageLiteral(resourceName: &quot;placeholder&quot;)

    var body: some View {
        Image(uiImage: image)
            .onAppear {
                let cancellable = imageLoader.publisher(for: url).sink(receiveCompletion: { failure in
                    print(failure) // doesn't print
                }, receiveValue: { image in
                    self.image = image // not getting executed
                })
                cancellable.cancel() // tried with and without this line.
            }
    }
}
</code></pre>
<p>How do I extract the <code>UIImage</code> from the <code>ImageLoader</code> publisher that returns an instance of <code>AnyPublisher&lt;UIImage, Error&gt;</code>?</p>
","7098650","","","","","2021-06-14 02:11:24","Loading image from remote URL asynchronously in SwiftUI Image using combine's Publisher","<swift><image><swiftui><combine><publisher>","3","4","0","","","CC BY-SA 4.0"
"64864422","1","","","2020-11-16 19:23:56","","1","538","<p>I want to listen for the <code>isHidden</code> property of the <code>UIView</code> and based on the changes in the value, I am notifying the respective delegates.</p>
<p>I trying to convert the following Rx code to Combine and I am not sure how.</p>
<p>Sample Rx Code:</p>
<pre><code>customView.rx
   .observe(Bool.self, &quot;hidden&quot;)
   .subscribe(onNext: { [weak self] value in
      guard let self = self else { return }
      self.view.isHidden = value ?? true
      self.delegate?didUpdate(isHidden: value ?? true)
   })
   .disposed(by: disposeBag)
</code></pre>
<p>Kindly share a few ideas or suggestions.</p>
<p>Note: I am pretty new to <strong>RxSwift</strong> and <strong>Combine</strong> Framework.</p>
","849486","","","","","2020-11-16 20:35:46","RxSwift to Combine: Listening for UIView property update","<ios><swift><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"64902399","1","64904404","","2020-11-18 22:27:05","","0","680","<p>I'm trying to have a combine pipeline that fetches five random photo urls using the Unsplash API, then downloads a photo from each url. The issue I’m running into is that the images are mostly the same. Sometimes (and I don't know why) one of the images will be different than the other four.</p>
<p>Any help would be appreciated. I've included all the necessary code besides the UnSplash Api key.</p>
<pre><code>static func fetchRandomPhotos() -&gt; AnyPublisher&lt;UIImage, Error&gt;{
        let string = createURL(path: &quot;/photos/random&quot;)

        return [1,2,3,4,5]
            .publisher
            .flatMap{ i -&gt; AnyPublisher&lt;UnsplashImageResults, Error&gt; in
                return self.downloadAndDecode(string, type: UnsplashImageResults.self)
            }
            .flatMap{ result -&gt; AnyPublisher&lt;UIImage, Error&gt; in
                print(result.urls.thumb)
                let url = URL(string: result.urls.thumb)!
                return URLSession.shared.dataTaskPublisher(for: url)
                    .map { UIImage(data: $0.data)! }
                    .mapError{_ in NetworkError.invalidURL}
                    .eraseToAnyPublisher()
            }
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }

</code></pre>
<pre><code>struct UnsplashURLs: Decodable{
    let full: String
    let regular: String
    let small: String
    let thumb: String
}

struct UnsplashImageResults: Decodable{
    let urls: UnsplashURLs
}
</code></pre>
<pre><code>enum NetworkError: LocalizedError{
    case invalidURL

    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return &quot;The url is invalid&quot;
        }
    }
}
</code></pre>
<pre><code>static private func createURL(path: String)-&gt; String{
        var components = URLComponents()
        components.scheme     = &quot;https&quot;
        components.host       = &quot;api.unsplash.com&quot;
        components.path       = path
        components.queryItems = [
            URLQueryItem(name: &quot;client_id&quot;, value: &quot;YOUR API KEY HERE&quot;)
        ]
        
        return components.string!
    }
    
    static private func downloadAndDecode&lt;T:Decodable&gt;(_ urlString: String, type: T.Type) -&gt; AnyPublisher&lt;T, Error&gt;{
        guard let url = URL(string: urlString) else{
            return Fail(error: NetworkError.invalidURL).eraseToAnyPublisher()
        }
        return URLSession.shared.dataTaskPublisher(for: url)
            .tryMap() { element -&gt; Data in
                guard let httpResponse = element.response as? HTTPURLResponse,
                      httpResponse.statusCode == 200 else {
                    throw URLError(.badServerResponse)
                }
                return element.data
            }
            .decode(type: T.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
</code></pre>
<pre><code>class UnsplashImagesViewModel: ObservableObject{
    var subscriptions = Set&lt;AnyCancellable&gt;()
    @Published var images = [UIImage]()
    
    init(){
        UnsplashAPI.fetchRandomPhotos()
            .sink { (_) in
                
            } receiveValue: { image in
                self.images.append(image)
            }.store(in: &amp;subscriptions)

    }
}

struct UnsplashImagesGrid: View {
    @StateObject private var model = UnsplashImagesViewModel()
    
    var body: some View {
        List(model.images, id: \.self){ image in
            Image(uiImage: image)
        }
    }
}
</code></pre>
","10830089","","","","","2020-11-19 02:14:26","Repeat Network Request Multiple Times With Swift Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64909143","1","65507827","","2020-11-19 09:48:49","","1","108","<p>I'm new to SwiftUI and Combine. What I trying to build is a manual camera app, and there's only 4 UI component:</p>
<ul>
<li><code>CaptureButton</code> for making a shot from the camera</li>
<li><code>FocusPicker</code> for controlling manually camera focus exposure</li>
<li><code>OffsetView</code> for displaying a level of exposure</li>
<li><code>CameraPreviewRepresentable</code> for integrating UIKit camera into SwiftUI view</li>
</ul>
<p>Also added Privacy requests into.Info.plist file from a user to allow camera feature and saving to Apple Photo App</p>
<p><a href=""https://i.stack.imgur.com/QYYkl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QYYkl.png"" alt=""enter image description here"" /></a></p>
<p>For updating data and passing it to the UI, I'm using <code>CameraViewModel</code>, <code>currentCameraSubject</code> and <code>currentCamera</code> Publisher to showing new values from <code>AVCaptureDevice</code> and setting it to <code>CameraViewModel</code>.</p>
<p>And I'm noticing a really interesting behavior/bug of <code>FocusPicker</code> when I start interacting with it and piking a new focus it constantly get back to started position and when <code>OffsetView</code> is getting a new value each time.</p>
<p>But interesting enough for example when <code>OffsetView</code> has the same value then <code>FocusPicker</code> is doing normal. And I do not know why this is happening. Please help, it's really frustrating to fix for me.</p>
<p>By the way, it will only work on a real device only.</p>
<p>Here's all the code:</p>
<pre><code>import SwiftUI

//@main
//struct StackOverflowCamApp: App {
//    var cameraViewModel = CameraViewModel(focusLensPosition: 0)
//    let cameraController: CustomCameraController = CustomCameraController()
//
//    var body: some Scene {
//        WindowGroup {
//            ContentView(cameraViewModel: cameraViewModel, cameraController: cameraController)
//        }
//    }
//}

struct ContentView: View {
    
    @State private var didTapCapture = false
    @ObservedObject var cameraViewModel: CameraViewModel
    let cameraController: CustomCameraController
    
    var body: some View {
        
        VStack {
            ZStack {
                CameraPreviewRepresentable(didTapCapture: $didTapCapture, cameraViewModel: cameraViewModel, cameraController: cameraController)
                    .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .center)
                
                VStack {
                    FocusPicker(selectedFocus: $cameraViewModel.focusChoice)
                    
                    Text(String(format: &quot;%.2f&quot;, cameraViewModel.focusLensPosition))
                        .foregroundColor(.red)
                        .font(.largeTitle)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
            }
            .edgesIgnoringSafeArea(.all)
            
            Spacer()
            
            OffsetView(levelValue: cameraViewModel.exposureTargetOffset, height: 100)
                .frame(maxWidth: .infinity, alignment: .leading)
            
            CaptureButton(didTapCapture: $didTapCapture)
                .frame(width: 100, height: 100, alignment: .center)
                .padding(.bottom, 20)
        }
    }
}

struct CaptureButton: View {
    @Binding var didTapCapture : Bool
    
    var body: some View {
        Button {
            didTapCapture.toggle()
            
        } label: {
            Image(systemName: &quot;photo&quot;)
                .font(.largeTitle)
                .padding(30)
                .background(Color.red)
                .foregroundColor(.white)
                .clipShape(Circle())
                .overlay(
                    Circle()
                        .stroke(Color.red)
                )
        }
    }
}

struct OffsetView: View {
    
    var levelValue: Float
    let height: CGFloat
    
    var body: some View {

        ZStack {
            Rectangle()
                .foregroundColor(.red)
                .frame(maxWidth: height / 2, maxHeight: height, alignment: .trailing)

            Rectangle()
                .foregroundColor(.orange)
                .frame(maxWidth: height / 2, maxHeight: height / 20, alignment: .trailing)
                .offset(x: 0, y: min(CGFloat(-levelValue) * height / 2, height / 2))
        }
    }
}

struct FocusPicker: View {
    
    @Binding var selectedFocus: FocusChoice
    
    var body: some View {
        
        Picker(selection: $selectedFocus, label: Text(&quot;&quot;)) {
            ForEach(0..&lt;FocusChoice.allCases.count) {
                Text(&quot;\(FocusChoice.allCases[$0].caption)&quot;)
                    .foregroundColor(.white)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .tag(FocusChoice.allCases[$0])
            }
            .animation(.none)
            .background(Color.clear)
            .pickerStyle(WheelPickerStyle())
        }
        .frame(width: 60, height: 200)
        .border(Color.gray, width: 5)
        .clipped()
    }
}

import SwiftUI
import Combine
import AVFoundation

struct CameraPreviewRepresentable: UIViewControllerRepresentable {
    
    @Environment(\.presentationMode) var presentationMode
    @Binding var didTapCapture: Bool
    @ObservedObject var cameraViewModel: CameraViewModel
    
    let cameraController: CustomCameraController
    
    func makeUIViewController(context: Context) -&gt; CustomCameraController {
        cameraController.delegate = context.coordinator
        
        return cameraController
    }
    
    func updateUIViewController(_ cameraViewController: CustomCameraController, context: Context) {
        
        if didTapCapture {
            cameraViewController.didTapRecord()
        }
        
        // checking if new value is differnt from the previous value
        if cameraViewModel.focusChoice.rawValue != cameraViewController.manualFocusValue {
            cameraViewController.manualFocusValue = cameraViewModel.focusChoice.rawValue
        }
    }
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self, cameraViewModel: cameraViewModel)
    }
    
    class Coordinator: NSObject, UINavigationControllerDelegate, AVCapturePhotoCaptureDelegate {
        let parent: CameraPreviewRepresentable
        var cameraViewModel: CameraViewModel
        
        var tokens = Set&lt;AnyCancellable&gt;()
        
        init(_ parent: CameraPreviewRepresentable, cameraViewModel: CameraViewModel) {
            self.parent = parent
            self.cameraViewModel = cameraViewModel
            super.init()
            
            // for showing focus lens position
            self.parent.cameraController.currentCamera
                    .filter { $0 != nil }
                    .flatMap { $0!.publisher(for: \.lensPosition) }
                    .assign(to: \.focusLensPosition, on: cameraViewModel)
                    .store(in: &amp;tokens)
            
            // for showing exposure offset
            self.parent.cameraController.currentCamera
                .filter { $0 != nil }
                .flatMap { $0!.publisher(for: \.exposureTargetOffset) }
                .assign(to: \.exposureTargetOffset, on: cameraViewModel)
                .store(in: &amp;tokens)
        }
        
        func photoOutput(_ output: AVCapturePhotoOutput, didFinishProcessingPhoto photo: AVCapturePhoto, error: Error?) {
            
            parent.didTapCapture = false
            
            if let imageData = photo.fileDataRepresentation(), let image = UIImage(data: imageData) {
                UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
            }
            
            parent.presentationMode.wrappedValue.dismiss()
        }
    }
}

import Combine
import AVFoundation

class CameraViewModel: ObservableObject {
    @Published var focusLensPosition: Float = 0
    @Published var exposureTargetOffset: Float = 0
    
    @Published var focusChoice: FocusChoice = .infinity
    
    private var tokens = Set&lt;AnyCancellable&gt;()

    init(focusLensPosition: Float) {
        self.focusLensPosition = focusLensPosition
    }
}

enum FocusChoice: Float, CaseIterable {
    case infinity = 1
    case ft_30 = 0.95
    case ft_15 = 0.9
    case ft_10 = 0.85
    case ft_7 = 0.8
    case ft_5 = 0.5
    case ft_4 = 0.7
    case ft_3_5 = 0.65
    case ft_3 = 0.6
    case auto = 0
}

extension FocusChoice {
    var caption: String {
        switch self {
        case .infinity: return &quot;∞ft&quot;
        case .ft_30: return &quot;30&quot;
        case .ft_15: return &quot;15&quot;
        case .ft_10: return &quot;10&quot;
        case .ft_7: return &quot;7&quot;
        case .ft_5: return &quot;5&quot;
        case .ft_4: return &quot;4&quot;
        case .ft_3_5: return &quot;3.5&quot;
        case .ft_3: return &quot;3&quot;
        case .auto: return &quot;Auto&quot;
        }
    }
}

import UIKit
import Combine
import AVFoundation

class CustomCameraController: UIViewController {
    
    var image: UIImage?
    
    var captureSession = AVCaptureSession()
    var backCamera: AVCaptureDevice?
    var frontCamera: AVCaptureDevice?
    lazy var currentCamera: AnyPublisher&lt;AVCaptureDevice?, Never&gt; = currentCameraSubject.eraseToAnyPublisher()
    var photoOutput: AVCapturePhotoOutput?
    var cameraPreviewLayer: AVCaptureVideoPreviewLayer?
    private var currentCameraSubject = CurrentValueSubject&lt;AVCaptureDevice?, Never&gt;(nil)
    
    var manualFocusValue: Float = 1 {
        didSet {
            guard manualFocusValue != 0 else {
                setAutoLensPosition()
                return
            }
            setFocusLensPosition(manualValue: manualFocusValue)
        }
    }
    
    //DELEGATE
    var delegate: AVCapturePhotoCaptureDelegate?
    
    func setFocusLensPosition(manualValue: Float) {
        do {
            try currentCameraSubject.value!.lockForConfiguration()
            currentCameraSubject.value!.focusMode = .locked
            currentCameraSubject.value!.setFocusModeLocked(lensPosition: manualValue, completionHandler: nil)
            currentCameraSubject.value!.unlockForConfiguration()
        } catch let error {
            print(error.localizedDescription)
        }
    }
    
    func setAutoLensPosition() {
        do {
            try currentCameraSubject.value!.lockForConfiguration()
            currentCameraSubject.value!.focusMode = .continuousAutoFocus
            currentCameraSubject.value!.unlockForConfiguration()
        } catch let error {
            print(error.localizedDescription)
        }
    }
    
    func didTapRecord() {
        
        let settings = AVCapturePhotoSettings()
        photoOutput?.capturePhoto(with: settings, delegate: delegate!)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setup()
    }
    
    func setup() {
        
        setupCaptureSession()
        setupDevice()
        setupInputOutput()
        setupPreviewLayer()
        startRunningCaptureSession()
    }
    
    func setupCaptureSession() {
        captureSession.sessionPreset = .photo
    }
    
    func setupDevice() {
        let deviceDiscoverySession =
            AVCaptureDevice.DiscoverySession(deviceTypes: [.builtInWideAngleCamera],
                                                                      mediaType: .video,
                                                                      position: .unspecified)
        for device in deviceDiscoverySession.devices {
            
            switch device.position {
            case .front:
                self.frontCamera = device
            case .back:
                self.backCamera = device
            default:
                break
            }
        }
        
        self.currentCameraSubject.send(self.backCamera)
    }
    
    func setupInputOutput() {
        do {
          let captureDeviceInput = try AVCaptureDeviceInput(device: currentCameraSubject.value!)
          captureSession.addInput(captureDeviceInput)
          photoOutput = AVCapturePhotoOutput()
          captureSession.addOutput(photoOutput!)
        } catch {
          print(error)
        }
         
      }
    
    func setupPreviewLayer() {
        
        self.cameraPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
        self.cameraPreviewLayer?.videoGravity = AVLayerVideoGravity.resizeAspectFill
        
        let deviceOrientation = UIDevice.current.orientation
        cameraPreviewLayer?.connection?.videoOrientation = AVCaptureVideoOrientation(rawValue: deviceOrientation.rawValue)!
        
        self.cameraPreviewLayer?.frame = self.view.frame
        self.view.layer.insertSublayer(cameraPreviewLayer!, at: 0)
    }
    
    func startRunningCaptureSession() {
        captureSession.startRunning()
    }
}
</code></pre>
","14553245","","14553245","","2020-12-29 14:52:17","2020-12-30 13:34:44","Weird behaviour of SwiftUI Picker View when the other view getting new value from AVCaptureDevice API","<swiftui><avfoundation><combine>","1","0","","","","CC BY-SA 4.0"
"64921656","1","","","2020-11-19 23:38:52","","2","1646","<p>Normally we can bridge our async code and Combine by wrapping our async code in a single-shot publisher using a <code>Future</code>:</p>
<pre><code>func readEmail() -&gt; AnyPublisher&lt;[String], Error&gt; {
  Future { promise in
    self.emailManager.readEmail() { result, error in
      if let error = error {
        promise(.failure(error))
      } else {
        promise(.success(result))
      }
    }
  }.eraseToAnyPublisher()
}
</code></pre>
<p>On the other hand, if we're wrapping the delegate pattern (instead of an async callback), it's <a href=""https://heckj.github.io/swiftui-notes/#patterns-delegate-publisher-subject"" rel=""nofollow noreferrer"">recommended to use a PassthroughSubject</a>, since the methods could be fired multiple times:</p>
<pre><code>final class LocationHeadingProxy: NSObject, CLLocationManagerDelegate {

  private let headingPublisher: PassthroughSubject&lt;CLHeading, Error&gt; 

  override init() {
    headingPublisher = PassthroughSubject&lt;CLHeading, Error&gt;()
    // ...
  }

  func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
    headingPublisher.send(newHeading) 
  }
}
</code></pre>
<p>However, I'm trying to create a <a href=""https://heckj.github.io/swiftui-notes/#reasoning-about-pipelines"" rel=""nofollow noreferrer"">one-shot publisher</a> which wraps an existing Delegate pattern. The reason is that I'm firing off a method like <code>connect()</code> and I expect either a success or failure to happen immediately. I do not want future updates to affect the pipeline.</p>
<p>For example, imagine I'm using <code>WKExtendedRuntimeSession</code> and wrapped the <code>.start()</code> method in <code>startSession()</code> below. If I have this wrapped successfully, I should be able to use it like so:</p>
<pre><code>manager.startSession()
  .sink(
    receiveCompletion: { result in
      if result.isError {
        showFailureToStartScreen()
      }
    },
    receiveValue: { value in
      showStartedSessionScreen()
    })
  .store(in: &amp;cancellables)
</code></pre>
<p>The reason a one-shot publisher is useful is because we expect one of the following two methods to be called soon after calling the method:</p>
<ul>
<li>Success: <code>extendedRuntimeSessionDidStart(_:)</code></li>
<li>Fail: <code>extendedRuntimeSession(_:didInvalidateWith:error:)</code></li>
</ul>
<p>Furthermore, when the session is halted (or we terminate it ourselves), we don't want side effects such as <code>showFailureToStartScreen()</code> to randomly happen. We want them to be handled explicitly elsewhere in the code. Therefore, having a one-shot pipeline is beneficial here so we can guarantee that <code>sink</code> is only called once.</p>
<hr />
<p>I realize that one way to do this is to use a <code>Future</code>, store a reference to the <code>Promise</code>, and call the promise at a later time, but this seems hacky at best:</p>
<pre><code>class Manager: NSObject, WKExtendedRuntimeSessionDelegate {
  var session: WKExtendedRuntimeSession?
  var tempPromise: Future&lt;Void, Error&gt;.Promise?

  func startSession() -&gt; AnyPublisher&lt;Void, Error&gt; {
    session = WKExtendedRuntimeSession()
    session?.delegate = self
    return Future { promise in
      tempPromise = promise
      session?.start()
    }.eraseToAnyPublisher()
  }

  func extendedRuntimeSessionDidStart(_ extendedRuntimeSession: WKExtendedRuntimeSession) {
    tempPromise?(.success(()))
    tempPromise = nil
  }

  func extendedRuntimeSession(_ extendedRuntimeSession: WKExtendedRuntimeSession, didInvalidateWith reason: WKExtendedRuntimeSessionInvalidationReason, error: Error?) {
    if let error = error {
      tempPromise?(.failure(error))
    }
    tempPromise = nil
  }
}
</code></pre>
<p>Is this really the most elegant way to work with delegates + one-shot publishers, or is there a more elegant way to do this in Combine?</p>
<hr />
<p>For reference, <a href=""https://mxcl.dev/PromiseKit/reference/v6/index.html"" rel=""nofollow noreferrer"">PromiseKit</a> also has a similar API to <code>Future.init</code>. Namely, <a href=""https://mxcl.dev/PromiseKit/reference/v6/Classes/Promise.html#/s:10PromiseKit0A0C7pendingACyxG7promise_AA8ResolverCyxG8resolvertyFZ"" rel=""nofollow noreferrer""><code>Promise.init(resolver:)</code></a>. However, PromiseKit also seems to natively support the functionality I describe above with their <a href=""https://mxcl.dev/PromiseKit/reference/v6/Classes/Promise.html#/s:10PromiseKit0A0C7pendingACyxG7promise_AA8ResolverCyxG8resolvertyFZ"" rel=""nofollow noreferrer""><code>pending()</code></a> function (<a href=""https://chariotsolutions.com/blog/post/swift-4-and-promisekit/"" rel=""nofollow noreferrer"">example</a>):</p>
<pre><code>  func startSession() -&gt; Promise {
    let (promise, resolver) = Promise.pending()
    tempPromiseResolver = resolver

    session = WKExtendedRuntimeSession()
    session?.delegate = self
    session?.start()

    return promise
  }
</code></pre>
","35690","","35690","","2020-11-24 00:17:49","2020-11-24 00:17:49","How to wrap the delegate pattern with a one-shot publisher?","<ios><swift><combine>","1","0","3","","","CC BY-SA 4.0"
"64932846","1","64935533","","2020-11-20 16:06:43","","0","1418","<p>I'm currently developing an application using SwiftUI.</p>
<p>I want to show a progress status when a flag is true.</p>
<p>In my code, the flag has true status during a <code>while</code> loop with a method wrapped in the <code>DispatchQueue.main.sync</code> method works.
But I get an error below:</p>
<p><a href=""https://i.stack.imgur.com/PvcJs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PvcJs.png"" alt=""enter image description here"" /></a></p>
<blockquote>
<p>Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.</p>
</blockquote>
<p>How cloud I solve this problem?</p>
<hr />
<p>Here are the codes:</p>
<p>AppState.swift</p>
<pre><code>@Published var isLoading:Bool = false
@Published var weatherInfos:[WeatherInfos]?


func getTemperatureAsync(date: String) {

    DispatchQueue.global().async {

        var counter:Int = 0
        var totalTemp:Float = 0.0

        while counter &lt; 100
        {
            self.isLoading = true // I get error here

            counter += 1
            totalTemp += self.getTemperature(date: date)

            self.isLoading = false // I get error here
        }
    }
}


func getTemperature(date: String) -&gt; Float{

    var temperature: Float = 0.0
    let semaphore = DispatchSemaphore(value: 0)

    let endpoint: String = &quot;https://sample.com/api/weather/?&amp;date=\(date)&quot;
    let url = URL(string: endpoint)
    var urlRequest = URLRequest(url: url!)
    urlRequest.addValue(&quot;token xxxxxxxxxxxx&quot;, forHTTPHeaderField: &quot;authorization&quot;)
    // set up the session
    let config = URLSessionConfiguration.default
    let session = URLSession(configuration: config)

    let task = session.dataTask(with: urlRequest) {(data, response, error) in
        guard error == nil else {
            print(&quot;error calling GET&quot;)
            return
        }
        // make sure we got data
        guard let responseData = data else {
            print(&quot;Error: did not receive data&quot;)
            return
        }
        DispatchQueue.main.sync {
            do{
                self.weatherInfos = try JSONDecoder().decode([WeatherInfos].self, from: responseData)

                for info in self.weatherAveInfos!{
                    temperature += info.ave_temp
                }
            }catch{
                print(&quot;Error: did not decode&quot;)
                return
            }
        }
        semaphore.signal()
    }
    task.resume()
    semaphore.wait()

    return temperature
}
</code></pre>
<p>JsonModel.swift</p>
<pre><code>struct WeatherInfos:Codable,Identifiable {
    var id: Int
    var ave_temp: Float
}
</code></pre>
<p>Progress.swift</p>
<pre><code>struct Progress: View {
    var body: some View {
        ProgressView(&quot;Loading...&quot;)
    }
}
</code></pre>
<p>MainView.swift</p>
<pre><code>import SwiftUI

struct InformationView: View {

@EnvironmentObject var appState: AppState

    var body: some View {
       if appState.isLoding {
           Progress()
       }
       Button(action:{
            appState.getTemperatureAsync(date: &quot;2020-11-01&quot;)
       }){
            Text(&quot;show progress&quot;)
         }
    }
}
</code></pre>
<hr />
<p>Xcode: Version 12.0.1</p>
<p>iOS: 14.0</p>
","12611330","","1271826","","2020-11-20 22:04:09","2020-11-20 22:04:09","How to publish values from the main thread using DispatchQueue.global().async?","<swiftui><combine><ios14>","2","3","","","","CC BY-SA 4.0"
"64938442","1","64942348","","2020-11-20 23:57:29","","5","3166","<p>I have a custom pipeline where I want to have 3 retry attempt for some error codes which are recoverable plus I want to add some short delay for the recoverable error. Anyone has an idea how I can do it?</p>
<pre><code>func createRequest(for message: Message) -&gt; AnyPublisher&lt;ResponseMessage, Error&gt; {
    Future&lt;ResponseMessage, Error&gt; { promise in
        .....   
    }
    .tryCatch({ error -&gt; AnyPublisher&lt;ResponseMessage, Error&gt; in
        // If error is a recoverable error retry, otherwise fail directly
        if case let MessageBusError.messageError(responseError) = error {
            if responseError.isRecoverable {
                // Make a next attempt only for recoverable error
                throw error
            }
        }
            //Should fail directly if the error code is not recoverable
        return Fail&lt;ResponseMessage, Error&gt;(error: error)
               .eraseToAnyPublisher()

    })
    .retry(3)
    .eraseToAnyPublisher()
}
</code></pre>
","4142753","","","","","2022-03-29 06:40:59","Swift combine retry only for some error types","<ios><swift><combine>","2","0","5","","","CC BY-SA 4.0"
"64946867","1","","","2020-11-21 18:55:01","","0","91","<p><strong>Scenario:</strong> Accessing data (of variable size) from a server and display it.  In this case, an array of countries.</p>
<p>Server access should be <em>called once(1)</em> upon entering this View (or before).</p>
<p><strong>Observation:</strong> I can see the data via debugger &amp; print statements within the publisher.</p>
<p><strong>Problem:</strong> Data doesn't display within View.</p>
<p>The following is the ENTIRE code (reduced to a simple request for an array of countries via playground).</p>
<p>Please feel free to cut/paste into playground. <br/>
It should run as expected, but doesn't display any data.</p>
<p><strong>Solution?</strong></p>
<p>
<pre><code>import Combine
import SwiftUI
import PlaygroundSupport

// ---------------------------------------------------------------------------

var cancellables: Set&lt;AnyCancellable&gt; = []

struct VaccinesDataView: View {
    @State private var appleData: [String]?
    @StateObject var appleCountries = AppleCountries()

    var body: some View {
        Form {
            Section(header: VStack(alignment: .leading) {
                Text(&quot;Apple Data&quot;)
            }) {
                if let vacData = appleData {
                    ForEach(vacData, id: \.self) { source in

                        HStack {
                            Text(source)
                                .font(.title)
                        }
                    }
                }
            }
            .navigationBarTitle(&quot;Vaccines&quot;, displayMode: .inline)
        }.onAppear {
            self.appleCountries.getData()
        }

        .navigationViewStyle(StackNavigationViewStyle())
    }
}

// =====================================================================================================

class AppleCountries: ObservableObject {
    @Published var appleData: [String]?

    func getData() {
        let appleURL = URL(string: &quot;https://disease.sh/v3/covid-19/apple/countries&quot;)!
        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: appleURL)
            .map(\.data)
            .receive(on: DispatchQueue.main)
            .decode(type: [String].self, decoder: JSONDecoder())
            .print(&quot;Apples: &quot;)

        remoteDataPublisher
            .eraseToAnyPublisher()
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    print(&quot;Publisher Finished&quot;)
                case let .failure(anError):
                    Swift.print(&quot;\nReceived error: &quot;, anError)
                }
            }, receiveValue: { someValue in
                self.appleData = someValue
                print(&quot;appleData: \(String(describing: self.appleData))&quot;)
            }).store(in: &amp;cancellables)
    }
}

PlaygroundPage.current.setLiveView(VaccinesDataView())
</code></pre>
<p><strong>Hint:</strong> I notice REPEATED access to server, when I only want one (1). <br/></p>
<p>The server access is via <strong>.onAppear()</strong> which is <em>probably</em> called multiple times.</p>
<pre><code>Apples: : receive subscription: (Decode)
Apples: : request unlimited
Apples: : receive subscription: (Decode)
Apples: : request unlimited
Apples: : receive subscription: (Decode)
Apples: : request unlimited
Apples: : receive subscription: (Decode)
Apples: : request unlimited
Apples: : receive value: ([&quot;Albania&quot;, &quot;Argentina&quot;, &quot;Australia&quot;, &quot;Austria&quot;, &quot;Belgium&quot;, &quot;Brazil&quot;, &quot;Bulgaria&quot;, &quot;Cambodia&quot;, &quot;Canada&quot;, &quot;Chile&quot;, &quot;Colombia&quot;, &quot;Croatia&quot;, &quot;Czechia&quot;, &quot;Denmark&quot;, &quot;Egypt&quot;, &quot;Estonia&quot;, &quot;Finland&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Greece&quot;, &quot;Hong Kong&quot;, &quot;Hungary&quot;, &quot;Iceland&quot;, &quot;India&quot;, &quot;Indonesia&quot;, &quot;Ireland&quot;, &quot;Israel&quot;, &quot;Italy&quot;, &quot;Japan&quot;, &quot;Latvia&quot;, &quot;Lithuania&quot;, &quot;Luxembourg&quot;, &quot;Macao&quot;, &quot;Malaysia&quot;, &quot;Mexico&quot;, &quot;Morocco&quot;, &quot;Netherlands&quot;, &quot;New Zealand&quot;, &quot;Norway&quot;, &quot;Philippines&quot;, &quot;Poland&quot;, &quot;Portugal&quot;, &quot;S. Korea&quot;, &quot;Romania&quot;, &quot;Russia&quot;, &quot;Saudi Arabia&quot;, &quot;Serbia&quot;, &quot;Singapore&quot;, &quot;Slovakia&quot;, &quot;Slovenia&quot;, &quot;South Africa&quot;, &quot;Spain&quot;, &quot;Sweden&quot;, &quot;Switzerland&quot;, &quot;Taiwan&quot;, &quot;Thailand&quot;, &quot;Turkey&quot;, &quot;Ukraine&quot;, &quot;UAE&quot;, &quot;UK&quot;, &quot;USA&quot;, &quot;Uruguay&quot;, &quot;Vietnam&quot;])
appleData: Optional([&quot;Albania&quot;, &quot;Argentina&quot;, &quot;Australia&quot;, &quot;Austria&quot;, &quot;Belgium&quot;, &quot;Brazil&quot;, &quot;Bulgaria&quot;, &quot;Cambodia&quot;, &quot;Canada&quot;, &quot;Chile&quot;, &quot;Colombia&quot;, &quot;Croatia&quot;, &quot;Czechia&quot;, &quot;Denmark&quot;, &quot;Egypt&quot;, &quot;Estonia&quot;, &quot;Finland&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Greece&quot;, &quot;Hong Kong&quot;, &quot;Hungary&quot;, &quot;Iceland&quot;, &quot;India&quot;, &quot;Indonesia&quot;, &quot;Ireland&quot;, &quot;Israel&quot;, &quot;Italy&quot;, &quot;Japan&quot;, &quot;Latvia&quot;, &quot;Lithuania&quot;, &quot;Luxembourg&quot;, &quot;Macao&quot;, &quot;Malaysia&quot;, &quot;Mexico&quot;, &quot;Morocco&quot;, &quot;Netherlands&quot;, &quot;New Zealand&quot;, &quot;Norway&quot;, &quot;Philippines&quot;, &quot;Poland&quot;, &quot;Portugal&quot;, &quot;S. Korea&quot;, &quot;Romania&quot;, &quot;Russia&quot;, &quot;Saudi Arabia&quot;, &quot;Serbia&quot;, &quot;Singapore&quot;, &quot;Slovakia&quot;, &quot;Slovenia&quot;, &quot;South Africa&quot;, &quot;Spain&quot;, &quot;Sweden&quot;, &quot;Switzerland&quot;, &quot;Taiwan&quot;, &quot;Thailand&quot;, &quot;Turkey&quot;, &quot;Ukraine&quot;, &quot;UAE&quot;, &quot;UK&quot;, &quot;USA&quot;, &quot;Uruguay&quot;, &quot;Vietnam&quot;])
Apples: : receive finished
Publisher Finished
Apples: : receive value: ([&quot;Albania&quot;, &quot;Argentina&quot;, &quot;Australia&quot;, &quot;Austria&quot;, &quot;Belgium&quot;, &quot;Brazil&quot;, &quot;Bulgaria&quot;, &quot;Cambodia&quot;, &quot;Canada&quot;, &quot;Chile&quot;, &quot;Colombia&quot;, &quot;Croatia&quot;, &quot;Czechia&quot;, &quot;Denmark&quot;, &quot;Egypt&quot;, &quot;Estonia&quot;, &quot;Finland&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Greece&quot;, &quot;Hong Kong&quot;, &quot;Hungary&quot;, &quot;Iceland&quot;, &quot;India&quot;, &quot;Indonesia&quot;, &quot;Ireland&quot;, &quot;Israel&quot;, &quot;Italy&quot;, &quot;Japan&quot;, &quot;Latvia&quot;, &quot;Lithuania&quot;, &quot;Luxembourg&quot;, &quot;Macao&quot;, &quot;Malaysia&quot;, &quot;Mexico&quot;, &quot;Morocco&quot;, &quot;Netherlands&quot;, &quot;New Zealand&quot;, &quot;Norway&quot;, &quot;Philippines&quot;, &quot;Poland&quot;, &quot;Portugal&quot;, &quot;S. Korea&quot;, &quot;Romania&quot;, &quot;Russia&quot;, &quot;Saudi Arabia&quot;, &quot;Serbia&quot;, &quot;Singapore&quot;, &quot;Slovakia&quot;, &quot;Slovenia&quot;, &quot;South Africa&quot;, &quot;Spain&quot;, &quot;Sweden&quot;, &quot;Switzerland&quot;, &quot;Taiwan&quot;, &quot;Thailand&quot;, &quot;Turkey&quot;, &quot;Ukraine&quot;, &quot;UAE&quot;, &quot;UK&quot;, &quot;USA&quot;, &quot;Uruguay&quot;, &quot;Vietnam&quot;])
appleData: Optional([&quot;Albania&quot;, &quot;Argentina&quot;, &quot;Australia&quot;, &quot;Austria&quot;, &quot;Belgium&quot;, &quot;Brazil&quot;, &quot;Bulgaria&quot;, &quot;Cambodia&quot;, &quot;Canada&quot;, &quot;Chile&quot;, &quot;Colombia&quot;, &quot;Croatia&quot;, &quot;Czechia&quot;, &quot;Denmark&quot;, &quot;Egypt&quot;, &quot;Estonia&quot;, &quot;Finland&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Greece&quot;, &quot;Hong Kong&quot;, &quot;Hungary&quot;, &quot;Iceland&quot;, &quot;India&quot;, &quot;Indonesia&quot;, &quot;Ireland&quot;, &quot;Israel&quot;, &quot;Italy&quot;, &quot;Japan&quot;, &quot;Latvia&quot;, &quot;Lithuania&quot;, &quot;Luxembourg&quot;, &quot;Macao&quot;, &quot;Malaysia&quot;, &quot;Mexico&quot;, &quot;Morocco&quot;, &quot;Netherlands&quot;, &quot;New Zealand&quot;, &quot;Norway&quot;, &quot;Philippines&quot;, &quot;Poland&quot;, &quot;Portugal&quot;, &quot;S. Korea&quot;, &quot;Romania&quot;, &quot;Russia&quot;, &quot;Saudi Arabia&quot;, &quot;Serbia&quot;, &quot;Singapore&quot;, &quot;Slovakia&quot;, &quot;Slovenia&quot;, &quot;South Africa&quot;, &quot;Spain&quot;, &quot;Sweden&quot;, &quot;Switzerland&quot;, &quot;Taiwan&quot;, &quot;Thailand&quot;, &quot;Turkey&quot;, &quot;Ukraine&quot;, &quot;UAE&quot;, &quot;UK&quot;, &quot;USA&quot;, &quot;Uruguay&quot;, &quot;Vietnam&quot;])
Apples: : receive finished
Publisher Finished
...
...
...
</code></pre>
","715747","","715747","","2020-11-21 19:18:13","2020-11-21 19:18:13","SwiftUI: How can I get server data to display?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"64948720","1","64949874","","2020-11-21 22:26:29","","1","1011","<p>I am not able to bind the bookName from my Core Data object to a TextField inside a ForEach loop. How can I get this binding to work? I want the bookName value to be saved to Core Data when it changes.</p>
<p>I am receiving an error that says: Cannot find $book in scope.</p>
<pre><code>extension Book: Identifiable {
                @nonobjc public class func fetchRequest() -&gt; NSFetchRequest&lt;Book&gt; {
                    return NSFetchRequest&lt;Book&gt;(entityName: &quot;Book&quot;)
                }
                
                @NSManaged public var id: UUID?
                @NSManaged public var bookName: String?
                
                var wrappedBookName: String {
                    bookName ?? &quot;&quot;
                }
           }    
            
    struct BookListView: View {
            @FetchRequest(entity: Book.entity(), sortDescriptors: [NSSortDescriptor(keyPath: \Book.rankNumber, ascending: false)]) var books: FetchedResults&lt;Book&gt;
                
                 var body: some View {
                    ForEach(books) { book in
                       TextField(&quot;Book Name&quot;, text: $book.bookName)  //Error: cannot find $book in scope
                    }
                 }
    }
</code></pre>
","618916","","","","","2020-11-22 01:40:35","SwiftUI Bind to core data object inside foreach","<core-data><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"64957228","1","64957540","","2020-11-22 17:23:04","","4","4329","<p>I have following RxSwift view model code:</p>
<pre><code>private(set) var num = BehaviorRelay&lt;Int&gt;(value: 1)
private let indexTrigger = PublishRelay&lt;Int&gt;()
private let disposeBag = DisposeBag()

private func setupBindings() {
   //...
   self.num.distinctUntilChanged().bind(to: self.indexTrigger).disposed(by: self.disposeBag)
}

func numSelected(num: Int) {
   self.num.accept(num)
}

</code></pre>
<p>This code is working fine and does what I want. I'm trying to do same, but with swift Combine framework with following code:</p>
<pre><code>@Published private(set) var num: Int = 1
private let indexTrigger = PassthroughSubject&lt;Int, Never&gt;()
private var subscriptions = Set&lt;AnyCancellable&gt;()

private func setupBindings() {
   //...
   self.$num.removeDuplicates().sink(receiveValue: { [weak self] num in
      self.indexTrigger.send(num)
   }).store(in: &amp;self.subscriptions)
}

func numSelected(num: Int) {
   self.num = num
}
</code></pre>
<p>So RxSwift binding looks much clean and simple and without need of weak. I tried to check <code>assign(on:)</code> method in combine, but seems it is not the one. Is there way to do same thing?</p>
","1246675","","","","","2020-11-22 17:52:17","Combine assign publisher to PassthroughSubject","<ios><swift><rx-swift><combine>","1","5","","","","CC BY-SA 4.0"
"64958288","1","","","2020-11-22 19:02:37","","0","51","<p><strong>Goal:</strong> to pre-populate a SwiftUI View with data to display once the View is activated.  <br/> <strong>Note:</strong> these children Views are accessed via the Navigator Link as separate, distinct views.</p>
<p><strong>Reality:</strong> I had to create a <em>button to locally change the View status</em> in order to display the available data.  <br/>I prefer it to be automatically population prior to user activity.</p>
<p><strong>Question:</strong> How do I implement a local imperative paradigm of forcing the target SwiftUI View to display the available data? <br/>
(i.e. a boiler-plate code to make pre-loading data seen in target views.)</p>
<p><strong>Observation:</strong> the target SwiftUIView (and siblings) have already been instantiated before the server-supplied data is available when SwiftUIView is actually activated for viewing.</p>
<p><a href=""https://i.stack.imgur.com/txXw2.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/txXw2.png"" alt=""enter image description here"" /></a></p>
","715747","","715747","","2020-11-22 19:06:23","2020-11-23 18:08:32","How do I force a SwiftUIView to display pre-loaded data without requiring user to manually alter its state?","<swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"64975317","1","64976195","","2020-11-23 19:45:57","","0","524","<p>I want to perform an API call whenever a user types 3 or more letters into a search field.</p>
<p>I finally got it to work, but unfortunately when I turned off and on the server it turned out that the <code>Publisher</code> terminates upon the first error and when user types text into the search field again no API call is made.</p>
<p>I watched the WWDC 2019 videos on <code>Combine</code> and read a few blog posts, but it seems that <code>Combine API</code> changes quite often, every source does everything differently, and when I tinker around it the compiler often throws useless errors like <code>Fix: Replace type X with type X</code> (see screenshot)</p>
<p><a href=""https://i.stack.imgur.com/AOM3c.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/AOM3c.png"" alt=""enter image description here"" /></a></p>
<p>PS: I know I can use <code>filter</code> to filter out queries shorter than 3 letters, but I somehow couldn't get the publishers and types to work.. I feel like I am missing something fundamental on <code>Combine</code>...</p>
<p>Here is the code:</p>
<p>DictionaryService.swift</p>
<pre><code>class DictionaryService {

    func searchMatchesPublisher(_ query: String,
                                inLangSymbol: String,
                                outLangSymbol: String,
                                offset: Int = 0,
                                limit: Int = 20) -&gt; AnyPublisher&lt;[TranslationMatch], Error&gt; {
        
    ...
}
</code></pre>
<p>DictionarySearchViewModel.swift</p>
<pre><code>class DictionarySearchViewModel: ObservableObject {
    @Published var inLang = &quot;de&quot;
    @Published var outLang = &quot;en&quot;
    
    @Published var translationMatches = [TranslationMatch]()
    @Published var text: String = &quot;&quot;
    
    private var cancellable: AnyCancellable? = nil
    
    init() {
        cancellable = $text
            .debounce(for: .seconds(0.2), scheduler: DispatchQueue.main)
            .removeDuplicates()
            .map { [self] queryText -&gt; AnyPublisher&lt;[TranslationMatch], Error&gt; in
                if queryText.count &lt; 3 {
                    return Future&lt;[TranslationMatch], Error&gt; { promise in
                        promise(.success([TranslationMatch]()))
                    }
                    .eraseToAnyPublisher()
                } else {
                    return DictionaryService.sharedInstance()
                        .searchMatchesPublisher(queryText, inLangSymbol: self.inLang, outLangSymbol: self.outLang)
                }
            }
            .switchToLatest()
            .eraseToAnyPublisher()
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)
            .assign(to: \.translationMatches, on: self)
    }
}
</code></pre>
","659389","","659389","","2020-11-24 10:00:41","2020-11-24 10:00:41","SwiftUI + Combine - Publisher terminates upon first error","<ios><swift><swiftui><reactive-programming><combine>","2","5","","","","CC BY-SA 4.0"
"64976084","1","65010017","","2020-11-23 20:40:10","","1","3782","<p>How can you have different return types for a flatMap when using Swift Combine? I have my first publisher, which emits a value and then I flatMap that to transform it into a new publisher. However, based on the original value, I might need to have a different publisher that returns a different type.</p>
<p>I've added a basic example below.</p>
<pre><code>import Combine


class Testing{
    var subscriptions = Set&lt;AnyCancellable&gt;()
    
    
    func getTestScore()-&gt;AnyPublisher&lt;Int, Never&gt;{
        return Just(80).eraseToAnyPublisher()
    }
    
    func congratulate()-&gt;AnyPublisher&lt;String, Never&gt;{
        return Just(&quot;Good Job!&quot;).eraseToAnyPublisher()
    }
    
    func getGPA()-&gt;AnyPublisher&lt;Double, Never&gt;{
        return Just(2.2).eraseToAnyPublisher()
    }
    
    init() {
        getTestScore()
            .flatMap{ score in
                if score &lt; 70{
                    return self.getGPA()
                } else{
                    return self.congratulate()
                }
            }
            .sink { _ in } receiveValue: { value in
                print(value)
            }.store(in: &amp;subscriptions)
    }
}

let testing = Testing()

</code></pre>
","10830089","","","","","2022-06-05 15:10:26","Swift Combine Conditional FlatMap Results","<swift><conditional-statements><combine><flatmap>","2","5","1","","","CC BY-SA 4.0"
"64981458","1","64981955","","2020-11-24 06:46:31","","3","164","<p>I got this sample code about ObservableObject from <a href=""https://developer.apple.com/documentation/combine/observableobject"" rel=""nofollow noreferrer"">Apple official website</a></p>
<pre><code>import Foundation

class Contact: ObservableObject {
    @Published var name: String
    @Published var age: Int
    
    
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    
    func changeAge() -&gt; Int {
        self.age += 1
        return self.age
    }
}



class Test {
    init() {
        let john = Contact(name: &quot;John Appleseed&quot;, age: 24)
        _ = john.objectWillChange
            .sink { _ in
                print(&quot;\(john.age) will change&quot;)
        }
        print(john.changeAge())
    }
}

let test = Test()
</code></pre>
<p>When running on terminal by <code>swift Contact.swift</code>, the result is only <code>25</code>, but official website shows the result should be</p>
<pre><code>// Prints &quot;24 will change&quot;
// Prints &quot;25&quot;
</code></pre>
<p>Why the first line <code>Prints &quot;24 will change&quot;</code> is not shown?</p>
<p>Thank you.</p>
","9355534","","","","","2020-11-24 07:28:29","Why objectWillChange has no effect","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"64991368","1","","","2020-11-24 17:05:03","","0","98","<p>I'm trying to reference an environment object in a SwiftUI view initializer to set up a state value, but I'm getting an error <code>'self' used before all stored properties are initialized</code>. Is there a way to do this at all as you need to reference self to access the environment object? I feel like referencing an inherited value is something you should be able to do in a view's construction.</p>
<pre><code>struct Example: View {
 
  @EnvironmentObject var object: Items
  @State var ints: Array&lt;Int&gt;
  
  init() {
    self._ints = State(initialValue: Array(repeating: 0, count: self.object.items.count))
  }
}
</code></pre>
","5605633","","","","","2020-11-24 17:10:43","Error referencing EnvironmentObject in view initializer","<constructor><swiftui><state><combine><environmentobject>","1","0","","","","CC BY-SA 4.0"
"65010016","1","","","2020-11-25 17:40:35","","0","229","<p>I have a situation where I am using <code>LazyVGrid</code> to display Images from a users Photo library. The grid has sections, and each section contains an array of images which are to be displayed, along with some meta data about the section.</p>
<p>The problem I am having is that each time the user clicks on a tile, which toggles <code>markedForDeletion</code> in the corresponding Image, <strong>all of the views in the Grid (which are visible) redraw.</strong> This isn't ideal, as in the &quot;real&quot; version of the sample code there is a real penalty to redrawing each <code>Tile</code>, as images must be retrieved and rendered.</p>
<p>I have tried to make <code>Tile</code> conform to <code>Equatable</code>, and then use the <code>.equatable()</code> modifier to notify SwiftUI that the Tile shouldn't be redrawn, but this doesn't work.</p>
<p>Placing another <code>.onAppear</code> outside the <code>Section</code> hints that the entire section is being redrawn each time anything changes, but I'm not sure how to structure my code so that the impact of redrawing expensive <code>Tiles</code> is minimised.</p>
<pre><code>import SwiftUI

struct ContentView: View {
    
    @ObservedObject var viewModel: ViewModel = ViewModel()
    
    let columns = [
        GridItem(.flexible(minimum: 40), spacing: 0),
        GridItem(.flexible(minimum: 40), spacing: 0),
    ]
    
    var body: some View {
        
        GeometryReader { gr in
            ScrollView {
                LazyVGrid(columns: columns) {
                    ForEach(viewModel.imageSections.indices, id: \.self) { imageSection in
                        Section(header: Text(&quot;Section!&quot;)) {
                            ForEach(viewModel.imageSections[imageSection].images.indices, id: \.self) { imageIndex in
                                Tile(image: viewModel.imageSections[imageSection].images[imageIndex])
                                    .equatable()
                                    .onTapGesture {
                                        viewModel.imageSections[imageSection].images[imageIndex].markedForDeletion.toggle()
                                    }
                                    .overlay(Color.blue.opacity(viewModel.imageSections[imageSection].images[imageIndex].markedForDeletion ? 0.2 : 0))
                                
                                    .id(UUID())
                            }
                        }
                    }
                }
            }
        }
        
    }
}


struct Image {
    
    var id: String = UUID().uuidString
    var someData: String
    var markedForDeletion: Bool = false
    
}

struct ImageSection {
    
    var id: String = UUID().uuidString
    var images: [Image]
    
    
}

class ViewModel: ObservableObject {
    
    @Published var imageSections: [ImageSection] = generateFakeData(numSections: 10, numImages: 10)
    
}

func generateFakeData(numSections: Int, numImages: Int) -&gt; [ImageSection] {
    
    var sectionsToReturn: [ImageSection] = []
    
    for _ in 0 ..&lt; numSections {
        var imageArray: [Image] = []
        
        for i in 0 ..&lt; numImages {
            imageArray.append(Image(someData: &quot;Data \(i)&quot;))
        }
        
        sectionsToReturn.append(ImageSection(images: imageArray))
    }
    
    return sectionsToReturn
}

struct Tile: View, Equatable {
    
    static func == (lhs: Tile, rhs: Tile) -&gt; Bool {
        
        return lhs.image.id == rhs.image.id
    }
    
    
    var image: Image
    
    var body: some View {
        
        Text(image.someData)
            .background(RoundedRectangle(cornerRadius: 20).fill(Color.blue))
        
            .onAppear(perform: {
                NSLog(&quot;Appeared - \(image.id)&quot;)
            })
        
    }
    
}

</code></pre>
","11826694","","","","","2020-11-25 18:15:45","Make view not redraw after updating ObservableObject","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65018290","1","","","2020-11-26 08:17:39","","0","1277","<p>I'm trying to merge multiple Futures with combine and I'm out of luck so far. I'm trying using Publishers.MergeMany similar to this.</p>
<pre><code>let f = Future&lt;Void, Error&gt; { promise in
   promise(.success(Void()))
}

let g = Future&lt;Void, Error&gt; { promise in
  promise(.success(Void()))
}

var subscriptions = Set&lt;AnyCancellable&gt;()

Publishers.MergeMany([f,g]).collect()
.sink { _ in
    print(&quot;merge&quot;)
} receiveValue: { value in
    print(&quot;done&quot;)
}.store(in: &amp;subscriptions)
</code></pre>
<p>For some reason on my real case scenario, only the first publisher finish but the other one get stuck in oblivion.</p>
<p>If a call each Future one by one sequentially, all works fine.</p>
<p>Does anybody had an issue like this before?</p>
","12668593","","12668593","","2020-11-26 10:45:04","2020-11-26 10:45:04","Swift Combine - Merging multiple Futures","<ios><swift><combine>","0","6","1","","","CC BY-SA 4.0"
"65024144","1","65024734","","2020-11-26 14:38:50","","0","61","<p>I have a game written with SwiftUI with two classes, a Game class to manage the game, and a ScoreStore class that manages an array of high scores. Currently the score of a game is stored (via a function on ScoreStore) when the user presses a button (displayed in the ContentView struct) to start a new game. I want to have the score saved when a game reaches a certain state (considered here to be a certain score).</p>
<p>Both Game and ScoreStore are ObservableObjects and have @Published properties available to ContentView as @EnvironmentObjects. Within Game, score is not @Published because it is a computed property.</p>
<pre><code>class Game: ObservableObject, Codable {
    
    var deck: [Card] = []
    
    @Published var piles: [[Card]] = [[],[],[],[]] 

    var score: Int {
        let fullDeckCount = 52
        var cardsOnThePiles = 0
        for pile in piles {
            cardsOnThePiles += pile.count
        }
        return fullDeckCount - deck.count - cardsOnThePiles
    }

</code></pre>
<pre><code>class ScoresStore: Codable, ObservableObject, Identifiable {
    
    @Published var highScores: [Score] = []
    
    func addScore(newScore: Int, date: Date = Date()) {
        // Do things to add the score to the array
}
        
</code></pre>
<pre><code>struct ContentView: View {
    @EnvironmentObject var game: Game
    @EnvironmentObject var scores: ScoresStore

func saveScore() {
        scores.addScore(newScore: game.score)
    }
    
var body: some View {
    Button(action: { saveScore }) {
        Text(&quot;New Game?&quot;)
    }
}
</code></pre>
<p>I've looked at questions whose answers reference binding via a @State property but in this case the property I'm &quot;observing&quot; is in Game (not ContentView).</p>
<p>Thanks in advance!</p>
","13648289","","4667835","","2020-11-26 14:43:06","2020-11-26 15:14:53","How do I execute a function on ClassB when something changes in ClassA?","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65048095","1","","","2020-11-28 09:22:21","","0","233","<p>How to write custom operator for Publisher which would include <strong>compactMap</strong> and <strong>tryMap</strong> operators?
As result I would like to have one method <strong>tryMyMap</strong> which will cover compactMap and tryMap operators.</p>
<p>Below is simplified example what I want to achieve.</p>
<pre><code>struct My: Codable {
    let value: Int
}

let json1 = &quot;{ \&quot;value\&quot;: 1 }&quot;
let json2 = &quot;{ \&quot;value\&quot;: 2 }&quot;

var array = [json1, json2].publisher


array
    .compactMap { Data($0.utf8) }   // 1: Converts String to Data
    .tryMap { try JSONDecoder().decode(My.self, from: $0) } // 2: Decodes data to My class
    .sink { (error) in
        print(error)
    } receiveValue: { (my) in
        print(my)
    }
</code></pre>
<p>I tried many things. Bellow one of them:</p>
<pre><code>extension Publisher {
    func tryMyMap&lt;T&gt;(_ transform: @escaping (My) throws -&gt; T) -&gt; Publishers.TryMap&lt;Self, My&gt; {
        tryMap {
            let d = try transform($0 as! My)
            let dd = My(value: $0)

        }
    }
}
</code></pre>
","1151916","","","","","2020-11-28 09:22:21","How to write custom operator for Publisher?","<swift><combine>","0","2","","","","CC BY-SA 4.0"
"65053108","1","","","2020-11-28 18:26:13","","0","167","<p><strong>Goal:</strong> I want to make a <strong>dataTaskPublisher</strong> generator that any subscriber can access.</p>
<p>I would like to a create function that <em>returns a publisher</em> for use by a general-purpose subscriber.   Something like:</p>
<pre><code>let remoteDataPublisher = generatedPublisher(url: &lt;http://....&gt;) 
</code></pre>
<p>Here's what I envision for the function:</p>
<pre><code>struct model: Codable {
}
    
func generalPublisher(url: URL) -&gt; URLSession.DataTaskPublisher  {
        let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: url)
                        .map(\.data)
                        .receive(on: DispatchQueue.main)
                        .decode(type: model.self, decoder: JSONDecoder())

         return remoteDataPublisher

    }
</code></pre>
<p>Here's the subscriber: <p></p>
<pre><code>remoteDataPublisher
                    .eraseToAnyPublisher()
                    .sink(receiveCompletion: { completion in
                        switch completion {
                        case .finished:
                            print(&quot;Publisher Finished&quot;)
                        case let .failure(anError):
                            Swift.print(&quot;\n(GovernmentCountryDataList: \(country) Received error: #function&quot;, anError)
                        }
                    }, receiveValue: { someValue in
                        SingletonData.shared.governmentCountryDataList = someValue
                        print(&quot;GovernmentCountryDataList: \(country)&quot;)
                        print(SingletonData.shared.governmentCountryDataList ?? &quot;No Data for \(country)&quot;)
                        NotificationCenter.default.post(name: NSNotification.Name(rawValue: &quot;noteName&quot;), object: DataModelType.GovernmentCountryDataList(country: country))
                    }).store(in: &amp;cancellables)
</code></pre>
<p>Here's the compiler error:</p>
<p><a href=""https://i.stack.imgur.com/VGF9J.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VGF9J.png"" alt=""enter image description here"" /></a></p>
<p><strong>Question:</strong> What's the function's correct return-value Syntax/Data Type? <br/> Remedy?</p>
","715747","","715747","","2020-11-28 18:53:43","2020-11-29 05:30:40","DataTaskPublisher Generator: What would be the correct function return type?","<ios><combine>","1","0","0","","","CC BY-SA 4.0"
"65065623","1","","","2020-11-29 21:55:18","","0","103","<p>I'm having issues trying to understand combine and publishers. I have a PhotoPicker that selects one ore more images from the photo library. These images should be added to my core data model. This is handled in my model class.</p>
<p>However, I ends up in an infinit loop that I don't understand. The View keeps updating and the onReceive method keeps executing over and over again making the View render again. Below is a sample code (without core data) that behaves the same</p>
<p>Sample code:</p>
<pre><code>struct MyImage: Hashable {
    var id: String
    var uiImage: UIImage
}

class Model: ObservableObject {
    
    @Published var images: [MyImage] = []
    
    func add(uiImage: UIImage) {
        let id = UUID().uuidString
        let image = MyImage(id: id, uiImage: uiImage)
        self.images.append(image)
    }
    
}

struct ContentView: View {
    
    @StateObject var model = Model()
    
    @State var showPhotoPicker = false
    @State var pickerResult: [UIImage] = []
    
    var body: some View {
        
        VStack {
            
            ForEach(model.images, id: \.self) { image in
                Text(image.id)
            }
            
            Button(action: { showPhotoPicker.toggle() }) {
                Text(&quot;ADD&quot;)
            }
            .fullScreenCover(isPresented: $showPhotoPicker) {
                let config = PHPickerConfiguration(photoLibrary: PHPhotoLibrary.shared())
                PhotoPicker(configuration: config, pickerResult: $pickerResult)
            }
            
        }
        
        .onReceive(pickerResult.publisher, perform: { image in
            model.add(uiImage: image)
        })
    }
}

struct PhotoPicker: UIViewControllerRepresentable {
    
    @Environment(\.presentationMode)
    var presentationMode
    
    let configuration: PHPickerConfiguration
    
    @Binding var pickerResult: [UIImage]
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(self)
    }
    
    func makeUIViewController(context: Context) -&gt; PHPickerViewController {
        let controller = PHPickerViewController(configuration: configuration)
        controller.delegate = context.coordinator
        return controller
    }
    
    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {
        
    }
    
    class Coordinator: PHPickerViewControllerDelegate {
      
        private let parent: PhotoPicker
        
        init(_ parent: PhotoPicker) {
            self.parent = parent
        }
        
        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            
            self.parent.pickerResult = []
            
            results.forEach { (image) in
                
                if image.itemProvider.canLoadObject(ofClass: UIImage.self)  {
                    image.itemProvider.loadObject(ofClass: UIImage.self) { (newImage, error) in
                        if let error = error {
                            print(error.localizedDescription)
                        } else {
                            self.parent.pickerResult.append(newImage as! UIImage)
                        }
                    }
                    
                } else {
                    print(&quot;Loaded Assest is not a Image&quot;)
                }
            }
            
            self.parent.presentationMode.wrappedValue.dismiss()
            
        }
        
    }
    
}
</code></pre>
<p>Can someone explain what is happening?</p>
","578945","","578945","","2020-11-30 07:43:36","2020-12-05 19:06:54","Why keeps View updating when adding photos from photo picker to my model in SwiftUI?","<swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"65066854","1","","","2020-11-30 00:59:22","","0","1433","<p>I was looking at some Apple Combine source code and saw a Publisher name <code>MergeMany</code> with an init method defined like this:</p>
<pre class=""lang-swift prettyprint-override""><code>public init(_ upstream: Upstream...)
</code></pre>
<p>What are the three dots <code>...</code> after the <code>Upstream</code>? The value of <code>Upstream</code> is just another publisher as defined in the Struct definition.</p>
<pre class=""lang-swift prettyprint-override""><code>public struct MergeMany&lt;Upstream&gt; : Publisher where Upstream : Publisher {
</code></pre>
","4576323","","","","","2020-11-30 01:32:05","Three dots in Swift init method","<swift><init><combine>","1","1","","","","CC BY-SA 4.0"
"65071408","1","","","2020-11-30 09:59:15","","0","519","<p>The API I'm making calls to can return JSON containing error message.</p>
<p>How can I tell <code>Combine</code> to try and decode this custom error if I'm expecting another <code>Decodable</code> object to be returned on successful request?</p>
<p>My code currently looks like this:</p>
<pre><code>    private var cancellable: AnyCancellable?

    internal func perform&lt;T&gt;(request: URLRequest, completion: @escaping (Result&lt;T, Error&gt;) -&gt; Void) where T: Decodable {
            cancellable = session.dataTaskPublisher(for: request)
                .tryMap { output in
                    guard let response = output.response as? HTTPURLResponse, response.statusCode == 200 else {
                        throw HTTPError.statusCode
                    }
                    return output.data
                }
                .decode(type: T.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
                .sink(receiveCompletion: { _completion in
                    guard case .failure(let error) = _completion else {
                        return
                    }
                    completion(.failure(error))
                }, receiveValue: { value in
                    completion(.success(value))
                })
}
</code></pre>
<p>With <code>URLSession</code> I would do something like this:</p>
<pre><code>URLSession.shared.dataTask(with: request) { data, response, error in
    // Check for any connection errors
    if let error = error {
        completion(.failure(error))
        return
    }
    // Read data
    guard let data = data, !data.isEmpty else {
        completion(.failure(SPTError.noDataReceivedError))
        return
    }
    // Check response's status code, if it's anything other than 200 (OK), try to decode SPTError from the data.
    guard let httpResponse = response as? HTTPURLResponse,
          httpResponse.statusCode == 200 else {
        let sptError = (try? JSONDecoder().decode(SPTError.self, from: data)) ?? SPTError.badRequest
        completion(.failure(sptError))
        return
    }
    // Decode requested objects
    do {
        let object = try JSONDecoder().decode(T.self, from: data)
        completion(.success(object))
    } catch {
        print(completion(.failure(error)))
    }
}.resume()
</code></pre>
<p><code>SPTError</code> is just a struct that contains code and message, it conforms to <code>Codable</code></p>
","7235585","","","","","2020-11-30 18:56:07","How can I decode custom Error with Combine?","<ios><swift><nsurlsession><combine><urlsession>","1","2","","","","CC BY-SA 4.0"
"65072163","1","65072289","","2020-11-30 10:51:23","","3","1153","<p>I am trying to use 2 publishers and have them stream to 1 publisher that is mapped from both values.</p>
<p>My code is:</p>
<pre><code>class ViewModel {

    let email = CurrentValueSubject&lt;String, Never&gt;(&quot;&quot;)

    lazy var isEmailValid = email.map { self.validateEmail(email: $0) }

    let password = CurrentValueSubject&lt;String, Never&gt;(&quot;&quot;)

    lazy var isPasswordCorrect = password.map {
        self.validatePassword(password: $0)
    }

    let canLogin: CurrentValueSubject&lt;Bool, Never&gt;

    private func validateEmail(email: String) -&gt; Bool {
        return email == &quot;1234@gmail.com&quot;
    }

    private func validatePassword(password: String) -&gt; Bool {
        return password == &quot;1234&quot;
    }


    init() {
    
        canLogin = Publishers
            .CombineLatest(isEmailValid, isPasswordCorrect)
            .map { $0 &amp;&amp; $1 } 

    }
}
</code></pre>
<p>Then in the init I get this error:</p>
<pre><code>    //error: Cannot assign value of type 
'Publishers.Map&lt;Publishers.CombineLatest&lt;Publishers.Map&lt;CurrentValueSubject&lt;String, Never&gt;, 
Bool&gt;, Publishers.Map&lt;CurrentValueSubject&lt;String, Never&gt;, Bool&gt;&gt;, Bool&gt;' to type 'CurrentValueSubject&lt;Bool, Never&gt;'
</code></pre>
<p>I am new to combine so I find it a little confusing.
How should I achieve, from the code above, the combination of 2 publishers isEmailValid and isPasswordCorrect, into 1 publisher that is a CurrentValueSubject&lt;Bool, Never&gt;?</p>
","5784052","","","","","2020-11-30 11:02:03","how to use Publishers.CombineLatest to get 1 publisher","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"65079961","1","","","2020-11-30 19:30:23","","0","43","<p><strong>Scenario:</strong> I'm trying to use less post-data processing versus in-stream filtering.<br/>
I want to filter out zeroed items from a long data stream (array).</p>
<p><strong>Problem:</strong> I don't know how to read the '$0' placeholder to determine the available elements to filter.</p>
<p>Here's what I'm getting:
<a href=""https://i.stack.imgur.com/vyRt5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vyRt5.png"" alt=""enter image description here"" /></a></p>
<p>
Here's a code snippet:
<pre><code>struct CanadaDataListElement: Codable {
    let updated: Int
    let province: String
    let date: String
    let todayCases, todayTests, todayRecovered, todayDeaths: Int
    let cases, active, tests, recovered: Int
    let deaths: Int
}

typealias CanadaDataList = [CanadaDataListElement]

...

func getData() {
    let str = &quot;https://disease.sh/v3/covid-19/gov/Canada?allowNull=false&quot;
    let url = URL(string: str)!
    let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: url)
        .map(\.data)
        .receive(on: DispatchQueue.main)
        .filter { $0.CanadaDataListElement.tests != 0 }
        .decode(type: CanadaDataList.self, decoder: JSONDecoder())
      ...
</code></pre>
<p>
I looks like the filter is working on raw data, hence this may not be the right place for it.
<p>So I moved the .filter <em>to after the</em> <strong>.decode</strong>.
<br/>
I put in an index of '1' to see if I got anything.</p>
<p><a href=""https://i.stack.imgur.com/HgkPT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/HgkPT.png"" alt=""enter image description here"" /></a></p>
<p>
This should be an easy fix once I know the correct syntax for filtering out data with a zeroed member.
<p>Here's some of the data.  There are a lot of elements; hence I want to filter out ones with zero (0) cases (and/or) tests.</p>
<pre><code>(lldb) po someValue 
▿ 4017 elements
  ▿ 0 : CanadaDataListElement
    - updated : 1606752145723
    - province : &quot;Ontario&quot;
    - date : &quot;31-01-2020&quot;
    - todayCases : 3
    - todayTests : 0
    - todayRecovered : 0
    - todayDeaths : 0
    - cases : 3
    - active : 3
    - tests : 0
    - recovered : 0
    - deaths : 0
  ▿ 1 : CanadaDataListElement
  ...
</code></pre>
<p><strong>Question:</strong> What is the correct syntax for filter data per element value?</p>
","715747","","715747","","2020-11-30 20:02:10","2020-11-30 20:02:10","What is the syntax of filtering an array per element value?","<ios><combine>","1","1","","","","CC BY-SA 4.0"
"65082713","1","65084641","","2020-11-30 23:38:46","","2","118","<p>Whenever the value of the <code>@State</code> variable <code>myData</code> changes I would like to be notified and store that data in an <code>@AppStorage</code> variable <code>myStoredData</code>.  However, I don't want to have to write explicitly this storing code everywhere the state var is changed, I would like to associate a block of code with it that gets notified whenever the state var changes and performs storage.  The reason for this is, for example, I want to pass the state var as a binding to another view, and when that view would change the variable, the storage block would automatically be executed.  How can I do this/can I do this in SwiftUI?</p>
<pre><code>struct MyView : View {
  @AppStorage(&quot;my-data&quot;) var myStoredData : Data!
  @State var myData : [String] = [&quot;hello&quot;,&quot;world&quot;]
  var body : some View {
    Button(action: {
      myData = [&quot;something&quot;,&quot;else&quot;]
      myStoredData = try? JSONEncoder().encode(myData)
    }) {
      Text(&quot;Store data when button pressed&quot;)
    }
    .onAppear {
        myData = (try? JSONDecoder().decode([String].self, from: myStoredData)) ?? []
    }
  }
}
</code></pre>
<p>I'm looking for something like this, but this does not work:</p>
<pre><code>@State var myData : [String] = [&quot;hello&quot;,&quot;world&quot;] {
  didSet {
    myStoredData = try? JSONEncoder().encode(myData)
  }
}
</code></pre>
<pre><code></code></pre>
","213563","","213563","","2020-12-01 00:35:43","2020-12-01 04:15:14","How to associate a block of code with a @State var when it changes","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"65123979","1","","","2020-12-03 10:17:50","","0","159","<p>I would like to know how to pass my published values from UserSettings to my ThirdView only when the buttons on the secondView are selected..</p>
<p>I need to published values to be displayed in a text on the thirdView when overlay is selected and then not show when overlay isn't on.</p>
<p>Is this even possible?? I have been trying for three weeks but can't seem to make it work. I can pass one but I can't seem to show more or delete it when overlay is not on.</p>
<p>Thanks in advance.</p>
<p><strong>UserSettings</strong></p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class UserSettings: ObservableObject {

    @Published var username: String {
        didSet {
            UserDefaults.standard.set(username, forKey: &quot;username&quot;)
        }
    }

    @Published var email: String {
        didSet {
            UserDefaults.standard.set(email, forKey: &quot;email&quot;)
        }
    }

    @Published var firstname: String {
        didSet {
            UserDefaults.standard.set(firstname, forKey: &quot;firstname&quot;)
        }
    }

    init() {
        self.username = UserDefaults.standard.object(forKey: &quot;username&quot;) as? String ?? &quot;&quot;
        self.email = UserDefaults.standard.object(forKey: &quot;email&quot;) as? String ?? &quot;&quot;
        self.firstname = UserDefaults.standard.object(forKey: &quot;firstname&quot;) as? String ?? &quot;&quot;
    } 
}
</code></pre>
<p><strong>ContentView</strong></p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct ContentView: View {
    
    @ObservedObject var userSettings = UserSettings()
    
    var body: some View {
        
        NavigationView {
            VStack {
                HStack {
                    Text(&quot;username&quot;)
                    TextField(&quot;Enter userNmae&quot;, text: $userSettings.username)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                }
                HStack {
                    Text(&quot;Email&quot;)
                    TextField(&quot;Enter Email&quot;, text: $userSettings.email)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                }
    
                NavigationLink(destination: SecondView()) {
                    Text(&quot;fsfsdfgsdfg&quot;)
                }
            }
        }
    }
}
</code></pre>
<p><strong>SecondView</strong></p>
<pre class=""lang-swift prettyprint-override""><code>var body: some View {
    NavigationView {
  
        VStack {
            Group {
                Button(
                    action: { self.isTapped1.toggle() }
                ){
                    Circle()
                        .fill(Color.blue)
                        .frame(width: 80, height: 80)
                        .overlay(Circle().stroke(Color.red, lineWidth: self.isTapped1 ? 3 : 0))
                }
                
                Button(
                    action: { self.isTapped1.toggle() }
                ){
                    Circle()
                        .fill(Color.blue)
                        .frame(width: 80, height: 80)
                        .overlay(Circle().stroke(Color.red, lineWidth: self.isTapped2 ? 3 : 0))
                }
            }
                
            Button(action: 
                { self.isTapped1.toggle() }){
                    Circle()
                        .fill(Color.blue)
                        .frame(width: 80, height: 80)
                        .overlay(Circle().stroke(Color.red, lineWidth: self.isTapped3 ? 3 : 0))
</code></pre>
<p><strong>ThirdView</strong></p>
<p>Help</p>
","14668050","","12276301","","2020-12-04 06:50:49","2020-12-04 06:50:49","How to pass Observable object with Button action (OnTap) to a new view","<swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"65124793","1","65124886","","2020-12-03 11:07:22","","0","1166","<p>I have this code:</p>
<pre><code>class ViewModel {

    let email = CurrentValueSubject&lt;String, Never&gt;(&quot;&quot;)

    private var isEmailValid: AnyPublisher&lt;Bool, Never&gt;?

    var emailColor: AnyPublisher&lt;UIColor, Never&gt;?


    private func validateEmail(email: String) -&gt; Bool { return email == &quot;1234@gmail.com&quot; }
    private func emailColor(isValid: Bool) -&gt; UIColor { return isValid ? UIColor.black : 
UIColor.red }

    public func setupPublishers() {
        isEmailValid = email
        .map { self.validateEmail(email: $0) }
        .eraseToAnyPublisher()

        emailColor = email
        .map { self.emailColor(isValid: self.validateEmail(email: $0)) }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p>In the function setupPublishers, I create isEmailValid as a map from the CurrentValueSubject 'email'.
I wish to map it directly from 'isEmailValid', but if I do this:</p>
<pre><code>        emailColor = isEmailValid
        .map { self.emailColor(isValid: $0) }
        .eraseToAnyPublisher()
</code></pre>
<p>I get this error:</p>
<pre><code>Cannot convert value of type 'AnyPublisher&lt;Bool, Never&gt;' to expected argument type 'Bool'
Value of type 'UIColor?' has no member 'eraseToAnyPublisher'
</code></pre>
<p>Which obviously indicates that mapping from the publisher gives me the actual value instead of another publisher.
So how could I achieve this task?</p>
","5784052","","","","","2020-12-03 11:13:33","Map an AnyPublisher to another AnyPublisher","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65126447","1","65181122","","2020-12-03 12:57:06","","0","299","<pre><code>enum FailureReason : Error {
  case sessionFailed(error: URLError)
  case decodingFailed
  case other(Error)
}
</code></pre>
<p>the custom error enum</p>
<pre><code> private func performOperation&lt;T: Decodable&gt;(requestUrl: URLRequest, responseType: T.Type)-&gt;AnyPublisher&lt;T, FailureReason&gt;
   {
return URLSession.shared.dataTaskPublisher(for: requestUrl)
          .map(\.data)
          .decode(type: T.self, decoder: JSONDecoder())
          .mapError({ error -&gt; FailureReason in
            switch error {
            case is Swift.DecodingError:
              return .decodingFailed
            case let urlError as URLError:
              return .sessionFailed(error: urlError)
            default:
              return .other(error)
            }
          })
          .eraseToAnyPublisher()
   
}
</code></pre>
<p>this is how my urlsession publisher looks like</p>
<pre><code>func validateLogin(username : String , password :String) {
    
    let url = &quot;\(Constants.baseUrl)api/v1/auth/login/&quot;
    let htppbodyRequest = EmailLogin(username: username, password: password)
    let httpBody = try! JSONEncoder().encode(htppbodyRequest)
    
   cancellable = webservice.apiRequest(url: URL(string: url)!, resultType: User.self, httpMethodType: .post, requestBody: httpBody)
             .map{ $0 }
             .receive(on: RunLoop.main)
             .sink(receiveCompletion: {
                print(&quot;Received completion: \($0).&quot;)
             }, receiveValue: { (user) in
                  print(&quot;user name is :\(user)&quot;)
                  self.subject.send(user)
            })
</code></pre>
<p>User is the decodable struct. Even if i enter invalid username and password the Received completion of sink prints finished error is never thrown.
Subject is a passthroughSubject.</p>
","12478078","","4667835","","2020-12-07 11:18:59","2020-12-07 11:43:35","Error is not triggering on url session using combine","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"65132939","1","65137146","","2020-12-03 19:38:12","","2","862","<p>I am currently using Alamofire which contains Combine support and using it following way:</p>
<pre class=""lang-swift prettyprint-override""><code>    let request = AF.request(endpoint)

    ...
    request
            .publishDecodable(type: T.self, decoder: decoder)
            .value()
            .eraseToAnyPublisher()
</code></pre>
<p>This will publish result and <code>AFError</code> but from subscriber's <code>.sink</code>, I can't find anywhere to get the HTTP status code. What's the best way to get the status code in subscriber?</p>
","2970107","","","","","2022-01-22 22:32:29","Alamofire + Combine: Get the HTTP response status code","<ios><swift><alamofire><combine>","3","0","","","","CC BY-SA 4.0"
"65134392","1","65148363","","2020-12-03 21:25:21","","0","3403","<p>Trying to figure out how to make quick http requests using combine. I've mostly been looking at this <a href=""https://developer.apple.com/documentation/foundation/urlsession/processing_url_session_data_task_results_with_combine"" rel=""nofollow noreferrer"">doc</a> by Apple. I haven't made any progress though and it seems simple enough so I don't know what I'm doing wrong.</p>
<p>I'm use to JavaScript and using the <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"" rel=""nofollow noreferrer"">Fetch API</a><br />
Also use to <a href=""https://golang.org/pkg/net/http/"" rel=""nofollow noreferrer"">http pkg</a> in Golang<br />
But for some reason doing it in Swift is really confusing to me like it's not very streamlined like the two I mentioned</p>
<p>I'm using SwiftUI with the MVVM architecture so my goal is to implement a way of communicating to my Golang server in my view model.</p>
<p>This requires mostly <code>POST</code> requests with <code>Accept</code> and <code>Authorization</code> headers and a <code>JSON</code> body</p>
<p>I tried this code:</p>
<pre class=""lang-swift prettyprint-override""><code>let url = URL(string: &quot;https://api.example.com/user/login&quot;)!
var request = URLRequest(url: url)
request.httpMethod = &quot;POST&quot;
request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)
request.setValue(String(format: &quot;Bearer %s&quot;, idToken!), forHTTPHeaderField: &quot;Authorization&quot;)
        
_ = URLSession.shared.dataTaskPublisher(for: request)
    .tryMap() { element -&gt; Data in
        // not worried about the status code just trying to get any response.
        guard let httpResponse = element.response as? HTTPURLResponse, httpResponse.statusCode &gt;= 200
        else {
            throw URLError(.badServerResponse)
        }
        return element.data
    }
    // .decode(type: LoginResponseData.self, decoder: JSONDecoder()) commenting this out because I just want to see any data.
    .sink(
        receiveCompletion: { print (&quot;Received completion: \($0).&quot;) },
        receiveValue: { data in print (&quot;Received user: \(data).&quot;)}
    )
</code></pre>
<p>And get this console message: <code>nw_protocol_get_quic_image_block_invoke dlopen libquic failed</code><br />
Which I read <a href=""https://forums.swift.org/t/swift-firebase-connection/41632/2"" rel=""nofollow noreferrer"">here</a> may have nothing to do with my issue however they were talking about firebase I think.</p>
<p>I would like to know if there is anything wrong with my code?<br />
Or a working example with some <code>JSON</code> API or even a http <code>GET</code> request of some website would be fine.</p>
<p>Thanks!</p>
","9745881","","","","","2022-05-11 17:00:09","Swift Combine HTTP request","<ios><swift><http><combine>","2","2","","","","CC BY-SA 4.0"
"65140999","1","","","2020-12-04 09:27:30","","0","75","<p>I am trying to do multiple async operations, in sequence, on an array of data. However I am having problems with the return values of <code>map</code>.</p>
<p>Here is the test code:</p>
<pre><code>import Combine

func getLength(_ string: String) -&gt; Future&lt;Int,Error&gt; {
    return Future&lt;Int,Error&gt;{ promise in
        print(&quot;Length \(string.count)&quot;)
        promise(.success(string.count))
    }
}


func isEven(_ int: Int) -&gt; Future&lt;Bool,Error&gt; {
    return Future&lt;Bool,Error&gt;{ promise in
        print(&quot;Even \(int % 2 == 0)&quot;)
        promise(.success(int % 2 == 0))
    }
}

let stringList = [&quot;a&quot;,&quot;bbb&quot;,&quot;c&quot;,&quot;dddd&quot;]

func testStrings(_ strings:ArraySlice&lt;String&gt;) -&gt; Future&lt;Void,Error&gt; {
    var remaining = strings
    
    if let first = remaining.popFirst() {
        return getLength(first).map{ length in
            return isEven(length)
        }.map{ even in
            return testStrings(remaining)
        }
    } else {
        return Future { promise in
            promise(.success(()))
        }
    }
}

var storage = Set&lt;AnyCancellable&gt;()

testStrings(ArraySlice&lt;String&gt;(stringList)).sink { _ in } receiveValue: { _ in print(&quot;Done&quot;) }.store(in: &amp;storage)

</code></pre>
<p>This generates the following error:</p>
<pre><code>error: MyPlayground.playground:26:11: error: cannot convert return expression of type 'Publishers.Map&lt;Future&lt;Int, Error&gt;, Future&lt;Void, Error&gt;&gt;' to return type 'Future&lt;Void, Error&gt;'
        }.map{ even in
</code></pre>
<p>I thought we could use map to convert from one publisher type to the other, but it seems it's wrapped inside a <code>Publishers.Map</code>. How do I get rid of this?</p>
<p>Thanks!</p>
","251824","","","","","2020-12-04 09:47:21","Asynchronous iteration using Swift Combine","<swift><combine>","1","6","","","","CC BY-SA 4.0"
"65148657","1","65148737","","2020-12-04 18:12:09","","2","706","<p>I am pretty nw to SwiftUI, and to make my code more readable, I usually break my views into smaller views.</p>
<p>Let's say I have a viewModel, what is the best way to call a method of my viewModel from a nested view? Right now I am passing around my ViewModel as a parameter of every nested view, but I don't find it very optimal and clean...</p>
<p>Is there a way to notify MyMainView that the button of HeaderSubview was tapped ? Can I use Combine for example?</p>
<p><strong>ViewModel</strong></p>
<pre><code>class MyViewModel {
    func fetchSomeData() {
        print(&quot;Fetching Some Data&quot;)
    }
}
</code></pre>
<p><strong>MainView</strong></p>
<pre><code>struct MyMainView: View {

    var myViewModel = MyViewModel()
    var body: some View {
        HeaderView(viewModel: myViewModel)
    }
}

struct HeaderView: View {
    var viewModel: MyViewModel

    var body: some View {
        HeaderSubview(viewModel: viewModel)
    }
}

struct HeaderSubview: View {
    var viewModel: MyViewModel
    var body: some View {
        Button(&quot;Search&quot;) {
            // I want to call my View Model method here
            viewModel.fetchSomeData()
        }
    }
}
</code></pre>
","6248848","","","","","2022-08-23 14:39:32","SwiftUI: calling a method from nested view","<ios><mvvm><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65164651","1","65202129","","2020-12-06 04:23:42","","2","762","<p>I am trying to replace delegation pattern with Combine.</p>
<p>The architecture of my app is a VIPER, so I need to pass the sink subscriber from one module to another. The use case is i have data from module A (list) that needs to be show to module B (detail view), and module B can also update the data so I need to get it back to module A also.</p>
<p>With delegates it works okay but when I use a sink subscriber I am facing an issue.</p>
<p>The first time I go from module A to module B, I pass the subscriber and then subscribe it to the publisher (from moduleB) it works well and the subscriber in module A receives all the events from module B.</p>
<p>But then when dismissing the module B and routing again from A to B, then the subscriber receives immediately a cancel event when trying to subscribe again: <strong>receive subscription: (PublishedSubject) ... receive cancel ...</strong></p>
<p>I made a very simplified example to show what is happening:</p>
<p><strong>Module A:</strong></p>
<pre><code>class ViewController_A: UIViewController {
    
    var subscriber: AnySubscriber&lt;String, Never&gt;!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        createSubscriber()
    }
    
    func createSubscriber() {
        let subscriber = Subscribers.Sink&lt;String, Never&gt;(
            receiveCompletion: { completion in
                print(completion)
            }, receiveValue: { value in
                print(value)
            })
        self.subscriber = AnySubscriber(subscriber)
    }
    
    func showViewControllerB() {
        let viewControllerB = ViewControllerB()
        viewControllerB.passSubscriber(AnySubscriber(subscriber))
    }
}
</code></pre>
<p><strong>Module B:</strong></p>
<pre><code>protocol MyProtocol {
    var publisher: Published&lt;String&gt;.Publisher { get }
    func passSubscriber(_ subscriber: AnySubscriber&lt;String, Never&gt;)
}

class ViewController_B: UIViewController, MyProtocol {
    
    @Published var word: String = &quot;House&quot;
    var publisher: Published&lt;String&gt;.Publisher { $word }
    
    func passSubscriber(_ subscriber: AnySubscriber&lt;String, Never&gt;) {
        publisher
            .print()
            .subscribe(subscriber)
    }
    
    func dismiss() {
        dismiss(animated: true)
    }
}
</code></pre>
<p><strong>When routing..</strong></p>
<pre><code>let viewControllerA = ViewController_A()
viewControllerA.showViewController_B() // When presenting B for the first time, receiving events here
// Dismiss B here...
viewControllerA.showViewControllerB() // When presenting B again (hence subscribing again), the subscription gets cancelled here without receiving any events/values
</code></pre>
<p>I noticed something interesting.. When I create the subscriber again every time I route to module B instead of creating it only one time in <code>viewDidLoad</code>, it seems to work okay, but I am not sure why.</p>
<p>Does this mean that a subscriber cannot subscribe to another publisher once it subscribed to one, even when the previous publisher doesn't exist anymore?</p>
<p>How I can make it work in my delegation case?</p>
","","user13611542","3585796","","2021-11-02 02:19:54","2021-11-02 02:19:54","Combine - Subscriber gets cancelled silently when subscribing a second time","<swift><combine><delegation><viper-architecture>","1","6","0","","","CC BY-SA 4.0"
"65167350","1","","","2020-12-06 11:13:51","","2","2020","<p>I'm trying to updating view with SwiftUI and binding.
I have a MainView that observes changes in ViewModel.
I would like this view to respond to changes in <strong>viewModel.data.image</strong>. I don't know how to pass a value to HeaderView.</p>
<p>Currently this code refuses to compile. I get an error:</p>
<pre><code>Value of type 'ObservedObject &lt;LockedCourseViewModel&gt; .Wrapper' has no dynamic member 'course' using key path from root type
</code></pre>
<p>View:</p>
<pre><code>struct MainView: View {
    @ObservedObject var viewModel = ViewModel()
    
    var body: some View {
        VStack {
            HeaderView(image: $viewModel.data.image)
        }
    }
}
</code></pre>
<p>ViewModel:</p>
<pre><code>class ViewModel: ObservableObject {    
    @Published var data: Model?
    
    func fetchData(id: Int) {
        // fetching some data from api
        self.data = Model(data: data)
    }
}
</code></pre>
<p>Model:</p>
<pre><code>class Model: ObservableObject {
    @Published var image: URL
}
</code></pre>
<p>HeaderView:</p>
<pre><code>struct HeaderView: View {
    @Binding var image: URL?
}
</code></pre>
<p>Thank you for help!</p>
","11262008","","","","","2020-12-06 11:50:13","SwiftUI passing @Published viewmodel object value to @Binding","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65176436","1","65176792","","2020-12-07 05:12:22","","2","1131","<p>I have a particular situation where the returning function provides something like <code>AnyPublisher&lt;Response, Error&gt;</code>. But from the calling function, I want to return <code>AnyPublisher&lt;Response, Never&gt;</code>.</p>
<pre><code>//just an example
func getList(_ request: QueryRequest) -&gt; AnyPublisher&lt;Response, Never&gt; {
   return executeQuery(request).eraseToAnyPublisher()
}

func executeQuery(_ request: QueryRequest) -&gt; AnyPublisher&lt;Response, Error&gt; {
   return someData().eraseToAnyPublisher()
}
</code></pre>
<p>When I do this, I am getting <code>Cannot convert return expression of type 'AnyPublisher&lt;Response, Error&gt;' to return type 'AnyPublisher&lt;Response, Never&gt;'</code></p>
<p>How do I do convert to <code>AnyPublisher&lt;Response, Never&gt;</code> without modifying the called function?</p>
<p>Note: <em>I cannot modify the called function's return type as it's used by other methods which make use of Error</em></p>
","849486","","","","","2020-12-07 06:06:09","Combine: AnyPublisher<Response, Error> to AnyPublisher<Response, Never>","<swift><combine>","1","8","","","","CC BY-SA 4.0"
"65191868","1","","","2020-12-08 01:39:06","","0","192","<p>I am facing a problem initializing the view, it is reinitialized when the @Published property is set and I cannot figure out why.</p>
<p>The app structure is:
MyApp -&gt; MainView -&gt; fullscreenCover OrderView -&gt; ListOfOrders -&gt; fullscreenCover ProductView -&gt; Bug Button. The view model is injected as @StateObject.</p>
<p>Here is a simplified version of the app I'm working on:</p>
<p><strong>View model</strong></p>
<pre><code>class SystemService: ObservableObject {
  @Published private(set) var testValue: Bool = false
  @Published private(set) var products: [Product] = []
}
</code></pre>
<p><strong>The App declaration</strong></p>
<pre><code>@main
struct MyApp: App {
  @StateObject private var systemService = SystemService()

  @ViewBuilder
  var body: some Scene {
    WindowGroup {
      MainView(systemService: systemService)
    }
  }
}
</code></pre>
<p><strong>The main view</strong>, which basically just shows a fullscreen modal view - OrderView</p>
<pre><code>struct MainView: View {
  @StateObject var systemService: SystemService
  @State private var activeFullScreen: ActiveFullScreenEnum?

  var body: some View {
    VStack {
      Button(action: {
        activeFullScreen = .order
      }, label: Text(&quot;Order Details&quot;))
    }
    .fullScreenCover(item: $activeFullScreen, content: { item in
      switch item {
      case .order:
        OrderView(systemService: systemService)
      }
    })
  }
}
</code></pre>
<p>The <strong>Order View</strong> contains a list of products.</p>
<pre><code> struct OrderView: View {
      @StateObject var systemService: SystemService
      @State private var activeFullScreen: OrderFullScreenEnum?
    
      init(systemService: SystemService) {
        _systemService = StateObject(wrappedValue: systemService)
    
        print(&quot;OrderScreen Initialized&quot;)
      }
    
      var body: some View {
        VStack {
          ScrollView {
            ForEach(systemService.products) { product in
              Button(action: {
                activeFullScreen = .product(product)
              }, label: Text(&quot;Prodcut Details&quot;))
            }
          }
        }
        .fullScreenCover(item: $activeFullScreen, content: { item in
          switch item {
          case .product(let product):
            ProductView(systemService: systemService, product: product)
          }
        })
      }
    }
</code></pre>
<p>And finally the <strong>Product View</strong> where the bug is discovered.</p>
<p>The bug is - when pressing on the &quot;Bug Button&quot; the <strong>ProductView</strong> is dismisses, and OrderView's init calls and prints out &quot;OrderScreen Initialized&quot;.</p>
<pre><code>struct ProductView: View {
  @StateObject var systemService: SystemService

  var body: some View {
    VStack {
      Button(action: {
        systemService.testValue.toggle()
      }, label: Text(&quot;Bug Button&quot;))
    }
  }
}
</code></pre>
<p>Probably the issue in my fundamental misunderstanding of how Combine works, I will be grateful if somebody could help.</p>
<p>***** Additional info *****</p>
<p>If I add <code>.onAppear</code> to the Order View</p>
<pre><code> .onAppear {
      print(&quot;Order View Did Appear&quot;)
    }
</code></pre>
<p>The first call to <code>systemService.testValue.toggle()</code> from the Ordre View triggers <code>.onAppear</code>, but only once, only the first time. After that, the bug disappears and .fullScreenCover doesn't get dismissed anymore.</p>
","14204818","","14204818","","2020-12-08 15:51:23","2020-12-08 15:51:23","Changing @Published value triggers Init in View","<swift><swiftui><combine>","1","6","","","","CC BY-SA 4.0"
"65194585","1","65195474","","2020-12-08 07:13:39","","2","556","<p>I'm trying to manage user state via a series of nested classes.</p>
<p>The basic view of the app uses a <code>globalState</code> environment object. This object allows other views to the user in and out.</p>
<pre class=""lang-swift prettyprint-override""><code>@EnvironmentObject var globalState: GlobalState

// View Code
Text(&quot;Logged In&quot;).opacity(globalState.user.isLoggedIn ? 1 : 0)
Text(&quot;Please Sign In&quot;).opacity(globalState.user.isLoggedIn ? 0 : 1)
</code></pre>
<p>Then the <code>GlobalState</code> class merely houses the <code>User</code> class. The <code>user</code> field is init'ed elsewhere (and no, I'm not referencing different <code>user</code> objects).</p>
<pre class=""lang-swift prettyprint-override""><code>class GlobalState: ObservableObject {
    @Published public var user: User // Inited somewhere else
}
class User {
    @Published var isLoggedIn: Bool = false
}
</code></pre>
<p>The <code>User</code> class automatically pulls data about the user when it is <code>init</code>ed. On app launch, user information is pulled from the Keychain (if present). If the user can be created from existing data, that user's <code>isLoggedIn</code> is set to <code>true</code>.</p>
<p>I know I do not have duplicate objects, as the memory addresses of the <code>globalState.user</code> in <code>GlobalState</code>'s View Code is the same as when <code>isLoggedIn</code> is updated for a user.</p>
<p>I feel a disturbance in the Force by using two levels of <code>@Published</code> variables, but everything should work out?</p>
<p>The view code in <code>GlobalState</code> does not update though. Any one know why? Some Combine jiu jitsu I'm missing?</p>
","6637709","","","","","2020-12-08 08:25:44","SwiftUI Published updates not refreshing","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"65202102","1","65205031","","2020-12-08 15:43:37","","0","674","<p>I'm pretty new to SwiftUI, so I'd love any help!</p>
<p>I'm looking to build a <code>TextField</code> that shows an error state based on the validation of the <code>text</code>.</p>
<p>For example, if the <code>TextField</code> is meant to collect an email, show an error if the <code>text</code> doesn't contain <code>@</code>. Let's say the error state would change the border color of the <code>TextField</code> to <code>Color.green</code>.</p>
<p>I was thinking of approaching this with a validating closure, but I'm still unsure of how to change the actual visual state of the <code>TextField</code>.</p>
<p>I see that we can <a href=""https://stackoverflow.com/questions/60379010/how-to-change-swiftui-textfield-style-after-tapping-on-it"">can change border color based on editing state</a> - should I just declare something like a <code>@State var isError</code>?</p>
<p>I've also tried holding <code>TextFieldStyle</code> as a <code>@State</code>, but that seems to be a protocol with an associated type, which I haven't been able to get around:</p>
<p>Something like:</p>
<pre><code>TextField(&quot;&quot;,
              text: $text,
              onEditingChanged: { _ in
                self.style = CustomErrorStyle()
</code></pre>
<p>Please let me know if I can clarify at all, thanks!</p>
","6383587","","6383587","","2020-12-08 15:59:11","2020-12-08 18:49:34","How can you change TextField state based on input in SwiftUI?","<ios><swift><swiftui><textfield><combine>","1","4","","","","CC BY-SA 4.0"
"65202332","1","","","2020-12-08 15:55:38","","1","432","<p>Here's the code I'm wondering about:</p>
<pre><code>final class Foo {
    
    var subscriptions = Set&lt;AnyCancellable&gt;()
    
    init () {
        Timer
            .publish(every: 2, on: .main, in: .default)
            .autoconnect()
            .zip(Timer.publish(every: 3, on: .main, in: .default).autoconnect())
            .sink {
                print($0)
            }
            .store(in: &amp;subscriptions)
    }
}
</code></pre>
<p>This is the output it produces:</p>
<pre><code>(2020-12-08 15:45:41 +0000, 2020-12-08 15:45:42 +0000)
(2020-12-08 15:45:43 +0000, 2020-12-08 15:45:45 +0000)
(2020-12-08 15:45:45 +0000, 2020-12-08 15:45:48 +0000)
(2020-12-08 15:45:47 +0000, 2020-12-08 15:45:51 +0000)
</code></pre>
<p>Would this code eventually crash from memory shortage? It seems like the zip operator is storing every value that it receives but can't yet publish.</p>
","2977972","","","","","2020-12-14 09:07:00","Swift Combine - Does the zip operator retain all values that it hasn't had a chance to publish?","<memory-leaks><timer><zip><combine><publisher>","1","2","","","","CC BY-SA 4.0"
"65297150","1","65297766","","2020-12-14 22:05:30","","0","861","<p>I am new to SwiftUI and I am having difficulty with something that I presume is rather simple.
I have created an app that shows the user's current location. If the user puts the app into the background, and the user's physical location changes, the app does not show the new location when it enters the foreground. If I kill the app, then restart, it shows the new location.</p>
<p>I also want to call a function to get an updated dataset from Firebase when the location change is detected. Here is a simplified version of the code that I am using. Please let me know what I am missing. I think I am supposed to use more Combine functionality to achieve this outcome, but I am not sure how?</p>
<p><em><strong>My key question is: &quot;How do I detect a location change in my view and call a function as a result of that location change?&quot;</strong></em></p>
<p>MyView.swift</p>
<pre><code>import SwiftUI

struct MyView: View {

    @ObservedObject var locationManager = LocationManager()

    var userLatitude: String {
        return &quot;\(locationManager.lastLocation?.coordinate.latitude ?? 0)&quot;
    }

    var userLongitude: String {
        return &quot;\(locationManager.lastLocation?.coordinate.longitude ?? 0)&quot;
    }

    var body: some View {
        VStack {
            Text(&quot;location status: \(locationManager.statusString)&quot;)
            HStack {
                Text(&quot;latitude: \(userLatitude)&quot;)
                Text(&quot;longitude: \(userLongitude)&quot;)
            }
            Text(&quot;place: \(locationManager.placemark?.thoroughfare ?? &quot;&quot;)&quot;) 
        }
     
    }
    
    func refreshData() {
        // call firebase listener with new location data
    }

}
</code></pre>
<p>LocationManager.swift</p>
<pre><code>import Foundation
import CoreLocation
import Combine

class LocationManager: NSObject, ObservableObject {
    
    let objectWillChange = PassthroughSubject&lt;Void, Never&gt;()
    
    private let locationManager = CLLocationManager()
    
    override init() {
        super.init()
        self.locationManager.delegate = self
        self.locationManager.desiredAccuracy = kCLLocationAccuracyThreeKilometers
        self.locationManager.requestWhenInUseAuthorization()
        self.locationManager.startUpdatingLocation()
    }
    
    @Published var locationStatus: CLAuthorizationStatus? {
        willSet {
            objectWillChange.send()
        }
    }
    
    @Published var lastLocation: CLLocation? {
        willSet {
            objectWillChange.send()
        }
    }
    
    @Published var placemark: CLPlacemark? {
        willSet {
            objectWillChange.send()
        }
    }
    
    var statusString: String {
        guard let status = locationStatus else {
            return &quot;unknown&quot;
        }
        
        switch status {
        case .notDetermined: return &quot;notDetermined&quot;
        case .authorizedWhenInUse: return &quot;authorizedWhenInUse&quot;
        case .authorizedAlways: return &quot;authorizedAlways&quot;
        case .restricted: return &quot;restricted&quot;
        case .denied: return &quot;denied&quot;
        default: return &quot;unknown&quot;
        }
        
    }
    
}

extension LocationManager: CLLocationManagerDelegate {
    
    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        self.locationStatus = status
        print(#function, statusString)
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        self.lastLocation = location
        print(#function, location)
        
        let geocoder = CLGeocoder()
        geocoder.reverseGeocodeLocation(location) { (placemarks, error) in
            if (error != nil){
                print(&quot;Error in reverseGeocode: \(error)&quot;)
                return
            }
            
            let placemark = placemarks! as [CLPlacemark]
            
            if placemark.count &gt; 0 {
                let placemark = placemarks![0]
                self.placemark = placemark
            }
        }
        locationManager.stopUpdatingLocation()
    }
    
    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        if let error = error as? CLError, error.code == .denied {
            // Location updates are not authorized.
            locationManager.stopUpdatingLocation()
            return
        }
        // Notify the user of any errors.
    }
    
}
</code></pre>
","7993358","","","","","2020-12-14 23:02:04","SwiftUI - Get Location and Call Function when App enters Foreground","<swiftui><core-location><combine>","1","2","","","","CC BY-SA 4.0"
"65297505","1","65297709","","2020-12-14 22:36:03","","1","82","<p>I have created an Atimeter as ObservableObject, so that I can access it from several points in my App. Unfortunately the view is not updating, when the @Published variable pressure changes. Can somebody explain why?</p>
<p>I already tried {willSet {objectWillChange.send()} }, which will trigger but also not update the View!</p>
<p>The Altimeter:</p>
<pre><code>//
//  Altimeter.swift
//  iAlti_v2
//
//  Created by Lukas Wheldon on 14.12.20.
//

import Foundation
import CoreMotion
import Combine

class Altimeter: CMAltimeter, ObservableObject {
    static let shared = Altimeter()
    
    @Published var pressure: Double = 0
    
    func start() {
        if Altimeter.isRelativeAltitudeAvailable() {
            switch Altimeter.authorizationStatus() {
            case .notDetermined: // Handle state before user prompt
                debugPrint(&quot;CM: Awaiting user prompt...&quot;)
            //fatalError(&quot;Awaiting CM user prompt...&quot;)
            case .restricted: // Handle system-wide restriction
                fatalError(&quot;CM Authorization restricted!&quot;)
            case .denied: // Handle user denied state
                fatalError(&quot;CM Authorization denied!&quot;)
            case .authorized: // Ready to go!
                debugPrint(&quot;CM Authorized!&quot;)
            @unknown default:
                fatalError(&quot;Unknown CM Authorization Status!&quot;)
            }
            Altimeter.shared.startRelativeAltitudeUpdates(to: OperationQueue.main) { data, error in
                if let trueData = data {
                    //debugPrint(#function, trueData)
                    Altimeter.shared.pressure = trueData.pressure.doubleValue * 10
                } else {
                    debugPrint(&quot;Error starting relative Altitude Updates: \(error?.localizedDescription ?? &quot;Unknown Error&quot;)&quot;)
                }
            }
        }
    }
}
</code></pre>
<p>The View:</p>
<pre><code>import SwiftUI

struct SwiftUIView: View {
    var body: some View {
        Text(&quot;\(Altimeter.shared.pressure)&quot;)
    }
}

</code></pre>
","7678035","","7678035","","2020-12-14 22:56:29","2020-12-15 10:55:26","ObservableObject not updating View","<ios><xcode><swiftui><combine><observableobject>","2","0","","","","CC BY-SA 4.0"
"65314094","1","","","2020-12-15 21:40:20","","0","48","<p><strong>Scenario:</strong>  I retrieve data from a server via <strong>@ObservableObject</strong>/<strong>@Publish</strong>; within a <strong>tabview()</strong>.</p>
<p>Data is displayed as expected.  <br/>
However when I return to the tabView from another tab, I data is gone, requiring me to do another fetch which isn't needed.</p>
<p>Here's the subscriber:</p>
<pre><code>struct NYTStatesView: View {
    @ObservedObject var dataSource = NYTStatesModel()
    ...
}
</code></pre>
<p>Here's the publisher:</p>
<pre><code>final class NYTStatesModel: ObservableObject {
    @Published var revisedNYTStates: RevisedNYTStates!
    // ...
}
</code></pre>
<p><strong>dataSource.revisedNYTStates</strong> <em>is empty</em> upon return to the View.</p>
<p><strong>Question:</strong>  <em>How do I RETAIN the data</em> so I don't have to <em><strong>always</strong></em> access the server per View display?</p>
","715747","","","","","2020-12-16 02:23:59","How do I keep data persistent while the App is running?","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"65327281","1","65328672","","2020-12-16 16:28:50","","1","367","<p>I'm new to the <code>Combine</code> game and am trying to figure out how to generalize a HTTP <code>POST</code> request.</p>
<p>I created the following <code>APIService</code> class to extend individual resource services from:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class APIService {
  let decoder: JSONDecoder
  let session: URLSession
  
  init(session: URLSession = URLSession.shared, decoder: JSONDecoder = JSONDecoder()) {
    self.decoder = decoder
    self.session = session
  }
}

// MARK: JSON API
extension APIService {
  struct Response&lt;T&gt; {
    let response: HTTPURLResponse
    let value: T
  }
  
  func post&lt;T: Codable&gt;(
    payload: T,
    url: URL
  ) -&gt; AnyPublisher&lt;Response&lt;T&gt;, APIError&gt; {
    return Just(payload)
      .setFailureType(to: APIError.self) // &lt;&lt;&lt; THIS WAS MISSING!
      .encode(encoder: JSONEncoder())
      .flatMap({ [weak self] payload -&gt; AnyPublisher&lt;Data, Error&gt; in
        guard let self = self else {
          return Fail(error: .default(&quot;Failing to establish self.&quot;)).eraseToAnyPublisher()
        }
        var request = URLRequest(url: url)
        request.httpMethod = Methods.post
        request.setValue(
          Mimetypes.json,
          forHTTPHeaderField: Headers.contentType
        )
        request.httpBody = payload
        return self.session
          .dataTaskPublisher(
            for: request
          )
          .tryMap { response -&gt; Response&lt;T&gt; in
            let value = try self.decoder.decode(T.self, from: response.data)
            return Response(
              value: value,
              response: response.response
            )
          }
          .mapError { error in
            return APIError.default(error.localizedDescription)
          }
          .receive(on: DispatchQueue.main)
          .eraseToAnyPublisher()
      })
      .eraseToAnyPublisher()
  }
}
</code></pre>
<p>However, this class won't compile with the following error at the <code>post</code> function.</p>
<pre><code>Type of expression is ambiguous without more context
</code></pre>
<p>Being new to Swift in general and Combine in particular, I am unfortunately out of ideas on how to proceed.</p>
<p><strong>Any help is greatly appreciated!</strong></p>
<h2>Figured it out myself: Solution</h2>
<p>Add a <code>Failure</code> type to the <code>Just</code>, so input and output <code>Failure</code> types to <code>flatMap</code> are equal. Or put differently: <code>flatMap</code> cannot convert the <code>Never</code> failing <code>Just</code> to a <code>Publisher</code> with <code>Failure</code>.</p>
<p>The missing line in my case:</p>
<pre class=""lang-swift prettyprint-override""><code>Just(payload)
  .setFailureType(to: APIError.self)
</code></pre>
","5061949","","5061949","","2020-12-16 17:58:16","2020-12-18 14:12:53","Trouble posting API request with Combine","<ios><swift><combine>","2","0","1","","","CC BY-SA 4.0"
"65353749","1","65353916","","2020-12-18 08:23:16","","0","2530","<p>I have a publisher which emits an optional output type. I need to <code>flatMap</code> to a new publisher if the output isn't <code>nil</code>, or fallback to an empty publisher if it is <code>nil</code>.</p>
<p>For example, something like:</p>
<pre class=""lang-swift prettyprint-override""><code>[1, nil, 5].publisher // Generic parameter 'T' could not be inferred
    .flatMap {
        $0?.someNewPublisher ?? Empty(completeImmediately: false)
    }
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>[1, nil, 5].publisher
    .map {
        $0?.someNewPublisher
    }
    .replaceNil(with: Empty(completeImmediately: false)) // Generic parameter 'Failure' could not be inferred
    .flatMap { $0 }

</code></pre>
<p>I'm wondering if maybe I'm trying to solve this in the wrong way. Just to be clear, filtering <code>nil</code> before mapping would not solve my issue, as that would not replace a current publisher with an empty publisher (I would continue to receive elements which I should no longer be receiving).</p>
","343299","","","","","2021-01-04 01:23:32","With Combine, how can you flatMap with nil-coalescing","<ios><swift><reactive-programming><combine>","2","3","","","","CC BY-SA 4.0"
"65362213","1","65362488","","2020-12-18 18:32:11","","0","308","<p>I have a view model that is parent to other children view models. That is:</p>
<pre><code>public class ViewModel: ObservableObject {
    
    @Published var nav = NavigationViewModel()
    @Published var screen = ScreenViewModel()
</code></pre>
<p>The other children view model, such as nav and screen, all serve a specific purpose. For example, nav’s responsibility is to keep track of the current screen:</p>
<pre><code>class NavigationViewModel: ObservableObject {
    
    // MARK: Publishers
    @Published var currentScreen: Screen = .Timeline
    
}
</code></pre>
<p>The ViewModel is instantiated in the App struct:</p>
<pre><code>    @main
struct Appy_WeatherApp: App {
    
    // MARK: Global
    var viewModel = ViewModel()
    
    // MARK: -
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(viewModel)
        }
    }
}
</code></pre>
<p>And I declare an @EnvironmentObject for it on any view that needs access to it:</p>
<pre><code>@EnvironmentObject var viewModel: ViewModel 
</code></pre>
<p>Any view referencing a non-object property of ViewModel that is being <code>@Published</code> whose value changes will result in the view to be re-rendered as expected. However, if the currentScreen <code>@Published</code> property of the <code>NavigationViewModel</code> changes, for example, then the view is not being re-rendered.</p>
<p>I know I can make it work if I separate <code>NavigationViewModel</code> from ViewModel, instantiate it at the app level and use it as its own environment object in any views that access any of its published properties.</p>
<p>My question is whether the above workaround is actually the correct way to handle this, and/or is there any way for views to be subscribed to value changes of properties inside child objects of environment objects? Or is there another way that I’ve not considered that’s the recommended approach for what I’m trying to achieve through fragmentation of view model responsibilities?</p>
","698971","","14437411","","2020-12-19 06:06:40","2020-12-19 06:06:40","Subscribing to value changes inside child objects of environment view models (view not being re-rendered when this happens)","<ios><swift><swiftui><viewmodel><combine>","1","0","1","","","CC BY-SA 4.0"
"65368391","1","65376768","","2020-12-19 09:32:26","","1","1490","<p>I'm working on caching for my network module. My module will return an <code>AnyCancallable</code> back to the caller for each request. If cached data is not available, I use <code>URLSession.dataTaskPublisher</code>, it works fine with 2 events: data received and completion. If cached data is available, I will use a  <code>CurrentValueSubject</code> to create the AnyCancallable to return. I send both of the 2 events on this subject, but on the caller side, it only gets notified on the completion, no data.</p>
<pre><code>cacheSubject.send(cachedData.data)
cacheSubject.send(completion: Subscribers.Completion&lt;Error&gt;.finished)
</code></pre>
<p>Removing the completion send and now it can receive data, but no completion notification.</p>
<p>Could someone please let me know what I'm doing wrong here?</p>
<p>Here is the full file in case you guys need it:</p>
<pre><code>public class SSNetworkManager {
    public static let shared = SSNetworkManager()
    
    private var cache: [String: CachedData] = [:]
    private let cacheSubject = CurrentValueSubject&lt;Data, Error&gt;(Data())
    
    @discardableResult public func makeServiceCall&lt;D: Decodable&gt;(forRequest request: SSNetworkRequest&lt;D&gt;, onMainThread: Bool = true) -&gt; AnyPublisher&lt;D, Error&gt;? {
        guard let urlRequest = request.urlRequest else {
            return nil
        }
        
        var cancelable: AnyPublisher&lt;Data, Error&gt;
        
        if let url = urlRequest.url?.absoluteString,
           let cachedData = cache[url],
           cachedData.isValid {
            cancelable = cacheSubject.eraseToAnyPublisher()
            cacheSubject.send(cachedData.data)
            cacheSubject.send(completion: Subscribers.Completion&lt;Error&gt;.finished)
        } else {
            cancelable = URLSession.shared.dataTaskPublisher(for: urlRequest).tryMap {[weak self] (data, response) -&gt; Data in
                guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                    throw SSNetworkError(httpCode: (response as? HTTPURLResponse)?.statusCode ?? 0, data: data)
                }
                if request.shouldCacheNow,
                   let url = urlRequest.url?.absoluteString {
                    self?.cache[url] = CachedData(data: data, expirationTime: request.cacheExpirationTime)
                }
                return data
            }.eraseToAnyPublisher()
        }
        
        if onMainThread {
            return cancelable
                .receive(on: RunLoop.main)
                .decode(type: D.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
        } else {
            return cancelable
                .decode(type: D.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
        }
    }
}

fileprivate struct CachedData {
    let data: Data
    let expirationTime: Date
    
    var isValid: Bool {
        return Date().compare(expirationTime) != .orderedDescending
    }
}
</code></pre>
","8355412","","","","","2020-12-20 03:52:45","Swift Combine: send completion after send value","<ios><swift><combine>","1","6","","","","CC BY-SA 4.0"
"65385652","1","","","2020-12-20 22:57:31","","3","364","<p>I am migrating the codebase to Combine and the snapshotlistener isn't working i.e. when the document is updated in the back-end, it doesn't get reflected in the app.</p>
<p>This is where I call the service from the Controller:</p>
<pre><code>@objc func loadPlans() {
    guard let userEmail = userEmail else { return }
    getPlansToken = PlanService.sharedInstance.queryPlans(userEmail: userEmail)
        .receive(on: DispatchQueue.main)
        .sink { (completion) in
        switch completion {
        case .failure(let error):
            self.showAlert(alertTitle: &quot;Error&quot;, message: error.localizedDescription)
        case .finished:
            print(&quot;Publisher stopped observing&quot;)
        }
    } receiveValue: { (mealplans) in
        self.mealplanArray.removeAll()
        self.mealplanArray = mealplans.map({return PlanViewModel(mealplan: $0)})
        self.planTableView.reloadData()
        self.refreshControl.endRefreshing()
    }
}
</code></pre>
<p>And this is the service:</p>
<pre><code>var listener : ListenerRegistration!
let db = Firestore.firestore()
static let sharedInstance = PlanService()

func queryPlans(userEmail: String) -&gt; Future&lt;[Mealplan], Error&gt; {
    var mealplans = [Mealplan]()
    return Future { promise in
        self.listener = self.db.collection(&quot;Meal_Plans&quot;)
            .whereField(&quot;userId&quot;, isEqualTo: userEmail)
            .order(by: &quot;timeOfCreation&quot;, descending: true)
            .addSnapshotListener({ (querySnapshot, error) in
                guard let documents = querySnapshot?.documents else {
                    print(&quot;No mealplans&quot;)
                    return
                }
                mealplans = documents.compactMap { queryDocumentSnapshot -&gt; Mealplan? in
                    return try? queryDocumentSnapshot.data(as: Mealplan.self)
                }
                promise(.success(self.updateTimeZone(source: mealplans)))
                if let error = error {
                    promise(.failure(error))
                }
        })
    }
}
</code></pre>
","9950391","","10810527","","2020-12-23 10:55:54","2020-12-23 10:55:54","Migrating to Combine causes Snapshotlistener to fail","<swift><firebase><google-cloud-firestore><combine>","0","8","","","","CC BY-SA 4.0"
"65386645","1","65387024","","2020-12-21 01:54:40","","1","1637","<p>I'm trying to compose a publisher, that, when a subsequent subscriber connects to it, emits the last emitted value immediately to that subscriber, and then continues to emit future values to all connected subscribers.</p>
<p><strong>Q:</strong> Is there a way to do this <strong>without writing a publisher from scratch</strong>, and only by composing built-in publishers? I might be missing something here.</p>
<p>So, if we had a publisher counting every second:</p>
<pre><code>let counter = Timer.publish(every: 1, on: .main, in: .common)
                   .autoconnect()
                   .scan(0, { v, _ in v + 1 })


let sharedPublisher = // ??? something with counter publisher above

sharedPublisher.sink { print(&quot;A: &quot;, $0 }.store(in: &amp;bag)

// after 2.5 seconds
sharedPublisher.sink { print(&quot;B: &quot;, $0 }.store(in: &amp;bag)
</code></pre>
<p>The output would be:</p>
<pre><code>A: 1 // at t=1 sec
A: 2 // at t=2
B: 2 // at t=2.5
A: 3 // at t=3
B: 3 // at t=3
</code></pre>
<hr />
<p>Initially, naively, I thought I could just use a <code>.share</code> and a <code>.buffer</code>:</p>
<pre><code>let sharedPublisher = counter
                  .share()
                  .buffer(size: 1, prefetch: .byRequest, whenFull: .dropOldest)
</code></pre>
<p>but of course, that doesn't work since <code>buffer</code> only buffers if the downstream isn't ready to accept values, which isn't the case here.
Maybe something with <code>Record</code>/<code>Record.Recording</code>?</p>
","968155","","","","","2020-12-21 04:31:22","How to compose a combine publisher that emits the last-emitted value to its 2nd subscriber","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"65390440","1","","","2020-12-21 09:38:45","","0","105","<p>I'm looking for a method that allows you to react upon the previous output to create a new stream.</p>
<p>It would be similar to <a href=""https://developer.apple.com/documentation/combine/publishers/zip/scan(_:_:)"" rel=""nofollow noreferrer"">scan</a>, but rather than returning an output, it would return another publisher that publishes the next result.</p>
<p>Here's something similar to the scan example:</p>
<pre><code>func next(x: Int) -&gt; AnyPublisher&lt;Int?, Never&gt; {
    return Future { x &lt; 5 ? $0(.success(x + 1)) : $0(.success(nil)) }
}

next(0)
    .fold { x != nil ? next(x) : nil }
    .collect()
// Yields [1, 2, 3, 4]
</code></pre>
<p>Something more real:</p>
<pre><code>paginated(0)
    .fold(limit: 100) { $0.index &lt; $0.total ? paginated($0.index + 1) : nil  }
    .collect()
// Yields all pages as an array
</code></pre>
","730797","","730797","","2020-12-21 14:34:21","2020-12-21 14:40:46","'Unfold' in Swift's Combine Framework","<swift><functional-programming><reactive><combine>","2","0","","","","CC BY-SA 4.0"
"65390833","1","","","2020-12-21 10:08:35","","0","341","<p>I want to achieve the opposite of the collect operator. Instead of collecting 10 items and then getting a publisher with array type, I want to get a subject with array type and have the publisher get each array element one by one.</p>
<p>So I could get my intended output by doing this:</p>
<pre><code>let subject = PassthroughSubject&lt;Int, Never&gt;()

let sub = subject.sink(receiveValue: {
    print($0)
})

for val in 1...100 {
    subject.send(val)
}
</code></pre>
<p>I want it to work like this, that the subject gets an array, and then add another operator to emit the values from the array one by one, like the opposite of the <code>collect</code> operator:</p>
<pre><code>let subject = PassthroughSubject&lt;[Int], Never&gt;()

let sub = subject.sink(receiveValue: {
    print($0)
})

subject.send(Array(1...100))
</code></pre>
<p>The issue is that the second implementation prints the whole array as it just gets it as a value. I want to add a stage in the stream, a little like collect works but the opposite, to manipulate the stream that it will emit the values from the array one by one.</p>
<p>Is there any operator to achieve that?</p>
","5784052","","","","","2020-12-21 10:38:08","Map PassthroughSubject<[Int], Never> to AnyPublisher<Int, Never>","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"65391066","1","","","2020-12-21 10:26:09","","7","2146","<p>I have a <code>UITableViewCell</code> that contain a <code>UISwitch</code>. This cell has its own <code>SwitchCellViewModel</code>. Lets say it contains some <code>Bool</code> value (enabled vs disabled). And <code>ViewController</code> is the one who contains <code>UITableView</code>, creates <code>viewModel</code> for the cell and sets cell with it.</p>
<p><strong>I want to a achieve:</strong></p>
<ol>
<li>On a cell level: change UISwitch state whenever a viewModel’s bool property value changes (without reloading tableView of course).</li>
<li>On a ViewController level: handle UISwitch state change (by user).</li>
</ol>
<p>The use case is next: cell shows some option that can be disabled or enabled. That action goes to backend, and after I receive response with a result (enabled vs disabled on backend), I have to sync view’s state again with the updated data.</p>
<p>I understand how to subscribe to a property value change on a cell level, so when I change it in viewModel from viewController, it updates a cell view right away. But I’m not sure how to deal with back action from <code>UISwitch</code> to viewController.</p>
<p><em>Is it achievable with a single <code>@Published</code> bool property in viewModel, or I have to have 2 separate things for this bidirectional case.</em></p>
<p>It looks really silly to me that I have to expose a separate <code>Publisher</code> for this purpose, since I already have a <code>@Published</code> property in viewmodel, that view controller should be notified about, so why wouldn’t I use it. But if I use just one, then it will be the case that ViewController sets <code>@Published</code> var in viewModel, cell itself will handle it and adjust UI, but ViewController immediately gets event about it as well, since it is subscribed to on it.</p>
","4989504","","","","","2021-03-17 16:48:42","Two-way binding in Swift Combine (UIKit)","<ios><swift><mvvm><uikit><combine>","1","1","","","","CC BY-SA 4.0"
"65391477","1","65391657","","2020-12-21 10:55:34","","3","773","<p>I'm trying to figure out how to link the <code>@Binding</code> passed into a custom View to an <code>@Published</code> from that view's model.  Essentially I'm trying to create a reusable integer only TextField.  I'm using the below code, which works to set the integer value into the text field, but what I can't figure out is how to update the binding when the text changes.</p>
<pre class=""lang-swift prettyprint-override""><code>private class IntegerTextFieldValue: ObservableObject {
    @Published var value = &quot;&quot; {
        didSet {
            let numbersOnly = value.filter { $0.isNumber }
            if value != numbersOnly {
                value = numbersOnly
            }
        }
    }
}

struct IntegerTextField: View {
    @Binding var value: Int?
    @StateObject private var fieldValue = IntegerTextFieldValue()

    var placeholder = &quot;&quot;

    var body: some View {
        TextField(placeholder, text: $fieldValue.value)
            .keyboardType(.numberPad)
            .onAppear {
                if let value = value {
                    fieldValue.value = &quot;\(value)&quot;
                }
            }
    }
}
</code></pre>
","1455351","","","","","2021-01-04 02:05:28","Link @Binding to @Published with SwiftUI","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"65397556","1","65402086","","2020-12-21 17:45:39","","4","5585","<p>I have found ways of combining publishers using <code>MergeMany</code> or <code>CombineLatest</code>, but I don't seem to find a solution in my particular case.</p>
<p>Example:</p>
<pre><code>class Test {
    @Published var firstNameValid: Bool = false
    @Published var lastNameValid: Bool = false
    @Published var emailValid: Bool = false

    @Published var allValid: Bool = false
}
</code></pre>
<p>I want <code>allValid</code> to become <code>false</code> when any of the previous publishers are set to <code>false</code>, and <code>true</code> if all of them are <code>true</code>.
I also don't want to hardcode the list of publishers I am observing since I want a flexible solution, so I want to be able to pass an array of <code>Bool</code> publishers to whatever code I use to do this.</p>
<p>I tried this</p>
<pre><code>        let fieldPublishers = [$firstNameValid, $lastNameValid, $emailValid]
        Publishers
            .MergeMany(fieldPublishers)
            .sink { [weak self] values in
                self?.allValid = values.allSatisfy { $0 }
            }
            .store(in: &amp;subscribers)
</code></pre>
<p>But this of course doesn't work because I get an array of publishers and not an array of values. I tried some other ways (forgot which ones) but they only seemed to call <code>sink</code> if I assigned a value during execution to all 3 publishers.</p>
<p>In the case of only using 2 publishers I managed to get it working using <code>CombineLatest</code>.</p>
<p>So the question is: Can I have <code>sink</code> triggered when only one of the publishers in an array changes value after instantiation of <code>Test</code>, and then iterate over the values of all the publishers I am observing?</p>
","251824","","","","","2020-12-22 01:28:04","Swift Combine, how to combine publishers and sink when only one publisher's value changes?","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"65433180","1","65433349","","2020-12-24 02:13:52","","1","438","<p>I'm trying to take advantage of Combine's ability to <code>subscribe</code> to an upstream Publisher on a different queue but I'm finding that when I do, the upstream Publisher does not correctly get cancelled.</p>
<p>The documentation for <a href=""https://developer.apple.com/documentation/combine/publisher/subscribe(on:options:)"" rel=""nofollow noreferrer"">subscribe(on:options:)</a> makes the following reference:</p>
<blockquote>
<p>Using subscribe(on:options:) also causes the upstream publisher to
perform cancel() using the specified scheduler.</p>
</blockquote>
<p>It's not entirely clear to me what this statement implies. In the example code below, I have a basic type <code>NameIterator</code> that conforms to <code>Sequence</code> and <code>IteratorProtocol</code>. It's just simulating a custom iterator that might take a long time to fetch elements.</p>
<p>Combine adds a <code>.publisher</code> property to <code>Sequence</code>. If you subscribe to that publisher in a single thread, then any cancellation events are correctly propagated up to the root publisher and iteration stops.</p>
<p>However, if you call <code>subscribe(on:)</code>, then the cancellation event does not reach the root publisher until it has exhausted calls to the iterator. Note that <code>sink</code> is correctly called in both cases, but the iterator continues to get called even though no values are being pushed down the pipeline.</p>
<p>This causes a problem if the iterator is expensive and contains a large number of items, like traversing a filesystem. Is there a way to correctly cancel the upstream publisher? Or perhaps I'm incorrectly configuring the chain of Publishers.</p>
<p><strong>Sample Iterator:</strong></p>
<pre><code>struct NameIterator: Sequence, IteratorProtocol {

  private let names = [&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Charlie&quot;, &quot;Delta&quot;]
  private var index = 0

  mutating func next() -&gt; String? {
    guard index &lt; names.endIndex else {
      return nil
    }

    // Simulate an expensive iterator.
    sleep(1)
    
    defer { index = names.index(after: index) }
    print(&quot;NameIterator.next() called with \(names[index])&quot;)
    return names[index]
  }
}
</code></pre>
<p><strong>Correctly Cancelled:</strong></p>
<pre><code>let cancellable = NameIterator().publisher
  .first()
  .sink { print(&quot;Sink: \($0)&quot;) }

// Outputs:

NameIterator.next() called with Alpha
NameIterator.next() called with Beta
Sink: Alpha
</code></pre>
<p><strong>Incorrectly Cancelled:</strong></p>
<pre><code>let cancellable = NameIterator().publisher
  .subscribe(on: DispatchQueue(label: &quot;BackgroundQueue&quot;))
  .first()
  .sink { print(&quot;Sink: \($0)&quot;) }

// Outputs: 

NameIterator.next() called with Alpha
NameIterator.next() called with Beta
Sink: Alpha
NameIterator.next() called with Charlie  // This call was unexpected.
NameIterator.next() called with Delta    // This call was unexpected.   
</code></pre>
","48321","","48321","","2020-12-24 09:35:35","2020-12-24 09:35:35","Combine Publisher does not cancel when subscribed to on a background queue","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"65440412","1","","","2020-12-24 15:39:59","","1","507","<p>I know how to fix this error, but my fix leads to another error.</p>
<p>The initial problem is the following</p>
<pre><code>@Binding var report: Report

init(property: Property, report: Binding&lt;Report&gt;, saveAction: @escaping () -&gt; Void) {
    self.property = property
    self.report = report // cannot assign value of type Binding&lt;Report&gt; to type Report
    self.data = SpacesData(property: property, report: report)
    self.saveAction = saveAction
}
</code></pre>
<p>If I change to the following</p>
<pre><code>var report: Binding&lt;Report&gt;

init(property: Property, report: Binding&lt;Report&gt;, saveAction: @escaping () -&gt; Void) {
    self.property = property
    self.report = report
    self.data = SpacesData(property: property, report: report)
    self.saveAction = saveAction
}
</code></pre>
<p>The error goes away but I can no longer call methods on report. So for instance the following</p>
<pre><code>let image = report.loadCoverImage(for: property)
</code></pre>
<p>throws the error</p>
<blockquote>
<p>Dynamic key path member lookup cannot refer to instance method
'loadCoverImage(for:)'</p>
</blockquote>
","9400730","","","","","2020-12-24 15:39:59","Cannot assign value of type Binding<XXX> to type XXX","<swiftui><combine>","0","3","","2020-12-24 23:47:23","","CC BY-SA 4.0"
"65443391","1","65443413","","2020-12-24 21:31:57","","1","644","<p>I'm following along with the WWDC 2019 'Combine in Practice' video and I get the following error</p>
<pre><code>Cannot find 'CombineLatest' in scope
</code></pre>
<p>I did it in a playground made in Xcode 12</p>
<pre><code>import SwiftUI
import Combine

class Stuff {
    @Published var password: String = &quot;&quot;
    @Published var passwordAgain: String = &quot;&quot;

    var validatedPassword: AnyPublisher&lt;String?, Never&gt; {
        // wtf? &quot;Cannot find 'CombineLatest' in scope&quot;
        return CombineLatest($password, $passwordAgain) { password, passwordAgain in
            guard password == passwordAgain, password.count &gt; 8 else { return nil }
            return password
        }
        .map { $0 == &quot;password1&quot; ? nil : $0 }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p>Has the API changed since 2019? Because it seems that</p>
<pre><code>CombineLatest($password, $passwordAgain) -&gt; $password.combineLatest($passwordAgain) 
</code></pre>
<p>Is this true? Can anyone find any formal documentation on if it's true and why?</p>
","465446","","","","","2020-12-24 21:35:12","Cannot find 'CombineLatest' in scope","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65456295","1","65456352","","2020-12-26 12:17:59","","1","41","<p>I want to establish a binding for an object in a collection so that I can pass it on downstream like a reference pointer. I want this to be a convenience function but I am having some trouble.</p>
<p>What constraint, if any, can I put on the following protocol 'Diskable' to eliminate the error I'm getting below?</p>
<pre><code>final class PropertiesData: ObservableObject, Diskable {
    
    @Published var fetchedItems: [Property] = []
        
    var location: URL {
        let file = try! LocalStorage.rootFolder.createFileIfNeeded(withName: &quot;properties.data&quot;)
        return file.url
    }
}

extension Diskable where T: Identifiable {
    
    func binding(for object: T) -&gt; Binding&lt;T&gt; {
        let index = fetchedItems.firstIndex(where: { $0.id == object.id } )!
        return $fetchedItems[index] // cannot find 'fetchedItems' in scope
    }
}

protocol Diskable: AnyObject {
    associatedtype T: Codable
    var location: URL { get }
    var fetchedItems: [T] { get set }
}
</code></pre>
","9400730","","","","","2020-12-26 12:25:37","Which is an appropriate protocol constraint to identify a property as being '@Published'","<swiftui><combine><protocol-extension>","1","0","","","","CC BY-SA 4.0"
"65466576","1","65466803","","2020-12-27 14:04:14","","0","433","<p>I have a function that takes a publisher parameterlike this</p>
<pre><code>func runPublisher(publisher: AnyPublisher&lt;Void, Error&gt;, shouldLoad: Bool = true) {

}
</code></pre>
<p>When I try to convert to publisher, I get this error</p>
<pre><code>let publisher = provider.check(credentials: cred)
            .eraseToAnyPublisher()
            .tryMap({ (data) in
            })
            .mapError({ (error) -&gt; Error in
                return error
            })
            .map { _ in

                return ()
            }

runPublisher(publisher: publisher)
</code></pre>
<p>I get the error</p>
<pre><code>Cannot convert value of type 'Publishers.Map&lt;Publishers.MapError&lt;Publishers.TryMap&lt;AnyPublisher&lt;BaseResponseData&lt;AuthResponse&gt;, MoyaError&gt;, ()&gt;, Error&gt;, ()&gt;' to expected argument type 'AnyPublisher&lt;Void, Error&gt;'
</code></pre>
","8310287","","","","","2020-12-27 15:53:06","map to AnyPublisher Void","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65469679","1","65469932","","2020-12-27 19:33:17","","1","234","<p>trying to post a notification when ever the observable object changes.</p>
<p>this seems wrong. looking for a better way.</p>
<pre><code>class MyClass: ObservableObject {
    
    @Published var date: Date {
        didSet {
            NotificationCenter.default.post(name: .modified, object: self) // want to also post notifications for changes, not just publish to owners of the object
        }
    }
    @Published var a: Int {
        didSet {
            NotificationCenter.default.post(name: .modified, object: self)
        }
    }
    @Published var b: Int {
        didSet {
            NotificationCenter.default.post(name: .modified, object: self)
        }
    }
}
</code></pre>
","1532045","","","","","2020-12-27 20:02:36","How to post a notification when an observable object has changed","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65503215","1","65503279","","2020-12-30 06:57:41","","1","710","<p>I have two functions which return <strong>AnyPublisher</strong> with different failure type: <strong>Never</strong> and <strong>Error</strong>. When using these functions in the <strong>CombineLates</strong>, then compilation fails with an error: <strong>Generic struct 'CombineLatest' requires the types 'Error' and 'Never' be equivalent</strong></p>
<h3>Function which never fails:</h3>
<pre><code>func foo() -&gt; AnyPublisher&lt;Int, Never&gt; {
    Result&lt;Int, Never&gt;
        .success(1).publisher
        .eraseToAnyPublisher()
}
</code></pre>
<h3>Function which sometimes fails:</h3>
<pre><code>func boo() -&gt; AnyPublisher&lt;Int, Error&gt; {
    Result&lt;Int, Error&gt;
        .failure(NSError(domain: &quot;d&quot;, code: -1))
        .publisher.eraseToAnyPublisher()
}
</code></pre>
<h3>foo &amp; boo functions usage:</h3>
<pre><code>Publishers.CombineLatest(foo(), boo())
</code></pre>
<h3>Error generated:</h3>
<pre><code>Generic struct 'CombineLatest' requires the types 'Error' and 'Never' be equivalent
</code></pre>
<p><strong>How to use CombineLates when publisher's failure types are not equivalent?</strong></p>
","1151916","","5133585","","2020-12-30 09:45:16","2022-09-18 16:50:32","How to use CombineLates when when publishers failure types is not equivalent?","<swift><combine>","2","2","2","","","CC BY-SA 4.0"
"65508784","1","","","2020-12-30 14:44:49","","4","3399","<p>My goal is to chain multiple (two at this time) network calls with Combine, breaking chain if first call fails.</p>
<p>I have two object types: <code>CategoryEntity</code> and <code>SubcategoryEntity</code>. Every <code>CategoryEntity</code> has a property called <code>subcategoriesIDS</code>.
With first call I need to fetch all subcategories, with second I will fetch all categories and then I will create an array of <code>CategoryEntityViewModel</code>.
<code>CategoryEntityViewModel</code> contains an array of <code>SubcategoryEntityViewModel</code> based on <code>CategoryEntity</code>'s <code>subcategoriesIDS</code>.</p>
<p>Just to be clearer:</p>
<ol>
<li>Fetch subcategories</li>
<li>Fetch categories</li>
<li>Create a <code>SubcategoryEntityViewModel</code> for every fetched subcategory and store somewhere</li>
<li><code>CategoryEntityViewModel</code> is created for every category fetched. This object will be initialized with a <code>CategoryEntity</code> object and an array of <code>SubcategoryEntityViewModel</code>, found filtering matching ids between <code>subcategoriesIDS</code> and stored <code>SubcategoryEntityViewModel</code> array</li>
</ol>
<p>My code right now is:</p>
<pre><code>class CategoriesService: Service, ErrorManager {
    static let shared = CategoriesService()
    internal let decoder = JSONDecoder()
    
    @Published var error: ServerError = .none
    
    private init() {
        decoder.dateDecodingStrategyFormatters = [ DateFormatter.yearMonthDay ]
    }
    
    func getAllCategories() -&gt; AnyPublisher&lt;[CategoryEntity], ServerError&gt; {
        let request = self.createRequest(withUrlString: &quot;\(AppSettings.api_endpoint)/categories/all&quot;, forMethod: .get)
        return URLSession.shared.dataTaskPublisher(for: request)
            .receive(on: DispatchQueue.main)
            .tryMap { data, response -&gt; Data in
                guard let httpResponse = response as? HTTPURLResponse, 200..&lt;300 ~= httpResponse.statusCode else {
                    switch (response as! HTTPURLResponse).statusCode {
                    case (401):
                        throw ServerError.notAuthorized
                    default:
                        throw ServerError.unknown
                    }
                }
                return data
            }
            .map { $0 }
            .decode(type: NetworkResponse&lt;[CategoryEntity]&gt;.self, decoder: self.decoder)
            .map { $0.result}
            .mapError { error -&gt; ServerError in self.manageError(error: error)}
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
    
    func getAllSubcategories() -&gt; AnyPublisher&lt;[SubcategoryEntity], ServerError&gt; {
        let request = self.createRequest(withUrlString: &quot;\(AppSettings.api_endpoint)/subcategories/all&quot;, forMethod: .get)
        return URLSession.shared.dataTaskPublisher(for: request)
            .receive(on: DispatchQueue.main)
            .tryMap { data, response -&gt; Data in
                guard let httpResponse = response as? HTTPURLResponse, 200..&lt;300 ~= httpResponse.statusCode else {
                    switch (response as! HTTPURLResponse).statusCode {
                    case (401):
                        throw ServerError.notAuthorized
                    default:
                        throw ServerError.unknown
                    }
                }
                return data
            }
            .map { $0 }
            .decode(type: NetworkResponse&lt;[SubcategoryEntity]&gt;.self, decoder: self.decoder)
            .map { $0.result }
            .mapError { error -&gt; ServerError in self.manageError(error: error)}
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>These methods are working (<code>sink</code> is called in another class, don't think it is useful so not copied here) but I cannot find the correct way to chain them.</p>
","14913805","","14913805","","2020-12-30 15:09:32","2020-12-30 16:17:58","Chain network calls sequentially in Combine","<swift><combine>","1","2","1","","","CC BY-SA 4.0"
"65515460","1","","","2020-12-31 01:01:58","","0","676","<p>Here I have a simple SwiftUI project which has two timer publishers which are set to fire every 1 second and 2 seconds respectively.</p>
<p>The <em>expected</em> behavior is that the first label would update every second and the second label would update every 2 seconds. However what actually happens is only the first label updates every second and the second label remains at 0 indefinitely.</p>
<p>I know it's possible to make multiple timers using <code>Timer.scheduledTimer(withTimeInterval:)</code> by simply making new variables of those timer instances but it doesn't seem to work the same way with these publishers.</p>
<p>How can I make both timers work?</p>
<pre><code>import SwiftUI

struct ContentView: View {
    @State private var counter1 = 0
    @State private var counter2 = 0
    
    let timer1 = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    let timer2 = Timer.publish(every: 2, on: .main, in: .common).autoconnect()
    
    var body: some View {
        VStack(spacing: 30) {
            Text(String(counter1))
                .frame(width: 50, height: 20)
            Text(String(counter2))
                .frame(width: 50, height: 20)
        }
        .padding()
        .onReceive(timer1) {_ in
            counter1 += 1
        }
        .onReceive(timer2) {_ in
            counter2 += 2
        }
    }
}
</code></pre>
","10001194","","","","","2021-01-13 06:27:12","How to set up multiple combine timer publishers?","<swift><swiftui><combine>","1","6","","","","CC BY-SA 4.0"
"65517394","1","","","2020-12-31 06:27:28","","1","473","<p>I don't understand why I have error:</p>
<blockquote>
<p>Cannot convert return expression of type '()' to return type 'AnyPublisher&lt;[Comments], Never&gt;'</p>
</blockquote>
<pre><code>func fetchCommetsPublisher(endpoint: EndPoint) -&gt; AnyPublisher&lt;[Comments], Never&gt; {
     URLSession.shared.dataTaskPublisher(for: stringUrl(with: endpoint)!)
        .map{$0.data}
        .decode(type: [Comments].self, decoder: JSONDecoder())
        .replaceError(with: [])
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
        .assign(to: \.isFormValid, on: self)
        .store(in: &amp;cancel)
</code></pre>
<pre><code>struct Comments: Codable, Identifiable, Hashable {
    var postId: Int
    var id: Int
    var name: String
    var email: String
    var body: String
}
</code></pre>
","13065117","","8697793","","2020-12-31 17:37:57","2020-12-31 17:37:57","SwiftUI Combine cannot convert type","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"65521039","1","65521484","","2020-12-31 12:39:02","","2","66","<p>I want to send empty text inside the <code>searchText</code> to <code>AuthorService()</code> if button value <code>.isCancel</code> is true. So that my author search result will be cleaned.</p>
<pre><code>import SwiftUI
import Combine

struct AuthorSearchBar: View {
        @StateObject var service = AuthorService()
        @Binding var isCancel: Bool
        @State var emptyText = &quot;&quot;
        var body: some View {
            VStack(spacing: 0) {
               HStack {
                Image(systemName: &quot;magnifyingglass&quot;)
                if isCancel == false{
                TextField(&quot;Search&quot;, text: $service.searchText)
                } else if isCancel {
                    TextField(&quot;Search&quot;, text: $service.searchText = &quot;&quot;) 
            //Cannot assign to property: '$service' is immutable
            //Cannot assign value of type 'String' to type 'Binding&lt;String&gt;'
            //Cannot convert value of type '()' to expected argument type 'Binding&lt;String&gt;'
                }
                .padding()
                .onReceive(Just( self.isCancel ? emptyText : service.searchText), perform: { _ in
                    service.fetchData()
                })
            }
        }
}
</code></pre>
<p>My service <code>fetchData()</code> gets searchText parameter as below.</p>
<p>so I want to send &quot;&quot; to fetchData if .isCancel is true.</p>
<pre><code>class AuthorService: ObservableObject {
@Published var searchText : String = &quot;&quot;
func fetchData() {
    let parameters = [&quot;index&quot;: &quot;authors&quot;, &quot;query&quot;: &quot;\(searchText)&quot; ]
</code></pre>
","8418174","","8418174","","2020-12-31 13:32:11","2020-12-31 13:39:59","Send emptyText to Service SwiftUI","<swiftui><uitextfield><combine>","1","1","","","","CC BY-SA 4.0"
"65525930","1","","","2020-12-31 22:16:01","","0","368","<p>I have defined the following functions:</p>
<pre><code>func createAccessControl() -&gt; Future&lt;SecAccessControl, Error&gt;

func evaluatePolicy(context: LAContext, localizedReason: String) -&gt; Future&lt;LAContext, Error&gt;

func evaluateAccessControl(
    context: LAContext,
    accessControl: SecAccessControl,
    operation: LAAccessControlOperation,
    localizedReason: String
) -&gt; Future&lt;LAContext, Error&gt;

func copy(query: [String: Any]) -&gt; Future&lt;Data, Error&gt;
</code></pre>
<p>And I want to chain them together like this:</p>
<pre><code>func load(key: String, context: LAContext = LAContext(), localizedReason: String) -&gt; Future&lt;Data, Error&gt; {
        createAccessControl().flatMap { accessControl in
            evaluatePolicy(context: context, localizedReason: localizedReason)
                .flatMap { context in
                    evaluateAccessControl(context: context, accessControl: accessControl, operation: .useItem, localizedReason: localizedReason)
                }
                .flatMap { context in
                    copy(query: [
                        kSecClass as String: kSecClassGenericPassword as String,
                        kSecAttrService as String: service,
                        kSecAttrAccount as String: account,
                        kSecAttrAccessControl as String: accessControl,
                        kSecUseAuthenticationContext as String: context,
                        kSecReturnData as String: kCFBooleanTrue,
                        kSecMatchLimit as String: kSecMatchLimitOne,
                    ])
                }
        }
    }
</code></pre>
<p>However, I get this error:</p>
<pre><code>Cannot convert return expression of type 'Publishers.FlatMap&lt;Publishers.FlatMap&lt;Future&lt;Data, Error&gt;, Publishers.FlatMap&lt;Future&lt;LAContext, Error&gt;, Future&lt;LAContext, Error&gt;&gt;&gt;, Future&lt;SecAccessControl, Error&gt;&gt;' to return type 'Future&lt;Data, Error&gt;'
</code></pre>
<p>I thought <code>flatMap</code> was supposed to flatten the resulting type, but that doesn't seem to be happening the way I expect.</p>
<p>How do I chain futures together, similar to JavaScript's &quot;then&quot;?</p>
","211350","","211350","","2020-12-31 22:48:23","2020-12-31 23:24:35","How to chain Swift Futures","<swift><functional-programming><combine>","1","8","","","","CC BY-SA 4.0"
"65533070","1","","","2021-01-01 19:42:02","","0","251","<p>This is a followup question to <a href=""https://stackoverflow.com/questions/65505053/how-to-share-published-model-between-two-view-models-in-swiftui"">How to share published model between two view models in SwiftUI?</a>.</p>
<p>In order to make <strong>nested published models</strong> really publish, I used an approach described here: <a href=""https://stackoverflow.com/questions/58406287/how-to-tell-swiftui-views-to-bind-to-nested-observableobjects"">How to tell SwiftUI views to bind to nested ObservableObjects</a>. So far so good, the manual objectWillChange passing works and the changes are getting published by the parent view model.</p>
<p>But if I'm trying to use custom publishers, which tap into the published nested model, they do not function as I am used to (With regular published properties). Here is a simplified example.</p>
<p>Am I missing something?</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @StateObject var contentViewModel = ContentViewModel()
    var body: some View {
        VStack{
            // Both toggle together, indicating that objectWillChange works correctly
            ModelEditView(model: contentViewModel.model)
            ModelEditView(model: contentViewModel.model)
            // This toggle binds another not nested published property
            Toggle(&quot;Not Nested Toggle&quot;, isOn: $contentViewModel.isToggled)
            // Custom toggleChangedPublisher only works with the not nested property
            Text(contentViewModel.internalChangedValue ? &quot;true&quot; : &quot;false&quot;)
        }
    }
}

class Model: ObservableObject {
    @Published var nestedIsToggled = false
}

class ContentViewModel: ObservableObject {
    //Nested Model
    @Published var model = Model()
    //Not nested model equivalent
    @Published var isToggled = false
    //Property only altered by the custom toggleChangedPublishers
    @Published var internalChangedValue = false
    
    var anyCancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        // This should notify the &quot;parent&quot; ContentViewModel of changes in nested model
        anyCancellables.insert(model.objectWillChange.sink { [weak self] (_) in
            self?.objectWillChange.send()
        })
        nestedToggleChangedPublisher
            .receive(on: RunLoop.main)
            .assign(to: \.internalChangedValue, on: self)
            .store(in: &amp;anyCancellables)
        toggleChangedPublisher
            .receive(on: RunLoop.main)
            .assign(to: \.internalChangedValue, on: self)
            .store(in: &amp;anyCancellables)
        
    }
    private var nestedToggleChangedPublisher: AnyPublisher&lt;Bool, Never&gt; {
        // Not working on change of model
        $model
            .map({return $0.nestedIsToggled})
            .eraseToAnyPublisher()
    }
    

    private var toggleChangedPublisher: AnyPublisher&lt;Bool, Never&gt; {
        // Is working when toggled
        $isToggled
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>Thanks for your support!</p>
","11122049","","11122049","","2021-01-04 12:58:14","2021-01-04 12:58:14","Why are nested publishers not calling my custom Publishers in SwiftUI/Combine?","<ios><swift><swiftui><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"65533884","1","65536404","","2021-01-01 21:32:37","","1","127","<p>I'm new to SwiftUI and have been following along with @<a href=""https://stackoverflow.com/users/281221/peter-friese"">peter-friese</a>'s <a href=""https://youtu.be/4RUeW5rUcww"" rel=""nofollow noreferrer"">example SwiftUI/Firebase app</a>.</p>
<p>My example app works perfectly, but am now trying to modify slightly but am <strong>unable to get the correct keypath syntax of in the <code>assign/map</code> in order to set a property.</strong></p>
<p>Relevantly (and slightly simplified), there is a struct for the data model:</p>
<pre><code>struct Task: Codable, Identifiable {
  var title: String
  var status: Bool
  var flag: Bool
}
</code></pre>
<p>and a class for a view model:</p>
<pre><code>class TaskCellViewModel {
  @Published var task: Task
  var iconName:String = &quot;&quot; 
}
</code></pre>
<p>In this tutorial a <code>map/assign</code> is used within the <code>TaskCellViewModel</code> to set the value of the <code>iconName</code> property in the instance of the <code>TaskCellViewModel</code> as follows:</p>
<pre><code>private var cancellables = Set&lt;AnyCancellable&gt;()

init(task: Task) {
    self.task = task
$task
   .map { task in
            task.status ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;
        }
   .assign(to: \.iconName, on: self)
   .store(in: &amp;cancellables)
}
</code></pre>
<p>This works for setting the <code>iconName</code>. <strong>What is the correct syntax to set the <code>flag</code> property on the <code>Task</code> itself?</strong></p>
<p>I have tried various combinations but none work, including:</p>
<pre><code>.assign(to .\Task.task.flag, on: self)
.assign(to .\task.flag, on: self)
.assign(to .\Task.task.flag, on: TaskCellViewModel)
</code></pre>
<p>Using <code>Task.task.flag</code> it fails at runtime with <code>EXC_BAD_ACCESS</code> error or a type conversion compile error:</p>
<blockquote>
<p>Cannot convert value of type <code>AnswerRowViewModel.Type</code> to expected argument type <code>AnswerRowViewModel</code>.</p>
</blockquote>
<p>PS given I'm learning and trying to follow along with the tutorials, I'm hoping for a answer to the assign/map question - as opposed to a workaround/alternative.</p>
","7371966","","3585796","","2021-11-24 00:06:49","2021-11-24 00:06:49","Need keypath syntax for use in assign(to:_) in SwiftUI","<swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"65541603","1","65544683","","2021-01-02 16:45:49","","0","549","<p>Below is my code to call api and it returns Swift.Error when the api call has error.</p>
<pre><code>AccountAPI.postAccount(withSignUpCommand: signUpCommand)
            .sink(receiveCompletion: { [weak self] result in
                guard let self = self else { return }

                switch result {
                    case .finished:
                        self.logger.debug(&quot;signUp completed.&quot;)
                    case .failure(let error):
                        self.isAuthenticating = false
                        self.logger.error(&quot;signUp error : \(error)&quot;)
                }
            }, receiveValue: { [weak self] (statusCode, userId) in
                guard let self = self else { return }

                self.logger.debug(&quot;signUp status code : \(statusCode)&quot;)

                guard (200...299).contains(statusCode) else {
                    return
                }

                self.logger.debug(&quot;UserId: \(userId)&quot;)
            })
            .store(in: &amp;disposables)
</code></pre>
<p>And my publisher here</p>
<pre><code>static func postAccount(
        withSignUpCommand signUpCommand: SignUpCommand,
        apiResponseQueue: DispatchQueue = CloudHospitalClientAPI.apiResponseQueue
    ) -&gt; AnyPublisher&lt;(Int, String), Error&gt; {
        let url = &quot;\(CloudHospitalClientAPI.identityBasePath)/api/v1/accounts&quot;

        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: signUpCommand)

        return Future&lt;(Int, String), Error&gt;.init { promise in
            postAccountWithRequestBuilder(withURLString: url, withParameters: parameters, isBody: true).execute(apiResponseQueue) { result -&gt; Void in
                switch result {
                    case let .success(response):
                        promise(.success((response.statusCode, response.body!)))
                    case let .failure(error):
                        promise(.failure(error))
                }
            }
        }
        .eraseToAnyPublisher()

    }

    static func postAccountWithRequestBuilder(
        withURLString URLString: String,
        withParameters parameters: [String: Any]?,
        isBody: Bool
    ) -&gt; RequestBuilder&lt;String&gt; {

        let url = URLComponents(string: URLString)
        let requestBuilder: RequestBuilder&lt;String&gt;.Type = CloudHospitalClientAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: &quot;POST&quot;, URLString: (url?.string ?? URLString), parameters: parameters, isBody: isBody)
    }
</code></pre>
<p>When debugging this, I get below result.
<a href=""https://i.stack.imgur.com/Er933.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Er933.png"" alt=""Debugging"" /></a></p>
<p>The api error response below format and I'd like to parse this Data but can't access to this value at all.
<a href=""https://i.stack.imgur.com/oV7IC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oV7IC.png"" alt=""Error response from api(swagger)"" /></a></p>
<p>Tried to change the Return type to custom error response but had no luck.</p>
<p>Please share some advice where I can insert decoding error response code and return to caller function.</p>
<p>Thanks in advance.</p>
<p>Thanks to Bruno, below is my edited code.</p>
<pre><code>        AccountAPI.postAccount(withSignUpCommand: signUpCommand)
            .sink(receiveCompletion: { [weak self] result in
                guard let self = self else { return }

                switch result {
                    case .finished:
                        self.logger.debug(&quot;signUp completed.&quot;)
                    case .failure(let error):
                        self.isAuthenticating = false
                        self.logger.error(&quot;signUp error : \(error)&quot;)
                        if case let ErrorResponse.error(_, data, _) = error {
                            let decoder = JSONDecoder()
                            let identityErrors = try! decoder.decode([IdentityError].self, from: data!)

                            // TODO: Decode `data` here...
                            self.logger.debug(&quot;data: \(String(describing: identityErrors))&quot;)

                            self.errors = identityErrors
                        }
                }
            }, receiveValue: { [weak self] (statusCode, userId) in
                guard let self = self else { return }

                self.logger.debug(&quot;signUp status code : \(statusCode)&quot;)

                guard (200...299).contains(statusCode) else {
                    return
                }

                self.logger.debug(&quot;UserId: \(userId)&quot;)
            })
            .store(in: &amp;disposables)
</code></pre>
","4596095","","4596095","","2021-01-03 03:14:41","2021-01-03 03:14:41","How do I get Data value from Combine + Alamofire Error response?","<swift5><decoding><combine><openapi-generator>","1","0","","","","CC BY-SA 4.0"
"65543473","1","","","2021-01-02 19:57:48","","1","350","<p>I'm having a hard time understanding how JSON data is supposed to be updated in a List in SwiftUI. I'm fetching data from NewsAPI.org, my list and detail views work just fine. I'm trying to figure out how to keep the list up-to-date when my json data changes, but the data remains outdated. I'm still a beginner to swift so if I made a mistake any help would be greatly appreciated.</p>
<p>UPDATED
Attempted to use combine with the same results, outdated data</p>
<p>New data class</p>
<pre><code>class NewsData: ObservableObject {
    var objectWillChange = PassthroughSubject&lt;NewsData, Never&gt;()
    
    @Published var articles = [Article]() {
        willSet {
            objectWillChange.send(self)
        }
    }
    
    init() {
        guard let url = URL(string: &quot;http://newsapi.org/v2/top-headlines?country=us&amp;apiKey=API_KEY&quot;) else { return }
        let request = URLRequest(url: url)
        URLSession.shared.dataTask(with: request) { data, response, error in
            if let data = data {
                if let response = try? JSONDecoder().decode(News.self, from: data) {
                    DispatchQueue.main.async() {
                        self.articles = response.articles
                    }
                }
            }
        }
        .resume()
    }
    
    /*
    init() {
        URLSession.shared
            .dataTaskPublisher(for: URLRequest(url: URL(string: &quot;http://newsapi.org/v2/top-headlines?country=us&amp;apiKey=API_KEY&quot;)!))
            .map(\.data)
            .decode(type: News.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    print(error.localizedDescription)
                }
            }, receiveValue: { data in
                self.articles = data.articles
            })
            .store(in: &amp;self.cancellables)
    }
    */
    
    /*
    init() {
        load()
    }
    
    func load() {
        guard let url = URL(string: &quot;http://newsapi.org/v2/top-headlines?country=us&amp;apiKey=API_KEY&quot;) else { return }
        let request = URLRequest(url: url)
        URLSession.shared.dataTask(with: request) { data, response, error in
            if let data = data {
                if let response = try? JSONDecoder().decode(News.self, from: data) {
                    DispatchQueue.main.async() {
                        self.articles = response.articles
                    }
                }
            }
        }
        .resume()
    }
    */
}

</code></pre>
<p>My data old class</p>
<pre><code>struct News : Codable {
    var articles : [Article]
}

struct Article : Codable {
    let description : String?
    let title : String?
    let author: String?
    let source: Source
    let content: String?
    let publishedAt: String?
}

struct Source: Codable {
    let name: String?
}

class NewsData: ObservableObject {
   @Published var news: News = News(articles: [])
    
    init() {
        load()
    }
    
    func load() {
        guard let url = URL(string: &quot;http://newsapi.org/v2/top-headlines?country=us&amp;apiKey=API_KEY_HERE&quot;) else { return }
        let request = URLRequest(url: url)
        URLSession.shared.dataTask(with: request) { data, response, error in
            if let data = data {
                if let response = try? JSONDecoder().decode(News.self, from: data) {
                    DispatchQueue.main.async() {
                        self.news = response
                    }
                }
            }
        }
        .resume()
    }
}
</code></pre>
<p>My ContentView</p>
<pre><code>func relativeDate(date: String) -&gt; String {
    let formatter = RelativeDateTimeFormatter()
    let dateFormatter = ISO8601DateFormatter()
    return formatter.localizedString(for: dateFormatter.date(from: date) ?? Date(), relativeTo: Date())
}


struct ContentView: View {
    @ObservedObject var news: NewsData
    
    var body: some View {
        NavigationView {
            List(news.news.articles , id: \.title) { article in
                VStack (alignment: .leading, spacing: 5){
                    Text(article.title ?? &quot;&quot;)
                        .fontWeight(.bold)
                        .font(.subheadline)
                        .lineLimit(1)
                    Text(article.description ?? &quot;&quot;)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                   Text(relativeDate(date: article.publishedAt ?? &quot;&quot;))
                         .font(.subheadline)
                         .foregroundColor(.secondary)
                }
            }
            .navigationTitle(&quot;News&quot;)
        }
    }
}
</code></pre>
","14601731","","14601731","","2021-01-04 03:56:06","2021-01-04 03:56:06","Updating List from JSON data SwiftUI","<ios><swiftui><combine><swiftui-list>","0","6","1","","","CC BY-SA 4.0"
"65548389","1","","","2021-01-03 09:41:02","","0","367","<p>I'm trying to create a photo app in SwiftUI that display the photos from <code>PHAsset</code> on a device.
However when I keep scrolling the grid view, the memory would keep growing and eventually crash because of memory issue.</p>
<p>I'm also switching from RxSwfit to SwiftUI, so if there's a better way to construct grid items and their view models, please do suggest. Thank you.</p>
<pre><code>struct LibraryView: View {
    @ObservedObject var viewModel = ViewModel(photoLibraryService: PhotoLibraryService.shared)

    private var gridItemLayout = Array(repeating: GridItem(.flexible(), spacing: 2), count: 4)

    var body: some View {
        GeometryReader { gp in
            let width = CGFloat((Int(gp.size.width) - (2 * 3)) / 4)
            ScrollView {
                LazyVGrid(columns: gridItemLayout, spacing: 2) {
                    ForEach(viewModel.assets) { asset in
                        PhotoGridItem(asset: asset)
                            .frame(width: width, height: width)
                            .clipped()
                    }
                }
            }
        }
    }
}
</code></pre>
<pre><code>struct PhotoGridItem: View {
    @ObservedObject var viewModel: ViewModel

    init(asset: LibraryAsset) {
        viewModel = ViewModel(asset: asset)
    }

    var body: some View {
        Image(uiImage: viewModel.image)
            .resizable()
            .scaledToFill()
            .clipped()
            .onAppear {
                viewModel.fetchImage()
                print(&quot;onAppear called&quot;)
            }.onDisappear {
                viewModel.cancelRequest()
                print(&quot;onDisappear called&quot;)
        }
    }
}

extension PhotoGridItem {
    class ViewModel: ObservableObject {
        @Published var image: UIImage = UIImage()
        var imageRequestID: PHImageRequestID?

        let asset: LibraryAsset

        init(asset: LibraryAsset) {
            self.asset = asset
        }

        // Note that the completion block below would be called multiple times
        // At first a smaller image would get returned first
        // Then it would return a clear image
        // Like it's progressively loading the image
        func fetchImage() {
            DispatchQueue.global(qos: .userInteractive).async {
                let requestOptions = PHImageRequestOptions()
                requestOptions.isNetworkAccessAllowed = true
                requestOptions.deliveryMode = .opportunistic

                PHImageManager.default().requestImage(
                    for: self.asset.asset,
                    targetSize: CGSize(width: 300, height: 300),
                    contentMode: .aspectFill,
                    options: requestOptions,
                    resultHandler: { [weak self] (image: UIImage?, info: [AnyHashable: Any]?) -&gt; Void in
                        if let imageRequestID = info?[PHImageResultRequestIDKey] as? PHImageRequestID {
                            self?.imageRequestID = imageRequestID
                        }
                        DispatchQueue.main.async {
                            if let image = image {
                                self?.image = image
                            }
                        }
                    }
                )
            }
        }

        func cancelRequest() {
            image = UIImage()
            if let imageRequestID = imageRequestID {
                PHImageManager.default().cancelImageRequest(imageRequestID)
            }
        }
    }
}
</code></pre>
","2577123","","2577123","","2021-01-03 18:19:52","2021-07-13 15:01:21","SwiftUI Grid Item Memory Leak","<ios><swift><cocoa-touch><swiftui><combine>","1","0","3","","","CC BY-SA 4.0"
"65550076","1","","","2021-01-03 12:52:29","","0","324","<p>Hi So i am trying to wrap an async network request with Combine's Future/Promise.</p>
<p>my code goes something like that:</p>
<pre><code>enum State {
    case initial
    case loading
    case success(movies: [Movie])
    case error(message: String)
}

protocol ViewModelProtocol {

    var statePublisher: AnyPublisher&lt;State, Never&gt; { get }

    func load(genreId: String)
}

class ViewModel: ViewModelProtocol {

   var remoteDataSource = RemoteDataSource()

   @Published state: State = .initial
   var statePublisher: AnyPublisher&lt;State, Never&gt; { $state.eraseToAnyPubliher() }

   public func load(genreId: String) {
        self.state = .loading
        self.getMovies(for: genreId)
            .sink { [weak self] (moveis) in
                guard let self = self else { return }
                if let movies = movies {
                    self.state = .success(movies: movies)
                } else {
                    self.state = .error(message: &quot;failed to load movies&quot;)
                }
            }
   }


func getMovies(for genreId: String) -&gt; AnyPublisher&lt;[Movie]?, Never&gt; {
        Future {  promise in
            self.remoteDataSource.getMovies(for: genreId) { (result) in
                switch result {
                case .success(let movies): promise(.success(movies))
                case .failure: promise(.success(nil))
                }
            }
        }.eraseToAnyPublisher()
   }
}
</code></pre>
<p>I was trying to see if there are any memory leaks and found that there is a reference to the Future that is not being deallocated
same as here: <a href=""https://stackoverflow.com/questions/61128355/combine-future-publisher-is-not-getting-deallocated/65549919#65549919"">Combine Future Publisher is not getting deallocated</a></p>
","14931821","","14931821","","2021-01-05 14:17:44","2021-01-13 06:02:32","Combine Future publisher is leaking","<ios><swift><memory-leaks><combine>","1","2","1","","","CC BY-SA 4.0"
"65554158","1","65554638","","2021-01-03 19:41:37","","0","1130","<p>Here's a simplified example of an approach I want to take, but I can't get the simple example to work.</p>
<p>I have a Combine publisher who's subject is a view model State:</p>
<pre><code>struct State {
    let a: Bool
    let b: Bool
    let transition: Transition?
}
</code></pre>
<p>The State includes a <code>transition</code> property. This describes the <code>Transition</code> that the <code>State</code> made in order to become the current state.</p>
<pre><code>enum Transition {
    case onAChange, onBChange
}
</code></pre>
<p>I want to use <code>transition</code> property to drive animations in a <code>View</code> subscribed to the publisher so that different transitions animate in specific ways.</p>
<h1>View code</h1>
<p>Here's the code for the view. You can see how it tries to use the <code>transition</code> to choose an animation to update with.</p>
<pre><code>struct TestView: View {
    
    let model: TestViewModel

    @State private var state: TestViewModel.State
    private var cancel: AnyCancellable?

    init(model: TestViewModel) {
        self.model = model
        self._state = State(initialValue: model.state.value)
        self.cancel = model.state.sink(receiveValue: updateState(state:))
    }
    
    var body: some View {
        VStack(spacing: 20) {
            Text(&quot;AAAAAAA&quot;).scaleEffect(state.a ? 2 : 1)
            Text(&quot;BBBBBBB&quot;).scaleEffect(state.b ? 2 : 1)
        }
        .onTapGesture {
            model.invert()
        }
    }
    
    private func updateState(state: TestViewModel.State) {
        withAnimation(animation(for: state.transition)) {
            self.state = state
        }
    }

    private func animation(for transition: TestViewModel.Transition?) -&gt; Animation? {
        guard let transition = transition else { return nil }

        switch transition {
        case .onAChange: return .easeInOut(duration: 1)
        case .onBChange: return .easeInOut(duration: 2)
        }
    }
}

struct TestView_Previews: PreviewProvider {
    static var previews: some View {
        TestView(model: TestViewModel())
    }
}
</code></pre>
<h1>Model code</h1>
<pre><code>final class TestViewModel: ObservableObject {
    
    var state = CurrentValueSubject&lt;State, Never&gt;(State(a: false, b: false, transition: nil))
    
    struct State {
        let a: Bool
        let b: Bool
        let transition: Transition?
    }
    
    enum Transition {
        case onAChange, onBChange
    }

    func invert() {
        let oldState = state.value
        setState(newState: .init(a: !oldState.a, b: oldState.b, transition: .onAChange))
        setState(newState: .init(a: !oldState.a, b: !oldState.b, transition: .onBChange))
    }
    
    private func setState(newState: State) {
        state.value = newState
    }
}
</code></pre>
<p>You can see in the model code that when <code>invert()</code> is called, <em>two</em> state changes occur. The model first toggles <code>a</code> using the <code>.onAChange</code> transition, and then toggles <code>b</code> using the <code>.onBChange</code> transition.</p>
<h1>What should happen</h1>
<p>What should happen when this is run is that each time the view is clicked, the text &quot;AAAAAAA&quot; and &quot;BBBBBBB&quot; should toggle size. However, the &quot;AAAAAAA&quot; text should change quickly (1 second) and the &quot;BBBBBBB&quot; text should change slowly (2 seconds).</p>
<h1>What actually happens</h1>
<p>However, when I run this and click on the view, the view doesn't update at all.</p>
<p>I can see from the debugger that <code>onTapGesture { … }</code> is called and <code>invert()</code> is being called on the model. Also <code>updateState(state:)</code> is also being called. However, <code>TestView</code> is not changing on screen, and <code>body</code> is not invoked again.</p>
<h1>Other things I tried</h1>
<h2>Using a callback</h2>
<p>Instead of using a publisher to send the event to the view, I've tried a callback function in the model set to the view's <code>updateState(state:)</code> function. I assigned to this in the <code>init</code> of the view with <code>model.handleUpdate = self.update(state:)</code>. Again, this did not work. The function <code>invert()</code> and <code>update(state:)</code> were called, as expected, but the view didn't actually change.</p>
<h2>Using <code>@ObservedObject</code></h2>
<p>I change the model to be <code>ObservableObject</code> with its <code>state</code> being <code>@Published</code>. I set up the view to have an <code>@ObservedOject</code> for the model. With this, the view <em>does</em> update, but it updates both pieces of text using the same animation, which I don't want. It seems that the two state updates are squashed and it only sees the last one, and uses the <code>transition</code> from that.</p>
<h1>Something that did work – sort of</h1>
<p>Finally, I tried to directly copy the model's <code>invert()</code> function in to the view's <code>onTapGesture</code> handler, so that the view updates its own state directly. This did work! Which is  something, but I don't want to put all by model update logic in my view.</p>
<h1>Question</h1>
<p>How can I have a SwiftUI view subscribe to <em>all</em> states that a model sends through its publisher so that it can use a <code>transition</code> property in the state to control the animation used for that state change?</p>
","2547229","","2547229","","2021-01-04 03:39:59","2021-01-04 03:39:59","Subscribe SwiftUI View to every update of a combine publisher","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65558967","1","65559015","","2021-01-04 07:17:03","","1","288","<p>I'm new to SwiftUI, and was wondering if someone could help me make my app work. Also I'm trying to get my head around MVVM, and was wondering if I was doing it correctly.</p>
<p>The app makes a call to <a href=""https://jsonplaceholder.typicode.com/users"" rel=""nofollow noreferrer"">https://jsonplaceholder.typicode.com/users</a> and I'm trying to generate user cards based on the json response.</p>
<p><strong>Model:</strong></p>
<pre><code>import Foundation

// MARK: - User
class User: Codable {
    
    
    let id: Int
    let name, username, email: String
    let address: Address
    let phone, website: String
    let company: Company

    init(id: Int, name: String, username: String, email: String, address: Address, phone: String, website: String, company: Company) {
        self.id = id
        self.name = name
        self.username = username
        self.email = email
        self.address = address
        self.phone = phone
        self.website = website
        self.company = company
    }
}

// MARK: - Address
class Address: Codable {
    let street, suite, city, zipcode: String
    let geo: Geo

    init(street: String, suite: String, city: String, zipcode: String, geo: Geo) {
        self.street = street
        self.suite = suite
        self.city = city
        self.zipcode = zipcode
        self.geo = geo
    }
}

// MARK: - Geo
class Geo: Codable {
    let lat, lng: String

    init(lat: String, lng: String) {
        self.lat = lat
        self.lng = lng
    }
}

// MARK: - Company
class Company: Codable {
    let name, catchPhrase, bs: String

    init(name: String, catchPhrase: String, bs: String) {
        self.name = name
        self.catchPhrase = catchPhrase
        self.bs = bs
    }
}

typealias Users = [User]
</code></pre>
<p><strong>View:</strong></p>
<pre><code>import SwiftUI

struct UserView: View {
    let user: User
    
    var body: some View {
        VStack {
            Text(user.name)
                .font(.title)
                .fontWeight(.bold)
            Text(user.email)
                .font(.callout)
                .foregroundColor(.gray)
                .textCase(.uppercase)
        }
        .frame(width: 300, height: 200, alignment: .center)
        .background(Color.yellow)
        .cornerRadius(10.0)
    }
}
</code></pre>
<p><strong>ViewModel:</strong></p>
<pre><code>
import SwiftUI

class UserViewModel: ObservableObject {
    @Published var users: Users = []
    
    init() {
        fetchUsers()
    }
    
    func fetchUsers() {
        guard let url = URL(string: &quot;https://jsonplaceholder.typicode.com/users&quot;) else { print(&quot;Invalid url&quot;)
            return
        }
        
        let task = URLSession.shared.dataTask(with: url) { data, response, error in
            guard let data = data else {
                print(&quot;There was an error: \(String(describing: error?.localizedDescription))&quot;)
                return
            }
            
            do {
                let userData = try JSONDecoder().decode(Users.self, from: data)
                print(&quot;success: \(userData.capacity)&quot;)
            } catch let parsingError {
                print(&quot;There was an error: \(parsingError.localizedDescription)&quot;)
            }
        }
        
        task.resume()
        
    }
}
</code></pre>
<p>And I want to display it in a <strong>UserContainerView:</strong></p>
<pre><code>struct UserContainer: View {
    let uservm = UserViewModel()
    
    var body: some View {
        VStack {
            Button(action: uservm.fetchUsers, label: {
                Text(&quot;Fetch some users boy&quot;)
            })
            
            ForEach(uservm.users, id: \.id, content: { user in
                UserView(user: user)
            })
            
            Spacer()
        }
        
        
    }
}
</code></pre>
<p><strong>My problem is</strong> not a single UserView is displayed, because the array of Users passed to UserView is empty. Can someone tell me what am I doing wrong? I don't have a solid grasp on this. Thanks.</p>
","11914725","","","","","2021-01-04 11:23:56","Generating views from API call - SwiftUI","<swift><swiftui><combine><swiftui-state>","2","0","","","","CC BY-SA 4.0"
"65571455","1","","","2021-01-04 23:58:11","","3","968","<p>I'm starting to learn SwiftUI development, I'm making my first basic SwiftUI based news application which I plan on open sourcing but I'm currently stuck. I've been reading Apple's documentation and looking at examples on how to automatically handle data changes in SwiftUI using combine etc. I've found an <a href=""https://finsi-ennes.medium.com/build-and-update-lists-automatically-with-swiftui-and-combine-fde0cbd773f1"" rel=""nofollow noreferrer"">article</a>, that's suppose to automatically update the list. I haven't been able to see any immediate data changes or anything being logged.</p>
<p>I'm using the same structure as NewsAPI but as an example I've uploaded it to a GitHub <a href=""https://raw.githubusercontent.com/ca13ra1/data/main/data.json"" rel=""nofollow noreferrer"">repo</a>. I've made a small project and tried updating the data in my repo and trying to see any changes made in my data. I'm honestly trying my best and could really use some pointers or corrections in what my errors may be. I think my confusion lies in <code>@ObservedObject</code> and <code>@Published</code> and how to handle any changes in my content view. The article doesn't show anything they did to handle data changes so maybe I'm missing something?</p>
<pre><code>import Foundation
import Combine

struct News : Codable {
    var articles : [Article]
}

struct Article : Codable,Hashable {
    let description : String?
    let title : String?
    let author: String?
    let source: Source
    let content: String?
    let publishedAt: String?
}

struct Source: Codable,Hashable {
    let name: String?
}


class NewsData: ObservableObject {
    @Published var news: News = News(articles: [])
    
    init() {
        guard let url = URL(string: &quot;https://raw.githubusercontent.com/ca13ra1/data/main/data.json&quot;) else { return }
        let request = URLRequest(url: url)
        URLSession.shared.dataTask(with: request) { data, response, error in
            if let data = data {
                if let response = try? JSONDecoder().decode(News.self, from: data) {
                    DispatchQueue.main.async() {
                        self.news = response
                        print(&quot;data called&quot;)
                    }
                }
            }
        }
        .resume()
    }
}
</code></pre>
<p>My View</p>
<pre><code>import SwiftUI
import Combine

struct ContentView: View {
    @ObservedObject var data: NewsData
    var body: some View {
        List(data.news.articles , id: \.self) { article in
            Text(article.title ?? &quot;&quot;)
        }
    }
}
</code></pre>
","14601731","","","","","2021-01-13 04:08:53","Build and update lists automatically with SwiftUI and Combine","<ios><swift><swiftui><combine>","2","6","","","","CC BY-SA 4.0"
"65592624","1","65592730","","2021-01-06 08:41:48","","0","242","<p>Below there are three functions. The first one is the function that I need to refactor. Basically what I'm hoping for is something similar what can be achieved using Promise Kit but in this case using Swifts combine framework.</p>
<p>The second function <code>loginWithFacebook()</code> returns a <code>AuthCredential</code>.
This <code>AuthCredential</code> needs to be passed on to the last functions which returns a type <code>Future&lt;UserProfileCompact, Error&gt;</code> which is a similar return type to the main function (1st function).</p>
<p>My question is is there a way to achieve this in a Swifty way, similar to Promise Kit doing this operation:<code> return loginWithFacebook().then {loginWithFirebase(:_)}</code></p>
<pre><code>    // Call site is a View Model 
    // Main Function that needs to be refactored
    func loginwithFacebook() -&gt; Future&lt;UserProfileCompact, Error&gt; {
        //This returs a Future Firebase Credential
        loginWithFacebook()
        //The above credential needs to be passed to this method and this returns a type Future&lt;UserProfileCompact, Error&gt; 
        loginWithFirebase(&lt;#T##credentials: AuthCredential##AuthCredential#&gt;)
    }
    
    private func loginWithFacebook() -&gt; Future&lt;AuthCredential,Error&gt; {
        return Future { [weak self] promise in
            self?.loginManager.logIn(permissions: [&quot;public_profile&quot;,&quot;email&quot;], from: UIViewController()) { (loginResult, error) in
                if let error = error {
                    promise(.failure(error))
                } else if loginResult?.isCancelled ?? false {
                    //fatalError()
                }
                else if let authToken = loginResult?.token?.tokenString {
                    let credentials = FacebookAuthProvider.credential(withAccessToken: authToken)
                    
                    promise(.success(credentials))
                }
                else{
                    fatalError()
                }
            }
        }
    }
    
    private func loginWithFirebase(_ credentials: AuthCredential) -&gt; Future&lt;UserProfileCompact, Error&gt; {
        return Future { promise in
            Auth.auth().signIn(with: credentials) { (result, error) in
                if let error = error {
                    //Crashlytics.crashlytics().record(error: error)
                    promise(.failure(error))
                }
                else if let user = result?.user {
                    //Crashlytics.crashlytics().setUserID(user.uid)
                    let profile = UserProfileCompactMapper.map(firebaseUser: user)
                    promise(.success(profile))
                }
                else {
                    fatalError()
                }
            }
        }
    }
</code></pre>
","5201157","","","","","2021-01-06 08:51:01","Chaining calls when using Future in Swift similar to PromiseKit","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65604302","1","65608413","","2021-01-06 22:44:57","","2","686","<p>I'm using the timeout operator in Combine, and my understanding was that it would timeout only if a publisher does not publish an event, but it seems to timeout even if a value is published.</p>
<p>From the <a href=""https://developer.apple.com/documentation/combine/fail/timeout(_:scheduler:options:customerror:)"" rel=""nofollow noreferrer"">docs</a></p>
<blockquote>
<p>A publisher that terminates if the specified interval elapses with no events received from the upstream publisher.</p>
</blockquote>
<pre class=""lang-swift prettyprint-override""><code>import PlaygroundSupport
import Combine
import Foundation

PlaygroundPage.current.needsIndefiniteExecution = true

let subject = PassthroughSubject&lt;String, Never&gt;()
let cancellable = subject
    .timeout(.seconds(5), scheduler: DispatchQueue.main)
    .sink(
          receiveCompletion: { print (&quot;completion: \($0) at \(Date())&quot;) },
          receiveValue: { print (&quot;value: \($0) at \(Date())&quot;) }
     )

subject.send(&quot;Sending data&quot;)

/*
Prints
value: Sending data at 2021-01-06 22:41:12 +0000
completion: finished at 2021-01-06 22:41:17 +0000
*/
</code></pre>
<p>Is my understanding wrong with the operator?.</p>
","723056","","","","","2021-01-07 07:47:53","timeout operator in Combine times out even after an event is published","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"65626760","1","65682054","","2021-01-08 09:52:15","","1","219","<p>I am trying to merge two publishers but one of the completions are never run.<br/>
The following is how I create my two publishers and try to use <code>.sink</code> to observe when they complete. The <code>featureFlagPublisher</code> will finish as expected and print &quot;featureFlagPublisher done&quot;, but the <code>migratePublisher</code> and the merged publishers will never complete.<code>publisher.send(completion: .finished)</code> is run but nothing happens.</p>
<pre><code>private var cancellables = Set&lt;AnyCancellable&gt;()

func start() {
    let featureFlagPublisher = self.startFeatureFlagging()
    let migratePublisher = self.migrate()
    
    migratePublisher.sink { _ in
        print(&quot;migratePublisher done&quot;)
    } receiveValue: { _ in }.store(in: &amp;cancellables)

    featureFlagPublisher.sink { _ in
        print(&quot;featureFlagPublisher done&quot;)
    } receiveValue: { _ in }.store(in: &amp;cancellables)
    
    migratePublisher.merge(with: featureFlagPublisher)
        .sink { completion in
            print(&quot;All Done&quot;)
        } receiveValue: { _ in }
        .store(in: &amp;cancellables)
}

private func startFeatureFlagging() -&gt; AnyPublisher&lt;Bool, Never&gt; {
    let future = Future&lt;Bool, Never&gt; { promise in
        FeatureFlaggingService.shared.start {
            promise(.success(true))
        }
    }
    return future.eraseToAnyPublisher()
}


private func migrate() -&gt; AnyPublisher&lt;Bool, Never&gt;  {
    let future = Future&lt;Bool, Never&gt; { promise in 
        FavoriteMigrationsAPI.shared.get { result in
            switch result {
                case .success(let favoriteIDs):
                    promise(.success(true))
            ...
        }
    }

    return future.eraseToAnyPublisher()
}
</code></pre>
","2501509","","2501509","","2021-01-08 10:41:30","2021-01-18 07:41:00","Publisher sink never runs completion","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"65636907","1","65741413","","2021-01-08 21:52:49","","0","519","<p>I am working on a project that is using Combine to get updates from Firebase Firestore. I have a StockListView, a StockListCellView, and a StockDetailView that I want updates to be registered in.</p>
<p>The StockListView holds StockListCellViews which push StockDetailsViews onto the stack.  Each view also has a corresponding ViewModel where I am working with Combine.</p>
<p>My trouble is my StockDetailView is not receiving the updates from Combine and I can't see why. Below is a simplified version of the code for each view and viewModel. I think this has something to do with how I am assigning in the StockDetailViewModel but I can't figure it out. Any help would be appreciated.</p>
<p><strong>StockListViewModel - Works Great</strong></p>
<pre><code>class StockListViewModel: ObservableObject {
    @Published var stockRepository = StockRepository()
    @Published var stockListCellViewModels = [StockListCellViewModel]()

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        stockRepository.$stocks.map { stocks in
            stocks.map { stock in
                StockListCellViewModel(stockDetailViewModel: StockDetailViewModel(stock: stock))
            }
        }
        .assign(to: \.stockListCellViewModels, on: self)
        .store(in: &amp;cancellables)
    }
}
</code></pre>
<p><strong>StockListView - Works Great</strong></p>
<pre><code>struct StockListView: View {
    @ObservedObject var stockRepository = StockRepository()
    @ObservedObject var stockListVM = StockListViewModel()
        
    var body: some View {
       NavigationView {
                List {
                    ForEach(stockListVM.stockListCellViewModels) { stockListCellVM in
                            NavigationLink(destination: StockDetailView(stockDetailVM: stockListCellVM.stockDetailViewModel)) {
                                StockListCell(stockListVM: stockListVM, stockListCellVM: stockListCellVM)
                            }
                    }
                } // List
                .listStyle(PlainListStyle())
            .navigationBarTitle(&quot;stock&quot;)
        } // NavigationView
    } // View
}
</code></pre>
<p><strong>StockListCellViewModel - Works Great</strong></p>
<pre><code>class StockListCellViewModel: ObservableObject, Identifiable {
    var id: String = &quot;&quot;
    @Published var stockDetailViewModel: StockDetailViewModel
    @Published var stock: Stock

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(stockDetailViewModel: StockDetailViewModel) {
        self.stockDetailViewModel = stockDetailViewModel
        self.stock = stockDetailViewModel.stock

        stockDetailViewModel.$stock.compactMap { stock in
            stock.id
        }
        .assign(to: \.id, on: self)
        .store(in: &amp;cancellables)

        stockDetailViewModel.$stock.map { stock in
            StockDetailViewModel(stock: stock)
        }
        .assign(to: \.stockDetailViewModel, on: self)
        .store(in: &amp;cancellables)
    }
}
</code></pre>
<p><strong>StockListCellView - Works Great</strong></p>
<pre><code>struct StockListCell: View {
    @ObservedObject var stockListVM: StockListViewModel
    @ObservedObject var stockListCellVM: StockListCellViewModel

    var body: some View {
                Text(stockListCellVM.stock.ticker)
    }
}
</code></pre>
<p><strong>StockDetailViewModel - Not Updating</strong></p>
<pre><code>class StockDetailViewModel: ObservableObject, Identifiable {
    var id: String = &quot;&quot;
    @Published var stock: Stock
    
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(stock: Stock) {
        self.stock = stock
        self.chartColor = UIColor()

        $stock.compactMap { stock in
            stock.id
        }
        .assign(to: \.id, on: self)
        .store(in: &amp;cancellables)
}
</code></pre>
<p><strong>StockDetailView - Not Updating</strong></p>
<pre><code>struct StockDetailView: View {
    @ObservedObject var stockDetailVM: StockDetailViewModel

    var body: some View {
                    Text(stockDetailVM.stock.ticker)
    }
}
</code></pre>
","4441627","","988260","","2021-01-09 05:55:16","2021-01-15 18:09:01","Swift Combine Not Receiving Published Values","<swift><swiftui><combine>","1","9","","","","CC BY-SA 4.0"
"65649090","1","65696363","","2021-01-10 00:38:27","","0","860","<p>this question is straight forward :</p>
<p>My code :</p>
<pre><code>        return urlSession.dataTaskPublisher(for: urlRequest)
        .tryMap { (data: Data, response: URLResponse) -&gt; Data in
            //TODO: hide loader
            GRP.hideLoader()
            if let httpURLResponse = response as? HTTPURLResponse {
                if !(200...299 ~= httpURLResponse.statusCode) {
                    var error = NetworkingError(errorCode: httpURLResponse.statusCode)
                    if let json = try? JSONSerialization.jsonObject(with: data, options: []) {
                        error.jsonPayload = json
                    }
                    throw error
                }
            }
            
            if withErrorMessage, let errorCheckModel = try? JSONDecoder().decode(ErrorModel.self, from: data)
            {
                if let statusIsSuccess = errorCheckModel.success, let errorMessage = errorCheckModel.message, !errorMessage.isEmpty
                {
                    if(!statusIsSuccess)
                    {
                        print(urlString)
                        GRP.showToast(failure: true, message: errorMessage)
                    }
                }
            }

            
            return data
        }.mapError { error -&gt; NetworkingError in
            return NetworkingError(error: error)
        }
        .decode(type: T.self, decoder: decoder)
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>i made this task buikder but i am stuck, i want to know how can i implement refresh token i. Thank you.</p>
","11650653","","","","","2021-01-13 05:53:28","refresh token using combine networking ios","<ios><swift><swiftui><combine><refresh-token>","1","0","2","","","CC BY-SA 4.0"
"65649602","1","","","2021-01-10 02:20:36","","0","105","<p><strong>Scenario:</strong> Data stream that contains an item that has changed from an <code>Int</code> to <code>String</code> type causing the JSON parser to crash.</p>
<p><strong>Result:</strong> Subscriber 'sink' crashed with data type not matching the original receiving type via JSON parser.</p>
<p><strong>Goal:</strong> to convert the <code>Int</code> values to <code>String</code> to have a consistent stream for a successful parsing.</p>
<p>Here's a snippet of the data stream that has caused the crash:</p>
<pre class=""lang-json prettyprint-override""><code>...
{
  &quot;city&quot;: &quot;אלון שבות&quot;,
  &quot;sickCount&quot;: 124,
  &quot;actualSick&quot;: 15,
  &quot;verifiedLast7Days&quot;: &quot; 11-14 &quot;,
  &quot;testLast7Days&quot;: 699,
  &quot;patientDiffPopulationForTenThousands&quot;: 47
},
{
  &quot;city&quot;: &quot;סייד (שבט)&quot;,
  &quot;sickCount&quot;: &quot; קטן מ-15 &quot;,
  &quot;actualSick&quot;: &quot; קטן מ-15 &quot;,
  &quot;verifiedLast7Days&quot;: &quot;  0  &quot;,
  &quot;testLast7Days&quot;: 17,
  &quot;patientDiffPopulationForTenThousands&quot;: 4
},
...
</code></pre>
<p>Here's the error via console:</p>
<blockquote>
<p>CodingKeys(stringValue: &quot;sickCount&quot;, intValue: nil)], debugDescription: &quot;Expected to decode Int but found a string/data instead.&quot;, underlyingError: nil))</p>
</blockquote>
<p>Here's the code:</p>
<pre class=""lang-swift prettyprint-override""><code>func getData() {
    let str = &quot;https://disease.sh/v3/covid-19/gov/Israel&quot;
    let url = URL(string: str)!
    let remoteDataPublisher = URLSession.shared.dataTaskPublisher(for: url)
        .map(\.data)
        .receive(on: DispatchQueue.main)
        .decode(type: IsraelDataElement.self, decoder: JSONDecoder())
    
    remoteDataPublisher
        .eraseToAnyPublisher()
        .sink(receiveCompletion: { completion in
            switch completion {
            case .finished:
                print(&quot;{IsraelModel} Publisher Finished&quot;)
            case let .failure(anError):
                Swift.print(&quot;\nIsrael - Received error: #function&quot;, anError)
            }
        }, receiveValue: { someData in
            self.add_UUID(origData: someData)
            print(someData)
        }).store(in: &amp;cancellables)
}
</code></pre>
","715747","","988260","","2021-01-10 05:06:22","2021-01-13 04:39:02","What's the proper syntax of mapping/filtering a data-stream element to convert its data type?","<ios><json><swift><combine><urlsession>","2","8","","","","CC BY-SA 4.0"
"65691867","1","65722102","","2021-01-12 20:51:47","","2","400","<p>I am new to Combine and Sink, however the prints that I put in them do not seem to log however the result of the action completes as the user is created within AWS Amplify.</p>
<pre><code>@objc private func createAccountButtonAction(sender: UIButton) {
    print(&quot;Create Account Button Action&quot;)
    signUp(password: self.password, email: self.email)
  }
  
  func signUp(password: String, email: String) -&gt; AnyCancellable {
      let userAttributes = [AuthUserAttribute(.email, value: email)]
      let options = AuthSignUpRequest.Options(userAttributes: userAttributes)
      let sink = Amplify.Auth.signUp(username: email, password: password, options: options)
        .resultPublisher.sink(receiveCompletion: { (authError) in
          print(&quot;Failed with error: \(authError)&quot;)
        }, receiveValue: { (signUpResult) in
          print(&quot;Signed Up&quot;)
        })
    return sink
  }
</code></pre>
","5034263","","8387516","","2021-01-13 20:51:12","2021-01-14 15:40:58","Combine .sink print doesn't print","<swift><aws-amplify><combine>","1","4","","","","CC BY-SA 4.0"
"65719548","1","65719977","","2021-01-14 13:06:31","","0","222","<p>I am at the beginning phases of understanding Combine and to my surprise I actually got this simple model to work. In the model I simply pass data the .receive publisher in the init using .receive. What I'm wondering is:</p>
<ol>
<li>Is there a better way to implement this functionality</li>
<li>None of it worked until I added .store() and passed in a Set = []. which to my understanding is a way to cancel the stream of data. But although it is just to cancel to stream, the stream also will not work without it. Wondering if my understanding of that is correct and if there is a better to way to implement the cancellable.</li>
</ol>
<p><img src=""https://atenivel.sirv.com/Screen%2BRecording%2B2021-01-14%2Bat%2B07.52.40%2BAM.mp4"" alt=""Text"" /></p>
<pre><code>    import SwiftUI
import Combine

struct ContentView: View {
    @ObservedObject var viewModel = SimpleViewModel()
    @State private var changer = &quot;&quot;
    
    var body: some View {
        VStack {
            TextField(&quot;ENTER TEXT TO PASS&quot;, text: $changer)
                .padding()
                .textFieldStyle(RoundedBorderTextFieldStyle())
            HStack(alignment: .top) {
                Button(action: {
                    viewModel.changer = self.changer
                }){
                    Text(&quot;Change&quot;)
                        .fontWeight(.bold)
                        .padding()
                        .foregroundColor(.white)
                        .background(Color.blue)
                        .cornerRadius(10)
                }
                VStack {
                    Button(action: {}){
                        Text(&quot;Receive&quot;)
                            .fontWeight(.bold)
                            .padding()
                            .foregroundColor(.white)
                            .background(Color.green)
                            .cornerRadius(10)
                    }
                    Group {
                        Text(viewModel.firstValue).bold()
                        Text(viewModel.secondValue).bold()
                        Text(viewModel.thirdValue).bold()
                    }.padding(.vertical)
                }

            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

    final class SimpleViewModel: ObservableObject {
    @Published var changer = &quot;&quot;
    @Published var firstValue = &quot;Value #1&quot;
    @Published var secondValue = &quot;Value #2&quot;
    @Published var thirdValue = &quot;Value #3&quot;
    
    private var cancellableSet: Set&lt;AnyCancellable&gt; = []
    
    init() {
       $changer
        .receive(on: RunLoop.main)
        .assign(to: \.firstValue, on: self)
        .store(in: &amp;cancellableSet)
    }

}
                             
</code></pre>
","14346703","","752890","","2021-01-14 20:21:20","2021-01-14 20:21:20","Is there a better way to assign data using Combine","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65744503","1","65744543","","2021-01-15 22:43:53","","1","90","<p>I have two blocks of code, both similar.</p>
<p>One works in playground and performs as expected.</p>
<p>The other, when I make it part of a function (in an Xcode proj) does not work, and a very telltale warning from Xcode is that the 'immutable value of cancellableSink was never used'</p>
<p>I do not get that warning from Xcode when I execute this code in playgrounds. What is going on?</p>
<p>I have a feeling that my problem is not with Combine but something more fundamental</p>
<pre><code>import Foundation
import Combine


let url = URL(string: &quot;https://xkcd.com/614/info.0.json&quot;)



let publisher = URLSession.shared.dataTaskPublisher(for: url!)
    .map{ $0.data }
    .decode(type: Joke.self, decoder: JSONDecoder())
    .map { $0.img}

let cancellableSink = publisher
    .sink(receiveCompletion: { completion in
        print(String(describing: completion))
    }, receiveValue: { value in
        print(&quot;Returned value: \(value)&quot;)
    })
</code></pre>
<p><strong>The code snippet above will work in playground</strong> .. but why wouldn't this work in a Xcode proj inside of a function.</p>
<p>Below is a warning that I will get in a Xcode proj that I cannot repeat in playgrounds</p>
<p><img src=""https://atenivel.sirv.com/Screen%20Shot%202021-01-15%20at%205.16.01%20PM.png"" alt=""Text"" /></p>
","14346703","","8697793","","2021-01-15 22:49:27","2021-01-15 22:49:27","Combine snippet not working in function, how do I get this to work","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65747222","1","65747301","","2021-01-16 07:00:22","","0","407","<p>In my Combine pipeline, I'm trying to prevent the upstream from terminating by using <code>flatMap</code> to catch the error outside of the original publisher:</p>
<pre><code>PlaygroundPage.current.needsIndefiniteExecution = true

let cancellable = Timer.publish(every: 1, on: .main, in: .default)
    .autoconnect()
    .flatMap { _ in
        Timer.publish(every: 1, on: .main, in: .default)
            .autoconnect()
            .tryMap { value throws -&gt; String? in
                return &quot;\(Date())&quot;
            }
            .catch { _ in
                Just(nil)
            }
            .filter { $0 != nil }
    }
    .sink { _ in
        print(&quot;complete&quot;)
        PlaygroundPage.current.finishExecution()
    } receiveValue: {
        print(&quot;sink: \(String(describing: $0))&quot;)
    }
</code></pre>
<p>Although this never terminates the upstream publisher when an error is replaced with a <code>nil</code>, it's duplicating every upstream event for some reason. The above code will result as:</p>
<pre><code>sink: Optional(&quot;2021-01-16 06:49:58 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:49:59 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:49:59 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:00 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:00 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:00 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
</code></pre>
<p>On the first event, output is just once. Second upstream event, it's twice. Third upstream result in three outputs and so on.</p>
<p>It seems like <code>flatMap</code> creates a new publisher every upstream event and stays alive. How do I cancel the previous flatMaps and always get one value, or is there a better way to do this? I don't want past upstream events to stay alive, I only care of the one value not old ones. I'd want to end up with something like:</p>
<pre><code>sink: Optional(&quot;2021-01-16 06:49:58 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:49:59 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:00 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:01 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:02 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
sink: Optional(&quot;2021-01-16 06:50:03 +0000&quot;)
</code></pre>
","235334","","","","","2021-01-16 07:14:23","Combine FlatMap duplicates for every new successful upstream","<swift><combine>","1","4","","","","CC BY-SA 4.0"
"65748175","1","","","2021-01-16 09:33:45","","1","147","<p>I'd like to use <code>@AppStorage(&quot;interval&quot;)</code> to initialize <code>timer</code>. I cannot do this in the struct initialization because I'll get an error. But if I try to do declare <code>timer</code> first and initialize it in <code>startTimer()</code>, I get all sorts of errors as well. What's the best way to make sure <code>interval</code> is available to initialize <code>timer</code>? Here's the relevant code:</p>
<pre><code>struct ContentView: View {
    @AppStorage(&quot;interval&quot;) var interval = 5.0
    @State private var timer = Timer.publish(every: interval, on: .main, in: .common).autoconnect()
    //or try this:
    @State private var timer: Publishers.Autoconnect&lt;Timer.TimerPublisher&gt;?
    //or try this:
    @State private var timer: Publishers.Autoconnect&lt;Timer.TimerPublisher&gt;? = nil

    init() {
        startTimer()
    }

    func startTimer() {
        timer = Timer.publish(every: interval, on: .main, in: .common).autoconnect()
    }

    func stopTimer() {
        timer.upstream.connect().cancel()
    }
}
</code></pre>
","1091437","","8697793","","2021-01-16 10:57:32","2021-01-16 11:14:32","Declare Timer.TimerPublisher","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"65762338","1","","","2021-01-17 15:12:42","","1","96","<p>In general, do you feel that Combine has developed enough that it can replace Cocoa Bindings?</p>
<p>I want to create a data model that is totally based on Combine @Published properties and attach it to my view controller and view with Combine.</p>
<p>But before I spend all the effort, I wanted to get you all’s thoughts on potential pitfalls or considerations I should be taking into account. Should I just stick with tried and true Cocoa Bindings?</p>
<p>Thanks!</p>
","1922718","","4244136","","2021-01-17 20:10:49","2021-01-17 20:10:49","Combine vs. Cocoa Bindings","<swift><macos><cocoa><combine>","1","0","1","2021-01-17 18:49:41","","CC BY-SA 4.0"
"65767117","1","","","2021-01-17 23:38:50","","0","393","<p>I'm new to the Combine Framework and SwiftUI in general, I'm stuck trying to handle errors from a <code>dataTaskPublisher</code>.
The API I'm working with is returning a JSON file containing the data of the user and a 204 status response code if the user doesn't exist.</p>
<p>I created a simple struct to manage the User data and his state after the request is done:</p>
<pre><code>struct User: Decodable{
    enum UserState {
        case unknown, Valid, errorDecoding, errorNetwork, noUser
    }
    
    // Attributes of the decodable struct
    // ...
    //
    
    var status: UserState = .unknown
}
</code></pre>
<p>In the <code>ViewModel</code> I created an instance of <code>User</code> and a function that gets the data from the API. I just want to assign the data to the User instance and set the status of the user accordingly to the status of the API request.</p>
<p>This works fine when the API return some valid result and the publisher finishes assigning the data in the <code>receiveValue</code>.</p>
<p>The issues starts when the <code>tryMap</code> throws some errors: the errors are correctly handled by <code>mapError</code> and then the <code>receiveCompletion</code> is executed, however when it finishes the status of the user is still set to .unknown as if the user instance was never edited.</p>
<pre><code>final class ViewModel: ObservableObject {
    
    @Published var user = User()
    private var cancellables = Set&lt;AnyCancellable&gt;()

    func getuser() {
        enum UserError: Error {
            case unknown, noUser, network, badURL, decoding
        }
        
        let url = URL(string: &quot;https://www.example.com/JSON&quot;)!
        
        URLSession.shared.dataTaskPublisher(for: url)
            .tryMap { (data, response) in
                guard let httpResponse = response as? HTTPURLResponse else { throw UserError.badURL }
                if httpResponse.statusCode == 204 {
                    throw UserError.noUser
                } else if httpResponse.statusCode != 200 {
                    throw UserError.network
                }
                return data
            }
            .decode(type: User.self, decoder: JSONDecoder())
            .receive(on: DispatchQueue.main)
            .mapError({ error -&gt; UserError in
                switch error {
                case is Swift.DecodingError:
                    return .decoding
                case is UserError:
                    return error as! UserError
                default:
                    return .unknown
                }
            })
            .sink(receiveCompletion: { completion in
                switch completion {
                case .failure(.decoding):
                    print(&quot;Error decoding&quot;)
                    self.user.status = .errorDecoding
                case .failure(.network):
                    print(&quot;Error network&quot;)
                    self.user.status = .errorNetwork
                case .failure(.noUser):
                    print(&quot;Error no User&quot;)
                    self.user.status = .noUser
                case .failure(.badURL):
                    print(&quot;Error bad URL&quot;)
                    self.user.status = .errorNetwork
                case .failure(.unknown):
                    print(&quot;Error unknown&quot;)
                    self.user.status = .unknown
                case .finished:
                    break
                }
            }, receiveValue: { user in
                self.user = user
                self.user.status = .Valid
            })
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>Any ideas about what i did wrong here?
Is there maybe a better way to accomplish what i need to do?</p>
<p>Thanks</p>
","3929403","","","","","2021-01-17 23:38:50","URLSession.DataTaskPublisher doesn't publish values when throws an error","<ios><swift><xcode><swiftui><combine>","0","6","0","","","CC BY-SA 4.0"
"65779662","1","65780031","","2021-01-18 17:53:05","","2","999","<p>I've tried creating my own <code>ProgressView</code> to support iOS 13, but for some reason it appears to not work. I've tried <code>@State</code>, <code>@Binding</code> and the plain <code>var progress: Progress</code>, but it doesn't update at all.</p>
<pre class=""lang-swift prettyprint-override""><code>struct ProgressBar: View {
    @Binding var progress: Progress

    var body: some View {
        VStack(alignment: .leading) {
            Text(&quot;\(Int(progress.fractionCompleted))% completed&quot;)
            ZStack {
                RoundedRectangle(cornerRadius: 2)
                    .foregroundColor(Color(UIColor.systemGray5))
                    .frame(height: 4)
                GeometryReader { metrics in
                    RoundedRectangle(cornerRadius: 2)
                        .foregroundColor(.blue)
                        .frame(width: metrics.size.width * CGFloat(progress.fractionCompleted))
                }
            }.frame(height: 4)
            Text(&quot;\(progress.completedUnitCount) of \(progress.totalUnitCount)&quot;)
                .font(.footnote)
                .foregroundColor(.gray)
        }
    }
}
</code></pre>
<p>In my content view I added both the iOS 14 variant and the iOS 13 supporting one. They look the same, but the iOS 13 variant does not change anything.</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    @State private var progress = Progress(totalUnitCount: 10)
    let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()

    var body: some View {
        VStack {
            ProgressBar(progress: $progress)
                .padding()
                .onReceive(timer) { timer in
                    progress.completedUnitCount += 1
                    if progress.isFinished {
                        self.timer.upstream.connect().cancel()
                        progress.totalUnitCount = 500
                    }
                }
            if #available(iOS 14, *) {
                ProgressView(progress)
                    .padding()
                    .onReceive(timer) { timer in
                        progress.completedUnitCount += 1
                        if progress.isFinished {
                            self.timer.upstream.connect().cancel()
                            progress.totalUnitCount = 500
                        }
                    }
            }
        }
    }
}
</code></pre>
<p>The iOS 14 variant works, but my iOS 13 implementation fails. Can somebody help me?</p>
","5530076","","","","","2022-08-23 15:02:56","ProgressBar iOS 13","<swift><swiftui><progress-bar><combine>","1","0","2","","","CC BY-SA 4.0"
"65797398","1","65800729","","2021-01-19 18:30:24","","1","1042","<p>As example I have a basic published value like</p>
<pre class=""lang-swift prettyprint-override""><code>@Published var value: String
</code></pre>
<p>I have want to validates this value of my form to give my user an output. For that I will use Combine in my MVVM project.</p>
<p>Now this type of value needs to be validated against my REST API. For my REST API I already have a method to get my results of my like <code>getFirstMailboxRedirectFromAPI</code> which returns <code>AnyPublisher&lt;MailboxAPIResponse, APIError&gt;</code>. MailboxAPIResponse is a decodable object for the api response. So if I just want to display the result, I create a subscriber with <code>.sink</code> add the result to a variable which will be shown in a view. So good so far. Now my problem:</p>
<p>As described in the first section my value is already a Publisher (because of @Published), where I can do some <code>.map</code> stuff for validation with it and returning true or false if everything is fine or not.</p>
<p>So to validate my published value I need to call my other Publisher which uses the API to check if the value already exists. But I don't know how this should work.</p>
<p>This is my code so far but this doesn't work. But this shows you my idea how it should work.</p>
<pre class=""lang-swift prettyprint-override""><code>private var isMailboxRedirectNameAvailablePublisher: AnyPublisher&lt;Bool, Never&gt; {
    $mailboxRedirectName
        .debounce(for: 0.5, scheduler: RunLoop.main)
        .setFailureType(to: Error.self)
        .flatMap { name in
            self.getFirstMailboxRedirectFromAPI(from: name, and: self.domainName)
                .map { apiResponse in
                    return apiResponse.response.data.count == 0
                }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>So in result the publisher should use the redirectName to call the API and the API gives me the result if the mailbox already exists, then returns a boolean, if it's existing or not.</p>
<p>How can I nest multiple publishers and use the result of the API publisher in my published value publisher?</p>
","9618687","","8080648","","2021-01-19 22:51:44","2021-01-19 22:55:30","Use result of publisher in map of another publisher","<swift><mvvm><combine><flatmap><publisher>","1","0","","","","CC BY-SA 4.0"
"65800839","1","","","2021-01-19 23:06:47","","0","343","<p>The data that I need to create a model are split and only receivable via two API requests.</p>
<p>The first (<code>query.snapshotPublisher()</code>) publisher will get the main part of the model (inclusive it's ID) and the second request (<code>getPersonalLikeCount(blogModel: blogModel, userID: &quot;408VYXScmxUtUQB91EoTf0LEMgj2&quot;)</code>) will get some additional data and needs the ID (which is part of the model that's why I'm passing the complete model) that I got from the first request.</p>
<p>If both requests would be independent I would use the <code>.Zip(other: )</code> operator but since the second one depends on the first one I tried the following to be able to pass the model to the second publisher.</p>
<p>But with this approach the second publisher get's cancelled after sending the first value and therefore won't update the model even when the <code>getPersonalLikeCount</code> publisher gets new data and should publish them again.</p>
<pre><code>private func getBlogs(from query: Query) -&gt; AnyPublisher&lt;BlogModel, Error&gt; {
    let publisher = query.snapshotPublisher()
        .flatMap { [self] blogModel -&gt; AnyPublisher&lt;(BlogModel, Int), Never&gt; in
            let blogModelPublisher = Just(blogModel)
            let likeCountPublisher = getPersonalLikeCount(blogModel: blogModel, userID: &quot;408VYXScmxUtUQB91EoTf0LEMgj2&quot;)
            let combined = Combine.Publishers.Zip(blogModelPublisher, likeCountPublisher)
            return combined.eraseToAnyPublisher()
        }
        .map { blogModel, personalLikeCount -&gt; BlogModel in
            var newModel = blogModel
            newModel.personalLikeCount = personalLikeCount
            return newModel
        }
        .eraseToAnyPublisher()
    return publisher
}
</code></pre>
","13799435","","","","","2021-01-20 03:16:05","How to zip two publishers if the second one depends on the values received by the first one?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"65813674","1","","","2021-01-20 16:34:56","","0","71","<p>I have a view that includes a ForEach, and I have a button that adds more items to the list. In each instance, in the loop, I have a TextField that is pre-filled with an autogenerated counter name. But when I add a new instance, all the previously added items change the name to the same:</p>
<p><a href=""https://i.stack.imgur.com/uN2Pql.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uN2Pql.png"" alt=""After adding one"" /></a><br /></p>
<p><a href=""https://i.stack.imgur.com/Qv1gwl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Qv1gwl.png"" alt=""After adding 2, both elements are called Counter 2"" /></a><br /></p>
<p><a href=""https://i.stack.imgur.com/xmzmtl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/xmzmtl.png"" alt=""After adding 3, all elements are called Counter 3"" /></a></p>
<p>What I would like is to have the counter names be Counter 1 for the first, the second Counter 2, third Counter 3, etc.</p>
<p>Here's my code:</p>
<pre class=""lang-swift prettyprint-override""><code>    import SwiftUI

    struct Counter: Identifiable, Equatable {
        var id: UUID = UUID()
        var name: String = &quot;&quot;
        var rows: Int = 0
        var repeats: Int?
        var rowsPerRepeat: Int?
        var countRepeats: Bool = false
    }

    struct Project: Identifiable, Equatable {
       var id:UUID = UUID()
       var name:String = &quot;&quot;
       var counters: [Counter] = [Counter]()
    }

    class AddEditCounterViewModel : ObservableObject {
        @Published var counter : Counter
        @Published var project: Project
       
        init(counter: Counter, project: Project) {
            self.project = project
           self.counter = counter
           if self.counter.name.isEmpty {
               self.counter.name = counterNameGenerator()
           }
       }
       
        func counterNameGenerator() -&gt; String {
            let count = project.counters.count
            return String.localizedStringWithFormat(NSLocalizedString(&quot;Counter %d&quot;, comment: &quot;Counter name&quot;), count)
       }
       
       func countRepeats(countRepeats : Bool) {
           if countRepeats {
               counter.countRepeats = true
               if counter.rowsPerRepeat == nil {
                   counter.rowsPerRepeat = 2
               }
           } else {
               counter.countRepeats = false
               counter.rowsPerRepeat = nil
           }
       }
    }

    struct AddEditCounterView: View {
       @ObservedObject var viewModel : AddEditCounterViewModel
       
       @State var countRepeats = false
       @State var hiddenHeight : CGFloat = 0.0
        @State var opacity = 0.0
       
       init(viewModel: AddEditCounterViewModel) {
           self.viewModel = viewModel
       }
       
       var body: some View {
           VStack(spacing: 20) {
               VStack (alignment: .leading) {
                   
                   Text(&quot;Counter Name&quot;)
                       .multilineTextAlignment(.leading)
                   TextField(&quot;&quot;, text: $viewModel.counter.name)
               }
               HStack {
                   Text(&quot;Start at&quot;)
                       .multilineTextAlignment(.leading)
                   Spacer()
                   TextField(&quot;&quot;, value: $viewModel.counter.rows, formatter: NumberFormatter())
                       .keyboardType(.numberPad)
                       .multilineTextAlignment(.center)
                       .frame(width: 70.0, height: nil, alignment: .leading)
               }.frame(maxWidth: .infinity, alignment: .leading)
               
               Toggle(isOn: $countRepeats) {
                       Text(&quot;Count sets (repeats)&quot;)
               }.onChange(of: countRepeats, perform: { value in
                   viewModel.countRepeats(countRepeats: value)
                   hiddenHeight = value ? 30.0 : 0
                   opacity = value ? 1 : 0
               })
               HStack {
                   Text(&quot;How many rows per set (repeat)&quot;)
                       .multilineTextAlignment(.leading)
                   Spacer()
                   TextField(&quot;&quot;, value: $viewModel.counter.rowsPerRepeat, formatter: NumberFormatter())
                       .keyboardType(.numberPad)
                       .multilineTextAlignment(.center)
                       .frame(width: 70.0, height: nil, alignment: .leading)
               }
               .opacity(opacity)
               .frame(maxWidth: .infinity, maxHeight: $hiddenHeight.wrappedValue, alignment: .leading)
               .animation(.easeIn)
           }
       }
    }


    class AddEditProjectViewModel: ObservableObject  {
       @Published var project : Project
       
       init(project: Project) {
           self.project = project
           if self.project.counters.count &lt; 1 {
               addNewCounter()
           }
       }
       func addNewCounter()  {
           project.counters.append(Counter())
       }
    }

    struct AddEditProjectView: View {
       
       @ObservedObject var viewModel : AddEditProjectViewModel
       
       var body: some View {
          
           VStack {
                ForEach(viewModel.project.counters) { counter in
                    AddEditCounterView(viewModel: AddEditCounterViewModel(counter: viewModel.project.counters[0], project: viewModel.project))
                }
               Button( action: {
                   viewModel.addNewCounter()
               }){
                   Text(&quot;Add Counter&quot;)
               }
           }
       }
    }

    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            AddEditProjectView(viewModel: AddEditProjectViewModel(project: Project()))
        }
    }

</code></pre>
","1394457","","","","","2021-01-20 16:34:56","Keeping instances unique inside ForEach in SwiftUI","<swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"65817307","1","","","2021-01-20 20:39:16","","1","82","<p><strong>Goal:</strong> To use a common header View containing a shared title Text().</p>
<p><strong>Scenario:</strong> I have multiple Views that share a common tab space <em>within the one container tab View</em> that contains a struct Header that is to be shared.</p>
<p>👉 This is a (many : 1) scenario.</p>
<p><strong>Note:</strong> I don't want to use a NavigationView because it screws up landscape mode.  A simple small header View is fine.  I just need to populate the shared Title space amongst the member Views.
<br/>
I don't want to merely add duplicate headers (having exactly the same layout) for each member View.</p>
<p><strong>Several ideas:</strong> I need the header to respond to the 'change of title' event so I can see the new title.</p>
<p>
So I believe I could use 1) @Binder(each member View) --> @State (shared Header View) or <br/> 2) @Environment.
<p>
I don't know how I could fit #1 into this particular scenario. <br/>
So I'm playing with #2: Environment Object.
<p><strong>DesignPattern:</strong> Main Header View's title set by multiple Views so the Header View is not aware of the multiple Views:</p>
<p><a href=""https://i.stack.imgur.com/v4goW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/v4goW.png"" alt=""enter image description here"" /></a></p>
<p>I'm not getting the EnvironmentObject paradigm to work.</p>
<p>Here's the codes... <br>
MainView:</p>
<pre><code>import SwiftUI

// Need to finish this.

class NYTEnvironment {
    var title = &quot;Title&quot;
    var msg = &quot;Mother had a feeling...&quot;
}

class NYTSettings: ObservableObject {
    @Published var environment: NYTEnvironment
    init() {
        self.environment = NYTEnvironment()
    }
}

struct NYTView: View {
    var nytSettings  = NYTSettings()
     
    @State var selectionDataSegmentIndex = 0

    var bindingDataSourceSegment: Binding&lt;Int&gt; {
        .init(get: {
            selectionDataSegmentIndex
        }, set: {
            selectionDataSegmentIndex = $0
        })
    }

    var body: some View {
        let county = 0; let state = 1; let states = 2

        VStack {
            NYTHeaderView()
            SegmentAndDataPickerVStack(spacing: 10) {
                if let segments = Source.NYT.dataSegments {
                    Picker(&quot;NYT Picker&quot;, selection: bindingDataSourceSegment) {
                        ForEach(segments.indices, id: \.self) { (index: Int) in
                            Text(segments[index])
                        }
                    }.pickerStyle(SegmentedPickerStyle())
                }
            }
            if selectionDataSegmentIndex == county {
                NYTCountyView()
            } else if selectionDataSegmentIndex == state {
                NYTStateView()
            } else if selectionDataSegmentIndex == states {
                NYTStatesView()
            }
            Spacer()
        }.environmentObject(nytSettings)
    }

    struct TrailingItem: View {
        var body: some View {
            Button(action: {
                print(&quot;Info&quot;)
            }, label: {
                Image(systemName: &quot;info.circle&quot;)
            })
        }
    }
}

// ====================================================================================

struct NYTHeaderView: View {
    @EnvironmentObject var nytSettings: NYTSettings
    var body: some View {
        ZStack {
            Color.yellow
            Text(nytSettings.environment.title)
        }.frame(height: Header.navigationBarHeight)
    }
}
</code></pre>
<p>Revision: I've added EnvironmentObject modifiers to the memberViews():</p>
<pre><code>if selectionDataSegmentIndex == county {
                NYTCountyView().environmentObject(NYTSettings())
            } else if selectionDataSegmentIndex == state {
                NYTStateView().environmentObject(NYTSettings())
            } else if selectionDataSegmentIndex == states {
                NYTStatesView().environmentObject(NYTSettings())
            }
            ...
</code></pre>
<p>
One of the member Views that's within the Main Container/Tab View (per above):
<pre><code>struct NYTCountyView: View {
    @ObservedObject var dataSource = NYTCountyModel()
    @EnvironmentObject var nytSettings: NYTSettings
    ...
    ...

 }.onAppear {
       nytSettings.environment.title = &quot;Selected Counties&quot;
                            
       if dataSource.revisedCountyElementListAndDuration == nil {
              dataSource.getData()
          }
       }
       Spacer()
       ...
}
</code></pre>
<p>Here's the compile-time error:</p>
<p><a href=""https://i.stack.imgur.com/NAfnl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NAfnl.png"" alt=""enter image description here"" /></a></p>
<p><strong>Modus Operandi:</strong> Set the title w/in header per member View upon .onAppear().</p>
<p><strong>Problem:</strong> I'm not getting any title; just the default &quot;Title&quot; value.</p>
<p><strong>Question:</strong> Am I on the right track?  <br/>If so, what am I missing?
<br/> or... is there an alternative?</p>
","715747","","715747","","2021-01-21 00:50:20","2021-01-21 16:33:06","Setting a shared title within a common Header View amongst Views; per Active View","<ios><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"65831741","1","65832036","","2021-01-21 16:33:12","","1","115","<p>Kotlin’s coroutines provide the ability to write very flat code. I am trying to work on converting some of the async iOS code to utilize Combine to flatten it out on my end as well.</p>
<p><strong>Kotlin looks like:</strong></p>
<pre><code>private suspend fun getData(
        networkCall: Boolean = true,
        networkRequest: suspend () -&gt; Either&lt;FieldError, List&lt;JobModel&gt;&gt;,
        localRequest: suspend () -&gt; Either&lt;FieldError, List&lt;JobModel&gt;&gt;,
        cache: suspend (data: List&lt;JobModel&gt;) -&gt; Unit
): Either&lt;FieldError, List&lt;JobModel&gt;&gt; {
    // getting of Jobs and passing in pair if result was from network
    var resultNetwork = false
    var result: Either&lt;FieldError, List&lt;JobModel&gt;&gt; = Left(GenericError)
    if (!networkCall) {
        result = localRequest()
    }
    // if it was not a network call and failed we will force network call
    if (networkCall || result.isLeft()) {
        resultNetwork = true
        result = networkRequest()
    }

    if (result is Either.Right &amp;&amp; resultNetwork) {
        cache(result.b)
    }

    return result

}
</code></pre>
<p><strong>Swift WIP looks like:</strong></p>
<pre><code>public func getData(isNetworkCall: AnyPublisher&lt;Bool, Error&gt;,
                    networkRequest: AnyPublisher&lt;[Job], Error&gt;,
                    localRequest: AnyPublisher&lt;[Job], Error&gt;,
                    cache: ([Job]) -&gt; AnyPublisher&lt;Void, Error&gt;) -&gt; AnyPublisher&lt;[Job], Error&gt;? {
    
    let getJobsRequest =  isNetworkCall.flatMap { (isCall) in
        return isCall
            ? networkRequest
            //.also { jobs in cache(jobs) }
            .catch{ _ in return localRequest }
            .eraseToAnyPublisher()
            : localRequest
    }.eraseToAnyPublisher()
    
    return getJobsRequest
}
</code></pre>
<p>How do I add this logic of caching data as part of this AnyPublisher? I would like to have it cache in the midst of this logic transformation. Ideally there could be an <em>also</em> function that appends logic when the transaction is being completed by the subscriber.</p>
<p><strong>Solution:</strong></p>
<pre><code>private func getData(isNetworkCall: AnyPublisher&lt;Bool, Error&gt;,
                         networkRequest: AnyPublisher&lt;[Job], Error&gt;,
                         localRequest: AnyPublisher&lt;[Job], Error&gt;,
                         cache: @escaping ([Job]) -&gt; AnyPublisher&lt;Void, Error&gt;) -&gt; AnyPublisher&lt;[Job], Error&gt; {
    
    // Sequence of steps for when we should do a network call
    let networkCallFlow = networkRequest
        .flatMap { jobs in // cache jobs from network
            cache(jobs)
                .replaceError(with: ()) // fire and forget cache, replace error with Void to continue
                .map { _ in jobs } // need to give back jobs to flatMap
                .setFailureType(to: Error.self) // match failure type
        }
        .catch { _ in localRequest } // return local if network fails
        .eraseToAnyPublisher()
    
    // Sequence of steps for when we should get from local
    let localCallFlow = localRequest
        .catch { _ in networkCallFlow } // do network flow if local call fails
        .eraseToAnyPublisher()

    return isNetworkCall
        .flatMap { $0 ? networkCallFlow : localCallFlow }
        .eraseToAnyPublisher()
}
</code></pre>
","15053529","","15053529","","2021-01-21 23:24:05","2021-01-21 23:24:05","Add additional logic to chain of publisher transformation without affecting Publisher type","<ios><swift><kotlin><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"65851027","1","65851523","","2021-01-22 18:46:18","","7","1381","<p>I have a question about the <a href=""https://developer.apple.com/documentation/combine/fail/subscribe(on:options:)"" rel=""noreferrer"">subscribe(on:options:)</a> operator. I would appreciate if anyone can help me to figure it out.</p>
<p>So what we have from the documentation:</p>
<blockquote>
<p>Specifies the scheduler on which to perform subscribe, cancel, and request operations.
In contrast with receive(on:options:), which affects downstream messages, subscribe(on:options:) changes the execution context of upstream messages.</p>
</blockquote>
<p>Also, what I got from different articles is that unless we explicitly specify the <code>Scheduler</code> to receive our downstream messages on (using <code>receive(on:options:)</code>), messages will be send on the <code>Scheduler</code> used for receiving a subscription.</p>
<p>This information is not aligned with what I am actually getting during the execution.</p>
<p>I have the next code:</p>
<pre><code>Just(&quot;Some text&quot;)
    .map { _ in
        print(&quot;Map: \(Thread.isMainThread)&quot;)
    }
    .subscribe(on: DispatchQueue.global())
    .sink { _ in
        print(&quot;Sink: \(Thread.isMainThread)&quot;)
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>I would expect next output:</p>
<pre><code>Map: false
Sink: false
</code></pre>
<p>But instead I am getting:</p>
<pre><code>Map: true
Sink: false
</code></pre>
<p>The same thing happens when I use <code>Sequence</code> publisher.</p>
<p>If I swap the position of <code>map</code> operator and <code>subscribe</code> operator, I receive what I want:</p>
<pre><code>Just(&quot;Some text&quot;)
    .subscribe(on: DispatchQueue.global())
    .map { _ in
        print(&quot;Map: \(Thread.isMainThread)&quot;)
    }
    .sink { _ in
        print(&quot;Sink: \(Thread.isMainThread)&quot;)
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>Output:</p>
<pre><code>Map: false
Sink: false
</code></pre>
<p>Interesting fact is that when I use the same order of operators from my first listing with my custom publisher, I receive the behaviour I want:</p>
<pre><code>struct TestJust&lt;Output&gt;: Publisher {
    typealias Failure = Never
    
    private let value: Output
    
    init(_ output: Output) {
        self.value = output
    }
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
        subscriber.receive(subscription: Subscriptions.empty)
        _ = subscriber.receive(value)
        subscriber.receive(completion: .finished)
    }
}

TestJust(&quot;Some text&quot;)
    .map { _ in
        print(&quot;Map: \(Thread.isMainThread)&quot;)
    }
    .subscribe(on: DispatchQueue.global())
    .sink { _ in
        print(&quot;Sink: \(Thread.isMainThread)&quot;)
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>Output:</p>
<pre><code>Map: false
Sink: false
</code></pre>
<p>So I think there is either my total misunderstanding of all these mechanisms, or some publishers intentionally choose the thread to publish values (<code>Just</code>, <code>Sequence</code> -&gt; <code>Main</code>, <code>URLSession.DataTaskPublisher</code> -&gt; <code>Some of Background</code>), which does not make sense for me, cause in this case why would we need this <code>subscribe(on:options:)</code> for.</p>
<p>Could you please help me to understand what am I missing? Thank you in advance.</p>
","12178141","","","","","2021-01-22 22:14:03","Combine`s subscribe(on:options:) operator","<swift><combine><frp>","1","0","1","","","CC BY-SA 4.0"
"65880240","1","65880337","","2021-01-25 06:59:53","","0","316","<p>I have a view performing expensive updates so I'd like to throttle them:</p>
<p>currently my view is like this:</p>
<pre><code>struct CodeGenerationView: View {
    @StateObject var root: RootState
    var body: some View {
        Text(CodeGenerator.generate(root: root))
    }
}
</code></pre>
<p>so it is called on each update.</p>
<p>I'd like to throttle the changes to update only once a second</p>
<p>is this possible?</p>
","1532045","","","","","2021-01-25 07:08:57","how can i throttle changes to stateobject in swiftui","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"65891565","1","","","2021-01-25 19:57:17","","0","355","<p>I'm new to SwiftUI and Combine, and have a simple project that I'm using to test.  I'm using the <code>CDPublisher</code> class outlined in <a href=""https://medium.com/better-programming/combine-publishers-and-core-data-424b68fe9473"" rel=""nofollow noreferrer"">this article</a> to create the bridge between Core Data and Combine.  I have declared a Core Data entity class called <code>ItemEntity</code>.  It has a single property, a <code>String</code>, containing a serialized JSON object.  This object deserializes to a struct called <code>Item</code>.  My SwiftUI view simply displays a list of items returned from my ViewModel:</p>
<pre><code>struct ContentView: View {
    
    @ObservedObject
    var viewModel: MyListViewModel
    
    var body: some View {
        NavigationView {
            List {
                ForEach(viewModel.items, id: \.self.id) { item in
                    Text(&quot;\(item.name) - \(item.createdDate)&quot;)
                }
            }
            .onAppear {
                self.viewModel.fetchItems()
            }
            .toolbar {
                Button(action: addItem) {
                    Label(&quot;Add Item&quot;, systemImage: &quot;plus&quot;)
                }
            }
        }
    }
    
    private func addItem() {
        let entity = ItemEntity(context: viewContext)
        let rand = arc4random()
        var model = Item(name: &quot;Item \(rand)&quot;, createdDate: Date())
        model.id = UUID().uuidString
        let jsonData = try! JSONEncoder().encode(model)
        
        entity.modelJSON = String(data: jsonData, encoding: .utf8)
        do {
            try viewContext.save()
        } catch {
            let nsError = error as NSError
            fatalError(&quot;\(nsError) - \(nsError.userInfo)&quot;)
        }
    }
}
</code></pre>
<p>My <code>ViewModel</code> makes use of the <code>CDPublisher</code> class to fetch the entities from Core Data.  It also has a map function that deserializes the JSON string in each entry to an <code>Item</code> instance.  Eventually, an <code>Array</code> of <code>Item</code> objects is what is made available via my <code>ViewModel</code>.  It looks like this:</p>
<pre><code>import Foundation
import CoreData
import Combine
import SwiftUI

class MyListViewModel: ObservableObject {
    
    private var viewContext: NSManagedObjectContext =  PersistenceController.shared.container.viewContext
    
    @Published
    var items: [Item] = []
    
    private var cancellables = [AnyCancellable]()
    
    func fetchItems() {
        print(&quot;FETCHING...&quot;)
        
        let decoder = JSONDecoder()
        let fetchReq: NSFetchRequest&lt;ItemEntity&gt; = ItemEntity.fetchRequest()
        CoreDataPublisher(request: fetchReq, context: self.viewContext)
            .map({ (entities: [ItemEntity]) -&gt; [Item] in
                var items: [Item] = []
                entities.forEach { (entity: ItemEntity) in
                    if let json = entity.modelJSON?.data(using: .utf8) {
                        if let item = try? decoder.decode(Item.self, from: json) {
                            items.append(item)
                        }
                    }
                }
                
                return items
            })
            .receive(on: DispatchQueue.main)
            .replaceError(with: [])
            .eraseToAnyPublisher()
            .sink { completion in
                print(&quot;COMPLETION : \(completion)&quot;)
            } receiveValue: { items in
                print(&quot;SUCCESS&quot;)
                items.forEach { (item) in
                    print(&quot;\t\(item)&quot;)
                }
                self.items = items
            }.store(in: &amp;cancellables)
    }
}
</code></pre>
<p>My code compiles and runs successfully.  I see print statements originating via my <code>fetchItems()</code> method, indicating that my items array contains all of the objects expected:</p>
<pre><code>FETCHING...
SUCCESS
    Item(name: &quot;Item 854277542&quot;, createdDate: 2021-01-25 19:19:16 +0000)
    Item(name: &quot;Item 92334228&quot;, createdDate: 2021-01-25 19:19:17 +0000)
    Item(name: &quot;Item 405319813&quot;, createdDate: 2021-01-25 19:19:18 +0000)
    Item(name: &quot;Item 121330574&quot;, createdDate: 2021-01-25 19:19:18 +0000)
    Item(name: &quot;Item 3025980536&quot;, createdDate: 2021-01-25 19:19:19 +0000)
    Item(name: &quot;Item 1278077958&quot;, createdDate: 2021-01-25 19:19:19 +0000)
    Item(name: &quot;Item 4274618146&quot;, createdDate: 2021-01-25 19:19:19 +0000)
    Item(name: &quot;Item 2320455869&quot;, createdDate: 2021-01-25 19:19:19 +0000)
    Item(name: &quot;Item 3542559526&quot;, createdDate: 2021-01-25 19:19:22 +0000)
    Item(name: &quot;Item 4217121551&quot;, createdDate: 2021-01-25 19:19:23 +0000)
    Item(name: &quot;Item 4139555338&quot;, createdDate: 2021-01-25 19:19:24 +0000)
    Item(name: &quot;Item 1345067436&quot;, createdDate: 2021-01-25 19:20:49 +0000)
</code></pre>
<p>However, my UI is not displaying the items as expected.  I would expect a row for each <code>Item</code> object.  Instead, I see multiple rows but they all have the exact same text matching the <em>first</em> <code>Item</code> in my array.  It's essentially the same row repeated over and over again.</p>
<p>I'm obviously doing something wrong here, but I'm not experienced enough to know exactly what.  Why is it that my items property has the correct values, but I'm not seeing that reflected in my UI?  Is it due to my map function and the JSON decoding?  (Also, is there a better way to accomplish mapping an array of <code>ItemEntity</code> entities to an array of <code>Item</code> objects?)  Any hints?</p>
<p><strong>UPDATE:</strong>  Below is the definition for my <code>Item</code> struct</p>
<pre><code>import Foundation

struct Item {
    
    var name: String = &quot;&quot;
    var createdDate: Date = Date()
    
}

extension Item: Codable {
    
}

extension Item: Identifiable {
    private struct IdentifiableHolder {
        static var _id: String = &quot;&quot;
    }
    
    var id: String {
        get {
            return IdentifiableHolder._id
        }
        set(newId) {
            IdentifiableHolder._id = newId
        }
    }
}
</code></pre>
","331747","","331747","","2021-01-25 21:29:52","2021-01-25 23:08:06","SwiftUI, Combine, and Core Data -- Items not being mapped/displayed properly","<swift><core-data><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"65905731","1","","","2021-01-26 16:58:25","","3","1587","<p>Is there a way to make a <code>@Published</code> variable that only publishes its value when the new value is different from the old one?</p>
<p>Right now if we have</p>
<p><code>@Published var test: Bool = false</code></p>
<p>and we do</p>
<pre><code>test = false
test = false
test = false
</code></pre>
<p>the publisher is called 3 times. This is quite annoying as it sometimes causes my SwiftUI Views to be recreated because somewhere higher up in the hierarchy a publisher was set to the value it previously was set, trough another publisher that was triggered (and that destroys text field inputs because view models through the hierarchy are recreated when that happens).</p>
<p>is there a way of only publishing when it goes from <code>false</code> to <code>true</code> or vice versa?</p>
<p>An example scenario:</p>
<p>We create a user object in our app, and we want to add a car to the user. The app should immediately show the &quot;add car&quot; view if no car is found, otherwise show the main application view. For that we have a listener somewhere. On our top level view we have:</p>
<pre><code>
    @ObservedObject var viewModel = UserViewModel()


    var body: some View {
            if !viewModel.hasVehicles {
                return AnyView(AddVehicleView(viewModel:AddVehicleViewModel())
            } else {
                return AnyView(UserMainView(user: user))
            }
        }
    }
</code></pre>
<p>in our <code>UserViewModel</code> we have</p>
<pre><code>class UserViewModel: ObservableObject {
    @Published var hasVehicles: Bool = false

</code></pre>
<ul>
<li>some code that updates that boolean when certain listeners trigger.</li>
</ul>
<p>Inside <code>AddVehicleView</code> we have a form that allows the user to fill out some text fields and save the vehicle.</p>
<p>Now imagine that for some reason the code that updates the <code>hasVehicles</code> property is triggered, but there still are no vehicles. What happens:</p>
<p><code>hasVehicles = false</code></p>
<p>and the top level view is re-evaluated, resulting in <code>return AnyView(AddVehicleView(viewModel:AddVehicleViewModel())</code> being executed, and my form with text fields is emptied.</p>
<p>I suppose in this case I could solve it by putting <code>AddVehicleViewModel()</code> as a property inside the <code>View</code> struct, but that wouldn't solve it in the case when we want this to be executed multiple times, as that would mean next time the view gets built it will show the data of the last time we created that view, as we reuse the view model.</p>
","251824","","251824","","2021-01-26 17:04:42","2021-11-22 20:40:14","Does Combine have publishers that only publish when a value actually changes?","<swiftui><combine>","2","8","","","","CC BY-SA 4.0"
"65922671","1","65922746","","2021-01-27 15:53:14","","-1","1164","<p>I have the following situation:</p>
<p>2 futures, one returns a value I am interested in, the other does some operations and returns void. The 2 are not related to each other (so the code should not be mixed), but both need to be executed in the right order in the application logic.</p>
<p>What I want to do is subscribe to a publisher that does the following:</p>
<ul>
<li>future one executes and gives a value</li>
<li>future two executes and returns nothing</li>
<li>the subscriber receives the value of future one after the execution of future two.</li>
</ul>
<p>Here is a small code example that does not compile, that shows what I would like to achieve:</p>
<pre><code>import Combine


func voidFuture() -&gt; Future&lt;Void, Error&gt; {
    return Future&lt;Void, Error&gt; { promise in
        promise(.success(()))
    }
}

func intFuture() -&gt; Future&lt;Int, Error&gt; {
    return Future&lt;Int, Error&gt; { promise in
        promise(.success(1))
    }
}

  

func combinedFuture() -&gt; AnyPublisher&lt;Int, Error&gt; {
    var intValue: Int!

    return intFuture().flatMap { result in
        intValue = result
        return voidFuture()
    }.flatMap{ _ in
        return CurrentValueSubject(intValue).eraseToAnyPublisher()
    }.eraseToAnyPublisher()
}

var subscriptions = Set&lt;AnyCancellable&gt;()

combinedFuture()
    .sink(receiveCompletion: { _ in }, receiveValue: { val in print(val)})
    .store(in: &amp;subscriptions)


</code></pre>
","251824","","","","","2021-01-27 15:57:11","Swift Combine return result of first future after evaluation of second","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"65922994","1","","","2021-01-27 16:11:18","","1","272","<p>Swift 5.2 iOS 14</p>
<p>Trying to understand the Combine Framework in SwiftUI and put this code together using an example I found on the web. But ... the example wasn't complete.</p>
<p>Now when I change the orientation of my device, it does write to orientation, but how do I use this in my main loop? I cannot seem to find anything to subscribe too so I tried just using a onChange. Sadly that doesn't work.</p>
<pre><code>class SizeClassViewV: ObservableObject {
  @Environment(\.verticalSizeClass) var verticalSizeClass: UserInterfaceSizeClass?
  @Environment(\.horizontalSizeClass) var horizontalSizeClass: UserInterfaceSizeClass?

  enum Orientation {
    case portrait
    case landscape
  }
  @Published var orientation: Orientation = .portrait
  private var listener: AnyCancellable?

  init() {
    if horizontalSizeClass == .compact &amp;&amp; verticalSizeClass == .regular {
      orientation = .portrait
    } else if horizontalSizeClass == .regular &amp;&amp; verticalSizeClass == .compact {
      orientation = .landscape
    }
    listener = NotificationCenter.default.publisher(for: UIDevice.orientationDidChangeNotification)
        .compactMap { ($0.object as? UIDevice)?.orientation }
        .compactMap { deviceOrientation -&gt; Orientation? in
            if deviceOrientation.isPortrait {
                return .portrait
            } else if deviceOrientation.isLandscape {
                return .landscape
            } else {
                return nil
            }
        }
        .assign(to: \.orientation, on: self)
  }

  deinit {
    listener?.cancel()
  }
}
</code></pre>
<p>In my main loop looks like this right now?</p>
<pre><code>struct ContentView: View {
@State var orient = SizeClassViewX()
var body: some View {
  Text(&quot;foo&quot;)
    .onChange(of: orient.orientation) { ( _ ) in
      print(&quot;changed&quot;)
    }
  }
}
</code></pre>
<p>Changed is never printed when I change the orientation?</p>
","3069232","","8697793","","2021-01-27 23:59:30","2021-01-27 23:59:30","Basic use of the Combine Framework","<ios><swift><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"65925048","1","65925377","","2021-01-27 18:19:48","","1","329","<p>I use combine to connect to a REST API which pulls some data into an ObservableObject. The whole setup is really just MVVM. The ObservableObject is then being Observed in a view. Now, I'm stuck with a bug I can't seem to get resolved. What seems to happen is that the View is drawn twice. The first time it updates with the values from the ObservedObject. Then it immediately re-draws, but now the pulled data is suddenly gone. I have confirmed that the code that pulls the data is not executed a second time. Also, the View Hierarchy Viewer seems to suggest that the Text Views which are supposed to be render the data in the view are somehow deleted on the second render run.</p>
<p>This is what the model looks like (the authentication related code is from Firebase):</p>
<pre><code>class ItemViewModel: ObservableObject {
    
    @Published var items = [ScheduleItem]()
    
    private var publisher: AnyCancellable?
    
    func fetchData() {
        
        let currentUser = Auth.auth().currentUser
        currentUser?.getIDTokenForcingRefresh(false, completion: { idToken, error in
        
            let url = URL(string: &quot;abc&quot;)!
            var request = URLRequest(url: url)
            request.httpMethod = &quot;GET&quot;
            request.setValue(&quot;Bearer &quot;+String(idToken!), forHTTPHeaderField: &quot;Authorization&quot;)
     
            self.publisher = URLSession.shared
                .dataTaskPublisher(for: url)
                .map(\.data)
                .decode(
                    type: [ScheduleItem].self,
                    decoder: JSONDecoder()
                )
                .receive(on: DispatchQueue.main)
                .sink(
                    receiveCompletion: { completion in
                        switch completion {
                        case .failure(let error):
                            print(&quot;SINKERROR&quot;)
                            print(error)
                        case .finished:
                            print(&quot;SINKSUCCESS&quot;)
                        }
                    },
                    receiveValue: { repo in
                        print(&quot;DONE&quot;)
                        self.items.append(contentsOf: repo)
                    }
                )
        })
    }
}
</code></pre>
<p>The output from the print statements is
DONE
SINKSUCCESS
Both can only be found once in the debug output.</p>
<p>This is the view:</p>
<pre><code>struct TreatmentCardView: View {
    
    let startDate: String
    let uid: Int
    
    @ObservedObject var data = ItemViewModel()
    
    @State private var lastTime: String = &quot;2&quot;
    
    var body: some View {
        ZStack {
            GeometryReader { geometry in
                VStack{
                    
                    Text(&quot;Headline&quot;)
                        .font(.title)
                        .foregroundColor(Color.white)
                        .padding([.top, .leading, .bottom])
                    
                    Print(&quot;ISARRAYEMPTY&quot;)
                    Print(String(data.items.isEmpty))
                    
                    Text(String(data.items.isEmpty))
                                .font(.headline)
                                .fontWeight(.light)
                                .foregroundColor(Color.white)
                                .frame(width: 300, height: 25, alignment: .leading)
                                .multilineTextAlignment(.leading)
                                .padding(.top)
                      
                     
                }
            }
        }
        .background(Color(&quot;ColorPrimary&quot;))
        .cornerRadius(15)
        .onAppear{
            self.data.fetchData()
        }
    }
}
</code></pre>
<p>Print(String(data.items.isEmpty)) is first false, then true, indicating the view was re-rendered.</p>
<p>What is a bit weird to me is that I would have expected the view to render at least once before the data is pulled, but I don't see any indication of this happening.</p>
<p>I've been trying to make this word for two days now. Any help and advise is greatly appreciated!</p>
","1763259","","","","","2021-01-27 18:54:15","Data from ObservedObject not rendered in SwiftUI view","<swiftui><combine><observableobject><observedobject>","2","0","1","","","CC BY-SA 4.0"
"65942698","1","65943062","","2021-01-28 17:57:19","","0","69","<p>I'm having trouble getting a function call using a generic type to work using a <code>URLSession</code> <code>DataTaskPublisher</code>...</p>
<p>The API I'm calling always responds with an HTTP 200, and indicates whether it was successful or not in the JSON via a <code>code</code> string with an indicator.</p>
<p>I created a <code>protocol</code> that all response objects conform to, e.g.:</p>
<pre><code>protocol APIResponse: Decodable {
    var code: String { get }
}
</code></pre>
<p>My actual response will be something like:</p>
<pre><code>struct LoginResponse :  APIResponse {
    let code: String
    let name: String
    enum CodingKeys: String, CodingKey {
        case code = &quot;code&quot;
        case name = &quot;name&quot;
    }
    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        code = try values.decode(String.self, forKey: .code)
        name = try values.decode(String.self, forKey: .name)
    }
}
</code></pre>
<p>Now I want a function like this that I can use:</p>
<pre><code>    private func call&lt;T: APIResponse&gt;(_ endpoint: String, using data: Encodable, providing response: T)
                    -&gt; AnyPublisher&lt;T, Error&gt; {
        let request = createRequest(for: endpoint, using: data)
        return session
                .dataTaskPublisher(for: request)
                .map {
                    $0.data
                }
                .decode(type: T.self, decoder: decoder)
                .tryMap {
                    response in
                    if response.code.suffix(1) != &quot;I&quot; {
                        throw MyError(message: &quot;Error \(code)&quot;)
                    }
                    return response
                }
                .eraseToAnyPublisher()
    }
</code></pre>
<p>So far, so good!</p>
<p>But here's the problem... I want to use it like this:</p>
<pre><code>    func login() -&gt; AnyPublisher&lt;String, Error&gt; {
        call(&quot;login&quot;, using: LoginRequest(), providing: LoginResponse)
                .map {
                    $0.name
                }
                .eraseToAnyPublisher()
    }

</code></pre>
<p>The compiler complains with <code>Type 'LoginResponse.Type' cannot conform to 'APIResponse'; only struct/enum/class types can conform to protocols</code></p>
<p>My fix (which works, but is kludgy), it to provide a no-arg <code>init()</code> for <code>LoginResponse</code> and call it like this: <code>call(&quot;login&quot;, using: LoginRequest(), providing: LoginResponse())</code></p>
<p>Any way to get the Generic to work without the no-arg <code>init()</code>?</p>
<p>Should I be taking a totally different approach?</p>
","7833553","","","","","2021-02-14 14:55:19","Calling a function with a Generic parameter requires a no-arg init for the type","<swift><combine>","3","2","","","","CC BY-SA 4.0"
"65950123","1","","","2021-01-29 07:03:58","","1","152","<p>I'm trying to implement a rate limiting scheduler in combine. The docs aren't great for Scheduler so I'm making some assumptions about how they operate internally. I'm assuming that the <code>schedule</code> function gets called for each event in the stream but that's not what I'm seeing in practice. I'm only seeing a couple of calls to that function in a stream of many more events.</p>
<p>Here is my implementation which is doing effectively nothing right now and allowing all events through...</p>
<pre class=""lang-swift prettyprint-override""><code>public class RateLimitedScheduler: Scheduler {
    public typealias SchedulerTimeType = DispatchQueue.SchedulerTimeType
    public typealias SchedulerOptions = DispatchQueue.SchedulerOptions
    
    // MARK: API
    
    public var now: SchedulerTimeType { queue.now }
    public var minimumTolerance: SchedulerTimeType.Stride { queue.minimumTolerance }

    public func schedule(options: SchedulerOptions? = nil, _ action: @escaping () -&gt; Void) {
        queue.schedule(after: nextDeadline(), tolerance: .init(floatLiteral: period / 10), options: options, action)
    }

    public func schedule(after date: SchedulerTimeType, tolerance: SchedulerTimeType.Stride, options: SchedulerOptions? = nil, _ action: @escaping () -&gt; Void) {
        let deadline = max(nextDeadline(), date)
        queue.schedule(after: deadline, tolerance: tolerance, options: options, action)
    }

    public func schedule(after date: SchedulerTimeType,
                  interval: SchedulerTimeType.Stride,
                  tolerance: SchedulerTimeType.Stride,
                  options: SchedulerOptions? = nil,
                  _ action: @escaping () -&gt; Void) -&gt; Cancellable {
        let deadline = max(nextDeadline(), date)
        return queue.schedule(after: deadline, interval: interval, tolerance: tolerance, options: options, action)
    }
    
    // MARK: Initialization
    
    public init(maxEvents: Int, period: TimeInterval, queue: DispatchQueue = .main) {
        self.maxEvents = maxEvents
        self.period = period
        self.queue = queue
    }
    
    // MARK: Private
    
    private let maxEvents: Int
    private let period: TimeInterval
    private let queue: DispatchQueue

    private var eventCount = 0
    private var windowStartTime = DispatchTime.now()

    private func nextDeadline() -&gt; SchedulerTimeType {
        let now = DispatchTime.now()

        if eventCount &lt; maxEvents {
            eventCount += 1
            return SchedulerTimeType(max(windowStartTime, now))
        }

        let nextStartTime = windowStartTime + period
        eventCount = 1
        
        if now &gt; nextStartTime {
            windowStartTime = now
            return SchedulerTimeType(max(windowStartTime, now))
        }
        
        windowStartTime = nextStartTime
            
        return SchedulerTimeType(max(nextStartTime, now))
    }
}
</code></pre>
<p>And to test:</p>
<pre class=""lang-swift prettyprint-override""><code>let cancellable = Array(repeating: 0, count: 20).publisher
    .map { $0 * 1 }
    .subscribe(on: RateLimitedScheduler(maxEvents: 5, period: 1))
    .sink(receiveValue: { _ in
        print(Date())
    })
</code></pre>
<p>My algorithm for <code>nextDeadline</code> definitely works as I've tested it outside of the scheduler so that's not the issue.</p>
<p>So my questions are:</p>
<ol>
<li>Is my assumption correct that each event should fire the schedule function in the scheduler? And if not, why not?</li>
<li>Can anyone help figure this out or provide me with an alternative?</li>
</ol>
","2570590","","","","","2021-01-29 07:03:58","Custom Combine RateLimitedScheduler","<swift><scheduler><combine>","0","11","","","","CC BY-SA 4.0"
"65956865","1","","","2021-01-29 15:01:28","","2","1065","<p>I was writing a unit test for some code I was working on in an iOS App and ran into very strange behavior.<br />
The PassthroughSubject sink closure in my code wasn't running and thus the test was failing. When i uncomment the print line in the below code it passes.  It also passes with no problems in a playground. I tried the whole quite Xcode delete derived data trick and that didn't work. I tried to move the class and unit test to a completely different project and it was still failing. To me this looks like an Apple bug but wanted to ask here to see if anyone has any insights.  see the below code. Note i've simplified the code from my original project a bit to make is easier to read. This makes me feel like RxSwift is more polished than Combine at this point. Never saw anything like this happen with RxSwift.</p>
<pre><code>class BadPassThroughSendClass {

    let publisher = PassthroughSubject&lt;Any, Never&gt;()
    var anyCancellable: AnyCancellable?
    var sinkClosureBlock: (()-&gt;())?

    init() {
        createSubscription()
    }

    func createSubscription() {
        let subscription = publisher
            .subscribe(on: DispatchQueue.global())
            .receive(on: DispatchQueue.global())
            .sink { [unowned self] event in
                sinkClosureBlock?()
            }
        anyCancellable = AnyCancellable(subscription)
    }

}

class UnitTests: XCTestCase {

    func testBadPassThroughClass() {
        let badClass = BadPassThroughSendClass()
        let sinkExpectation = expectation(description: &quot;Sink closure should fire&quot;)
        badClass.sinkClosureBlock = {
            sinkExpectation.fulfill()
        }
        // print(&quot;pass the test with this line&quot;)
        badClass.publisher.send(&quot;my test message&quot;)
        waitForExpectations(timeout: 0.5)
    }

}
</code></pre>
","6349831","","4667835","","2021-01-29 16:17:32","2021-01-29 16:17:32","Swift Combine PassThroughSubject not firing sink closure in XCTestCase","<swift><xctest><combine>","0","3","1","","","CC BY-SA 4.0"
"65965666","1","65968034","","2021-01-30 07:30:53","","2","813","<p>I'm subscribing the the built-in User Defaults extension, but it seems to be firing multiple times unnecessarily.</p>
<p>This is the code I'm using:</p>
<pre><code>import Combine
import Foundation
import PlaygroundSupport

extension UserDefaults {
    
    @objc var someProperty: Bool {
        get { bool(forKey: &quot;someProperty&quot;) }
        set { set(newValue, forKey: &quot;someProperty&quot;) }
    }
}

let defaults = UserDefaults.standard

defaults.dictionaryRepresentation().keys
    .forEach(defaults.removeObject)

print(&quot;Before: \(defaults.someProperty)&quot;)

var cancellable = Set&lt;AnyCancellable&gt;()

defaults
    .publisher(for: \.someProperty)
    .sink { print(&quot;Sink: \($0)&quot;) }
    .store(in: &amp;cancellable)

defaults.someProperty = true
cancellable.removeAll()

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre>
<p>This prints:</p>
<pre><code>Before: false
Sink: false
Sink: true
Sink: true
</code></pre>
<p>Why is it firing the sink 3 times instead of only once?</p>
<p>I can maybe understand it firing on subscribe, which is confusing because it doesn't seem to be a <code>PassthroughSubject</code> or any documentation of this. However, what really confuses me is the third time it fires.</p>
<p><strong>UPDATE:</strong></p>
<p>It's strange but it seems the initial value gets factored into the new/old comparison:</p>
<pre><code>defaults.someProperty = false
defaults.someProperty = true
defaults.someProperty = false
defaults.someProperty = true

print(&quot;Initial: \(defaults.someProperty)&quot;)

defaults
    .publisher(for: \.someProperty, options: [.new])
    .sink { print(&quot;Sink: \($0)&quot;) }
    .store(in: &amp;cancellable)

defaults.someProperty = true
</code></pre>
<p>The above will print which looks good:</p>
<pre><code>Initial: true
Sink: true
</code></pre>
<p>But when the initial value is different than what you set it to:</p>
<pre><code>defaults.someProperty = false
defaults.someProperty = true
defaults.someProperty = false
defaults.someProperty = true
defaults.someProperty = false

print(&quot;Initial: \(defaults.someProperty)&quot;)

defaults
    .publisher(for: \.someProperty, options: [.new])
    .sink { print(&quot;Sink: \($0)&quot;) }
    .store(in: &amp;cancellable)

defaults.someProperty = true
</code></pre>
<p>The above will strangely print:</p>
<pre><code>Initial: false
Sink: true
Sink: true
</code></pre>
<p>This is untiutive because it's treating the initial value as a trigger of <code>[.new]</code>, then compares again for what was set.</p>
","235334","","235334","","2021-01-30 18:00:49","2021-01-30 18:16:52","Why does User Defaults publisher trigger multiple times","<swift><combine>","1","4","1","","","CC BY-SA 4.0"
"65973320","1","","","2021-01-30 21:31:42","","3","371","<p>The <code>UserDefaults</code> publisher allows you subscribe even though the property is not compliant:</p>
<pre><code>enum Direction: String {
    case north, south, east, west
}

extension UserDefaults {
    
    var direction: Direction {
        get { Direction(rawValue: string(forKey: &quot;direction&quot;) ?? &quot;&quot;) ?? .north }
        set { set(newValue.rawValue, forKey: &quot;direction&quot;) }
    }
}

let defaults = UserDefaults.standard
var cancellable = Set&lt;AnyCancellable&gt;()

defaults
    .publisher(for: \.direction)
    .sink { print(&quot;Sink: \($0)&quot;) } // Crash 💥
    .store(in: &amp;cancellable)

defaults.direction = .east
cancellable.removeAll()
</code></pre>
<p>The above code compiles and gives no warning either. At runtime, it crashes in the <code>sink</code>:</p>
<pre><code>error: Execution was interrupted, reason: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0).
The process has been left at the point where it was interrupted, use &quot;thread return -x&quot; to return to the state before expression evaluation.

Fatal error: Could not extract a String from KeyPath Swift.ReferenceWritableKeyPath&lt;__C.NSUserDefaults, __lldb_expr_43.Direction&gt;: file Foundation/NSObject.swift, line 124
</code></pre>
<p>I'll probably end up creating a private string version and expose it through a publisher like this:</p>
<pre><code>extension UserDefaults {
    
    @objc private var directionRaw: String? {
        get { string(forKey: &quot;direction&quot;) }
        set { set(newValue, forKey: &quot;direction&quot;) }
    }
    
    var directionPublisher: AnyPublisher&lt;Direction, Never&gt; {
        publisher(for: \.directionRaw)
            .compactMap { [weak self] _ in self?.direction }
            .eraseToAnyPublisher()
    }
    
    var direction: Direction {
        get { Direction(rawValue: directionRaw ?? &quot;&quot;) ?? .north  }
        set { directionRaw = newValue.rawValue }
    }
}

defaults
    .directionPublisher
    .sink { print(&quot;Sink: \($0)&quot;) }
    .store(in: &amp;cancellable)
</code></pre>
<p>The problem is anyone can still do this in the codebase:</p>
<pre><code>defaults
    .publisher(for: \.direction)
    .sink { print(&quot;Sink: \($0)&quot;) } // Crash 💥
    .store(in: &amp;cancellable)
</code></pre>
<p>Is there a way to prevent anyone from doing this, or hopefully there's a better way to do this altogether?</p>
","235334","","","","","2021-01-30 21:31:42","Compile safety for UserDefaults publisher instead of crash?","<swift><nsuserdefaults><key-value-observing><combine>","0","4","","","","CC BY-SA 4.0"
"65983371","1","65983730","","2021-01-31 19:33:40","","-1","49","<p>I started to program with swift and I have problem with the call to a local service that returns for example:</p>
<p>{&quot;idMember&quot;:14,&quot;externalID&quot;:&quot;001996.dce&quot;,&quot;email&quot;:null,&quot;name&quot;:&quot;Manu&quot;,&quot;isActive&quot;:true,&quot;logDate&quot;:&quot;2020-12-12 12:12:12&quot;,&quot;logUser&quot;:&quot;asdasd&quot;}</p>
<p>I tried this:</p>
<pre><code>let url = URL(string: &quot;http://localhost:8080/member/findByExternalID/001996.dce&quot;)!
let token = URLSession.shared.dataTaskPublisher(for: url)
           .map { $0.data }
           .decode(type: Member.self, decoder: JSONDecoder())
           .sink(receiveCompletion: { completion in
              print(completion)
            }, receiveValue: { value in
               print(&quot;service has \(value) value&quot;)
           })
</code></pre>
<p>Member.swift:</p>
<pre><code>struct Member: Codable, Identifiable {
var id = UUID()
let idMember:Int
var name:String
    
var logDate:Date
var logUser:String

var externalID:String
var email:String
var isActive:Bool

enum CodingKeys: String, CodingKey {
    case idMember, name,  logDate,  logUser,  externalID, email, isActive }
}
</code></pre>
<p>but never print info, the service is never invoked (I check it in the server log). I suppose this is a trivial question. But I didn't find what's wrong.</p>
","15118472","","","","","2021-02-01 01:31:13","Swift and Combine. Problems when I recover one record from a local service","<swift><rest><combine>","1","2","","","","CC BY-SA 4.0"
"66000229","1","","","2021-02-01 21:14:11","","0","324","<p>I'm stuck on a Combine problem, and I can't find a proper solution for this.</p>
<p>My goal is to monitor a queue, and process items in the queue until it's empty. If then someone adds more items in the queue, I resume processing. Items needs to be processed one by one, and I don't want to lose any item.</p>
<p>I wrote a very simplified queue below to reproduce the problem. My items are modeled as just strings for the sake of simplicity again.</p>
<p>Given the contraints above:</p>
<ul>
<li>I use a <code>changePublisher</code> on the queue to monitor for changes.</li>
<li>A button lets me add a new item to the queue</li>
<li>The <code>flatMap</code> operator relies on the <code>maxPublishers</code> parameter to only allow one in-flight processing.</li>
<li>The <code>buffer</code> operator prevents items from being lost if the <code>flatMap</code> is busy.</li>
</ul>
<p>Additionally, I'm using a <code>combineLatest</code> operator to only trigger the pipeline under some conditions. For simplicity, I'm using a <code>Just(true)</code> publisher here.</p>
<p><strong>The problem</strong></p>
<p>If I tap the button, a first item goes in the pipeline and is processed. The <code>changePublisher</code> triggers because the queue is modified (item is removed), and the pipeline stops at the <code>compactMap</code> because the <code>peek()</code> returns <code>nil</code>. So far, so good. Afterwards, though, if I tap on the button again, a value is sent in the pipeline but <strong>never makes it through the <code>buffer</code></strong>.</p>
<p><strong>Solution?</strong></p>
<p>I noticed that removing the <code>combineLatest</code> prevents the problem from happening, but I don't understand why.</p>
<p><strong>Code</strong></p>
<pre><code>import Combine
import UIKit

class PersistentQueue {
    let changePublisher = PassthroughSubject&lt;Void, Never&gt;()

    var strings = [String]()

    func add(_ s: String) {
        strings.append(s)
        changePublisher.send()
    }

    func peek() -&gt; String? {
        strings.first
    }

    func removeFirst() {
        strings.removeFirst()
        changePublisher.send()
    }
}

class ViewController: UIViewController {

    private let queue = PersistentQueue()
    private var cancellables: Set&lt;AnyCancellable&gt; = []

    override func viewDidLoad() {
        super.viewDidLoad()
        start()
    }

    @IBAction func tap(_ sender: Any) {
        queue.add(UUID().uuidString)
    }

    /*
     Listen to changes in the queue, and process them one at a time. Once processed, remove the item from the queue.
     Keep doing this until there are no more items in the queue. The pipeline should also be triggered if new items are
     added to the queue (see `tap` above)
     */
    func start() {
        queue.changePublisher
            .print(&quot;Change&quot;)
            .buffer(size: Int.max, prefetch: .keepFull, whenFull: .dropNewest)
            .print(&quot;Buffer&quot;)
            // NOTE: If I remove this combineLatest (and the filter below, to make it compile), I don't have the issue anymore.
            .combineLatest(
                Just(true)
            )
            .print(&quot;Combine&quot;)
            .filter { _, enabled in return enabled }
            .print(&quot;Filter&quot;)
            .compactMap { _ in
                self.queue.peek()
            }
            .print(&quot;Compact&quot;)
            // maxPublishers lets us process one page at a time
            .flatMap(maxPublishers: .max(1)) { reference in
                return self.process(reference)
            }
            .sink { reference in
                print(&quot;Sink for \(reference)&quot;)

                // Remove the processed item from the queue. This will also trigger the queue's changePublisher,
                // which re-run this pipeline in case
                self.queue.removeFirst()
            }
            .store(in: &amp;cancellables)
    }

    func process(_ value: String) -&gt; AnyPublisher&lt;String, Never&gt; {
        return Future&lt;String, Never&gt; { promise in
            print(&quot;Starting processing of \(value)&quot;)
            DispatchQueue.global(qos: .userInitiated).asyncAfter(deadline: .now() + 2) {
                promise(.success(value))
            }
        }.eraseToAnyPublisher()
    }

}
</code></pre>
<p><strong>Output</strong></p>
<p>Here is a sample run of the pipeline if you tap on the button twice:</p>
<pre><code>Change: receive subscription: (PassthroughSubject)
Change: request max: (9223372036854775807)
Buffer: receive subscription: (Buffer)
Combine: receive subscription: (CombineLatest)
Filter: receive subscription: (Print)
Compact: receive subscription: (Print)
Compact: request max: (1)
Filter: request max: (1)
Combine: request max: (1)
Buffer: request max: (1)
Change: receive value: (())
Buffer: receive value: (())
Combine: receive value: (((), true))
Filter: receive value: (((), true))
Compact: receive value: (3999C98D-4A86-42FD-A10C-7724541E774D)
Starting processing of 3999C98D-4A86-42FD-A10C-7724541E774D
Change: request max: (1) (synchronous)
Sink for 3999C98D-4A86-42FD-A10C-7724541E774D // First item went through pipeline
Change: receive value: (())
Compact: request max: (1)
Filter: request max: (1)
Combine: request max: (1)
Buffer: request max: (1)
Buffer: receive value: (())
Combine: receive value: (((), true))
Filter: receive value: (((), true))

// Second time compactMap is hit, value is nil -&gt; doesn't forward any value downstream.

Filter: request max: (1) (synchronous)
Combine: request max: (1) (synchronous)
Change: request max: (1)

// Tap on button

Change: receive value: (())

// ... Nothing happens
</code></pre>
<p>[EDIT] Here is a much more constrained example, which can run in Playgrounds and which also demonstrates the problem:</p>
<pre><code>import Combine
import Foundation

import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

func process(_ value: String) -&gt; AnyPublisher&lt;String, Never&gt; {
    return Future&lt;String, Never&gt; { promise in
        print(&quot;Starting processing of \(value)&quot;)
        DispatchQueue.global(qos: .userInitiated).asyncAfter(deadline: .now() + 0.1) {
            promise(.success(value))
        }
    }.eraseToAnyPublisher()
}

var count = 3

let s = PassthroughSubject&lt;Void, Never&gt;()

var cancellables = Set&lt;AnyCancellable&gt;([])

// This reproduces the problem. Switching buffer and combineLatest fix the problem…

s
    .print()
    .buffer(size: Int.max, prefetch: .keepFull, whenFull: .dropNewest)
    .combineLatest(Just(&quot;a&quot;))
    .filter { _ in count &gt; 0 }
    .flatMap(maxPublishers: .max(1)) { _, a in process(&quot;\(count)&quot;) }
    .sink {
        print($0)
        count -= 1
        s.send()
    }
    .store(in: &amp;cancellables)

s.send()

Thread.sleep(forTimeInterval: 3)

count = 1
s.send()
</code></pre>
<p>Switching combine and buffer fixes the problem.</p>
","283899","","283899","","2021-02-02 08:41:14","2021-04-18 09:08:27","Why is this Combine pipeline not letting items through?","<ios><swift><rx-swift><combine>","2","7","","","","CC BY-SA 4.0"
"66003164","1","","","2021-02-02 03:13:52","","0","54","<p>I'm trying to get dowloaded data into the audioArray variable for use elsewhere, but it keeps returning nil if I try to use it in another function.</p>
<pre><code>var audioArray: [String] = []

func listFiles(){
    
    var tempArray: [String] = []

        let storageOperation = Amplify.Storage.list()
        resultSink = storageOperation.resultPublisher.sink {
                if case let .failure(storageError) = $0 {
                    print(&quot;Failed: \(storageError.errorDescription). \(storageError.recoverySuggestion)&quot;)
                }
            }

        receiveValue: { [self] listResult in
                print(&quot;Completed&quot;)
                listResult.items.forEach { item in
                    
                    tempArray.append(item.key)

                    audioArray = tempArray
                    
                    print(self.audioArray)
                    
                }

            }

    }
</code></pre>
","6447294","","","","","2021-02-02 03:13:52","How do I get data out of iOS Combine closure","<ios><swift><combine>","0","2","","","","CC BY-SA 4.0"
"66007062","1","","","2021-02-02 09:40:03","","0","353","<p>In the following code, which is a simplified version of a more elaborate pipeline, &quot;Done processing&quot; is never called for 2.</p>
<p>Why is that?</p>
<p>I suspect this is a problem due to the demand, but I cannot figure out the cause.</p>
<p>Note that if I remove the <code>combineLatest()</code> or the <code>compactMap()</code>, the value 2 is properly processed (but I need these <code>combineLatest</code> and <code>compactMap</code> for correctness, in my real example they are more involved).</p>
<pre><code>var cancellables = Set&lt;AnyCancellable&gt;([])

func process&lt;T&gt;(_ value: T) -&gt; AnyPublisher&lt;T, Never&gt; {
    return Future&lt;T, Never&gt; { promise in
        print(&quot;Starting processing of \(value)&quot;)
        DispatchQueue.global(qos: .userInitiated).asyncAfter(deadline: .now() + 0.1) {
            promise(.success(value))
        }
    }.eraseToAnyPublisher()
}

let s = PassthroughSubject&lt;Int?, Never&gt;()

s
    .print(&quot;Combine-&gt;Subject&quot;)
    .combineLatest(Just(true))
    .print(&quot;Compact-&gt;Combine&quot;)
    .compactMap { value, _ in value }
    .print(&quot;Sink-&gt;Compact&quot;)
    .flatMap(maxPublishers: .max(1)) { process($0) }
    .sink {
        print(&quot;Done processing \($0)&quot;)
    }
    .store(in: &amp;cancellables)

s.send(nil)

// Give time for flatMap to finish
Thread.sleep(forTimeInterval: 1)
s.send(2)
</code></pre>
","283899","","","","","2021-02-03 19:55:11","Combine pipeline not receiving values","<ios><swift><reactive-programming><combine>","1","5","","","","CC BY-SA 4.0"
"66010221","1","66010340","","2021-02-02 12:57:23","","1","242","<p>I'm trying to wrap a tryMap operator along the lines of <a href=""https://www.swiftbysundell.com/articles/extending-combine-with-convenience-apis/"" rel=""nofollow noreferrer"">this</a> article.</p>
<pre class=""lang-swift prettyprint-override""><code>extension Publisher where Output == Data {
    func decode&lt;T: Decodable&gt;(as type: T.Type = T.self, using decoder: JSONDecoder = .init()) -&gt; Publishers.Decode&lt;Self, T, JSONDecoder&gt; {
        decode(type: type, decoder: decoder)
    }
}

extension Publisher where Output == URLSession.DataTaskPublisher.Output {
    func processData(_: @escaping (Self.Output) throws -&gt; Data) -&gt; Publishers.TryMap&lt;Self, Data&gt; {
        tryMap { element -&gt; Data in
            guard let httpResponse = element.response as? HTTPURLResponse,
                  httpResponse.statusCode == 200
            else {
                throw URLError(.badServerResponse)
            }
            return element.data
        }
    }
}
</code></pre>
<p>While using it I'm getting a compiler error which I'm struggling with:</p>
<pre><code>return urlSession
    .dataTaskPublisher(for: request)
    .processData // &lt;- Value of type '(@escaping (URLSession.DataTaskPublisher.Output) throws -&gt; Data) -&gt; Publishers.TryMap&lt;URLSession.DataTaskPublisher, Data&gt;' (aka '(@escaping ((data: Data, response: URLResponse)) throws -&gt; Data) -&gt; Publishers.TryMap&lt;URLSession.DataTaskPublisher, Data&gt;') has no member 'decode'
    .decode(as: InstantResponse.self)
    .eraseToAnyPublisher()
</code></pre>
<p>What would be the correct way of doing it?
Thanks!</p>
","4473187","","4473187","","2021-02-02 13:01:29","2021-02-02 13:04:31","Swift: Extending Combine operators","<swift><generics><combine>","1","0","","","","CC BY-SA 4.0"
"66012946","1","","","2021-02-02 15:43:48","","1","608","<p>I have a simple nested <strong>list</strong> that generates <strong>DisclosureGroup</strong> using the parent item but when I tapped on the <strong>Button</strong> in the child node, it's called multiple times which includes child view initialization as well.</p>
<pre><code>struct TopicView: View {
    @ObservedObject private var levelsListVM = LevelsViewModel()
    @State var isActive = false
    @State var levelId : Int = 0
    @State var topicId : Int = 0
    
    var body: some View {
        List {
            ForEach(self.levelsListVM.levelsWithTopics, id:\.level ) { level in
                DisclosureGroup(
                    isExpanded: .constant(!level.isLock),
                    content: {
                        VStack {
                            ForEach(level.topics, id:\.title ) { topic in
                                Button (action: {
                                    self.levelId = level.level
                                    self.topicId = topic.id
                                    self.isActive = true
                                }, label: {
                                    ImageDisplay(imageURL: topic.imageUrl).clipShape(Circle())
                                        .background(Color.blue)
                                        .frame(width: 50, height: 50)
                                }).fullScreenCover(isPresented: self.$isActive, content: {
                                    GameTwo(level: level.level, topicId: topic.id, practiceMode: true)
                                })
                            }
                        }
                    },
                    label: {
                        HStack {
                            ImageDisplay(imageURL: level.levelImageUri).clipShape(Circle())
                                .background(Color.blue)
                                .frame(width: 100, height: 100, alignment: .center)
                            HStack {
                                VStack {
                                    Text(level.levelName)
                                    Text(&quot;Level  0 / 2 / 3&quot;).font(.subheadline)
                                }
                            }
                        }
                    }
                )
            }
        }
        .navigationTitle(&quot;Demo&quot;)
    }
}
</code></pre>
<p>How Can I avoid this behavior?</p>
<p>FYI: I'm using <strong>ObservedObject</strong> and <strong>MVVM</strong> pattern to pass the data.</p>
","2126513","","1974224","","2022-06-15 05:23:02","2022-06-15 05:23:02","SwiftUI list items triggered multiple times","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"66016627","1","","","2021-02-02 19:47:44","","1","501","<p>I have this ViewModel that uses combine along with a timer and I want this ViewModel to update a LottieView and filename with a new animation. When the timer counts down I want it to publish and send specific strings, these strings will be the json Lottie filenames. When my ContentView receives these filenames I want it to dynamically update the LottieViews animation.</p>
<p>So I made an @State variable called name inside ContentView and made that equal to the received value that is passed in. However, what confuses me is that the filename that is being published and sent from the ViewModels timer at the 10 second mark is suppose to be received and used inside  LottieView(filename: name).</p>
<p>However this LottieView instantly runs this file when I launch the app. How so? The only place that filename exists in the whole app is when the timer reaches 10 seconds and it shouldn't even exist when LottieView(name) is called. It also ignores the previous file name that should have been run at the 19 second mark. If I were to ignore LottieView(name) all together and run a Text View instead, so in this case Text(name), when I run the app the Text properly changes when the timer reaches 10.</p>
<p>So how come LottieView(name) runs like this? I verified these files properly match their animations as well.</p>
<pre><code>import SwiftUI
import Combine

class ViewModel: ObservableObject {
    
    var anyCancellable: AnyCancellable?
    let publish = PassthroughSubject&lt;String, Never&gt;()
    
    private var timer: Timer?
    private var scheduleTime = 20
    
    init() {
        fire()
        anyCancellable = publish.sink { str in
            print(&quot;Value that is being passed over: \(str)&quot;)
        }

    }
    
    func fire() {
        print(&quot;Fire timer&quot;)
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in
            
            
            self.scheduleTime -= 1
            print(self.scheduleTime)
            if self.scheduleTime == 19 {
                self.publish.send(&quot;13865-sign-for-error-flat-style&quot;)
            }
            if self.scheduleTime == 10 {
               self.publish.send(&quot;4174-unlock-to-premium&quot;)
                timer.invalidate()
            }
        }
    }
}


import SwiftUI
import Combine

struct ContentView: View {
    
    @ObservedObject var vm = ViewModel()
    @State var name: String = &quot;&quot;
    var body: some View {
      
        VStack {
            LottieView(filename: $name)
            Text(name)
        }
            .onReceive(vm.publish, perform: { value in
                print(&quot;passed over : \(value)&quot;)
                name = value
                print(name)
            })
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}


import SwiftUI
import Lottie

struct LottieView: UIViewRepresentable {
    
  typealias UIViewType = UIView
  @Binding var filename: String
  
  func makeUIView(context: UIViewRepresentableContext&lt;LottieView&gt;) -&gt; UIView {
    let view = UIView(frame: .zero)
    
    let animationView = AnimationView()
    let animation = Animation.named(filename)
    animationView.animation = animation
    animationView.contentMode = .scaleAspectFit
    animationView.play()
    
    animationView.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(animationView)
    
    NSLayoutConstraint.activate([
      animationView.widthAnchor.constraint(equalTo: view.widthAnchor),
      animationView.heightAnchor.constraint(equalTo: view.heightAnchor),
      animationView.centerXAnchor.constraint(equalTo: view.centerXAnchor),
      animationView.centerYAnchor.constraint(equalTo: view.centerYAnchor)
    ])
    
    return view
  }
  
  func updateUIView(_ uiView: UIView, context: UIViewRepresentableContext&lt;LottieView&gt;) {
  }
    
}
</code></pre>
<p><a href=""https://i.stack.imgur.com/tgbtf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tgbtf.png"" alt=""Console output when the code runs"" /></a></p>
","14262975","","2756409","","2021-09-29 13:10:18","2022-01-17 16:04:51","When using combine in SwiftUI to update a Lottie Animation, it fails to update at the right time and gives an unexpected result","<swift><swiftui><combine><lottie>","1","6","","","","CC BY-SA 4.0"
"66017261","1","","","2021-02-02 20:36:16","","0","57","<h1>Future won’t work the same in a button as it does in it’s own function</h1>
<p>I have a button that updates my upcoming notifications using Combine and it works well enough, but for some reason when I, as closely as I can, copy the block inside the button to it’s own independent function, and use that function in a button, it doesn’t work.</p>
<p>This works</p>
<pre class=""lang-swift prettyprint-override""><code>    Button(&quot;updatePendingView&quot;) {
        let future = futureUpcomingNotificationRequests()
    
        future
          .map() {
              notificationRequestsToDates(notificationRequests: $0)
          }
          .sink(receiveCompletion: {
                    print(&quot;Completed with,&quot;, $0)
                },
                receiveValue: {
                    print(&quot;Recieved \($0) as an array of Dates&quot;)
                    upcomingNotificationDates = $0
                })
          .store(in: &amp;subscriptions)
    
    }
</code></pre>
<p>This does not work (it does not use the final closure to set the array which updates the <code>View</code>)</p>
<pre class=""lang-swift prettyprint-override""><code>    @State var upcomingNotificationDates: [Date] = []
    @State var subscriptions = Set&lt;AnyCancellable&gt;()
    
    ...
    
    Button(&quot;updatePending with future function&quot;) {
        updateNotificationView(subscriptions: subscriptions) {
            upcomingNotificationDates = $0
        }
    }

    func updateNotificationView(subscriptions: Set&lt;AnyCancellable&gt;, closure: @escaping ([Date]) -&gt; ()) {
        var subscriptions = subscriptions
        let future = futureUpcomingNotificationRequests()
    
        future
            .map() {
                notificationRequestsToDates(notificationRequests: $0)
            }
            .sink(receiveCompletion: {
                print(&quot;Completed with,&quot;, $0)
            },
            receiveValue: {
                print(&quot;Recieved \($0) as an array of Dates&quot;)
                closure($0)
            })
            .store(in: &amp;subscriptions)
    
    }
</code></pre>
<p>Here’s my future factory:</p>
<pre class=""lang-swift prettyprint-override""><code>    func futureUpcomingNotificationRequests(notificationCenter: UNUserNotificationCenter = UNUserNotificationCenter.current()) -&gt; Future&lt;[UNNotificationRequest], Never&gt; {
        Future&lt;[UNNotificationRequest], Never&gt; { promise in
            print(&quot;Original&quot;)
            notificationCenter.getPendingNotificationRequests { requests in
                    promise(.success(requests))
            }
        }
    }
</code></pre>
<p>Here’s my function to convert <code>[UNNotificationReuqest]</code> to <code>[Date]</code> s</p>
<pre class=""lang-swift prettyprint-override""><code>    func notificationRequestsToDates(notificationRequests: [UNNotificationRequest]) -&gt;  [Date] {
        var arrayOfDates: [Date] = []
        for request in notificationRequests {
            let realTrigger = request.trigger as? UNCalendarNotificationTrigger
            arrayOfDates.append((realTrigger?.nextTriggerDate())!)
        }
    //    return notificationRequest.trigger as! UNCalendarNotificationTrigger
        return arrayOfDates
    }
</code></pre>
<p>Despite what’s in my <code>updateNotificationView</code> function’s body being almost identical to what is in the original button, it doesn’t update the <code>View</code>’s array.  I the future in the <code>updateNotificationView</code> function isn’t even initializing(?, starting?), and I’m not sure why.</p>
","12051065","","","","","2021-02-03 07:27:49","Why does my Combine future logic work inside of a Button, but not inside of it's own function called by a Button?","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"66019350","1","66019521","","2021-02-03 00:00:45","","0","153","<p>I am using an isLoading Bool in an environment object named authState.</p>
<pre><code>import Foundation
import FirebaseAuth
import Combine

class AuthState: ObservableObject {
    
    enum AuthStateMode {
        case unregistered
        case signedInAnonymously
        case signedInWithEmail
    }
    
    @Published var user: User?
    @Published var authStateMode: AuthStateMode = .unregistered
    @Published var error: AuthError?
    @Published var isLoading: Bool = false
    
    private var cancellables = Set&lt;AnyCancellable&gt;()

    
    let authService = AuthService()
    
    init() {
        authService.authStateSubject.assign(to: &amp;$user)
        $user.map { user -&gt; AuthStateMode in
            if let user = user {
                if user.email != nil { return .signedInWithEmail }
                else if user.uid != &quot;&quot; { return .signedInAnonymously }
                else { return .unregistered }
            } else { return .unregistered }
        }.assign(to: &amp;$authStateMode)
    
    }
    
    func signIn(email: String, password: String) {
        self.isLoading = true
        authService.signIn(email: email, password: password)
            .sink { completion in
                self.isLoading = false
                switch completion {
                case let .failure(error):
                    return self.error = error
                case .finished: return print(&quot;authState.signIn finished&quot;)
                }
            } receiveValue: { _ in }
            .store(in: &amp;cancellables)
    }
    
    func signInAnonymously() {
        isLoading = true
        authService.signInAnonymously()
            .sink { completion in
                self.isLoading = false
                switch completion {
                case let .failure(error):
                    return self.error = error
                case .finished: return
                }
            } receiveValue: { user in
                self.user = user
            }.store(in: &amp;cancellables)
    }
    
    func linkAccount(email: String, password: String) {
        isLoading = true
        authService.linkAccount(email: email, password: password)
            .sink { completion in
                self.isLoading = false
                switch completion {
                case let .failure(error):
                    return self.error = error
                case .finished:
                    return print(&quot;linkAccount finished&quot;)
                }
            } receiveValue: { user in
                self.user = user
            }
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>I have a parent View that uses the authState.isLoading Bool.</p>
<pre><code>import SwiftUI
import Combine

struct SelectUserTypeView: View {
    
    @EnvironmentObject var authState: AuthState

    var body: some View {
        
        NavigationView {
            VStack {
                Spacer()
                if authState.isLoading == true {
                    ProgressView()
                } else if authState.authStateMode == .unregistered {
                    Button { authState.signInAnonymously() }
                        label:{ Text(&quot;Connect&quot;) }
                } else {
                    NavigationLink(
                        destination: GuestPreviewView(),
                        label: { Text(&quot;Join as Guest&quot;) })
                    Spacer()
                    NavigationLink(
                        destination: SignInUpView(viewModel: .init(mode: .signUp)),
                        label: { Text(&quot;Host a Session&quot;) })
                }
                Spacer()
                NavigationLink(destination: RecordingsView(),
                               label: { Text(&quot;Browse Recordings&quot;) })
                Spacer()
                    .navigationBarTitle(Text(&quot;Welcome to Fullres&quot;), displayMode: .inline)
                    .onAppear(perform: authState.signInAnonymously)
            }
        }
    }
}
</code></pre>
<p>I have a child view that also uses the authState.isLoading Bool.</p>
<pre><code>import SwiftUI
import Combine

struct SignInUpView: View {
    
    @EnvironmentObject var authState: AuthState
    @StateObject var viewModel: SignInUpViewModel
    
    var body: some View {
        ZStack {
            if authState.isLoading {
                ProgressView()
            } else if authState.authStateMode == .signedInWithEmail {
                HostPreviewView()
            } else {
                VStack {
                    Spacer()
                    Text(viewModel.heading)
                        .font(.title)
                        .bold()
                        .padding()
                    if let error = authState.error { Text(&quot;\(error.localizedDescription)&quot;) }
                    TextField(&quot;Email&quot;, text: $viewModel.email)
                        .autocapitalization(/*@START_MENU_TOKEN@*/.none/*@END_MENU_TOKEN@*/)
                        .disableAutocorrection(true)
                        .padding()
                    SecureField(&quot;Password&quot;, text: $viewModel.password)
                        .autocapitalization(/*@START_MENU_TOKEN@*/.none/*@END_MENU_TOKEN@*/)
                        .disableAutocorrection(true)
                        .padding()
                    Button(viewModel.signInUpBtnLbl) {signInUpBtnAction()}
                        .font(.title2)
                        .padding()
                    Spacer()
                    Button(viewModel.signInUpModeBtnLbl) {
                        viewModel.mode.toggle()
                    }
                    .padding()
                    Spacer()
                }
            }
        }
    }
    
    func signInUpBtnAction() {
        switch viewModel.mode {
        case .signIn: authState.signIn(email: viewModel.email, password: viewModel.password)
        case .signUp: authState.linkAccount(email: viewModel.email, password: viewModel.password)
        }
    }
}
</code></pre>
<p>It seems that whenever the isLoading Bool switches to true while on the child view, the UI presents the parent view.</p>
<p>Can someone shed some light on how best to go about solving this issue?</p>
","15068510","","15068510","","2021-02-03 00:10:40","2021-02-03 01:12:57","How to use isLoading with a viewModel and an Environment Object","<mvvm><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"66030354","1","","","2021-02-03 15:14:34","","1","863","<p>With the following code, after I put <code>receive(on: backgroundQueue)</code>, the <code>receiveCompletion</code> will be called 100%, but the <code>receiveValue</code> block is not.</p>
<pre class=""lang-swift prettyprint-override""><code>xxxxPublisher
    .xxxx()
    .receive(on: backgroundQueue)
    .xxxx()
    .receive(on: DispatchQueue.main)
    .sink(receiveCompletion: { completion in
        // completion code
    }, receiveValue: { value in
        // receive value code
    }).store(in: &amp;cancellables)
</code></pre>
<p>This seems not a good behavior, are we supposed to not use <code>receive&lt;S&gt;(on scheduler: S, options: S.SchedulerOptions? = nil)</code> in this way? Am I missing something?</p>
<p>Here is the code to reproduce this bug, if you run this code, you will see that <code>receiveCompletion</code> is called exactly 300 times, but <code>receiveValue</code> is called less than 300.</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

private var cancellables: Set&lt;AnyCancellable&gt; = []
let backgroundQueue = DispatchQueue.global(qos: .background)
for i in 1...300 {
    runPublisher(i)
}
var sinkCompletedIndices = Set&lt;Int&gt;()
var sinkOutputIndices = Set&lt;Int&gt;()

func runPublisher(_ index: Int) {
    [1].publisher
    .receive(on: backgroundQueue)
    .receive(on: DispatchQueue.main)
    .sink(receiveCompletion: { completion in
        NSLog(&quot;sink receiveCompletion&quot;)
        sinkCompletedIndices.insert(index)
    }, receiveValue: { value in
        NSLog(&quot;sink receiveValue&quot;)
        sinkOutputIndices.insert(index)
    }).store(in: &amp;cancellables)
}
DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) {
    let diff = sinkCompletedIndices.filter { !sinkOutputIndices.contains($0) }
    NSLog(&quot;Difference between completions and outputs \(diff)&quot;)
}
RunLoop.main.run()
</code></pre>
","4050529","","4050529","","2021-02-03 15:22:49","2021-02-03 16:31:25","`Sink.receiveValue` is not called after `publisher.receive(on: backgroundQueue)`","<ios><swift><combine>","1","6","","","","CC BY-SA 4.0"
"66035450","1","66036283","","2021-02-03 20:49:53","","1","1149","<p>I'm exploring Combine, and this issue has come up and perplexed me no end. My understanding is that a PassthroughSubject will exist as long as the object it is scoped in if a reference to it is stored as <code>AnyCancellable</code>.</p>
<p>In this example of a <code>loginPublisher: PassthroughSubject&lt;User, Error&gt;</code> waiting for updates to the <code>User</code> object, the <code>Subject.Completion.finished</code> block is called immediately after the first value is received.</p>
<pre><code>import SwiftUI
import Combine

class AppDelegate: NSObject, UIApplicationDelegate {
    let appState = AppState()

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -&gt; Bool {
        return true
    }
}

@main
struct SPMDepsTestApp: SwiftUI.App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    var body: some Scene {
        WindowGroup {
            ContentView().environmentObject(appDelegate.appState)
        }
    }
}

struct User {
    var id: Int
    var name: String
}

class App {
    var currentUser: User? = nil

    func login (user: User) -&gt; Future&lt;User, Error&gt; {
        Future { promise in
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                self.currentUser = user
                promise(.success(user))
            }
        }
    }
}

class AppState: ObservableObject {
    var app = App()
    var loginPublisher = PassthroughSubject&lt;User, Error&gt;()

    var cancellables = Set&lt;AnyCancellable&gt;()

    init () {

        loginPublisher
                .receive(on: DispatchQueue.main)
                .sink(receiveCompletion: { completion in
                    switch completion {
                        case .failure(let err):
                            dump(err)
                        case .finished:
                            print(&quot;ISSUE: loginPublisher is finished&quot;) // &lt;&lt; Why should this happen immediately?
                    }
                }, receiveValue: { user in
                    dump(user)
                })
                .store(in: &amp;cancellables)

        if let user = app.currentUser {
            loginPublisher.send(user)
        } else {
            app.login(user: User(id: 0, name: &quot;AAA&quot;))
                    .receive(on: DispatchQueue.main)
                    .subscribe(loginPublisher)
                    .store(in: &amp;cancellables)
        }
    }
}
</code></pre>
<p>Differently, If I initialize the App object like so</p>
<pre><code>var App = App(user: user)
</code></pre>
<p>so that <code>app.currentUser != nil</code> then the line</p>
<pre><code> if let user = app.currentUser {
      loginPublisher.send(user) // &lt;&lt; loginPublisher completion (finished) block is never called
 }
 
</code></pre>
<p>Why is <code>PassthroughSubject</code> completing if (seemingly) loginPublisher.send() is not called synchronously?</p>
","4286164","","","","","2021-02-03 21:54:42","Why is PassthroughSubject completing with .finished?","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"66042703","1","","","2021-02-04 09:23:14","","2","113","<p>I'm having issues where as more text is being typed into the textfield, the application (Mac) becomes more and more laggy.</p>
<pre><code>class Action: ObservableObject, Identifiable {
    var id = String(UUID().uuidString.prefix(7))
    @Published var actionType = ActionType.display
    @Published var arguments = [String:ValueType]()
}

struct AnalyticsKeyValuePairView: View {
    var state: Action
    let initialKey : String
    @State var stateKey: String
    @State var value: String
    init(state: Action, initialKey: String) {
        self.initialKey = initialKey
        self.state = state
        self._stateKey = State(initialValue: initialKey)
        self._value = State(initialValue: state.arguments[initialKey]!.stringValue!)
    }
    var body: some View {
        HStack {
            TextField(&quot;key&quot;, text: $stateKey) { (b) in
                
            } onCommit: {
                if initialKey != stateKey {
                    state.setArgument(nil, forKey: initialKey)
                }
                state.setArgument(.string(value), forKey: stateKey)
            }

            Spacer()
            
            TextField(&quot;value&quot;, text: $value) { (_) in
                
            } onCommit: {
                if initialKey != stateKey {
                    state.arguments[initialKey] = nil
                }
                state.setArgument(.string(value), forKey: stateKey)
                
            }
    }
}
</code></pre>
<p>in instruments you can see a lot core animation activity</p>
<p><a href=""https://i.stack.imgur.com/sFodq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sFodq.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.stack.imgur.com/qdKdi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qdKdi.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.stack.imgur.com/B9tSZ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/B9tSZ.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.stack.imgur.com/GgR9b.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GgR9b.png"" alt=""enter image description here"" /></a></p>
<p><a href=""https://i.stack.imgur.com/qdtcM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qdtcM.png"" alt=""enter image description here"" /></a></p>
","1532045","","","","","2021-02-04 09:23:14","swiftui textfield is extremely laggy","<macos><swiftui><core-animation><instruments><combine>","0","1","","","","CC BY-SA 4.0"
"66043573","1","66044955","","2021-02-04 10:16:54","","1","706","<p>Thats my model class</p>
<pre><code>struct LoginResponse: Codable {
    let main: LoginModel
}

struct LoginModel: Codable {
    
    let success: Bool?
    let token: String?
    let message: String?
    
    static var placeholder: LoginModel {
        return LoginModel(success: nil, token: nil, message: nil)
    }
    
}
</code></pre>
<p>Thats my service. I have one more issue i am using two map here but when try to remove map.data getting error in dataTaskPublisher. error mention below</p>
<blockquote>
<p>Instance method 'decode(type:decoder:)' requires the types 'URLSession.DataTaskPublisher.Output' (aka '(data: Data, response: URLResponse)') and 'JSONDecoder.Input' (aka 'Data') be equivalent</p>
</blockquote>
<pre><code>class LoginService {
    func doLoginTask(username: String, password: String) -&gt; AnyPublisher&lt;LoginModel, Error&gt; {
        
       
        
      let networkQueue = DispatchQueue(label: &quot;Networking&quot;,
                                           qos: .default,
                                           attributes: .concurrent)
        
        guard let url = URL(string: Constants.URLs.baseUrl(urlPath: Constants.URLs.loginPath)) else {
            fatalError(&quot;Invalid URL&quot;)
         }
        
        print(&quot;uri&quot;, url)
        
        let body: [String: String] = [&quot;username&quot;: username, &quot;password&quot;: password]

                let finalBody = try! JSONSerialization.data(withJSONObject: body)
                var request = URLRequest(url: url)
                request.httpMethod = &quot;POST&quot;
                request.httpBody = finalBody
                request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        
        return URLSession.shared.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: LoginResponse.self, decoder: JSONDecoder())
            .map { $0.main }
            .receive(on: networkQueue)
            .eraseToAnyPublisher()
        
    }
    
}
</code></pre>
<p>Thats my contentView</p>
<pre><code>Button(action: {
                    self.counter += 1
                    print(&quot;count from action&quot;, self.counter)
                    
                
                    
                    func loaginTask() {
                        _ = loginService.doLoginTask(username: &quot;1234567890&quot;, password: &quot;12345&quot;)
                        .sink(
                          receiveCompletion: {
                            print(&quot;Received Completion: \($0)&quot;) },
                          receiveValue: { doctor in
                            print(&quot;hhhhh&quot;)
                          //  print(&quot;yes &quot;, doctor.message as Any)
                            
                          }
                      )
                    }
                })
</code></pre>
<p>Thats my json response</p>
<pre><code>{
    &quot;success&quot;: true,
    &quot;token&quot;: &quot;ed48aa9b40c2d88079e6fd140c87ac61fc9ce78a&quot;,
    &quot;expert-token&quot;: &quot;6ec84e92ea93b793924d48aa9b40c2d88079e6fd140c87ac61fc9ce78ae4fa93&quot;,
    &quot;message&quot;: &quot;Logged in successfully&quot;
}
</code></pre>
","5532139","","","","","2021-02-04 12:15:44","Unable to get the response from URL using combine with SwiftUI","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"66055959","1","","","2021-02-05 00:37:21","","0","1673","<p>I am trying out <a href=""https://docs.mongodb.com/realm/ios/swiftui/"" rel=""nofollow noreferrer"">this quick start for SwiftUI and Combine</a> in order to try and understand how to connect my Realm database to Combine.</p>
<p>The example observes a <code>RealmSwift.List</code> and keeps a table populated with its data. This is is a linked list to a child class. I'm wondering how to observe a <code>Results</code> collection so I can keep track of any changes to an entire Realm class.</p>
<p>For example, let's say I have a <code>Workspace</code> class:</p>
<pre><code>class Workspace: Object, ObjectKeyIdentifiable{
  @objc dynamic var id = UUID().uuidString
  @objc dynamic var name = &quot;&quot;
  @objc dynamic var archived = false
}
</code></pre>
<p>In the state object, I can set up a <code>Results&lt;Workspace&gt;</code> variable like this:</p>
<pre><code>class AppState: ObservableObject {
  @Published var workspaces: Results&lt;Workspace&gt;?
  var cancellables = Set&lt;AnyCancellable&gt;()
  
  init(){

    let realmPublisher = PassthroughSubject&lt;Realm, Error&gt;()

    realmPublisher
      .sink(receiveCompletion: { _ in }, receiveValue: { realm in
        //Get the Results
        self.workspaces = realm.objects(Workspace.self)
      })
      .store(in: &amp;cancellables)

    realmPublisher.send(try! Realm())

    return
  }
}
</code></pre>
<p>But when it comes time to observe the object, I can't because <code>Results</code> isn't an object (I assume).</p>
<pre><code>struct ContentView: App {
  @ObservedObject var state = AppState()
  var view: some View {
    ItemsView(workspaces: state.workspaces!)  
  }
  var body: some Scene {
    WindowGroup {
      view.environmentObject(state)
    }
  }
}

struct ItemsView: View {
  @ObservedObject var workspaces: Results&lt;Workspace&gt; //&lt;!-- Error

  var body: some View {
    //...
  }
}
</code></pre>
<p>Xcode gives a syntax error on the <code>workspaces</code> property:</p>
<blockquote>
<p><em>Property type 'Results' does not match that of the 'wrappedValue' property of its wrapper type 'ObservedObject'</em></p>
</blockquote>
<p>Is it possible to observe a set of <code>Results</code> just like we can have a notification listener on a collection of <code>Results</code>?</p>
","1142348","","1142348","","2021-02-05 17:21:31","2021-02-05 18:46:38","Observe Collection Results in Realm with Combine and SwiftUI","<swiftui><realm><combine>","2","0","","","","CC BY-SA 4.0"
"66071387","1","66072284","","2021-02-05 22:20:53","","0","372","<p>I have an object called <code>ProcessorStack</code> which contains zero or more child <code>Processor</code> items. The <code>ProcessorStack</code> and the individual <code>Processor</code> objects each have only a single method:</p>
<p><code>process(input: Value) -&gt; Future&lt;Value, Never&gt;</code></p>
<p>I would like the return value to be a <code>Future</code> rather than <code>AnyPublisher</code> to clearly indicate that the caller should only expect a single result to be emitted. Other objects only have access to the <code>ProcessorStack</code>, not its <code>Processor</code> children. Here's what I want to happen:</p>
<ol>
<li>An object calls the <code>ProcessorStack</code>:
<pre><code>stack.process(value: someValue).sink { result in
    // Do something with the result
}.store(in: &amp;subscriptions)
</code></pre>
</li>
<li>The <code>ProcessorStack</code> chains all of its child <code>Processor</code> objects together using a reduce operation and returns the final result via the <code>Future</code>:
<pre><code>func process(value: Value) -&gt; Future&lt;Value, Never&gt; {
    guard !childProcessors.isEmpty else {
        return Future { $0(.success(value)) }
    }
    let just = Just(value).eraseToAnyPublisher()
    childProcessors.reduce(just) { (publisher, processor) -&gt; AnyPublisher&lt;Value, Never&gt; in
        publisher.flatMap { processor.process(value: $0).eraseToAnyPublisher() }
    }
    // Here's where I'm lost.
}
</code></pre>
</li>
</ol>
<p>I cannot for the life of me figure out how to execute the asynchronous reduce chain and then return the result as a <code>Future</code>. If I wrap the whole reduce operation in a <code>Future</code> initializer, I'm left holding an <code>AnyPublisher&lt;Value, Never&gt;</code> which I somehow have to get to execute and then the result of that get passed to the <code>Future</code>'s completion closure. I can't <code>sink</code> it inside the <code>Future</code>'s closure, because I have to hold on to the cancellable returned from that or the whole process immediately halts. I can't FlatMap the result into a Future, because that has the type <code>FlatMap&lt;AnyPublisher&lt;Value, Never&gt;, Future&lt;Value, Never&gt;&gt;</code>. I can accomplish all of this if I just make the outer return type <code>AnyPublisher&lt;Value, Never&gt;</code>, but I was really hoping to have the <code>Future</code> semantics for subscribers.</p>
","630517","","","","","2021-02-06 00:18:05","Swift Combine: Do asynchronous work in a Future?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66075000","1","66078973","","2021-02-06 08:39:33","","2","1497","<p>I have a publisher which would need re-evaluating on day change, but should continue to emit values at any other time.</p>
<p>As such, I thought I could use a <code>NotificationCenter</code> publisher for the <code>UIApplication.significantTimeChangeNotification</code> notification and combine it with my publisher such that the combine emission process would re-run on either on data change or day change and hence re-evaluate the map filter. See a rough outline of that code below.</p>
<p>The problem is that there is no published event by <code>NotificationCenter</code> at the point in time that this is setup and hence, none of the following <code>map</code> etc calls actually evaluate. <code>merge(with:)</code> won't work as the two publishers publish different types, but <code>combineLatest(_:)</code> and <code>zip(_:)</code> both won't emit events until both publishers have emitted a single event.</p>
<p>I can validate that my code operates as expected by adding <code>NotificationCenter.default.post(name: UIApplication.significantTimeChangeNotification, object: nil)</code> after this code, but that is undesirable due to it potentially signalling other areas of the app that an actual time change has occurred when it hasn't</p>
<pre class=""lang-swift prettyprint-override""><code>private func todaysDate() -&gt; String {
    let formatter = DateFormatter()
    formatter.dateFormat = &quot;YYYY-MM-dd&quot;
    return formatter.string(from: Date())
}

@Published var entities: [MyEntity]

let dayChangePublisher = NotificationCenter.default
    .publisher(for: UIApplication.significantTimeChangeNotification)

$entities.combineLatest(dayChangePublisher)
    .map(\.0) // Only pass on the entity for further operations
    .map { entities -&gt; MyEntity? in
        let today = todaysDate()
        return entities?.first(where: { $0.id == today })
    }
    ...remainder of combine code

</code></pre>
<p>Can this combination of publishers and evaluation of events occur with the current Swift combine framework? Like the behaviour I'd expect from <code>merge(with:)</code> but where the publishers emit two different types.</p>
<p>edit:
I found one solution where I map the notification publisher to a nil array</p>
<pre class=""lang-swift prettyprint-override""><code>let dayChangePublisher = NotificationCenter.default
    .publisher(for: UIApplication.significantTimeChangeNotification)
    .map { _ ➝ [MyEntity]? in
        return nil
    }
</code></pre>
<p>And then use <code>merge</code> and <code>compactMap</code> to avoid passing any nil values on</p>
<pre class=""lang-swift prettyprint-override""><code>let mergedPub = repo.$entities
        .merge(with: dayChangePublisher)
        .compactMap { entity -&gt; MyEntity? in
            let today = todaysDate()
            return entities?.first { $0.id == today }
        }
        .share()
</code></pre>
<p>It works, but maybe a bit cumbersome if anyone has a better solution?</p>
","1602729","","1602729","","2021-02-06 10:05:29","2021-03-17 13:33:35","Swift combine publishers where one hasn't sent a value yet","<swift><combine>","1","0","2","","","CC BY-SA 4.0"
"66075819","1","","","2021-02-06 10:27:06","","0","39","<p>I have a view that consists of two subviews with 1) separate internal states but 2) a high-level state that’s noteworthy to any associated views i.e. each other. That is, a change in one’s high-level state should trigger the other to reconsider/change its own. Imagine – in the interest of keeping it simple/generalisable - a header that has a set of buttons that change based on the option selected in the footer. On the flip side, there’s a button in the header that exits the active state and reset it back to its original state (and therefore the footer’s too).</p>
<p>I’ve managed to conveniently achieve this by adopting a shared universal instance for each view’s view model. The header for example was observing changes in the footer’s view model, and therefore is able react to a change in the footer’s high-level state. However, considering the footer had other internal states (i.e. irrelevant to the header but necessary for the footer view that was observing changes to its own view model), the header view was being re-rendered every time there was any change, regardless of relevance, to the footer view. In reality, at least to my eyes, I wouldn’t notice any visual hiccups but I’m aware this is a fundamentally inefficient (and wrong) way to manage the flow of states. And that if this misbehavior was widespread, then performance is likely to become compromised (visible).</p>
<p>What I have is something along the lines of:</p>
<pre><code>struct HeaderView: View {
        
    // MARK: Observers
    @ObservedObject var viewModel: HeaderViewModel = HeaderViewModel.shared
    @ObservedObject var footerViewModel: FooterViewModel = FooterViewModel.shared
    
    // MARK: -
    var body: some View {
        VStack {
            switch footerViewModel.state {
                case 1: HeaderState1View()
                case 2: HeaderState2View()
                case 3: HeaderState3View()
            }
            Button(&quot;EXIT&quot;, action: {viewModel.reset()})
        }
    }
}

struct FooterView: View {
        
    // MARK: Observers
    @ObservedObject var viewModel: FooterViewModel = FooterViewModel.shared
    
    // MARK: -
    var body: some View {
        Button(&quot;State 1&quot;, action: {viewModel.state(to: 1)})
            .background(viewModel.state == 1 ? Color.red : Color.clear)
        Button(&quot;State 2&quot;, action: {viewModel.reset()})
            .background(viewModel.state == 2 ? Color.red : Color.clear)
        Button(&quot;State 3&quot;, action: {viewModel.reset()})
            .background(viewModel.state == 3 ? Color.red : Color.clear)
    }
}

class HeaderViewModel: ObservableObject {
    // ...
    
    func reset() {
        FooterViewModel.shared.reset()
        // and other internal state changes
    }

    // ...
}

class FooterViewModel: ObservableObject {
    
    @Published var state: Int = 1
    // ...
    
    func state(to state: Int) {
        self.state = state
    }

    func reset() {
        self.state = 1
    }

    // ...
}
</code></pre>
<p>The view models for each is created inside a root-level ViewModel responsible for creating both (and others).</p>
<pre><code>class ViewModel {
    var footer = FooterViewModel()
    var header = HeaderViewModel()
    // etc.
}
</code></pre>
<p>That’s created in @main root struct:</p>
<pre><code>@main
struct myApp: App {
    
    // MARK: Variables
    var viewModel = ViewModel()
    
    // MARK: Layout
    var body: some Scene {        
        return WindowGroup {
            ContentView()
                .environmentObject(viewModel)
        }
    }
}

struct ContentView: View {
    
    // MARK: -
    var body: some View {
        VStack {
            header
            /// other views
            footer
        }
    }
</code></pre>
<p>Without depending on shared instances of both header and footers’ view models, as I have above, what would the most appropriate/efficient way to achieve what I’m after?</p>
<p>To be more specific/clear, if, for example, the Header and Footer views create a @StateObject of their respective view models i.e.</p>
<pre><code>@StateObject var viewModel: FooterViewModel = FooterViewModel() /// in FooterView.swift
@StateObject var viewModel: HeaderViewModel = HeaderViewModel() /// in HeaderView.swift
</code></pre>
<p>How would I be able let any change in HeaderView communicate back to the instance of FooterViewModel that FooterView created?</p>
<p>EDIT:</p>
<p>I imagine one way to possibly achieve this is if I create a third view model that consists of the published shared state and that it’s passed into both views when they’re initialised. But imagine there was more than one published property that needed to be shared between the views, and that there was another view in the mix that needed access to only one of them – would I create two shared view models then: one with publishers for shared properties between all 3 and another with ones for the 2? Doesn’t seem a practical strategy.</p>
","698971","","698971","","2021-02-06 11:54:59","2021-02-06 11:54:59","Communicating/reacting to a specific state change between views for two separate yet semi-associated view models","<swift><mvvm><viewmodel><publish-subscribe><combine>","0","7","","","","CC BY-SA 4.0"
"66085127","1","66089919","","2021-02-07 06:23:36","","1","653","<p>I have a function that needs to only be executed once at time. I'm trying to avoid a function to be called while it hasn't completed the last request. Here's what I'm trying to:</p>
<pre><code>import Combine
import Foundation
import PlaygroundSupport

var publisher1 = PassthroughSubject&lt;Bool, Never&gt;()
var publisher2 = PassthroughSubject&lt;Void, Never&gt;()
var cancellable = Set&lt;AnyCancellable&gt;()

func scheduleNotifications() -&gt; Future &lt;Void, Never&gt; {
    Future() { promise in
        print(&quot;Started scheduling... \(Date())&quot;)

        DispatchQueue.main.asyncAfter(deadline: .now() + 10) {
            promise(.success(()))
        }
    }
}

Publishers.Merge(
    publisher1
        .filter { $0 }
        .map { _ in },
    publisher2
)
.flatMap { scheduleNotifications() }
.sink { print(&quot;Complete: \(Date())&quot;) }
.store(in: &amp;cancellable)

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre>
<p>If <code>publisher1</code> and <code>publisher2</code> fire, then <code>scheduleNotifications()</code> is called. However, before the function finishes, <code>publisher1</code> could fire and call <code>scheduleNotifications()</code>:</p>
<pre><code>DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    publisher1.send(true)
}

DispatchQueue.main.asyncAfter(deadline: .now() + 4) {
    publisher1.send(true)
}
</code></pre>
<p>This prints:</p>
<pre><code>Started scheduling... 2021-02-07 15:50:25 +0000
Started scheduling... 2021-02-07 15:50:27 +0000
Complete: 2021-02-07 15:50:35 +0000
Complete: 2021-02-07 15:50:38 +0000
</code></pre>
<p>This is a problem because the <code>scheduleNotifications</code> is erasing all notifications before adding them. So the second request that fired one second later is erasing all the notifications the first request is still busy building.</p>
<p>Is there a way to tell the 2nd fire to hold on until <code>scheduleNotifications()</code> has completed any currently on going work it has finished yet?</p>
","235334","","235334","","2021-02-07 15:51:39","2021-02-07 15:57:31","How to queue or wait until last Combine request done?","<swift><combine>","2","6","","","","CC BY-SA 4.0"
"66089669","1","66106239","","2021-02-07 15:33:39","","-1","263","<p>I have 2 independent <code>ObservableObject</code>s called <code>ViewModel1</code> and <code>ViewModel2</code>.</p>
<p><code>ViewModel2</code> has an array of strings:</p>
<p><code>@Published var strings: [String] = []</code>.</p>
<p>Whenever that array is modified i want <code>ViewModel1</code> to be informed.</p>
<p>What's the recommended approach to achieve this?</p>
","294661","","","","","2021-02-08 17:16:28","Data communication between 2 ObservableObjects","<swift><swiftui><combine><observableobject><data-communication>","2","8","","","","CC BY-SA 4.0"
"66101210","1","66107017","","2021-02-08 11:59:38","","0","597","<p>I would like to perform a recursive once retry with Swift Combine when the server responds with a certain message (in the example a 401 error). The data in that response alters a model, which allows for a single retry.</p>
<p>I wrote a small extension for the result type that was used pre iOS 13</p>
<pre class=""lang-swift prettyprint-override""><code>extension URLSession {
    typealias HTTPResponse = (response: HTTPURLResponse, data: Data)
    typealias DataTaskResult = ((Result&lt;HTTPResponse, Error&gt;) -&gt; Void)

    func dataTask(with request: URLRequest, completionHandler: @escaping DataTaskResult) -&gt; URLSessionDataTask {
        self.dataTask(with: request) { (data, response, error) in
            if let error = error {
                completionHandler(.failure(error))
            }
            completionHandler(.success((response as! HTTPURLResponse, data!)))
        }
    }
}
</code></pre>
<p>I used this extension to do the following</p>
<pre class=""lang-swift prettyprint-override""><code>class Account {
    enum CommunicationError: Swift.Error {
        case counterOutOfSync
    }

    var counter: Int = 0

    func send(isRetry: Bool = false, completionBlock: @escaping URLSession.DataTaskResult) {
        var request = URLRequest(url: URL(string: &quot;https://myserver.com/fetch/&quot;)!)
        request.setValue(&quot;\(counter)&quot;, forHTTPHeaderField: &quot;MESSAGE-COUNTER&quot;)
        request.httpMethod = &quot;POST&quot;

        URLSession.shared.dataTask(with: request) { [weak self] taskResult in
            do {
                let taskResponse = try taskResult.get()
                if taskResponse.response.statusCode == 401 {
                    if isRetry { throw CommunicationError.counterOutOfSync }

                    // Counter is resynced based on taskResponse.data
                    self?.send(isRetry: true, completionBlock: completionBlock)
                } else {
                    completionBlock(.success(taskResponse))
                }
            } catch {
                completionBlock(.failure(error))
            }
        }.resume()
    }
}
</code></pre>
<p>You can see the recursive call in the function. I would like to do the same with Combine, but I don't know how to. This is as far as I get</p>
<pre class=""lang-swift prettyprint-override""><code>func combine(isRetry: Bool = false) -&gt; AnyPublisher&lt;Data, Error&gt; {
    var request = URLRequest(url: URL(string: &quot;https://myserver.com/fetch/&quot;)!)
    request.setValue(&quot;\(counter)&quot;, forHTTPHeaderField: &quot;MESSAGE-COUNTER&quot;)
    request.httpMethod = &quot;POST&quot;

    return URLSession.shared.dataTaskPublisher(for: request).tryMap {
        let response = $0.response as! HTTPURLResponse
        if response.statusCode == 401 {
            if isRetry { throw CommunicationError.counterOutOfSync }

            // Counter is resynced based on $0.data
            return self.combine(isRetry: true)
        } else {
            return $0.data
        }
    }.eraseToAnyPublisher()
}
</code></pre>
<p>Any help is appreciated</p>
","5530076","","","","","2021-02-08 18:09:11","Swift combine recursive retry","<ios><swift><http><recursion><combine>","1","2","","","","CC BY-SA 4.0"
"66113659","1","","","2021-02-09 05:49:53","","1","62","<pre><code>func bindUI() {
    tableView
        .publisher(for: \UITableView.indexPathForSelectedRow, options: [.new, .old, .initial])
        .compactMap { (indexPath) -&gt; Int in return indexPath?.row ?? 0 }
        .eraseToAnyPublisher()
        .receive(on: DispatchQueue.main, options: nil)
        .sink { [weak self] (row) in self?.label.text = &quot;Selected Row = \(row)&quot; }
        .store(in: &amp;cancellable)
}
</code></pre>
<p>I am trying to access the selected indexpath by observing the indexPathForSelectedRow key path. Getting initial value but not getting old or new selected values.</p>
","9187215","","","","","2021-02-09 05:49:53","Combine in swift - Not getting updated value for indexPath selected","<ios><swift><combine>","0","0","","","","CC BY-SA 4.0"
"66118723","1","","","2021-02-09 12:09:36","","5","1236","<p>I wish to apply a custom property wrapper to a variable already wrapped in <code>@Published</code>, nesting them like<br />
<em>(A)</em> <code>@Custom @Published var myVar</code> or<br />
<em>(B)</em> <code>@Published @Custom var myVar</code><br />
(notice the application order of the wrappers).</p>
<p>In the case of <em>(A)</em> I get the error</p>
<blockquote>
<p><code>'wrappedValue' is unavailable: @Published is only available on properties of classes</code></p>
</blockquote>
<p>and for <em>(B)</em></p>
<blockquote>
<p><code>error: key path value type 'Int' cannot be converted to contextual type 'Updating&lt;Int&gt;'</code></p>
</blockquote>
<p>neither of which are particularly helpful. Any ideas how to make it work?</p>
<h3>Minimal code example</h3>
<pre><code>import Combine

class A {
    @Updating @Published var b: Int
    
    init(b: Int) {
        self.b = b
    }
}

@propertyWrapper struct Updating&lt;T&gt; {
    var wrappedValue: T {
        didSet {
            print(&quot;Update: \(wrappedValue)&quot;)
        }
    }
}

let a = A(b: 1)
let cancellable = a.$b.sink {
    print(&quot;Published: \($0)&quot;)
}
a.b = 2
// Expected output:
// ==&gt; Published: 1
// ==&gt; Published: 2
// ==&gt; Update: 2
</code></pre>
","442852","","","","","2021-09-16 16:09:28","Combining custom property wrapper with @Published","<swift><combine><property-wrapper>","2","2","2","","","CC BY-SA 4.0"
"66129348","1","66129484","","2021-02-10 00:43:35","","1","365","<p>So I'm very new to swift so I might be getting this all wrong.</p>
<p>I'm learning to work with combine so I used the playground to log at an interval like so</p>
<pre><code>var cancellable:AnyCancellable? = Timer.publish(every: 1, on: .main, in: .default)
.autoconnect()
.sink {
    print($0)
}

PlaygroundPage.current.needsIndefiniteExecution = true
</code></pre>
<p>It's very simple and it works like I expect it to, printing a log every second.</p>
<p>Now when I create a new iOS project in Xcode it doesn't seem to work and I can't figure out why. From a blank project, I simply added this in the ContentView</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    func test() {
        var cancellable: AnyCancellable?
        cancellable = Timer.publish(every: 1, on: .main, in: .default)
        .autoconnect()
        .sink {
            print($0)
        }
    }
    
    var body: some View {
        VStack {
            Text(&quot;Hello, world!&quot;)
                .padding()
        }
    }
    
    init() {
        test()
    }
}
</code></pre>
<p>All of a sudden, it doesn't work and the log won't print. I'm sure it's something dumb that I'm not understanding but I've been looking at this forever now. My real case is with a network call that is not running so I tried simplifying as much as I can and this is as simple as I could get.</p>
<p>Any help appreciated!</p>
<p>Thanks!</p>
","7759526","","","","","2021-02-10 01:02:05","Swift combine not running properly in iOS app","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"66141387","1","67892456","","2021-02-10 16:57:28","","6","442","<p>I am using <strong>List</strong> to show the models in the main view. When I update the model in detail view it is not updated in detail view.</p>
<p>When I don't use <code>List</code>, detail view is updated. What am I missing for <code>List</code>?</p>
<hr />
<pre><code>struct Person: Identifiable {
  var id: UUID
  var name: String
}

class PersonModel: ObservableObject {
  @Published var persons: [Person] = [Person(id: UUID(), name: &quot;Ege&quot;)]
}

struct PersonListView: View {
  
  @StateObject private var personModel = PersonModel()
  
  var body: some View {
    NavigationView {
      List {
        ForEach(personModel.persons) { person in
          NavigationLink(destination: PersonDetailView(person: person).environmentObject(personModel)) {
            Text(person.name)
          }
        }
      }
      .navigationTitle(&quot;Persons&quot;)
    }
  }
}

struct PersonDetailView: View {
  
  let person: Person
  @EnvironmentObject var personModel: PersonModel
  
  var body: some View {
    VStack {
      Text(person.name)
      
      Button(action: {
        let personIndex = personModel.persons.firstIndex(where: { $0.id == person.id })!
        personModel.persons[personIndex].name = &quot;Updated Name&quot;
      }) {
        Text(&quot;Update&quot;)
      }
    }
    .navigationTitle(&quot;Person Detail&quot;)
  }
}
</code></pre>
<p>Workarounds that I used for List:</p>
<ul>
<li>Using custom binding function for NavigationLink.</li>
</ul>
<p>Example code:</p>
<pre><code>//1
private func binding(for person: Person) -&gt; Binding&lt;Person&gt; {
  let personIndex = personModel.persons.firstIndex(where: { $0.id == person.id }) ?? 0
  return $personModel.persons[personIndex]
}
//2
NavigationLink(destination: PersonDetailView(person: binding(for: person)))
//3
@Binding var person: Person //DetailView
</code></pre>
<ul>
<li>Using another <code>@State</code> in detail view which is initialized with passed
model in onAppear method.</li>
</ul>
","13886048","","13886048","","2021-03-28 09:52:45","2021-06-08 18:09:49","Detail View is not updated when the model is updated (Using List) SwiftUI","<swift><swiftui><combine><swiftui-list>","3","2","2","","","CC BY-SA 4.0"
"66152490","1","66157775","","2021-02-11 10:02:10","","0","206","<p>Swift 5.x iOS 14</p>
<p>Wrote this code, trying understand the sequence publisher in the Combine Framework.</p>
<pre><code>struct SwiftUIViewH: View {
  @State var textColor = Color.black
  var body: some View {
    Text(&quot;Hello, World!&quot;)
      .foregroundColor(textColor)
      .onAppear { 
        let initialSequence = [Color.red, Color.blue, Color.green, Color.orange]
        _ = initialSequence.publisher
              .delay(for: 1.0, scheduler: RunLoop.main)
              .sink {
                textColor = $0
                print($0)
              }
        }
  }
}
</code></pre>
<p>It works, in that I goes thru the list in milli-seconds and changes the colour of hello World if I don't try and slow the process down with a delay? But with delay in place as you see here, it does nothing it seems... <strong>the code above is broken</strong>?</p>
","3069232","","","","","2021-02-11 15:32:21","Why does .delay break this short piece of code using Combine framework in swift","<ios><swift><sequence><combine>","1","0","","","","CC BY-SA 4.0"
"66156293","1","","","2021-02-11 14:07:05","","0","187","<p>I use swiftUI in my project and i create a tabview with PageTabViewStyle and every tab has a specific viewModel and also the view of tabview has a viewModel that all tab's viewModel passed to it.</p>
<p>How I can call a method in my parent viewModel when nested viewmodel change from nested viewModel's such as show nextPage?</p>
<p>but app crashes with this error:
Thread 1: EXC_BAD_ACCESS (code=2, address=0x7ffee94bcfe8)</p>
<pre><code>class NestedViewModel: ObservableObject {
    @Published var isSelected = false

}

class ParentViewModel: ObservableObject {
    @Published var nestedViewModel: NestedViewModel = NestedViewModel()
    
    var anyCancellable: AnyCancellable? = nil
    
    init() {
        anyCancellable = submodel.objectWillChange.sink { [weak self] (_) in
            self?.objectWillChange.send()
            self?.showNextTab()
        }
    } 

    func showNextTab(){}
}

</code></pre>
","7364315","","7364315","","2021-02-11 14:58:49","2021-02-11 14:58:49","SwiftUI: How to call method from nested ViewModel with Combine?","<ios><swift><mvvm><swiftui><combine>","0","9","","","","CC BY-SA 4.0"
"66162810","1","","","2021-02-11 21:04:24","","6","681","<p><strong>Short:</strong> The Images in my view are not updating after the first load. The URL remains the same as the previous loaded view, however the rest of the view that doesn't fetch a URL or data from storage is updated.</p>
<p><strong>Full:</strong> I have two Views, a <code>ListView</code> and a <code>DetailView</code>.</p>
<p>In the <code>ListView</code> I display a list of type <code>List</code>. The detail view is supposed to show each <code>Profile</code> from <code>List.profiles</code>. I do this by storing each string <code>uid</code> in <code>List.profiles</code> and calling <code>model.fetchProfiles</code> to fetch the profiles for each list selected.</p>
<p>On the first selected <code>List</code> <code>model.fetchProfiles</code> returns the documents and <code>model.profiles</code> displays the data fine in the <code>DetailView</code>.</p>
<p>When first loading the <code>DetailView</code> the <code>ProfileRow</code> on appear is called and logs the profiles fetched. Then the <code>ProfileRow</code> loads the <code>imageURL</code> from the <code>imagePath</code> and uses it like to fetch the image.</p>
<p><strong>Console: Load List1</strong></p>
<blockquote>
<p>CARD DID APPEAR: Profiles []<br />
CARD DID APPEAR: SortedProfiles []
CARD ROW<br />
CARD ROW DID APPEAR: Profiles profiles/XXXXXX/Profile/profile.png<br />
CARD ROW DID APPEAR: SortedProfiles profiles/XXXXXX/Profile/profile.png<br />
Get url from image path: profiles/XXXXXX/Profile/profile.png<br />
Image URL: <a href=""https://firebasestorage.googleapis.com/APPNAME/profiles%XXXXXXX"" rel=""nofollow noreferrer"">https://firebasestorage.googleapis.com/APPNAME/profiles%XXXXXXX</a></p>
</blockquote>
<p>When selecting the second <code>List</code> from <code>ListView</code> the <code>ProfileRow </code> <code>didAppear</code> is not called due to;</p>
<pre><code>if model.profiles.count &gt; 0 {
  print(&quot;CARD ROW DID APPEAR: Profiles \(model.profiles[0]. imgPath)&quot;)     
  print(&quot;CARD ROW DID APPEAR: Sorted  \(model.sortedProfiles[0].imgPath)&quot;)
}
</code></pre>
<p>and won't ever again when selecting a <code>List</code> in <code>ListView</code>, however the rest of the profile data in the <code>ProfileRow</code> is displayed such as name so the data must be fetched.</p>
<p>The <code>ImagePath</code> is the same as the first view loading the exact same image. All other properties for the <code>Profile</code> such as name are loaded correctly.</p>
<p><strong>Console: Load List2</strong></p>
<blockquote>
<p>CARD DID APPEAR: Profiles []<br />
CARD DID APPEAR: SortedProfiles []
CARD ROW<br />
Get url from image path: profiles/XXXXXX/Profile/profile.png
Image URL:
<a href=""https://firebasestorage.googleapis.com/APPNAME/profiles%XXXXXXX"" rel=""nofollow noreferrer"">https://firebasestorage.googleapis.com/APPNAME/profiles%XXXXXXX</a></p>
</blockquote>
<p>If I then navigate to <code>List1</code> then the image for <code>List2</code> appears, if I reselect <code>List2</code> the image appears fine. The image show is correct on first load, and when selecting another list it always the one from before.</p>
<p>Can anyone help me out ?</p>
<p><strong>First View</strong></p>
<pre><code>struct ListViw: View {
  @EnvironmentObject var model: Model

  var body: some View {
    VStack {
        
        ForEach(model.lists.indices, id: \.self) { index in
            NavigationLink(
                destination: DetailView()
                            .environmentObject(model)
                            .onAppear() {
                                model.fetchProfiles()
                            }
            ) {
                 ListRow(home:model.lists[index])
                    .environmentObject(model)
            }
            .isDetailLink(false)
        }
    }
  }

}
</code></pre>
<p><strong>DetailView Card</strong></p>
<pre><code>struct ProfilesCard: View {

@EnvironmentObject var model: Model

var body: some View {
    VStack(alignment: .trailing, spacing: 16) {                
            if !model.sortedProfiles.isEmpty {
                VStack(alignment: .leading, spacing: 16) {
                    ForEach(model.sortedProfiles.indices, id: \.self) { index in
                        ProfileRow(
                            name: &quot;\(model.sortedProfiles[index].firstName) \(model.sortedProfiles[index].lastName)&quot;,
                            imgPath: model.sortedProfiles[index].imgPath,
                            index: index)
                            .environmentObject(model)
                    }
                }
                .padding(.top, 16)
            }
        
    }//End of Card
    .modifier(Card())
    .onAppear() {
        print(&quot;CARD DID APPEAR: Profiles \(model.profiles)&quot;)
        print(&quot;CARD DID APPEAR: SORTED \(model.sortedTenants)&quot;)
    }
}
}



struct ProfileRow: View {

@EnvironmentObject var model: Model

@State var imageURL = URL(string: &quot;&quot;)

var name: String
var imgPath: String
var index: Int

private func loadImage() {
    print(&quot;load image: \(imgPath)&quot;)
    DispatchQueue.main.async {
        fm.getURLFromFirestore(path: imgPath,  success: { (imgURL) in
                   print(&quot;Image URL: \(imgURL)&quot;)
            imageURL = imgURL
               }) { (error) in
                   print(error)
        }
    }
}

var body: some View {
    VStack(alignment: .leading, spacing: 12) {
        HStack(alignment: .center, spacing: 12) {

                   KFImage(imageURL,options: [.transition(.fade(0.2)), .forceRefresh])
                       .placeholder {
                           Rectangle().foregroundColor(.gray)
                       }
                       .resizable()
                       .aspectRatio(contentMode: .fill)
                       .frame(width: 32, height: 32)
                       .cornerRadius(16)


                // Profile text is always displayed correctly
            Text(name)
                    .modifier(BodyText())
                    .frame(maxWidth: .infinity, alignment: .leading)
        }
    }
    .onAppear() {
        print(&quot;CARD ROW&quot;)

        // Crashes if check is not there
        if model.profiles.count &gt; 0 {

            print(&quot;CARD ROW DID APPEAR: Profiles \(model.profiles[0]. imgPath)&quot;)

            print(&quot;CARD ROW DID APPEAR: Sorted  \(model.sortedProfiles[0].imgPath)&quot;)
        }
        
       loadImage()
    }
  }
}
</code></pre>
<p><strong>Model</strong></p>
<pre><code>class Model: ObservableObject {

  init() {
      fetchData()
  }

  @Published var profiles: [Profile] = []
  var sortedProfiles: [Profile] {return profiles.removeDuplicates } 

  @Published var list: List? {
      didSet {
          fetchProfiles()
      }
  }

  func fetchData() {
    if let currentUser = Auth.auth().currentUser {
        
        email = currentUser.email!

            db.collection(&quot;lists&quot;)
                .whereField(&quot;createdBy&quot;, isEqualTo: currentUser.uid)
                .addSnapshotListener { (querySnapshot, error) in
                guard let documents = querySnapshot?.documents else {
                    return
                }

                self.lists = documents.compactMap { queryDocumentSnapshot -&gt; List? in
                    return try? queryDocumentSnapshot.data(as: List.self)
                }
            }

    }
 }

  func fetchProfiles() {
    profiles.removeAll()
    
    for p in list!.profiles {
        firestoreManager.fetchProfile(uid: t, completion: { [self] profile in
            profiles.append(profile)
        })
    }
  }

}
</code></pre>
<p><strong>Update</strong></p>
<p>What I have tried so far is to use <code>didSet</code> for the <code>ImgPath</code> or <code>ImgURL</code> but still not luck. Also have tried using <code>model.profiles</code> directly.</p>
","4556409","","4556409","","2021-02-14 01:18:00","2021-02-17 04:47:39","How to refresh view with fetched data - Firestore & SwiftUI","<firebase><google-cloud-firestore><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"66164898","1","66165075","","2021-02-12 00:24:52","","18","7652","<p>I have a SwiftUI app with SwiftUI App life cycle. I'm trying to setup a standard way to add
typing debounce to TextFields. Ideally, I'd like to create my own TextField modifier that
can easily be applied to views that have many textfields to edit. I've tried a bunch of
ways to do this but I must be missing something fundamental. Here's one example. This
does not work:</p>
<pre><code>struct ContentView: View {

    @State private var searchText = &quot;&quot;
    
    var body: some View {
    
        VStack {
            Text(&quot;You entered: \(searchText)&quot;)
                .padding()
            TextField(&quot;Enter Something&quot;, text: $searchText)
                .frame(height: 30)
                .padding(.leading, 5)
                .overlay(
                    RoundedRectangle(cornerRadius: 6)
                        .stroke(Color.blue, lineWidth: 1)
                )
                .padding(.horizontal, 20)
                .onChange(of: searchText, perform: { _ in
                    var subscriptions = Set&lt;AnyCancellable&gt;()
                
                    let pub = PassthroughSubject&lt;String, Never&gt;()
                    pub
                        .debounce(for: .seconds(1), scheduler: DispatchQueue.main)
                        .collect()
                        .sink(receiveValue: { t in
                            self.searchText = t.first ?? &quot;nothing&quot;
                        } )
                        .store(in: &amp;subscriptions)
                })
        }
    }
}
</code></pre>
<p>Any guidance would be appreciated. Xcode 12.4, iOS 14.4</p>
","2698617","","","","","2022-07-16 12:25:20","SwiftUI Combine Debounce TextField","<ios><xcode><swiftui><combine>","4","0","8","","","CC BY-SA 4.0"
"66176535","1","66176703","","2021-02-12 17:39:14","","1","767","<p>I have a generic function used to send requests to the server.
Now before I send a request I need to check if the session token is expired and update it if needed.</p>
<p>my function looks like this<br />
<code>func upload&lt;T: Decodable&gt;(some parameters here) -&gt; AnyPublisher&lt;T, Error&gt;</code></p>
<p>I wanted to check and update the token inside that function before calling the main request but in this case, I can not return <code> AnyPublisher&lt;T, Error&gt;</code></p>
<pre><code>func upload&lt;T: Decodable&gt;(some parameters here) -&gt; AnyPublisher&lt;T, Error&gt; {
    if shouldUpdateToken {
        let request = // prepare request
        let session = // prepare session
        return session.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: SomeTokenObject.self, decoder: JSONDecoder())
            // here I wanted to save token and continue with 
            // the previous request 
            // but using .map, .flatMap, .compactMap will not return needed publisher
            // the error message I'll post below
            .map {
                // update token with $0
                // and continue with the main request
            }
    } else {
        return upload() // this will return AnyPublisher&lt;T, Error&gt; so it's ok here
    }
}
</code></pre>
<p>This error I get when using .flatMap
<code>Cannot convert return expression of type 'Publishers.FlatMap&lt;AnyPublisher&lt;T, Error&gt;, Publishers.Decode&lt;Publishers.MapKeyPath&lt;URLSession.DataTaskPublisher, JSONDecoder.Input&gt;, SomeTokenObject, JSONDecoder&gt;&gt;' (aka 'Publishers.FlatMap&lt;AnyPublisher&lt;T, Error&gt;, Publishers.Decode&lt;Publishers.MapKeyPath&lt;URLSession.DataTaskPublisher, Data&gt;, SomeTokenObject, JSONDecoder&gt;&gt;') to return type 'AnyPublisher&lt;T, Error&gt;'</code><br />
And similar for .map.</p>
<p>I added another function that was returning AnyPublisher&lt;SomeTokenObject, Error&gt; and thought to use inside <code>shouldUpdateToken</code> like that</p>
<pre><code>func upload&lt;T: Decodable&gt;(some parameters here) -&gt; AnyPublisher&lt;T, Error&gt; {
    if shouldUpdateToken {
        return refreshToken() // returns AnyPublisher&lt;Void, Error&gt;
            // now I need to continue with original request
            // and I'd like to use something like
            .flatMap { result -&gt; AnyPublisher&lt;T, Error&gt;
                upload()
            }
            // but using .map, .flatMap, .compactMap will not return needed publisher
            // the error message I'll post below
            
    } else {
        return upload() // this will return AnyPublisher&lt;T, Error&gt; so it's ok here
    }
}
</code></pre>
<p>for flatMap:
<code>Cannot convert return expression of type 'Publishers.FlatMap&lt;AnyPublisher&lt;T, Error&gt;, AnyPublisher&lt;Void, Error&gt;&gt;' to return type 'AnyPublisher&lt;T, Error&gt;'</code><br />
for map: <code>Cannot convert return expression of type 'Publishers.Map&lt;AnyPublisher&lt;Void, Error&gt;, AnyPublisher&lt;T, Error&gt;&gt;' to return type 'AnyPublisher&lt;T, Error&gt;'</code></p>
<p>Maybe I need to change to another approach?
I have a lot of requests all around the app so updating the token in one place is a good idea, but how can it be done?</p>
<p>Here is the <code>refreshToken()</code> function</p>
<pre><code>func refreshToken() -&gt; AnyPublisher&lt;Void, Error&gt; {
        let request = ...
        let session = ...
        return session.dataTaskPublisher(for: request)
            .map(\.data)
            .decode(type: SomeTokenObject.self, decoder: JSONDecoder())
            .map {
                // saved new token
            }
            .eraseToAnyPublisher()
    }
</code></pre>
","1507356","","1507356","","2021-02-12 18:00:39","2021-02-12 18:00:39","How to combine two requests but return generic publisher? Details below","<swift><generics><combine><publisher>","1","3","","","","CC BY-SA 4.0"
"66184006","1","66184274","","2021-02-13 10:19:51","","1","139","<p>I want to update button, from &quot;pause&quot; sign, back to &quot;play&quot; sign; when the class finishes to do the speech task. Current code doesn't do any change... What's wrong?</p>
<p>Can I do <code>.onChange</code> with condition? (only if change is specific)</p>
<pre><code>struct SwiftUIView: View {
    
    var speaker = Speaker()
    @State var isPlaying = false
        
    var body: some View {

        VStack {
            Button(action: {
                
                if isPlaying {
                    isPlaying.toggle()
                    speaker.synth.pauseSpeaking(at: .immediate)
                } else {
                    isPlaying.toggle()
                    // continue playing here if it was paused before, else ignite speech utterance
                    if speaker.synth.isPaused {
                        speaker.synth.continueSpeaking()
                    } else {
                        speaker.speak(&quot;Holly Molly bro&quot;)
                    }
                    
                }
            }, label: {
                Text(isPlaying ? &quot;pause&quot; : &quot;play&quot;)
            })
            
            
        }
        .onChange(of: speaker.hasStopped, perform: { value in
            isPlaying = false
            print(&quot;Who asked for change?&quot;)
        })
        
    }
}
</code></pre>
<p>...</p>
<pre><code>import AVFoundation
import Combine

class Speaker: ObservableObject, AVSpeechSynthesizerDelegate {
    let synth = AVSpeechSynthesizer()
    
    @Published var hasStopped: Bool = false

    func speak(_ string: String) {
            hasStopped = false
            
            let utterance = AVSpeechUtterance(string: string)
            utterance.voice = AVSpeechSynthesisVoice(language: &quot;en-GB&quot;)
            utterance.rate = 0.4
            synth.speak(utterance)
        }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
            print(&quot;all done&quot;)
            
            hasStopped = true
        }
}
</code></pre>
","11419259","","11419259","","2021-02-13 11:29:31","2021-02-22 03:04:57","How to update SwiftUI button after event in external class?","<swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"66186284","1","66186499","","2021-02-13 14:37:45","","2","399","<p>This is what I am trying to achieve:</p>
<pre><code>class MyVC: UIViewController {
    @State var myBoolState: Bool = false

    private var subscribers = Set&lt;AnyCancellable&gt;()

    override func viewDidLoad() {
        super.viewDidLoad()

        myBoolState.sink { value in .... }.store(in:&amp;subscribers)
    }

    func createTheView() {
        let vc = UIHostingController(rootView: MySwiftUIView(myBoolState: $myBoolState))
        self.navigationController!.pushViewController(vc, animated: true)
    }
}

struct MySwiftUIView: View {
    @Binding var myBoolState: Bool

    var body: some View {
          Button(action: {
              myBoolState = true
          }) {
              Text(&quot;Push Me&quot;)
          }

    }

}
</code></pre>
<p>But the above of course does not compile.</p>
<p>So the question is: can I somehow declare a published property inside a view controller, pass it to a SwiftUI View and get notified when the SwiftUI view changes its value?</p>
","251824","","","","","2021-02-13 15:00:23","Create a Publishable property in a view controller, pass it to a SwiftUI View and listen to changes inside view controller?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66188140","1","66188633","","2021-02-13 17:52:11","","2","1541","<p>I just want to ask you. Do I need <code>ObservableObject</code> as an inheritance in viewModel with UIKit and Combine (without SwiftUI)? I tried it without inheritance and it works. Should I use it or not?</p>
<p>Thanks for your responses.</p>
","11746995","","","","","2021-02-13 18:41:53","Do I need ObservableObject with UIKit?","<swift><uikit><observable><combine>","1","0","","","","CC BY-SA 4.0"
"66193060","1","66201291","","2021-02-14 06:43:09","","0","204","<p>I'm having trouble wrapping my head around how to use Combine in SwiftUI. I'm accustomed to using key-value observation in AppKit an UIKit because view controllers don't need to know about each other and can just react to some global objects that help determine state.</p>
<p>For example, in an AppKit/UIKit app, I would create a global state object like this:</p>
<pre><code>//Global State file
@objc class AppState: NSObject {
  @objc dynamic var project: Project?
}

//Create an instance I can access anywhere in my app
let app = AppState()
</code></pre>
<p>Then in a view controller, I can get notified of any changes to my app-wide project instance and react accordingly:</p>
<pre><code>//View Controller
class MyViewController: NSViewController{
  var observerProject: NSKeyValueObservation?

  override func viewDidLoad() {
    observerProject = app.observe(\.project) { object, change in
      self.refreshData()
    }
  }
  
  func refreshData(){
    //Query my persistent store and update my UI
  }
}
</code></pre>
<p>What is the Combine/SwiftUI analog to this?</p>
<p>Do I need to create a Publisher and then listen to my global object changes? If so, how do I make my Core Data <code>@FetchRequest</code> (whose predicate includes my global <code>Project</code> object) respond in real-time?</p>
<p>I've done things the old way for so long that this transition to SwiftUI/Combine is rather confusing to me. 🙂</p>
","1142348","","","","","2021-02-15 00:32:13","Converting Key-Value Observation in AppKit/UIKit to Combine and SwiftUI","<core-data><swiftui><key-value-observing><combine>","1","0","1","","","CC BY-SA 4.0"
"66201492","1","66202115","","2021-02-15 00:33:07","","3","489","<p>So I have this combine publisher that say emits integers -  <code>1,2,3,4,5,6,7,8,9,10,11 ....</code></p>
<p>These integers are though not always there. They are generated on the fly and sent to the publisher.</p>
<p>I am aware of the collect operator which when say called as .collect(5) gives me - <code>[1,2,3,4,5], [6,7,8,9,10], ...</code></p>
<p>What I am instead looking for is somewhat like buffer and collect combined - <code>[1,2,3,4,5], [2,3,4,5,6], [3,4,5,6,7] ...</code>.</p>
<p>Is there any way to do it without writing a custom operator? And if a custom operator is the way to go, can you provide some guidance towards that, I have not written a custom operator before. I hope what I am asking for is clear from the examples.</p>
<p>Thanks</p>
<h1>Edit</h1>
<p>This works, but I am not sure if this is the best solution -</p>
<pre class=""lang-swift prettyprint-override""><code>publisher.zip(
    publisher.dropFirst(),
    publisher.dropFirst(2))
</code></pre>
","10077646","","968155","","2021-02-15 02:39:34","2022-05-17 09:26:07","Swift Combine: Collect with Sliding window like functionality","<swift><combine>","3","0","","","","CC BY-SA 4.0"
"66206178","1","66213015","","2021-02-15 10:16:21","","1","335","<p>The API provider requires performing requests no more often than 1 second. How can this limitation be implemented using Combine in my <code>request</code> method?</p>
<pre><code>func request&lt;T: Codable&gt;(components: URLComponents) -&gt; AnyPublisher&lt;T, Error&gt; {
    return urlSession.dataTaskPublisher(for: components.url!)
        .map(\.data)
        .decode(type: T.self, decoder: JSONDecoder())
        .receive(on: RunLoop.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>So I would like to get from this:</p>
<pre><code>Request1 - 0.0 sec
Request2 - 0.3 sec
Request3 - 0.6 sec
Request4 - 0.9 sec
Request5 - 1.2 sec
</code></pre>
<p>... something like that:</p>
<pre><code>Request1 - 0.0 sec
Request2 - 1.0 sec
Request3 - 2.0 sec
Request4 - 3.0 sec
Request5 - 4.0 sec
</code></pre>
","6279226","","6279226","","2021-02-15 11:22:02","2021-02-15 17:53:59","Cooldown between api requests","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"66221952","1","","","2021-02-16 09:41:11","","1","523","<p>I'm using the new timer style (Text.DateStyle) that was introduced at WWDC 2020 in SwiftUI to display a countdown timer. This works initially. However, as soon as the date that is provided by my view model changes (e.g. click reset), the view doesn't update. The timer does indeed get the new date but it isn't displayed. You can check this by rotating the device / simulator or press+hold the reset button to see the updated timer work just fine. So it must be something related to the view lifecycle.</p>
<p>The code:</p>
<pre><code>import SwiftUI
import Combine

class ViewModel: ObservableObject {
    @Published var date: Date = Date().addingTimeInterval(1000)

    func reload() {
        date = Date().addingTimeInterval(1000)
    }
}

struct ContentView: View {
    @StateObject var viewModel = ViewModel()

    var body: some View {
        VStack {
            Text(viewModel.date, style: .timer)
            .padding()
            
            Button(&quot;Reset&quot;) {
                NotificationCenter.default.post(name: NSNotification.Name(&quot;TEST&quot;), object: nil)
            }
            Spacer()
        }
        .frame(width: 500.0)
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name(&quot;TEST&quot;)), perform: { _ in
            viewModel.reload()
        })
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
<p>Is this a know problem (and if so, is there a workaround?) or am I doing something wrong here?</p>
<p>Thanks for your help!</p>
","3184888","","","","","2021-02-16 15:29:24","SwiftUI: Text with timer style doesn't update after provided date changes","<swift><timer><swiftui><combine>","2","0","1","","","CC BY-SA 4.0"
"66231216","1","66231375","","2021-02-16 19:49:58","","1","385","<p>When adding to or removing from an array, the view does not update unless the user interacts with the <code>ScrollView</code>.</p>
<p>The <code>Model</code> is a <code>ObservableObject</code> that is declared as a <code>StateObject</code> early in the app lifecycle and then passed as a <code>EnvironmentObject</code>.</p>
<p>The data is simply a custom <code>Profile</code> object with an array of objects, when adding to <code>store.profile!.tasks.append()</code> or removing from the view does not update unless the user scrolls the ScrollView; I mean literally by 1 pixel.</p>
<p>What I have tried</p>
<ul>
<li>Wrapping the ForEach in a LazyVStack or VStack</li>
<li>Wrapping the NavigationLink in a VStack</li>
<li>Making sure size is full height incase it needed to recalculate</li>
</ul>
<p><strong>Code</strong></p>
<pre><code>class Profile: Identifiable, Codable, Equatable
    var tasks: [Task]
}


struct Task: Identifiable, Codable, Equatable {
    var createdBy: String
    var title: String
    var date: Date
}

class Store : ObservableObject {
    @Published var profile: Profile?
}

struct ListView: View {

@EnvironmentObject var store: Store

  var body: some View {
     GeometryReader { geometry in
        ZStack(alignment: .bottomTrailing) {
          ScrollView(.vertical, showsIndicators: false){
              ForEach(store.profile!.tasks.filter({ return $0.createdBy == store.profile!.uid}).indices, id: \.self) { index in
                 NavigationLink(destination: DetailView().environmentObject(store)) {
                      TasksRow().id(UUID()) 
                 }
             }
          }
           .frame(maxWidth: geometry.size.width, alignment: .center)
           .frame(maxHeight: geometry.size.height)
           .background(Color.gray)
       }
    }
 }
</code></pre>
","4556409","","4556409","","2021-02-16 20:03:17","2021-02-16 20:03:17","ForEach in ScrollView not updating until interaction","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66241909","1","66242168","","2021-02-17 12:23:32","","0","145","<p>I am trying to make a try-catch block with combine so I can execute certain function and re-execute main block again. I am doing something like this -</p>
<pre><code>return urlSession.dataTaskPublisher(for: request)
    .tryMap(verifyAPIResponse)
    .tryCatch { (error) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), URLError&gt; in
        self.apiCallOne()
            .tryMap(\.apiResponse)
            .tryMap({ (response) in
            })
        return self.urlSession.dataTaskPublisher(for: request) //&lt;&lt;- DOES this execute after refreshToken or executes in parallel?
    }
    .tryMap(parseJson)
    .receive(on: RunLoop.main)
    .eraseToAnyPublisher()
</code></pre>
<p>So my main concern here is -</p>
<ol>
<li>Does the apiCallOne happen before it returns self.urlSession.dataTaskPublisher(for: request) or</li>
<li>Does the API call apiCallOne execute in background and self.urlSession.dataTaskPublisher(for: request) will be returned immediately? If so, I can I return after completion of apiCallOne?</li>
</ol>
<p>Any pointers/help would be great.</p>
","3307233","","3307233","","2021-02-17 12:30:51","2021-02-17 12:41:53","How does Combine work inside try-catch block?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"66244396","1","66250725","","2021-02-17 14:52:26","","0","1023","<p>I have an <code>ObservableObject</code> that publishes some values using <code>@Published</code> property wrappers. This object also holds a timer.</p>
<p>The question is, how can I fire an event as soon as the timer is executed and handle that event in a view in SwiftUI (I'd prefer using something like <code>onReceive</code>)?
Using the Combine framework for publishing changing values already, I'd like to implement this event triggering / handling properly. But all that I've read so far about Combine is always about handling value changes. But in my case it's rather a single simple event (without any values).</p>
<p>I know that I could simply use a closure and call that when the timer expires, and I will do that if there's no better, combine-like solution.</p>
<p>This is a conceptual question for a very simple problem so I think it's self explaining without me coming up with a code example?</p>
","1754221","","1015258","","2021-02-17 17:44:55","2021-02-18 15:43:11","SwiftUI receive custom Event","<swift><swiftui><event-handling><combine>","2","6","","","","CC BY-SA 4.0"
"66253532","1","66264100","","2021-02-18 04:17:42","","2","185","<p>I have a Core Data publisher that is working great so far. I have a <code>Workspace</code> entity and a <code>Project</code> entity. I use the following publisher to get all the projects for a given workspace:</p>
<pre><code>class ProjectModel: ObservableObject {
  @Published var projects = [Project]()
  private var cancellableSet: Set&lt;AnyCancellable&gt; = []

  init(){
    CoreDataPublisher(request: Project.getAllProjects(), context: PersistenceController.shared.container.viewContext)
      .sink(
        receiveCompletion: { print($0) },
        receiveValue: { [weak self] items in
          self?.projects = items
        })
      .store(in: &amp;cancellableSet)
  }
}
</code></pre>
<p>The fetch request <code>getAllProjects()</code> is in a Core Data entity extension here where the <code>NSPredicate</code> filters based on a <code>Workspace</code> object set in the UI.</p>
<pre><code>//Core Data Entity Extension
extension Project{
  @nonobjc public class func getAllProjects() -&gt; NSFetchRequest&lt;Project&gt; {
    let workspace = AppState.shared.workspace as Workspace //&lt;-- The user can change this workspace
  
    let request = NSFetchRequest&lt;Project&gt;(entityName: &quot;\(Self.self)&quot;)
    request.sortDescriptors = [NSSortDescriptor(keyPath: \Project.name, ascending: true)]
    request.predicate = NSPredicate(format: &quot;workspace = %@&quot;, workspace)
    return request
  }
}
</code></pre>
<p>This <code>Workspace</code> object is in a global state class:</p>
<pre><code>class AppState: ObservableObject{
  static let shared = AppState()
  @Published var workspace: Workspace!

  init(){
    //Setup the workspace for the first time
  }
}
</code></pre>
<p>I can successfully receive data from my publisher and I can successfully change the global <code>Workspace</code> in the UI. The problem is that after changing the <code>Workspace</code>, the publisher still points to the old <code>Workspace</code> originally set when the fetch request was created.</p>
<p>How do I prompt the <code>ProjectModel</code> to reinitialize in order to renew the publisher's state when the <code>AppState</code>'s <code>workspace</code> is changed?</p>
","1142348","","","","","2021-02-18 16:32:05","Reinitialize Combine Publishers When User Changes Global Object","<core-data><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"66254326","1","","","2021-02-18 05:48:04","","0","383","<p>How would I go about assigning the array contents to a variable for use in the view.
<br /></p>
<pre><code>struct SwiftCameraApp: App {
     @StateObject var service = CameraService()
     var body: some Scene {
        WindowGroup {
            Home()
                .environmentObject(service)     
     }
}

public class CameraService: NSObject, ObservableObject {
    
    @Published var videoClips = [URL]()

    public func fileOutput(_ output: AVCaptureFileOutput, didFinishRecordingTo outputFileURL: URL, from connections: [AVCaptureConnection], error: Error?) {
        print(&quot;finished recording the video to: \(outputFileURL)&quot;)
        print(output.recordedDuration)

        videoClips.append(outputFileURL)
            
        //returns 1 at this point
        print(&quot;\(videoClips.count) video clip is now in the camera service&quot;)
}

struct ViewA: View {
    @StateObject var model = CameraService()
     Button(&quot;Adds item to videoClips&quot;) {
            model.fileOutput()
        }    
}

struct ViewB: View {
    @EnvironmentObject var service : CameraService
    var body: some View {
        Button(&quot;Prints Array count&quot;) {
            print(service.$videoClips.count())
        }
    }
}
</code></pre>
<p>Output:
<br />
<br />
Count(upstream: Combine.Published&lt;Swift.Array&lt;Foundation.URL&gt;&gt;.Publisher(subject: Combine.PublishedSubject&lt;Swift.Array&lt;Foundation.URL&gt;&gt;))
<br />
<br />
Maybe helpful to know.
<br />
a) When the CameraService is initiated videoClips is empty. A value is added AFTER the button is pressed in view A.
<br />
<br />
b) I think when the view is initialized a new CameraService is created making it an empty array
<br />
<br />
c) The idea is to take a video. Append it to a videoClips array and then do something with the contents in view B.</p>
","3335641","","3335641","","2021-02-18 06:51:22","2021-02-19 13:38:20","How to 'unwrap' Publisher object in view [swift]","<ios><swift><swiftui><swift5><combine>","2","0","","","","CC BY-SA 4.0"
"66257019","1","66260412","","2021-02-18 09:24:33","","1","85","<p>In order to update a view, I want to forward the view from my ViewController to the ViewModel by forwarding it.</p>
<p>Something like the following:</p>
<pre class=""lang-swift prettyprint-override""><code>viewModel.labelViewModel.subscribe(forward: labelView) { labelView, model in labelView.update(with: model) }
</code></pre>
<p>but using Combine.</p>
<p>So how can I return the observer with the observable?</p>
<p>In the ViewController I'm trying:</p>
<pre class=""lang-swift prettyprint-override""><code>viewModel.$labelModel.sink { lab in
    print(&quot;Value: \(lab?.1.text)&quot;)            
}.store(in: &amp;subscriptions)
</code></pre>
<p>with the label in the ViewModel:</p>
<pre class=""lang-swift prettyprint-override""><code>@Published private(set) var labelModel: (Label, Label.Model)?
</code></pre>
<p>but what I want to do is actually return the same label in the sink as is subscribing from the ViewController.</p>
<p>Is this possible?</p>
","1800285","","","","","2021-02-18 12:55:02","Forward object using Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66258759","1","66260701","","2021-02-18 11:09:17","","0","402","<p>I'm trying to communicate with CoreBluetooth using Combine, but my completion handler of a <code>PassthroughSubject</code> is not called. Below you can see a rough layout of the code. The <code>DetailViewModel</code> contains the bluetooth peripheral and the data to send.</p>
<pre class=""lang-swift prettyprint-override""><code>final class DetailViewModel: NSObject, ObservableObject, CBPeripheralDelegate {
    // Called when the correct write characteristic is found
    private var writeCharacteristicReceived = PassthroughSubject&lt;CBCharacteristic, Never&gt;()
    // Used to send and listen for peripheral data
    private var bluetoothDidChange = PassthroughSubject&lt;Data, Error&gt;()

    func open() -&gt; AnyPublisher&lt;Data, Error&gt; {
        writeCharacteristicReceived.tryMap { characteristic -&gt; AnyPublisher&lt;Data, Error&gt; in
            print(&quot;Write char&quot;, characteristic)

            let data: Data = try constructPayload()

            self.peripheral?.writeValue(data, for: characteristic, type: .withoutResponse)

            return self.bluetoothDidChange.eraseToAnyPublisher()
        }
        .switchToLatest()
        .eraseToAnyPublisher()
    }

    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
        print(&quot;Did update value&quot;, characteristic.value ?? Data())
        guard let value = characteristic.value, value.count &gt;= 84 else { return }

        defer {
            // Never called
            bluetoothDidChange.send(completion: .finished)
        }

        do {
            let message: Data = try parse(value)
            bluetoothDidChange.send(message)
            // Never called when placed here either
            // bluetoothDidChange.send(completion: .finished)
        } catch {
            bluetoothDidChange.send(completion: .failure(error))
        }
    }
}
</code></pre>
<p>I then listen for these changes in the view itself as follows</p>
<pre class=""lang-swift prettyprint-override""><code>viewModel.open().sink(receiveCompletion: { (completion) in
    print(&quot;Open completion: \(completion)&quot;)
}, receiveValue: { (payload) in
    print(&quot;Open payload \(payload)&quot;)
}).store(in: &amp;cancellable)
</code></pre>
<p>Now, this works fine for receiving values every now and then and the completion block is correctly called when an error occurs. But I never get the finished completion hander, not even when I specifically do <code>send(completion: .finished)</code>. Can anyone help me out?</p>
","5530076","","","","","2021-02-18 13:22:31","PassthroughSubject completion finished not called","<swift><swiftui><core-bluetooth><combine><publisher>","1","0","1","","","CC BY-SA 4.0"
"66263029","1","66752350","","2021-02-18 15:29:20","","3","413","<p>I have a SwiftUI app that fetches some information from the backend when the view appears and then attempts to update the State by setting <code>@Published</code> vars in an <code>ObservableObject</code>. The problem I have is it doesn't update at first fetch (it remains empty since it was initialized with an empty array) but if I click to another view and come back it's updated (since the information was already fetched).</p>
<p>Obviously, the intended thing I'm going for with using <code>@Published</code> is for the view to update once the information is fetched. This is part of a larger app but I have the reduced version of what I have below.</p>
<p>First, we have a parent view that contains the view I want to update.</p>
<pre><code>struct ParentView: View {
    
    var body: some View {
        NavigationView {
        ScrollView {
            VStack {
                SummaryView()
                // In real life I have various forms of summary
                // but to simplify here I will just use this one SummaryView.
                SummaryView()
                SummaryView()
            }
        }
        }
    }
}
</code></pre>
<p>Here is the summary view itself:</p>
<pre><code>struct SummaryView: View {
    
    @ObservedObject var model = AccountsSummaryViewModel()
    
    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Text(&quot;Accounts&quot;)
                    .font(.title)
                
                Spacer()
                
                NavigationLink(
                    destination: AccountView(),
                    label: {
                        Image(&quot;RightArrow&quot;)
                    })
                
            }
            
            if model.accounts.count &gt; 0 {
                Divider()
            }
            
            // And if I add the following line for debugging
            //Text(model.accounts.count)
            // It remains 0.

            ForEach(model.accounts, id: \.id) { account in
                Text(account.account.text)
            }
        }
        .padding()
        .onAppear() {
            model.onAppear()
        }
    }
}
</code></pre>
<p>Here is it's simple view model:</p>
<pre><code>class AccountsSummaryViewModel: ObservableObject, Identifiable {
    
    @Published var accounts: [AccountIdentifiable] = []
    
    func onAppear() {
        
        AccountsService.accounts { (success, error, response) in
            DispatchQueue.main.async {
                // This always succeeds
                if let response = response {
                    
                    // All AccountIdentifiable does is make a struct that is Identifiable (has an account and a var id = UUID())
                    self.accounts = Array(response.accounts.map { AccountIdentifiable(account: $0) }.prefix(3))
                }
            }
        }
        
    }
    
}
</code></pre>
<p>Here is the contents of the AccountsService also, I will note that the URL is a localhost but I'm not sure if that matters:</p>
<pre><code>public struct AccountsService {
    
    public static func accounts(completion: @escaping ((Bool, Error?, AccountsResponse?) -&gt; Void)) {
        guard let url = getAllAccountsURL() else {
            completion(false, nil, nil)
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = &quot;GET&quot;
        request.allHTTPHeaderFields = [&quot;Content-Type&quot;: &quot;application/json&quot;,
                                       BusinessConstants.SET_COOKIE : CredentialsObject.shared.jwt]

        let task = URLSession.shared.dataTask(with: request) { (data, urlResponse, error) in
            guard let data = data else {
                completion(false, error, nil)
                return
            }
            
            guard let response = try? JSONDecoder().decode(AccountsResponse.self, from: data) else {
                completion(false, error, nil)
                return
            }

            // This does successfully decode and return here. 
            completion(true, nil, response)
            
            return
        }

        task.resume()

    }
    
    private static func getAllAccountsURL() -&gt; URL? {
        let address = &quot;\(BusinessConstants.SERVER)/plaid/accounts&quot;

        return URL(string: address)
    }
    
}
</code></pre>
<p>I have read that there are issues with an empty <code>ScrollView</code>, however, my <code>ScrollView</code> is never empty as I have those static text elements. I also read that if you use a <code>ForEach</code> without the <em>id</em> it can fail - but you can see I am using the <em>id</em> so I'm kind of at a loss.</p>
<p>I have print statements in the <code>onAppear()</code> so I know it runs and successfully sets the <code>@Published accounts</code> but looking at the UI and putting breakpoints in the <code>ForEach</code> I can see the view does not update. However, if I navigate somewhere else in my app, and then come back to the <code>ParentView</code> then since the <code>@Published accounts</code> is non-empty (already fetched) it updates perfectly.</p>
","3853879","","3853879","","2021-02-18 15:59:07","2021-03-22 19:05:58","SwiftUI identifiable ForEach doesn't update when initially starting with empty","<swift><swiftui><combine>","2","4","","","","CC BY-SA 4.0"
"66266534","1","66268508","","2021-02-18 19:04:56","","2","616","<p>I have this general implementation for my api <code>.post</code> method:</p>
<pre><code>func post&lt;T: Decodable&gt;(endpoint: Endpoint, parameters: Parameters, responseType: T.Type) -&gt; AnyPublisher&lt;T, Error&gt; {
    sessionManager.request(self.baseUrl + endpoint.path, method: .post, parameters: parameters)
        .publishDecodable(type: responseType)
        .value()
        .mapError(ServiceError.init(error: ))
        .eraseToAnyPublisher()
}
</code></pre>
<p>It's working and I think it's how it supposed to be in SwiftUI/Combine. My problem is that I want to be able parse response when I get other status codes then 2xx. I fount <a href=""https://stackoverflow.com/a/64574546/367593"">this answer</a> and <a href=""https://charlesmuchene.com/custom-response-handler-in-alamofire-80267c3773a9"" rel=""nofollow noreferrer"">this article</a> about how to do it.</p>
<p>With that help I was able to change my code to this:</p>
<pre><code>func post&lt;T: Decodable&gt;(endpoint: Endpoint, parameters: Parameters, responseType: T.Type, completionHandler: @escaping (Result&lt;T, ErrorResponse&gt;) -&gt; Void) {
    sessionManager.upload(multipartFormData: multipartFormData, to: self.baseUrl + endpoint.path, method: .post, headers: headers)
        .validate(statusCode: 200..&lt;300)
        .responseTwoDecodable(of: responseType, completionHandler: completionHandler)
}
</code></pre>
<p>For more info here is my <code>TwoDecodableResponseSerializer</code> (created with help from that two links):</p>
<pre><code>final class TwoDecodableResponseSerializer&lt;T: Decodable&gt;: ResponseSerializer {
     
    lazy var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
        return decoder
    }()
    
    private lazy var successSerializer = DecodableResponseSerializer&lt;T&gt;(decoder: decoder)
    private lazy var errorSerializer = DecodableResponseSerializer&lt;ErrorResponse&gt;(decoder: decoder)
    
    public func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws -&gt; Result&lt;T, ErrorResponse&gt; {
        
        guard let response = response else { return .failure(ErrorResponse()) }
        
        do {
            if response.statusCode &lt; 200 || response.statusCode &gt;= 300 {
                let result = try errorSerializer.serialize(request: request, response: response, data: data, error: nil)
                return .failure(result)
            } else {
                let result = try successSerializer.serialize(request: request, response: response, data: data, error: nil)
                return .success(result)
            }
        } catch(let err) {
            return .failure(ErrorResponse())
        }
        
    }
}

extension DataRequest {
    @discardableResult func responseTwoDecodable&lt;T: Decodable&gt;(queue: DispatchQueue = DispatchQueue.global(qos: .userInitiated), of t: T.Type, completionHandler: @escaping (Result&lt;T, ErrorResponse&gt;) -&gt; Void) -&gt; Self {
        return response(queue: .main, responseSerializer: TwoDecodableResponseSerializer&lt;T&gt;()) { response in
            switch response.result {
            case .success(let result):
                completionHandler(result)
            case .failure(let error):
                completionHandler(.failure(ErrorResponse()))
            }
        }
    }
}
</code></pre>
<p>and ErrorResponse:</p>
<pre><code>class ErrorResponse: Error, Decodable {
    
    var error: Int = 0
    
    enum CodingKeys: String, CodingKey {
        case error = &quot;error&quot;
    }
    
}
</code></pre>
<p>and it's working. That's great but I would like to have more reactive/Combine code. Not with closure. Is it possible? How would you do this?</p>
<p>Thanks for any help</p>
","367593","","","","","2021-02-18 21:36:54","SwiftUI - Combine and Alamofire parse error Response","<swift><swiftui><alamofire><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"66271928","1","","","2021-02-19 04:47:20","","1","659","<p>I have a Swift Combine question. Let’s say I have an <code>ObservableObject</code> with a few properties like this:</p>
<pre><code>class AppState: ObservableObject{
  static let shared = AppState()
  @Published var a: Object?
  @Published var b: Object?
  @Published var c = [Object]()
}
</code></pre>
<p>I know I can be notified if a single object changes like this:</p>
<pre><code>myCancellable = AppState.shared.$a.sink { a in
  //Object 'a' changed
}
</code></pre>
<p>But is there a way to watch multiple properties and respond if any of them change?</p>
<p>Something like:</p>
<pre><code>myCancellable = AppState.shared.[$a, $b, $c].sink { a, b, c in
  //Objects 'a', 'b', or 'c' changed
}
</code></pre>
","1142348","","","","","2021-02-19 05:35:00","Be Notified of Multiple ObservableObject Property Changes in Combine","<swift><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"66279651","1","","","2021-02-19 14:41:41","","0","175","<p>I have a rather odd problem. All the code below does is post json to a url. I use the same code in other parts of the project. For some reason though, this specific code's DataTaskPublisher doesn't execute (as in: doesn't seem to do anything at all. It doesn't even throw an error message, none of the print's in the pipeline print). The last sign of life I get is from print(arr). However, if I very often press the button in the app which executes this code then eventually a single call <em>might</em> get through, so not very often. Other network code in the app always executes without any issues. Also, I know the url can be called because I keep testing with Postman. Does someone have any good ideas how to debug this? Any leads are much appreciated!</p>
<pre><code>import Foundation
import Combine
import FirebaseAuth

class HistoryViewModel: ObservableObject {
    
    @Published var items = [History]()
    
    private var publisher: AnyCancellable?
    

    func saveData(dataArr: [Bool]){
        
        let currentUser = Auth.auth().currentUser
        currentUser?.getIDTokenForcingRefresh(false, completion: { idToken, error in
            
            var json = History()
            
            var arr: [Int] = []
            for (index, value) in dataArr.enumerated() {
                if(value) { arr.append(index) }
            }
            
            json.user_id = currentUser?.uid ?? &quot;1&quot;
            json.dataArr = arr
            json.created_client = DateHelper().ISOString
            
            let encoder = JSONEncoder()
            let data = try! encoder.encode(json)
            
            let url = URL(string: &quot;XXXXXXXXXXXXXXXX&quot;)!
            var request = URLRequest(url: url)
            request.httpMethod = &quot;POST&quot;
            request.addValue(&quot;application/json; charset=utf-8&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
            request.setValue(&quot;Bearer &quot;+String(idToken!), forHTTPHeaderField: &quot;Authorization&quot;)
            request.httpBody = data
            
            print(arr)
            
            self.publisher = URLSession.shared.dataTaskPublisher(for: request)
                .tryCatch({ error -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), Error&gt; in
                    print(&quot;In the tryCatch&quot;)
                    throw error
                })
                //.receive(on: DispatchQueue.main)
                .sink(
                    receiveCompletion: { completion in
                        print(&quot;completion&quot;)
                        switch completion {
                        case .failure(let error):
                            print(&quot;SINKERRORPOST&quot;)
                            print(error)
                        case .finished:
                            print(&quot;SINKSUCCESSPOST&quot;)
                        }
                    },
                    receiveValue: { repo in
                        print(&quot;DONEPOST&quot;)
                    }
                )
               
            
        })
    }
}
</code></pre>
","1763259","","","","","2021-02-19 14:41:41","DataTaskPublisher is not executed","<swift><combine>","0","2","","","","CC BY-SA 4.0"
"66292925","1","","","2021-02-20 14:52:57","","0","171","<p>I'm working on a publisher for Swift/Combine</p>
<p>Given a stream of inputs, I want to record the max value.
If the next number is lower, take one from the last recorded max value and emit that.</p>
<pre><code>Input:  [1,2,3,4,5,2,3,3,1]
Output: [1,2,3,4,5,4,3,3,2]
</code></pre>
<p>I can do this easily with the following code, however, I really don't like the instance variable</p>
<pre><code>var lastMaxInstanceValue: Float = 0

publisher
.map { newValue
  if newValue &gt; lastMaxInstanceValue {
    lastMaxInstanceValue = newValue
  } else {
    lastMaxInstanceValue = max(0, lastMaxInstanceValue - 1)
  }
}
.assign(to: \.percentage, on: self)
.store(in: &amp;cancellables)
</code></pre>
<p>So I wrote a publisher/subscriber here which encapsulates the <code>map</code> part above:</p>
<p><a href=""https://github.com/nthState/FallingMaxPublisher"" rel=""nofollow noreferrer"">https://github.com/nthState/FallingMaxPublisher</a></p>
<p>With my publisher, the code turns into:</p>
<pre><code>publisher
.fallingMax()
.assign(to: \.percentage, on: self)
.store(in: &amp;cancellables)
</code></pre>
<p>My question is, is my GitHub publisher necessary? Can the value I want be calculated without having the extra variable?</p>
","174955","","","","","2021-02-20 17:41:38","Falling Max Swift Combine Publisher","<swift><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"66304103","1","66306256","","2021-02-21 15:48:26","","0","43","<p>I am trying to use a Picker to select a VideoFormat from Twilio's Video API via a ForEach loop. The loop is working– it lists all of the correctly formatted format strings.</p>
<p>Here's my view, <code>SettingsView</code>:</p>
<pre><code>import SwiftUI

struct SettingsView: View {
    
    @EnvironmentObject var twilioState: TwilioState
        
    var body: some View {
        Form {
            Section(header: Text(&quot;Stream&quot;)) {
                HStack {
                    Text(&quot;Device&quot;)
                    Spacer()
                    Text(&quot;\(twilioState.captureDevice?.localizedName ?? &quot;N/A&quot;)&quot;)
                }
</code></pre>
<p>This is where I run into trouble. I cannot seem to get the <code>Picker</code> to assign a value to my <code>selection</code>, <code>$twilioState.videoFormat</code>. I suspect it has something to do with <code>id</code> and <code>VideoFormat</code> not conforming to <code>Hashable</code>? I was considering changing the <code>selection</code> to an <code>Int</code> and using a range for <code>ForEach</code>, like <code>0..&lt;twilioState.videoFormats.count</code>.</p>
<pre><code>                Picker(&quot;Select a Format&quot;, selection: $twilioState.videoFormat) {
                    if let videoFormats = twilioState.videoFormats {
                        ForEach(videoFormats, id: \.self) {
                            Text(&quot;\(twilioState.getVideoFormatString(videoFormat: $0))&quot;)
                                .tag($0)
                        }
                    }
                }
                .disabled(twilioState.videoFormats == nil)
</code></pre>
<p>The rest is a listing of <code>twilioState.videoFormat</code> as I try to figure out how to successfully implement the <code>Picker</code>.</p>
<pre><code>                HStack {
                    Text(&quot;Format&quot;)
                    Spacer()
                    if let videoFormat = twilioState.videoFormat {
                        Text(&quot;\(twilioState.getVideoFormatString(videoFormat: videoFormat))&quot;)
                    } else {
                        Text(&quot;N/A&quot;)
                    }
                }
            }
        }
        .navigationBarTitle(&quot;Settings&quot;)
    }
}
</code></pre>
<p>And here's my state model, <code>TwilioState</code>:</p>
<pre><code>import Foundation
import TwilioVideo
import Combine


class TwilioState: ObservableObject {

    let twilioService = TwilioService()
    private var cancellables = Set&lt;AnyCancellable&gt;()
    var camera: CameraSource?
    
    @Published var videoFormat: VideoFormat?
    @Published var videoFormats: [VideoFormat]?
    @Published var captureDevice: AVCaptureDevice?
    @Published var twilioError: TwilioError?
        
    init() {
        
        twilioService.setCaptureDevice(captureDevice: self.captureDevice)
            .sink { completion in
                switch completion {
                case let .failure(twilioError):
                    return self.twilioError = twilioError
                case .finished:
                    return print(&quot;Capture device set&quot;)
                }
            } receiveValue: { captureDevice in
                self.captureDevice = captureDevice
            }
            .store(in: &amp;cancellables)

        twilioService.getVideoFormats(captureDevice: self.captureDevice!)
            .sink { completion in
                switch completion {
                case let .failure(twilioError):
                    return self.twilioError = twilioError
                case .finished: return print(&quot;Capture device formats set&quot;)
                }
            } receiveValue: { videoFormats in
                self.videoFormats = videoFormats
            }
            .store(in: &amp;cancellables)
    }
    
    func getVideoFormatString(videoFormat: VideoFormat) -&gt; String {
        return &quot;\(videoFormat.dimensions.width) x \(videoFormat.dimensions.height) @ \(videoFormat.frameRate)&quot;
    }
    
    deinit {
        // We are done with camera
        if let camera = self.camera {
            camera.stopCapture()
            self.camera = nil
        }
    }
}
</code></pre>
<p>In case it's helpful, this is the service function, <code>getVideoFormats()</code>, which is feeding values to <code>@Published videoFormats</code> in my model, <code>TwilioState</code>:</p>
<pre><code>    func getVideoFormats(captureDevice: AVCaptureDevice) -&gt; AnyPublisher&lt;[VideoFormat], TwilioError&gt; {
        return Just(captureDevice)
            .map { captureDevice -&gt; [VideoFormat] in
                return CameraSource.supportedFormats(captureDevice: captureDevice)
                    .compactMap { $0 as? VideoFormat }
            }
            .setFailureType(to: TwilioError.self)
            .eraseToAnyPublisher()
    }
</code></pre>
","15068510","","15068510","","2021-02-21 15:54:12","2021-02-21 19:30:01","How can I get Picker to return a VideoFormat var using a ForEach loop?","<foreach><swiftui><twilio><picker><combine>","1","0","","","","CC BY-SA 4.0"
"66306735","1","66310042","","2021-02-21 20:22:33","","1","437","<p>The point is that after successfully adding a record to the database (when I tap confirm button), the view should be closed. The problem is that it does not close after adding, <code>.onReceive</code> does not triggered, although the publisher <code>PassthroughSubject</code> sends a new value. There is one thing: the view will close if an alert was triggered before clicking the confirm button (for example, when not all fields are filled in, a warning is displayed)</p>
<p>Also properties <code>viewModel.name</code> and <code>viewModel.name</code> (for <code>TextField</code>'s) after adding a record become equal to empty strings, although I do not explicitly assign such a value to them anywhere in the code (as if a new instance of the view model is created where such default values are)</p>
<p><strong>View:</strong></p>
<pre><code>struct AddChallengeView: View {
    @Environment(\.presentationMode) var presentationMode
    @ObservedObject var viewModel = AddChallengeViewModel()
    
    
    var body: some View {
        Form{
            Section(header: Text(&quot;Name&quot;)){
                TextField(&quot;Type challenge name&quot;, text: $viewModel.name) //viewModel.name == &quot;&quot; after new record added
            }
            
            Section(header: Text(&quot;Description&quot;)){
                TextEditor(text: $viewModel.description) //viewModel.description == &quot;&quot; after new record added
            }
            //...
            
            Section{
                Button(action: { viewModel.addChallenge()}){
                    HStack{
                        Spacer()
                        Text(&quot;Submit&quot;).bold()
                        Spacer()
                    }
                }
            }
            
        }.alert(isPresented: $viewModel.showErrorAlert){
            Alert(title: Text(&quot;Please, set all values!&quot;))
        }
        .onReceive(viewModel.viewDismissalModePublisher) { shouldDismiss in
        print(&quot;new value received&quot;) //not printed 
        if shouldDismiss {
            self.presentationMode.wrappedValue.dismiss()
        }
    }
        
    }
}
</code></pre>
<p><strong>ViewModel:</strong></p>
<pre><code>class AddChallengeViewModel: ObservableObject{
    var viewDismissalModePublisher = PassthroughSubject&lt;Bool, Never&gt;()
    
    private var shouldDismissView = false {
        print(&quot;sending new value&quot;) //printed
        didSet {
            viewDismissalModePublisher.send(shouldDismissView)
        }
    }
    
    @Published var showErrorAlert = false

    @Published var name = &quot;&quot;
    @Published var description = &quot;&quot;

    //...
    
    func addChallenge () {
        //...
        
        if (name != &quot;&quot; &amp;&amp; description != &quot;&quot; &amp;&amp; grounds.count != 0){
            Firestore.firestore().collection(&quot;users&quot;).document(Auth.auth().currentUser!.uid).collection(&quot;challenges&quot;).addDocument(data: [
                &quot;name&quot;: &quot;\(name)&quot;,
                &quot;description&quot;: &quot;\(description)&quot;,
                &quot;grounds&quot;: grounds
            ]) { err in
                if let err = err {
                    print(&quot;Error adding document: \(err)&quot;)
                } else {
                    print(&quot;setting new value&quot;) //printed
                    self.shouldDismissView = true
                }
            }
        } else {
            showErrorAlert.toggle()
        }
    }
}
</code></pre>
<p><strong>UPDATE:</strong> I found a solution. We need to replace <code>@ObservedObject var viewModel = AddChallengeViewModel()</code> with <code>@StateObject var viewModel = AddChallengeViewModel()</code> in <code>AddChallengeView</code> but why does it work?</p>
","13696467","","13696467","","2021-02-21 21:30:40","2021-02-22 04:28:00","onReceive is not triggered after published value has changed","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66306859","1","66319796","","2021-02-21 20:34:04","","0","454","<p>I am trying to do some decoding of JSON I am receiving from a server. As this app is being written in SwiftUI I thought I may as well give Combine a go as well. I have been using .decode() as part of my combine chain which has been working well but now I need to decode json which won't work with this.</p>
<p>I am trying to decode JSON of a format into a <code>Team</code> struct. However the issue is that this is not guaranteed to exist on the server, in those cases, the server simply returns no JSON (it does however still have the correct HTTPS response code so I do know when this is the case). My question is how to decode the received data into an optional <code>Team?</code> (where it is either the decoded team data or nil if no JSON is received.</p>
<pre><code>struct Team: Codable, Identifiable, Hashable {
    var id: UUID
    var name: String
    var currentRating: Int

    enum CodingKeys: String, CodingKey {
        case id = &quot;id&quot;
        case name = &quot;name&quot;
        case currentRating = &quot;rating&quot;
    }
}
</code></pre>
<pre><code>func fetch&lt;T: Decodable&gt;(
        from endpoint: Endpoint,
        with decoder: JSONDecoder = JSONDecoder()
    ) -&gt; AnyPublisher&lt;T, DatabaseError&gt; {
        // Get the URL from the endpoint
        guard let url = endpoint.url else { ... }
        
        let request = URLRequest(url: url)
        
        // Get the publisher data from the server
        // retrieveData is a function with the return type AnyPublisher&lt;Data, DatabaseError&gt;
        return retrieveData(with: request)
            // Try to decode into a decodable object
            .decode(type: T.self, decoder: decoder)
            // If there is an error, map it to a DatabaseError
            .mapError { ... }
            // Main thread
            .receive(on: DispatchQueue.main)
            // Type erase
            .eraseToAnyPublisher()
    }
</code></pre>
","9682666","","","","","2021-02-22 16:43:02","Swift Combine version of decodeIfPresent?","<json><swift><codable><combine><decodable>","1","0","1","","","CC BY-SA 4.0"
"66315177","1","66358184","","2021-02-22 11:50:18","","0","418","<p>I'm trying to track an AVAudioPlayerNode's playback state via its Combine Publisher:</p>
<pre class=""lang-swift prettyprint-override""><code>import Cocoa
import AVFoundation
import Combine

@main
class AppDelegate: NSObject, NSApplicationDelegate {

    let engine = AVAudioEngine()
    let player = AVAudioPlayerNode()
    var cancellable: AnyCancellable?

    func applicationDidFinishLaunching(_ aNotification: Notification) {

        cancellable = player.publisher(for: \.isPlaying)
            .sink { newValue in
                print(&quot;is playing: \(newValue)&quot;)
            }

        let url = Bundle.main.url(forResource: &quot;blues&quot;, withExtension: &quot;aiff&quot;)!
        let file = try! AVAudioFile(forReading: url)

        let buffer = AVAudioPCMBuffer(pcmFormat: file.processingFormat, frameCapacity: UInt32(file.length))!
        try! file.read(into: buffer)

        engine.attach(player)
        engine.connect(player, to: engine.mainMixerNode, format: file.processingFormat)

        player.scheduleBuffer(buffer, at: nil, options: .loops, completionHandler: nil)

        try! engine.start()
        player.play()
    }
}
</code></pre>
<p>The sink gets called just once when it's initialised, and never again. I would expect it to get called when playback starts, but it doesn't... Any ideas why?</p>
","1072846","","","","","2021-02-24 20:11:01","Combine Publisher not firing for a KVO property","<ios><macos><combine><avaudioengine>","1","3","","","","CC BY-SA 4.0"
"66320320","1","66320913","","2021-02-22 17:15:56","","0","1903","<p>I would like to wait for data from all elements and combine them into one result:</p>
<pre><code>Item: AnyPublisher &lt;Int, Swift.Error&gt;
Array: AnyPublisher &lt;[Result&lt;Int, Swift.Error&gt;], Never&gt;
</code></pre>
<p>Can this be done somehow? I've tried using Zip and Merge - but I couldn't get the desired result.</p>
<p>Example:</p>
<pre><code>func createItem(num: Int) -&gt; AnyPublisher&lt;Int, Swift.Error&gt; {
    Just(num)
        .setFailureType(to: Swift.Error.self)
        .eraseToAnyPublisher()
}
func createItems(nums: [Int]) -&gt; AnyPublisher&lt;[Result&lt;Int, Swift.Error&gt;], Never&gt; {
    Publishers.MergeMany(nums.map { self.createItem(num: $0) } )
        .collect()
        .eraseToAnyPublisher()
}
</code></pre>
<p>Function but &quot;createItems&quot; does not work</p>
","10682199","","10682199","","2021-02-22 18:10:51","2021-02-22 19:20:03","Swift Combine Sink Array AnyPublisher","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"66325099","1","66325152","","2021-02-22 23:47:15","","1","534","<p>In this code I am expecting the <code>Empty()</code> publisher to send completion to the <code>.sink</code> subscriber, but no completion is sent.</p>
<pre><code>func testEmpty () {
    let x = XCTestExpectation()

    let subject = PassthroughSubject&lt;Int, Never&gt;()

    emptyOrSubjectPublisher(subject).sink(receiveCompletion: { completion in
        dump(completion)
    }, receiveValue: { value in
        dump(value)
    }).store(in: &amp;cancellables)

    subject.send(0)

    wait(for: [x], timeout: 10.0)
}

func emptyOrSubjectPublisher (_ subject: PassthroughSubject&lt;Int, Never&gt;) -&gt; AnyPublisher&lt;Int, Never&gt; {
    subject
        .flatMap { (i: Int) -&gt; AnyPublisher&lt;Int, Never&gt; in
            if i == 1 {
                return subject.eraseToAnyPublisher()
            } else {
                return Empty().eraseToAnyPublisher()
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>Why does the <code>emptyOrSubjectPublisher</code> not receive the completion?</p>
","4286164","","","","","2021-02-23 03:31:22","Empty() publisher does not send completion","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66331398","1","66334804","","2021-02-23 10:30:46","","2","2401","<p>I'm getting my way through Combine bit I don't seem to wrap my head around some trivial operations. I'm building a Combine based to do some HealthKit operations. Mainly I have two operations:</p>
<ol>
<li><code>func workouts(_ limit: Int) -&gt; AnyPublisher&lt;[HKWorkout], Error&gt;</code></li>
<li><code>func workoutDetails(_ workout: HKWorkout) -&gt; AnyPublisher&lt;WorkoutDetails, Error&gt;</code></li>
</ol>
<p>First off I will use the first one to query some workouts, that's easy.</p>
<pre class=""lang-swift prettyprint-override""><code>HKHealthStore().workouts(HKObjectQueryNoLimit)
    .sink(receiveCompletion: { subject in
        switch subject {
        
        case .finished:
            break
        case .failure(let error):
            dump(error)
        }
    }, receiveValue: { workouts in
        dump(workouts)
        // What now? 
    }).store(in: &amp;bag)  
</code></pre>
<p>Now I'd like to query the second function. It takes a workout as an argument and returns more information about the <code>HKWorkout</code>. How can I query the second function with the returned <code>[HKWorkout]</code> but don't know how to approach this.</p>
<ul>
<li>Should I do the query in a nested way in the sink part of the first method?</li>
<li>Is there a way to nest operations for each of the workout in the <code>[HKWorkout]</code> and call <code>workoutDetails(_ workout: HKWorkout)</code> for each one so I get as a result <code>[WorkoutDetails]</code>?</li>
</ul>
<p>What I have attempted so far it's not working.</p>
<pre class=""lang-swift prettyprint-override""><code>HKHealthStore().workouts(HKObjectQueryNoLimit)
    .map({ workouts -&gt; AnyPublisher&lt;[WorkoutDetails], Never&gt; in
        
        return workouts.publisher.flatMap({ workout in
            return Just(workout as! [WorkoutDetails]).eraseToAnyPublisher()
                .eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
        
    }).sink(receiveCompletion: { subs in
        switch subs {
        
        }
    }, receiveValue: { val in
        /// Cannot convert value of type 'AnyPublisher&lt;[WorkoutDetails], Never&gt;' to expected argument type 'Void'
        /// I am not able to get [WorkoutDetails] here as I'd like
        dump(val)
    })
    .store(in: &amp;bag)
</code></pre>
<hr />
<p>Edit: Solution I've finally used. There are two options that I've finally managed to make it work and understand it.</p>
<p>One is @New Dev's answer to finally receive in the <code>sink</code> the combined array and another one is to receive on the <code>sink</code> individual elements to save on an array.</p>
<pre class=""lang-swift prettyprint-override""><code>HKHealthStore().workouts(HKObjectQueryNoLimit)
    .flatMap({
        $0.publisher.eraseToAnyPublisher()
    }).flatMap({
        $0.workoutWithDetails
    }).sink(receiveCompletion: { comp in
        switch comp {

        case .finished:
            break
        case .failure(let er):
            dump(er)
        }
    }, receiveValue: { details in
        /// Add the individual `WorkoutDetails` elements to an array 
        results.append(details)
    }).store(in: &amp;SGHealthManager.bag)

</code></pre>
","4296481","","4296481","","2021-02-23 14:38:04","2021-02-23 14:45:55","Swift Combine transform an array of publishers","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"66332306","1","66333540","","2021-02-23 11:31:37","","1","168","<p>Let's say I have the following <code>PassthroughSubject</code>, somewhere in an <code>ObservableObject</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>@Published var errorOccured = PassthroughSubject&lt;(), Error&gt;()
</code></pre>
<p>I send an error to it with:</p>
<pre class=""lang-swift prettyprint-override""><code>self.errorOccured.send(completion: .failure(error))
</code></pre>
<p>How can I be notified in a <code>View</code> whenever an error occurs? I know that with <code>onReceive</code> I can be notified of values, but I am interested in errors.</p>
","6603599","","","","","2021-02-23 12:55:07","Observe errors in PassthroughSubject in SwiftUI","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66334051","1","","","2021-02-23 13:26:49","","0","1028","<p>I am trying to work around 401 error scenario where I want to catch the error, check if error is 401 and if it is,</p>
<ol>
<li>Refresh oAuth</li>
<li>Execute same API again.</li>
</ol>
<p>Currently, I am doing something like below:</p>
<pre><code>return urlSession.dataTaskPublisher(for: request)
    .tryMap(checkForAPIError)
    .tryCatch { (error) -&gt; AnyPublisher&lt;(data: serverData, response: URLResponse), URLError&gt; in
        self.fetchoAuthToken()
            .tryMap { (token) in
                // Saves token
            }
            .receive(on: RunLoop.main)
            .subscribe(on: DispatchQueue.main)
            .sink { (completion) in
                 // Completion handling here
            } receiveValue: { (value) in
                print(&quot;Received \(value)&quot;)
            }
            .store(in: &amp;self.subscription)

        return self.urlSession.dataTaskPublisher(for: request)
    }
    .tryMap(parseJson)
    .retry(3)
    .receive(on: RunLoop.main)
    .eraseToAnyPublisher()
</code></pre>
<p>The current problem for me is, while API <code>self.fetchoAuthToken()</code> is still in execution, block returns new request. Which then executes with old tokens.</p>
<p>I want for <code>self.fetchoAuthToken()</code> to execute synchronously so return can be done after it executes and new tokens can be used.</p>
<p>Any help would be appreciated.</p>
","3307233","","1974224","","2021-08-29 06:39:27","2021-08-29 06:39:27","Swift - Combine - Synchronous API execution inside .tryCatch","<ios><swift><combine>","2","0","1","","","CC BY-SA 4.0"
"66339422","1","66339700","","2021-02-23 18:59:59","","0","669","<p>I want to use the <code>@Published</code> property wrapper combined with <code>map</code>, but I get this compiler error:</p>
<blockquote>
<p>Cannot convert return expression of type 'Publishers.Map&lt;Published.Publisher, Bool&gt;' to return type 'Published.Publisher'</p>
</blockquote>
<pre><code>@Published private var aNumber: Int = 1

var theNumberIsZero2: Published&lt;Bool&gt;.Publisher {
   $aNumber.map { number -&gt; Bool in
      return number == 0
   }
}
</code></pre>
<p>I could just use a <code>CurrentValueSubject</code>, like below, but I lost some benefit because <code>theNumberIsZero</code> cannot be synchronously checked.</p>
<pre><code>private let currentValueNumber = CurrentValueSubject&lt;Int, Never&gt;(0)
    
var theNumberIsZero: AnyPublisher&lt;Bool, Never&gt; {
   currentValueNumber.map { number -&gt; Bool in
      return number == 0
    }
    .eraseToAnyPublisher()
}
    
</code></pre>
<p>How can I do this?</p>
","9718260","","9718260","","2021-02-23 19:08:35","2021-02-24 10:08:21","How do I use @Published and map?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"66349952","1","66355245","","2021-02-24 11:27:20","","1","891","<p>I'm trying to fetch some data with this helper file:
<a href=""https://gist.github.com/jbfbell/e011c5e4c3869584723d79927b7c4b68"" rel=""nofollow noreferrer"">https://gist.github.com/jbfbell/e011c5e4c3869584723d79927b7c4b68</a></p>
<p>Here's a snippet of the important code:</p>
<p><b>Class</b></p>
<pre><code>/// Base class for requests to the Alpha Vantage Stock Data API.  Intended to be subclasssed, but can
/// be used directly if library does not support a new api.
class AlphaVantageRequest : ApiRequest {

    private static let alphaApi = AlphaVantageRestApi()
    let method = &quot;GET&quot;
    let path = &quot;&quot;
    let queryStringParameters : Array&lt;URLQueryItem&gt;
    let api : RestApi = AlphaVantageRequest.alphaApi

    var responseJSON : [String : Any]? {
        didSet {
            if let results = responseJSON {
            print(results)
        }
    }
  }
}
</code></pre>
<p><b> Extension ApiRequest </b></p>
<pre><code>    /// Makes asynchronous call to fetch response from server, stores response on self
    ///
    /// - Returns: self to allow for chained method calls
    public func callApi() -&gt; ApiRequest {
        guard let apiRequest = createRequest() else {
            print(&quot;No Request to make&quot;)
            return self
        }
        let session = URLSession(configuration: URLSessionConfiguration.ephemeral)
        let dataTask = session.dataTask(with: apiRequest) {(data, response, error) in
            guard error == nil else {
            print(&quot;Error Reaching API, \(String(describing: apiRequest.url))&quot;)
            return
            }
            self.receiveResponse(data)
        }
        dataTask.resume()
        return self
    }
</code></pre>


My goal is to fetch the data from <b>responseJSON</b> after the data of the url request is loaded.
<p>My ViewModel currently looks like this:</p>
<pre><code>class CompanyViewModel: ObservableObject {
    
    var companyOverviewRequest: ApiRequest? {
        didSet {
            if let response = companyOverviewRequest?.responseJSON {
                print(response)
            }
        }
    }
    
    private var searchEndpoint: SearchEndpoint
    
    init(companyOverviewRequest: AlphaVantageRequest? = nil,
         searchEndpoint: SearchEndpoint) {
        
        self.companyOverviewRequest = CompanyOverviewRequest(symbol: searchEndpoint.symbol)
    }
    
    
    func fetchCompanyOverview() {
        
        guard let request = self.companyOverviewRequest?.callApi() else { return }
        self.companyOverviewRequest = request

    }
    
}
</code></pre>
<p>So in my ViewModel the didSet gets called once but not when it should store the data. The results of <strong>AlphaVantageRequest</strong> always prints out properly, but not in my ViewModel. How can I achieve to have the loaded data also in my ViewModel?</p>
","13618212","","13618212","","2021-02-25 07:40:19","2021-02-25 14:23:12","How does a view obtain data using a view model and Network API","<api><swiftui><protocols><viewmodel><combine>","1","2","","","","CC BY-SA 4.0"
"66361024","1","","","2021-02-25 01:05:31","","0","77","<p>I have a publisher that emits an object which contains a few params. In the object, one of the params (called optionId) distinctly identifies an option. I'd like to debounce instances of that emission. However, if a new optionId shows up, I'd like to start a new clock, and start a new debounce.</p>
<p>Consider a stream like this:</p>
<p>Time in seconds: optionID emitted at source | what <code>debounce(3 seconds)</code> gets me | what I need //<code>-</code> means no event emitted.</p>
<pre><code>00: 1 | - | -
01: 1 | - | -
02: - | - | -
03: - | - | -
04: - | 1 | 1
05: - | - | -
06: 3 | - | -
07: 1 | - | -
08: 3 | - | -
09: 1 | - | -
10: - | - | -
11: - | - | 3
12: - | 1 | 1
13: - | - | -
</code></pre>
","1269509","","1269509","","2021-02-25 04:23:12","2021-02-25 04:56:52","How to split a stream to multiple streams based on some ID then debounce them?","<swift><reactive-programming><combine>","1","1","","","","CC BY-SA 4.0"
"66370035","1","66372175","","2021-02-25 14:03:43","","0","106","<p>I have created an <code>AnyPublisher</code> for subscribing to Firestore documents and the Output type is a DocumentSnapshot.</p>
<p>I run it like this...</p>
<pre><code>firestoreSubscription.subscribe(MyHashable(), &quot;/user/1234567890&quot;)
    .compactMap { try? $0.data(as: UserDoc.self }
</code></pre>
<p>The return type of this is <code>&lt;UserDoc, Never&gt;</code> which I want to keep.</p>
<p>This worked but I thought it would be cool if I could use the <code>.decode</code> function on Publisher to make it a bit more Combiney.</p>
<p>So I created this...</p>
<pre><code>public struct FirestoreDecoder: TopLevelDecoder {
    public init() {}
    
    public typealias Input = DocumentSnapshot
    
    public func decode&lt;T&gt;(_ type: T.Type, from: DocumentSnapshot) throws -&gt; T where T : Decodable {
        try! from.data(as: type)!
    }
}
</code></pre>
<p>So now I try this...</p>
<pre><code>environment.firestoreSubscription.subscribe(userSubscriptionID, &quot;/user/\(state.userID)&quot;)
    .decode(type: UserDoc.self, decoder: FirestoreDecoder())
</code></pre>
<p>But... <code>TopLevelDecoder</code> throws rather than returning <code>nil</code>. I wonder, is it possible to throw away the throws and default back to my compact map solution that I had whilst using the <code>.decode</code> method?</p>
<p>Or... should I just keep using the <code>.compactMap</code>?</p>
<p>Also... will the <code>throw</code> on the <code>.decode</code> end the publisher?</p>
","421018","","","","","2021-02-25 16:09:23","Combine replace `.compactMap` with custom `.decode`","<swift><decode><combine><publisher>","2","0","","","","CC BY-SA 4.0"
"66374840","1","66383795","","2021-02-25 19:01:47","","1","83","<p>I have a VielModel in SwiftUI handling my person model. To be able to store draft persons in the editor in the View(s), I have two objects:</p>
<pre><code>@Published var person: Person
@Published var draftPerson: Person
</code></pre>
<p>In the UI, I am only changing the draftPersons until the user clicks on &quot;Save&quot;, which stores the draftPerson as the person. In the onAppear method of the editor, I reset the draftPerson to the person.</p>
<p>Now I want to disable the &quot;Save&quot; button of the Editor and therefor introduced a bool &quot;modified&quot; in the VM. Using a pipeline, I want to set the modified to true, if and as long as the draftPerson is not equal to person, by doing the following:</p>
<pre><code>    $draftPerson.map { draftPerson in
        return draftPerson != self.person
    }
    .assign(to: \.modified, on: self)
    .store(in: &amp;cancellables)
</code></pre>
<p>It looks like it is working on first glance, but if I change something in a textField, the value of modified is only set to true after the second change in the field. Vice versa, if I delete the typed values, it is only set back to false after I delete one more character as were originally there.</p>
<p>Question 1:
Is there another &quot;best practice&quot; to handle changes in draft objects and deactivating the &quot;Save&quot; button in SwiftUI?</p>
<p>Question 2:
Why is the pipeline &quot;one change behind&quot;?</p>
<p>Thanks a lot for your input.</p>
<p><strong>Edit</strong>: I created a separate part of the App focusing only on the pipeline and realized that it is indeed working as intended if I remove my other pipelines. I have to check now in detail. Nevertheless, I will stick with my first question:
Is there anything I can do better?</p>
<p>Please find the code <a href=""https://gist.github.com/brenner-tobias/0dcf340342e9142d8538458c5d945e9f"" rel=""nofollow noreferrer"">here on Github</a></p>
","14596897","","14596897","","2021-02-26 10:04:19","2021-02-26 10:08:36","Swift Combine Pipeline to compare draft model","<swift><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"66375767","1","66376399","","2021-02-25 20:08:24","","1","836","<p>I'd like not to use <code>saveButton.addTarget(:selector:event)</code> that's why
I try to use tap publisher from <em><strong><a href=""https://github.com/CombineCommunity/CombineCocoa"" rel=""nofollow noreferrer"">CombineCocoa</a></strong></em> framework like this</p>
<pre><code> saveButton.tapPublisher.sink {  _ in
        print(&quot;tap&quot;) // tap twice
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>and when I tap <code>saveButton</code> then 'tap' printed twice.</p>
<p>Also I try to use from <em><strong>Combine</strong></em> framework</p>
<pre><code>saveButton.publisher(for: .touchUpInside) 
</code></pre>
<p>but have the same result.</p>
<p>My code here</p>
<pre><code>class ArticleVC: UIViewController {
    let saveButton: UIButton = {
        let btn = UIButton()
        btn.setTitle(&quot;Save&quot;, for: .normal)
        return btn
    }()
    
    var subscriptions: Set&lt;AnyCancellable&gt; = []
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // add to view
        view.addSubview(saveButton)
        didTapSave()
        saveButton.snp.makeConstraints {
            $0.centerX.centerY.equalToSuperview()
        }
        
        didTapSave()
    }
    
    func didTapSave() {
//        saveButton.tapPublisher.sink(receiveValue: { _ in
//            print(&quot;tap&quot;)  // twice printed 'tap'
//        })
//        .store(in: &amp;subscriptions)
        /// OR
        saveButton.publisher(for: .touchUpInside).sink { _ in
            print(&quot;tap&quot;) // twice printed 'tap'
        }
        .store(in: &amp;subscriptions)
    }
}

</code></pre>
<p>What the reason for it?</p>
","11079607","","11079607","","2021-02-25 21:11:31","2021-02-25 21:17:28","Tap publisher execute twice in Combine","<swift><combine>","1","8","","","","CC BY-SA 4.0"
"66386532","1","","","2021-02-26 13:18:01","","2","410","<p>I am working on a Combine request which I want to either execute or queue to execute after a certain event. Below is the scenario -</p>
<ol>
<li>New request is generated.</li>
<li>Check if the app has an access token</li>
<li>If yes, execute the request</li>
<li>If no, fetch token, then execute the request</li>
</ol>
<p>Below is my API where every request will be triggered -</p>
<pre><code>public func fetchData&lt;T: Codable&gt;(to request: URLRequest) -&gt; AnyPublisher&lt;Result&lt;T&gt;, Error&gt; {
    
    if hasToken {
        return self.urlSession.dataTaskPublisher(for: request)
            .tryMap(self.parseJson)
            .receive(on: RunLoop.main)
            .subscribe(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
    else {
        // Store request somewhere
        // Get token
        // Execute stored request
    }
}
</code></pre>
<p>I would really appreciate it if anyone can suggest how I can proceed with the <strong>else part of my code.</strong></p>
","3307233","","","","","2021-04-16 16:46:47","Swift - Queueing Combine Requests","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"66402638","1","66404043","","2021-02-27 19:22:25","","0","163","<p>I've included stubbed code samples. I'm not sure how to get this presentation to work. My expectation is that when the sheet presentation closure is evaluated, <code>aDependency</code> should be non-nil. However, what is happening is that <code>aDependency</code> is being treated as nil, and <code>TheNextView</code> never gets put on screen.</p>
<p>How can I model this such that <code>TheNextView</code> is shown? What am I missing here?</p>
<pre><code>struct ADependency {}

struct AModel {
    func buildDependencyForNextExperience() -&gt; ADependency? {
        return ADependency()
    }
}

struct ATestView_PresentationOccursButNextViewNotShown: View {
    @State private var aDependency: ADependency?
    @State private var isPresenting = false
    @State private var wantsPresent = false {
        didSet {
            aDependency = model.buildDependencyForNextExperience()
            isPresenting = true
        }
    }
    private let model = AModel()
    
    var body: some View {
        Text(&quot;Tap to present&quot;)
            .onTapGesture {
                wantsPresent = true
            }
            .sheet(isPresented: $isPresenting, content: {
                if let dependency = aDependency {
                    // Never executed
                    TheNextView(aDependency: dependency)
                }
            })
    }
}

struct TheNextView: View {
    let aDependency: ADependency
    
    init(aDependency: ADependency) {
        self.aDependency = aDependency
    }
    
    var body: some View {
        Text(&quot;Next Screen&quot;)
    }
}
</code></pre>
","9718260","","","","","2021-02-27 22:29:08","How can I dynamically build a View for SwiftUI and present it?","<ios><swift><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"66407815","1","","","2021-02-28 09:57:12","","0","442","<p>I'm trying to create a protocol for something that must also conform to <code>ObservableObject</code>, which will live within another object <code>Services</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>protocol ThumbnailServiceProtocol: ObservableObject where ObjectWillChangePublisher == ObservableObjectPublisher {
    var processingThumbnails: [String] { get }
}

final class ThumbnailService: ThumbnailServiceProtocol {
    var processingThumbnails: [String] = []
}

struct Services {
    var thumbnailService: ThumbnailServiceProtocol
}

var services = Services(thumbnailService: ThumbnailService())

</code></pre>
<p>My problem comes when I try to swap out services to use a mock in my tests like this:</p>
<pre class=""lang-swift prettyprint-override""><code>final class MockThumbnailService: ThumbnailServiceProtocol {
    var processingThumbnails: [String] = []
}

services = Services(thumbnailService: MockThumbnailService()) /// Cannot convert value of type 'MockThumbnailService' to expected argument type 'ThumbnailServiceProtocol'
</code></pre>
<p>I think the problem is coming from the fact that <code>ObservableObject</code> is a protocol with an associated type (<code>associatedtype ObjectWillChangePublisher</code>) but I thought I'd 'filled in the hole' by specifying <code>where ObjectWillChangePublisher == ObservableObjectPublisher</code>.</p>
<p>Am I missing something please?</p>
<p>Edit: to clarify, <code>services</code> is a global object which I'd like to swap out with a new instance of <code>Services</code> containing mocks in my unit tests, which is why I've tried to make this work:</p>
<pre class=""lang-swift prettyprint-override""><code>var services = Services(thumbnailService: ThumbnailService())
services = Services(thumbnailService: MockThumbnailService()) /// Cannot convert value of type 'MockThumbnailService' to expected argument type 'ThumbnailServiceProtocol'
</code></pre>
","5954887","","5954887","","2021-02-28 13:19:55","2021-02-28 13:19:55","How to use a protocol with associated type with ObservableObject?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66415728","1","66416084","","2021-03-01 02:00:10","","0","852","<p>I'm trying to call several publishers in sequence and call the <code>completionBlock</code> when the last one is finished. All the return type of the publishers is <code>AnyPublisher&lt;Void, Error&gt;</code>. Compared to the solution below, can I do it with <code>.flatMap</code> or some other functions provided in <code>Publishers</code>?</p>
<pre><code>private var firstObserver: AnyCancellable?
private var secondObserver: AnyCancellable?

public func setup() {
    firstObserver = Manager.firstPublisher()
        .sink(receiveCompletion: {_ in}, receiveValue: {[weak self] _ in
            self?.secondObserver = Manager.secondPublisher()
                .sink(receiveCompletion: {_ in}, receiveValue: {[weak self] _ in
                    self?.completionBlock()
                }
        })
}
</code></pre>
","1682474","","","","","2021-03-01 03:07:37","Chaining Combine.Publisher and calling completion when finished","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"66416700","1","","","2021-03-01 04:35:44","","0","893","<p>I am writing a simple WKWebView extension that executes some Javascript and return the result as a Future.</p>
<pre><code>func runJSFuture(_ js: String) -&gt; Future&lt;Any?, Error&gt; {
    
    Future&lt;Any?, Error&gt; { promise in
        self.evaluateJavaScript(js) { (result: Any?, error: Error?) in
            
            if let errorUnwrapped = error {
                promise(.failure(errorUnwrapped))
                return
            }
                promise(.success(result))
        }
    }
}
</code></pre>
<p>However, sometimes(consistently at a particular JS, but not all the time, so I figured it's not a problem with the JS itself) I get a crash as follows. I've been debugging and researching for a while and I've checked for implicitly unwrapped vars, force unwrapping. I'm stll unable to find the cause. There is not much useful information on the stack trace as well.</p>
<p><a href=""https://i.stack.imgur.com/nZW8o.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/nZW8o.png"" alt=""crashing thread"" /></a></p>
<p><a href=""https://i.stack.imgur.com/D0NIg.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/D0NIg.png"" alt=""crash - inline"" /></a></p>
<p><a href=""https://i.stack.imgur.com/YI1RF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YI1RF.png"" alt=""crash info"" /></a></p>
<p>EDIT :</p>
<p>I've did some poking around converting the future to a PassthroughSubject and I have found where exactly the code in my question crashes. It'd comfort me if one could explain why/ how the crash happens and what I can do to avoid it or if this is a Combine bug.</p>
<pre><code>func runJSFuture(_ js: String) -&gt; AnyPublisher&lt;Any?, Error&gt; {
    
    let pts = PassthroughSubject&lt;Any?, Error&gt;()
    
    self.evaluateJavaScript(js) { (result, error) in
        
        if let errorUnwrapped = error {
            
            pts.send(completion: .failure(errorUnwrapped))
            return
        }
        
        pts.send(result)
        //pts.send(completion: .finished) // crashes here
    }
    
    return pts.eraseToAnyPublisher()
}
</code></pre>
<p>If I comment the line that crashes, the code works fine, but if I understand correctly, the pipeline would be open indefinitely? Any help would be extremely appreciated.</p>
","3970488","","3970488","","2021-03-02 01:44:43","2021-03-02 01:44:43","How can I debug a ""BUG IN CLIENT OF LIBPLATFORM: Trying to recursively lock an os_unfair_lock"" crash?","<ios><swift><wkwebview><combine>","0","1","","","","CC BY-SA 4.0"
"66433501","1","66435139","","2021-03-02 04:48:30","","0","533","<ol>
<li>I have an upstream <code>Publisher</code> emitting values. For example, a stream of hex colors.</li>
<li>Separately I have an <code>Operator</code> backed by a <code>Publisher</code> that takes in those values and outputs some derived about them that is one-to-one in the long-term, but requires information about the value before or after. For example, returning the difference between each hex color and the color before it. <strong>I can't modify this.</strong></li>
<li>I would like a simple way to return the two values together. E.g. a tuple <code>(color, differenceToPreviousColor)</code></li>
<li>I am using OpenCombine for backwards compatibility and it might be missing some operators. For example, it doesn't have <code>zip</code> (if that's what I would even need)</li>
</ol>
<p>Pseudocode:</p>
<pre class=""lang-swift prettyprint-override""><code>// Can't mess with this. Basically just returns the consecutive differences
extension Publisher {
    func colorDiff&lt;E&gt;() -&gt; AnyPublisher&lt;Color, E&gt; where Color == Output, E == Failure {
        return self
          .map({ ($0, $0) })
          .scan((Color.black(), Color.black()), {
            let (_, prev) = $0
            let (curr, _) = $1
            return (prev, curr)
          })
          .map({
            let (prev, curr) = $0
            return curr - prev
          })
          .eraseToAnyPublisher()
    }
}

let colorPublisher = ... // emits #333333; #444444; ...
</code></pre>
<p>What's the simplest way to do something like the below with OpenCombine (without using zip)?</p>
<pre class=""lang-swift prettyprint-override""><code>let _ = zip(colorPublisher, colorPublisher.colorDiff()).sink { (e) in } receiveValue: { (tuple) in
      debugPrint(tuple.description) // (#333333, #333333); (#444444, #111111); ...
    }
</code></pre>
","37685","","","","","2021-03-03 07:12:34","How can I cleanly split and recombine Swift Publisher values? (using OpenCombine)","<swift><combine>","2","3","","","","CC BY-SA 4.0"
"66436139","1","66436581","","2021-03-02 08:53:27","","2","730","<p>I'm combining two publishers:</p>
<pre><code>let timer = Timer.publish(every: 10, on: .current, in: .common).autoconnect()
let anotherPub: AnyPublisher&lt;Int, Never&gt; = ...

Publishers.CombineLatest(timer, anotherPub)
    .sink(receiveValue: (timer, val) in { 
      print(&quot;Hello!&quot;)
} )
</code></pre>
<p><strong>Unfortunately, sink is not called until both publishers emit at least one element.</strong></p>
<p>Is there any way to make the sink being called without waiting for all publishers?
So that if any publisher emits a value, sink is called with other values set to nil.</p>
","380014","","","","","2021-03-02 09:22:49","Swift Combine - combining publishers without waiting for all publishers to emit first element","<ios><swift><combine>","1","0","1","","","CC BY-SA 4.0"
"66484891","1","","","2021-03-05 00:12:19","","2","852","<p>Here is the simple playground code that shows the two subscriptions in reverse order. How can I modify code so it will always print out 555? Currently it prints randomly 0 or 555 since operations are async. Please bear in mind that it is a concept, not an actual problem to solve, so putting all into one sink will not be a solution. Thanks</p>
<pre><code>import Combine

class Foo {

    let subject = PassthroughSubject&lt;Void, Never&gt;()
    var myProperty = 0

    var bag = Set&lt;AnyCancellable&gt;()

    init() {
        subject
            .sink { _ in print(self.myProperty) }
            .store(in: &amp;bag)

        subject
            .map { _ in 555 }
            .assign(to: \.myProperty, on: self)
            .store(in: &amp;bag)

        subject.send()
    }
}

let testClass = Foo()
</code></pre>
","6942474","","6942474","","2021-03-05 10:55:30","2021-03-06 01:18:41","Swift Combine making serial sequence in order","<ios><swift><queue><combine>","1","4","0","","","CC BY-SA 4.0"
"66519416","1","66519511","","2021-03-07 17:34:15","","1","596","<p>I have a view model called <code>UserService</code>. Let's says that this stores all the user data and it's automatically updated when the data is changed in Firestore.</p>
<p>Then I have a View with a <code>TextField</code> called <code>phone</code>. This is used as an input to get the user phone number.</p>
<p>This view has a ViewModel also and this vm contains the <code>@Published var phone: String = &quot;&quot;</code> property which the TextField uses.</p>
<p><strong>The problem is that other than using this <code>TextField</code> to update the value I want it to also show the current value coming from <code>UserService</code>.</strong></p>
<p>I do not know how to pass this data from <code>UserService</code> to <code>TestViewModel</code>. If a put <code>UserService</code> inside <code>TestViewModel</code> the property wont be updated in real time since vm inside vm is not supported yet in SwiftUI. Right now i have ended up with two separate properties. the <code>phone</code> inside  <code>UserService</code> and the <code>phone</code> inside <code>TestViewModel</code>.</p>
<p>I thought of manually updating <code>phone</code> inside on init() (<code>TestViewModel</code>) but I'm not sure if thats the correct way to do it since I have a other properties other than <code>phone</code></p>
<p>How can I achieve smth like this?</p>
<pre><code>struct User: Identifiable, Codable {
    var phone: String
}


class UserService: ObservableObject {
    @Published var user: User?
}


struct TestView: View {
    @ObservedObject var testViewModel = TestViewModel()
    @EnvironmentObject var userService: UserService
    
    var body: some View {
        Form {
            Section(header: Text(&quot;PHONE NUMBER&quot;)) {
                TextField(&quot;Phone number&quot;, text: $testViewModel.phone)
            }
        }
    }
}


class TestViewModel: ObservableObject {
    @Published var phone: String = &quot;&quot;

    init() {
        prefillForm()
    }
    
    func prefillForm() {
      //
    }
    
}
</code></pre>
","2738166","","","","","2021-03-07 17:42:51","SwiftUI pre fill TextField from ViewModel","<ios><swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66538341","1","66542235","","2021-03-08 22:47:39","","1","153","<p>I'm looking to wrap AVPlayer's play and pause methods so that I may use ReCombine effects to dispatch actions from SwiftUI which will ultimate play and pause some audio.</p>
<pre><code>public extension AVPlayer {
    func timeControlPub() -&gt; AnyPublisher&lt;TimeControlStatus, Never&gt; {
        publisher(for: \.timeControlStatus).eraseToAnyPublisher()
        
    }
    
    func playPub() -&gt; AnyPublisher&lt;() -&gt; Void, Never&gt; {
        publisher(for: \.play).eraseToAnyPublisher()
    }
}
</code></pre>
<p>The above snippet shows the general idea of the playback API and errors with:</p>
<p><strong>Key path cannot refer to instance method 'play()'</strong></p>
<p>Ive also tried</p>
<pre><code>protocol PlaybackAPIManager {
    func playStream() -&gt; AnyPublisher&lt;()-&gt; Void, Never&gt;
}

extension AVPlayer: PlaybackAPIManager {
    func playStream() -&gt; AnyPublisher&lt;()-&gt; Void, Never&gt;{
        return AVPlayer.play
    }
}
</code></pre>
<p>But receive the error:</p>
<p><strong>Cannot convert return expression of type '(AVPlayer) -&gt; () -&gt; Void' to return type 'AnyPublisher&lt;() -&gt; Void, Never&gt;'</strong></p>
<pre><code>static let togglePlayPause = Effect(dispatch: false)  { (actions: AnyPublisher&lt;Action, Never&gt;) in
            actions.ofTypes(TogglePlay.self)
                .flatMap(playStremAPI)
                .print(&quot;Stream Played&quot;)
                .eraseToAnyPublisher()
        }
</code></pre>
<p>I am have trouble wrapping AVPlayer methods with AnyPublisher to appease ReCombine.</p>
","10106418","","10106418","","2021-03-09 00:39:12","2021-03-09 07:03:31","Is it possible to wrap AVPlayer Play and Pause with AnyPublisher","<swift><avfoundation><avplayer><combine>","1","0","1","","","CC BY-SA 4.0"
"66550628","1","","","2021-03-09 16:13:21","","0","198","<p>I've made an IOC container with Swinject to manage my dependency injection and I've tried to pair that with some property wrappers :</p>
<pre><code>@propertyWrapper
struct Inject&lt;T:ObservableObject&gt;{
    let wrappedValue: T = SwinjectContainer.resolve(ObjectType: T.self)
}
</code></pre>
<p>Next step is to use this property wrapper into my view ... but with another property wrapper <code>@StateObject</code>, but this goes wrong because my wrapped value does not match with <code>@StateObject</code>objectType, which needs to be an <code>ObservableObject</code>.</p>
<pre><code>struct MyView: View {
    
    @StateObject @Inject var VM:MyViewModel
    
    var body: some View {
        VStack{
            Text(&quot;\(VM.A ?? 23)&quot;)
            Button(action: {VM.B()}){
                Text(&quot;click&quot;)
            }
        }
        .onAppear{
            VM.appear()
        }
    }
}

</code></pre>
<p>Is it a good approach to manage my dependency injection, and is it possible ?</p>
","2114456","","","","","2021-03-18 00:30:20","Property wrapper into property wrapper","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"66558997","1","66559279","","2021-03-10 05:44:52","","0","214","<p>When I have a Binding in SwiftUI and I want to save whenever the binding changes I do (e.g. on a TextField)</p>
<pre><code>var myText: String { /* value is derived */ }
func save(_ text: String) { /* doing the save stuff */ }
TextFiel(text: .init(get: { myText }, set: { save($0) }) 
</code></pre>
<p>Doing this, <code>save()</code> gets called whenever the binding changes. In some cases this might not be ideal, e.g. when save() makes a server call or some expensive computations.  So what I'm looking for, is to get notified whenever the <strong>binding</strong> changes for the <em>last time</em>.
Maybe some kind of delayed observer that fires x seconds after the final change and get's invalidated if another change happens earlier than that threshold. Does Combine offer something like this?</p>
<p><strong>Disclaimer</strong>: This question is about bindings in general and not just about TextFields in particular. The Textfield is only a coding example , so <code>.onCommit</code> is not the solution I'm looking for ;)</p>
","1754221","","","","","2021-03-10 06:12:42","Capture the Very Last Change of a Binding in SwiftUI / Combine","<swift><swiftui><binding><onchange><combine>","1","0","1","","","CC BY-SA 4.0"
"66570066","1","","","2021-03-10 17:38:52","","0","571","<p>I have a potential use for Combine, but I am having a lot of trouble with the implementation details. The goal is to provide an Publisher that will do the following:</p>
<ol>
<li>Search for a cached value, and emit that value, or:</li>
<li>Refer the subscriber to an upstream publisher that will emit a value, storing it in the appropriate cache location</li>
</ol>
<p><strong>I understand that this could be done using existing operators, but I would like to learn how to make a custom <code>Operator</code>/<code>Publisher</code>/<code>Subscription</code> pattern, if possible.</strong></p>
<p>I'd like the usage to be similar to the following bit of pseduocode:</p>
<pre><code>URLSession.shared.dataTaskPublisher(for: url)
    .cache(with: { someSortOfCachingPolicy })
    .sink()
</code></pre>
<p>In order to implement this, I am guessing at what Apple does for things like <code>map</code> and <code>flatMap</code>.</p>
<p>I have created a <code>CachePublisher</code> to try to capture the Upstream <code>Publisher</code>:</p>
<pre><code>struct CachePublisher&lt;Upstream: Publisher&gt;: Publisher {
    typealias Output = Upstream.Output
    typealias Failure = Upstream.Failure
    
    var upstream: Upstream
    
    var getCache: ()-&gt;Output?
    var setCache: (Output)-&gt;Void
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input {
        let subscription = CachePublisherSubscription(subscriber: subscriber, upstream: upstream, getCache: getCache, setCache: setCache)
        subscriber.receive(subscription: subscription)
    }
    
    init(_ upstream: Upstream, getCache: @escaping ()-&gt;Output?, setCache: @escaping (Output)-&gt;Void) {
        self.upstream = upstream
        self.getCache = getCache
        self.setCache = setCache
    }
}
</code></pre>
<p>This is followed up with a <code>Subscription</code>:</p>
<pre><code>extension CachePublisher {
    class CachePublisherSubscription&lt;S: Subscriber&gt;: Subscription where S.Input == Upstream.Output, S.Failure == Upstream.Failure {
        var subscriber: S
        var upstream: Upstream
        
        var setCache: (Output)-&gt;Void
        var getCache: ()-&gt;Output?
        
        init(subscriber: S, upstream: Upstream, getCache: @escaping ()-&gt;Output?, setCache: @escaping (Output)-&gt;Void) {
            self.subscriber = subscriber
            self.upstream = upstream
            self.getCache = getCache
            self.setCache = setCache
        }
        
        func request(_ demand: Subscribers.Demand) {
            ///check the cache for a value that satisfies the type
            ///return a value from the upstream publisher if not
            if let output = self.getCache() {
                subscriber.receive(output)
            } else {
                //forward an upstream value?
                //how? an entire publisher/subscriber chain?
            }
            
        }
        
        func cancel() {
        }
    }
}
</code></pre>
<p>And finally, a function so you can pass the upstream publisher to the <code>CachePublisher</code></p>
<pre><code>extension Publisher {
    func cache() -&gt; CachePublisher&lt;Self&gt; {
        return CachePublisher(self, getCache: { nil }, setCache: { _ in })
    }
}
</code></pre>
<p>I have no idea what to put in the required methods, or how to pass the subscriber up the chain to the upstream publisher. Or how to capture values from the upstream publisher.</p>
<p>The idea that came into my head is that downstream subscribers sort of create a nesting doll type structure, but I just don't know how to connect them.</p>
","2499200","","","","","2021-03-11 15:14:16","How do I forward Publisher output to a downstream Subscriber through a custom operator?","<swift><operators><reactive-programming><combine>","2","0","","","","CC BY-SA 4.0"
"66579482","1","66580926","","2021-03-11 09:14:02","","1","2122","<p>I have a Combine publisher like this:</p>
<pre><code>enum RemoteError: Error {
    case networkError(Error)
    case parseError(Error)
    case emptyResponse
}

func getPublisher(url: URL) -&gt; AnyPublisher&lt;Entiy, RemoteError&gt; {
    return URLSession.shared
        .dataTaskPublisher(for: url)
        .map(\.data)
        .decode(type: RemoteResponse.self, decoder: decoder)
        .mapError { error -&gt; RemoteError in
            switch error {
            case is URLError:
                return .networkError(error)
            default:
                return .parseError(error)
            }
        }
        .map { response -&gt; Entiy in
            response.enitities.last
        }
        .eraseToAnyPublisher()
}

struct RemoteResponse: Codable {
    let enitities: [Entity]
    let numberOfEntries: Int
}

struct Entity {

}
</code></pre>
<p>By the above setting, the compiler complains because <code>response.enitities.last</code> can be nil. The question is can I replace nil with Empty publisher and if not can I replace it with error <code>emptyResponse</code> in Combine chain? The first option is preferable.</p>
","3477974","","","","","2022-08-02 21:39:08","Replace nil with Empty or Error in Combine","<swift><reactive-programming><combine>","3","0","","","","CC BY-SA 4.0"
"66588983","1","66594384","","2021-03-11 19:10:15","","0","247","<p>Is it possible to fire multiple requests which return a <code>Publisher</code> and be able to cancel them without <code>sink</code>?</p>
<p>I would like to combine the requests into a single cancellable reference or store each one if possible without <code>sink</code> (code below). Is this possible?</p>
<pre class=""lang-swift prettyprint-override""><code>func fetchDetails(for contract: String) -&gt; AnyPublisher&lt;String, Error&gt;
</code></pre>
<p>Fire Multiple requests and store</p>
<pre class=""lang-swift prettyprint-override""><code>  @State var cancellable: Set&lt;AnyCancellable&gt; = []

    let promises = items.map {
      self.fetchFeed.fetchDetails(for: $0.contract)
    }
    
    Publishers.MergeMany(promises)
      .sink(receiveCompletion: { _ in }, receiveValue: { _ in }) // ** is this required?
      .store(in: &amp;cancellable)
</code></pre>
","5222077","","5222077","","2021-03-12 02:33:59","2021-03-12 04:54:38","Swift Combine erase array of publishers into AnyCancellable","<swift><combine>","1","0","0","","","CC BY-SA 4.0"
"66608682","1","66610389","","2021-03-12 23:49:46","","1","321","<p>I am currently running into an issue that is confusing me. I am trying to create a user using Firebase for my app, which is a SwiftUI app. I have a <code>UserDataController</code> that holds onto a <code>@Published var profile: Profile?</code> variable.</p>
<p>What I am noticing is that after creating a <code>Profile</code> in Firebase I get the callback with the data and decode it into my model. I then set that decoded model on my published property. However, when I do that the SwiftUI view does not change like I expect it to.</p>
<p>I have tested this functionality before introducing Firebase with test data. When I set the published property with the test data I do see the SwiftUI views update accordingly. I see that happen even when I update the published property in a <code>DispatchQueue.main.asyncAfter</code> block to simulate a network request.</p>
<p>Am I doing something wrong that is not allowing SwiftUI to update?</p>
<p>Also note that I am using <a href=""https://github.com/hmlongco/Resolver"" rel=""nofollow noreferrer"">Resolver</a> for my <code>UserDataController</code> injection. The <code>@InjectedObject</code> grabs an <code>@ObservedObject</code> for use in SwiftUI views.</p>
<p>Here is my code:</p>
<p><strong>App.swift</strong></p>
<pre><code>import Resolver
import SwiftUI

@main
struct MyApp: App {

    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    @InjectedObject var userController: UserDataController

    init() {
          // This is the method that calls `DispatchQueue.main.asyncAfter` which causes the
          // view to update correctly.
//        userController.authenticate()
    }

    var body: some Scene {
        WindowGroup {
            // This is where SwiftUI should be updating to show the profile instead of 
            // the LandingView since we have been logged in.
            if let profile = userController.profile {
                ProfileView()
                    .environmentObject(ProfileViewModel(profile: profile))
            } else {
                // This is where the login form is
                LandingView()
            }
        }
    }
}
</code></pre>
<p><strong>UserDataController.swift</strong></p>
<pre><code>import Firebase
import FirebaseAuth
import FirebaseFirestoreSwift
import Foundation

// This AuthError also will not show as an alert when set from a completion block
enum AuthError: Error, Identifiable {

    var id: AuthError { self }

    case noUser
    case emailExists
    case couldNotSignOut
    case generic
}

final class UserDataController: ObservableObject {

    @Published var profile: Profile? {
        didSet {
            print(&quot;Profile: \(profile)&quot;)
        }
    }
    @Published var user: User?

    @Published var authError: AuthError?

    private lazy var db = Firestore.firestore()

    private var authStateListener: AuthStateDidChangeListenerHandle?
    private var profileListener: ListenerRegistration?

    // MARK: Auth

    func authenticate() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            self.profile = TestData.amyAlmond
        }
    }

    func login(email: String, password: String) {
        applyStateListener()

        Auth.auth().signIn(withEmail: email, password: password) { [weak self] result, error in
            if let error = error {
                self?.authError = .generic
            } else if let user = result?.user {
                self?.addSnapshotListener(for: user)
            } else {
                self?.authError = .noUser
            }
        }
    }

    func signUp(email: String, password: String, firstName: String, lastName: String) {
        applyStateListener()

        Auth.auth().createUser(withEmail: email, password: password) { [weak self] result, error in
            if let error = error {
                self?.authError = .generic
            } else if let user = result?.user {
                self?.addSnapshotListener(for: user)
                self?.createProfile(for: user, firstName: firstName, lastName: lastName)
            } else {
                self?.authError = .noUser
            }
        }
    }
}

// MARK: - Private

private extension UserDataController {

    func applyStateListener() {
        guard authStateListener == nil else { return }

        authStateListener = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            guard let self = self else { return }

            if let user = auth.currentUser {
                self.user = user
            } else {
                self.user = nil
                self.profile = nil

                self.profileListener?.remove()
                self.profileListener = nil

                if let stateListener = self.authStateListener {
                    Auth.auth().removeStateDidChangeListener(stateListener)
                    self.authStateListener = nil
                }
            }
        }
    }

    func addSnapshotListener(for user: User) {
        guard profileListener == nil else { return }

        profileListener = db.collection(&quot;profiles&quot;).document(user.uid).addSnapshotListener { [weak self] snapshot, error in
            guard let self = self else { return }
            guard let snapshot = snapshot else { return }

            do {
                // Setting the profile here does not change the SwiftUI view
                // These blocks happen on the main thread as well, so wrapping this
                // in a `DispatchQueue.main.async` does nothing.
                self.profile = try snapshot.data(as: Profile.self)
            } catch {
                print(&quot;Error Decoding Profile: \(error)&quot;)
            }
        }
    }

    func createProfile(for user: User, firstName: String, lastName: String) {
        let profile = Profile(uid: user.uid, firstName: firstName, lastName: lastName, farms: [], preferredFarmId: nil)

        do {
            try db.collection(&quot;profiles&quot;).document(user.uid).setData(from: profile)
        } catch {
            print(error)
        }
    }
}
</code></pre>
<p><strong>LandingView.swift</strong></p>
<pre><code>import Resolver
import SwiftUI

struct LandingView: View {

    @InjectedObject private var userController: UserDataController

    var body: some View {
        VStack(spacing: 10) {
            LightText(&quot;Title&quot;)
                .font(.largeTitle)

            Spacer()

            AuthenticationView()

            Spacer()
        }
        .frame(maxWidth: .infinity)
        .padding()
        .alert(item: $userController.authError) { error -&gt; Alert in
            Alert(title: Text(&quot;Oh Boy&quot;), message: Text(&quot;Something went wrong&quot;), dismissButton: .cancel())
        }
    }
}
</code></pre>
<p><strong>AuthenticationView.swift</strong></p>
<pre><code>import SwiftUI

struct AuthenticationView: View {

    @StateObject private var viewModel = AuthenticationViewModel()

    var body: some View {
        VStack {
            VStack {
                Group {
                    switch viewModel.mode {
                    case .login:
                        loginForm
                    case .signUp:
                        signUpForm
                    }
                }
                .textFieldStyle(RoundedBorderTextFieldStyle())
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .foregroundColor(Color.gray)
            )

            Button(action: viewModel.switchMode) {
                Text(viewModel.switchModeTitle)
            }
            .padding(.bottom, 10)

            Button(action: viewModel.submitAction) {
                Text(viewModel.submitButtonTitle)
            }
            .disabled(!viewModel.isValid)
        }
        .padding()
    }
}

private extension AuthenticationView {

    @ViewBuilder
    var loginForm: some View {
        TextField(&quot;Email Address&quot;, text: $viewModel.emailAddress)
        TextField(&quot;Password&quot;, text: $viewModel.password)
    }

    @ViewBuilder
    var signUpForm: some View {
        TextField(&quot;First Name&quot;, text: $viewModel.firstName)
        TextField(&quot;Last Name&quot;, text: $viewModel.lastName)
        TextField(&quot;Email Address&quot;, text: $viewModel.emailAddress)
        TextField(&quot;Password&quot;, text: $viewModel.password)
        TextField(&quot;Confirm Password&quot;, text: $viewModel.confirmPassword)
    }
}
</code></pre>
<p><strong>AuthenticationViewModel.swift</strong></p>
<pre><code>import Foundation
import Resolver

final class AuthenticationViewModel: ObservableObject {

    @Injected private var userController: UserDataController

    enum Mode {
        case login, signUp
    }

    @Published var firstName: String = &quot;&quot;
    @Published var lastName: String = &quot;&quot;
    @Published var emailAddress: String = &quot;&quot;
    @Published var password: String = &quot;&quot;
    @Published var confirmPassword: String = &quot;&quot;

    @Published var mode: Mode = .login
}

extension AuthenticationViewModel {

    var isValid: Bool {
        switch mode {
        case .login:
            return !emailAddress.isEmpty &amp;&amp; isPasswordValid
        case .signUp:
            return !firstName.isEmpty
                &amp;&amp; !lastName.isEmpty
                &amp;&amp; !emailAddress.isEmpty
                &amp;&amp; isPasswordValid
                &amp;&amp; !confirmPassword.isEmpty
                &amp;&amp; password == confirmPassword
        }
    }

    var submitButtonTitle: String {
        switch mode {
        case .login:
            return &quot;Login&quot;
        case .signUp:
            return &quot;Create Account&quot;
        }
    }

    var switchModeTitle: String {
        switch mode {
        case .login:
            return &quot;Create a New Account&quot;
        case .signUp:
            return &quot;Login&quot;
        }
    }

    func switchMode() {
        if mode == .login {
            mode = .signUp
        } else {
            mode = .login
        }
    }

    func submitAction() {
        switch mode {
        case .login:
            loginUser()
        case .signUp:
            createUser()
        }
    }
}

private extension AuthenticationViewModel {

    var isPasswordValid: Bool {
        !password.isEmpty &amp;&amp; password.count &gt; 8
    }

    func loginUser() {
        userController.login(email: emailAddress, password: password)
    }

    func createUser() {
        userController.signUp(email: emailAddress, password: password, firstName: firstName, lastName: lastName)
    }
}
</code></pre>
","2317492","","2317492","","2021-03-13 00:12:17","2021-03-13 05:24:41","Setting @Published var in Firebase Completion Block Not Updating SwiftUI View","<ios><swift><firebase><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66612944","1","66613030","","2021-03-13 11:30:40","","2","2181","<p>I had a setup using <code>@State</code> in my SwiftUI view and going all my operations in the View (loading API etc) however when attempting to restructure this away from using <code>@ViewBuilder</code> and <code>@State</code> and using a <code>@ObservedObject</code> ViewModel, I lost the ability to dynamically change my view based on the <code>@State</code> variables</p>
<p>My code is now</p>
<pre><code>    
    @ObservedObject private var contentViewModel: ContentViewModel
    
    init(viewModel: ContentViewModel) {
        self.contentViewModel = viewModel
    }
    
    var body: some View {
        if contentViewModel.isLoading {
            loadingView
        }
        else if contentViewModel.fetchError != nil {
            errorView
        }
        else if contentViewModel.movies.isEmpty {
            emptyListView
        } else {
            moviesList
        }
    }
</code></pre>
<p>However whenever these viewmodel properties change, the view doesn't update like it did when i used them in the class as <code>@State</code> properties...</p>
<p>ViewModel is as follows:</p>
<pre><code>final class ContentViewModel: ObservableObject {

    var movies: [Movie] = []
    var isLoading: Bool = false
    var fetchError: String?
    
    private let dataLoader: DataLoaderProtocol
    
    init(dataLoader: DataLoaderProtocol = DataLoader()) {
        self.dataLoader = dataLoader

        fetch()
    }

    func fetch() {
        isLoading = true
        dataLoader.loadMovies { [weak self] result, error in
            guard let self = `self` else { return }
            self.isLoading = false
            guard let result = result else {
                return print(&quot;api error fetching&quot;)
            }
            guard let error = result.errorMessage, error != &quot;&quot; else {
                return self.movies = result.items
            }
            return self.fetchError = error
        }
    }
</code></pre>
<p>How can i bind these 3 state deciding properties to View outcomes now they are abstracted away to a viewmodel?</p>
<p>Thanks</p>
","7321892","","4145420","","2022-07-20 13:06:46","2022-07-20 13:06:46","Updating SwiftUI View Based on ViewModel States?","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"66616334","1","66625395","","2021-03-13 17:14:29","","1","474","<p>I'm wondering if there is a way to chain <strong>array of publishers</strong> similar to how we chain publishers with regular <code>flatMap</code></p>
<p>Let's say I have three publishers: <strong>publisher1, publisher2, publisher3</strong> all of them <strong>have the same Output, Failure types</strong>. For example, each of them is <code>AnyPublisher&lt;String, Never&gt;</code> and emits a single String value. The only role of each publisher is to fetch its own value and emits previous value joined with its own.</p>
<p>I'm looking for same effect as from the following pseudo code:</p>
<pre><code>let pipe = publisher1(value: &quot;&quot;)
      .flatMap { publisher2(value: $0) }
      .flatMap { publisher3(value: $0) }
</code></pre>
<p>Execution flow:</p>
<blockquote>
<p>publisher1 (fetches &quot;A&quot;) -&gt; publisher2 (fetches &quot;B&quot;) -&gt; publisher3 (fetches &quot;C&quot;) -&gt; &quot;ABC&quot;</p>
</blockquote>
<p>I would like to reproduce the same flow for the array with unknown count of publishers <strong>n</strong> <code>([AnyPublisher&lt;String, Never&gt;])</code></p>
<blockquote>
<p>1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; n</p>
</blockquote>
<p>I'll appreciate any tips, thanks! :)</p>
","6857974","","6857974","","2021-03-14 11:14:38","2022-06-30 18:41:08","Chaining array of AnyPublishers","<swift><combine>","3","2","1","","","CC BY-SA 4.0"
"66619128","1","66620390","","2021-03-13 22:18:41","","0","157","<p>I have a property with a fixed type</p>
<pre><code>var statusPublisher: Published&lt;Status&gt;.Publisher
</code></pre>
<p>and some other statuses like <code>substatus1</code>, <code>substatus2</code></p>
<p>and I want it to combine values of other statuses like</p>
<pre><code>var statusPublisher: Published&lt;Status&gt;.Publisher {
    $substatus1.combineLatest($substatus2).map { s1, s2 -&gt; Status in ... }
}
</code></pre>
<p>but it says <code>Cannot convert return expression of type 'Publishers.CombineLatest&lt;Published&lt;Substatus1&gt;.Publisher, Published&lt;Substatus2&gt;.Publisher&gt;' to return type 'Published&lt;Status&gt;.Publisher'</code></p>
<p>I managed to workaround it with one extra</p>
<pre><code>var connectionStatusSubject = PassthroughSubject&lt;Status, Never&gt;()
</code></pre>
<p>that I put into</p>
<pre><code>var connectionStatusPublisher: AnyPublisher&lt;Status, Never&gt; {
    connectionStatusSubject.eraseToAnyPublisher()
}
</code></pre>
<p>with new <code>AnyPublisher</code> here, but it seems not so neat.</p>
<p>Is there any way to make it the right way?</p>
","1261347","","","","","2021-03-14 02:00:31","Deriving Publisher from different publishers in Combine","<ios><swift><xcode><combine>","1","1","","","","CC BY-SA 4.0"
"66621874","1","66627313","","2021-03-14 06:54:52","","0","832","<p>In the <code>init()</code> of my <code>ViewModel</code>, I have 2 subscribers.</p>
<ol>
<li>The first one subscribes to downloaded data within <code>DataProvider()</code> and updates <code>downloadedData</code> with the result. This makes an API call and usually takes a few seconds before publishing data.</li>
<li>The second one subscribes to <code>$savedData</code> and then updates the <code>filteredData</code> array only with data that is contained in the <code>savedData</code> <strong>AND</strong> the <code>downloadedData</code>.</li>
</ol>
<p>The problem is that the <code>downloadedData</code> takes time to download, while <code>savedData</code> is instant (it's actually in Core Data). After it downloads, I want to force an update to the second observer above (<code>$savedData</code>) to update the <code>filteredData</code> accordingly.</p>
<p><strong>Is there a way to manually force a publisher to publisher a value? On ObservedObjects, we can call <code>objectWillChange.send()</code> but is there something like that I can call on <code>$savedData</code>?</strong></p>
<p><em>Disclaimer: This is a super-simplified version of my app. Please do not include answers that change the hierarchy. I also realize that I can add another publisher on $allCoins to mimic the one on $savedData, but I'd rather just force an update to $savedData. Thanks!</em></p>
<pre class=""lang-swift prettyprint-override""><code>    import SwiftUI
    
    struct TestView: View {
        
        @StateObject var vm = ViewModel()
        
        
        var body: some View {
            VStack {
                ForEach(vm.filteredData, id: \.self) { user in
                    Text(user)
                }
            }
        }
    }
    
    struct TestView_Previews: PreviewProvider {
        static var previews: some View {
            TestView()
        }
    }
    
    import Combine
    
    class ViewModel: ObservableObject {
        
        @Published var downloadedData: [String] = []
        @Published var savedData: [String] = []
        @Published var filteredData: [String] = []
        var cancellables = Set&lt;AnyCancellable&gt;()
        @Published var provider = DataProvider()
    
        init() {
            // WHEN THIS GETS PUBLISHED...
            // CAN I FORCE A PUBLISH / UPDATE TO savedData?
            provider.$data
                .assign(to: \.downloadedData, on: self)
                // here?
                .store(in: &amp;cancellables)
            
            $savedData
                .map { (saved) -&gt; [String] in
                    return saved.map { (savedItem) -&gt; String in
                        return self.downloadedData.contains(savedItem) ? savedItem : &quot;NO&quot;
                    }
                }
                .assign(to: \.filteredData, on: self)
                .store(in: &amp;cancellables)
            
            getSavedData()
        }
        
        func getSavedData() {
            savedData = [&quot;ONE&quot;, &quot;TWO&quot;]
        }
        
    }
    
    class DataProvider: ObservableObject {
        
        @Published var data: [String] = []
        
        init() {
            getData()
        }
        
        func getData() {
            // simulating api call
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                self.data.append(contentsOf: [&quot;ONE&quot;, &quot;TWO&quot;])
            }
        }
    }

</code></pre>
","11279971","","11279971","","2021-03-14 18:12:30","2021-03-14 18:12:30","Force publisher to publish an update?","<swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"66628712","1","66629431","","2021-03-14 19:30:31","","0","67","<p>I'm trying to use SwiftUI in a project but beyond the very basic version of using @States and @Bindings that can be found in every tutorial, so I need some help on what I'm doing wrong here.</p>
<p>Environment Setup:
I have following files involved with this problem:</p>
<ul>
<li><strong>CustomTextField</strong>: It's a SwiftUI View that contains an internal TextField along with bunch of other things (According to the design)</li>
<li><strong>CustomTextFieldConfiguration</strong>: Contains the things that I need to configure on my custom textfield view</li>
<li><strong>RootView</strong>: It's a SwiftUI View that is using CustomTextField as one of it's subviews</li>
<li><strong>RootPresenter</strong>: This is where the UI Logic &amp; Presentation Logic goes (Between the view and business logic)</li>
<li><strong>RootPresentationModel</strong>: It's the viewModel through which the Presenter can modify view's state</li>
<li><strong>RootBuilder</strong>: It contains the builder class that uses the builder pattern to wire components together</li>
</ul>
<p><em><strong>The Problem</strong></em>:</p>
<ul>
<li>The textField value does not update in the <strong>textValue</strong> property of <strong>rootPresentationModel</strong></li>
</ul>
<p>Here are the implementations (Partially) as I have done and have no idea where I have gone wrong:</p>
<p><strong>CustomTextField</strong>:</p>
<pre><code>struct CustomTextField: View {
@Binding var config: CustomTextFieldConfiguration

var body: some View {
    ZStack {
        VStack {
            VStack {
                ZStack {
                    HStack {
                        TextField($config.placeHolder,
                                  value: $config.textValue,
                                  formatter: NumberFormatter(),
                                  onEditingChanged: {_ in },
                                  onCommit: {})
                            .frame(height: 52.0)
                            .padding(EdgeInsets(top:    0, leading:  16 + ($config.detailActionImage != nil ? 44 : 0),
                                                bottom: 0, trailing: 16 + ($config.contentAlignment == .center &amp;&amp; $config.detailActionImage != nil ? 44 : 0)))
                            .background($config.backgroundColor)
                            .cornerRadius($config.cornerRedius)
                            .font($config.font)
            ...
            ...
            ...
            ...
</code></pre>
<p><strong>CustomTextFieldConfiguration</strong>:</p>
<pre><code>struct CustomTextFieldConfiguration {
    @Binding var textValue: String
    ...
    ...
    ...
    ...
</code></pre>
<p><strong>RootView</strong>:</p>
<pre><code>struct RootView: View {
    @State var configuration: CustomTextFieldConfiguration
    var interactor: RootInteractorProtocol!
    @Environment(\.colorScheme) private var colorScheme
    
    var body: some View {
        HStack {
            Spacer(minLength: 40)
            VStack(alignment: .trailing) {
                CustomTextField(config: $configuration)
                Text(&quot;\(configuration.textValue)&quot;)
            }
            Spacer(minLength: 40)
        }
    }
}
</code></pre>
<p><strong>RootPresenter</strong>:</p>
<pre><code>class RootPresenter: BasePresenter {

    @ObservedObject var rootPresentationModel: RootPresentationModel

    init(presentationModel: RootPresentationModel) {
        rootPresentationModel = presentationModel
    }
    ...
    ...
    ...
</code></pre>
<p><strong>RootPresentationModel</strong>:</p>
<pre><code>class RootPresentationModel: ObservableObject {
    var textValue: String = &quot;&quot;  {
        didSet {
            print(textValue)
        }
    }
}
</code></pre>
<p><strong>RootBuilder</strong>:</p>
<pre><code>class RootBuilder: BaseBuilder {
    class func build() -&gt; (RootView, RootInteractor) {
        let interactor = RootInteractor()
        
        let presenter = RootPresenter(presentationModel: RootPresentationModel())
        let view: RootView = RootView(configuration: CustomTextFieldConfiguration.Presets.priceInput(textValue: presenter.$rootPresentationModel.textValue, placeholder: &quot;&quot;, description: &quot;&quot;), interactor: interactor)
        let router = RootRouter()
        
        interactor.presenter = presenter
        interactor.router = router
        
        return (view, interactor)
    }
}
</code></pre>
<p>(That Presets method doesn't do anything important, but just to make sure it will not raise an irrelevant question, here's the implementation):</p>
<pre><code>static func priceInput(textValue: Binding&lt;String&gt;, placeholder: String, description: String) -&gt; CustomTextFieldConfiguration {
      return CustomTextFieldConfiguration(textValue: textValue,
                                         placeHolder: placeholder,
                                         description: description,
                                         defaultDescription: description,
                                         textAlignment: .center,
                                         descriptionAlignment: .center,
                                         contentAlignment: .center,
                                         font: CustomFont.headline1))
}
</code></pre>
","1665870","","","","","2021-03-14 21:24:04","Placing SwiftUI Data Sources Somewhere Else","<swift><swiftui><binding><state><combine>","1","6","","","","CC BY-SA 4.0"
"66652554","1","66653169","","2021-03-16 09:39:19","","0","605","<p>Whenever usecase call any method from repository, it should return data saved in Core data first and start fetching data from remote server. Once repository receives data from remote server it should update in local db and emit new event with latest data.</p>
<p>How to do it using Swift Combine?</p>
<pre><code>Class UsersRepository {

  func fetchUsers() -&gt; AnyPublisher&lt;[Users], Error&gt; {
     1. Emit Users from local DB
     2. Emit Users received from remote server
   }
}
</code></pre>
","1453349","","1453349","","2022-07-19 10:49:56","2022-07-19 10:49:56","Swift Combine: Return local data first and then remote data","<swift><combine>","1","2","0","2021-03-17 23:32:34","","CC BY-SA 4.0"
"66657614","1","","","2021-03-16 14:48:57","","0","1030","<p>I'm trying to write a &quot;closure like&quot; combine observers.
Let's say I have MyClass</p>
<pre><code>class MyClass {
    @Published var value: Int = 0

    func doSomethingClosure(completion: (Int?) -&gt; Void) {
        value += 1
        completion(value)
    }

    func doSomethingCombine() {
        value += 1
    }
}
</code></pre>
<p>And I can access it using a simple function with closure</p>
<pre><code>let myClass = MyClass()
myClass.doSomethingClosure { (value) in
    print(value)
}
</code></pre>
<p>Now, I want to do the same using a combine @Published
So I will call</p>
<pre><code>var cancelSet: Set&lt;AnyCancellable&gt; = []
myClass.$value
    .sink { (value) in
    print(value)
}.store(in: &amp;cancelSet)
</code></pre>
<p>However, I want it to be triggered only once, so if I call</p>
<pre><code>for _ in 0..&lt;5 {
    myClass.doSomethingCombine()
}
</code></pre>
<p>I won't get 5 prints but only the first one.
One solution I've found for this is cancelling the subscriber inside the sink:</p>
<pre><code>myClass.$value
    .sink { (value) in
    print(value)
    **cancelSet.removeAll()**
}.store(in: &amp;cancelSet)
</code></pre>
<p>but I find it kinda &quot;not as intended&quot;.</p>
<p>Another solution is using the approach for back pressure, something like:</p>
<pre><code>class MySubscriber: Subscriber {
    typealias Input = Int
    typealias Failure = Never
    
    func receive(subscription: Subscription) {
        subscription.request(.max(1))
    }
    
    func receive(completion: Subscribers.Completion&lt;Never&gt;) {
        print(&quot;Subscription \(completion)&quot;)
    }
    
    func receive(_ input: Int) -&gt; Subscribers.Demand {
        print(&quot;Input:\(input)&quot;)
        return .none
    }
}
let mySubscriber = MySubscriber()
myClass.$value.subscribe(mySubscriber)
</code></pre>
<p>But I find it cumbersome and overkill for my usage.</p>
<p>Is there any way of implementing &quot;closure style&quot; in a clean way?</p>
<p>Thanks.</p>
","15236938","","","","","2021-03-16 15:00:35","Make sure subscribe (sink) happens only once","<swift><closures><publish-subscribe><combine><backpressure>","1","1","","","","CC BY-SA 4.0"
"66661277","1","","","2021-03-16 18:30:41","","0","68","<p>I am building my first app as I learn SwiftUI and the Combine framework, so I am sorry if this question regarding MVVM is somewhat basic, but I am really stuck right now.</p>
<p>I built a <code>SomeWebService</code> class that returns multiple publishers to consume different resources of a Web API that powers my app:</p>
<pre><code>class SomeWebService {
    func resourceA() -&gt; AnyPublisher&lt;ResponseA, SomeWebServiceError&gt; { ... }
    func resourceB() -&gt; AnyPublisher&lt;ResponseB, SomeWebServiceError&gt; { ... }
    // etc...
}
</code></pre>
<p>The responses are potentially large structs that I would like to fetch only once in a <code>ParentView</code> and then pass them in the most efficient way to child views that can use a combination of those resources to display processed data. I just don't know how to efficiently pass those resources to the children and initialise their view models with these resources.</p>
<p>I first created a <code>Fetcher</code>:</p>
<pre><code>class Fetcher: ObservableObject {
    @Published private(set) var resourceA: ResponseA? // Potentially large struct
    @Published private(set) var resourceB: ResponseB? // Potentially large struct
    // etc...
    
    private let webService = SomeWebService()
    
    private var cancellableA: AnyCancellable?
    private var cancellableB: AnyCancellable?
    // etc...
    
    func fetchA() {
        cancellableA = webService.resourceA()
            .sink(receiveCompletion: { result in
                switch result {
                case .failure(let error): print(error)
                case .finished: break
                }
            }, receiveValue: { [weak self] response in
                self?.resourceA = response
            })
    }
    func fetchB() { ... }
    // etc...
}
</code></pre>
<p>Then I wanted to use it in the <code>ParentView</code> to perform all network requests only once <code>onAppear</code>, or whenever the user wants to refresh the app:</p>
<pre><code>struct ParentView: View {
    @StateObject private var fetcher = Fetcher()
    
    var body: some View {
        VStack {
            ChildA() // view model needs a combination of resourceA, resourceB, etc
            ChildB() // view model needs another combination of resources
            // etc ...
        }
        .onAppear {
            fetcher.fetchA()
            fetcher.fetchB()
            // etc...
        }
    }
}
</code></pre>
<p>Right now each child view has its own view model where I fetch the combination of resources that that particular child view needs, so I am currently fetching and storing unnecessary copies of those resources.</p>
<ol>
<li>I would like to use the resources as parameters to the children view models, so that I can handle all the data processing logic inside each of those view models. Is this a bad ideia?</li>
<li>If I can go that route, how should I pass those potentially large responses to the children view models?</li>
</ol>
","9023378","","","","","2021-03-16 18:30:41","MVVM - Efficiently pass fetched data from network requests in parent view to child views using SwiftUI & Combine","<mvvm><swiftui><combine>","0","4","","","","CC BY-SA 4.0"
"66661396","1","","","2021-03-16 18:37:28","","1","71","<p>I have a SwiftUI login-view with 2 textfields for username, password and a login button. I am using MVVM design pattern, and want my viewModel to authenticate after the user clicks on Login-Button.</p>
<p>the implementation of the view is as following</p>
<pre class=""lang-swift prettyprint-override""><code>struct LoginView: View {
    
    @ObservedObject var viewModel = LoginViewModel()
    
    var body: some View {
        
        VStack(alignment: .leading) {
            
            TextField(&quot;Enter e-mail address&quot;, text: $viewModel.email)
            TextField(&quot;Enter password&quot;, text: $viewModel.password)
            
            Button(&quot;Login&quot;) {
                viewModel.login()
            }
        }
    }
}
</code></pre>
<p>and the viewModel</p>
<pre class=""lang-swift prettyprint-override""><code>class LoginViewModel: ObservableObject {
    
    @Published var email: String = &quot;&quot;
    @Published var password: String = &quot;&quot;
    
    var authenticate = PassthroughSubject&lt;User, Never&gt;()
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        authenticate.sink { user in
            Webservice().authenticate(username: user.username, passsword: user.password).sink { error in
                //
            } receiveValue: { token in
                //
            }.store(in: &amp;self.cancellables)
        }.store(in: &amp;cancellables)
    }
    
    func login() {
        authenticate.send(User(username: email, password: password))
    }
}
</code></pre>
<p>everything works fine, but the number of items in cancellables increases everytime the user clicks the login button. I suppose this shouldn't be like that. what's wrong here?</p>
","15147595","","968155","","2021-03-16 21:46:41","2021-03-17 09:46:28","is it normal that number of cancellable items is getting higher?","<swift><mvvm><combine>","2","1","","","","CC BY-SA 4.0"
"66679183","1","66682230","","2021-03-17 18:31:53","","0","333","<p>I have two lists of URLs that return some links to images.
The lists are passed into a future like</p>
<pre><code>static func loadRecentEpisodeImagesFuture(request: [URL]) -&gt; AnyPublisher&lt;[RecentEpisodeImages], Never&gt; {
        return Future { promise in
            print(request)
             networkAPI.recentEpisodeImages(url: request)
                .sink(receiveCompletion: { _ in },
                        receiveValue: { recentEpisodeImages in
                            promise(.success(recentEpisodeImages))
                        })
                .store(in: &amp;recentImagesSubscription)
        }
        .eraseToAnyPublisher()
    }
</code></pre>
<p>Which calls:</p>
<pre><code>    /// Get a list of image sizes associated with a featured episode .
    func featuredEpisodeImages(featuredUrl: [URL]) -&gt; AnyPublisher&lt;[FeaturedEpisodeImages], Error&gt; {
        let featuredEpisodesImages = featuredUrl.map { (featuredUrl) -&gt; AnyPublisher&lt;FeaturedEpisodeImages, Error&gt; in
        return URLSession.shared
            .dataTaskPublisher(for: featuredUrl)
            .map(\.data)
            .decode(type: FeaturedEpisodeImages.self, decoder: decoder)
            .receive(on: networkApiQueue)
            .catch { _ in Empty&lt;FeaturedEpisodeImages, Error&gt;() }
            .print(&quot;###Featured###&quot;)
            .eraseToAnyPublisher()
        }
        return Publishers.MergeMany(featuredEpisodesImages).collect().eraseToAnyPublisher()
    }
    /// Get a list of image sizes associated with a recent episode .
    func recentEpisodeImages(recentUrl: [URL]) -&gt; AnyPublisher&lt;[RecentEpisodeImages], Error&gt; {
        let recentEpisodesImages = recentUrl.map { (recentUrl) -&gt; AnyPublisher&lt;RecentEpisodeImages, Error&gt; in
        return URLSession.shared
            .dataTaskPublisher(for: recentUrl)
            .map(\.data)
            .decode(type: RecentEpisodeImages.self, decoder: decoder)
            .receive(on: networkApiQueue)
            .catch { _ in Empty&lt;RecentEpisodeImages, Error&gt;() }
            .print(&quot;###Recent###&quot;)
            .eraseToAnyPublisher()
        }
        return Publishers.MergeMany(recentEpisodesImages).collect().eraseToAnyPublisher()
    }
</code></pre>
<p>and is attached to the app state:</p>
<pre><code>/// Takes an action and returns a future mapped to another action.
     static func recentEpisodeImages(action: RequestRecentEpisodeImages) -&gt; AnyPublisher&lt;Action, Never&gt; {
        return loadRecentEpisodeImagesFuture(request: action.request)
             .receive(on: networkApiQueue)
             .map({ images in ResponseRecentEpisodeImages(response: images) })
             .replaceError(with: RequestFailed())
             .eraseToAnyPublisher()
     }
</code></pre>
<p>It seems that:</p>
<pre><code>return Publishers.MergeMany(recentEpisodes).collect().eraseToAnyPublisher()
</code></pre>
<p>doesn't give me a reliable downstream value as whichever response finishes last overwrites the earlier response.</p>
<p>I am able to log the responses of both series of requests. Both are processing the correct arrays and returning the proper json.</p>
<p>I would like something like:</p>
<pre class=""lang-swift prettyprint-override""><code>return recentEpisodeImages
</code></pre>
<p>but currently this gives me the error</p>
<blockquote>
<p>Cannot convert return expression of type '[AnyPublisher&lt;RecentEpisodeImages, Error&gt;]' to return type 'AnyPublisher&lt;[RecentEpisodeImages], Error&gt;'</p>
</blockquote>
<p>How can I collect the values of the inner publisher and return them as</p>
<pre class=""lang-swift prettyprint-override""><code>AnyPublisher&lt;[RecentEpisodeImages], Error&gt;
</code></pre>
","10106418","","10106418","","2021-03-17 20:52:42","2022-05-09 20:55:42","Swift Combine - Accessing separate lists of publishers","<swift><asynchronous><combine><urlsession>","1","4","1","","","CC BY-SA 4.0"
"66679964","1","","","2021-03-17 19:28:57","","0","437","<p>I built an iOS app with the SwiftUI framework.
I want to run a task for a long period of time depending on whether the user is running or not.
So I used the Combine framework to start and stop some processes related to running activity using a background thread with quality of service as .background.
However, I noticed that sometimes the process of starting and stop gets delayed or killed.
I'm okay with delaying the process but I'm not okay with it being killed.</p>
<p>I wonder how can I solve this?
Because if you use google maps and you hit start navigation for your location.
The process doesn't get killed.
So there must be a way to start the process on the background thread for a longer period of time. I just don't know-how.
Any Ideas?</p>
<pre><code>        self.activaity.$running
        .subscribe(on: self.BackgroundQueue)
        .receive(on: self.BackgroundQueue)
        .removeDuplicates(by: {$0 == $1})
        .sink(receiveValue: { [self] value in
                if value {
                        self.start()
                }
                else{
                        self.stop()
                }
        })
        .store(in: &amp;self.cancellables)   


func start() {
    self.persistMetaData()
    self.persist()
    self.sensorManager.startUpdates()
   }
        
</code></pre>
<p>Thanks</p>
","10409527","","10409527","","2021-03-17 20:00:39","2021-03-18 01:42:46","Background threading for longer tasks","<ios><swiftui><combine><background-thread>","1","27","","","","CC BY-SA 4.0"
"66689833","1","","","2021-03-18 11:06:09","","2","258","<p>In my app which is designed in MVVM-pattern I have a loginView. Login may fail if there is either a network or authentication problem. My goal is to catch errors and display the corresponding alerts. I defined and enum for alerts as follow:</p>
<pre><code>enum Alerts: Identifiable {
    var id: Int {
        return self.hashValue
    }

    case networkError
    case authenticationError
}
</code></pre>
<p>the implementation of the view is:</p>
<pre><code>struct LoginView: View {

    @ObservedObject var viewModel = LoginViewModel()

    var body: some View {
    
        VStack {
            TextField(&quot;Enter e-mail address&quot;, text: $viewModel.email)
            SecureField(&quot;Enter password&quot;, text: $viewModel.password)
        
            Button(&quot;Log In&quot;) {
                viewModel.login()
            }
        }.alert(item: $viewModel.errorAlert, content: { alert in
            switch alert {
            case .networkError:
                return Alert(title: Text(&quot;Error&quot;), message: Text(&quot;Check internet Connection&quot;), dismissButton: .default(Text(&quot;Ok&quot;)))
            case .authenticationError:
                return Alert(title: Text(&quot;Error&quot;), message: Text(&quot;Some error occured, please try again&quot;), dismissButton: .default(Text(&quot;Ok&quot;)))
            }
        })
     }
 }
</code></pre>
<p>and the viewModel is:</p>
<pre><code>class LoginViewModel: ObservableObject {

    @Published var email: String = &quot;&quot;
    @Published var password: String = &quot;&quot;

    @Published var errorAlert: Alerts? = nil
    @Published var token: Token? = nil

    var authentication = PassthroughSubject&lt;User, WebserviceError&gt;()

    var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
    
        authentication.map { Webservice().authenticate($0) }.switchToLatest().print().sink { error in
            self.errorAlert = Alerts.networkError
        } receiveValue: { token in
            self.token = token
        }.store(in: &amp;cancellables)

        token.map { KeychainWrapper.save(token: $0)}?.sink(receiveCompletion: { error in
            self.errorAlert = Alerts.authenticationError
        }, receiveValue: { _ in
            //
        }).store(in: &amp;cancellables)
    }

    func login() {
        authentication.send(User(username: email, password: password))
    }
}
</code></pre>
<p>implementation of the Webservice</p>
<pre><code>class Webservice {
    func authenticate(_ user: User) -&gt; AnyPublisher&lt;Token, WebserviceError&gt; {
        return Future&lt;Token, WebserviceError&gt; { promis in
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                if user.username.lowercased() == &quot;root&quot; &amp;&amp; user.password == &quot;1234&quot; {
                    promis(.success(Token(access: &quot;asdasda&quot;, refresh: &quot;sdfsdfsdf&quot;, exprationDate: Date().addingTimeInterval(120))))
                } else {
                    promis(.failure(.unknown))
                }
            }
        }.eraseToAnyPublisher()
    }
}
</code></pre>
<p>considering the following scenario:
user runs the app for the first time. in the first try she/he puts the wrong username/password.</p>
<p>what happens is that the user will be shown the equivalent alert and can click ok to dismiss it.
The problem is that from the 2nd time so on, after clicking the login button, nothing happen. looks like the  authentication.map { .... } in Viewmodel is cancelled forever. why is that so?</p>
","15147595","","","","","2021-03-18 14:02:50","subscription cancels when receiveCompletion with error","<ios><swift><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"66706403","1","66708496","","2021-03-19 10:26:26","","-1","1498","<p><strike>I'm attempting to use combine to chain two requests together. The code is pretty rough, but I need to call two api requests. One to get the schedule data than one for live data. I'm able to get the live data <em>(second request)</em> but how do I get the schedule data <em>(first request)</em>? I'm having a hard time understanding how to use combine to chain two requests together, this is my first need to use combine for a widget I'm working on. I'm still fresh to Swift, so my terminology may be lacking.</strike></p>
<p>My last code example wasn't correct and my question was unclear. I have two <code>publishers</code> and the <em>second one</em> depends on the <em>first one</em>. My understanding is still unclear on how to handle the data from my first <code>publisher</code> as well as in <code>.flatMap</code> for the second data. Does it need to be <code>ObservableObject</code> class and have <code>@Published</code> variables for the data? Do I use <code>.assign</code> or <code>.sink</code> to get data from my codable data <code>Schedule</code> and <code>Live</code>? Articles seem a bit too advance for myself as they create custom <code>extensions</code> and changing the API data to <code>nested types</code>.</p>
<p>New example code</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class DataGroup {
    // How to get data from Schedule and Live codable data, do I use a variable and .assign or .sink?
    // Where do I put the subscriber?
    
    func requestSchedule(_ teamID : Int) -&gt; AnyPublisher&lt;Schedule, Error&gt; {
        let url = URL(string: &quot;https://statsapi.web.nhl.com/api/v1/schedule?teamId=\(teamID)&quot;)!
        return URLSession
            .shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Schedule.self, decoder: JSONDecoder())
            .flatMap {self.fetchLiveFeed($0.dates.first?.games.first?.link ?? &quot;&quot;)}
            /*
            .flatMap {URLSession.shared.dataTaskPublisher(for: URL(string: $0.dates.first?.games.first?.link ?? &quot;&quot;)!)}
            */
            .eraseToAnyPublisher()
    }
    

    // Remove and put into flatMap URLSession.shared.dataTaskPublisher?
    func fetchLiveFeed(_ link: String) -&gt; AnyPublisher&lt;Live, Error&gt; {
        let url = URL(string: &quot;https://statsapi.web.nhl.com\(link)&quot;)!
        return URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Live.self, decoder: JSONDecoder())
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>OLD
<strike></p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class CombineData {
    var schedule: Schedule? // Get schedule data alongside live data
    var live: Live?
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    func fetchSchedule(_ teamID: Int, _ completion: @escaping (/* Schedule, */Live) -&gt; Void) {
        let url = URL(string: &quot;https://statsapi.web.nhl.com/api/v1/schedule?teamId=\(teamID)&quot;)!
        URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: Schedule.self, decoder: JSONDecoder())
            .flatMap { self.fetchLiveFeed($0.dates.first?.games.first?.link ?? &quot;&quot;) }
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { _ in }) { data in
                // How to get both schedule data and live data here?
                //self.schedule = ?
                self.live = data
                print(data)
                completion(self.schedule!, self.live!)
            }.store(in: &amp;cancellables)
    }

    func fetchLiveFeed(_ link: String) -&gt; AnyPublisher&lt;Live, Error&gt; {
        let url = URL(string: &quot;https://statsapi.web.nhl.com\(link)&quot;)!
        return URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Live.self, decoder: JSONDecoder())
            .eraseToAnyPublisher()
    }
}
</code></pre>
</strike>
","14601731","","14601731","","2021-03-21 09:48:19","2021-03-21 09:48:19","Swift combine chain requests","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"66708005","1","66708229","","2021-03-19 12:15:50","","-1","450","<p>I have question regarding how to pass data between two models.</p>
<pre><code>struct SettingsCell: View {
    @State var isOn: Bool

    var body: some View {
        Toggle(name, isOn: $isOn)
    }
}

class SettingsModel: ObservableObject {
    @Published var someValue: Bool = false
}

struct SettingsView: View {
    @ObservedObject var model = SettingsModel()

    var body: some View {
        List {
            SettingsCell(isOn: model.someValue)
        }
    }
}
</code></pre>
<p>So i want to pass isOn state from cell, to main model, and react there. Send requests for example.</p>
","2185412","","","","","2021-03-19 12:37:47","SwiftUI / Combine Pass data between two models","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"66708406","1","66708695","","2021-03-19 12:42:32","","0","148","<p>I try to reset a <code>TextField</code> value when a certain condition is met <code>(.count == 4)</code>, but it does not work, what am I missing?</p>
<pre><code>class ViewModel: ObservableObject {
    @Published var code = &quot;&quot;
    private var anyCancellable: AnyCancellable?
    init() {
        anyCancellable = $code.sink { (newVal) in
            if newVal.count == 4 {
                self.code = &quot;&quot;
            }
        }
    }
}
struct ContentView: View {
    
    @ObservedObject var viewModel = ViewModel()
    
    var body: some View {
        TextField(&quot;My code&quot;, text: $viewModel.code)
    }
}
</code></pre>
","10208552","","","","","2021-03-19 13:03:04","Reset TextField value using Combine and Swiftui","<ios><swiftui><combine>","2","0","0","","","CC BY-SA 4.0"
"66709950","1","66714610","","2021-03-19 14:23:17","","1","596","<p>Recently, I tried to use <a href=""https://github.com/freshOS/Networking"" rel=""nofollow noreferrer"">freshOS/Networking</a> swift package.</p>
<p>And I read the README file several times and I couldn't make it work with me. I'm trying to get a list of countries using public API services and here's what I did:</p>
<p><strong>Model</strong></p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Networking

struct CountryModel: Codable {
    let error: Bool
    let msg: String
    let data: [Country]
}

struct Country: Codable {
    let name: String
    let Iso3: String
}

extension Country: NetworkingJSONDecodable {}
extension CountryModel: NetworkingJSONDecodable {}

/* 
Output
{
     &quot;error&quot;:false,
     &quot;msg&quot;:&quot;countries and ISO codes retrieved&quot;,
     &quot;data&quot;:[
          {
               &quot;name&quot;:&quot;Afghanistan&quot;,
               &quot;Iso2&quot;:&quot;AF&quot;,
               &quot;Iso3&quot;:&quot;AFG&quot;
          }
     ]
}
*/
</code></pre>
<p><strong>View Controller</strong> + print(data) in <code>callAPI()</code> function does not print</p>
<pre class=""lang-swift prettyprint-override""><code>    override func viewDidLoad() {
        super.viewDidLoad()
        
        configureUI()
        callAPI()
        
    }

    fileprivate func configureUI() {
        title = &quot;Choose Country&quot;
        
        view.addSubview(tableView)
        tableView.delegate = self
        tableView.dataSource = self
        tableView.frame = view.bounds
    }

    fileprivate func callAPI() {
        let countriesService = CountriesApi()
        var cancellable = Set&lt;AnyCancellable&gt;()
        
        countriesService.countries().sink(receiveCompletion: { completion in
            switch completion {
            case .finished:
                print(&quot;finished&quot;) // not printing
                break
            case .failure(let error):
                print(error.localizedDescription)
            }
        }) { data in
            print(data) // not printing
            self.countriesData = data
        }.store(in: &amp;cancellable)
    }
</code></pre>
<p><strong>CountriesAPI()</strong></p>
<pre class=""lang-swift prettyprint-override""><code>struct CountriesApi: NetworkingService {
    
    let network = NetworkingClient(baseURL: &quot;https://countriesnow.space/api/v0.1&quot;)
    
    // Create
    func create(country c: Country) -&gt; AnyPublisher&lt;Country, Error&gt; {
        post(&quot;/countries/create&quot;, params: [&quot;name&quot; : c.name, &quot;Iso3&quot; : c.Iso3])
    }
    
    // Read
    func fetch(country c: Country) -&gt; AnyPublisher&lt;Country, Error&gt; {
        get(&quot;/countries/\(c.Iso3)&quot;)
    }
    
    // Update
    func update(country c: Country) -&gt; AnyPublisher&lt;Country, Error&gt; {
        put(&quot;/countries/\(c.Iso3)&quot;, params: [&quot;name&quot; : c.name, &quot;Iso3&quot; : c.Iso3])
    }
    
    // Delete
    func delete(country c: Country) -&gt; AnyPublisher&lt;Void, Error&gt; {
        delete(&quot;/countries/\(c.Iso3)&quot;)
    }
    
    func countries() -&gt; AnyPublisher&lt;[CountryModel], Error&gt; {
        get(&quot;/countries/iso&quot;)
    }
}
</code></pre>
<p>I hope someone can help with what I'm missing.</p>
","5564548","","5231607","","2021-04-03 17:34:12","2021-10-24 18:45:28","Swift - Combine subscription not being called","<swift><xcode><networking><combine><urlsession>","1","0","","","","CC BY-SA 4.0"
"66713123","1","66715459","","2021-03-19 17:42:10","","3","1833","<p>I am studying and trying out a few stuff with Combine to apply on my own and came into the following situation with this contrived example..</p>
<pre><code>let sequencePublisher = [70, 5, 17].publisher
var cancellables = [AnyCancellable]()

sequencePublisher
//    .spellOut()
    .flatMap { query -&gt; URLSession.DataTaskPublisher in
        return URLSession.shared.dataTaskPublisher(for: URL(string: &quot;http://localhost:3000?q=\(query)&quot;)!)
    }
    .compactMap { String(data: $0.data, encoding: .utf8) }
    .sink(receiveCompletion: { completion in
        switch completion {
        case .failure(let error):
            print(error.localizedDescription)
        default: print(&quot;finish&quot;)
        }
    }) { value in
        print(value)
    }
    .store(in: &amp;cancellables)
</code></pre>
<p>I have a sequence publisher that emits 3 Integers and I pass it through <code>flatMap</code> and send a Get request request to my local API that simply returns back the same value it got embedded in a string.</p>
<p>It all works fine, I get all 3 API responses in sink, as long as I don't uncomment the <code>spellOut()</code> custom operator, this operator is supposed to fail if the number is smaller than 6, here is what it does:</p>
<pre><code>enum ConversionError: LocalizedError {
    case lessThanSix(Int)
    var errorDescription: String? {
        switch self {
        case .lessThanSix(let n):
            return &quot;could not convert number -&gt; \(n)&quot;
        }
    }
}

extension Publisher where Output == Int {
    func spellOut() -&gt; Publishers.TryMap&lt;Self, String&gt; {
        tryMap { n -&gt; String in
            let formatter = NumberFormatter()
            formatter.numberStyle = .spellOut
            guard n &gt; 6, let spelledOut = formatter.string(from: n as NSNumber) else { throw ConversionError.lessThanSix(n) }
            return spelledOut
        }
    }
}
</code></pre>
<p>The code doesn't even compile if I add another <code>map</code> operator before flatMap it works, but with a tryMap it just says</p>
<blockquote>
<p>No exact matches in call to instance method 'flatMap'</p>
</blockquote>
<p>Is there any way of achieving this or why is it not allowed?</p>
<p>Thank you in advance for the answers</p>
","9819649","","11559619","","2021-03-19 18:42:52","2021-03-20 09:29:27","Why can't I use .flatMap() after .tryMap() in Swift Combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66716119","1","67853022","","2021-03-19 22:04:10","","3","338","<p>I have a Swift package which supports iOS 10, macOS 10.13, tvOS 10 and watchOS 2. I want this package to expose some SwiftUI functionality which could be used when the referencing module can import SwiftUI. For example, making my package type (<code>Persisted</code>) conform to the SwiftUI protocol <code>DynamicProperty</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>#if canImport(SwiftUI)
import SwiftUI

@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension Persisted: DynamicProperty { }

#endif
</code></pre>
<p>With the above in place, the project no longer builds when building for &quot;Any iOS Device (arm64)&quot; - I get the compiler error:</p>
<blockquote>
<p>Cannot find type 'DynamicProperty' in scope</p>
</blockquote>
<p>When I change the build target to any iPhone simulator, it builds OK. It also builds OK when building for &quot;Any Mac&quot;, &quot;Any tvOS Device&quot;, etc. What do I need to do to make the package build for Any iOS?</p>
","5513562","","5513562","","2021-03-20 18:45:33","2021-06-05 19:01:06","Cannot find SwiftUI or Combine types when building Swift package for ""Any iOS Device""","<ios><swift><swiftui><combine><swift-package-manager>","1","0","1","","","CC BY-SA 4.0"
"66720310","1","","","2021-03-20 10:06:30","","0","102","<p>I have several datataskpublisher, which performs requests to the server, from different application screens. How to make them run serial?</p>
<p><strong>Below will be a rough example</strong></p>
<p><em>This is a service that performs requests and additional logic.</em></p>
<pre><code>class Service {

   var cacheResult: Data?
   var cacnellable: AnyCancellable?
   static let shared = Service()


   func performPost() -&gt; AnyPublisher&lt;Data, URLError&gt; {
      let task = URLSession.shared.dataTaskPublisher(for: URL(string: &quot;postURL&quot;)!)
         .map { (data, _) in data}
         .multicast(subject: PassthroughSubject())

      cacnellable = task.eraseToAnyPublisher().sink(
         receiveCompletion: {_ in },
         receiveValue: { data in
            self.cacheResult = data
         })

      return task.autoconnect().eraseToAnyPublisher()
   }

   func performGet() -&gt; AnyPublisher&lt;Data, URLError&gt; {
      let task = URLSession.shared.dataTaskPublisher(for: URL(string: &quot;getURL&quot;)!)
         .map { (data, _) in data}
         .multicast(subject: PassthroughSubject())

      cacnellable = task.eraseToAnyPublisher().sink(
         receiveCompletion: {_ in },
         receiveValue: { data in
            self.cacheResult = data
         })

      return task.autoconnect().eraseToAnyPublisher()
   }

}
</code></pre>
<p><em>This is views</em></p>
<pre><code>final class GetVC: UIViewController {

   let service = Service.shared
   var cancellable: AnyCancellable?

   override func viewWillAppear(_ animated: Bool) {
      super.viewWillAppear(true)
      cancellable = service.performGet()
         .sink(receiveCompletion: {_ in},
               receiveValue: { data in
                  print(&quot;Present data&quot;)
               })
   }

}
</code></pre>
<pre><code>final class PostVC: UIViewController {

   let service = Service.shared
   var cancellable: AnyCancellable?

   lazy var button: UIButton = {
      let btn = UIButton(primaryAction: UIAction(handler: { _ in
         self.cancellable = self.service.performPost()
            .sink(receiveCompletion: {_ in },
                  receiveValue: { data in
                     print(&quot;Some logic&quot;)
                  })
      }))
      return btn
   }()
}
</code></pre>
<p><strong>I need that requests never went to the server in parallel</strong></p>
<p>If &quot;post task&quot; finished , &quot;get task&quot; start</p>
<p>Thank you!</p>
","4137436","","","","","2021-03-20 12:58:38","How to make serial queue for a few URLSession.DataTaskPublisher?","<multithreading><nsurlsession><combine><nsurlsessiondatatask>","1","0","","","","CC BY-SA 4.0"
"66733456","1","","","2021-03-21 14:21:42","","1","426","<p>I have been playing with Combine to understand how it works in more details and I create a custom  Publisher, Subscription and Subscriber.</p>
<p>Here's how it looks..</p>
<p>The emoji beamer publisher along with subscription:</p>
<pre><code>struct EmojiBeamerPublisher: Publisher {
    typealias Output = String
    typealias Failure = Error
    private let emojis: [String] = [&quot;👍&quot;,&quot;❤️&quot;,&quot;✅&quot;,&quot;🥰&quot;,&quot;😍&quot;,&quot;🚀&quot;,&quot;😅&quot;,&quot;🍑&quot;,&quot;🍞&quot;,&quot;🎅&quot;,&quot;❄️&quot;,&quot;🐻&quot;,&quot;👀&quot;,&quot;👄&quot;,&quot;🦷&quot;,&quot;✍️&quot;,&quot;🙏&quot;,&quot;👨‍💻&quot;,&quot;🐝&quot;,&quot;🐛&quot;,&quot;🦉&quot;,&quot;🦀&quot;,&quot;🐍&quot;,&quot;🐞&quot;,&quot;🧸&quot;]
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input {
        let subscription = EmojiBeamerSubscription(output: emojis, subscriber: subscriber)
        subscriber.receive(subscription: subscription)
    }
}

extension EmojiBeamerPublisher {
    private final class EmojiBeamerSubscription&lt;S: Subscriber&gt;: Subscription where S.Input == Output, S.Failure == Failure {
        var subscriber: S?
        let output: [String]
        init(output: [String], subscriber: S) {
            self.subscriber = subscriber
            self.output = output
        }
        
        func request(_ demand: Subscribers.Demand) {
            Swift.print(&quot;Demand: \(demand)&quot;) // Here I receive Unlimited demand
            var demand = demand
            Timer.scheduledTimer(withTimeInterval: 5, repeats: true) { [weak self] timer in
                guard let self = self else { return }
                guard demand &gt; 0, let subscriber = self.subscriber else {
                    timer.invalidate()
                    self.subscriber?.receive(completion: .finished)
                    self.cancel()
                    return
                }
                demand -= 1
                demand += subscriber.receive(self.output.randomElement()! + &quot; \(Date())&quot;)
            }
        }
        
        func cancel() {
            subscriber = nil
        }
    }
}
</code></pre>
<p>Here is my Custom subscriber:</p>
<pre><code>final class EmojiBeamerSubscriber&lt;Input, Failure: Error&gt;: Subscriber, Cancellable {
    var subscription: Subscription?
    let receiveValue: (Input) -&gt; Void
    
    init(receiveValue: @escaping (Input) -&gt; Void) {
        self.receiveValue = receiveValue
    }
    
    func receive(subscription: Subscription) {
        self.subscription = subscription
        subscription.request(.max(3)) // Here I send only 3 as max demand
    }
    
    func receive(_ input: Input) -&gt; Subscribers.Demand {
        receiveValue(input)
        return .none
    }
    
    func receive(completion: Subscribers.Completion&lt;Failure&gt;) {
        print(&quot;Will handle later:&quot;, completion)
    }
    
    func cancel() {
        self.subscription?.cancel()
        self.subscription = nil
    }
}

extension Publisher {
    func myCustomSink(receiveValueHandler: @escaping (Self.Output) -&gt; Void) -&gt; AnyCancellable {
        let myCustomSubscriber = EmojiBeamerSubscriber&lt;Self.Output, Self.Failure&gt;(receiveValue: receiveValueHandler)
        subscribe(myCustomSubscriber)
        return AnyCancellable(myCustomSubscriber)
    }
}
</code></pre>
<p>As you can see on my custom subscription I request with demand <code>.max(3)</code> if I don't use collect everything works fine, I get an emoji beamed every 5 second after 3 I got a <code>.finish</code> completion.</p>
<p>Works fine (and sends .max(3) demand):</p>
<pre><code>let emojiBeamer = EmojiBeamerPublisher()
var cancellables = Set&lt;AnyCancellable&gt;()

emojiBeamer
    .myCustomSink { value in Swift.print(&quot;Random Emoji:: \(value)&quot;) }
    .store(in: &amp;cancellables)
</code></pre>
<p>However if I simply add <code>.collect()</code> to catch all 3 results at once in an array it just requests with <code>.unlimited</code> demand on my subscription, resulting in a never ending subscription because my demand will never reach <code>zero</code>.</p>
<p>Never complete (and sends unlimited demand):</p>
<pre><code>let emojiBeamer = EmojiBeamerPublisher()
var cancellables = Set&lt;AnyCancellable&gt;()

emojiBeamer
    .collect()
    .myCustomSink { value in Swift.print(&quot;Random Emoji:: \(value)&quot;) }
    .store(in: &amp;cancellables)
</code></pre>
<p>Is there something wrong with my implementation? Or Did I misunderstood the purpose of <code>.collect()</code> operator?</p>
<p>Thank you in advance :)</p>
","9819649","","9819649","","2021-03-21 14:31:05","2021-03-21 16:10:34","Why .collect() operator in swift Combine always sends .unlimited demand regardless of the demand of upstream publisher?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66737960","1","66738971","","2021-03-21 21:53:58","","0","164","<p>I'm building a wrapper for a textField that is used to introduce quantities. I'm trying to build everything with Combine. One of the use cases consists in that if the stringValue sent by the text field has a letter, I filter the letters and reassign the new value to the same var, so the text field filters these values. There's also a code to change this value to an int so other components can read the int value. Here's the code:</p>
<pre><code>class QuantityPickerViewModel: ObservableObject {
    private var subscriptions: Set&lt;AnyCancellable&gt; = Set&lt;AnyCancellable&gt;()
    @Published var stringValue: String = &quot;&quot;
    @Published var value : Int? = nil
    
    init(initialValue: Int?) {
        $stringValue
            .removeDuplicates()
            .print(&quot;pre-filter&quot;)
            .map {
                $0.filter {$0.isNumber}
            }
            .print(&quot;post-filter&quot;)
            .map {
                Int($0)
            }
            .assign(to: \.value, on: self)
            .store(in: &amp;subscriptions)

        $value.map {
            $0 != nil ? String($0!): &quot;&quot;
        }
        .print(&quot;Value&quot;)
        .assign(to: \.stringValue, on:self)
        .store(in: &amp;subscriptions)
    
        value = initialValue
    }
}
</code></pre>
<p>I verify the behavior using tests, I'll just the test that fails:</p>
<pre><code>class QuantityPickerViewModelTest: AppTestCase {
    var model: QuantityPickerViewModel!
    override func setUpWithError() throws {
        super.setUp()
        model = QuantityPickerViewModel(initialValue: 10)
    }
    
    func test_changeStringValueWithLetters_filtersLettersAndChangesValue() {
        model.stringValue = &quot;30a&quot;
        
        XCTAssertEqual(model.value, 30)
        XCTAssertEqual(model.stringValue, &quot;30&quot;) // fails saying stringValue is still &quot;30a&quot;
    }
}
</code></pre>
<p>The output of the test is:</p>
<pre><code>Test Case '-[SourdoughMasterTests.QuantityPickerViewModelTest test_changeStringValueWithLetters_filtersLettersAndChangesValue]' started.
pre-filter: receive subscription: (RemoveDuplicates)
post-filter: receive subscription: (Print)
post-filter: request unlimited
pre-filter: request unlimited
pre-filter: receive value: ()
post-filter: receive value: ()
Value: receive subscription: (PublishedSubject)
Value: request unlimited
Value: receive value: ()
Value: receive value: (10)
pre-filter: receive value: (10)
post-filter: receive value: (10)
Value: receive value: (10)
pre-filter: receive value: (30a)
post-filter: receive value: (30)
Value: receive value: (30)
pre-filter: receive value: (30)
post-filter: receive value: (30)
Value: receive value: (30)
/Users/jpellat/workspace/SourdoughMaster/SourdoughMasterTests/QuantityPickerViewModelTest.swift:54: error: -[SourdoughMasterTests.QuantityPickerViewModelTest test_changeStringValueWithLetters_filtersLettersAndChangesValue] : XCTAssertEqual failed: (&quot;30a&quot;) is not equal to (&quot;30&quot;)
</code></pre>
<p>Does anyone know why the value has not been assigned? Thanks</p>
","1068536","","1068536","","2021-03-21 22:07:10","2021-03-22 11:53:07","Use publishers to filter numbers in a string field","<ios><swift><combine>","2","6","","","","CC BY-SA 4.0"
"66741745","1","66830608","","2021-03-22 07:20:49","","0","888","<p>I have created  a class to perform a network request and parse the data using <code>Combine</code>. I'm <strong>not</strong> entirely certain the code is <strong>correct</strong>, <em>but it's working as of now</em> <strong>(still learning the basics of Swift and basic networking tasks)</strong>. My Widget has the correct data and is works until the data becomes nil. Unsure how to check if the data from my first <code>publisher</code> in my SwiftUI <code>View</code> is nil, the data seems to be valid even when there's no games showing.</p>
<p>My SwiftUI View</p>
<pre class=""lang-swift prettyprint-override""><code>struct SimpleEntry: TimelineEntry {
    let date: Date
    public var model: CombineData?
    let configuration: ConfigurationIntent
}

struct Some_WidgetEntryView : View {
    var entry: Provider.Entry
    @Environment(\.widgetFamily) var widgetFamily
    
    var body: some View {
        VStack (spacing: 0){
            if entry.model?.schedule?.dates.first?.games == nil {
                Text(&quot;No games Scheduled&quot;)
            } else {
                Text(&quot;Game is scheduled&quot;)
            }
        }
    }
}
</code></pre>
<p>Combine</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import WidgetKit
import Combine

// MARK: - Combine Attempt
class CombineData {
    var schedule: Schedule?
    var live: Live?
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    func fetchSchedule(_ teamID: Int, _ completion: @escaping (Live) -&gt; Void) {
        let url = URL(string: &quot;https://statsapi.web.nhl.com/api/v1/schedule?teamId=\(teamID)&quot;)!
        let publisher = URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Schedule.self, decoder: JSONDecoder())
            //.catch { _ in Empty&lt;Schedule, Error&gt;() }
            //.replaceError(with: Schedule(dates: []))
        let publisher2 = publisher
            .flatMap {
                return self.fetchLiveFeed($0.dates.first?.games.first?.link ?? &quot;&quot;)
            }
        Publishers.Zip(publisher, publisher2)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: {_ in
            }, receiveValue: { schedule, live in
                self.schedule = schedule
                self.live = live
                completion(self.live!)
                WidgetCenter.shared.reloadTimelines(ofKind: &quot;NHL_Widget&quot;)
            }).store(in: &amp;cancellables)
    }

    func fetchLiveFeed(_ link: String) -&gt; AnyPublisher&lt;Live, Error /*Never if .catch error */&gt; {
        let url = URL(string: &quot;https://statsapi.web.nhl.com\(link)&quot;)!
        return URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: Live.self, decoder: JSONDecoder())
            //.catch { _ in Empty&lt;Live, Never&gt;() }
            .eraseToAnyPublisher()
    }
}
</code></pre>
","14601731","","","","","2021-03-27 11:06:51","SwiftUI combine nil data","<swiftui><combine><widgetkit>","2","8","","","","CC BY-SA 4.0"
"66741936","1","","","2021-03-22 07:37:40","","0","215","<p>Using Swift5.3.2, iOS14.4.1, XCode12.4,</p>
<p>I am showing a modal sheet in SwiftUI.</p>
<p>Unfortunately, the sheet completely freezes whenever an underlying parent-View re-renders/updates.</p>
<p>I am absolutely clueless on how I can circumvent that issue. Any ideas ?</p>
<p>Here is the parent View:</p>
<pre><code>import SwiftUI

struct ParentTrialView: View {
    
    @State var currentDate = Date()
    @State private var showingGrid = false
    let timer = Timer.publish(every: 10, on: .main, in: .common).autoconnect()
        
    var body: some View {
        
        NavigationView {
            Text(&quot;\(currentDate)&quot;)
                .onReceive(timer) { input in
                    currentDate = input
                }
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button(action: {
                            showingGrid.toggle()
                        }) {
                            Image(systemName: &quot;square.grid.3x3&quot;)
                        }
                        .sheet(isPresented: $showingGrid) {                            
                            ChildTrialView(onDismiss: {
                                showingGrid = false
                            })
                        }
                    }
                }
        }
    }
}
</code></pre>
<p>And here is the child View:</p>
<pre><code>import SwiftUI

struct ChildTrialView: View {
    
    var onDismiss: () -&gt; ()
    
    var body: some View {
        
        NavigationView {
            Text(&quot;Trial&quot;)
                .onTapGesture {                    
                    onDismiss()
                }
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button(action: {
                            onDismiss()
                        }) {
                            Text(&quot;Cancel&quot;)
                        }
                    }
                }
        }
        
    }
}
</code></pre>
<p>If you, for example, set the timer to 20 seconds. Then you have 20 seconds where everything works on the child View (i.e. it's tap-Gesture works, and also its Cancel button to close the child-View works perfectly).</p>
<p>However, when the timer fires an update to the parent-View, then no action works on the child-View anymore !!</p>
<p>I am more than desperate with this SwiftUI problem.</p>
<p>Any solution on this ?</p>
","3826232","","3826232","","2021-03-22 20:44:29","2021-03-22 20:44:29","Sheet freeze in SwiftUI when parent-View gets updated","<swiftui><binding><combine><modal-sheet>","0","7","","","","CC BY-SA 4.0"
"66747996","1","","","2021-03-22 14:25:16","","2","503","<p>Hey I learned on an HackingWithSwift Tutorial How to make a chained network request with Combine (see code below). Now I will build the same logic with RXSwift but I don't know how can I get/subscribe like in Combine to get the end result.</p>
<p>Combine:</p>
<pre><code>//Combine code
func fetch&lt;T: Decodable&gt;(_ url: URL, defaultValue: T) -&gt; AnyPublisher&lt;T, Never&gt; {
       let decoder = JSONDecoder()
       decoder.dateDecodingStrategy = .iso8601

       return URLSession.shared.dataTaskPublisher(for: url)
           .retry(1)
           .map(\.data)
           .decode(type: T.self, decoder: decoder)
           .replaceError(with: defaultValue)
           .receive(on: DispatchQueue.main)
           .eraseToAnyPublisher()
   }

//call fetch method and get the end result 
fetch(url, defaultValue: [URL]())
        .flatMap { urls in
           urls.publisher.flatMap { url in
              fetch(url, defaultValue: [NewsItem]())
           }
        }
        .collect()
        .sink { values in
            let allItems = values.joined()
            items = allItems.sorted { $0.id &gt; $1.id }
        }
        .store(in: &amp;requests)



//RXSwift code
func fetchWithRX&lt;T: Decodable&gt;(_ url: URL, defaultValue: T) -&gt; Observable&lt;T&gt; {
       let decoder        = JSONDecoder()
       decoder.dateDecodingStrategy = .iso8601
       let request        = URLRequest(url: url)
       
       return URLSession.shared.rx.response(request: request)
           .retry(1)
           .map(\.data)
           .decode(type: T.self, decoder: decoder)
           .debug()
           .catchAndReturn(defaultValue)
           .observe(on: MainScheduler.instance)
   }


//call fetch2 method 
Now I want to subscribe to the values like in the first fetch method with flatMap..collect..sink etc.

fetchWithRX(url, defaultValue:  [URL]()) 

</code></pre>
","9094724","","","","","2021-03-24 11:19:21","Chained Network Request RXSwift","<swift><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"66754330","1","66754778","","2021-03-22 21:51:31","","0","122","<p>I'm trying to merges two published object from query of two different collections to make a single published array using <code>combineLatest</code>.</p>
<pre><code>import Combine
import Firebase

class FirestoreViewModel: ObservableObject {
    let userId: String
    
    @Published var aList: [DocumentA]? = nil
    @Published var bList: [DocumentB]? = nil
    
    init(userId: String, listenForChanges: Bool = false)    {
        
        // Get the user
        if (listenForChanges)   {
            self.loadA()
            self.loadB()
        }
    }
    
    var cList: AnyPublisher&lt;[DocumentC]?, Never&gt; {
        return Publishers.CombineLatest(
            $aList.map { (aList) -&gt; [DocumentC]?  in
                guard let aList = aList else { return nil }
                return aList.map {a in
                    DocumentC(from: a)
                }
            },
            $bList.map { (bList) -&gt; [DocumentC]?  in
                guard let bList = bList else { return nil }
                return bList.map { n in
                    DocumentC(from: b)
                }
            })
            .map { (aList, bList) -&gt; [DocumentC]?  in
                
                if (aList == nil &amp;&amp; bList == nil) { return nil }
                
                var cList: [DocumentC] = []
                
                if let aList = aList {
                    cList.append(contentsOf: aList)
                }
                
                if let bList = bList {
                    cList.append(contentsOf: bList)
                }
                return cList
            }
            .eraseToAnyPublisher()
    }
    
    private func loadA() {
        
        // Start listening
        Firestore.firestore().collection(&quot;colA&quot;).addSnapshotListener { (snapshot, error) in
            if let error = error {
                print(&quot;DEBUG: Unable to get user data: \(error.localizedDescription)&quot;)
                return
            }
            
            // Invalid data return
            guard let snapshot = snapshot else {
                print(&quot;DEBUG: null data returned&quot;)
                self.aList = nil
                return
            }
            
            // Update the info
            var aList: [DocumentA] = []
            snapshot.documents.forEach { document in
                let aData = document.data()
                guard !aData.isEmpty else {
                    return
                }
                aList.append(DocumentA(from: aData)
                
            }
            self.aList = aList
        }
    }
    
    private func loadB() {
        
        // Start listening
        Firestore.firestore().collection(&quot;colB&quot;).addSnapshotListener { (snapshot, error) in
            if let error = error {
                print(&quot;DEBUG: Unable to get user data: \(error.localizedDescription)&quot;)
                return
            }
            
            // Invalid data return
            guard let snapshot = snapshot else {
                print(&quot;DEBUG: null data returned&quot;)
                self.bList = nil
                return
            }
            
            // Update the info
            var bList: [DocumentB] = []
            snapshot.documents.forEach { document in
                let bData = document.data()
                guard !bData.isEmpty else {
                    return
                }
                bList.append(DocumentB(from: bData))
                
            }
            self.userUnits = userUnits
        }
    }
}
</code></pre>
<p>When I debug, I can see that <code>aList</code> and <code>bList</code> are published once, however, the <code>cList</code> keeps been published eventually eating all the memory...</p>
<p>The <code>cList</code> is consumed via a onReceive statement in the view, which output each item.</p>
<p>Would anybody be able to tell me why the <code>combineLatest</code> keeps on publishing <code>cList</code>, though there are no fresh <code>aList</code> or <code>bList</code> published ?</p>
<p>Many thanks in advance.</p>
","2405639","","968155","","2021-03-22 22:06:24","2021-03-22 22:36:57","Swiftui + Firestore + CombineLatest keep publishing data","<swift><google-cloud-firestore><combine><combinelatest>","1","1","","","","CC BY-SA 4.0"
"66768077","1","","","2021-03-23 17:18:08","","0","210","<p>I am trying to query an endpoint that includes HTTPS and Self Signed Certificate.  How would I implement the code below to include a certificate using Combine in Swift.</p>
<pre><code>struct API {
    
    func getJSON() -&gt; AnyPublisher&lt;ResultList, Error&gt; {
        let url = URL(string:urlString)!
        return URLSession.shared.dataTaskPublisher(for: url)
            .map({$0.data})
            .decode(type: ResultList.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>For example without using Combine I normally do the following:</p>
<pre><code>class SessionDelegate: NSObject, URLSessionDelegate {
    
    public func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) {
        
        if challenge.protectionSpace.host == myCert {
            completion(.useCredential, URLCredential(trust: challenge.protectionSpace.serverTrust!))
        } else {
            completion(.performDefaultHandling, nil)
        }
    }
}
</code></pre>
","13602468","","968155","","2021-03-23 17:18:45","2022-01-28 15:45:58","Self Signed Certificate Swift Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"66795201","1","","","2021-03-25 07:50:54","","0","111","<p>I am building a Combine pipeline which monitors for the immediate child in a Firebase node and use a passthrough subject to convert the observer to a publisher to dispatch observers based on the changed child's key. However, I need to combine the observers for childAdded and childRemoved into a single observer. What I tried is to use two separate observers for each, but then the initial snapshot gets called twice.</p>
<pre><code>    let childAddedHandle = userDatabaseRef!
        .observe(DataEventType.childAdded) { snapshot in
            self.memberPS.send(snapshot) // memberPS is a passthrough subject and I use it downstream to dispatch observers
        }
    let childRemovedHandle = userDatabaseRef!
        .observe(DataEventType.childRemoved) { snapshot in
            self.memberPS.send(snapshot)
        }
</code></pre>
<p>I have read the documentation on observing events in list of data in the firebase documentation, but there is no explanation in there on how to combine two events. There might be a simple solution to this, but I'm stuck on this for some time and any help would be appreciated.</p>
","3970488","","","","","2021-03-25 07:50:54","How can I combine two event observers (childAdded and childRemoved) in Firebase realtime DB?","<ios><swift><firebase><firebase-realtime-database><combine>","0","3","","","","CC BY-SA 4.0"
"66832641","1","66972872","","2021-03-27 14:51:22","","0","410","<p>I have a <code>Show</code> <code>CoreData</code> <code>NSManagedObject</code> with multiple <code>Seasons</code>. Both models can be marked as <code>watched</code>. When all seasons of a <code>Show</code> are marked as watched the <code>Show</code> should be marked watched as well. How do I achieve this? I tried using manual getter and setter for my <code>NSManagedObject</code> classes but I can't get my view to update when the state changes.</p>
<p>The GUI:
<a href=""https://i.stack.imgur.com/STKEJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/STKEJ.png"" alt=""enter image description here"" /></a></p>
<p>My code of the main View:</p>
<pre><code>// ShowDetailView.swift

@ObservedObject var show: Show

// ... in the body

Button(action: {
    show.isWatched.toggle()
}, label: {
    HStack {
        Image(systemName: show.isWatched ? &quot;checkmark.rectangle.fill&quot; : &quot;checkmark.rectangle&quot;)
    }
})

ScrollView(.horizontal) {
    LazyHStack {
        ForEach(seasons) { season in
            NavigationLink(destination: SeasonDetailView(season: season)) {
                SeasonListItemView(season: season)
                    .environment(\.managedObjectContext, viewContext)
            }
        }
    }
}
</code></pre>
<p>The class for the list item:</p>
<pre><code>// SeasonListItemView.swift

@ObservedObject var season: Season

Button(action: {
    season.isWatched.toggle()
}, label: {
    HStack {
        Image(systemName: season.isWatched ? &quot;checkmark.rectangle.fill&quot; : &quot;checkmark.rectangle&quot;)
    }
})
</code></pre>
<p>I mean it totally makes sense because the <code>Show</code> model does not know it should be marked as watched when all seasons are watched, but how can I implemented and let it update automatically and using <code>CoreData</code> at the same time?</p>
<p><strong>// Edit:</strong>
Added my last edit as answer because no other solution was found.</p>
","1195661","","1195661","","2021-04-06 16:40:47","2021-04-06 16:40:47","Update view after subview change SwiftUI","<swift><swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"66850468","1","67097502","","2021-03-29 07:51:05","","1","231","<p>I have a LazyVGrid, every item with is favorite button. and use combine to debounce user input($isFavoriteI), when isFavoriteO changed, then modify the items.</p>
<p>it works fine, but when i scroll the list, log will print: &quot;X, isFavorite changed as false/true)&quot;, what cause isFavoriteO changed and why? because of item reusing in list? how to avoid it?</p>
<pre><code>index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
index 7, isFavorite changed as true
</code></pre>
<pre><code>import SwiftUI
import Combine

struct Item {
    var index: Int
    var favorite: Bool
}

var items = [
    Item(index: 0, favorite: true),
    Item(index: 1, favorite: false),
    Item(index: 2, favorite: true),
    Item(index: 3, favorite: false),
    Item(index: 4, favorite: true),
    Item(index: 5, favorite: false),
    Item(index: 6, favorite: true),
    Item(index: 7, favorite: false),
//    Item(index: 8, favorite: true),
//    Item(index: 9, favorite: false),
//    Item(index: 10, favorite: true),
//    Item(index: 11, favorite: false),
//    Item(index: 12, favorite: true),
//    Item(index: 13, favorite: false),
//    Item(index: 14, favorite: true),
//    Item(index: 15, favorite: false),
//    Item(index: 16, favorite: true),
//    Item(index: 17, favorite: false),
//    Item(index: 18, favorite: true),
//    Item(index: 19, favorite: false),
]

struct ViewModelInListTestView: View {
    var body: some View {
        ScrollView(showsIndicators: false) {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 200), spacing: 4, alignment: .center)], spacing: 4) {
                ForEach(items, id: \.index) { item in
                    ItemView(item: item)
                }
            }
        }.navigationTitle(&quot;ViewModel In List&quot;)
    }
}

struct ItemView: View {
    let item: Item
    @ObservedObject var viewModel: ViewModel
    
    init(item: Item) {
        print(&quot;ItemView.init, \(item.index)&quot;)
        self.item = item
        self.viewModel = ViewModel(item: item)
    }
    
    var body: some View {
        HStack {
            Text(&quot;index \(item.index)&quot;)
            Spacer()
            Image(systemName: viewModel.isFavoriteI ? &quot;heart.fill&quot; : &quot;heart&quot;)
                .foregroundColor(viewModel.isFavoriteI ? .red : .white)
                .padding()
                .onTapGesture { onFavoriteTapped() }
                .onChange(of: viewModel.isFavoriteO) { isFavorite in
                    setFavorite(isFavorite)
                }
        }
        .frame(width: 200, height: 150)
        .background(Color.gray)
    }
    
    func onFavoriteTapped() {
        viewModel.isFavoriteI.toggle()
    }
    
    func setFavorite(_ isFavorite: Bool) {
        print(&quot;index \(item.index), isFavorite changed as \(isFavorite)&quot;)
        items[item.index].favorite = isFavorite
    }
    
    class ViewModel: ObservableObject {
        @Published var isFavoriteI: Bool = false
        @Published var isFavoriteO: Bool = false
        private var subscriptions: Set&lt;AnyCancellable&gt; = []
        
        init(item: Item) {
            print(&quot;ViewModel.init, \(item.index)&quot;)
            let isFavorite = item.favorite
            isFavoriteI = isFavorite; isFavoriteO = isFavorite
            $isFavoriteI
                .print(&quot;index \(item.index) isFavoriteI:&quot;)
                .dropFirst()
                .debounce(for: .milliseconds(500), scheduler: DispatchQueue.main)
                .removeDuplicates()
                .eraseToAnyPublisher()
                .print(&quot;index \(item.index) isFavoriteO:&quot;)
                .receive(on: DispatchQueue.main)
                .assign(to: \.isFavoriteO, on: self)
                .store(in: &amp;subscriptions)
        }
    }
}

</code></pre>
<p>update @ 4.15
according to @Cenk Bilgen, i re-write the code, but strange thing happened. print(&quot;set favorite as (favorite)&quot;) will not present if adding removeDuplicates. why?</p>
<pre><code>
import SwiftUI
import Combine

struct Item: Identifiable {
    var index: Int
    var favorite: Bool
    var id: Int { index }
}

class Model: ObservableObject {
    @Published var items = [
        Item(index: 0, favorite: true),
        Item(index: 1, favorite: false),
        Item(index: 2, favorite: true),
        Item(index: 3, favorite: false),
        Item(index: 4, favorite: true),
        Item(index: 5, favorite: false),
        Item(index: 6, favorite: true),
        Item(index: 7, favorite: false),
    ]
}

struct ViewModelInListTestView: View {
    @StateObject var model = Model()
    var body: some View {
        print(&quot;ViewModelInListTestView refreshing&quot;); return
        ScrollView(showsIndicators: false) {
            LazyVGrid(columns: [GridItem(.adaptive(minimum: 200), spacing: 4, alignment: .center)], spacing: 4) {
                ForEach(model.items.indices) { index in
                    ItemView(item: model.items[index])
                        .environmentObject(model)
                }
            }
        }.navigationTitle(&quot;ViewModel In List&quot;)
    }
    
    
    struct ItemView: View {
        @EnvironmentObject var model: Model
        let item: Item
        @State private var updateFavourite = PassthroughSubject&lt;Bool, Never&gt;()
        @State private var favorite: Bool = false
        
        init(item: Item) {
            self.item = item
            self._favorite = State(initialValue: item.favorite)
        }
        
        var body: some View {
            print(&quot;ItemView \(item.index) refreshing&quot;); return
            HStack {
                Text(&quot;index \(item.index)&quot;)
                Spacer()
                Image(systemName: favorite ? &quot;heart.fill&quot; : &quot;heart&quot;)
                    .foregroundColor(favorite ? .red : .white)
                    .padding()
                    .onTapGesture {
                        favorite.toggle()
                        updateFavourite.send(favorite)
                    }
                    .onReceive(
                        updateFavourite
                            .debounce(for: .seconds(0.5), scheduler: DispatchQueue.main)
//                            .removeDuplicates()  &lt;------ HERE
//                            .eraseToAnyPublisher()
                    ) { favorite in
                        print(&quot;set favorite as \(favorite)&quot;)
                        model.items[item.index].favorite = favorite
                    }
            }
            .frame(width: 200, height: 150)
            .background(Color.gray)
        }
    }
    
}

</code></pre>
","12668737","","12668737","","2021-04-15 14:39:21","2021-04-15 14:39:21","swiftui+combine: why isFavoriteO changed when scroll the LazyVGrid?","<swiftui><combine>","3","7","","","","CC BY-SA 4.0"
"66854873","1","66855029","","2021-03-29 13:12:44","","0","697","<p>How to update view, when view models publish var's (user's) , name property is updated. I do know why its happening but what is the best way to update the view in this case.</p>
<pre><code>class User {
    var id  = &quot;123&quot;
    @Published  var name = &quot;jhon&quot;
}
</code></pre>
<hr />
<pre><code> class ViewModel : ObservableObject {
    @Published var user : User = User()
}
 
</code></pre>
<hr />
<pre><code>struct ContentView: View {
     @ObservedObject var viewModel = ViewModel() 
    
    var body: some View  {
        userNameView 
    }

    var userNameView: some View  {
        Text(viewModel.user.name)
            .background(Color.red)
            .onTapGesture {
                viewModel.user.name += &quot;update&quot;
                print( viewModel.user.name)
            }
    }
}
</code></pre>
<p>so one way i do it, is by using onReceive like this,</p>
<pre><code>var body: some View  {

         userNameView
             .onReceive(viewModel.user.$name){ output in

                    let tmp = viewModel.user
                           viewModel.user = tmp
                    print(&quot;onTapGesture&quot;,output)

          }
}
</code></pre>
<p>but it is not a good approach it will update all view using users properties.
should i make a @state var for the name?
or should i just make a ObservedObject for user as well?</p>
","12383844","","13899957","","2021-03-29 13:45:33","2021-03-29 14:07:47","update View when view model's, publish object's, property is updated","<swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"66867313","1","","","2021-03-30 08:28:50","","0","301","<p>I'm looking for a way to prefetch data and cache it without any subscriptions made towards that subscriber or when first subscription is made.</p>
<p>For example :</p>
<pre><code>products = getProducts.shareReply(scope : forever)
</code></pre>
<p>And when new subscribers subscribes it should receive the last data. If there is no subscribers it's shouldn't restart this publisher on next subscription instead it should return last cached data.</p>
<p>I'm already using shareReply operator with multicast, custom ReplaySubject and autoconnect but if there is no subscriptions towards the publisher next time something subscribes it will restart the publisher and new data will be fetched. And I don't want that.</p>
<p>This is code for shareReply operator :</p>
<pre><code>extension Publisher {
   
    func shareReplay(_ bufferSize: Int = 1) -&gt; AnyPublisher&lt;Output, Failure&gt; {
        return multicast(subject: ShareReplySubject(bufferSize))
            .autoconnect()
            .eraseToAnyPublisher()
    }
}
</code></pre>
","3820641","","","","","2021-03-31 14:13:39","Combine prefetching and caching results","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"66872702","1","","","2021-03-30 14:16:05","","0","294","<p>I'm sorry if this is a basic question but I'm still getting to grips with Combine.</p>
<p>I have a publisher that is linked to changes in CoreData.</p>
<p>I am trying to subscribe to those changes in my ViewModel using :</p>
<pre><code>CDPublisher(
        request: Book.fetchAllBooks(),
        context: PersistentStore.shared.context
    )
    .map { $0 }
    .receive(on: DispatchQueue.main)
    .sink { [weak self] newBooks in
        self?.books = newBooks // Error here
    }
    .store(in: &amp;cancellables)
</code></pre>
<p>I want to assign the new array of books <code>newBooks</code> to an <code>@Published</code> array called <code>books</code> of type <code>[Book]</code>.</p>
<p>However I get this error:</p>
<blockquote>
<p>Cannot assign value of type 'Subscribers.Completion&lt;CDPublisher.Failure&gt;' (aka 'Subscribers.Completion') to type '[Book]'</p>
</blockquote>
<p>I believe the problem stems from my <code>.map</code>. I added it because without it I got this error:</p>
<blockquote>
<p>Referencing instance method 'sink(receiveValue:)' on 'Publisher' requires the types 'CDPublisher.Failure' (aka 'Error') and 'Never' be equivalent</p>
</blockquote>
<p>FYI the publisher I'm using is taken from: <a href=""https://betterprogramming.pub/combine-publishers-and-core-data-424b68fe9473"" rel=""nofollow noreferrer"">https://betterprogramming.pub/combine-publishers-and-core-data-424b68fe9473</a></p>
<p>Thanks for your help.</p>
","13296730","","","","","2021-03-30 14:16:05","Combine - Assigning publisher value","<swift><swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"66877876","1","","","2021-03-30 20:14:38","","1","35","<p>I am trying to query documents from Firebase, but I am unable to to correctly await the response of the function. I have tried with Future, but seemingly I cannot return promise from within the query body. Could you help me, how to correctly query and then subscribe to it with Swift (Combine) and Firebase?</p>
<p>I need to know the result of the query (error/empty/success), and if success, then use the value of the query. Is this possible?</p>
<p>The query:</p>
<pre><code>func getProductByCode(code: String) -&gt; Future&lt;[Product], QueryError&gt; {
        return Future { promise in
            self.db.collection(&quot;products&quot;)
            .whereField(&quot;code&quot;, isEqualTo: code)
            .getDocuments { (querySnapshot, error) in
                if let error = error {
                    print(&quot;Error on loading products: \(error.localizedDescription)&quot;)
                    return promise(.failure(.error))
                }
                
                if let querySnapshot = querySnapshot {
                    if querySnapshot.isEmpty {
                        print(&quot;Empty products list&quot;)
                        return promise(.failure(.empty))
                    } else {
                        self.products = querySnapshot.documents.compactMap { document in
                            try? document.data(as: Product.self)
                        }
                        print(&quot;List of products: \(self.products)&quot;)
                        return promise(.success(self.products))
                    }
                }
            }
        }
    }

enum QueryError: Error {
        case empty
        case error
    }
</code></pre>
<p>The method call, with subscription:</p>
<pre><code>productRepository.getProductByCode(code: qrText)
    .sink(receiveCompletion: { completion in
            switch completion {
            case .failure(.error):
                print(&quot;ERROR on retrieving products&quot;)
            case .failure(.empty):
                print(&quot;EMPTY products&quot;)
            default:
                print(&quot;ALRIGHT&quot;)
            }
        }, receiveValue: { value in
            print(&quot;Returned value: \(value)&quot;)
            // Here I should get the result of the query and then use it.
        })

//After the method call I would like to use the result value.
//But I cannot correctly await it.
//It would be called before the async function returns the value.
</code></pre>
<p>I am open to any kind of change, I have tried Future, because it can return promises and we can subscribe to it. If there is a better solution to this kind of situation, please help.</p>
","15516954","","","","","2021-05-07 20:32:51","Swift query from Firebase not correctly awaited","<swift><firebase><future><combine>","1","0","","","","CC BY-SA 4.0"
"66884390","1","66885061","","2021-03-31 08:44:13","","4","1027","<p>What is the best approach to have swiftUI still update based on nested observed objects?</p>
<p>The following example shows what I mean with nested observed objects. The balls array of the ball manager is a published property that contains an array of observable objects, each with a published property itself (the color string).</p>
<p>Unfortunately, when tapping one of the balls it dos not update the balls name, nor does it receive an update. So I might have messed up how combine was ment to work in that case?</p>
<pre><code>import SwiftUI

class Ball: Identifiable, ObservableObject {
    let id: UUID
    @Published var color: String
    init(ofColor color: String) {
        self.id = UUID()
       self.color = color
    }
}

class BallManager: ObservableObject {
    @Published var balls: [Ball]
    init() {
        self.balls = []
    }
}

struct Arena: View {
   @StateObject var bm = BallManager()

    var body: some View {
        VStack(spacing: 20) {
            ForEach(bm.balls) { ball in
                Text(ball.color)
                    .onTapGesture {
                        changeBall(ball)
                    }
            }
        }
        .onAppear(perform: createBalls)
        .onReceive(bm.$balls, perform: {
            print(&quot;ball update: \($0)&quot;)
        })
    }
    
    func createBalls() {
        for i in 1..&lt;4 {
            bm.balls.append(Ball(ofColor: &quot;c\(i)&quot;))
        }
    }
    
    func changeBall(_ ball: Ball) {
        ball.color = &quot;cx&quot;
    }
}
</code></pre>
","1754221","","","","","2021-03-31 14:50:15","SwiftUI Combine: Nested Observed-Objects","<swift><swiftui><combine><observableobject>","4","0","3","","","CC BY-SA 4.0"
"66895144","1","","","2021-03-31 20:49:25","","2","1154","<p>Is there a way to get the value of a <strong>PassthroughSubject</strong> publisher in a Unit test?
I want to test that a function returns success and to test this one I want to see when the publisher value is <strong>.loaded</strong>, then is success.</p>
<pre><code>class HomeViewModel: ObservableObject {

    var homeState = PassthroughSubject&lt;StatePublisher, Never&gt;()

    func load(item: HomeModel) {
        self.homeState.send(.loading)
        self.dataSource.load(item: item) { result in
            switch result {
            case .success:
                self.homeState.send(.loaded)
            case let .failure(error):
                self.homeState.send(.error(message: error.localizedDescription))
            }
        }
    }

}
</code></pre>
<pre><code>class HomeViewModelTests: XCTestCase {
    var sut: ViewModel!
    var subscriptions = Set&lt;AnyCancellable&gt;()
    
    override func setUpWithError() throws {
        sut = ViewModel()
    }

    override func tearDownWithError() throws {
        sut = nil
        subscriptions = []
    }
        
    func testUpdateHomeSuccess() {
        let expected = StatePublisher.loaded
        var result = StatePublisher.loading
    
        sut.load(item: HomeModel.fixture())
        
        sut.homeState
            .sink(receiveValue: { state in
                result = state
            })
            .store(in: &amp;subscriptions)
    
        XCTAssert(
            result == expected,
            &quot;Home expected to be \(expected) but was \(result)&quot;
        )
    }
    
}
</code></pre>
<p>I tried a test like this, but sink is never called.</p>
","11995597","","77567","","2021-04-01 13:42:51","2021-07-12 10:02:07","Unit Test for getting the PassthroughSubject publisher's value","<swift><combine>","2","1","","","","CC BY-SA 4.0"
"66896055","1","","","2021-03-31 22:20:32","","2","142","<p>I have this inside my View:</p>
<pre><code>Image(uiImage: viewModel.emojiImage)

Button(action: {
    viewModel.updatesRandomEmojiImage()
}, label: {
    Text(&quot;RANDOM EMOJI&quot;)
}).buttonStyle(FilledButton())
</code></pre>
<p>and these methods in my ViewModel:</p>
<pre><code>@State var emojiImage: UIImage = UIImage()

func updatesRandomEmojiImage() {
    guard let url = URL(string: randomEmojiUrl()) else { return }
    downloadEmojiImage(fromUrl: url)
}
    
func randomEmojiUrl() -&gt; String {
    repository.emojis().randomElement()?.imageUrl ?? &quot;&quot;
}
    
private func downloadEmojiImage(fromUrl url: URL) {
    if let data = try? Data(contentsOf: url) {
        self.emojiImage = UIImage(data: data)!
    }
}
</code></pre>
<p>I'm trying to make that the <code>Image</code> content changes whenever I click on the &quot;RANDOM EMOJI&quot; button. How can I do that?</p>
","985979","","","","","2021-03-31 22:58:24","SwiftUI Make the content of an Image reactive to a property update","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66908175","1","66910608","","2021-04-01 16:20:34","","4","4266","<p>Here is a simple &quot;Download&quot; class to illustrate what I want to do.</p>
<pre class=""lang-swift prettyprint-override""><code>class Download {
    
    public var progress: CurrentValueSubject&lt;Double, Never&gt; = CurrentValueSubject&lt;Double, Never&gt;(0)
    
    var subscriptions: Set&lt;AnyCancellable&gt; = []
    
    func start(task: URLSessionTask) {
        task.resume()
        task.progress.publisher(for: \.fractionCompleted).sink { [weak self] (newProgress) in
            self?.progress.send(newProgress)
        }.store(in: &amp;subscriptions)
    }
    
}
</code></pre>
<p>I would like to be able to &quot;re-publish&quot; the progress property observer publisher to my current value subject. As you can see I currently subscribe using the <code>.sink</code> function and then just call the <code>CurrentValueSubject</code> publisher directly.</p>
<p>I would like to be able to use something like the <code>.assign(to:, on:)</code> operator like this.</p>
<pre class=""lang-swift prettyprint-override""><code>task.progress.publisher(for: \.fractionCompleted).assign(to: \.progress, on: self)
</code></pre>
<p>However, that will not work nor will the <code>.assign(to:)</code> operator that seems to be reserved for &quot;re-publishing&quot; on a SwiftUI <code>@Published</code> property. Why is Combine not living up to it's name here?</p>
","4576323","","","","","2021-04-01 19:40:25","Combine assign(to: on:) another publisher","<ios><swift><combine>","2","1","2","","","CC BY-SA 4.0"
"66912429","1","66913662","","2021-04-01 22:42:46","","0","173","<p>I'm following a <a href=""https://www.youtube.com/watch?v=4RUeW5rUcww"" rel=""nofollow noreferrer"">video on the Firebase YouTube channel</a>. Starting around 27:45, the instructor is trying to set a variable based on a Boolean and ends up with the following code in <code>init(task: Task)</code>:</p>
<pre><code>$task
    .map { task in
        task.isCompleted ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;
    }
    .assign(to: \.completionStateIconName, on: self)
    .store(in: &amp;cancellables)
</code></pre>
<p>This seems overly convoluted to me. First, I can't find documentation on using <code>.map</code> on a struct object, only on arrays, etc. Second, what is with this <code>&amp;cancellables</code> thing? (It's defined as <code>private var cancellables = Set&lt;AnyCancellable&gt;()</code> before the <code>init{}</code>.) Third, why all this code, and not simply:</p>
<pre><code>task.completionStateIconName = task.isCompleted ? &quot;checkmark.circle.fill&quot; : &quot;circle&quot;
</code></pre>
<p>This seems to give the same result, but will there be something down the line that the first code fragment works, but the second doesn't?</p>
","1363998","","1015258","","2021-04-01 22:45:09","2021-04-02 02:12:38","SwiftUI and Combine","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66916090","1","66937105","","2021-04-02 07:50:24","","-1","352","<p>In my app, I've added the capabilities of background audio and background processing.</p>
<p>My code presently uses <code>AVAudioPlayer</code> to play audio. While playback is good when the app in the foreground, with a locked screen, the audio is has some static jitteriness to it.</p>
<p>My app is written using SwiftUI and Combine. Has anyone encountered this issue and what would you suggest as a workaround?</p>
<p>Here is the <code>play</code> method:</p>
<pre><code>    /// Play an `AudioFile`
    /// - Parameters:
    ///   - audioFile: an `AudioFile` struct
    ///   - completion: optional completion, default is `nil`
    func play(_ audioFile: AudioFile,
              completion: (() -&gt; Void)? = nil) {
        if audioFile != currentAudioFile {
            resetPublishedValues()
        }
        currentAudioFile = audioFile
        setupCurrentAudioFilePublisher()
        guard let path = Bundle.main.path(forResource: audioFile.filename, ofType: &quot;mp3&quot;) else {
            return
        }
        
        let url = URL(fileURLWithPath: path)
        
        // everybody STFU
        stop()
        
        do {
            // make sure the sound is one
            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
            // instantiate instance of AVAudioPlayer
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer.prepareToPlay()
            // play the sound
            let queue = DispatchQueue(label: &quot;audioPlayer&quot;, qos: .userInitiated, attributes: .concurrent, autoreleaseFrequency: .inherit, target: nil)
            
            queue.async {
                self.audioPlayer.play()
            }
            audioPlayer.delegate = self
        } catch {
            // Not much to go wrong, so leaving alone for now, but need to make `throws` if we handle errors
            print(String(format: &quot;play() error: %@&quot;, error.localizedDescription))
        }
    }
</code></pre>
<p>This is the class definition:</p>
<pre><code>import AVFoundation
import Combine
import Foundation

/// A `Combine`-friendly wrapper for `AVAudioPlayer` which utilizes `Combine` `Publishers` instead of `AVAudioPlayerDelegate`
class CombineAudioPlayer: NSObject, AVAudioPlayerDelegate, ObservableObject {
    static let sharedInstance = CombineAudioPlayer()
    private var audioPlayer = AVAudioPlayer()
    /*
     FIXME: For now, gonna leave this timer on all the time, but need to refine
     down the road because it's going to generate a fuckload of data on the
     current interval.
     */
    // MARK: - Publishers
    private var timer = Timer.publish(every: 0.1,
                                      on: RunLoop.main,
                                      in: RunLoop.Mode.default).autoconnect()
    @Published public var currentAudioFile: AudioFile?
    public var isPlaying = CurrentValueSubject&lt;Bool, Never&gt;(false)
    public var currentTime = PassthroughSubject&lt;TimeInterval, Never&gt;()
    public var didFinishPlayingCurrentAudioFile = PassthroughSubject&lt;AudioFile, Never&gt;()
    
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    
    // MARK: - Initializer
    private override init() {
        super.init()
        // set it up with a blank audio file
        setupPublishers()
        audioPlayer.setVolume(1.0, fadeDuration: 0)
    }
    
    // MARK: - Publisher Methods
    private func setupPublishers() {
        timer.sink(receiveCompletion: { completion in
            // TODO: figure out if I need anything here
            // Don't think so, as this will always be initialized
        },
        receiveValue: { value in
            self.isPlaying.send(self.audioPlayer.isPlaying)
            self.currentTime.send(self.currentTimeValue)
        })
        .store(in: &amp;cancellables)
        
        didFinishPlayingCurrentAudioFile.sink(receiveCompletion: { _ in
            
        },
        receiveValue: { audioFile in
            self.resetPublishedValues()
        })
        .store(in: &amp;cancellables)
    }
    
    private func setupCurrentAudioFilePublisher() {
        self.isPlaying.send(false)
        self.currentTime.send(0.0)
    }
    
    // MARK: - Playback Methods
    
    /// Play an `AudioFile`
    /// - Parameters:
    ///   - audioFile: an `AudioFile` struct
    ///   - completion: optional completion, default is `nil`
    func play(_ audioFile: AudioFile,
              completion: (() -&gt; Void)? = nil) {
        if audioFile != currentAudioFile {
            resetPublishedValues()
        }
        currentAudioFile = audioFile
        setupCurrentAudioFilePublisher()
        guard let path = Bundle.main.path(forResource: audioFile.filename, ofType: &quot;mp3&quot;) else {
            return
        }
        
        let url = URL(fileURLWithPath: path)
        
        // everybody STFU
        stop()
        
        do {
            // make sure the sound is one
            try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default)
            try AVAudioSession.sharedInstance().setActive(true)
            // instantiate instance of AVAudioPlayer
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer.prepareToPlay()
            // play the sound
            let queue = DispatchQueue(label: &quot;audioPlayer&quot;, qos: .userInitiated, attributes: .concurrent, autoreleaseFrequency: .inherit, target: nil)
            
            queue.async {
                self.audioPlayer.play()
            }
            audioPlayer.delegate = self
        } catch {
            // Need to make `throws` if we handle errors
            print(String(format: &quot;play error: %@&quot;, error.localizedDescription))
        }
    }
    
    func stop() {
        audioPlayer.stop()
        resetPublishedValues()
    }
    
    private func resetPublishedValues() {
        isPlaying.send(false)
        currentTime.send(0.0)
    }
    
    private var currentTimeValue: TimeInterval {
        audioPlayer.currentTime
    }
    
    /// Use the `Publisher` to determine when a sound is done playing.
    /// - Parameters:
    ///   - player: an `AVAudioPlayer` instance
    ///   - flag: a `Bool` indicating whether the sound was successfully played
    func audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {
        if let currentAudioFile = currentAudioFile {
            didFinishPlayingCurrentAudioFile.send(currentAudioFile)
        }
        resetPublishedValues()
    }
}
</code></pre>
","4475605","","4475605","","2021-04-02 08:21:28","2021-04-04 00:45:02","Using AVAudioPlayer in background","<audio><swiftui><avaudioplayer><combine>","1","0","1","","","CC BY-SA 4.0"
"66930090","1","66930971","","2021-04-03 10:28:25","","0","259","<p>There are three publishers. First you need to try the first, if an error occurs, then use the second, if again an error, then use the third, if there is a failure, then return the last error. Important: you cannot call in parallel, it is necessary to follow the sequence. I have an assumption that the scan method should be used, but I do not understand how exactly.</p>
","10682199","","","","","2021-04-04 14:01:10","How to call the next swift combine publisher in turn if the previous one reported an error?","<combine>","1","0","","","","CC BY-SA 4.0"
"66931982","1","","","2021-04-03 13:58:09","","0","59","<p>I am following the tutorial for IAP from the following site:
<a href=""https://betterprogramming.pub/set-up-your-swiftui-app-to-support-in-app-purchases-ef2e0a11d10c"" rel=""nofollow noreferrer"">https://betterprogramming.pub/set-up-your-swiftui-app-to-support-in-app-purchases-ef2e0a11d10c</a></p>
<p>Here is the portion of the code that handles the transaction and the states:</p>
<pre><code>extension IAPManager: SKPaymentTransactionObserver {
  
    func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) {
 
        transactions.forEach { (transaction) in
  
            switch transaction.transactionState {
  
            case .purchased:
                SKPaymentQueue.default().finishTransaction(transaction)
                purchasePublisher.send((&quot;Purchased &quot;,true))
  
            case .restored:
                totalRestoredPurchases += 1
                SKPaymentQueue.default().finishTransaction(transaction)
                purchasePublisher.send((&quot;Restored &quot;,true))
   
            case .failed:
                if let error = transaction.error as? SKError {
                    purchasePublisher.send((&quot;Payment Error \(error.code) &quot;,false))
                    print(&quot;Payment Failed \(error.code)&quot;)
                }
                SKPaymentQueue.default().finishTransaction(transaction)
  
            case .deferred:
                print(&quot;Ask Mom ...&quot;)
                purchasePublisher.send((&quot;Payment Diferred &quot;,false))
  
            case .purchasing:
                print(&quot;working on it...&quot;)
                purchasePublisher.send((&quot;Payment in Process &quot;,false))
  
            default:
                break
  
            }

        }

    }   

}
</code></pre>
<p>In short, it checks each case on the queue for each buy request you placed with the server and sends the status back to the SwiftUI interface through the purchasePublisher PassThruSubject that looks like this:</p>
<pre><code>let purchasePublisher = PassthroughSubject&lt;(String, Bool), Never&gt;()
</code></pre>
<p>That is the part I am confused about!? How do I access the <code>purchasePublisher</code> so that I can check on the SwiftUI view (SwiftUI interface) that the purchase was in fact completed successfully so that then I can take action accordingly?</p>
","7386152","","9086770","","2021-04-03 16:07:41","2021-04-03 16:07:41","Confusion with notifying the UI view that the purchase was completed","<ios><swiftui><in-app-purchase><combine>","1","0","","","","CC BY-SA 4.0"
"66938411","1","66938539","","2021-04-04 06:02:37","","0","123","<p>I kind of wrote everything correctly and the code itself is working but it gives me an error Result of call to 'fetchPokemon()' is unused, what could be the problem here?</p>
<p>Hear is my code: ModelView class</p>
<pre><code> import Foundation
 import Combine
 class NetworkManager: ObservableObject {

let baseuRL = &quot;https://pokeapi.co/api/v2/pokemon&quot;

@Published var pokemon: [Pokemon] = []
var error: Error?
var cancellables: Set&lt;AnyCancellable&gt; = []

func fetchPokemon() -&gt; Future&lt;[Pokemon], Error&gt; {
    return Future&lt;[Pokemon], Error&gt; { promice in
        guard let url = URL(string: &quot;\(self.baseuRL)&quot;) else {
            return promice(.failure(ApiError.unknowed))
        }
        URLSession.shared.dataTaskPublisher(for: url)
            .tryMap { (data, response) -&gt; Data in
                guard let http = response as? HTTPURLResponse,
                      http.statusCode == 200 else {
                    throw ApiError.responseError
                }
                return data
            }
            .decode(type: PokemonList.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    print(error)
                }
            }, receiveValue: {
                promice(.success($0.results))
            })
            .store(in: &amp;self.cancellables)
    }
}


 struct ContentView: View {
@StateObject var net = NetworkManager()
var body: some View {
    List(net.pokemon, id: \.self) { pokemon in
        Text(pokemon.name)
    }.onAppear {
        net.fetchPokemon()
    }
}
</code></pre>
<p>}</p>
","13065117","","","","","2021-04-04 06:22:03","Result with combine can't get results","<swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"66953439","1","","","2021-04-05 12:56:51","","1","446","<p>My starting point is a method like this <code>foo()</code> example here. I'm using <code>retries: 1</code>.</p>
<pre class=""lang-swift prettyprint-override""><code>    func foo() {

        // create url ...

        let urlRequest = URLRequest(for: url, httpMethod: &quot;POST&quot;, resource: nil, token: accessToken)
        let combineRequest = CombineRequest(auth: auth)
        combineRequest.runWithResponseStatus(urlRequest, checkStatusCode: 201, retries: 1)
            .sink { completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    self.toasts.insert(ToastText(type: .error, text: Text(&quot;\(error.localizedDescription)&quot;)), at: 0)
                    self.clearToasts()
                }
            } receiveValue: { _ in
                // successful
            }
            .store(in: &amp;cancellables)
    }
</code></pre>
<p>So it's a <code>POST</code> combine request (<code>runWithResponseStatus()</code>). When I get a <code>401 - unauthorized</code>, I would like to execute another combine request (<code>refresh()</code>).</p>
<ol>
<li>If <code>refresh()</code> is successful, it should execute <code>auth.setAccessToken(to: newAccessToken.token)</code> and retry it's previously called (<code>runWithResponseStatus()</code>) method one more time.</li>
<li>Right now, on <code>.failure</code> I'm doing a <code>print(&quot;\(error.localizedDescription)&quot;)</code> but I would like to return that error up in the chain so it ends up in the <code>foo()</code> method, where I can put it into the toasts array.</li>
</ol>
<p>Does someone know how to achieve these two points and also, if possible, utilise the power of combine and just make it cleaner?</p>
<pre class=""lang-swift prettyprint-override""><code>struct CombineRequest {
    
    var auth: Auth
    var jsonDecoder: JSONDecoder = JSONDecoder(dateFormatter: .isoDateFormatter)

    func runWithResponseStatus(_ request: URLRequest, checkStatusCode statusCode: Int = 200, queue: DispatchQueue = .main, retries: Int = 0) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), Error&gt; {
        
        var cancellable = Set&lt;AnyCancellable&gt;()
        
        return URLSession.shared.dataTaskPublisher(for: request)
        .retry(retries)
        .tryMap { output in
            if let response = output.response as? HTTPURLResponse, response.statusCode != statusCode {
                switch response.statusCode {
                case 401:
                    try refresh(decodingType: AccessData.self)
                        .sink { completion in
                            switch completion {
                            case .finished:
                                break
                            case .failure(let error):
                                print(&quot;\(error.localizedDescription)&quot;)
                            }
                        } receiveValue: { newAccessToken in
                            auth.setAccessToken(to: newAccessToken.token)
                        }
                        .store(in: &amp;cancellable)
                case 400:
                    throw ResourceError.internalServerError(&quot;General.error.general&quot;)
                default:
                    throw ResourceError.httpStatus(response.statusCode)
                }
            }
            return output
        }
        .receive(on: queue)
        .eraseToAnyPublisher()
    }


    private func refresh&lt;DecodingType&gt;(checkStatusCode statusCode: Int = 200, queue: DispatchQueue = .main, decodingType: DecodingType.Type) throws -&gt; AnyPublisher&lt;DecodingType, Error&gt; where DecodingType: Decodable {
        
        // prepare all properties ...
        
        return URLSession.shared.dataTaskPublisher(for: refreshRequest)
            .tryMap { output in
                if let response = output.response as? HTTPURLResponse, response.statusCode != statusCode {
                    switch response.statusCode {
                    case 401:
                        auth.loggedOut()
                    case 400:
                        throw ResourceError.internalServerError(&quot;General.error.general&quot;)
                    default:
                        auth.loggedOut()
                        throw ResourceError.httpStatus(response.statusCode)
                    }
                }
                return output.data
            }
            .decode(type: DecodingType.self, decoder: jsonDecoder)
            .receive(on: queue)
            .eraseToAnyPublisher()
    }

}
</code></pre>
","2458616","","","","","2021-04-14 12:24:28","How to execute swift combine request if previous request unauthorised","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"66962267","1","66962642","","2021-04-06 03:16:20","","1","432","<p>I have two publishers, both of which can publish a value or complete without publishing any at all. I'm combining the two publishers and comparing their values and doing some post-processing on the values and saving them to my local CoreData. Simplified code looks like:</p>
<pre><code>let p1 = [&quot;1&quot;]
    .publisher
    .map { Int($0) }

let p2 = [&quot;2&quot;]
    .publisher
    .map { Int($0) }

let p1p2 = p1.combineLatest(p2)
    .map { $0 == $1 }
    .sink { print($0) }
</code></pre>
<p>But in case one of the publishers doesn't publish any value, I still need to save the remaining value to my local DB. The issue is that the combineLatest operator doesn't fire any event if one of the publisher finishes without ever firing a value. I tried prepend and append operators, but they cannot be combined with any conditions, say if one of the publishers finish without publishing any value.</p>
<p>For example, something like:</p>
<pre><code>let p1String: [String] = []
let p1 = p1String.publisher
    .map { Int($0) }
    .if(completionWithoutPublishing, perform: { prepend(nil) })
</code></pre>
<p>Any ideas would be appreciated.</p>
","3970488","","","","","2021-04-06 04:24:59","Append element to publisher only if it wants to finish without publishing any value","<swift><combine>","2","2","1","","","CC BY-SA 4.0"
"66972792","1","66972903","","2021-04-06 16:34:42","","0","37","<p>Unable to get <code>Data</code> using <code>Combine</code>, nothing is printed on the console.</p>
<pre><code>struct RepositoryElement: Codable {}

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        
        let url = URL(string: &quot;https://api.github.com/users/brunosilva808/repos&quot;)!

        let repos = URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: [Repository].self, decoder: JSONDecoder())
            .sink(receiveCompletion: { completion in // 5
                print(completion)
            }, receiveValue: { repositories in
                print(&quot;brunosilva808 has \(repositories.count) repositories&quot;)
            })
    }
}
</code></pre>
","516765","","516765","","2021-04-06 16:39:19","2021-04-06 16:43:22","Unable to do a urlSession request with Combine","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"66982854","1","67011837","","2021-04-07 09:05:52","","2","643","<p>If I specify the <code>maxPublishers</code> parameter then source events after first maxPublishers events won't be flat mapped. While I want to limit only concurrency. That is to continue processing next events after some of the first maxPublishers flat map publishers have completed.</p>
<pre><code>Publishers.Merge(
    addImageRequestSubject
        .flatMap(maxPublishers: .max(3)) { self.compressImage($0) }
        .compactMap { $0 }
        .flatMap(maxPublishers: .max(3)) { self.addImage($0) },
    addVideoRequestSubject
        .flatMap(maxPublishers: .max(3)) { self.addVideo(url: $0) }
).sink(receiveCompletion: { _ in }, receiveValue: {})
.store(in: &amp;cancelBag)
</code></pre>
<p>I've also tried to limit concurrency with help of OperationQueue. But <code>maxConcurrentOperationCount</code> seems doesn't have an effect.</p>
<pre><code>Publishers.Merge(
    addImageRequestSubject
        .receive(on: imageCompressionQueue)
        .flatMap { self.compressImage($0) }
        .compactMap { $0 }
        .receive(on: mediaAddingQueue)
        .flatMap { self.addImage($0) },
    addVideoRequestSubject
        .receive(on: mediaAddingQueue)
        .flatMap { self.addVideo(url: $0) }
).sink(receiveCompletion: { _ in }, receiveValue: {})
.store(in: &amp;cancelBag)

private lazy var imageCompressionQueue: OperationQueue = {
    var queue = OperationQueue()
    queue.maxConcurrentOperationCount = 3

    return queue
}()

private lazy var mediaAddingQueue: OperationQueue = {
    var queue = OperationQueue()
    queue.maxConcurrentOperationCount = 3

    return queue
}()
</code></pre>
<p>Flat map publishers look this way:</p>
<pre><code>func compressImage(_ image: UIImage) -&gt; Future&lt;Data?, Never&gt; {
    Future { promise in
        DispatchQueue.global().async {
            let result = image.compressTo(15)?.jpegData(compressionQuality: 1)
            promise(Result.success(result))
        }
    }
}
</code></pre>
","1531671","","1531671","","2021-04-07 10:52:10","2021-04-08 21:01:35","How to limit flatMap concurrency in Combine still having all source events processed?","<swift><combine>","1","4","","","","CC BY-SA 4.0"
"66982859","1","66990247","","2021-04-07 09:06:05","","1","922","<p>I'm writing a ChartView using NSView with data obtained from a rest api using Combine. The struct PlotView is the SwiftUI View that displays the chart, ChartViewRepresentable is the bridge between the NSView with the chart and the SwiftUI world and ChartView is the view that I actually draw on.</p>
<p>RestRequest gets the data from the network correctly and PlotView has access to it with no issues. When the data is received a ChartViewRepresentable is created and it contains the data, and ChartViewRepresentable creates a ChartView with the data and the data is stored in its data property correctly.</p>
<p>There are two problems: 1) the view's draw method never gets called when the data is loaded, and 2) if the view is redrawn a new ChartViewRepresentable (with a new ChartView) is created by SwiftUI but with no data.</p>
<p>I have connected the RestRequest @StateObject in every possible way imaginable, using @Binding, using @State, with no luck so far, so I'm discounting it as the problem, but with SwiftUI who really knows. It doesn't matter how I load the data, even loading the data manually into ChartView, it never calls the draw method on its own when receiving the data, and then when I for example resize the window to force a draw call it does call the draw method but on a new ChartViewRepresentable struct with no data in it.</p>
<p>What am I doing wrong? This is all the code besides the RestRequest() struct which I know works because I have been using it reliably on other views until now. Any clue or even a hint would be greatly appreciated.</p>
<pre><code>struct PlotView: View {
    @StateObject var request = RestRequest()
    
    var body: some View {
        Group {
            ChartViewRepresentable(data: ChartData(array: ChartData.createArray(from: request.response.data)))
                .frame(minWidth: 300, maxWidth: .infinity, minHeight: 300, maxHeight: .infinity)
        }
        .onAppear{
            let params: [String: String] = [
                &quot;limit&quot;: &quot;10&quot;,
            ]
            request.perform(endPoint: &quot;http://localhost:4000/api/testdata&quot;, parameters: params)
        }
    }
}


struct ChartViewRepresentable: NSViewRepresentable {
    typealias NSViewType = ChartView
    
    var chart: ChartView
    
    init(data: ChartData) {
        chart = ChartView(data: data)
    }
    
    func makeNSView(context: Context) -&gt; ChartView {
        return chart
    }
    func updateNSView(_ nsView: ChartView, context: Context) {
    }
}

class ChartView: NSView {
    
    private var data: ChartData
    
    init(data: ChartData) {
        self.data = data
        print(&quot;\(data)&quot;)
        super.init(frame: .zero)
        wantsLayer = true
        layer?.backgroundColor = .white
    }
    
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    override func draw(_ dirtyRect: NSRect) {
        print(&quot;draw call - Frame: \(self.frame), Data: \(data.array.count)&quot;)
        
        super.draw(dirtyRect)
        
        guard let context = NSGraphicsContext.current else { return }
        context.saveGraphicsState()
        
        if data.array.count &gt; 0 {
            //detect data present on ChartView
            let ctx = context.cgContext
            ctx.setFillColor(NSColor.green.cgColor)
            ctx.fillEllipse(in: CGRect(x: 10, y: 10, width: 10, height: 10))
        }
        
        context.restoreGraphicsState()
    }
}
</code></pre>
","572366","","","","","2021-04-07 16:30:09","SwiftUI NSViewRepresentable can't read data from @Publisher","<swift><swiftui><core-graphics><combine><uiviewrepresentable>","1","0","","","","CC BY-SA 4.0"
"66983469","1","","","2021-04-07 09:43:11","","2","169","<p>We are using SwiftUI with a NavigationView.</p>
<p>We have one view (ParentView) that updates its data asynchronously through its view model (ParentViewModel) and then re-renders its body according to the new data. When the completion block is called after we have entered the second view (ChildView) through the NavigationLink, problems occur, e.g. the app automatically navigating back to the first view without any user interaction, or missing completion block calls in the second view.</p>
<pre><code>struct ParentView: View {

    @ObservedObject private var viewModel = ProjectListViewModel()

    var body: some View {
        ForEach(viewModel.items) { item in
            NavigationLink(destination: ChildView(item: item)) {
                Text(item.label)
            }
        }.onAppear(perform: viewModel.loadData))
    }
}

class ParentViewModel: ObservableObject {

    @Published var items: [Item] = []

    func loadData() {
        loadDataAsynchronously { [weak self] newItems in
            // Problems occur if this completion block is called after we have entered ChildView
            self?.items = newItems
        }
    }
}

class Item: Identifiable { ... }
</code></pre>
<p>This error occurs on the simulator as well as on a physical device.</p>
","3269827","","","","","2021-04-07 09:43:11","SwiftUI re-renders inactive View after updating @Published property asynchronously","<swiftui><combine><swiftui-navigationlink><swiftui-navigationview>","0","7","","","","CC BY-SA 4.0"
"66983922","1","","","2021-04-07 10:11:27","","2","3205","<p>I want to directly link a <code>UITableView</code> with a @Published attribute without using DiffableDataSouce.</p>
<p>If I make the person</p>
<pre><code>struct Person {
    let name: String
}
</code></pre>
<p>and create the data array:</p>
<pre><code>@Published
var people = [Person(name: &quot;Kim&quot;), Person(name: &quot;Charles&quot;)]
</code></pre>
<p>So I want to bind my <code>UITableView</code> directly, with something like:</p>
<pre class=""lang-swift prettyprint-override""><code>func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    return $people.count()
}
</code></pre>
<p>But this gives the error</p>
<p><code>Cannot convert return expression of type 'Publishers.Count&lt;Published[Person]&gt;.Publisher&gt;' to return type 'Int'</code></p>
","11076699","","","","","2021-08-31 11:02:17","Bind UITableView with Combine DataSource","<swift><combine>","1","2","2","","","CC BY-SA 4.0"
"66984760","1","66984986","","2021-04-07 11:03:30","","1","394","<p>I have the following functions:</p>
<pre><code>    func getUserProfile() -&gt; AnyPublisher&lt;UserProfileDTO?, Error&gt; {
    return Future { [unowned self] promise in
        do {
            if let data = KeychainWrapper.standard.data(forKey: profileKey) {
                let profileDTO = try PropertyListDecoder().decode(UserProfileDTO.self, from: data)
                setCurrentSession(profileDTO)
                promise(.success(profileDTO))
            }
            else {
                promise(.success(nil))
            }
        }
        catch {
            // Delete current UserProfile if cannot decode
            let _ = KeychainWrapper.standard.removeAllKeys()
            promise(.failure(error))
        }
    }.eraseToAnyPublisher()
}

    func connect(userProfile: UserProfileDTO) -&gt; AnyPublisher&lt;UserProfileDTO, Error&gt; {
    return Future { promise in
        SBDMain.connect(withUserId: userProfile.email) { (user, error) in
            if let error = error {
                promise(.failure(error))
            }
            else {
                promise(.success(userProfile))
            }
        }
    }.eraseToAnyPublisher()
}
</code></pre>
<p>What I want to do is to first call the getUserProfile() method and if the return value in not nil then call the connect() method. However, if the getUserProfile() has nil response it does not need to call the connect() and it should just return the nil response. Both these methods needs to be called from the autoLoginUser() method.
The problem I'm having right now is figuring out how to do this in a clean swift way without writing too much nested statements.</p>
<p>I tried to use flatMaps but it didn't workout the way I expected. Any help is much appreciated.</p>
<p>A solution I've been working on at the moment is this. But it doesn't quite work.</p>
<pre><code>    func autoLoginUser2() -&gt; AnyPublisher&lt;UserProfile?,Error&gt; {
    getUserProfile()
        .tryMap { [unowned self] in
            if let currentProfile = $0 {
                return connect(userProfile: currentProfile)
                    .tryMap {
                        //Map from UserProfileDTO --&gt; UserProfile
                        return UserProfileDTOMapper.map($0)
                        
                    }
            }
            return nil
        }.eraseToAnyPublisher()
}
</code></pre>
","5201157","","5201157","","2021-04-08 10:09:34","2021-04-08 10:09:34","Swift Combine - Async calls","<swift><async-await><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"66997336","1","66998365","","2021-04-08 04:25:17","","-1","270","<p>I'm attempting to implment a <code>Map</code> on a SwiftUI view from a view model. Every example I find online hard codes a coordinate. In my case, I'm initializing a view model with a <code>Codable</code> struct and I have no idea what the coordinate is going to be.</p>
<p>I do not encounter compiler issues when I build the project, but canvas crashes. I've tried closing Xcode, cleaning derived data, etc., but that doesn't seem to resolve it.</p>
<p>Any suggestions re: where my mistake is are greatly appreciated.</p>
<pre><code>class EarthquakeViewModel: ObservableObject {
    @Published private(set) var quakeData: Feature
    @State var region: MKCoordinateRegion
    
    
    init(quakeData: Feature) {
        self.quakeData = quakeData
        let center = CLLocationCoordinate2D(latitude: quakeData.geometry.coordinates[0],
                                        longitude: quakeData.geometry.coordinates[1])
        let span = MKCoordinateSpan(latitudeDelta: 1.0, longitudeDelta: 1.0)
        region = MKCoordinateRegion(center: center,
                                    span: span)
    }

        public lazy var title: String = {
        quakeData.properties.title
    }()
}
</code></pre>
<p>This is my <code>ContentView</code>:</p>
<pre><code>struct EarthquakeView: View {
    @ObservedObject var viewModel: EarthquakeViewModel
    
    var body: some View {
        VStack {
            Text(viewModel.title)
//            makeMapView()
            Map(coordinateRegion: $viewModel.region)
        }
    }
}
</code></pre>
<p>// I tried this, too, but it doesn't work.</p>
<pre><code>extension EarthquakeView {
    @ViewBuilder func makeMapView() -&gt; some View {
        Map(coordinateRegion: $viewModel.region)
    }
}

</code></pre>
<h2>Update</h2>
<p>This is the message from Diagnostics. Cleaning derived data with Xcode closed doesn't seem to resolve it, so I think my issue lies with one of my declarations:</p>
<pre><code>RemoteHumanReadableError: Failed to update preview.

The preview process appears to have crashed.

Error encountered when sending 'render' message to agent.

==================================

|  RemoteHumanReadableError: The operation couldn’t be completed. (BSServiceConnectionErrorDomain error 3.)
|  
|  BSServiceConnectionErrorDomain (3):
|  ==BSErrorCodeDescription: OperationFailed
</code></pre>
<h2>Update 2</h2>
<p>I tweaked my data model and added a computed region var off of it, so here's how I'm getting the region now:</p>
<pre><code>extension Feature /* Feature is a Codable struct */ {
    var region: MKCoordinateRegion {
        let center = CLLocationCoordinate2D(latitude: geometry.coordinates[0],
                                            longitude: geometry.coordinates[1])
        let span = MKCoordinateSpan(latitudeDelta: 1.0, longitudeDelta: 1.0)
        let region = MKCoordinateRegion(center: center,
                                        span: span)
        
        return region
    }
}
</code></pre>
<p>At <a href=""https://stackoverflow.com/users/560942/jnpdx"">jnpdx's</a> suggestion, I updated the region on my view model to<code> @Published</code>.</p>
<pre><code>class EarthquakeViewModel: ObservableObject {
    `@Published private(set) var quakeData: Feature
    `@Published var region: MKCoordinateRegion
    
    init(quakeData: Feature) {
        self.quakeData = quakeData
        region = quakeData.region
    }
    
    public lazy var title: String = {
        quakeData.properties.title
    }()
}
</code></pre>
<p>And lastly, my View, as follows:</p>
<pre><code>struct EarthquakeView: View {
    @ObservedObject var viewModel: EarthquakeViewModel
    
    @State var region: MKCoordinateRegion
    
    init(viewModel: EarthquakeViewModel) {
        self.viewModel = viewModel
        _region = State(initialValue: viewModel.region)
    }
    
    var body: some View {
        VStack {
            Text(viewModel.title)
            Map(coordinateRegion: $region)
        }
    }
}
</code></pre>
<p>The new error is this. Closing Xcode, rebooting, cleaning derived data, etc. doesn't seem to resolve it, so I am quickly concluding I'm missing something basic:</p>
<blockquote>
<p>PreviewUpdateTimedOutError: Updating took more than 5 seconds Updating
a preview from EarthquakeView_Previews in CombineQuake.app (16766)
took more than 5 seconds.</p>
</blockquote>
<h2>Update 3</h2>
<p>Preview initialization:</p>
<pre><code>struct EarthquakeView_Previews: PreviewProvider {
    static var previews: some View {
        
        let quakeData = EarthQuakeData(mag: 6.5,
                                       place: &quot;32km W of Sola, Vanuatu&quot;,
                                       time: 1388592209000,
                                       updated: 1594407529032,
                                       tz: 660,
                                       url: &quot;https://earthquake.usgs.gov/earthquakes/eventpage/usc000lvb5&quot;,
                                       detail: &quot;https://earthquake.usgs.gov/fdsnws/event/1/query?eventid=usc000lvb5&amp;format=geojson&quot;,
                                       felt: nil,
                                       cdi: nil,
                                       mmi: nil,
                                       alert: nil,
                                       status: &quot;reviewed&quot;,
                                       tsunami: 1,
                                       sig: 650,
                                       net: &quot;us&quot;,
                                       code: &quot;c0001vb5&quot;,
                                       ids: &quot;,pt14001000,at00myqcls,usc000lvb5,&quot;,
                                       sources: &quot;pt,at,us&quot;,
                                       types: &quot;cap,geoserve,impact-link,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary&quot;,
                                       nst: nil,
                                       dmin: 3.997,
                                       rms: 0.76,
                                       gap: 14.0,
                                       magType: &quot;mww&quot;,
                                       type: &quot;earthquake&quot;,
                                       title: &quot;M 6.5 - 32km W of Sola, Vanuatu&quot;)
        let geometry = Geometry(type: &quot;Point&quot;,
                                coordinates: [167.249, -13.8633, 187.0])
        let earthquake = Feature(type: &quot;Feature&quot;,
                                 properties: quakeData,
                                 geometry: geometry,
                                 id: &quot;usc000lvb5&quot;)
        
        let viewModel = EarthquakeViewModel(quakeData: earthquake)
        
        
        EarthquakeView(viewModel: viewModel)
    }
}
</code></pre>
","4475605","","4475605","","2021-04-08 06:05:28","2021-04-08 06:25:29","Initializing Map from an Observable view model in SwiftUI","<swiftui><mapkit><combine>","1","5","","","","CC BY-SA 4.0"
"66999406","1","","","2021-04-08 07:42:26","","0","716","<p>When I delete the data from array, the operation is successful, but only the picture does not change. The image still remains in the cache. However, when I close and open the application, the application works fine.
how can i update the cache?</p>
<p><a href=""https://i.stack.imgur.com/EyvNX.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/EyvNX.gif"" alt=""enter image description here"" /></a></p>
<p><strong>Image Loader</strong></p>
<pre><code>import Combine

class ImageLoader: ObservableObject {
    @Published var image: UIImage?
    private let url: String
    private var cancellable: AnyCancellable?
    private var cache: ImageCache?
    
    init(url: String, cache: ImageCache? = nil) {
        self.url = url
        self.cache = cache
    }
    
    deinit {
        cancel()
    }
    
    func load() {
        
        guard let cacheURL = URL(string: url) else { return }
        if let image = cache?[cacheURL] {
            self.image = image
            return
        }
        
        guard let url = URL(string: url) else { return }
        
        cancellable = URLSession.shared.dataTaskPublisher(for: url)
            .map { UIImage(data: $0.data) }
            .replaceError(with: nil)
            .handleEvents(receiveOutput: { [weak self] in self?.cache($0) })
            .receive(on: DispatchQueue.main)
            .sink { [weak self] in self?.image = $0 }
    }
    
    private func cache(_ image: UIImage?) {
        guard let cacheURL = URL(string: url) else { return }
        image.map { cache?[cacheURL] = $0 }
    }
    
    func cancel() {
        cancellable?.cancel()
    }
}
</code></pre>
<p><strong>Async Image</strong></p>
<pre><code>import Combine

struct AsyncImage&lt;Placeholder: View&gt;: View {
    @StateObject private var loader: ImageLoader
    private let placeholder: Placeholder
    
    init(url: String, @ViewBuilder placeholder: () -&gt; Placeholder) {
        self.placeholder = placeholder()
        _loader = StateObject(wrappedValue: ImageLoader(url: url, cache: Environment(\.imageCache).wrappedValue))
    }
    
    var body: some View {
        content
            .onAppear(perform: loader.load)
    }
    
    private var content: some View {
        Group {
            if loader.image != nil {
                Image(uiImage: loader.image!)
                    .resizable()
            } else {
                placeholder
            }
        }
    }
}
</code></pre>
<p><strong>Image Cache</strong></p>
<pre><code>protocol ImageCache {
    subscript(_ url: URL) -&gt; UIImage? { get set }
}
</code></pre>
<p><strong>Temporary Image Cache</strong></p>
<pre><code>struct TemporaryImageCache: ImageCache {
    private let cache = NSCache&lt;NSURL, UIImage&gt;()
    
    subscript(_ key: URL) -&gt; UIImage? {
        get { cache.object(forKey: key as NSURL) }
        set { newValue == nil ? cache.removeObject(forKey: key as NSURL) : cache.setObject(newValue!, forKey: key as NSURL) }
    }
}
</code></pre>
<p><strong>Image Cache Key</strong></p>
<pre><code>struct ImageCacheKey: EnvironmentKey {
    static let defaultValue: ImageCache = TemporaryImageCache()
}

extension EnvironmentValues {
    var imageCache: ImageCache {
        get { self[ImageCacheKey.self] }
        set { self[ImageCacheKey.self] = newValue }
    }
}
</code></pre>
<p><strong>Async Image Using</strong></p>
<pre><code> VStack {
      ZStack(alignment: .bottomTrailing) {
                
           AsyncImage(url: &quot;image url&quot;) {
                Text(&quot;Loading&quot;)
            }
             .aspectRatio(contentMode: .fill)
             .frame(width: 120, height: 180, alignment: .center)
             .cornerRadius(15)
           ....
      }
}
</code></pre>
","13125522","","","","","2021-04-08 12:22:17","How can I remove a image from the cache with Combine in SwiftUI?","<swift><swiftui><combine><nscache>","0","2","","","","CC BY-SA 4.0"
"67005269","1","67009115","","2021-04-08 13:41:40","","1","438","<p>Does anybody have a working copy/sample of using AWS Amplify with the Combine framework?</p>
<p>The samples provided
<a href=""https://docs.amplify.aws/lib/datastore/data-access/q/platform/ios"" rel=""nofollow noreferrer"">https://docs.amplify.aws/lib/datastore/data-access/q/platform/ios</a>
<a href=""https://docs.amplify.aws/lib/auth/getting-started/q/platform/ios#configure-auth-category"" rel=""nofollow noreferrer"">https://docs.amplify.aws/lib/auth/getting-started/q/platform/ios#configure-auth-category</a>
Seems really straight forward and I'm using it verbatim, but since I'm not well versed in Combine, it could be that I'm losing the sink, especially when these functions are placed in an Observable class.</p>
<p>And when going with URL session, my attempts deliver a load of the same error:</p>
<p>Error Domain=NSCocoaErrorDomain Code=4099 &quot;The connection to service on pid 0 named com.apple.commcenter.coretelephony.xpc was invalidated from this process.&quot; UserInfo={NSDebugDescription=The connection to service on pid 0 named com.apple.commcenter.coretelephony.xpc was invalidated from this process.}</p>
","5944973","","","","","2022-01-25 21:16:48","AWS Amplify for Swift / SwiftUI under Combine framework cause headache","<swift><sample><combine><amplify>","2","0","","","","CC BY-SA 4.0"
"67017829","1","67017950","","2021-04-09 08:40:17","","1","367","<p>I'm new to Combine and I don't understand the behaviour in these cases:</p>
<pre><code>func getPublisherWithFirst() -&gt; AnyPublisher&lt;Value, Error&gt; {
    // somePublisher: PassthroughSubject&lt;Bool, Never&gt;
    return somePublisher
        .compactMap { (someBool) -&gt; Value? in
            if someBool {
                return Value()
            }
            return nil
        }
        .setFailureType(to: Error.self)
        .first()
        .timeout(.seconds(5), scheduler: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<pre><code>func getPublisherWithFlatMap() -&gt; AnyPublisher&lt;Value, Error&gt; {
    // somePublisher: PassthroughSubject&lt;Bool, Never&gt;
    return somePublisher
        .flatMap { (someBool) -&gt; AnyPublisher&lt;Value, Never&gt; in
            if someBool {
                return Just(Value()).eraseToAnyPublisher()
            }
            return Empty(completeImmediately: false, outputType: Value.self, failureType: Never.self).eraseToAnyPublisher()
        }
        .setFailureType(to: Error.self)
        .timeout(.seconds(5), scheduler: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>When using <code>getPublisherWithFlatMap</code>, my stream does not finish (the timeout is triggered), even if a <code>Just</code> publisher is returned and it is supposed to finish. Why?</p>
","1220867","","4667835","","2021-04-09 08:45:45","2021-04-09 08:49:28","Combine: difference between Just and first() to finish a stream","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"67037463","1","67037735","","2021-04-10 17:43:52","","4","262","<p>I'm very new to Swift. For learning purposes I'm creating a little countdown app (days until date X).
Those countdowns are presented in a List. A single countdown in the list is represented by the following view.</p>
<pre><code>struct CountdownRow: View {
  @State private var remainingDays: Int = 0
  @State private var progress: Float = 0.0
  
  var countdown: Countdown
  
  var body: some View {
    VStack{
      HStack {
        Text(countdown.name)
          .font(.subheadline)
          .multilineTextAlignment(.leading)
          .padding(10)
        Spacer()
        Text(String(remainingDays))
          .font(.headline)
          .padding(10)
      }
      ProgressView(value: progress)
        .padding(10)
    }
    .onAppear {
      remainingDays = countdown.getRemainingDays()
      progress = countdown.getProgress()
    }
    .onReceive(NotificationCenter.default.publisher(for:
        UIApplication.significantTimeChangeNotification), 
        perform: { _ in
      remainingDays = countdown.getRemainingDays()
      progress = countdown.getProgress()
    })
  }
}
</code></pre>
<p>I want to update the remaining days for each countdown at midnight. But the .onReceive modifier doesn't trigger when the time changes from 23:59 to 0:00.
Receiving other notifications (e.g. UIApplication.willEnterForegroundNotification) instead works as expected.</p>
<p>Why is this specific notification not emitted (or received) at midnight?
According to the documentation at apple, it should be emitted at midnight.</p>
<p>Thank you!</p>
","9786743","","9786743","","2021-04-10 17:59:04","2021-04-10 18:11:39","Why is significantTimeChangeNotification not emitted (or not received?)","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67048077","1","","","2021-04-11 17:22:18","","0","130","<p>I am new to Swift and all its frameworks. I have a JSON file with readings for each day of the year. I have made a <code>Decodable</code> struct for the reading and an <code>ObservableObject</code> class which stores the readings in an array. I have made the <code>ObservableObject</code> an <code>@EnvironmentObject</code> so it can be accessed in all views. Can I link the readings to the date picker so that selecting a date will take me to a detailed view?</p>
<pre><code>import SwiftUI

struct CalendarView: View {
    // this is where ObserveableObject is required
    @EnvironmentObject var days: Days
    
    @State private var date = Date()
    
    let dateFormatter: DateFormatter = {
       let formatter = DateFormatter()
        // formatter.dateStyle = .long
        formatter.dateFormat = &quot;LLLL d&quot;
        return formatter
    }()
    
    var body: some View {
        VStack {
            Text(&quot;Select a date to read&quot;)
                .font(.largeTitle)
            
            DatePicker(&quot;Select a date&quot;, selection: $date, displayedComponents: .date)
                .datePickerStyle(GraphicalDatePickerStyle())
                .labelsHidden()
                .frame(maxHeight: 400)
            
            Text(&quot;\(date, formatter: dateFormatter)&quot;)
        }
        .navigationTitle(&quot;Datepicker&quot;)
    }
}

struct CalendarView_Previews: PreviewProvider {
    static var previews: some View {
        CalendarView()
    }
}
</code></pre>
","14986859","","13886048","","2021-04-13 03:57:12","2021-04-13 03:57:12","Linking ObservableObject to DatePicker in SwiftUI","<swift><swiftui><datepicker><combine>","1","0","","","","CC BY-SA 4.0"
"67055876","1","","","2021-04-12 09:24:28","","0","56","<p>Parent view contains <code>SearchBar</code> and <code>ForEach</code> <code>List</code>, each item in the list is wrapped inside <code>NavigationLink</code> item, the issue is parent list. It is cleared after tapping <code>NavigationLink</code> inside <code>ForEach</code>, I've also added <code>UUID()</code> for <code>ForEach</code>, but same issue happens. I'm using Xcode 12.4 and same issue happens on iOS 13 and 14.</p>
<p><strong>SearchView</strong></p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI

struct SearchView: View {
  @ObservedObject var simpleSearchMV = SimpleSearchModelView()

  var body: some View {
    VStack{
      SearchBar(searchTerm: self.$simpleSearchMV.searchText)
        .padding(.vertical, 10)
      ScrollView(showsIndicators: false) {
        ForEach(simpleSearchMV.dataResult.result ?? [], id: \.self.Id) { item in
          NavigationLink(destination: OffersView()) {
            Text(item.currentName)
          }

          Divider()
        }
        .id(UUID())
      }
    }
  }
}
</code></pre>
<p><strong>SimpleSearchModelView</strong></p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine
import SwiftUI
import Alamofire

class SimpleSearchModelView: ObservableObject, Identifiable {

  @ObservedObject var monitor = NetworkMonitor()

  @Published var dataResult: DataResult&lt;[SearchSimpleResult]&gt; = DataResult(loading: false)
  @Published var searchText: String = String()

  private var subscription: Set&lt;AnyCancellable&gt; = []

  init() {
    self.setSearchText()
  }

  func setSearchText() {
    $searchText
      .debounce(for: .milliseconds(500), scheduler: RunLoop.main) // debounces the string publisher, such that it delays the process of sending request to remote server.
      .removeDuplicates()
      .map({ (string) -&gt; String? in
        if string.count &lt; 1 {
          // self.dataResult.setData([])
          return nil
        }
        return string
      }) // prevents sending numerous requests and sends nil if the count of the characters is less than 1.
      .compactMap{ $0 } // removes the nil values so the search string does not get passed down to the publisher chain
      .sink { (_) in
        //
      } receiveValue: { [self] (searchField) in
        searchItems(searchText: searchField)
      }.store(in: &amp;subscription)
  }

  func searchItems(searchText: String) {
    self.dataResult.loading = true
    let url = &quot;\(API.URL)\(searchText)&quot;
    AF.request(url,method: .get, encoding: JSONEncoding(),headers: DataService.getHeader())
      .publishData()
      .sink { _ in }receiveValue: { (response) in
        self.dataResult.loading = false
        self.dataResult.getResult(response.response, data: response.data)
        if self.dataResult.result == nil || self.dataResult.result != nil &amp;&amp; self.dataResult.result?.count == 0{
          self.dataResult.setError(errorObj: ErrorMessage(ErrorType.Empty.rawValue))
        }
      }
      .store(in: &amp;subscription)
  }
}
</code></pre>
","4020738","","8976","","2021-04-19 18:06:23","2021-04-19 18:06:23","SwiftUI NavigationLink clears parent view's data when navigate to detail view","<swiftui><combine><swiftui-navigationlink><swiftui-foreach>","1","0","","","","CC BY-SA 4.0"
"67072311","1","67073664","","2021-04-13 09:36:20","","1","1531","<p>I'm exploring Combine Swift with this project <a href=""https://github.com/sgl0v/TMDB"" rel=""nofollow noreferrer"">https://github.com/sgl0v/TMDB</a>
and I'm trying to replace its imageLoader with something that supports Combine: <a href=""https://github.com/JanGorman/MapleBacon"" rel=""nofollow noreferrer"">https://github.com/JanGorman/MapleBacon</a></p>
<p>The project has a function that returns the type <code>AnyPublisher&lt;UIImage?, Never&gt;</code>.
But the imageLoader MapleBacon library returns the type <code>AnyPublisher&lt;UIImage, Error&gt;</code>.</p>
<p>So I'm trying to convert types with this function:</p>
<pre><code>func convert(_ loader: AnyPublisher&lt;UIImage, Error&gt;) -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
    // here.
}
</code></pre>
<p>I actually found a question that is kinda similar to mine, but the answers weren't helpful:
<a href=""https://stackoverflow.com/a/58234908/3231194"">https://stackoverflow.com/a/58234908/3231194</a></p>
<hr />
<p>What I've tried to so far (Matt's answer to the linked question).</p>
<p>The sample project has this function:</p>
<pre><code>func loadImage(for movie: Movie, size: ImageSize) -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
        return Deferred { return Just(movie.poster) }
            .flatMap({ poster -&gt; AnyPublisher&lt;UIImage?, Never&gt; in
                guard let poster = movie.poster else { return .just(nil) }
                let url = size.url.appendingPathComponent(poster)
                let a = MapleBacon.shared.image(with: url)
                    .replaceError(with: UIImage(named: &quot;&quot;)!) // &lt;----
            })
            .subscribe(on: Scheduler.backgroundWorkScheduler)
            .receive(on: Scheduler.mainScheduler)
            .share()
            .eraseToAnyPublisher()
    }
</code></pre>
<p>if I do <code>replaceError</code>,</p>
<p>I get the type <code>Publishers.ReplaceError&lt;AnyPublisher&lt;UIImage, Error&gt;&gt;</code></p>
<hr />
<p>BUT, I was able to solve this one, by extending the library.</p>
<pre><code>extension MapleBacon {
    public func image(with url: URL, imageTransformer: ImageTransforming? = nil) -&gt; AnyPublisher&lt;UIImage?, Never&gt; {
      Future { resolve in
        self.image(with: url, imageTransformer: imageTransformer) { result in
          switch result {
          case .success(let image):
            resolve(.success(image))
          case .failure:
            resolve(.success(UIImage(named: &quot;&quot;)))
          }
        }
      }
      .eraseToAnyPublisher()
    }
}
</code></pre>
","3231194","","3231194","","2021-04-13 10:42:03","2021-04-13 11:05:06","Swift combine Convert Publisher type","<ios><swift><combine>","1","6","","","","CC BY-SA 4.0"
"67074601","1","67074936","","2021-04-13 12:11:16","","-2","239","<p>In an <a href=""https://www.cocoawithlove.com/blog/separated-services-layer.html"" rel=""nofollow noreferrer"">article</a>, I saw a code snippet like below:</p>
<pre><code>extension URLSessionDataTask: Cancellable {}

extension URLSession: NetworkService {
   public func fetchData(with request: URLRequest, handler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; AnyCancellable {
      let task = dataTask(with: request, completionHandler: handler)
      task.resume()
      return AnyCancellable(task)
   }
}
</code></pre>
<p>There are several things that I do not understand:</p>
<ol>
<li>What is the purpose of making URLSessionDataTask conform to 'Cancellable' protocol;</li>
<li>If URLSessionDataTask conforms to 'Cancellable' protocol, why does not it implement the methods that 'Cancellable' protocol requires;</li>
<li>When I check the initialiser of AnyCancellable, there is no initialiser which accepts an argument, so what does 'AnyCancellable(task)' do here and is it correct?</li>
</ol>
<p>Appreciate any help.</p>
","3690904","","","","","2021-04-13 12:31:40","A question about URLSessionDataTask and Combine in Swift","<ios><swift><combine><nsurlsessiondatatask>","1","2","1","","","CC BY-SA 4.0"
"67075023","1","","","2021-04-13 12:37:07","","0","2036","<p>I have a folder with 15 images and 1 audio file:</p>
<p>image_1.jpg, image_2.jpg, image_3.jpg ..... and music.webm</p>
<p>(Also resolution of images is 1440x720)</p>
<p>I want to combine these images into a video with audio in background.And framerate I require is 0.2 (5 second for each frame).I gave a search on Stackoverflow and I found the nearest example and tried.But it failed.</p>
<p><code>ffmpeg -f image2 -i image%03d.jpg -i music.webm output.mp4</code></p>
<p>(Actually I have very little knowledge of ffmpeg so please excuse my foolishness)</p>
<p>Please help me with my issue.(Also I didn't understood where in the code I have to enter framerate)</p>
<p>Edit:-If needed I can easily tweak with filename of images.Be free to tell me that too</p>
","14347880","","","","","2021-07-04 00:00:21","Combine images into video (with audio in background) in ffmpeg","<audio><video><ffmpeg><merge><combine>","2","0","","","","CC BY-SA 4.0"
"67076317","1","","","2021-04-13 13:57:02","","1","1160","<p>Followed refresh token strategy from this gist - <a href=""https://gist.github.com/saroar/ca78de9dc798cdbaaa47791380062596"" rel=""nofollow noreferrer"">https://gist.github.com/saroar/ca78de9dc798cdbaaa47791380062596</a></p>
<p>but couldn't get it working.</p>
<p><strong>Ideal flow</strong> - <code>run</code> function from <code>NetworkAgent</code> will make a call using the <code>tokenSubject</code> from <code>Authenticator</code>. If that call fails with authentication error, <code>refreshToken</code> function from Authenticator will be called. Now, when this refresh token call gets completed, the <code>tokenSubject</code> will send a value (check the receiveCompletion block of sink operator in <code>Authenticator</code>) which <code>NetworkAgent</code> has already subscribed in <code>run</code> function. Once the NetworkAgent receives this value from <code>tokenSubject</code> it will again execute that request in the <code>run</code> function.</p>
<p><strong>Bug</strong> - Once the 401 error is received, the refresh token request is made but after that completes successfully, failed request doesn't get retried. Seems like the value sent by the tokenSubject is not received by the subscriber may be due to some reference issue.</p>
<p>Please find my implementation below: -</p>
<p>This is the Network Agent that makes all the api calls -</p>
<pre><code>class NetworkAgent {
struct Response {
let value: T
let response: URLResponse
}
let authenticator = Authenticator()

func run&lt;T: Decodable&gt;(_ request: URLRequest) -&gt; AnyPublisher&lt;Response&lt;T&gt;, Error&gt; {
    let tokenSubject = authenticator.tokenSubject()
    // a better way to handle refresh token logic would be to use tryCatch operator suceeded by retry operator
    // should be done in one of the upcoming releases
    
    return tokenSubject
        .flatMap({ token -&gt; AnyPublisher&lt;Response&lt;T&gt;, Error&gt; in
            return URLSession.shared
                .dataTaskPublisher(for: request)
                .tryMap { [weak self] result -&gt; Response&lt;T&gt; in
                    self?.logResponse(result.response, request: request, data: result.data)
                    
                    // check for the response status
                    if let httpURLResponse = result.response as? HTTPURLResponse {
                        let networkResponse = APIClient.status(httpURLResponse)
                        switch networkResponse {
                        case .success: break
                            
                        case .failure(let error):
                            if error == HTTPURLResponseError.authenticationError {
                                // refresh token logic
                                if request.url?.absoluteString.contains(&quot;/auth/token/refresh&quot;) == false {
                                    self?.authenticator.refreshToken(using: tokenSubject)
                                }
                            } else {
                                throw error
                            }
                        }
                    }
                    
                    // map response and return in case of a successful request
                    let value = try JSONDecoder().decode(T.self, from: result.data)
                    return Response(value: value, response: result.response)
                }
                .retry(3)
                .receive(on: DispatchQueue.main)
                .eraseToAnyPublisher()
        })
        .handleEvents(receiveOutput: { _ in
            tokenSubject.send(completion: .finished)
        })
        .eraseToAnyPublisher()
}
}
</code></pre>
<p>And this is the Authenticator class implementation -</p>
<pre><code>class Authenticator {
//MARK:- Properties
private var disposables = Set()
private let queue = DispatchQueue(label: &quot;Autenticator.(UUID().uuidString)&quot;)

//MARK:- Functions
func refreshToken&lt;S: Subject&gt;(using subject: S) where S.Output == Bool {
    queue.sync {
        URLSession.shared
            .dataTaskPublisher(for: APIRouter.refreshToken.request()!)
            .retry(3)
            .sink { com in
                print(com)
                subject.send(true)
            } receiveValue: { data in
                print(#line, data)
                
                do {
                    let jsonDecoder2 = JSONDecoder()
                    let user = try jsonDecoder2.decode(User.self, from: data.data)
                    
                    LocalData.loggedInUser = user
                    LocalData.token = user.token
                    
                } catch  {
                    print(#line, error)
                }
                
            }
            .store(in: &amp;disposables)
    }
}

func tokenSubject() -&gt; CurrentValueSubject&lt;Bool, Never&gt; {
    return CurrentValueSubject(true)
}
}
</code></pre>
<p>Any input would be greatly appreciated.</p>
","6152094","","6152094","","2021-04-14 11:15:04","2021-06-29 11:59:34","Refresh Token Mechanism with Combine framework iOS","<ios><swift><combine>","0","4","1","","","CC BY-SA 4.0"
"67082694","1","","","2021-04-13 21:34:28","","0","498","<p>Lets assume I have a <code>ViewControllerA</code> that presents <code>ViewControllerB</code> and I want to subscribe to a button tap. I can do something like this:</p>
<pre><code>public class ViewControllerB {
    public var didTapButton = PassthroughSubject&lt;Void, Never&gt;()
    ...

    func buttonTapped() {
        didTapButton.send(completion: .finished)
    }
}
</code></pre>
<p>then subscribe to <code>didTapButton</code> in <code>ViewControllerA</code> with <code>sink</code>.</p>
<p>If I want to do the same with <code>@Published</code> variable, all I can think of is doing this:</p>
<pre><code>public class ViewControllerB {
    @Published public var didTapButton: Void?
    ...

    func buttonTapped() {
        didTapButton = ()
    }
}
</code></pre>
<p>Does this make sense? or is there better way to do this?</p>
","3423468","","3423468","","2021-04-13 22:51:49","2021-04-13 22:51:49","What is the correct way of using void @Published variables in combine?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67099143","1","67099668","","2021-04-14 21:09:55","","2","817","<p>I am using Swift Combine and would like to make a <code>Publisher</code> that was created from an array of <code>Publisher</code>. It should emit an array of elements every time one of the Publishers in the array emits a new element.</p>
<p>In <code>RxSwift</code> would be like the following:</p>
<pre class=""lang-swift prettyprint-override""><code> let obs1 = PublishSubject&lt;Int&gt;()
 let obs2 = PublishSubject&lt;Int&gt;()
 let arrayObs = [obs1, obs2)]

 Observable.combineLatest(arrayObs)
    .subscribe(onNext: { arrayOfLatest in
        print(arrayOfLatest) //prints an array of integers
    }).disposed(by: disposeBag)

obs1.onNext(5) 
obs2.onNext(10) // prints [5,10]
obs1.onNext(12) // prints [12,10]

</code></pre>
","7969193","","","","","2021-05-04 14:47:53","How to make a Publisher from array of Publishers?","<ios><swift><reactive-programming><combine>","2","0","1","","","CC BY-SA 4.0"
"67110487","1","67110788","","2021-04-15 14:34:24","","0","61","<p>I am trying with combine to manage my socket &amp; handle messages</p>
<pre><code>private var garbageBag = Set&lt;AnyCancellable&gt;()

func setupSocket() {
  
    
    SocketHelper.shared.startListene()
  
    garbageBag.forEach{$0.cancel()}
    
    SocketHelper.shared.publisher.sink {[unowned self] (sub) in
        print(sub)
        print(&quot;FINISH &quot;)

    } receiveValue: {[unowned self] (value) in
        print(&quot;SUBSCRBE GOT VALUE &quot;)
      
     }.store(in: &amp;garbageBag)

}
</code></pre>
<p>This method call several times, so sink is also called many times to prevent that I have written like and it solves problem</p>
<pre><code>    garbageBag.forEach{$0.cancel()}
</code></pre>
<p>But Now suppose 4 time this method will be called so in <code>garbageBag</code> there will be 4 Items</p>
<p>How can I remove canceled items</p>
<p>I know directly empty the Set is one solution but is there any way to check ?</p>
","4601900","","","","","2021-04-15 14:53:35","Find Canceled Publisher Combine","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67113778","1","","","2021-04-15 18:05:03","","2","3047","<p>I am trying to merge multiple publishers that are of different types.</p>
<p>I have publishers of type string and a publisher of type, however when I merge them using <code>MergeMany</code> or <code>CombineLatest</code> I get a type mismatch error.</p>
<p>Is there anyway to merge publishers of different types? See the code example below:</p>
<pre class=""lang-swift prettyprint-override""><code>@Published var str1: String?
@Published var str2: String?
@Published var image: Image?
        
Publishers.MergeMany($str1, $str2, $image)
    .removeDuplicates()
    .sink { _ in
        //...
    }
    .store(in: &amp;bag)
</code></pre>
","15333472","","1974224","","2021-10-21 19:39:47","2021-10-21 19:39:47","Swift Combine: Merge publishers of different types","<swift><swiftui><combine>","2","3","","","","CC BY-SA 4.0"
"67128650","1","67131295","","2021-04-16 16:08:31","","0","625","<p>According to Apple, <a href=""https://developer.apple.com/documentation/combine/fail/receive(on:options:)"" rel=""nofollow noreferrer""><code>receive(on:options:)</code></a> runs callbacks on a given queue. We use a serial dispatch queue to prevent racing on <code>localOptionalCancellable</code> in the code below. But <code>receiveCancel</code> is not getting dispatched to that queue. Can someone tell me why?</p>
<p>From the documentation,</p>
<blockquote>
<p>You use the receive(on:options:) operator to receive results and completion on a specific scheduler, such as performing UI work on the main run loop.</p>
<p>...</p>
<p>Prefer receive(on:options:) over explicit use of dispatch queues when performing work in subscribers. For example, instead of the following pattern:</p>
</blockquote>
<h3>Issue Reproduction:</h3>
<pre><code>import Foundation
import Combine

class Example {
    private var localOptionalCancellable: AnyCancellable?
    private let dispatchQueue = DispatchQueue(label: &quot;LocalQueue-\(UUID())&quot;)
    
    func misbehavingFunction() {
        self.dispatchQueue.async {
            self.localOptionalCancellable = Just(())
                .setFailureType(to: Error.self)
                .receive(on: self.dispatchQueue)
                .handleEvents(
                    receiveCancel: {
                        // Simultaneous accesses to 0x600000364e10, but modification requires exclusive access.
                        // Can be fixed by wrapping in self.dispatchQueue.async {}
                        self.localOptionalCancellable = nil
                    }
                )
                .sink(
                    receiveCompletion: { _ in },
                    receiveValue: { _ in
                        self.localOptionalCancellable = nil
                    }
                )
        }
    }
}

Example().misbehavingFunction()
</code></pre>
<h3>Stack Trace:</h3>
<pre><code>Simultaneous accesses to 0x600000364e10, but modification requires exclusive access.
Previous access (a modification) started at  (0x10eeaf12a).
Current access (a modification) started at:
0    libswiftCore.dylib                 0x00007fff2ff7be50 swift_beginAccess + 568
3    Combine                            0x00007fff4ba73a40 Publishers.HandleEvents.Inner.cancel() + 71
4    Combine                            0x00007fff4ba74230 protocol witness for Cancellable.cancel() in conformance Publishers.HandleEvents&lt;A&gt;.Inner&lt;A1&gt; + 16
5    Combine                            0x00007fff4b9f10c0 Subscribers.Sink.cancel() + 652
6    Combine                            0x00007fff4b9f1500 protocol witness for Cancellable.cancel() in conformance Subscribers.Sink&lt;A, B&gt; + 16
7    Combine                            0x00007fff4b9dd2d0 AnyCancellable.cancel() + 339
8    Combine                            0x00007fff4b9dd5f0 AnyCancellable.__deallocating_deinit + 9
9    libswiftCore.dylib                 0x00007fff2ff7da20 _swift_release_dealloc + 16
13   Combine                            0x00007fff4b9f0da0 Subscribers.Sink.receive(_:) + 54
14   Combine                            0x00007fff4b9f14c0 protocol witness for Subscriber.receive(_:) in conformance Subscribers.Sink&lt;A, B&gt; + 16
15   Combine                            0x00007fff4ba73ed0 Publishers.HandleEvents.Inner.receive(_:) + 129
16   Combine                            0x00007fff4ba74170 protocol witness for Subscriber.receive(_:) in conformance Publishers.HandleEvents&lt;A&gt;.Inner&lt;A1&gt; + 16
17   Combine                            0x00007fff4ba26440 closure #1 in Publishers.ReceiveOn.Inner.receive(_:) + 167
18   libswiftDispatch.dylib             0x000000010e97cad0 thunk for @escaping @callee_guaranteed () -&gt; () + 14
19   libdispatch.dylib                  0x00007fff20105323 _dispatch_call_block_and_release + 12
20   libdispatch.dylib                  0x00007fff20106500 _dispatch_client_callout + 8
21   libdispatch.dylib                  0x00007fff2010c12e _dispatch_lane_serial_drain + 715
22   libdispatch.dylib                  0x00007fff2010cde1 _dispatch_lane_invoke + 403
23   libdispatch.dylib                  0x00007fff20117269 _dispatch_workloop_worker_thread + 782
24   libsystem_pthread.dylib            0x00007fff6116391b _pthread_wqthread + 290
25   libsystem_pthread.dylib            0x00007fff61162b68 start_wqthread + 15
Fatal access conflict detected.
</code></pre>
","7946143","","7946143","","2021-04-16 18:27:44","2021-04-16 19:41:33","Combine's receive(on:) not dispatching to serial queue, causing data race","<ios><swift><xcode><multithreading><combine>","1","9","","","","CC BY-SA 4.0"
"67128980","1","","","2021-04-16 16:31:17","","0","91","<p>Assume the following simplified code-snippet</p>
<pre><code>import Foundation
import Combine

public class NetworkFetch {
  fileprivate var networkPipelines : Set&lt;AnyCancellable&gt; = []
  
  public func loadDataFor(url : URL)
  { 
    URLSession.shared.dataTaskPublisher(for: url)
      .map { $0.data }
      .decode(type: City.self, decoder: JSONDecoder())
      .eraseToAnyPublisher()
      .sink(receiveCompletion: {_ in print(&quot;Finish&quot;)},
            receiveValue: { v in
              print(&quot;\(c)\n&quot;)
            }
      )
      .store(in: &amp;networkPipelines)
  }
}
</code></pre>
<p>For each call of loadDataFor a new combine-pipeline is generated and added to the networkPipelines container. This container grows over time.</p>
<p>What is the correct way to remove such an URLSession-pipeline from this container as soon as all data is fetched by the URLSession-pipeline?</p>
","4673352","","1161484","","2021-08-31 05:20:04","2021-09-03 19:00:36","Combine - Remove pipeline from container","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"67133680","1","67218104","","2021-04-17 00:44:14","","5","381","<p>I have a Combine function that I use to search through a list of items and return matches. It keeps track of not only what items to show the user that match the search term, but also what items have been marked as &quot;chosen&quot; by the user.</p>
<p>The function works great, including animations, until I add either <code>.debounce(for: .seconds(0.2), scheduler: RunLoop.main)</code> <em>or</em> <code>.receive(on: RunLoop.main)</code> in the Combine publisher chain. At that point, the rendering of the results in the <code>View</code> get inexplicably strange -- item titles start showing up as header views, items are repeated, etc.</p>
<p>You can see the result in the accompanying GIF.</p>
<img src=""https://i.stack.imgur.com/q891n.gif"" width=""200""/>
<p>The GIF version is using <code>.receive(on: RunLoop.main)</code>. Note I don't even use the search term here, although it <em>also</em> leads to funny results. It also may be worth noting that everything works correctly <em>with</em> the problem lines if <code>withAnimation { }</code> is removed.</p>
<p>I'd like to be able to use <code>debounce</code> as the list may eventually be pretty large and I don't want to filter the whole list on every keystroke.</p>
<p><strong>How can I get the table view to render correctly under these circumstances?</strong></p>
<p>Example code (see inline comments for the pain points and explanation of the code. It should run well as written, but if either of the two relevant lines is uncommented) :</p>
<pre><code>
import SwiftUI
import Combine
import UIKit

class Completer : ObservableObject {
    @Published var items : [Item] = [] {
        didSet {
            setupPipeline()
        }
    }
    @Published var filteredItems : [Item] = []
    @Published var chosenItems: Set&lt;Item&gt; = []
    @Published var searchTerm = &quot;&quot;
    
    private var filterCancellable : AnyCancellable?
    
    private func setupPipeline() {
        filterCancellable =
            Publishers.CombineLatest($searchTerm,$chosenItems) //listen for changes of both the search term and chosen items
            .print()
            // ** Either of the following lines, if uncommented will cause chaotic rendering of the table **
            //.receive(on: RunLoop.main) //&lt;----- HERE --------------------
            //.debounce(for: .seconds(0.2), scheduler: RunLoop.main) //&lt;----- HERE --------------------
            .map { (term,chosen) -&gt; (filtered: [Item],chosen: Set&lt;Item&gt;) in
                if term.isEmpty { //if the term is empty, return everything
                    return (filtered: self.items, chosen: chosen)
                } else { //if the term is not empty, return only items that contain the search term
                    return (filtered: self.items.filter { $0.name.localizedStandardContains(term) }, chosen: chosen)
                }
            }
            .map { (filtered,chosen) in
                (filtered: filtered.filter { !chosen.contains($0) }, chosen: chosen) //don't include any items in the chosen items list
            }
            .sink { [weak self] (filtered, chosen) in
                self?.filteredItems = filtered
            }
    }
    
    func toggleItemChosen(item: Item) {
        withAnimation {
            if chosenItems.contains(item) {
                chosenItems.remove(item)
            } else {
                searchTerm = &quot;&quot;
                chosenItems.insert(item)
            }
        }
    }
}

struct ContentView: View {
    @StateObject var completer = Completer()
    
    var body: some View {
        Form {
            Section {
                TextField(&quot;Term&quot;, text: $completer.searchTerm)
            }
            Section {
                ForEach(completer.filteredItems) { item in
                    Button(action: {
                        completer.toggleItemChosen(item: item)
                    }) {
                        Text(item.name)
                    }.foregroundColor(completer.chosenItems.contains(item) ? .red : .primary)
                }
            }
            if completer.chosenItems.count != 0 {
                Section(header: HStack {
                    Text(&quot;Chosen items&quot;)
                    Spacer()
                    Button(action: {
                        completer.chosenItems = []
                    }) {
                        Text(&quot;Clear&quot;)
                    }
                }) {
                    ForEach(Array(completer.chosenItems)) { item in
                        Button(action: {
                            completer.toggleItemChosen(item: item)
                        }) {
                            Text(item.name)
                        }
                    }
                }
            }
        }.onAppear {
            completer.items = [&quot;Chris&quot;, &quot;Greg&quot;, &quot;Ross&quot;, &quot;Damian&quot;, &quot;George&quot;, &quot;Darrell&quot;, &quot;Michael&quot;]
                .map { Item(name: $0) }
        }
    }
}

struct Item : Identifiable, Hashable {
    var id = UUID()
    var name : String
}

</code></pre>
","560942","","560942","","2021-04-17 01:06:27","2022-03-18 18:15:52","Combine + SwiftUI Form + RunLoop causes table view to render unpredictably","<swiftui><combine>","2","14","","","","CC BY-SA 4.0"
"67139077","1","67146446","","2021-04-17 14:09:42","","0","106","<p>I'm trying to instantiate a user profile based on the logged in user from my AuthenticationState class (using Firebase Auth). This user profile is part of my UserProfileViewModel, which should power a view for editing the user's profile.</p>
<p>But it appears that the loggedInUser is still seen as nil when the UserProfileViewModel is instantiated, and I'm not sure if there's a way I can use a Combine subscription from another class like this to make sure I'm subscribed to the loggedInUser published variable of that specific instance of Authentication state.</p>
<p>Authentication state is called by my main app file, as an environment object - once the user logs in, the loggedInUser is set to that Firebase Auth user:</p>
<pre><code>class AuthenticationState: NSObject, ObservableObject {
    
    // The firebase logged in user, and the userProfile associated with the users collection
    @Published var loggedInUser: User?
    
    
    @Published var isAuthenticating = false
    @Published var error: NSError?
    
    static let shared = AuthenticationState()
    
    private let auth = Auth.auth()
    fileprivate var currentNonce: String?
</code></pre>
<p>I initialize AuthenticationState in my main app file:</p>
<pre><code>@main
struct GoalTogetherApp: App {

    let authState: AuthenticationState
    
    init() {
        FirebaseApp.configure()
        self.authState = AuthenticationState.shared
        
        setupFirebase()
    }
 
 
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(authState)
        }
    }
}
</code></pre>
<p>And I have this other class that I want to grab the loggedInUser, and then use that user's uid to create or find a userProfile from Cloud Firestore:</p>
<pre><code>class UserProfileViewModel: ObservableObject {
    
    @Published var loggedInUser: User?
    @Published var userProfile: UserProfile?
    
    private let auth = Auth.auth()
    private let db = Firestore.firestore()
    
    init() {
        self.loggedInUser = AuthenticationState.shared.loggedInUser
        
        if self.loggedInUser != nil {
            self.userProfile = self.loadUser()
        }
    }
</code></pre>
<p>And the Profile page is supposed to grab that and pull the email from the UserProfile, but it keeps coming up as blank:</p>
<pre><code>struct ProfilePage: View {
    @ObservedObject var userProfileVM = UserProfileViewModel()
    
    @State var email: String = &quot;&quot;
    
    init() {
        print(&quot;User Profile VM equals: \(String(describing: userProfileVM.userProfile))&quot;)
        if userProfileVM.userProfile?.email != nil {
            _email = State(initialValue: userProfileVM.userProfile!.email!)
        } else {
            _email = State(initialValue: &quot;&quot;)
        }
    }
</code></pre>
","13831483","","","","","2021-04-18 08:15:18","Subscribing to a user variable from my authentication class in an unrelated ViewModel - Swift/Combine","<swift><firebase-authentication><combine>","1","2","","","","CC BY-SA 4.0"
"67144699","1","","","2021-04-18 02:31:49","","0","56","<p>For some reason when using a shared publisher flatMap behaves strangely. Instead of receiving all the values I am only getting one. I am mimicking my app's logic in the following example, where a flat mapped publisher sends values on a different queue.</p>
<p>Any ideas why the share logic could have this effect?</p>
<pre><code># swift playground 

import Combine
import XCTest


let shared = (0..&lt;10).publisher
    .share()

let sub = shared
    .flatMap(maxPublishers: .max(1)) { Just($0).subscribe(on: DispatchQueue.global()) }
    .sink { value in
        print(&quot;\(value)&quot;)
    }

print(&quot;waiting...&quot;)
_ = XCTWaiter.wait(for: [XCTestExpectation(description: &quot;test&quot;)], timeout: 2)
print(&quot;done&quot;)
</code></pre>
<p>Here is the output for the playground code</p>
<pre><code>0
waiting...
done

</code></pre>
<p>However if I comment out .share() then everything works as expected, meaning I receive all the 10 values. The output is</p>
<pre><code>0
1
2
3
4
waiting...
5
6
7
8
9
done

</code></pre>
","14610630","","","","","2021-04-18 03:20:55","Using flatMap on a shared publisher leads to data loss","<swift><combine>","1","0","1","2021-04-18 20:29:20","","CC BY-SA 4.0"
"67153619","1","67185880","","2021-04-18 21:39:28","","-1","1072","<p>I want to transform a Publisher to another one but I'm having an error <code>Cannot convert return expression of type 'AnyPublisher&lt;LoginState, LoginRepositoryError&gt;' to return type 'AnyPublisher&lt;LoginState, Never&gt;'</code></p>
<p>Is my approach feasible?, I have the following code:</p>
<pre><code>public protocol LoginUseCase {
    func login(email: String, password: String) -&gt; AnyPublisher&lt;Bool, LoginRepositoryError&gt;
}
</code></pre>
<p>MyViewmodel.swift</p>
<pre><code>public func login(email: String?, password: String?) -&gt; AnyPublisher&lt;LoginState, Never&gt; {
    guard let email=email, !email.isEmpty else {
        return Just&lt;LoginState&gt;(.invalidEmail).eraseToAnyPublisher()
    }
    guard let password=password, !password.isEmpty else {
        return Just&lt;LoginState&gt;(.invalidPassword).eraseToAnyPublisher()
    }
    
    return loginUseCase.login(email: email, password: password)
        .map { result in
            let subject = PassthroughSubject&lt;LoginState, Never&gt;()
            switch result {
            case .success(_):
                subject.send(.success)
                break
            case .failure(let error):
                switch error {
                case .wrongPassword:
                    subject.send(.wrongPassword)
                case .userNotExist:
                    subject.send(.error)
                case .emailValidationPending:
                    subject.send(.emailValidationPending)
                }
            }
            return subject.eraseToAnyPublisher()
        }.eraseToAnyPublisher()
}
</code></pre>
","2139691","","","","","2021-04-20 20:26:04","Combine: Transform an AnyPublisher into a another AnyPublisher","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67182853","1","","","2021-04-20 16:31:10","","2","245","<p>I'm using <code>CurrentValueSubject</code> to populate a diffabledatasource table.</p>
<p>How can I catch the error?</p>
<p><code>var strings = CurrentValueSubject&lt;[String], Error&gt;([String]())</code></p>
<pre><code>viewModel.strings
    .receive(on: DispatchQueue.main)
    .sink(receiveCompletion: {
        print(&quot;completion \($0)&quot;)
    }, receiveValue: { [weak self] in
        self?.applySnapshot()
    })
    .store(in: &amp;cancellables)
</code></pre>
<p>Now receiveCompletion receives the error, but <a href=""https://www.avanderlee.com/swift/combine-error-handling/"" rel=""nofollow noreferrer"">https://www.avanderlee.com/swift/combine-error-handling/</a> mentions using <code>.catch</code> but I can't see that this works in this case?</p>
","11076699","","11076699","","2021-04-20 16:46:14","2021-04-20 16:47:22","How can subscriber for CurrentValueSubject catch an error","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"67194514","1","","","2021-04-21 10:59:54","","0","446","<p>I have one publisher
<code>public let motionSubject = PassthroughSubject&lt;Bool, Never&gt;()</code></p>
<p>And i am listening values with</p>
<pre><code>motionManager.motionSubject.sink(receiveValue: { [weak self] isMoving in
    self?.isMoving = isMoving
}).store(in: &amp;subscription)
</code></pre>
<p>I want to add 2 seconds delay if the published value is &quot;true&quot; because I want to give 2 seconds sound feedback.</p>
<p>I tried to add DispatchQueue.asynafter before motionSubject.send(true) but it didn't work.</p>
<p>Is anyone know how can i achieve this?</p>
<p>Thanks.</p>
","4253266","","4667835","","2021-04-21 11:03:27","2021-04-21 19:05:55","Add delay to publisher based on value with Combine Framework in iOS","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"67195862","1","67196018","","2021-04-21 12:21:50","","0","45","<p>Simple question, but struggling a while with it.</p>
<p>I have a web request, where I fetch an array of strings: <code>['a','b','c']</code></p>
<p>So to speak I have a <code>CurrentValueSubject</code> of <code>['a','b','c']</code>. I would like to create a downstream, where the elements then go one by one, how to achieve that?</p>
<p>Combine Framework stream transformation <code>['a','b','c']</code> -&gt; <code>'a'</code> then <code>'b'</code> then <code>'c'</code></p>
","1003641","","15407542","","2021-04-21 12:31:32","2021-04-21 12:32:42","Combine Framework stream transformation ['a','b','c'] -> 'a' then 'b' then 'c'","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67203284","1","","","2021-04-21 20:48:35","","3","541","<p>I have a <code>SettingsManager</code> singleton for my entire app that holds a bunch of user settings. And I've got several <code>ViewModel</code>s that reference and can edit the <code>SettingsManager</code>.</p>
<p>The app basically looks like this...</p>
<pre class=""lang-swift prettyprint-override""><code>import PlaygroundSupport
import Combine
import SwiftUI

class SettingsManager: ObservableObject {
    static let shared = SettingsManager()

    @AppStorage(&quot;COUNT&quot;) var count = 10
}

class ViewModel: ObservableObject {
    @Published var settings = SettingsManager.shared
    
    func plus1() {
        settings.count += 1
        objectWillChange.send()
    }
}

struct ContentView: View {
    @StateObject var viewModel = ViewModel()
    var body: some View {
        VStack {
            Button(action: viewModel.plus1) {
                Text(&quot;\(viewModel.settings.count)&quot;)
            }
        }
    }
}

let viewController = UIHostingController(rootView: ContentView())

PlaygroundPage.current.liveView = viewController
</code></pre>
<p><strong>Frustratingly, it works about 85% of the time</strong>. But 15% of the time, the values don't update until navigating away from the view and then back.</p>
<p>How can I get @AppStorage to play nice with my View Model / MVVM framework?!</p>
","3731467","","3731467","","2021-04-21 21:05:49","2022-07-26 19:00:22","How can I get @AppStorage to work in an MVVM / SwiftUI framework?","<swift><swiftui><combine>","2","5","","","","CC BY-SA 4.0"
"67216064","1","67217168","","2021-04-22 15:14:15","","0","133","<p>I have two types</p>
<pre><code>let left: Future&lt;[Int]&gt;
let right: Future&lt;[Int]&gt;
</code></pre>
<p>How can I combine these so I have one contiguous 1D array?</p>
<p>Using <code>append</code> and <code>merge</code> create 2D arrays and there's no clear information. Is really the best way to collect the 2D arrays and then use a flatMap inside of a flatMap like:</p>
<pre><code>.collect().flatMap { arrays in arrays.flatMap { $0 } }
</code></pre>
<p>there has to be a better way.</p>
","2611971","","","","","2021-04-22 18:26:04","Merge two Combine Arrays into a Single Array","<arrays><swift><combine><flatmap>","1","3","","","","CC BY-SA 4.0"
"67216664","1","67216901","","2021-04-22 15:50:05","","0","173","<p>I have problem with catching notifications from default <code>NotificationCenter</code>. Sometimes it does not receive it at all.</p>
<p>Code example below:</p>
<pre><code>NotificationCenter.default.publisher(for: Notifications.userNotification)
    .removeDuplicates()
    .receive(on: DispatchQueue.main)
    .sink { self.handle(notification: $0) }
    .store(in: &amp;subscriptions)
</code></pre>
<p>As soon as I remove <code>.removeDuplicates()</code> line it starts to receive all notifications.
The question is: do I really need this line? Is it really helpful/important?
I was searching for good example with <code>.removeDuplicates()</code> usage for <code>NotificationCenter</code>, but could not find anything.
Could someone explain me, why it is like that?</p>
<p><strong>Update</strong>:</p>
<p>In my case the <code>Notification</code>s used for navigation inside the app. It has <code>userInfo</code> dictionary with information like: <code>[&quot;navigateTo&quot; : &quot;viewControllerTypeShoppingCart&quot;]</code> or <code>[&quot;navigateTo&quot; : &quot;viewControllerTypeWishList&quot;]</code></p>
","5381903","","5381903","","2021-04-23 06:17:59","2021-04-23 06:17:59","Handle notifications with Combine in Swift with removeDuplicated() sometimes does not cache notifications","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67223472","1","67223831","","2021-04-23 03:09:52","","-1","291","<p>I am new to combine and i am trying write the network layer for my App.</p>
<p>My network call is</p>
<pre><code>protocol NetworkRequest {
    associatedtype model
    func decode(_ data:Data) -&gt; AnyPublisher&lt;model,Error&gt;
}

extension NetworkRequest {

 fileprivate func load&lt;model&gt;(_ url:URL, session:NetworkSession = URLSession.shared) -&gt; AnyPublisher&lt;model,Error&gt; {
    
    return session.loadData(for: URLRequest(url: url))
        .mapError { error in
            .network(description: error.localizedDescription)
        }
        .flatMap(maxPublishers: .max(1)) { pair in
            self.decode(pair.data)
        }
        .eraseToAnyPublisher()
        
 }

}
</code></pre>
<p>my decode method is</p>
<pre><code>func decode(_ data:Data) -&gt; AnyPublisher&lt;model,Error&gt;
</code></pre>
<p>and my session.loadData is</p>
<pre><code>func loadData(for URLRequest: URLRequest) -&gt; AnyPublisher&lt;(data: Data, response: URLResponse), URLError&gt;
</code></pre>
<p>The problem is i am getting an error <code>Type of expression is ambiguous without more context</code></p>
<p>I am not exactly sure what i am doing wrong here. I simply want to use the decode method to get a publisher.</p>
","11975968","","11975968","","2021-04-23 07:31:51","2021-04-23 12:55:15","Converting one publisher into another publisher in Combine","<ios><swift><combine>","1","4","","","","CC BY-SA 4.0"
"67225254","1","67232083","","2021-04-23 06:51:33","","0","473","<p><em>Realm 10.7.3, Xcode 12.4, macOS 11.2.3</em></p>
<p>I am experimenting with Realm and Combine+SwiftUI. When I make changes to my data in Realm Studio, they immediately reflect in my app's UI as expected. But when I <strong>add</strong> or <strong>delete</strong> an object, my app UI does not change.</p>
<p>Here's my model definition:</p>
<pre><code>//--- Model ---
class Item: Object, ObjectKeyIdentifiable {
  @objc dynamic var _id = ObjectId.generate()
  @objc dynamic var text = &quot;&quot;
}
</code></pre>
<p>Here's my view model:</p>
<pre><code>//--- View Model ---
class ItemModel: ObservableObject {
  static let shared = ItemModel()
  var token: NotificationToken? = nil
  @Published var items = [Item]()
  
  init(){
    let realm = try! Realm()
    let results = realm.objects(Item.self)
    items = Array(results)
   
    token = results.observe { [weak self] _ in
      print(&quot;-- updated --&quot;)
      self?.objectWillChange.send()
    }
  }
  
  deinit{
    token?.invalidate()
  }
}
</code></pre>
<p>And last of all, here's my SwiftUI view:</p>
<pre><code>//--- View ---
struct ItemView: View {
  @StateObject private var model = ItemModel.shared

  var body: some View {
    ScrollView{
      VStack(spacing: 7){
        ForEach(model.items, id: \._id) { item in
          Text(item.text)
        }
      }
    }
  }
}
</code></pre>
<p>Any ideas why my app won't show new/deleted objects and only edits? If I rebuild my app, the new/deleted objects are shown.</p>
","1142348","","","","","2021-10-18 18:35:56","SwiftUI App Shows Realm Changes but Not New Objects","<swiftui><realm><combine>","1","0","1","","","CC BY-SA 4.0"
"67238880","1","67238915","","2021-04-24 02:47:05","","0","124","<p><a href=""https://i.stack.imgur.com/LX3S0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LX3S0.png"" alt=""enter image description here"" /></a></p>
<p>How can I make the sign in view expand so that its left side is constrained to the left side and its right side is constrained to the right side as well?</p>
<pre><code>
import SwiftUI

struct Intro: View {
    var body: some View {
        ZStack {
            Image(&quot;IntroImage&quot;)
                .resizable()
                .aspectRatio(contentMode: .fill)
                .frame(alignment: .center)
            VStack {
                Spacer()
                Button(action: {}, label: {
                    Text(&quot;Sign in&quot;)
                        .foregroundColor(Color.black)
                        .padding()
                        .background(Color.green)
                })
            }
        }
        .ignoresSafeArea()
    }
}

struct Intro_Previews: PreviewProvider {
    static var previews: some View {
        Intro()
    }
}
</code></pre>
<p>I want it to look like this: <a href=""https://i.stack.imgur.com/IEfkY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IEfkY.png"" alt=""enter image description here"" /></a></p>
<p>I am using a 640 × 1136 png for the image. I am testing it on all devices including iPhone 11.</p>
","3833666","","3833666","","2021-04-24 05:26:14","2021-04-24 05:26:14","How to make a button in front of an image but constrained to the left bottom and right of the view in SwiftUI?","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67239037","1","67239106","","2021-04-24 03:20:29","","1","75","<p>I am new to Combine/now learning the operators,
I followed the example in the apple developer docs but the output was different in playground
<a href=""https://developer.apple.com/documentation/combine/publisher/max(by:)"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/combine/publisher/max(by:)</a>
<a href=""https://i.stack.imgur.com/Xdsb4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Xdsb4.png"" alt=""enter image description here"" /></a>
//the website shows</p>
<pre><code>enum Rank: Int {
    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
}

let cards: [Rank] = [.five, .queen, .ace, .eight, .jack]
cancellable = cards.publisher
    .max {
        return  $0.rawValue &gt; $1.rawValue
    }
    .sink { print(&quot;\($0)&quot;) }

// Prints: &quot;queen&quot;

</code></pre>
<p>my playground shows:</p>
<pre><code>import Combine

enum Rank: Int {
    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
}

let cards: [Rank] = [.five, .queen, .ace, .eight, .jack]
cards.publisher
    .max {
        return  $0.rawValue &gt; $1.rawValue
    }
    .sink { print(&quot;\($0)&quot;) }
//Prints: &quot;ace&quot;
</code></pre>
<p>I tried to solve the &quot;most common name in an array&quot; problem and it only works when I use &quot;&lt;&quot; not &quot;&gt;&quot; to find the max value/</p>
<pre><code>import Combine

var subscriptions = Set&lt;AnyCancellable&gt;()
let nameArray: [String] = [&quot;bob&quot;, &quot;james&quot;, &quot;bob&quot;, &quot;james&quot;, &quot;lee&quot;, &quot;bob&quot;, &quot;bob&quot;]

nameArray
    .filter{ !$0.isEmpty }
    .reduce(into: [String: Int]()){ $0[$1] = ($0[$1] ?? 0) + 1 }
    .publisher
    .max {$0.1 &lt; $1.1 }
    .sink{print($0)}
    .store(in: &amp;subscriptions)

//Prints: &quot;(key: &quot;bob&quot;, value: 4)&quot; 
</code></pre>
<p>Is it possible the apple document is wrong?
or am I doing something wrong?</p>
","15354305","","15354305","","2021-04-24 04:46:47","2021-04-24 04:46:47","example in apple documents for max(by:) operator does not work as described?","<swift><max><documentation><combine>","2","3","","","","CC BY-SA 4.0"
"67240884","1","67241817","","2021-04-24 08:45:34","","0","1809","<p>I have a list of combine publishers that each publish one optional value.
From this list, i want to create a publisher, that runs the upstream publishers <em>in the sequence they appear in the list, one after the other</em>, and then publish the first non-nil item i can find.</p>
<p>My first approach was</p>
<pre><code>publishers
    .publisher
    .flatMap(identity)
    .first(where: {$0 != nil})
</code></pre>
<p>but this causes all publishers to run, and the fastest to win.</p>
<p>I created a minimal example with a solution that comes close to what i want to achieve.</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation
import PlaygroundSupport
PlaygroundPage.current.needsIndefiniteExecution = true

func delayedPublisher&lt;Value&gt;(_ value: Value?, delay after: Double) -&gt; AnyPublisher&lt;Value?, Never&gt; {
    let p = PassthroughSubject&lt;Value?, Never&gt;()
    DispatchQueue.main.asyncAfter(deadline: .now() + after) {
        p.send(value)
        p.send(completion: .finished)
    }
    return p.eraseToAnyPublisher()
}

let delays = [1,2,3,4,5].map({ Bool.random() ? nil : $0 }).shuffled()
print(&quot;Creating publishers with values and delays (in seconds)&quot;, delays)
let myPublishers = delays
    .map{ delayedPublisher($0, delay: Double($0 ?? 1))
        .print(&quot;\(String(describing: $0))&quot;)
        .eraseToAnyPublisher() }

let cancel = myPublishers
    .publisher
    .flatMap { $0 }
    .collect()
    .map { resultList in
        resultList.first(where: { $0 != nil }) ?? nil
    }
    .sink { result in
        print(&quot;result:&quot;, result ?? &quot;nil&quot;)
    }

</code></pre>
<p>This creates a bunch of publishers with different delays, that may or may not produce a value.
I then collect all results, and pick the first non-nil value.
The problem is</p>
<ul>
<li>All effects are run. I just want to run effects until i ran one that produces a value.</li>
<li>The results arrive in the order the publishers complete. I need to restore the original order after, which is possible but awkward in my specific example.</li>
</ul>
<p>I did my research but found nothing like that, perhaps because combine is not really designed to do that sort of thing. So any pointers are appreciated.</p>
","3885491","","","","","2021-06-17 20:48:55","Swift Combine: Run a list of publishers one after the other, and publish the first non-nil element","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"67259880","1","67283408","","2021-04-26 01:45:07","","0","964","<p>I'm playing about with writing a custom Combine publisher in order to better understand how I can turn various classes into them. Admittedly this is not something I want to do a lot, I just want to understand how it could be done if I need to.</p>
<p>The scenario I'm working with is where I have a class that generates values over time and potentially has multiple subscribers listening. It's not a case of the publisher generating values when requested, but pushing values when it desires. This might occur (for example) when reading text, or with random input from a UI.</p>
<p>To test this out I've started with a simple integer generator that's something like this:</p>
<pre class=""lang-swift prettyprint-override""><code>class IntPublisher {
                
    func generate() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            self?.send(0)
            self?.send(1)
            self?.send(2)
            self?.complete()
        }
    }
        
    private func send(_ value: Int) {
        queueOnMain()
    }
        
    func queueOnMain() {
        Thread.sleep(forTimeInterval: 0.5)
        DispatchQueue.main.async { /* ... */ }
    }
}

</code></pre>
<p>And here's the generator as a <code>Publisher</code> and <code>Subscription</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>class IntPublisher: Publisher {
    
    typealias Output = Int
    typealias Failure = Never
    
    class Subscription: Combine.Subscription, Equatable {
        
        private var subscriber: AnySubscriber&lt;Int, Never&gt;?
        private var didFinish: ((Subscription) -&gt; Void)?
        
        init&lt;S&gt;(subscriber: S, didFinish:@escaping (Subscription) -&gt; Void) where S: Subscriber, S.Input == Output, S.Failure == Failure {
            self.subscriber = AnySubscriber(subscriber)
            self.didFinish = didFinish
        }
        
        func request(_ demand: Subscribers.Demand) {
        }
        
        func cancel() {
            finish()
        }
        
        func complete() {
            self.subscriber?.receive(completion: .finished)
            finish()
        }
        
        func finish() {
            didFinish?(self)
            subscriber = nil
            didFinish = nil
        }
        
        func send(_ value: Int) {
            _ = subscriber?.receive(value)
        }
        
        static func == (lhs: PublisherTests.IntPublisher.Subscription, rhs: PublisherTests.IntPublisher.Subscription) -&gt; Bool {
            return lhs.subscriber?.combineIdentifier == rhs.subscriber?.combineIdentifier
        }
    }
    
    var subscriptions = [Subscription]()
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, S.Failure == Failure, S.Input == Output {
        
        let subscription = Subscription(subscriber: subscriber) { [weak self] (subscription) in
            self?.subscriptions.remove(subscription)
        }
        
        subscriptions.append(subscription)
        subscriber.receive(subscription: subscription)
    }
    
    func generate() {
        DispatchQueue.global(qos: .background).async { [weak self] in
            self?.send(0)
            self?.send(1)
            self?.send(2)
            self?.complete()
        }
    }
    
    private func send(_ value: Int) {
        queueOnMain { $0.send(value) }
    }
    
    private func complete() {
        queueOnMain { $0.complete() }
    }
    
    func queueOnMain(_ block: @escaping (Subscription) -&gt; Void) {
        Thread.sleep(forTimeInterval: 0.5)
        DispatchQueue.main.async { self.subscriptions.forEach { block($0) } }
    }
}
</code></pre>
<p>My question revolves around the way I've had to track the subscriptions in the publisher. Because it's generating the values and needs to forward them to the subscriptions, I've had to setup an array and store the subscriptions within it. In turn I had to find a way for the subscriptions to remove themselves from the publisher's array when they're cancelled or completed because the array effective forms a circular reference between the publisher and subscription.</p>
<p>In all the blogs I've read on custom publishing, they all cover the scenario where a publisher is waiting around for subscribers to request values. The publisher doesn't need to store a reference to the subscriptions because it passes closures which they can call to get a value. My use case is different because the publisher controls the request, not the subscribers.</p>
<p>So my question is this - Is using an array a good way to handle this? or is there something in Combine I've missed?</p>
","247090","","","","","2022-01-19 04:40:47","Combine: Is this a good technique for a custom publisher?","<swift><combine>","2","2","1","","","CC BY-SA 4.0"
"67260911","1","","","2021-04-26 04:39:25","","0","189","<p>Seems obvious that when I use both TabView and NavigationView - Pop To Root doesn't work.
This is two test codes I've implemented. One with both tabView and NavigationView, one with only Navigation View.</p>
<ol>
<li>Code with both TabView and NavigationView</li>
</ol>
<pre><code>import SwiftUI

class Views: ObservableObject {
  @Published var stacked = false
}

struct ContentView: View {
  @ObservedObject var views = Views()
  @State var selection: Int = 0

  var body: some View {
    NavigationView {
      TabView(selection: $selection) {
        ContentView2()
      }
    }
    .environmentObject(views)
  }
}

struct ContentView2: View {
  @EnvironmentObject var views: Views
  var body: some View {
    NavigationLink(destination: ContentView3(), isActive: $views.stacked) {
      Text(&quot;Go to View 2&quot;)
    }
    .isDetailLink(false)
  }
}

struct ContentView3: View {
  @EnvironmentObject var views: Views

  var body: some View {
    VStack {
      Button(&quot;Pop to root&quot;) {
        self.views.stacked = false
      }
    }
    .navigationBarTitle(&quot;View 3&quot;)
  }
}

</code></pre>
<ol start=""2"">
<li>Code only NavigationView</li>
</ol>
<ul>
<li>Just remove <code>TabView</code> bracket from Code and it works like charm...</li>
</ul>
<p>When I try to pop to root in tabview, there shows a log
<code>Trying to pop to a missing destination at /Library/Caches/com.apple.xbs/Sources/Monoceros/Monoceros-120/Shared/NavigationBridge_PhoneTV.swift:341</code></p>
<p>Has anybody found a way top TabView and NavigationView, and implement pop To Root?</p>
","11258185","","","","","2021-04-26 22:17:10","SwiftUI TabView and NavigationView Mixed - Pop To Root doesn't work","<ios><swift><navigation><combine>","1","0","","","","CC BY-SA 4.0"
"67275871","1","","","2021-04-27 01:40:49","","1","534","<p>I'm doing a comparison of Core Data and Realm in a SwiftUI app, and Core Data does something that I'm hoping to figure out how to do in Realm.</p>
<p>Core Data lets you mutate objects whenever you want, and when they are <code>ObservableObject</code> in SwiftUI, your UI instantly updates. You then save the <code>context</code> whenever you want to persist the changes.</p>
<p>In Realm, the objects in the UI are live, but you can't change them unless you are in a write transaction. I'm trying to get my UI to reflect live/instant changes from the user when the actual <code>write</code> is only performed occasionally. Below is a sample app.</p>
<p>Here's my Realm model:</p>
<pre><code>import RealmSwift

class Item: Object, ObjectKeyIdentifiable{
  @objc dynamic var recordName = &quot;&quot;
  @objc dynamic var text = &quot;&quot;

  override class func primaryKey() -&gt; String? {
    return &quot;recordName&quot;
  }
}
</code></pre>
<p>Here is my view model that also includes my <code>save()</code> function that only saves <strong>every 3 seconds</strong>. In my actual app, this is because it's an expensive operation and doing it as the user types brings the app to a crawl.</p>
<pre><code>class ViewModel: ObservableObject{
  static let shared = ViewModel()
  @Published var items: Results&lt;Item&gt;!
  @Published var selectedItem: Item?
  
  var token: NotificationToken? = nil
  
  init(){
    //Add dummy data
    let realm = try! Realm()
    realm.beginWrite()
    
    let item1 = Item()
    item1.recordName = &quot;one&quot;
    item1.text = &quot;One&quot;
    realm.add(item1, update: .all)
    
    let item2 = Item()
    item2.recordName = &quot;two&quot;
    item2.text = &quot;Two&quot;
    realm.add(item2, update: .all)
    
    try! realm.commitWrite()
    
    self.fetch()
    
    //Notifications
    token = realm.objects(Item.self).observe{ [weak self] _ in
      self?.fetch()
    }
  }
  
  //Get Data
  func fetch(){
    let realm = try! Realm()
    self.items = realm.objects(Item.self)
  }
  
  //Save Data
  var saveTimer: Timer?
  func save(item: Item, text: String){
    //Save occasionally
    saveTimer?.invalidate()
    saveTimer = Timer.scheduledTimer(withTimeInterval: 3, repeats: false){ _ in
      
      let realm = try! Realm()
      try? realm.write({
        item.text = text
      })
      
    }
  }
  
}
</code></pre>
<p>Last of all, here is the UI. It's pretty basic and reflects the general structure of my app where I'm trying to pull this off.</p>
<pre><code>struct ContentView: View {
  @StateObject var model = ViewModel.shared
  
  var body: some View {
   
    VStack{
      ForEach(model.items){ item in
        HStack{
          Button(item.text){
            model.selectedItem = item
          }
          Divider()
          ItemDetail(item: item)
        }
      }
    }

  }
}
</code></pre>
<p>...and the ItemDetail view:</p>
<pre><code>struct ItemDetail: View{
  @ObservedObject var item: Item
  @StateObject var model = ViewModel.shared
  
  init(item: Item){
    self.item = item
  }
  
  var body: some View{
    //Binding
    let text = Binding&lt;String&gt;(
      get: { item.text },
      set: { model.save(item: item, text: $0) }
    )
    
    TextField(&quot;Text...&quot;, text: text)
      .textFieldStyle(RoundedBorderTextFieldStyle())
  }
}
</code></pre>
<p>When I type in the <code>TextField</code>, how do I get the <code>Button</code> text to reflect what I have typed <strong>in real time</strong> considering that my <code>realm.write</code> only happens <strong>every 3 seconds</strong>? My <code>Button</code> updates after a write, but I want the UI to respond live--independent of the write.</p>
","1142348","","","","","2021-04-27 19:33:07","Realm in SwiftUI: Live Text in UI for Object Only Saved Occasionally","<swiftui><realm><combine>","1","10","","","","CC BY-SA 4.0"
"67277215","1","","","2021-04-27 05:00:23","","0","63","<p>I've got a SceneView that has two <code>.onReceive()</code> handlers. One responds to a 30 Hz timer I set up to animate the camera movement based on some space mouse input values, the second responds to changes in the space mouse input values to update the local state.</p>
<p>What I'm finding is that the timer fires as you would expect, 30 times/second, until input starts coming in from the space mouse, at which point the timer's onReceive stops being called. Once I stop manipulating the space mouse, its input stops flowing.</p>
<p>This makes for unusable camera control. Now, I may be doing it wrong, but I'm pretty limited with what the SwiftUI SceneView has to offer, and this seems like a pretty broken behavior for Combine.</p>
<p>Am I missing something obvious?</p>
<pre class=""lang-swift prettyprint-override""><code>struct
PerlinTerrainGeneratorView: View
{
    @EnvironmentObject  private var         multiAxisInput      :   MultiAxisDevice
    @State              private var         multiAxisState      :   MultiAxisState          =   MultiAxisState()
    
    let         updateTimer = Timer.publish(every: 1.0 / 30.0, on: .main, in: .common).autoconnect()
    
    var
    body: some View
    {
        SceneView(scene: self.scene, pointOfView: self.cameraNode, delegate: PerlinTerrainGeneratorRendererDelegate(view: self))
            .onReceive(self.updateTimer) { inTimer in
                if let ea = self.cameraNode
                {
                    debugLog(&quot;roll: \(self.multiAxisState.roll)&quot;)
                    let qq = GLKQuaternionMakeWithAngleAndAxis(Float(self.multiAxisState.roll) * 0.01, 0, 0, 1)
                    let q = SCNQuaternion(qq.x, qq.y, qq.z, qq.w)
                    ea.localRotate(by: q)
                }
            }
            .onReceive(self.multiAxisInput.$state) { inState in
                self.multiAxisState = inState
            }
    }
}
</code></pre>
","251914","","251914","","2021-04-27 12:57:14","2021-04-27 12:57:14","macOS SwiftUI SceneView with multiple onReceive() handlers seem to block each other","<swiftui><scenekit><combine>","0","3","","","","CC BY-SA 4.0"
"67282103","1","","","2021-04-27 11:24:08","","0","158","<p>I have to use a third party SDK to communicate with a Bluetooth device. The SDK only allows one call at a time and a call cannot be cancelled. I have abstracted each call to the SDK with a layer returning Combine publishers.</p>
<pre><code>struct AbstractedSDKLayer {
  func getBatteryLevel() -&gt; AnyPublisher&lt;Float, Error&gt; { ... }
  func getVersion() -&gt; AnyPublisher&lt;String, Error&gt; { ... }
  ...
}
</code></pre>
<p>My problem occurs when my UI is calling multiple times <code>getBatteryLevel()</code> for instance, because of some actions triggering refresh.</p>
<p>I have tried to create a custom operator to delay subscription to upstream publisher (because the SDK call is triggered when a subscription is received, using a <code>Deferred { Future }</code>). My idea was to have a &quot;pool&quot; of SDK pending requests, processing one and going on the next one. But well, I think I'm missing some understanding of Combine tools (Subscriber, Subscription, demand...) and my code is not working. I have made some tests using a connectable publisher but with still no success. From my point of view, it seems that most native Combine operator controls the publishing process but not the subscription process.</p>
<p>My Android colleague has handled this usecase by using a Kotlin coroutine Mutex.</p>
<p>What is the best way to do this with Combine?</p>
","1220867","","","","","2021-08-14 23:06:23","Preventing concurrency using Combine","<swift><combine>","0","5","","","","CC BY-SA 4.0"
"67288985","1","","","2021-04-27 18:47:50","","0","156","<p>I don't understand when I try to remove all items by calling viewContext.execute(deleteRequest) SwiftUI doesn't redraw UI.
I see items from sqlite are gone.</p>
<pre class=""lang-swift prettyprint-override""><code>struct CloudKitTestView: View {
    @Environment(\.managedObjectContext) private var viewContext

    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Item.timestamp, ascending: true)],
        animation: .default)
    private var items: FetchedResults&lt;Item&gt;

    var body: some View {
        VStack {
            Button(&quot;Remove all&quot;) {
                let fetchRequest = NSFetchRequest&lt;NSFetchRequestResult&gt;(entityName: &quot;Item&quot;)
                let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)

                do {
                    try viewContext.execute(deleteRequest)
                } catch {
                    // Replace this implementation with code to handle the error appropriately.
                    // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                    let nsError = error as NSError
                    fatalError(&quot;Unresolved error \(nsError), \(nsError.userInfo)&quot;)
                }
            }

            List {
                ForEach(items) { item in
                    Text(&quot;Item at \(item.timestamp!, formatter: itemFormatter)&quot;)
                }
                .onDelete(perform: deleteItems)
            }
            .toolbar {
                #if os(iOS)
                EditButton()
                #endif

                Button(action: addItem) {
                    Label(&quot;Add Item&quot;, systemImage: &quot;plus&quot;)
                }
            }
        }
    }

    private func addItem() {
        withAnimation {
            let newItem = Item(context: viewContext)
            newItem.timestamp = Date()

            do {
                try viewContext.save()
            } catch {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                let nsError = error as NSError
                fatalError(&quot;Unresolved error \(nsError), \(nsError.userInfo)&quot;)
            }
        }
    }

    private func deleteItems(offsets: IndexSet) {
        withAnimation {
            offsets.map { items[$0] }.forEach(viewContext.delete)

            do {
                try viewContext.save()
            } catch {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                let nsError = error as NSError
                fatalError(&quot;Unresolved error \(nsError), \(nsError.userInfo)&quot;)
            }
        }
    }
}
</code></pre>
","4067700","","4067700","","2021-04-27 20:46:13","2021-04-29 06:47:38","viewContext.execute(deleteRequest) doesn’t call redrawing SwiftUI List","<core-data><swiftui><combine><swiftui-list>","1","0","","","","CC BY-SA 4.0"
"67290017","1","","","2021-04-27 20:09:30","","0","198","<p>Let's say I have some API calls that retrieve a list of items for the given page:</p>

<pre class=""lang-swift prettyprint-override""><code>func getItemsA(_ page: Int) -&gt; AnyPublisher&lt;[A], Never&gt;
func getItemsB(_ page: Int) -&gt; AnyPublisher&lt;[B], Never&gt;
// (and more)
</code></pre>
<p>I want to create a generic <code>UIViewController</code> with an endless scroll (page 1 - 10 items, page 2 - 20 items and so on) that takes a
<code>(Int)-&gt;AnyPublisher&lt;[T], Never&gt;</code> closure and does as much work internally as possible (hidden from the outside world)</p>
<p>Currently what I have is something like this (again, I simplify the code to highlight the important parts)</p>
<pre class=""lang-swift prettyprint-override""><code>
// PagedCollectionViewController.swift
class PagedCollectionViewController&lt;T&gt;: UIViewController,
                                        UICollectionViewDelegate {

@Published var items: [T] = []
private var subscriptions = Set&lt;AnyCancellable&gt;()
var getItems: ((Int) -&gt; AnyPublisher&lt;[T], Never&gt;)?

// (...)

    override func viewDidLoad() {
        super.viewDidLoad()
        $items.sink { _ in
            self.collectionView.reloadData()
        }.store(in: &amp;subscriptions)

        // get the items on the initial call
        getItems?(currentPage).sink { newItems in
            self.items.append(contentsOf: newItems)
        }.store(in: &amp;subscriptions)
    }

// (...)

   func collectionView(_ collectionView: UICollectionView,
                        willDisplay cell: UICollectionViewCell,
                        forItemAt indexPath: IndexPath) {
        let itemsCount = collectionView
            .numberOfItems(inSection: indexPath.section)

       // everytime the user reaches the end of the list we need to load more items
        if indexPath.row == itemsCount - 1 {
           getItems?(currentPage).sink { newItems in
              self.items.append(contentsOf: newItems)
           }.store(in: &amp;subscriptions)
        }
    }
}

// HomeViewController.swift
final class HomeViewController: PagedCollectionViewController&lt;A&gt; {

(...)
override func loadView() {
        super.loadView()
        collectionView.dataSource = self
        getItems = interactor?.getItemsA
    }
}

</code></pre>
<p>So I'm mostly interested in the <code>getItems</code> part of the <code>PagedCollectionViewController</code>. I'm new to Combine and I find it kinda odd that I have the <code>sink</code> method called twice on <code>getItems</code>. Is there a better way of doing it?</p>
<p>The <code>PagedCollectionViewController</code> will be used with many other controllers and I expect it to work everywhere the same way thats why I want to keep it as generic as possible. Do You have any suggestions how to improve it? Maybe using Combine for this exact part (loading more items) is a bad idea in general? Would You solve the pagination problem differently?</p>
","2175228","","2175228","","2021-04-28 07:36:34","2021-04-28 07:36:34","Add pagination to UIViewController for endless scroll using the Combine framework","<ios><swift><pagination><uikit><combine>","0","2","","","","CC BY-SA 4.0"
"67292214","1","67292278","","2021-04-28 00:24:45","","0","173","<p>I have two methods with identical signature <code>func getItems() -&gt; AnyPublisher&lt;[Item], AppError&gt;</code>.
First is getting items from a storage, and the second one from the internet.</p>
<p>How can I add such logic to the third method with the same return type, if the first method completes successfully I return <code>storage.getItems()</code>, if not I return <code>network.getItems()</code>?</p>
","","user13691063","","","","2021-04-28 00:36:28","How to resolve two method calls with AnyPublisher return type into one?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"67299564","1","67300951","","2021-04-28 11:43:01","","0","177","<p>I'm struggling with handling errors in Combine and find it very counter-intuitive that <a href=""https://developer.apple.com/documentation/combine/fail/catch(_:)"" rel=""nofollow noreferrer"">catching</a> or <a href=""https://developer.apple.com/documentation/combine/fail/replaceerror(with:)"" rel=""nofollow noreferrer"">replacing</a> an error completes and ends the publisher. For example, this ends the publisher even though I handled the exception:</p>
<pre><code>Just([1, 2, 3, NaN, 5, 6])
   .tryMap { _ in throw DummyError() }
   .catch { _ in Just(4) } // or .replaceError(with: 4)
   .sink { print($0) } // &lt;-- ends at 4 and ignores 5, 6, and anything ever again
</code></pre>
<p>If the publisher was subscribed to some system change, the first error will make my app dead until the user restarts the app. I would like to create a <code>catch</code> counterpart that does NOT end the publisher. I know <code>flatMap</code> is used for that, but that creates a whole other dimension of complexity such as inverting inner/outer publishers, publishers getting duplicated infinitely, back pressure, etc.</p>
<p>Is there a way to do something like this:</p>
<pre><code>Just([1, 2, 3, NaN, 5, 6])
   .tryMap { _ in throw DummyError() }
   .ignoreError { error in
        log(&quot;Error occurred: \(error)&quot;)
   }
   .sink { print($0) } // 1, 2, 3, 5, 6
</code></pre>
<p>How can I encapsulate this intent in a simple custom chain command called <code>ignoreError</code> and make my publishers live on?</p>
","235334","","235334","","2021-04-28 12:11:44","2021-04-28 19:28:07","Create a catch/replace error counterpart that does not complete the publisher?","<swift><combine>","1","11","","","","CC BY-SA 4.0"
"67328738","1","67328842","","2021-04-30 05:40:53","","-1","379","<p>I am new to Swift programming. Trying to build a login page with username and password fields with non empty validation</p>
<p>This is the code for validation using Combine:</p>
<pre><code>private var isUsernameValid: AnyPublisher&lt;Bool, Never&gt; {
        $username
            .debounce(for: 0.2, scheduler: RunLoop.main)
            .removeDuplicates()
            .map {
                if $0.isEmpty {
                self.errorUsername = &quot;Invalid Username&quot;
                return false
            } else {
                self.errorUsername = &quot;&quot;
                return true
            } }
            .eraseToAnyPublisher()
    }
    
    private var isPasswordValid: AnyPublisher&lt;Bool, Never&gt; {
        $password
            .debounce(for: 0.2, scheduler: RunLoop.main)
            .removeDuplicates()
            .map {
                if $0.isEmpty {
                self.errorPassword = &quot;Invalid Password&quot;
                return false
            } else {
                self.errorPassword = &quot;&quot;
                return true
            } }
            .eraseToAnyPublisher()
    }
    
    private var isFormValid: AnyPublisher&lt;Bool, Never&gt; {
        Publishers.CombineLatest(isUsernameValid, isPasswordValid)
            .debounce(for: 0.2, scheduler: RunLoop.main)
            .map { $0 &amp;&amp; $1 }
            .eraseToAnyPublisher()
    }
</code></pre>
<p>As soon as I enter login page error message is showing. I only want validation error to show after user starts typing into text field. Please help</p>
","15618585","","","","","2021-04-30 05:52:22","Combine: How to validate textfields only after user input","<swift><validation><combine>","1","0","","2021-04-30 06:01:28","","CC BY-SA 4.0"
"67334880","1","","","2021-04-30 13:35:16","","1","257","<p>I've been following the <a href=""https://www.youtube.com/watch?v=4RUeW5rUcww&amp;t=217s"" rel=""nofollow noreferrer"">Peter Friese YT series on SwiftUI &amp; Firebase</a>, starting with parts 1 and 2. Now I'm trying to transfer what I learned there into my own little test app, specifically adding a <code>ViewModel</code> into the mix.</p>
<p>Peter's app has a single screen interface, whereas I want to use a second screen to enter several pieces of data for the new element and when the user clicks &quot;Save new element&quot;, it's added to the array and then is returned to the first screen.</p>
<p>Prior to adding the <code>ViewModel</code> code, it works exactly as intended: new element created, added to the array, UI updates. It also works for updating an existing element.</p>
<p>After adding the <code>ViewModel</code> code, it <em>almost</em> works. new element created, added to the array. <strong>But, the UI is not updated and I don't understand why not.</strong></p>
<p>Here's my code:</p>
<pre><code>import Foundation
import SwiftUI
import Combine

struct Tournament: Identifiable {
    var id = UUID().uuidString
    var name: String
    var location: String = &quot;Franchises&quot;
    var date: Date = Date()
}

#if DEBUG
var blankTournament = Tournament(name: &quot;&quot;)
var testTournamentData = [
    Tournament(name: &quot;Tournament 1&quot;),
    Tournament(name: &quot;Tournament 2&quot;),
    Tournament(name: &quot;Tournament 3&quot;),
]
#endif

struct ContentView: View {
    @ObservedObject var tournamentListVM = TournamentListVM()

    var body: some View {
        NavigationView {
            VStack {
                List(tournamentListVM.tournamentCellVMs) { tournamentCellVM  in
                    NavigationLink(
                        destination: TournamentDetails(tournament: tournamentCellVM.tournament),
                        label: { TournamentCell(tournamentCellVM: tournamentCellVM) }
)}}
            .navigationTitle(&quot;All in Two (\(tournamentListVM.tournamentCellVMs.count))&quot;)
            .navigationBarItems(
                trailing: NavigationLink(
                    destination: TournamentDetails(addingNewTournament: true))
                        { Image(systemName: &quot;plus&quot;) }
)}}}

struct TournamentCell: View {
    @ObservedObject var tournamentCellVM: TournamentCellVM

    var body: some View {
        VStack(alignment: .leading) {
            Text(tournamentCellVM.tournament.name)
        }
    }
}

struct TournamentDetails: View {
    @Environment(\.presentationMode) var presentationMode // used to dismiss the view
    @ObservedObject var tournamentListVM = TournamentListVM()

    @State var tournament = blankTournament

    var addingNewTournament: Bool = false
    var index: Int? // needed when updating an existing record

    var body: some View {
        Form {
            Section(header: Text(&quot;Tournament Info&quot;)) {
                TextField(&quot;Name&quot;, text: $tournament.name)
                TextField(&quot;Location&quot;, text: $tournament.location)
                DatePicker(selection: $tournament.date, displayedComponents: .date) { Text(&quot;Date&quot;) }
            }
            Section { Button(action: {
                if addingNewTournament  { tournamentListVM.createTournament(tournament) }
                else                            { tournamentListVM.updateTournament(tournament) }
                presentationMode.wrappedValue.dismiss()
            }) { Text(addingNewTournament ? &quot;Save Tournament&quot; : &quot;Update Tournament&quot;) }
}}}}

class TournamentListVM: ObservableObject {
    @Published var tournamentCellVMs = [TournamentCellVM]()

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        self.tournamentCellVMs = testTournamentData.map { tournament in
            TournamentCellVM(tournament: tournament)
        }
    }

    func createTournament(_ tournament: Tournament) {
        print (tournamentCellVMs.count)
        tournamentCellVMs.append(TournamentCellVM(tournament: tournament))
        print (tournamentCellVMs.count)
    }

    func updateTournament(_ tournament: Tournament) {
    }
}

class TournamentCellVM: ObservableObject, Identifiable {
    @Published var tournament: Tournament

    var id = &quot;&quot;

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(tournament: Tournament) {
        self.tournament = tournament

        $tournament
            .map { tournament in tournament.id }
            .assign(to: \.id, on: self)
            .store(in: &amp;cancellables)
}}
</code></pre>
","1363998","","472495","","2021-05-23 09:27:56","2021-05-23 09:27:56","Why doesn't my UI update after adding a ViewModel to my SwiftUI app?","<mvvm><swiftui><viewmodel><combine>","1","0","","","","CC BY-SA 4.0"
"67353167","1","67353428","","2021-05-02 05:08:53","","3","618","<p>I'm trying to listen to <code>@State</code> changes and followed <a href=""https://stackoverflow.com/a/64659265/14351818"">this answer</a>. Here's my code:</p>
<pre><code>import SwiftUI

struct ContentView: View {
    @State var isOn = false
    
    var body: some View {
        Toggle(&quot;Selection&quot;, isOn: $isOn)
            .onReceive(Just(isOn)) { isOn in
                print(&quot;Toggle is on? \(isOn)&quot;)
            }
    }
}
</code></pre>
<p>It doesn't compile: I get &quot;Cannot find 'Just' in scope&quot;</p>
<p><a href=""https://i.stack.imgur.com/qhFx1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qhFx1.png"" alt=""Cannot find 'Just' in scope with the line containing 'Just' highlighted"" /></a></p>
<p><a href=""https://developer.apple.com/documentation/combine/just"" rel=""nofollow noreferrer""><code>Just</code> is part of the Combine framework</a>. But, I thought SwiftUI already imported Combine? I <kbd>Command</kbd>-clicked <code>import SwiftUI</code>, then pressed <code>Jump to Definition</code>, and there it was at the top.</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th>Jump to Definition</th>
<th><code>import Combine</code> is at the top</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href=""https://i.stack.imgur.com/QNATz.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QNATz.png"" alt=""Jump to Definition in popup menu"" /></a></td>
<td><a href=""https://i.stack.imgur.com/P0dSf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/P0dSf.png"" alt=""Line 1 of SwiftUI file is import Combine"" /></a></td>
</tr>
</tbody>
</table>
</div>
<p>Once I add <code>import Combine</code> to my code, it compiles. But shouldn't this be redundant and unnecessary?</p>
<p><a href=""https://i.stack.imgur.com/Ig4X4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ig4X4.png"" alt=""Build succeeded"" /></a></p>
","14351818","","","","","2021-05-02 06:01:02","Why do I need to import Combine when SwiftUI already imports it?","<ios><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"67356382","1","","","2021-05-02 12:25:17","","1","343","<p>I have a function that setups <code>UISearchController</code> within <code>ViewController</code>.
I'm trying to subscribe to events from <code>searchBar.text</code> property and <code>debounce</code> events as this is making network calls (and I want to make as less as possible).
Unfortunately the sink is only called once when <code>setupSearchController</code> is called. What did I wrong?</p>
<pre><code>private func setupSearchController() {
    let powerSearchResultViewController = PowerSearchResultViewController(coreDataManager: self.coreDataManager)
    let searchController = UISearchController(searchResultsController: powerSearchResultViewController)
    searchController.searchBar.autocapitalizationType = .none
    let defaultAttributes = [NSAttributedString.Key.foregroundColor: UIColor(white: 1.0, alpha: 0.8)]
    UITextField.appearance(whenContainedInInstancesOf: [UISearchBar.self]).defaultTextAttributes = defaultAttributes
    searchController.searchBar.publisher(for: \.text)
        .debounce(for: .seconds(1), scheduler: DispatchQueue.main)
        .sink { [weak self] value in
            guard let self = self, let value = value, value != &quot;&quot; else { return }
            self.powerSearchResultViewController?.performQuery(with: value)
        }
        .store(in: &amp;self.disposables)
    searchController.obscuresBackgroundDuringPresentation = false
    searchController.hidesNavigationBarDuringPresentation = false
    searchController.searchBar.placeholder = &quot;Search...&quot;
    searchController.delegate = self
    self.navigationItem.searchController = searchController
    self.navigationItem.hidesSearchBarWhenScrolling = false
    self.powerSearchResultViewController = powerSearchResultViewController
    self.searchController = searchController
}
</code></pre>
","878395","","","","","2022-09-08 13:29:10","Using Combine with UISearchController and searchBar text change event","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"67366419","1","","","2021-05-03 09:21:24","","0","102","<p>The following code doesn't work with an EXC_BAD_ACCESS error.</p>
<pre><code>func publisherLoopExample() {
    let publisher = PassthroughSubject&lt;String, Never&gt;()
    
    let subscriber = publisher.sink { [weak publisher] received in
        guard let publisher = publisher else { return }
        publisher.send(received)
        print(&quot;received \(received)&quot;)
    }
    
    publisher.send(&quot;1&quot;)
}
</code></pre>
<p>Questions:</p>
<ol>
<li>Why EXC_BAD_ACCESS raised?</li>
<li>Is there a concern that in the subscriber, it sends data to the original publisher so it could be a loop?</li>
</ol>
","197116","","","","","2021-05-03 09:24:40","Is it possible a pipeline of loop been created using Publisher and Subscriber in Swift Combine framework?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67372556","1","67449130","","2021-05-03 16:35:04","","1","832","<p>I have started using Combine quite recently and I am trying to create a repository that returns the combination of several data sources. To do that, each data source loads its own data in a quite simple load method:</p>
<pre><code>func loadData() -&gt; AnyPublisher&lt;DataObject, Error&gt;
</code></pre>
<p>To combine the data sources I thought of using <code>combineLatest</code>, since it'll wait for the data sources to finish loading and then it'll publish either a combined set with the data or an error indicating that it failed:</p>
<pre><code>func loadData() -&gt; AnyPublisher&lt;[DataObject], Error&gt; {
   return dataSource1.loadData()
             .combineLatest(dataSource2.loadData())
             .map { $0.0 + $0.1 }
             .eraseToAnyPublisher()
}
</code></pre>
<p>Overall the behavior of it seems alright, I can call <code>repository.loadData()</code> and I'll get an array that includes the data for both items. However, that's not the case if any of the data sources fail. In that case, the load method will return an error regardless of whether the other data source succeeded.</p>
<p>Is there a standard or recommended way to collect all the errors when combining publishers? In my use context I'd like to be able to discard the error only if both publishers failed, but go through and succeed if only one of them does.</p>
","1523403","","1523403","","2021-05-04 08:11:47","2021-05-08 15:19:51","How are errors handled when combining publishers?","<ios><swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"67393767","1","67438117","","2021-05-05 00:29:14","","2","170","<p>My goal is to send async accelerometer readings to a server in periodic payloads.</p>
<p>Accelerometer data continues while offline and concurrently during the network requests, so I'll need to handle network failures as well as data that arrives during the duration of each network request.</p>
<p>My inelegant approach is to append each new update to an array:</p>
<pre><code>motionManager.startAccelerometerUpdates(to: .main) { data, error in
    dataArray.append(data)
}
</code></pre>
<p>And then periodically send a group of values to the server (<code>network</code> is my wrapper around <code>NWPathMonitor()</code>):</p>
<pre><code>let timer = Timer(fire: Date(), interval: 5, // Every 5 seconds
              repeats: true, block: { timer in
                if network.connected {
                    postAccelerometerData(payload: dataArray) { success
                        if success {
                            dataArray.removeAll()
                        }
                    }
                }
            })


RunLoop.current.add(timer, forMode: RunLoop.Mode.default)
</code></pre>
<p>The major issue with this approach is that the elements of the array added between when the network request fires and when it completes would be removed from the array without ever being sent to the server.</p>
<p>I've had some ideas about adding a queue and dequeuing X elements on for each network request (but then do I add them back to the queue if the request fails?).</p>
<p>I can't help but think there is a better way to approach this using <code>Combine</code> to &quot;stream&quot; these accelerometer updates to some sort of data structure to buffer them, and then send those on to a server.</p>
<p>The <code>postAccelerometerData()</code> function just encodes a JSON structure and makes the network request. Nothing particularly special there.</p>
","577237","","577237","","2021-05-07 14:18:53","2021-05-09 22:16:14","How to use Combine to send async accelerometer updates to server","<swift><networking><buffer><sensors><combine>","2","2","","","","CC BY-SA 4.0"
"67393881","1","67393936","","2021-05-05 00:51:59","","4","793","<p>We know Empty Publisher in Combine will trigger a completion event immediately：</p>
<pre><code>Empty&lt;Void,Never&gt;()
    .sink {
        print(&quot;completion: \($0)&quot;)  // will print!
    } receiveValue: {}
</code></pre>
<p>But Empty Publisher that flatMap returned will NOT trigger completion event:</p>
<pre><code>var subs = Set&lt;AnyCancellable&gt;()
let p0 = PassthroughSubject&lt;[Int],Error&gt;()
let p1 = p0
    .flatMap {_ in
        Empty&lt;Void,Never&gt;() // same Empty Publisher
    }.eraseToAnyPublisher()

p1
    .sink {
        print(&quot;completion: \($0)&quot;)  // but NOT print!
    } receiveValue: {}
    .store(in: &amp;subs)

p0.send([1,2,3])
</code></pre>
<p>Why is that??? Am I miss something??? Thanks! ;)</p>
","5487391","","","","","2021-05-05 03:14:36","Why Empty Publisher not trigger completion event in Combine?","<swift><combine><publisher>","1","2","1","","","CC BY-SA 4.0"
"67438411","1","67440677","","2021-05-07 16:12:28","","1","471","<p>I would like to subscribe to UIPasteboard changes in SwiftUI with onReceive.
<code>pHasStringsPublisher</code> will not be updated as soon as something in the clipboard changes and I don't understand why.</p>
<pre><code>import SwiftUI

struct ContentView: View {
    let pasteboard = UIPasteboard.general
    
    @State var pString: String = &quot;pString&quot;
    @State var pHasStrings: Bool = false
    @State var pHasStringsPublisher: Bool = false

    var body: some View {
        VStack{
            Spacer()
            Text(&quot;b: '\(self.pString)'&quot;)
                .font(.headline)
            Text(&quot;b: '\(self.pHasStrings.description)'&quot;)
                .font(.headline)
            Text(&quot;p: '\(self.pHasStringsPublisher.description)'&quot;)
                .font(.headline)
            Spacer()
            Button(action: {
                self.pString = self.pasteboard.string ?? &quot;nil&quot;
                self.pHasStrings = self.pasteboard.hasStrings
            }, label: {
                Text(&quot;read pb&quot;)
                    .font(.largeTitle)
            })
            Button(action: {
                self.pasteboard.items = []
            }, label: {
                Text(&quot;clear pb&quot;)
                    .font(.largeTitle)
            })
            Button(action: {
                self.pasteboard.string = Date().description
            }, label: {
                Text(&quot;set pb&quot;)
                    .font(.largeTitle)
            })
            
        }
        .onReceive(self.pasteboard
                    .publisher(for: \.hasStrings)
                    .print()
                    .receive(on: RunLoop.main)
                    .eraseToAnyPublisher()
                   , perform:
                    { hasStrings in
                        print(&quot;pasteboard publisher&quot;)
                        self.pHasStringsPublisher = hasStrings
                    })
    }

}
</code></pre>
","12523385","","","","","2021-05-07 19:30:06","SwiftUI onReceive don't work with UIPasteboard publisher","<swift><swiftui><combine><uipasteboard>","1","2","","","","CC BY-SA 4.0"
"67442948","1","67457749","","2021-05-08 00:15:20","","2","601","<p><em>Xcode 12.5, iOS 14.5, macOS 11.3</em></p>
<p>Let's say I have a simple Realm class like this in a SwiftUI app:</p>
<pre><code>class Item: Object, ObjectKeyIdentifiable{
  @objc dynamic var id = &quot;&quot;
  @objc dynamic var name = &quot;&quot;
  @objc dynamic var updated = Date()
}
</code></pre>
<p>I pass an object into a view using <code>@ObservedRealmObject</code> where I can edit its <code>name</code> property by binding it to a <code>TextField</code> view like this:</p>
<pre><code>struct DetailView: View {
  @ObservedRealmObject var item: Item

  var body: some View{
  
    TextField(&quot;Name...&quot;, $item.name)

  }
}
</code></pre>
<p>When I edit the field, the <code>name</code> property updates as I type and the realm is updated in real-time.</p>
<p>But I also want to update the <code>updated</code> property with a new <code>Date()</code> timestamp whenever the object is modified. Since the write transaction is managed automatically by <code>@ObservedRealmObject</code>, I'm unclear on how to pull this off.</p>
<p>How can I change <code>updated</code> every time the <code>name</code> (or any other additional property) is changed?</p>
","1142348","","","","","2021-05-09 12:35:20","Update Additional Field on Realm Object with ObservedRealmObject in SwiftUI","<swiftui><realm><combine>","1","5","1","","","CC BY-SA 4.0"
"67459039","1","","","2021-05-09 14:48:32","","1","260","<p>Hey 👋 So I am downloading images from AWS S3 and show them in my app using a swiftUI LazyVGrid.</p>
<p>My code to download is the following:</p>
<pre><code>class S3CacheFetcher: Fetcher {
    
    typealias KeyType = MediaItemCacheInfo
    typealias OutputType = NSData
    
    func get(_ key: KeyType) -&gt; AnyPublisher&lt;OutputType, Error&gt; {
        return download(mediaItem: key).eraseToAnyPublisher()
    }
    
    private func download(mediaItem: KeyType) -&gt; AnyPublisher&lt;OutputType, Error&gt;{
        let BUCKET = &quot;someBucket&quot;
        
        return Deferred {
            Future { promise in
                guard let key:String = S3CacheFetcher.getItemKey(mediaItem: mediaItem) else { fatalError(&quot;UserPoolID Error&quot;) }
                print(&quot;Downloading image with key: \(key)&quot;)
                AWSS3TransferUtility.default().downloadData(fromBucket: BUCKET,
                                                            key: key,
                                                            expression: nil) { (task, url, data, error) in
                    if let error = error{
                        print(error)
                        promise(.failure(error))
                    }else if let data = data{
// EDIT--------
                        let encrypt = S3CacheFetcher.encrypt(data: data)
                        let decrypt = S3CacheFetcher.decrypt(data: encrypt)
// EDIT--------
                        promise(.success(decrypt as NSData))

                    }
                }
            }
        }
        .eraseToAnyPublisher()
    }
....
// EDIT---------

// In my code I have a static function that decrypts the images using CryptoKit.AES.GCM

// To test my problem I added these two functions that should stand for my decryption.

    static var symmetricKey = SymmetricKey(size: .bits256)
    static func encrypt(data: Data) -&gt; Data{
        return try! AES.GCM.seal(data, using: S3CacheFetcher.symmetricKey).combined!
    }
    
    static func decrypt(data: Data) -&gt; Data{
        return try! AES.GCM.open(AES.GCM.SealedBox(combined: data), using: S3CacheFetcher.symmetricKey)
    }
}
</code></pre>
<p>My GridView:</p>
<pre><code>struct AllPhotos: View {
    @StateObject var mediaManager = MediaManager()
    var body: some View {
      ScrollView{
          LazyVGrid(columns: columns, spacing: 3){
              ForEach(mediaManager.mediaItems) { item in
                  VStack{
                      ImageView(downloader: ImageLoader(mediaItem: item, size: .large, parentAlbum: nil))
                  }
              }
         }
    }
}
</code></pre>
<p>My ImageView I am using inside my GridView:</p>
<pre><code>struct ImageView: View{
        @StateObject var downloader: ImageLoader
        
        var body: some View {
            Image(uiImage: downloader.image ?? UIImage(systemName: &quot;photo&quot;)!)
                .resizable()
                .aspectRatio(contentMode: .fill)
                .onAppear(perform: {
                    downloader.load()
                })
                .onDisappear {
                    downloader.cancel()
                }
        }
    }
</code></pre>
<p>And last but not least the ImageDownloader which is triggered when the image view is shown:</p>
<pre><code>class ImageLoader: ObservableObject {
    @Published var image: UIImage?
    
    private(set) var isLoading = false
    
    private var cancellable: AnyCancellable?
    private(set) var mediaItem:MediaItem
    private(set) var size: ThumbnailSizes
    private(set) var parentAlbum: GetAlbum?
    
    init(mediaItem: MediaItem, size: ThumbnailSizes, parentAlbum: GetAlbum?) {
        self.mediaItem = mediaItem
        self.size = size
        self.parentAlbum = parentAlbum
    }
    
    deinit {
        cancel()
        self.image = nil
    }
    
    func load() {
        guard !isLoading else { return }
        
        // I use the Carlos cache library but for the sake of debugging I just use my Fetcher like below
        cancellable = S3CacheFetcher().get(.init(parentAlbum: self.parentAlbum, size: self.size, cipher: self.mediaItem.cipher, ivNonce: self.mediaItem.ivNonce, mid: self.mediaItem.mid))
            .map{ UIImage(data: $0 as Data)}
            .replaceError(with: nil)
            .handleEvents(receiveSubscription: { [weak self] _ in self?.onStart() },
                          receiveCompletion: { [weak self] _ in self?.onFinish() },
                          receiveCancel: { [weak self] in self?.onFinish() })
            .receive(on: DispatchQueue.main)
            .sink { [weak self] in self?.image = $0 }
    }
    
    func cancel() {
        cancellable?.cancel()
        self.image = nil
    }
    
    private func onStart() {
        isLoading = true
    }
    
    private func onFinish() {
        isLoading = false
    }
}
</code></pre>
<p>So first of all before I describe my problem. Yes I know I have to cache those images for a smother experience. I did that but for the sake of debugging my memory issue I do not cache those images for now.</p>
<p><strong>Expected behavior:</strong> Downloads images and displays them if the view is shown. Purges the images out of memory if the image view is not shown.</p>
<p><strong>Actual behavior:</strong> Downloads the images and displays them <strong>but it does not purge them from memory once the image view has disappeared.</strong> If I scroll up and down for some period of time the memory usage is up in the Gb range and the app crashes.
If I use my persistent cache which grabs the images from disk <strong>with more or less the same logic for grabbing and displaying the images</strong> than everything works as expected and the memory usage is not higher than 50 Mb.</p>
<p>I am fairly new to Combine as well as SwiftUI so any help is much appreciated.</p>
","10176155","","10176155","","2021-05-10 09:32:09","2021-05-10 09:32:09","Downloading images from S3 and showing them using SwiftUI results in high memory usage","<swift><amazon-s3><swiftui><combine><awss3transferutility>","0","8","","","","CC BY-SA 4.0"
"67461067","1","67461230","","2021-05-09 18:26:01","","1","222","<p>I have this rather common situation where a <code>List</code> is displaying some items from an <code>@ObservedObject</code> data store as <code>NavigationLinks</code>.</p>
<p>On selecting a <code>NavigationLink</code> a <strong>DetailView</strong> is presented. This view has a simple <code>Toggle</code> conected to a <code>@Published</code> var on its <strong>ViewModel</strong> class.</p>
<p>When the <strong>DetailView</strong> appears (<code>onAppear:</code>) its View Model sets the published <code>var</code> that controls the <code>Toggle</code> to <code>true</code> and also triggers an async request that will update the <strong>main data store</strong>, causing the <code>List</code> in the previous screen to update too.</p>
<p>The problem is that when this happens (the <code>List</code> is reloaded from an action triggered in the Detail View) multiple instances of the DetailViewModel seem to retained and the DetailView starts receiving events from the wrong <strong>Publishers</strong>.</p>
<p>In the first time the Detail screen is reached the behaviour is correct (as shown in the code below), the toggle is set to <code>true</code> and the <strong>store</strong> is updated, however, on navigating back to the <code>List</code> and then again to another DetailView the toggle is set to <code>true</code> on appearing but this time when the code that reloads the <strong>store</strong> executes, the toggle is set back to <code>false</code>.</p>
<p>My understanding is that when the <code>List</code> is reloaded and a new DetailView and ViewModel are created (as the destination of the <code>NavigationLink</code>) the initial value from the <code>isOn</code>  variable that controls the <code>Toggle</code> (which is <code>false</code>) is somehow triggering an update to the <code>Toggle</code> of the currently displayed screen.</p>
<p>Am I missing something here?</p>
<pre><code>import SwiftUI
import Combine

class Store: ObservableObject {
    static var shared: Store = .init()
    @Published var items = [&quot;one&quot;, &quot;two&quot;]
    private init() { }
}

struct ContentView: View {
    @ObservedObject var store = Store.shared
    
    var body: some View {
        NavigationView {
            List(store.items, id: \.self) { item in
                NavigationLink(item, destination: ItemDetailView())
            }
        }
    }
}

struct ItemDetailView: View {
    @ObservedObject var viewModel = ItemDetailViewModel()
    
    var body: some View {
        VStack {
            Toggle(&quot;A toggle&quot;, isOn: $viewModel.isOn)
            Text(viewModel.title)
            Spacer()
        }   .onAppear(perform: viewModel.onAppear)
    }
}

class ItemDetailViewModel: ObservableObject {
    @ObservedObject var store: Store = .shared
    @Published var isOn = false

    var title: String {
        store.items[0]
    }
    
    func onAppear() {
        isOn = true
        asyncOperationThatUpdatesTheStoreData()
    }
    
    private func asyncOperationThatUpdatesTheStoreData() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) { [weak self] in
            self?.store.items = [&quot;three&quot;, &quot;four&quot;]
        }
    }
}
</code></pre>
<img src=""https://i.stack.imgur.com/ToFv9.gif"" width=""350"" />
","1222373","","1222373","","2021-05-09 21:05:01","2021-05-09 21:05:01","SwiftUI List data update from destination view causes unexpected behaviour","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67472990","1","67473266","","2021-05-10 15:09:09","","1","225","<p>I have 3 classes:</p>
<pre><code>class ClassOne: ObservableObject {
    @Published var loading: Bool = false
}

class ClassTwo: ObservableObject {
    @Published var loading: Bool = false
}

class ClassThree: ObservableObject {
    @Published var loading: Bool = false
}
</code></pre>
<p>In a SwiftUI view I need to do something when all <code>loading</code> variables are <code>true</code></p>
<p>This is a simplified version of my files of course: loading var of every class is set true or false by a download method.
I just need something to check if all download are completed and remove the loading view.</p>
<pre><code>struct MainScreen3: View {
    @State private var cancellables = Set&lt;AnyCancellable&gt;()
    @EnvironmentObject var classOne: ClassOne
    @EnvironmentObject var classTwo: ClassTwo
    @EnvironmentObject var classThree: ClassThree
    
    @State private var loading: Bool = true
    
    var body: some View {
        VStack {
            if loading {
                Text(&quot;Please wait...&quot;)
            } else {
                Text(&quot;Done!&quot;)
            }
            
        }.onAppear {
            self.classOne.fetchFromServer()
            self.classTwo.fetchFromServer()
            self.classThree.fetchFromServer()
        }
    }
}
</code></pre>
<p>Any suggestion?</p>
","15887870","","","","","2021-05-10 23:51:32","Check multiple @Published values","<swift><combine><observableobject>","2","0","","","","CC BY-SA 4.0"
"67491812","1","","","2021-05-11 17:40:48","","0","286","<p>I'm new with SwiftUI and i want to convert basically my computed property for being used in SwiftUI views with combine and all that. I couldn’t use it like that because &quot;get set&quot; doesn't work for my SwiftUI views and I kinda struggled here.
Maybe someone has a good solution how can i convert it with with combine to use in swift ui.</p>
<p>Storage service saves the Authdata into userdefaults.</p>
<pre><code>var currentAuthData: AuthData? {
    get {
        return self.storageService.get(AuthData.self, forKey: authDataStorageKey)
    }
    set {
        if let value = newValue {
            self.storageService.store(value, forKey: authDataStorageKey)
        }
    }
}
</code></pre>
","5696428","","5696428","","2021-05-11 18:34:02","2021-05-11 21:05:28","Convert computed property for @State for Swiftui Views","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"67508127","1","67512477","","2021-05-12 17:08:29","","0","1278","<p>What's the best way, to delay a moment when a publisher sends some data in Swift Combine? Let's assume following situation:</p>
<pre><code>private var publisher: PassthroughSubject&lt;Progress, Error&gt;

// closure called every second:
startWithProgress() { [weak self] progress in
    self.publisher.send(.init(progress: progress))

    // How to call this 0.5 second after the above `send`:
    self.publisher.send(.init(progress: progress + 0.5))
}
</code></pre>
<p>I checked <code>Delay</code> API, but it seems I'd need to create another publisher to make use of it, which is suboptimal in my case. I also checked <code>throttle</code> and <code>debounce</code>, but those also don't allow me to send 2 updates one after another, with a given delay between them.</p>
","1828352","","","","","2021-05-13 00:43:36","Combine - Delay publisher's send","<ios><swift><swiftui><combine>","3","4","","","","CC BY-SA 4.0"
"67523248","1","67523619","","2021-05-13 17:02:33","","1","173","<p>I'm looking for an operator that does the opposite of the <a href=""https://heckj.github.io/swiftui-notes/#reference-collect"" rel=""nofollow noreferrer"">collect</a> operator:</p>
<ul>
<li>Allows you to map from one emission value to many emission values, emitting them on the stream. For example if I have the element <code>[1,2,3]</code> in the stream, I want to convert it into a stream that emits <code>1</code> then <code>2</code>, then <code>3</code>.</li>
<li>Does not change the stream's completion state. Admittedly this <code>uncollect</code> operator wouldn't be exactly the opposite of <code>collect</code> since <code>collect</code> waits until the stream is finished. With <code>uncollect</code> it should just process results while the stream is unfinished, and not attempt to finish/unfinish the stream.</li>
</ul>
<p>For example, I imagine this is how an <code>uncollect</code> operator would function:</p>
<pre><code>func fibonacci(_ number: Int) -&gt; AnyPublisher&lt;Int, Never&gt; {
  Future { ... }.eraseToAnyPublisher()
}

let serverEventStream: AnyPublisher&lt;[Int], Never&gt; = ...

serverEventStream              // AnyPublisher&lt;[Int], Never&gt;  // Ex. 2 values: `[12, 24]`, `[1, 10, 50]`
  .uncollect { $0 }            // AnyPublisher&lt;Int, Never&gt;    // Ex. 5 values: `12`, `24`, `1`, `10`, `50`
  .flatMap { fibonacci($0) }   // AnyPublisher&lt;Int, Never&gt;    // Ex. 5 values: `144`, `46368`, `1`, `55`, `12586269025`
  .sink { print($0) }
</code></pre>
<p>I was looking for names like <code>explode</code>, <code>splat</code>, or <code>uncollect</code>, to no avail. The closest operator that shares a promising name is <a href=""https://heckj.github.io/swiftui-notes/#reference-flatmap"" rel=""nofollow noreferrer""><code>flatMap</code></a> since <a href=""https://developer.apple.com/documentation/swift/sequence/2905332-flatmap"" rel=""nofollow noreferrer""><code>Sequence.flatMap</code></a> is the equivalent in the non-Combine world. However, <a href=""https://stackoverflow.com/questions/59428026/how-to-replicate-promisekit-style-chained-async-flow-using-combine-swift"">Combine's <code>flatMap</code> is the way to chain promises together</a>.</p>
<p>Is there a way to uncollect elements, or map a single emission into an arbitrary number of emissions?</p>
<hr />
<p>I was able to get it to work with my <a href=""https://stackoverflow.com/a/67523545/35690"">custom <code>JustSeveral</code> Publisher</a>, but this seems clunky:</p>
<pre><code>class Tests: XCTestCase {
  func testUncollect() {
    func fibonacci(_ number: Int) -&gt; AnyPublisher&lt;Int, Never&gt; {
      switch number {
      case 1: return Just(1).eraseToAnyPublisher()
      case 10: return Just(55).eraseToAnyPublisher()
      case 12: return Just(144).eraseToAnyPublisher()
      case 24: return Just(46368).eraseToAnyPublisher()
      case 50: return Just(12586269025).eraseToAnyPublisher()
      default: fatalError(&quot;Should actually build this function.&quot;)
      }
    }

    let serverEventStream: AnyPublisher&lt;[Int], Never&gt; = JustSeveral([[12, 24], [1, 10, 50]]).eraseToAnyPublisher()

    serverEventStream              // AnyPublisher&lt;[Int], Never&gt;  // Ex. 2 values: `[12, 24]`, `[1, 10, 50]`
      .uncollect { $0 }            // AnyPublisher&lt;Int, Never&gt;    // Ex. 5 values: `12`, `24`, `1`, `10`, `50`
      .flatMap { fibonacci($0) }   // AnyPublisher&lt;Int, Never&gt;    // Ex. 5 values: `144`, `46368`, `1`, `55`, `12586269025`
      .sink { print($0) }
  }
}

extension Publisher {
  func uncollect&lt;T&gt;(_ transform: @escaping (Output) -&gt; [T]) -&gt; AnyPublisher&lt;T, Failure&gt; {
    self
      .flatMap { output -&gt; AnyPublisher&lt;T, Failure&gt; in
        JustSeveral(transform(output))
          .setFailureType(to: Failure.self)
          .eraseToAnyPublisher()
      }
      .eraseToAnyPublisher()
  }
}
</code></pre>
","35690","","35690","","2021-05-13 17:41:36","2021-05-13 17:47:40","Combine uncollect operator?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"67523504","1","67523663","","2021-05-13 17:21:05","","0","113","<p>I want a Publisher similar to <code>Just</code> except it should emit multiple values, and then complete the stream.</p>
<p>Let's call it <code>JustSeveral</code>:</p>
<pre><code>func fibonacci(_ number: Int) -&gt; AnyPublisher&lt;Int, Never&gt; {
  Future { ... }.eraseToAnyPublisher()
}

JustSeveral([293, 18, 104])
  .flatMap { fibonacci($0) }
  .sink { print($0) }
</code></pre>
<p>Is there a way to combine operators with <code>Just</code> to get the same thing, or do I need to build this Publisher myself?</p>
<p>Note: Any solution should be able to handle an arbitrary number of elements in the array, not just 3.</p>
<hr />
<p>For example, if we had an <a href=""https://stackoverflow.com/questions/67523248/combine-uncollect-operator""><code>uncollect</code> operator</a>, this would be trivial:</p>
<pre><code>Just([293, 18, 104])
  .uncollect { $0 }
  .flatMap { fibonacci($0) }
  .sink { print($0) }
</code></pre>
","35690","","","","","2021-05-24 02:02:55","Just with several values?","<ios><swift><combine>","2","0","","","","CC BY-SA 4.0"
"67525273","1","67526661","","2021-05-13 19:42:02","","1","525","<p>I have this minimal example:</p>
<pre><code>import UIKit
import Combine

var values = [1,2,3,4,5]

var cancel = values.publisher
    .delay(for: 0.1, scheduler: DispatchQueue.global())
    .print()
    .flatMap() { i in
        [i].publisher.first()
    }
    .sink { completion in
        print(&quot;Received Completion: \(completion)&quot;)
    } receiveValue: { v in
        print(&quot;Received Value: \(v)&quot;)
    }
</code></pre>
<p>My expectation is that the source publisher emits the values from 1 to 5 into the stream. Each number gets transformed into (just for the sake of it) a new publisher that emits exactly the first value and then completes. Since this is done with each number, I would expect that all values reach the sink. This is not the case, however. Output looks like this:</p>
<pre><code>request unlimited
receive value: (1)
Received Value: 1
receive value: (2)
Received Value: 2
receive value: (4)
Received Value: 4
receive finished
Received Completion: finished
receive value: (3)
receive value: (5)
</code></pre>
<p>In fact, only 3 values reach the sink before the completion event arrives. Why is this? The <a href=""https://developer.apple.com/documentation/combine/publisher/flatmap(maxpublishers:_:)-3k7z5"" rel=""nofollow noreferrer"">documentation</a> states:</p>
<blockquote>
<p>successful completion of the new Publisher does not complete the overall stream.</p>
</blockquote>
<p>Even more curious, when you replace <code>.flatMap()</code> for <code>.flatMap(maxPublishers: .max(1))</code> and add a <code>.share()</code> to the original source publisher only the first value makes it to the sink.</p>
<p>Any pointers are much appreciated!</p>
","1138434","","","","","2021-05-13 22:09:38","Premature completion of publisher in flatMap in Combine","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"67544607","1","","","2021-05-15 08:12:51","","-1","115","<p>I have a somewhat complicated situation. I'm implementing a simple scrolling chat view in SwiftUI. There's a <code>ChatView</code> with a list of <code>ChatMessageCell</code>s. Each <code>Message</code> has a <code>User</code>, and that has a <code>ProfileImage</code> which is a struct made up of a couple of fields (<code>bucket</code> and <code>key</code>, used to construct the URL to the image on the server). This can periodically update on the <code>User</code> class, and can also be <code>nil</code>.</p>
<p><strong>Update:</strong> This is not a particularly expensive operation, but let’s say for the sake of argument that it is expensive, and I only want to recompute it once. There basically two ways: recompute when (one of the) source properties changes, or recompute when needed and store the result. I’d like to know the best way to do both.</p>
<p>The view needs to construct the URL, because it needs to specify the desired image size for the image. In this way, the URL is a derived property of the <code>message.user.profileImage</code> property.</p>
<p>I tried using <code>.onChange(of: self.message.user.profileImage)</code> in my <code>ChatMessageCell</code> view hierarchy to then compute the URL and set <code>self.profileImageURL</code>, but you can’t set simple properties. So I adorned <code>self.profileImageURL</code> with <code>@State</code>, which allowed the code to compile, and I assign it in <code>init()</code>. But if it’s <code>@State</code>, that assignment doesn't seem to have any effect.</p>
<p>So, I'm pretty unsure how to do this.</p>
<p><code>ChatView</code> and <code>ChatMessageCell</code> look like this:</p>
<pre class=""lang-swift prettyprint-override""><code>struct ChatView : View
{
    @ObservedObject public  var     stream          :   ChatStream
    
    var body: some View {
        ScrollViewReader { scrollView in
            ScrollView {
                LazyVStack {
                    ForEach(self.stream.messages) { inMsg in
                        ChatMessageCell(message: inMsg)
                    }
            }
        }
    }
}

struct
ChatMessageCell: View
{
    public  let     message                 :   ChatStream.Message
    @State  var     profileImageURL         :   URL?
    
    init(message inMessage: ChatStream.Message)
    {
        self.message = inMessage
        let image = inMessage.user.profileImage
        let url = image?.sharpImageURL(forSize: kProfileImageSize)
        self.profileImageURL = url              //  &lt;-- doesn't assign if @State
    }
    
    var body: some View
    {
        VStack(alignment: .leading)
        {
            Text(&quot;Key: \(self.message.user.profileImage?.key ?? &quot;nil&quot;)&quot;)
            Text(&quot;URL: \(self.profileImageURL?.absoluteString ?? &quot;nil&quot;)&quot;)
            //  This is just for debugging. Really there's a `KFImage` here that’s
            //  supposed to async load the image.
        }
        .onChange(of: self.message.user.profileImage)
            { inVal in
                let url = inVal?.sharpImageURL(forSize: kProfileImageSize)
                self.profileImageURL = url      //  &lt;-- can't modify if not @State
            }
    }
}
</code></pre>
<p>Other classes:</p>
<pre class=""lang-swift prettyprint-override""><code>class ChatStream
{
    public struct Message
    {
        var id              :   Int
        var date            :   Date
        var message         :   String
        var user            :   User
        
        init(fromIncoming inMsg: IncomingMessage, user inUser: User)
        {
            self.id = inMsg.id
            self.date = inMsg.date
            self.message = inMsg.message
            self.user = inUser
        }
    }
    
    public class User
    {
        typealias ID = String
        
                    let id                  :   ID
                    var username            :   String
                    var onlineAt            :   Date?
        @Published  var profileImage        :   ProfileImage?
        
        init(fromIncoming inUser: IncomingUser)
        {
            self.id = inUser.id
            self.username = inUser.username
            self.onlineAt = inUser.onlineAt
            self.profileImage = inUser.profileImage
        }
        
        func update(fromIncoming inUser: IncomingUser)
        {
            self.username = inUser.username
            self.onlineAt = inUser.onlineAt
            self.profileImage = inUser.profileImage
        }
    }
    
    @Published  var         messages                                                =   OrderedSet&lt;Message&gt;()
    @Published  var         users                                                   =   [User.ID : User]()
}   

extension ChatStream : ObservableObject {}
extension ChatStream.ProfileImage : Equatable {}
</code></pre>
","251914","","251914","","2021-05-16 04:35:25","2021-05-16 04:35:25","Best way to implement expensive derived properties in SwiftUI?","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67549504","1","","","2021-05-15 17:28:09","","1","2399","<p>I have two Publishers A and B. They are imbalanced as in A will emit 3 values, then complete, B will only emit 1 value, then complete (A actually can emit a variable number, B will remain 1 if that helps):</p>
<pre><code>A =&gt; 1,   2,   3
B =&gt;         X
</code></pre>
<p>B also runs asynchronously and will likely only emit a value after A already emitted its second value (see diagram above). (B might also only emit any time, including after A already completed.)</p>
<p>I'd like to publish tuples of A's values combined with B's values:</p>
<pre><code>(1, X) (2, X) (3, X)
</code></pre>
<p><code>combineLatest</code> is not up for the job as it will skip the first value of A and only emit <code>(2, X)</code> and <code>(3, X)</code>. <code>zip</code> on the other hand will not work for me, because B only emits a single value.</p>
<p>I am looking for an <em>elegant</em>  way to accomplish this. Thanks!</p>
<hr />
<p><em>Edit and approach to a solution</em></p>
<p>A bit philosophical, but I think there is fundamental question if you want to go the <code>zip</code> or <code>combineLatest</code> route. You definitely need some kind of storage for the faster publisher to buffer events while you wait for the slower to start emitting values.</p>
<p>One solution might be to create a publisher that collects events from A until B emits and then emits all of the collected events and continues emitting what A gives. This is actually possible through</p>
<pre><code>let bufferedSubject1 = Publishers.Concatenate(
   prefix: Publishers.PrefixUntilOutput(upstream: subject1, other: subject2).collect().flatMap(\.publisher),
   suffix: subject1)
</code></pre>
<p><code>PrefixUntilOutput</code> will collect everything until B emits (<code>subject2</code>) and then switch to just regularly passing the output of it.</p>
<p>However if you run</p>
<pre><code>let cancel = bufferedSubject1.combineLatest(subject2)    
    .sink(receiveCompletion: { c in
        print(c)
    }, receiveValue: { v in
        print(v)
    })
</code></pre>
<p>you are still missing the first value from A <code>(1,X)</code> -- this seems to be a bit like a race condition: Will <code>bufferedSubject1</code> have all values emitted first or does subject2 provide a value to <code>combineLatest</code> first?</p>
<p>What I think is interesting is that without any async calls, the behavior seems to be undefined. If you run the sample below, sometimes™️ you get all values emitted. Sometimes you are missing out on <code>(1,X)</code>. Since there is no async calls and no dispatchQueue switching here, I would even assume this is a bug.</p>
<p>You can &quot;dirty fix&quot; the race condition by providing a <code>delay</code> or even just a <code>receive(on: DispatchQueue.main)</code> between <code>bufferedSubject1</code> and <code>combineLatest</code>, so that before we continue the pipeline, we hand back control to the DispatchQueue and let subject2 emit to <code>combineLatest</code>.</p>
<p>However, I would not deem that elegant and <strong>still looking for a solution</strong> that uses <code>zip</code> semantics but without having to create an infinite collection of the same value (which does not play well with sequential processing and unlimited demand, the way I see it).</p>
<p>Sample:</p>
<pre><code>var subject1 = PassthroughSubject&lt;Int, Never&gt;()
var subject2 = PassthroughSubject&lt;String, Never&gt;()

let bufferedSubject1 = Publishers.Concatenate(prefix: Publishers.PrefixUntilOutput(upstream: subject1, other: subject2).collect().flatMap(\.publisher),
                                      suffix: subject1)

let bufferedSubject2 = Publishers.Concatenate(prefix: Publishers.PrefixUntilOutput(upstream: subject2, other: subject1).collect().flatMap(\.publisher),
                                      suffix: subject2)

let cancel = bufferedSubject1.combineLatest(subject2)
    .sink(receiveCompletion: { c in
        print(c)
    }, receiveValue: { v in
        print(v)
    })

subject1.send(1)
subject1.send(2)
subject2.send(&quot;X&quot;)
subject2.send(completion: .finished)
subject1.send(3)
subject1.send(completion: .finished)
</code></pre>
","1138434","","1138434","","2021-05-16 10:21:51","2021-12-08 17:11:08","Elegant way to combineLatest without dropping values and imbalanced publishers in Swift Combine","<ios><swift><combine>","4","2","","","","CC BY-SA 4.0"
"67551354","1","","","2021-05-15 21:27:09","","1","366","<p>I want to listen to changes to $email and $password, and then store the result in signInDisabled, but I'm not sure how to listen to changes from both.</p>
<pre><code>@Published var email = &quot;&quot;
@Published var password = &quot;&quot;
var signInDisabled = true

var session : SessionListenerProtocol
private var cancellables = Set&lt;AnyCancellable&gt;()


init(){
    
// ???
    $email, $password  { email, password in
        email == &quot;&quot; || password == &quot;&quot;
    }
    .assign(to: \.signInDisabled, on: self)
    .store(in: &amp;cancellables)

}
</code></pre>
","10142976","","","","","2021-05-15 22:35:21","How to subscribe to multiple publishers in SwiftUI","<swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"67611093","1","","","2021-05-19 21:22:27","","0","317","<p>[Edit]</p>
<p>I should point out that I am collecting data from a large number of sensors and having to pollute the view model, that is orchestrating this, with lots of @Published and subscriber code gets quite tedious and error prone.</p>
<p>I've also edited the code to be more representative of the actual problem.</p>
<p>[Original]
I'm trying to reduce the amount of code needed to observer a result from another class when using publishers. I would prefer to publish the result from a class that is generating the result instead of having to propagate it back to the calling class.</p>
<p>Here is a simple playground example showing the issue.</p>
<pre><code>import SwiftUI
import Combine

class AnObservableObject: ObservableObject {
    
    @Published var flag: Bool = false

    
    private var timerPub: Publishers.Autoconnect&lt;Timer.TimerPublisher&gt;
    
    private var timerSub: AnyCancellable?
    
    init() {
        
        timerPub = Timer.publish(every: 1, on: .current, in: .common)
            .autoconnect()
        
        
    }
    
    func start() {
        timerSub = timerPub.sink { [self] _ in
            toggleFlag()
        }
    }
    
    func stop() {
        timerSub?.cancel()
        
    }
    
    func toggleFlag() {
        flag.toggle()
    }
}

class AnotherObservableObject: ObservableObject {
    let ao = AnObservableObject()
    
    func start() {
        ao.start()
    }
   
    func stop() {
        ao.stop()
    }
    
}

struct MyView: View {
    
    @StateObject var ao = AnotherObservableObject()
    
    var body: some View {
        VStack {
            if ao.ao.flag {
                Image(systemName: &quot;flag&quot;).foregroundColor(.green)
            }
            HStack {
                Button(action: {ao.start()}, label: {
                    Text(&quot;Toggle Flag&quot;)
                })
                Button(action: {ao.stop()}, label: {
                    Text(&quot;Stop&quot;)
                })
            }
        }
        .padding()
    }
}

import PlaygroundSupport
PlaygroundPage.current.needsIndefiniteExecution = true
// Make a UIHostingController
let viewController = UIHostingController(rootView: MyView())
// Assign it to the playground's liveView
PlaygroundPage.current.liveView = viewController
let myView = MyView()
</code></pre>
<p>The Only way I have got this to work is to do this:</p>
<pre><code>import SwiftUI
import Combine

class AnObservableObject: ObservableObject {
    
    let flag = CurrentValueSubject&lt;Bool, Never&gt;(false)

    private var subscriptions = Set&lt;AnyCancellable&gt;()

    
    private var timerPub: Publishers.Autoconnect&lt;Timer.TimerPublisher&gt;
    
    private var timerSub: AnyCancellable?
    
    init() {
        
        timerPub = Timer.publish(every: 1, on: .current, in: .common)
            .autoconnect()
        
        
    }
    
    func start() {
        timerSub = timerPub.sink { [self] _ in
            toggleFlag()
        }
    }
    
    func stop() {
        timerSub?.cancel()
        
    }
    
    func flagPublisher() -&gt; AnyPublisher&lt;Bool, Never&gt; {
        return flag.eraseToAnyPublisher()
    }
    
    func toggleFlag() {
        flag.value.toggle()
    }
}

class AnotherObservableObject: ObservableObject {
    let ao = AnObservableObject()
    
    @Published var flag = false
    
    
    
    init() {


        let flagPublisher = ao.flagPublisher()

        flagPublisher
            .receive(on: DispatchQueue.main)
            .assign(to: &amp;$flag)
    }
    
    func start() {
        ao.start()
    }
   
    func stop() {
        ao.stop()
    }
    
}

struct MyView: View {
    
    @StateObject var ao = AnotherObservableObject()
    
    var body: some View {
        VStack {
            if ao.flag {
                Image(systemName: &quot;flag&quot;).foregroundColor(.green)
            }
            HStack {
                Button(action: {ao.start()}, label: {
                    Text(&quot;Toggle Flag&quot;)
                })
                Button(action: {ao.stop()}, label: {
                    Text(&quot;Stop&quot;)
                })
            }
        }
        .padding()
    }
}

import PlaygroundSupport
PlaygroundPage.current.needsIndefiniteExecution = true
// Make a UIHostingController
let viewController = UIHostingController(rootView: MyView())
// Assign it to the playground's liveView
PlaygroundPage.current.liveView = viewController
let myView = MyView()
</code></pre>
<p>Thoughts?</p>
","4546605","","4546605","","2021-05-20 01:12:34","2021-05-20 01:12:34","How to observe a published property via another observable 0bject - Swift Combine","<swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"67614483","1","","","2021-05-20 05:30:50","","1","1802","<p>I have a set of traditional <code>UIViewController</code>s and <code>UIView</code>s that I’m passing a <code>Publisher</code> to:</p>
<pre class=""lang-swift prettyprint-override""><code>class MyModel : ObservableObject {
    @Published var product: Product?
}

…

let someView = SomeView(product: self.model.$product)

…

class SomeView : UIView {
    init(product: Published&lt;Product?&gt;.Publisher) {
        self.sub = product.sink { prod in &lt;do stuff when it changes&gt; }
    }
</code></pre>
<p>I need to do something with one of the properties of <code>MyModel.product</code> only once when the view inits, and <em>not</em> every subsequent time <code>product</code> updates. Is there anything like this:</p>
<pre class=""lang-swift prettyprint-override""><code>    self.pub = product
        .sinkOnSub { prod in &lt;do when creating this subscription&gt; }
        .sinkRemaining { prod in &lt;do subsequent times&gt; }
</code></pre>
","251914","","","","","2021-07-16 13:05:43","Swift Combine: Getting only the first value at subscription?","<swift><combine>","2","5","1","","","CC BY-SA 4.0"
"67614590","1","67693133","","2021-05-20 05:42:39","","0","122","<p>Anyone who understands please help me, I want to retrieve data from Firestore and it wants to be read in realtime whenever there is a change from the database, so I use addSnapshotListener to read it, it works every time there is a change from Firestore, but it's still in object form NewsResponse. Because the final result I want to change to a NewsDomainModel form, then I continue the results from NewsResponse to _mapper.transformerResponseToDomain to be converted into NewsDomainModel, but every latest data generated using addSnapshotListener is not updated to the _mapper.transformerResponseToDomain, _mapper only reads 1 time the data sent only.</p>
<p>GetNewsRepository</p>
<pre><code>import SwiftUI
import Core
import Combine

public class GetNewsRepository&lt;
  NewsLocaleDataSource: LocaleDataSource,
  RemoteDataSource: DataSource,
  Transformer: Mapper&gt;: ObservableObject, Repository
where
  NewsLocaleDataSource.Request == String,
  NewsLocaleDataSource.Response == NewsModuleEntity,
  RemoteDataSource.Request == String,
  RemoteDataSource.Response == [NewsResponse],
  Transformer.Request == String,
  Transformer.Response == [NewsResponse],
  Transformer.Entity == [NewsModuleEntity],
  Transformer.Domain == [NewsDomainModel] {
  
  public typealias Request = String
  @Published public var Response: [NewsDomainModel] = [NewsDomainModel]()
  
  private let _localeDataSource: NewsLocaleDataSource
  @Published public var _remoteDataSource: RemoteDataSource
  @Published public var _mapper: Transformer
  
  public init(
    localeDataSource: NewsLocaleDataSource,
    remoteDataSource: RemoteDataSource,
    mapper: Transformer) {
    _localeDataSource = localeDataSource
    _remoteDataSource = remoteDataSource
    _mapper = mapper
  }
  
  public func execute(request: String?) -&gt; AnyPublisher&lt;[NewsDomainModel], Error&gt; {
    return self._remoteDataSource.execute(request: request)
      .map { self._mapper.transformerResponseToDomain(response: $0) }
      .eraseToAnyPublisher()
  }
}
</code></pre>
<p>GetNewsRemoteDataSource</p>
<pre><code>import Core
import Combine
import FirebaseFirestore
import FirebaseFirestoreSwift
import Foundation

public class GetNewsRemoteDataSource: ObservableObject, DataSource {
  
  public typealias Request = String
  @Published public var Response: [NewsResponse] = [NewsResponse]()
  private let _endPoint: String
  
  public init(endPoint: String) {
    _endPoint = endPoint
  }
  
  public func execute(request: String?) -&gt; AnyPublisher&lt;[NewsResponse], Error&gt; {
    return Future&lt;[NewsResponse], Error&gt; { completion in
      let ref = Firestore.firestore()
      
      ref.collection(&quot;news&quot;).addSnapshotListener { (querySnapshot, error) in
        guard let documents = querySnapshot?.documents else {
          print(&quot;Document not found&quot;)
          return
        }
        
        let dataJson = documents.compactMap { queryDocumentSnapshot in
          try? queryDocumentSnapshot.data(as: NewsResponse.self)
        } // THIS DATA WILL BE AUTOMATIC UPDATE IF DATA FROM FIRESTORE UPDATED
        
        completion(.success(dataJson))
      }
    }.eraseToAnyPublisher()
  }
}
</code></pre>
<p>NewsTransformer</p>
<pre><code>import Core
import Combine

public class NewsTransformer&lt;NewsMapper: Mapper&gt;: ObservableObject, Mapper
where
  NewsMapper.Request == String,
  NewsMapper.Response == NewsResponse,
  NewsMapper.Entity == NewsModuleEntity,
  NewsMapper.Domain == NewsDomainModel {
  
  @Published public var Request = String()
  @Published public var Response = [NewsResponse]()
  @Published public var Entity = [NewsModuleEntity]()
  @Published public var Domain = [NewsDomainModel]()
  
  private let _newsMapper: NewsMapper
  
  public init(newsMapper: NewsMapper) {
    _newsMapper = newsMapper
  }
  
  public func transformerResponseToEntity(request: String?, response: [NewsResponse]) -&gt; [NewsModuleEntity] {
    return response.map { result in
      _newsMapper.transformerResponseToEntity(request: request, response: result)
    }
  }
  
  public func transformerResponseToDomain(response: [NewsResponse]) -&gt; [NewsDomainModel] {
    print(&quot;\(response) DATA RESPONSE&quot;) // NOT UPDATING
    return response.map { results in
      _newsMapper.transformerResponseToDomain(response: results)
    }
  }
  
  public func transformerEntityToDomain(entity: [NewsModuleEntity]) -&gt; [NewsDomainModel] {
    return entity.map { result in
      _newsMapper.transformerEntityToDomain(entity: result)
    }
  }
  
  public func transformerDomainToEntities(domain: [NewsDomainModel]) -&gt; [NewsModuleEntity] {
    return domain.map { result in
      _newsMapper.transformerDomainToEntities(domain: result)
    }
  }
}
</code></pre>
<p>The sequence of images above is GetNewsRepository (Repository), GetNewsRemoteDataSource (Get Data From Firebase), NewsTransformer (Transform from NewsResponse to NewsDomainModel)</p>
<p>Sorry if the title I ask is wrong.</p>
","9105991","","9105991","","2021-05-20 05:50:40","2021-05-25 17:48:19","Published Object Not Working - Combine Swift","<swift><google-cloud-firestore><combine>","1","2","","","","CC BY-SA 4.0"
"67616747","1","67626425","","2021-05-20 08:30:28","","-3","219","<p>Take this case of a type constrained class <code>Parameter</code>, wrapping a value of given type.</p>
<p>Parameter conforms to the <code>AnyParameter</code> so it can be passed anywhere in the app without knowing the type. Parameters can be displayed in value cells <code>AnyValueCell</code></p>
<ul>
<li>How would you do to observe the change without having to know the underlying value type? It would be nice to avoid the code repetition in the value cell <code>updateObserver</code> function</li>
<li>Could <code>AnyPublisher</code> can be used here and how?</li>
</ul>
<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Combine

print(&quot;Hello Playground&quot;)

protocol AnyParameter {
    var anyValue: Any { get }
    func set(value: Any)
}

protocol ParameterProtocol: AnyParameter {
    associatedtype ValueType
    
    var value: ValueType { get }
    func set(value: ValueType)

}

public class Parameter&lt;T&gt;: ParameterProtocol {
    
    typealias ValueType = T
    
    @Published var value: T
    
    var anyValue: Any { value }
    
    init(value: T) {
        self.value = value
    }
    
    func set(value: Any) {
        guard let value = value as? T else { return }
        set(value: value)
    }
    
    func set(value: T) {
        self.value = value
    }
}


public class AnyValueCell {
    
    var parameter: AnyParameter {
        didSet {
            updateObserver()
        }
    }
    
    var observer: AnyCancellable?
    
    init(parameter: AnyParameter) {
        self.parameter = parameter
        updateObserver()
    }
    
    func updateObserver() {
        observer?.cancel()
        
        // This is the point of the question - How to make this generic?
        // ----&gt;
        if let p = parameter as? Parameter&lt;Int&gt; {
            observer = p.$value.sink() { value in
                print(&quot;Update Cell -&gt; \(value)&quot;)
            }
            return
        }

        if let p = parameter as? Parameter&lt;Double&gt; {
            observer = p.$value.sink() { value in
                print(&quot;Update Cell -&gt; \(value)&quot;)
            }
            return
        }

        if let p = parameter as? Parameter&lt;Bool&gt; {
            observer = p.$value.sink() { value in
                print(&quot;Update Cell -&gt; \(value)&quot;)
            }
            return
        }
        // &lt;----

        print(&quot;Wrong param type&quot;)
    }
}

let intParam = Parameter&lt;Int&gt;(value: 42)
let doubleParam = Parameter&lt;Double&gt;(value: 3.14)
let boolParam = Parameter&lt;Bool&gt;(value: false)

var params: [AnyParameter] = [intParam, doubleParam, boolParam]

print (&quot;--&gt; Init Cells&quot;)
let cells: [AnyValueCell] = params.map { AnyValueCell(parameter: $0) }

print (&quot;--&gt; Change values&quot;)
intParam.set(value: 21)
doubleParam.set(value: 1.618)
boolParam.set(value: true)
</code></pre>
<p>Result, as expected:</p>
<pre><code>Hello Playground
--&gt; Init Cells
Update Cell -&gt; 42
Update Cell -&gt; 3.14
Update Cell -&gt; false
--&gt; Change values
Update Cell -&gt; 21
Update Cell -&gt; 1.618
Update Cell -&gt; true
</code></pre>
","441197","","","","","2021-05-20 18:51:43","Observe generic values with Combine","<swift><combine><type-constraints>","1","4","","","","CC BY-SA 4.0"
"67634928","1","67635273","","2021-05-21 10:15:41","","0","59","<p>I'm trying to load an array of <code>SCEvent</code>s into an array of <code>EventModel</code>s using Combine. The variable <code>imagePath</code> is optional, which I'd like to translate it to an empty <code>Data()</code> in its corresponding <code>EventModel.imageData</code> variable.</p>
<pre class=""lang-swift prettyprint-override""><code>struct SCEvent {
    let name: String
    let imagePath: String?
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>struct EventModel {
    let name: String
    let imageData: Data
}

</code></pre>
<p>The following code seems to work, but I can't help but wonder if it is the most optimal way of doing it:</p>
<pre class=""lang-swift prettyprint-override""><code>func loadEvents(_ events: [SCEvent]) -&gt; AnyPublisher&lt;[EventModel], Error&gt; {
    events.publisher
        .flatMap(loadEvent(_:))
        .collect()
        .eraseToAnyPublisher()
}

func loadEvent(_ event: SCEvent) -&gt; AnyPublisher&lt;EventModel, Error&gt; {
    if let imagePath = event.imagePath {
        return DataDownloader.downloadData(fromPath: imagePath)
                   .map { EventModel(name: event.name, imageData: $0) }
                   .eraseToAnyPublisher()
    }

    return Just(EventModel(name: event.name, imageData: Data())
               .eraseToAnyPublisher()
}
</code></pre>
<p>Ideally, I'd like to use a single publisher in the <code>loadEvent</code> function. Maybe something like this (doesn't work, but serves as an example of what I expect):</p>
<pre class=""lang-swift prettyprint-override""><code>func loadEvent(_ event: SCEvent) -&gt; AnyPublisher&lt;[EventModel], Error&gt; {
    event.imagePath
        .flatMap(DataDownloader.downloadData(_:))
        .replaceNil(with: Data())
        .map {
            EventModel(name: event.name, imageData: $0)
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>Which doesn't work because <code>.replaceNil</code> should be used after <code>event.imagePath</code> to replace a <code>nil</code> string. Another possible approach would be:</p>
<pre class=""lang-swift prettyprint-override""><code>func loadEvent(_ event: SCEvent) -&gt; AnyPublisher&lt;[EventModel], Error&gt; {
    event.imagePath
        .replaceNil(with: &quot;&quot;)
        .flatMap(
            DataDownloader.downloadData(_:)
                .replaceError(with: Data())
        )
        .map {
            EventModel(name: event.name, imageData: $0)
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>But it seems forced. Is it even possible with Combine? Is my initial approach the only valid solution?</p>
","2148023","","","","","2021-05-21 10:38:53","Combine using optional struct variable","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"67651153","1","","","2021-05-22 15:20:25","","0","126","<p>I am getting weird memory leaks in Combine. When wiring up the model of a view I need to connect a <code>PassThroughSubject</code> in my view model with a <code>PassThroughSubject</code> in my business logic. The <code>viewModel</code> gets regenerated with the view and the business logic <code>model</code> stays the same and persists over time.</p>
<p>I use the code below to connect. The one using <code>sink</code> does not leak, the one using <code>subscribe</code> leaks.</p>
<p>The reference to self does not seem to be the problem as the class that runs the connection logic is properly cleaned up (I also created a weak variable that I passed to subscribe). Also the viewModel is being cleaned up - with the subscriptions. Only a loop containing Combine classes stays. (see Image below)</p>
<p>It does not seem to be a temporary glitch of memory graph as the object count reflect the number of times I regenerated the view (and the viewModel) and I checked the reference count of the objects with CFGetRetainCount - and they reflect the links displayed in memory graph.</p>
<p>I would very much understand what's going on here. Any clues? My mistake? Known issue? Bug in Combine?</p>
<pre><code>   // not leaking 
   viewModel.triggerSubject
        .sink { [weak self] trigger in
            self?.model.triggerSubject.send(trigger)            }
        .store(in: &amp;viewModel.subscriptions)
    
    // leaking
    viewModel.triggerSubject
        .subscribe(model.triggerSubject)
        .store(in: &amp;viewModel.subscriptions)
</code></pre>
<p>Here is the Memory Graph:</p>
<p><a href=""https://i.stack.imgur.com/cm5Pf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cm5Pf.png"" alt=""Memory Graph"" /></a></p>
<p>And the issues reported by XCode:</p>
<p><a href=""https://i.stack.imgur.com/8SMDK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8SMDK.png"" alt=""Memory Issues"" /></a></p>
","10851991","","10851991","","2021-05-22 15:38:09","2021-05-22 15:38:09","Is Combines Publisher.subscribe(_ subject) leaking sometimes?","<ios><swift><combine>","0","4","","","","CC BY-SA 4.0"
"67656262","1","","","2021-05-23 04:53:02","","2","102","<p>I have a <code>Flight</code> Realm class with a <code>duration</code> property that is an <code>Int</code>. It stores the duration of a flight as the number of minutes.</p>
<pre><code>class Flight: Object, ObjectKeyIdentifiable{
  @objc dynamic var duration = 0
}
</code></pre>
<p>I pass a <code>Flight</code> object as an <code>ObservedRealmObject</code> to a child view where it's edited. The user can enter the time as <code>HHMM</code> (130 = 1 hr 30 min) or <code>#.#</code> (1.5 hrs). I have some extensions that convert either of those times from a <code>String</code> to the number of minutes stored as an <code>Int</code> and back again.</p>
<p>But the problem I'm having is binding my <code>TextField</code>. I can't bind to the <code>duration</code> property directly because I need to convert it from the time format to the number of minutes.</p>
<pre><code>struct MyView: View {
  @ObservedRealmObject var flight: Flight
  @AppStorage(&quot;timeDisplayHHMM&quot;) var timeDisplayHHMM = false
  
  var body: some View{
    TextField(timeDisplayHHMM ? &quot;HHMM&quot;: &quot;#.#&quot;, text: $flight.duration)
  }
}
</code></pre>
<p>I've tried a couple different approaches that don't quite work right.</p>
<h2>Attempt 1</h2>
<p>I created a <code>@State</code> variable which I set in <code>.onAppear</code> and then I save the value inside <code>.onChange</code> like this:</p>
<pre><code>@State var duration = &quot;&quot;

TextField(...)
  .onChange(of: duration, perform: { value in
    //Save duration using my view model
    model.saveDuration(flight: $flight, duration: duration)
  })
  .onAppear(){
    //Get value
    duration = flight.duration.timeDisplay //&quot;timeDisplay&quot; is my conversion Int extension.
  }
</code></pre>
<p>This works great, but it relies on <code>onAppear</code> to keep its value updated. So if the <code>duration</code> changes in my Realm, the UI won't update unless the user causes the view to appear again.</p>
<h2>Attempt 2</h2>
<p>I've tried creating a custom binding and I set the binding's value from the Realm property, and then save it in the setter. This behaves erratically as the user types because the value is saved and updated before they can finish typing.</p>
<p>For example, if they type <code>1.</code> then it quickly saves it as 1 hour and then the value updates to <code>1.0</code> before they can finish typing <code>1.5</code>.</p>
<pre><code>private var durationBinding: Binding&lt;String&gt; {
  Binding&lt;String&gt;(get: {
    //Set binding value
    flight.duration.timeDisplay
  }, set: {
    //Save
    model.saveDuration(flight: $flight, duration: $0)
  })
}
</code></pre>
<p>How can I get the benefits of binding to a <code>String</code> Realm property while still having the value convert to/from an <code>Int</code>?</p>
","1142348","","","","","2021-05-23 04:53:02","Convert Value on Realm Property When Retrieved and Saved in SwiftUI","<swift><swiftui><realm><combine>","0","3","","","","CC BY-SA 4.0"
"67666642","1","","","2021-05-24 04:23:09","","0","1185","<p>Is there any way to tell SwiftUI to receive changes to an <code>@ObservedObject</code> property on the main thread?</p>
<p>I have a model object that manages a list of chat messages and users in a chat channel. The channel is fed by some websocket code that periodically calls methods like <code>addMessages()</code> or <code>usersJoinedAndLeft()</code> on my model. My model then does some housekeeping of user and message lists.</p>
<pre class=""lang-swift prettyprint-override""><code>class ChatStream
    @Published var users: [Users]
    @Published var messages: [Message]
}
</code></pre>
<p>My SwiftUI  looks like</p>
<pre class=""lang-swift prettyprint-override""><code>struct OverlayChatView : View {
    @ObservedObject public var stream: ChatStream
    var body: some View {
        …
            ForEach(self.stream.messages) { inMsg in
            }
        …
    }
}
</code></pre>
<p>This all works great. The problem came when my network code updated to make its calls on a different dispatch queue. Now the changes to <code>.users</code> and <code>.messages</code> happen on this queue, and SwiftUI tries to update on this queue.</p>
<p>The obvious fix is to wrap all my changes to <code>.users</code> and <code>.messages</code> in <code>DispatchQueue.main.async</code> calls. But that gets kind of messy, as all that housekeeping is done in-place, possibly updating <code>.users</code> and <code>.messages</code> several times before it finishes processing a set of incoming messages or user presence changes (in the end it keeps an ordered list of messages and a collection of present and departed users, with each message referencing its author, because users can come back, and their properties can change.)</p>
<p>So, I could change my code to work on temporary copies of these collections, and only set the published properties at the end of the processing in a dispatch async call. This would have the added benefit of coalescing a lot of those interim changes.</p>
<p>I could add a second <code>PassthroughSubject</code> and call <code>.send()</code> at the end, but this seems clunky and undoes the streamlined nature of SwiftUI, since I’d probably have to keep a separate copy of the state to update on the main thread.</p>
<p>What I’d love to do is something like</p>
<pre class=""lang-swift prettyprint-override""><code>    @ObservedObject(receiveOn: DispatchQueue.main) var stream: ChatStream
</code></pre>
<p>or alternatively in my model, something like</p>
<pre class=""lang-swift prettyprint-override""><code>class ChatStream {
    func add(messages: [Message]) {
        self.$users.suspend()
        self.$messages.suspend()
        …process messages…
        DispatchQueue.main.async {
            self.$users.resume()
            self.$messages.resume()
        }
}
</code></pre>
<p>But it seems SwiftUI should probably just handle rebuilding the UI on the main thread for me, given that it requires it.</p>
","251914","","","","","2022-07-04 16:58:23","Receiving SwiftUI observed changes on the main thread","<swift><swiftui><combine>","3","6","","","","CC BY-SA 4.0"
"67692011","1","","","2021-05-25 16:26:31","","0","234","<p>I'm currently dealing with this problem. I have Firestore database. My goal is to fill <code>friends</code> array with <code>User</code> entities after being fetched. I call <code>fetchFriends</code>, which fetches currently logged user, that has <code>friends</code> array in it (each item is ID of friend). <code>friends</code> array is then looped and each ID of friend is fetched and new entity <code>User</code> is made. I want to map this <code>friends</code> array to <code>friends</code> Published variable. What I did there does not work and I'm not able to come up with some solution.</p>
<p>Firestore DB</p>
<pre><code>User
- name: String
- friends: [String]
</code></pre>
<p>User model</p>
<pre class=""lang-swift prettyprint-override""><code>struct User: Identifiable, Codable {   
    @DocumentID var id: String?
    var name: String?
    var email: String
    var photoURL: URL?
    
    var friends: [String]?
}
</code></pre>
<p>User ViewModel</p>
<pre class=""lang-swift prettyprint-override""><code>@Published var friends = [User?]()

func fetchFriends(uid: String) {
    
    let userRef = db.collection(&quot;users&quot;).document(uid)
    
    userRef.addSnapshotListener { documentSnapshot, error in
        
        do {
            guard let user = try documentSnapshot?.data(as: User.self) else {
                return
            }
            
            self.friends = user.friends!.compactMap({ friendUid in
                
                self.fetchUserAndReturn(uid: friendUid) { friend in
                    return friend
                }
            })
        }
        catch {
            print(error)
        }
    }
}

func fetchUserAndReturn(uid: String, callback:@escaping (User)-&gt;User) {
    let friendRef = db.collection(&quot;users&quot;).document(uid)
    
    friendRef.getDocument { document, error in
        callback(try! document?.data(as: User.self) as! User)
    }
}
</code></pre>
","12817338","","15082848","","2021-05-25 17:34:08","2021-05-25 19:04:32","Swift+Firestore - return from getDocument() function","<swift><firebase><google-cloud-firestore><combine>","1","6","","","","CC BY-SA 4.0"
"67722933","1","","","2021-05-27 13:15:47","","0","42","<p>I'm trying to load or create a &quot;Season&quot; which is basically a quarter or a month long block of time stored as a subcollection document inside a user profile document in cloud Firestore.</p>
<p>I have an &quot;order&quot; field in the Season subcollection that increments with each newly created season, and my query is just finding the most recent one.</p>
<p>I call this function (loadOrCreateCurrentSeason) that loads the most recent season, which returns a Combine Future - either a Season in my data model or an error, and it subscribes to that. It will return the season it finds as long as there is no error, and as long as the season it returns encompasses the current date.</p>
<p>If either of those are not true, it will create a new one and add that document to Firebase.</p>
<p>The issue I'm having is that in the helper function I'm using to return the most recent season, when it loads the document and tries to convert it to my app's model for Seasons (<code>let x = try document.data(as: Season.self</code>) my app keeps returning x as nil.</p>
<p>I'm not sure if this is an error with my query, or how I have the function set up to return the data as a Season, but I'm wondering if there's anything in there that may be preventing the app from converting the Firestore document into a Season?</p>
<p>Main function called on initialization of the Repository:</p>
<pre><code>    func loadOrCreateCurrentSeason() {
        var _ = loadMostRecentSeason()
            .sink(receiveCompletion: { error in
                self.addSeasonToSubcollection(season: Season(lastOrder: 0))
            }, receiveValue: { [weak self] season in
                    if season.endDate &lt; Date() {
                        let oldOrder = season.order
                        self?.saveCurrentSeasonToPast()
                        self?.currentSeason = self?.createCurrentSeason(order: oldOrder)
                        self?.addSeasonToSubcollection(season: season)
                    } else {
                        self?.currentSeason = season
                    }
                })
            .store(in: &amp;cancellables)
    }
</code></pre>
<p>Helper Function called to specifically load the most recent season from Firebase:</p>
<pre><code>    func loadMostRecentSeason() -&gt; Future&lt;Season, ErrorLoadingSeason&gt; {
        let seasonRef = db.collection(&quot;users&quot;).document(userProfile.id!).collection(&quot;season&quot;)
        
        return Future&lt;Season, ErrorLoadingSeason&gt; { promise in
            seasonRef.order(by: &quot;order&quot;, descending: true)
                .limit(to: 1)
                .getDocuments() { (querySnapshot, err) in
                    if let err = err {
                        print(&quot;Error getting most recent season: \(err.localizedDescription)&quot;)
                        promise(Result.failure(ErrorLoadingSeason.NoSeasonFound))
                    } else {
                        for document in querySnapshot!.documents {
                            do {
                                let x = try document.data(as: Season.self)
                                if x != nil {
                                    promise(Result.success(x!))
                                } else {
                                    promise(Result.failure(ErrorLoadingSeason.NoSeasonFound))
                                }
                            } catch {
                                print(&quot;An error converting the most recent season&quot;)
                                print(error)
                                promise(Result.failure(ErrorLoadingSeason.couldNotConvertData))
                            }
                        }
                    }
                }
        }
    }
</code></pre>
<p>Here's my structure for Seasons if this makes a difference:</p>
<pre><code>struct Season: Codable, Identifiable {
    
    // Identifiers
    @DocumentID var id: String?
    var title: String?
    var userId: String
    var order: Int
    
    //Completion Details
    var startDate: Date
    var endDate: Date
    // var seasonType: SeasonType?
    
    init(lastOrder: Int) {
        let userProfile = CurrentUserProfile.shared.currentUser!
        
        self.userId = userProfile.id!
        self.startDate = Date().startOfPeriod(userProfile.seasonLength ?? .quarter)
        self.endDate = Date().endOfPeriod(userProfile.seasonLength ?? .quarter)
        self.order = lastOrder + 1
        self.title = setTitle(userProfile: userProfile)
    }
    
}
</code></pre>
","13831483","","","","","2021-05-29 02:34:28","Returning and subscribing to the most recent value in a Firestore subcollection","<swift><google-cloud-firestore><combine>","1","2","","","","CC BY-SA 4.0"
"67727584","1","67728701","","2021-05-27 17:58:51","","0","242","<p>Please help me, I would like to test the <code>viewModel</code>, when I'm run unit test and then an error is raised <code>Asynchronous wait failed: Exceeded timeout of 1 second</code></p>
<pre><code>var usersSubject = PassthroughSubject&lt;[User],Error&gt;()

    func fetchUsers(){
        let url = URL(string: endpoint.urlString)!
        apiManager.fetchItems(url: url) { (result: Result&lt;[User],Error&gt;)  in
            switch result {
            case .success(let users):
                self.usersSubject.send(users)
            case .failure(let error):
                self.usersSubject.send(completion: .failure(error))
            }
        }
    }
</code></pre>
<pre><code>    func testsuccess(){
        viewModel.usersSubject.sink { completion in
            self.exectation.fulfill()
        } receiveValue: { users in
            XCTAssertEqual(1, users.count)
            XCTAssertEqual(&quot;Hello World&quot;, users[0].name)
            self.exectation.fulfill()
        }
        
        viewModel.fetchUsers()
        XCTAssertEqual(1, apiManager.numberOfCalled)
        
        wait(for: [exectation], timeout: 1.0)
    }

    class StubApiManager: APIManager {
        var numberOfCalled = 0
        override func fetchItems&lt;T&gt;(url: URL, completion: @escaping (Result&lt;[T], Error&gt;) -&gt; Void) where T : Decodable {
            let users = [
            User(id: 1, name: &quot;Hello World&quot;)
            ]
            numberOfCalled += 1
            completion(.success(users as! [T]))
        }
    }
</code></pre>
","11966001","","11966001","","2021-05-29 02:10:23","2021-05-29 02:10:23","On unit test, How does assert the PassthroughSubject value without an external library?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"67765693","1","","","2021-05-30 20:48:08","","0","145","<p>I've got a case where I'm using a <code>dataTaskPublisher</code> and then chaining the output, as shown below. Now I'm implementing a background download, using <code>URLSession</code>'s <code>downloadTask(with:completionHandler)</code> and I need to perform the exact same operations.</p>
<p>So everything in the code, below, from the <code>decode(type:decoder)</code> onwards is common between both situations. Is there some way I can take a <code>Data</code> object and let it be passed through that same set of steps without duplicating the code?</p>
<pre class=""lang-swift prettyprint-override""><code>anyCancellable = session.dataTaskPublisher(for: url)
  .map { $0.data }
  .decode(type: TideLowWaterHeightPredictions.self, decoder: Self.decoder)
  .map { $0.predictions }
  .eraseToAnyPublisher()
  .sink {
    ...
  } receiveValue: { predictions in
    ...
  }
</code></pre>
","1455351","","","","","2021-05-30 22:45:59","Reusable publishers (subscriptions?) in Combine","<swift><combine>","1","5","","","","CC BY-SA 4.0"
"67768620","1","","","2021-05-31 06:00:32","","0","116","<p>This piece of code does not result in a logged request on my server or a printed result.</p>
<pre><code>AF.request(endpoint, method: .post, parameters: parameters, headers: nil)
            .validate().publishDecodable(type: Token.self, decoder: decoder).value().print()
</code></pre>
<p>This, however, does:</p>
<pre><code>AF.request(endpoint, method: .post, parameters: parameters, headers: nil)
            .validate().responseDecodable(of: Token.self, decoder: decoder){
                print($0)
            }
</code></pre>
<p>How should the former be modified to produce the desired result?</p>
","11914759","","","","","2021-06-01 01:23:36","Alamofire publishDecodable does not send request to server but responseDecodable does","<swift><alamofire><combine>","1","0","","","","CC BY-SA 4.0"
"67775182","1","","","2021-05-31 13:58:38","","0","244","<p>I don't have much skill in reactive programming with Swift and I don't know how I can subscribe to a service that is a publisher and how to transform the output to an object.</p>
<p>The code is:</p>
<p>sorry, where?</p>
<p>the complete code is this:</p>
<pre><code>@Published var authResponse: Bool = false
let fireStoreDBService: FirestoreDbServiceProtocol = FirestoreDBService(). //return AnyPublishers

func authentication(email: String, password: String) -&gt; Bool {
      
    return fireStoreDBService.authentication(email: email, password: password)
        .map{ auth -&gt; Bool in
            
            self.authResponse = auth
            return self.authResponse
            
        }
}
</code></pre>
<p><strong>Error:</strong>
Cannot convert return expression of type 'Publishers.Map&lt;AnyPublisher&lt;Bool, Error&gt;, Bool&gt;' to return type 'Bool'</p>
<p>Thanks</p>
","11845697","","11845697","","2021-05-31 15:55:25","2021-05-31 15:55:25","Swiftui. Combine transform Publisher to object","<swift><publish-subscribe><reactive><combine>","0","3","","","","CC BY-SA 4.0"
"67775625","1","67781680","","2021-05-31 14:27:15","","5","2217","<p>I am making a post request, which has an empty response</p>
<pre><code>AF.request(URL(string: &quot;some url&quot;)!, method: .post, parameters: parameters, encoding: URLEncoding.default, headers: nil)
    .validate()
    .publishDecodable(type: T.self)
    .value()
    .eraseToAnyPublisher()
</code></pre>
<p>where T is</p>
<p><code>struct EmptyResponse: Codable {}</code></p>
<p>and I am having this error &quot;Response could not be serialized, input data was nil or zero length.&quot;
How do I handle a post request with an empty response using Alamofire and Combine?</p>
","","user13691063","","","","2022-01-31 22:54:40","How to handle empty response using Alamofire and Combine?","<ios><swift><alamofire><combine>","3","0","","","","CC BY-SA 4.0"
"67782329","1","","","2021-06-01 03:22:52","","1","68","<p>I need a one-second timer in my app, ideally firing on or just after the integral wall-clock second. Traditionally I would do this using <code>Timer(fire date: Date,…)</code> and pre-compute the appropriate <code>Date</code> for the upcoming second. I do this to ensure second-resolution timers in my app are well-synced to wall clock time, as one second is a long time, even for a human, in this app.</p>
<p>Is there any way to set up a first-fire date using <code>Timer.publish()</code>? Aside from using a regular timer to set it up, that is.</p>
","251914","","","","","2021-06-01 03:22:52","Timer.publish() vs Timer(fire:...)","<swift><timer><combine>","0","2","","","","CC BY-SA 4.0"
"67797742","1","","","2021-06-02 01:16:37","","1","260","<p>Not sure why i'm getting this.. any suggestions would be grateful!</p>
<p>I ran into issues with my original coding where I had Firebase pod and Firebase Package.. so I started from scratch since that wasnt fixing itself.. now I get this.. and I am at a loss for how to resolve it.</p>
<pre><code>static func fetchUsers() -&gt; AnyPublisher&lt;[UserProfile], Error&gt; {
        Future&lt; [UserProfile], Error &gt; { promise in
            self.db.collection(&quot;Users&quot;)
                .getDocuments { (snapshot, error) in
                    if let error = error {
                        promise(.failure(error))
                        return
                    }
                    
                    guard let snapshot = snapshot else {
                        promise(.failure(FirebaseError.badSnapshot))
                        return
                    }
                    
                    var users = [UserProfile]()
                    snapshot.documents.forEach { document in
                        print(users.count)
                        
                        if let user = try? document.data(as: UserProfile.self){
                            if users.contains(where: { $0.id == user.id}) {return}
                            users.append(user)
                        }  else {
                            print(&quot;Not working&quot;)
                        }
                    }
                    
                    promise(.success(users))
                    
                }
        }
        .eraseToAnyPublisher()
    }
</code></pre>
<p><img src=""https://i.stack.imgur.com/EPi6o.png"" alt=""Image of Error"" /></p>
","3288011","","209103","","2021-06-02 01:50:31","2021-06-02 16:26:50","Argument passed to call that takes no arguments.. Firebase","<xcode><firebase><google-cloud-firestore><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67800730","1","67835574","","2021-06-02 07:30:52","","0","298","<p>I need to build a <code>Combine</code> pipeline using <code>Swift</code> where 2 publishers are involved, pubA (A PassThroughSubject) generates values frequently and once pubB (another PassThroughSubject) generates a value, I need to use the latest value from pubA to trigger an event. The only strict condition is - the trigger should happen only on a new value of pubB (the driving publisher) and the pipeline should take most newest published value from pubA (should skip old values). Let me try to demonstrate with example:</p>
<pre><code>pubA =&gt; 
1               
          2               
                 3               
                                   4
                                             5 
pubB =&gt;                  true                     false       true
Expected Output:         (true, 3)                (false, 5)  (true, 5)
</code></pre>
<p>This seemed to be good for <code>Zip</code> initially but zip pops old value not newest, i.e the output becomes (true, 1), (false, 2). And using <code>combineLatest</code> triggers event whenever there is a value from any of the publishers &amp; breaks the dependency to trigger only on pubB’s new value, so the output becomes (true, 3), (true, 4), (true, 5), (false, 5)</p>
<p>Appreciate any pointers.</p>
<p>Edit Notes:</p>
<ol>
<li>The expectation is to get pair of values.</li>
<li>pubB is driving publisher, for each value from pubB there will be an event by using newest value from pubA.</li>
<li>If pubA hasn't produced any value, it will wait until pubA produces a value... as we need a pair.</li>
<li>If pubB produces more values than pubA, the newest pubA value will be paired with newest pubB value.</li>
</ol>
","693081","","693081","","2021-06-03 04:48:28","2021-06-04 10:21:01","How to zip two publishers but to get newest values instead of default oldest behavior of zip?","<ios><swift><reactive-programming><combine><publisher>","1","7","","","","CC BY-SA 4.0"
"67804019","1","","","2021-06-02 11:12:49","","3","71","<p>I'm pretty new in Combine, I'm trying to create a login flow where:</p>
<ul>
<li>When I click on the login button the app fires the GoogleSignIn <code>sign</code> function</li>
<li>Then, when the session data is received on GoogleDelegate it needs to start a request to my server-side login method.</li>
</ul>
<p>To do that I have a GoogleSignInController that controls the sign-in process:</p>
<pre><code>class GoogleSignInController: GIDSignInDelegate {
    @Published var onSessionAcquired: GoogleSignInSessionData = (&quot;&quot;, &quot;&quot;)

    func signIn() {
        if (GIDSignIn.sharedInstance()?.presentingViewController == nil) {
            GIDSignIn.sharedInstance()?.presentingViewController = UIApplication.shared.windows.last?.rootViewController
        }
        GIDSignIn.sharedInstance()?.signIn()
    }

    func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error!) {
        if let error = error {
            if (error as NSError).code == GIDSignInErrorCode.hasNoAuthInKeychain.rawValue {
                print(&quot;The user has not signed in&quot;)
            } else {
                print(&quot;\(error.localizedDescription)&quot;)
            }
            return
        }
        
        onSessionAcquired = GoogleSignInSessionData(idToken: user.authentication.idToken ?? &quot;&quot;, serverAuthCode: user.serverAuthCode ?? &quot;&quot;)
        
        print(&quot;Successful sign-in!&quot;)
        signedIn = true
    }
}
</code></pre>
<p>Then in the ViewModel, I'm using some states to control the process:</p>
<pre><code>    static func whenStartedLogin() -&gt; Feedback&lt;State, Event&gt; {
        Feedback { (state: State) -&gt; AnyPublisher&lt;Event, Never&gt; in
            guard case .loadingGoogleSignIn = state else { return Empty().eraseToAnyPublisher() }

            GoogleSignInController.shared.signIn()
            
            return GoogleSignInController.shared.$onSessionAcquired
                .receive(on: DispatchQueue.main)
                .map { Event.onGoogleSessionAcquired($0) }
                .eraseToAnyPublisher()
        }
    }

    static func whenReceivedGoogleSession() -&gt; Feedback&lt;State, Event&gt; {
        Feedback { (state: State) -&gt; AnyPublisher&lt;Event, Never&gt; in
            guard case let .loadingServerSession(googleSession) = state else { return Empty().eraseToAnyPublisher() }

            return self.signIn(idToken: googleSession.idToken, serverAuthCode: googleSession.serverAuthCode)
              .map { (userInfo, error) in
                  if let error = error {
                      return Event.onFailedToAcquireSession(error)
                  } else if let userInfo = userInfo {
                      return Event.onUserInfoAcquired(userInfo)
                  } else {
                      return Event.onFailedToAcquireSession(AppError.unknown)
                  }
              }
              .eraseToAnyPublisher()
        }
    }
</code></pre>
<p>The problem is: when I click on the login button, the <code>whenStatedLogin</code> function is fired, and it maps my event to be <code>Event.onGoogleSessionAcquired</code>. This should be mapped only when <code>onSessionAcquired</code> is changed (after the <code>sign</code> delegate is called). How can I do that?</p>
","985979","","","","","2021-06-02 12:30:38","How to make a Published property call map only when it receives data","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"67813464","1","67856782","","2021-06-02 22:54:01","","1","526","<p>I have a situation where my code needs to make one network call to fetch a bunch of items, but while waiting for those to come down, another network call might fetch an update to those items. I'd love to be able to enqueue those secondary results until the first one has finished. Is there a way to accomplish that with Combine?</p>
<p>Importantly, I am not able to wait before making the second request. It’s actually a connection to a websocket that gets made at the same time as the first request, and the updates come over the websocket outside of my control.</p>
<h2>Update</h2>
<p>After examining Matt’s thorough <a href=""https://www.apeth.com/UnderstandingCombine/operators/operatorsJoiners/operatorsappend.html"" rel=""nofollow noreferrer"">book</a> on Combine, I settled on <code>.prepend()</code>. But as Matt warned me in the comments, <code>.prepend()</code> doesn’t even subscribe to the other publisher until after the first one completes. This means I miss any signals sent prior to that. What I need is a <code>Subject</code> that enqueues values, but perhaps that’s not so hard to make. Anyway, this is where I got:</p>
<p>Initially I was going to use <code>.append()</code>, but I realized with <code>.prepend()</code> I could avoid keeping a reference to one of the publishers. So here’s a simplified version of what I’ve got. There might be syntax errors in this, as I’ve whittled it down from my (employer’s) code.</p>
<p>There’s the <code>ItemFeed</code>, which handles fetching a list of items and simultaneously handling item update events. The latter can arrive before the initial list of items, and thus must be sequenced via Combine to arrive after it. I attempt to do this by prepending the initial items source to the update <code>PassthroughSubject</code>.</p>
<p>Below that is an <code>XCTestCase</code> that simulates a lengthy initial item load, and adds an update before that load can complete. It attempts to subscribe to changes to the list of items, and tries to test that the first update is the initial 63 items, and the subsequent update is for 64 items (in this case, “update” results in adding an item).</p>
<p>Unfortunately, while the initial list is published, the update never arrives. I also tried removing the <code>.output(at:)</code> operators, but the two sinks are only called once.</p>
<p>After the test case sets up the delayed “fetch,” and subscribes to changes in <code>feed.items</code>, it calls <code>feed.handleItemUpatedEvent</code>. This calls <code>ItemFeed.updateItems.send(_:)</code>, but unfortunately that is lost to oblivion.</p>
<pre class=""lang-swift prettyprint-override""><code>class
ItemFeed
{
    typealias   InitialItemsSource      =   Deferred&lt;Future&lt;[[String : Any]], Error&gt;&gt;
    
                let updateItems         =   PassthroughSubject&lt;[Item], Error&gt;()
                var funnel              :   AnyCancellable?
    
    @Published  var items               =   [Item]()
    
    
    
    init(initialItemSource inSource: InitialItemsSource)
    {
        //  Passthrough subject each time items are updated…
        
        var pub = self.updateItems.eraseToAnyPublisher()
        
        //  Prepend the initial items we need to fetch…
        
        let initialItems = source.tryMap { try $0.map { try Item(object: $0) } }
        pub = pub.prepend(initialItems).eraseToAnyPublisher()
        
        //  Sink on the funnel to add or update to self.items…
        
        self.funnel =
            pub.sink { inCompletion in
                //  Handle errors
            }
            receiveValue: {
                self.update(items: inItems)
            }
    }
    
    func handleItemUpdatedEvent(_ inItem: Item) {
        self.updateItems.send([inItem])
    }
    
    func update(items inItems: [Item]) {
        //  Update or add inItems to self.items
    }
}

class
ItemFeedTests : XCTestCase
{
    func
    testShouldUpdateItems()
        throws
    {
        //  Set up a mock source of items…
        
        let source = fetchItems(named: &quot;items&quot;, delay: 3.0)      //  63 items
        
        let expectation = XCTestExpectation(description: &quot;testShouldUpdateItems&quot;)
        expectation.expectedFulfillmentCount = 2
        
        let feed = ItemFeed(initialItemSource: source)
        
        let sub1 = feed.$items
                    .output(at: 0)
                    .receive(on: DispatchQueue.main)
                    .sink { inItems in
                        expectation.fulfill()
                        
                        debugLog(&quot;Got first items: \(inItems.count)&quot;)
                        XCTAssertEqual(inItems.count, 63)
                    }
        
        let sub2 = feed.$items
                    .output(at: 1)
                    .receive(on: DispatchQueue.main)
                    .sink { inItems in
                        expectation.fulfill()

                        debugLog(&quot;Got second items: \(inItems.count)&quot;)
                        XCTAssertEqual(inItems.count, 64)
                    }
        
        //  Send an update right away…
        
        let item = try loadItem(named: &quot;Item3&quot;)
        feed.handleItemUpdatedEvent(item)
        
        XCTAssertEqual(feed.items.count, 0)         //  Should be no items yet
        
        //  Wait for stuff to complete…
        
        wait(for: [expectation], timeout: 10.0)
        
        sub1.cancel()           //  Not necessary, but silence the compiler warning
        sub2.cancel()
    }
}   
</code></pre>
","251914","","251914","","2021-06-03 07:50:50","2021-07-30 19:34:07","Swift Combine: enqueue updates to one publisher behind another publisher","<swift><combine>","2","12","1","","","CC BY-SA 4.0"
"67819795","1","","","2021-06-03 10:30:45","","0","74","<p>I'm learning Apple Combine in a Swift macOS command-line application but sometimes I struggle to experiment with asynchronous code and/or with reactive concepts. For instance, in the following example, the publisher is supposed to emit values every 1 second forever and the subscriber simply prints them to the console.</p>
<p>I store the reference to the cancelable object in a variable to avoid ARC canceling the pipeline when the variable ref. count goes to 0. However, in this example, nothing is printed on the console.</p>
<p>Is this due to the reference going out of scope right after the pipeline started so it is canceled right away? In this case, how to hold the reference long enough for the code to work?</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

let cancellable = Timer.publish(every: 1.0, on: .main, in: .common)
    .autoconnect()
    .scan(0) { i, _ in i + 1 }
    .sink { i in
        print(i)
    }
</code></pre>
<p>I tried to inspect what's going on with <code>handleEvents()</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>let output = Timer.publish(every: 1.0, on: .main, in: .common)
    .autoconnect()
    .scan(0) { i, _ in i + 1 }
    .handleEvents(receiveSubscription: { _ in
        print(&quot;Received subscription&quot;)
    }, receiveOutput: { _ in
        print(&quot;Received output&quot;)
    }, receiveCompletion: { _ in
        print(&quot;Received completion&quot;)
    }, receiveCancel: {
        print(&quot;Received cancel&quot;)
    }, receiveRequest: { demand in
        print(&quot;Received demand: \(demand)&quot;)
    })
    .sink { i in
        print(i)
    }
</code></pre>
<p>And the output is:</p>
<pre class=""lang-sh prettyprint-override""><code>Received subscription
Received demand: unlimited
Program ended with exit code: 0
</code></pre>
","6324055","","6324055","","2021-06-03 10:46:11","2021-06-03 10:46:11","How to hold a reference to a cancellable long enough for a Combine Pipeline to finish in Swift?","<swift><reactive-programming><combine>","0","2","","","","CC BY-SA 4.0"
"67821097","1","67857053","","2021-06-03 11:59:54","","1","220","<p>I am trying to use Combine to route SwiftUI views, and it sort of works, but has some unwanted behaviour that I hope someone can help me with. I made an <a href=""https://github.com/imyrvold/RouteTest/tree/main/RouteTest"" rel=""nofollow noreferrer"">example project</a> which only contains two files, <code>ViewRouter.swift</code> and <code>ViewController.swift</code> that just contains a <code>@IBSegueAction</code> to return a <code>UIHostingController</code>:</p>
<p>The class <code>ViewRouter</code> is a <code>ViewModel</code> for the SwiftUI Views that contains a <code>@ViewBuilder</code> property. When the <code>SwiftUI</code> views calls the <code>didFinish()</code> function, the <code>step</code> property is set to the next <code>View</code>.</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewRouter: ObservableObject {
    enum Step { case test1, test2, test3, test4 }
    @Published var step: Step = .test1
    @ViewBuilder var nextStepView: some View {
        switch step {
        case .test1:
            Test1(router: self)
        case .test2:
            Test2(router: self)
        case .test3:
            Test3(router: self)
        case .test4:
            Test4(router: self)
        }
    }
    
    func didFinish() {
        switch step {
        case .test1:
            step = .test2
        case .test2:
            step = .test3
        case .test3:
            step = .test4
        case .test4:
            break
        }
    }
}
</code></pre>
<p>This works perfect for <code>Test1</code>, when tapping the <code>Next</code> link, the <code>Test1</code> view is animated to the left, to reveal <code>Test2</code>. When tapping <code>Next</code> in <code>Test2</code> however, the <code>Test2</code> is animated to the left to reveal <code>Test3</code>, but then immediately it animates back to the right to reveal the same <code>Test3</code> view. Exactly the same happens when tapping <code>Next</code> in <code>Test3</code>.</p>
<p>And tapping the back button always ends up in <code>Test1</code> view.</p>
<p>All four views are the same, apart from the text in <code>Text</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>struct Test1: View {
    @ObservedObject var router: ViewRouter
    @State var nextView = false

    var body: some View {
        VStack {
            NavigationLink(destination: router.nextStepView, isActive: $nextView) {
                EmptyView()
            }

            Text(&quot;Test1&quot;)
            
            Button(action: {
                nextView = true
                router.didFinish()
            }, label: {
                Text(&quot;Next&quot;)
            })
        }
    }
}
</code></pre>
","6394244","","","","","2021-06-06 08:16:05","Use Combine to route SwiftUI Views","<swift><swiftui><combine>","1","2","1","","","CC BY-SA 4.0"
"67823301","1","","","2021-06-03 14:25:29","","0","98","<p>First iOS app. If <code>items</code> in the VM is replaced with an Array with one less element, I get the following exception, which placing exception breakpoints gives no useful information about:</p>
<blockquote>
<p>*** Terminating app due to uncaught exception 'NSRangeException', reason: 'Index (1176) out of bounds (1176)'</p>
</blockquote>
<p>View:</p>
<pre><code>struct LibrarySongsPageView: View {
    
    @StateObject var viewModel = LibrarySongsViewModel()
    
    var body: some View {
        print(viewModel.items.count)
        return List(viewModel.items, id: \.persistentID) { mediaItem in
            HStack {
                if let art = mediaItem.artwork, let uiImg = art.image(at: CGSize(width: 60, height: 60)) {
                    Image(uiImage: uiImg)
                        .toIcon()
                        .padding(.trailing)
                } else {
                    Image(systemName: &quot;music.note&quot;)
                }
                Text(mediaItem.title ?? &quot;Unknown&quot;)
                    .font(.title2)
            }
        }.navigationTitle(&quot;Songs&quot;)
    }
}
</code></pre>
<p>VM:</p>
<pre><code>class BaseLibraryViewModel: ObservableObject {
    let provider = LibraryProvider.instance
    
    @Published var items = [MPMediaItem]()
    
    let sortOrder = SortOrder.title
    var subscription: AnyCancellable!
    
    init() {
        subscription = provider.setActive(active: true, type: .songs)!.sink { [weak self] items in
            self?.items = items
        }
    }
}
class LibrarySongsViewModel: BaseLibraryViewModel {}
</code></pre>
<p>I have already fixed the problem by changing the first lines of the body to:</p>
<pre><code>return List(viewModel.items.indices, id: \.self) { index in
            let mediaItem = viewModel.items[index]
}
</code></pre>
<p>but I have no idea why the first version produces the exception. I checked the <code>viewModel.items.count</code> and <code>po viewModel.items</code> when the view <code>body</code> property is being accessed and it looks the the Array is the updated array with one less item than previous that I am expecting, yet the exception is still thrown during <code>body</code> access.</p>
<p>Can someone please explain?</p>
","1817031","","","","","2021-06-05 17:05:34","SwiftUI List crashes with 'NSRangeException' when view model @Published changes","<ios><swiftui><combine><swiftui-list>","1","0","","","","CC BY-SA 4.0"
"67831899","1","","","2021-06-04 05:26:05","","0","485","<p>I'm looking for some guidance here on an issue I'm encountering.  I am polling an API for stock data and instead of getting back an array or formatted JSON I get chunks of it.  Each block of JSON seems to be properly formatted, but the JSON decoders are looking for a properly formatted array.</p>
<p>Prior to using combine I had a different working.  I had to parse the data to remove 4 trailing characters, then I was left with lines of JSON that I could split by newline and then do a forEach loop on to parse.</p>
<p>This was messy but it works.  The issue now is I'm polling streaming data for live quote updating in my UI.  I need to have the JSON chunks read into my class, stored as a variable that will update the UI.  I am not worried about all of that code once I can figure out how to get the data read properly.</p>
<p>I know my app is receiving the data because I see the stats in the debugger for network.  I also test the same API call in a browser and see what data my app is receiving.  I just don't know how to break it up in the combine framework.</p>
<p>I have been working with something like this so far:</p>
<pre><code> return URLSession.shared.dataTaskPublisher(for: request)
        .map { $0.data }
        .handleEvents(receiveSubscription: { print(&quot;Receive subscription: \($0)&quot;) },
                          receiveOutput: { print(&quot;Receive output: \($0)&quot;) },
                          receiveCompletion: { print(&quot;Receive completion: \($0)&quot;) },
                          receiveCancel: { print(&quot;Receive cancel&quot;) },
                          receiveRequest: { print(&quot;Receive request: \($0)&quot;) })
        
        //.decode(type: CryptoDataContainer.self, decoder: JSONDecoder())
        .decode(type: Quote.self, decoder: JSONDecoder())
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
 }
</code></pre>
<p>The Quote struct is very basic:</p>
<pre><code>struct Quote: Codable {

 public var Symbol: String
 public var Last: Double
 public var Bid: Double
 public var Ask: Double
 public var Close: Double
    }
</code></pre>
<p>JSON data is posted below, and it streams.  I get a few chunks of it at a time, but if I can split by newline or by everything {.*} to get each JSON chunk and decode individually it would work great.</p>
<p>I'm really looking for Last price and Symbol out of the JSON.  I could even just look for Last and start one individual streaming session for each symbol I need.</p>
<p>I will also need to split these up using a subject to multicast each publisher to multiple subscribers but I wanted to get the basic functionality working before complicating matters.</p>
<p>Update:  From another post I found that the problem is the JSON formatting - The API is returning invalid JSON that is not formatted into an array - it is missing the surrounding [].  This is why it doesn't parse.  Another option may be to simply convert to string, add square brackets around all of the JSON passed down from the server (there is nothing but objects).. and then parse it correctly?  I'm not sure how to do this within a combine map but that seems to be the path forward.</p>
<p>Here’s an example of the map I’m trying to use currently, since the data comes in as json chunks I need to parse them each individually.</p>
<pre><code>          .map ({

                let stringRepresentation = String(data: $0, encoding: .utf8)
                let outputJson = stringRepresentation!.split(whereSeparator: \.isNewline).map(String.init)
                
                if outputJson.count &gt; 1 {
                    print(&quot;DEBUG: outputJson.count &gt; 1 code running..&quot;)
                    let formattedOutputJson:String = outputJson.joined(separator: &quot;,&quot;)
                    let finalJson:String = &quot;{\&quot;quotes\&quot;:[&quot; + formattedOutputJson  + &quot;]}&quot;
                    let data:Data? = finalJson.data(using: .utf8)
                    return data!
                } else {
                    print(&quot;DEBUG: outputJson.count = 1 (Else) code running..&quot;)
                    let finalJson:String = &quot;{\&quot;quotes\&quot;:[&quot; + outputJson[0]  + &quot;]}&quot;
                    let data:Data? = finalJson.data(using: .utf8)
                    return data!
                }
            }) 
</code></pre>
<p>Here is a better example of the JSON formatting in chunks I’m talking about:</p>
<pre><code>{&quot;heartbeat&quot;:4,&quot;timestamp&quot;:&quot;\/Date(1622898090819)\/&quot;}
{&quot;heartbeat&quot;:5,&quot;timestamp&quot;:&quot;\/Date(1622898095819)\/&quot;}
{&quot;heartbeat&quot;:6,&quot;timestamp&quot;:&quot;\/Date(1622898100819)\/&quot;}
{&quot;heartbeat&quot;:7,&quot;timestamp&quot;:&quot;\/Date(1622898105819)\/&quot;}
{&quot;heartbeat&quot;:8,&quot;timestamp&quot;:&quot;\/Date(1622898110819)\/&quot;}
</code></pre>
<p>If I can even capture the heartbeat number as an Int to use I would be well on my way to getting my code working.  The issue is I get zero data out of this.  I know I’m connected from packet captures and various other tests.  The data is getting to my system, and to the Xcode simulated app, I just don’t think I’m getting it to a point where I can print to the console correctly to display it.  I have been working on that prior to attempting to update the UI directly.</p>
<pre><code>{&quot;Description&quot;:&quot;E-Mini NASDAQ-100 Jun 2021&quot;,&quot;PreviousClose&quot;:13529.25,&quot;PreviousVolume&quot;:552987,&quot;AssetType&quot;:&quot;FUTURE&quot;,&quot;CountryCode&quot;:&quot;United States&quot;,&quot;Halted&quot;:false,&quot;Bid&quot;:13513.75,&quot;BidSize&quot;:3,&quot;Ask&quot;:13514.25,&quot;AskSize&quot;:1,&quot;Currency&quot;:&quot;USD&quot;,&quot;LastSize&quot;:1,&quot;LastVenue&quot;:&quot;CME&quot;,&quot;SymbolRoot&quot;:&quot;NQ&quot;,&quot;Exchange&quot;:&quot;CME&quot;,&quot;LastTradingDate&quot;:&quot;2021-06-18&quot;,&quot;DisplayType&quot;:3,&quot;FractionalDisplay&quot;:false,&quot;MinPrice&quot;:1258200,&quot;PointValue&quot;:20,&quot;TradeTime&quot;:&quot;2021-06-04T02:40:20.0000000+00:00&quot;,&quot;MaxPrice&quot;:1447600,&quot;MinMove&quot;:25,&quot;High52Week&quot;:14064,&quot;Open&quot;:13531.75,&quot;Low52Week&quot;:9591.75,&quot;High&quot;:13541.75,&quot;Low&quot;:13467.75,&quot;Close&quot;:13513.75,&quot;Symbol&quot;:&quot;NQM21&quot;,&quot;Volume&quot;:23877,&quot;DailyOpenInterest&quot;:231736,&quot;ExpirationDate&quot;:&quot;2021-06-18&quot;,&quot;Last&quot;:13513.75,&quot;NameExt&quot;:&quot;(D)&quot;,&quot;DataFeed&quot;:&quot;TradeStation&quot;,&quot;IsDelayed&quot;:true,&quot;Restrictions&quot;:[null],&quot;VWAP&quot;:13499.877658013,&quot;NetChange&quot;:-15.50,&quot;NetChangePct&quot;:-0.1145665872091948925476282900,&quot;High52WeekTimeStamp&quot;:&quot;2021-04-29T00:00:00.0000000+00:00&quot;,&quot;Low52WeekTimeStamp&quot;:&quot;2020-06-11T00:00:00.0000000+00:00&quot;,&quot;PreviousClosePriceDisplay&quot;:&quot;13529.25&quot;,&quot;BidPriceDisplay&quot;:&quot;13513.75&quot;,&quot;AskPriceDisplay&quot;:&quot;13514.25&quot;,&quot;MinPriceDisplay&quot;:&quot;1258200.00&quot;,&quot;MaxPriceDisplay&quot;:&quot;1447600.00&quot;,&quot;High52WeekPriceDisplay&quot;:&quot;14064.00&quot;,&quot;OpenPriceDisplay&quot;:&quot;13531.75&quot;,&quot;Low52WeekPriceDisplay&quot;:&quot;9591.75&quot;,&quot;HighPriceDisplay&quot;:&quot;13541.75&quot;,&quot;LowPriceDisplay&quot;:&quot;13467.75&quot;,&quot;ClosePriceDisplay&quot;:&quot;13513.75&quot;,&quot;LastPriceDisplay&quot;:&quot;13513.75&quot;,&quot;VWAPDisplay&quot;:&quot;13499.88&quot;,&quot;FirstNoticeDate&quot;:&quot;&quot;,&quot;StrikePrice&quot;:0,&quot;TickSizeTier&quot;:0,&quot;Underlying&quot;:&quot;&quot;,&quot;StrikePriceDisplay&quot;:&quot;0.00&quot;}
{&quot;Last&quot;:4188.5,&quot;NameExt&quot;:&quot;(D)&quot;,&quot;DataFeed&quot;:&quot;TradeStation&quot;,&quot;IsDelayed&quot;:true,&quot;Restrictions&quot;:[null],&quot;VWAP&quot;:4184.92506004117,&quot;Description&quot;:&quot;E-mini S&amp;P 500 Jun 2021&quot;,&quot;PreviousClose&quot;:4191.25,&quot;PreviousVolume&quot;:1384271,&quot;AssetType&quot;:&quot;FUTURE&quot;,&quot;CountryCode&quot;:&quot;United States&quot;,&quot;Halted&quot;:false,&quot;Bid&quot;:4188.25,&quot;BidSize&quot;:39,&quot;Ask&quot;:4188.5,&quot;AskSize&quot;:23,&quot;Currency&quot;:&quot;USD&quot;,&quot;LastSize&quot;:1,&quot;LastVenue&quot;:&quot;CME&quot;,&quot;SymbolRoot&quot;:&quot;ES&quot;,&quot;Exchange&quot;:&quot;CME&quot;,&quot;LastTradingDate&quot;:&quot;2021-06-18&quot;,&quot;DisplayType&quot;:3,&quot;FractionalDisplay&quot;:false,&quot;MinPrice&quot;:3898,&quot;PointValue&quot;:50,&quot;TradeTime&quot;:&quot;2021-06-04T02:40:10.0000000+00:00&quot;,&quot;MaxPrice&quot;:4484,&quot;MinMove&quot;:25,&quot;High52Week&quot;:4238.25,&quot;Open&quot;:4190.75,&quot;Low52Week&quot;:2977.8999,&quot;Hi{&quot;Volume&quot;:23880,&quot;TradeTime&quot;:&quot;2021-06-04T02:40:23.0000000+00:00&quot;,&quot;VWAP&quot;:13499.879455674,&quot;Symbol&quot;:&quot;NQM21&quot;}
{&quot;AskSize&quot;:18,&quot;Symbol&quot;:&quot;ESM21&quot;}
{&quot;Bid&quot;:13514.25,&quot;BidSize&quot;:1,&quot;AskSize&quot;:1,&quot;BidPriceDisplay&quot;:&quot;13514.25&quot;,&quot;Symbol&quot;:&quot;NQM21&quot;,&quot;VWAP&quot;:13499.8800582884,&quot;Volume&quot;:23881,&quot;TradeTime&quot;:&quot;2021-06-04T02:40:25.0000000+00:00&quot;}
{&quot;VWAP&quot;:4184.92521199492,&quot;AskSize&quot;:19,&quot;Volume&quot;:47807,&quot;TradeTime&quot;:&quot;2021-06-04T02:40:27.0000000+00:00&quot;,&quot;Symbol&quot;:&quot;ESM21&quot;}
{&quot;Bid&quot;:13514,&quot;BidSize&quot;:3,&quot;BidPriceDisplay&quot;:&quot;13514.00&quot;,&quot;Symbol&quot;:&quot;NQM21&quot;,&quot;TradeTime&quot;:&quot;2021-06-04T02:40:27.0000000+00:00&quot;,&quot;Ask&quot;:13514.75,&quot;VWAP&quot;:13499.8806713352,&quot;Close&quot;:13514.5,&quot;Last&quot;:13514.5,&quot;Volume&quot;:23882,&quot;NetChange&quot;:-14.75,&quot;NetChangePct&quot;:-0.1090230426668144945211301400,&quot;AskPriceDisplay&quot;:&quot;13514.75&quot;,&quot;ClosePriceDisplay&quot;:&quot;13514.50&quot;,&quot;LastPriceDisplay&quot;:&quot;13514.50&quot;}
{&quot;AskSize&quot;:18,&quot;Symbol&quot;:&quot;ESM21&quot;}
</code></pre>
","16124265","","16124265","","2021-06-07 23:05:46","2021-06-07 23:05:46","Swift - Parsing JSON with Combine, URLSession DataTaskPublisher - Strange formatting","<json><swift><combine><urlsession>","0","6","","","","CC BY-SA 4.0"
"67838981","1","","","2021-06-04 14:26:53","","1","115","<p>My app has two <code>ObservableObject</code>s:</p>
<pre><code>@main
struct SomeApp: App {
    @StateObject private var foo = Foo()
    @StateObject private var bar = Bar()

    var body: some Scene {
        WindowGroup {
            AppView()
                .environmentObject(foo)
                .environmentObject(bar)
        }
    }
}
</code></pre>
<pre><code>class Foo: ObservableObject {
    @Published var operationResult: Bool?

    private let operationQueue = OperationQueue()

    func start() {
        operationQueue.addOperation(SomeOperation())
        // SomeOperation will set operationResult
    }
}
</code></pre>
<pre><code>class Bar: ObservableObject {
    @Published var resultsAvailable = false

    func updateResults(operationResult: Bool) {
        if operationResult &amp;&amp; someOtherCondition {
            resultsAvailable = true
        }
    }
}
</code></pre>
<p>At some point, <code>Foo</code> is doing some work on a background thread. When it completes, state in <code>Bar</code> needs to be updated, perhaps by calling <code>updateResults()</code>. In a traditional UIKit app, I might coordinate this by setting a callback handler or posting an <code>NSNotification</code>.</p>
<p>Instead of passing <code>operationResult</code> around via a notification or handler, is there a way for <code>Bar</code> to subscribe to changes to <code>Foo</code>'s <code>operationResult</code> property? In examples I've found so far, it seems like the subscriptions may only be available inside <code>View</code> structs, but I haven't been able to confirm or deny that.</p>
","1445366","","","","","2021-06-04 14:26:53","In SwiftUI / Combine, how can two ObservableObjects coordinate?","<swift><swiftui><combine>","0","10","1","","","CC BY-SA 4.0"
"67840597","1","68041060","","2021-06-04 16:10:18","","0","183","<p>I have created <a href=""https://github.com/afarber/ios-questions/tree/master/Tops1"" rel=""nofollow noreferrer"">a simple Core Data project at Github</a> to demonstrate my problem:</p>
<p><a href=""https://i.stack.imgur.com/450Vb.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/450Vb.jpg"" alt=""Xcode screenshot"" /></a></p>
<p>My test app downloads a JSON list of objects, stores it in Core Data and displays in a SwiftUI List via <code>@FetchRequest</code>.</p>
<p>Because the list of objects has 1000+ elements in my <em>real</em> app, I would like to save the entities into the Core Data on a background thread and not on the main thread.</p>
<p>Preferably I would like to use the same default background thread, which is already used by the <a href=""https://developer.apple.com/documentation/foundation/urlsession/datataskpublisher"" rel=""nofollow noreferrer"">URLSession.shared.dataTaskPublisher</a>.</p>
<p>So in the standard <a href=""https://github.com/afarber/ios-questions/blob/master/Tops1/Tops1/Persistence.swift"" rel=""nofollow noreferrer"">Persistence.swift</a> generated by Xcode I have added only 2 lines:</p>
<pre><code>container.viewContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
container.viewContext.automaticallyMergesChangesFromParent = true
</code></pre>
<p>and in my <a href=""https://github.com/afarber/ios-questions/blob/master/Tops1/Tops1/Managers/DownloadManager.swift"" rel=""nofollow noreferrer"">DownloadManager.swift</a> singleton I call:</p>
<pre><code>static let instance = DownloadManager()

var cancellables = Set&lt;AnyCancellable&gt;()

// How to run this line on the background thread of URLSession.shared.dataTaskPublisher?
let backgroundContext = PersistenceController.shared.container.newBackgroundContext()

private init() {
    getTops()
}

func getTops() {
    guard let url = URL(string: &quot;https://slova.de/ws/top&quot;) else { return }
    
    URLSession.shared.dataTaskPublisher(for: url)
        .tryMap(handleOutput)
        .decode(type: TopResponse.self, decoder: JSONDecoder())
        .sink { completion in
            print(completion)
        } receiveValue: { [weak self] returnedTops in
            for top in returnedTops.data {
                // the next line fails with EXC_BAD_INSTRUCTION
                let topEntity = TopEntity(context: self!.backgroundContext)
                topEntity.uid = Int32(top.id)
                topEntity.elo = Int32(top.elo)
                topEntity.given = top.given
                topEntity.avg_score = top.avg_score ?? 0.0
            }
            self?.save()
        }
        .store(in: &amp;cancellables)
}
</code></pre>
<p>As you can see in the above screenshot, this fails with</p>
<blockquote>
<p>Thread 4: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)</p>
</blockquote>
<p>because I have added the following &quot;Arguments Passed on Launch&quot; in Xcode:</p>
<blockquote>
<p>-com.apple.CoreData.ConcurrencyDebug 1</p>
</blockquote>
<p>Could anyone please advise me, how to call the <code>newBackgroundContext()</code> on the proper thread?</p>
<p><strong>UPDATE:</strong></p>
<p>I have tried to workaround my problem as in below code, but the error is the same:</p>
<pre><code>URLSession.shared.dataTaskPublisher(for: url)
    .tryMap(handleOutput)
    .decode(type: TopResponse.self, decoder: JSONDecoder())
    .sink { completion in
        print(completion)
    } receiveValue: { returnedTops in
        let backgroundContext = PersistenceController.shared.container.newBackgroundContext()

        for top in returnedTops.data {
            // the next line fails with EXC_BAD_INSTRUCTION
            let topEntity = TopEntity(context: backgroundContext)
            topEntity.uid = Int32(top.id)
            topEntity.elo = Int32(top.elo)
            topEntity.given = top.given
            topEntity.avg_score = top.avg_score ?? 0.0
        }

        do {
            try backgroundContext.save()
        } catch {
            let nsError = error as NSError
            fatalError(&quot;Unresolved error \(nsError), \(nsError.userInfo)&quot;)
        }
</code></pre>
<p><strong>UPDATE 2:</strong></p>
<p>I was assuming that when <code>newBackgroundContext()</code> is called, it takes the current thread and then you can use that context from the same thread...</p>
<p>This seems not to be the case and I have to call <code>perform</code>, <code>performAndWait</code> or <code>performBackgroundTask</code> (I have updated <a href=""https://github.com/afarber/ios-questions/blob/master/Tops1/Tops1/Managers/DownloadManager.swift"" rel=""nofollow noreferrer"">my code at Github</a> to do just that).</p>
<p>Still I wonder, if the thread of <code>newBackgroundContext</code> can be the same as of the <code>URLSession.shared.dataTaskPublisher</code>...</p>
","165071","","165071","","2021-06-05 15:46:25","2021-06-18 20:22:40","How to use newBackgroundContext() with URLSession.shared.dataTaskPublisher?","<ios><swift><core-data><combine><ios-multithreading>","1","2","","","","CC BY-SA 4.0"
"67841828","1","67844744","","2021-06-04 17:47:58","","0","225","<p>Whenever I am typing something in TextField, I am getting the value through the 'sink' operator after making UITextField the publisher. However, now I want to validate that password and the below piece of code involves 'send()' that works only for the first time the validatePassword() method is called. After that 'send()' does not work. Any idea why is this happening? I have been exploring Combine for 4-5 days now and here is the gist:<br>1. Publishers, subscribers and operators.<br>2. publishers in ViewModel and subscribers in ViewController.<br>3. Send() is used for sending a value to subscriber.<br><br> Everything fits but it still doesn't get called after first time. Stuck on it for 3-4 hours now.</p>
<p>Here is the code for ViewController<br></p>
<pre><code>            viewModel.passwordValidationResult
                .print(&quot;Debugging&quot;)
                .sink { completion in
                    
                    switch completion {
    
                    case .finished:
                        print(&quot;c&quot;)
                        return
                    case .failure(_):
                        print(&quot;f&quot;)
                        return
                    }
                    
                } receiveValue: { _  in
                    print(&quot;v&quot;)
                }
                .store(in: &amp;bindings)
        }

</code></pre>
<p>Here is the code for ViewModel</p>
<pre><code>class ViewModel
{
    private var bindings = Set&lt;AnyCancellable&gt;()

    @Published var emailValueChanged: String = String()
    @Published var passwordValueChanged: String = String()
        
    let passwordValidationResult = PassthroughSubject&lt;Void, Error&gt;()
    
    //input
    
    func validatePassword(_ password: String) {
        
        if password.count &gt;= 6 {
            passwordValidationResult.send()
        }
        passwordValidationResult.send(completion: .failure(PasswordError.shortPassword))
    }
}
</code></pre>
","3972195","","","","","2021-06-05 02:28:25","send() gets called only for the first time in combine framework iOS","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"67860634","1","67861029","","2021-06-06 15:14:47","","-1","276","<p>I am trying to pass Int to the ViewModel, but it doesn't work. Value is still 0. There is no problem with Strings or Data objects, but Int, Double and others number values are still 0 value. I also tried this way:</p>
<blockquote>
<p>@Published var tankCapacity: Int?</p>
</blockquote>
<p>but still same. How to resolve that? Use a string and convert to a given type?</p>
<pre><code>AddVehicleView: 

import SwiftUI

struct AddVehicleView: View {

@ObservedObject var viewModel: AddVehicleViewModel
@State private var selected = 0
@State private var showingAlert = false

init(viewModel: AddVehicleViewModel) {
    self.viewModel = viewModel
    UITableView.appearance().backgroundColor = .clear
    UITableView.appearance()
}

var body: some View {
    
    VStack(alignment: .leading) {
        
        Text(&quot;Add new vehicle&quot;)
            .font(.system(size: 26, weight: .medium))
            .padding(.top, -30)
            .padding(.leading, 20)
        
        VStack {
            
            TextField(&quot;Brand/Model etc&quot;, text: $viewModel.name)
                .padding(.top, 10)
                .padding(.leading, 20)
                .padding(.trailing, 20)
                .font(.system(size: 20))
                .textFieldStyle(RoundedBorderTextFieldStyle())
            
            TextField(&quot;Capacity&quot;, value: $viewModel.tankCapacity, formatter: NumberFormatter()) // I am trying send int value from here
                .padding(.top, 30)
            .padding(.leading, 20)
            .padding(.trailing, 20)
            .font(.system(size: 20))
            .textFieldStyle(RoundedBorderTextFieldStyle())
            
            Form {
                Section {
                    Picker(&quot;Fuel type&quot;, selection: $viewModel.fuelType) {
                        ForEach(0 ..&lt; viewModel.fuels.count) {
                            Text(self.viewModel.fuels[$0]).tag($0)
                                .padding(.leading, 5)
                                .padding(.trailing, 5)
                        }
                    }
                }
            }
            .padding(.leading, 5)
            .padding(.trailing, 5)
            
            Button(&quot;Add&quot;) {
                if self.viewModel.name.isEmpty {
                    self.showingAlert = true
                }
                else {
                    self.viewModel.saveVehicle()
                    self.viewModel.name = &quot;&quot;
                }
                
            }
            .frame(width: 200, height: 50)
                .background(Color.blue)
                .font(.system(size: 20, design: .default))
                .foregroundColor(Color.white)
            .cornerRadius(10)
            .padding(.top, -350)
                .alert(isPresented: $showingAlert) {
                    Alert(title: Text(&quot;Warning!&quot;), message: Text(&quot;Fill the fields&quot;))
            }
        }
        Spacer()
        
    }
}
}
</code></pre>
<p>import Foundation</p>
<pre><code>class AddVehicleViewModel: ObservableObject {

@Published var name = &quot;&quot;
@Published var tankCapacity = 0 // and here I am trying to get value.
@Published var fuelType = 0
@Published var fuels = [&quot;Petrol&quot;, &quot;Diesel&quot;]

private let persistenceService: PersistenceServiceProtocol

init(persistenceService: PersistenceServiceProtocol) {
    self.persistenceService = persistenceService
}

func saveVehicle() {
    print(&quot;name: \(name)&quot;)
    print(&quot;tankCapacity: \(tankCapacity)&quot;)
    let vehicle = Vehicle(name: name,
                          tankCapacity: tankCapacity)
    
    do {
        try self.persistenceService.addVehicle(vehicle: vehicle)
    }
    catch {
        print(&quot;ADDVEHICLEMODEL saveVehicle Error&quot;)
    }
}
}
</code></pre>
","11056400","","11056400","","2021-06-06 15:36:02","2021-06-06 15:53:56","SwiftUI pass Int value to the ViewModel","<ios><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"67860892","1","67862470","","2021-06-06 15:38:20","","0","549","<p>I'm creating a swift UI radio streaming app that has a library of past episodes that can be downloaded. I would like users to be able to begin a download and then lock the screen. Currently this suspends the download(s) in progress. My download function :</p>
<pre class=""lang-swift prettyprint-override""><code>func downloadFile(withUrl url: URL, andFilePath filePath: URL) {
        URLSession.shared
            .downloadTaskPublisher(for: url)
            .retry(4)
            .map(\.0)
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { [self] _ in
                      downloading = false
                      downloaded = true
                  },
                  receiveValue: { data in
                      do {
                          self.downloading = true
                          try FileManager.default.moveItem(atPath: data.path,
                                                           toPath: filePath.path)
                      } catch {
                          self.downloaded = false
                          print(&quot;Error: \(error.localizedDescription)&quot;)
                          print(&quot;an error happened while downloading or saving the file&quot;)
                      }
                  })
            .store(in: &amp;networkSubscription)
    }
</code></pre>
<p>Where <code>.downloadTaskPublisher(for: url)</code> is :</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation

public extension URLSession {
    /// Returns a publisher that wraps a URL session download task for a given
    /// URL.
    ///
    /// - Parameter url: The URL for which to create a download task.
    /// - Returns: A publisher that wraps a download task for the URL.
    func downloadTaskPublisher(for url: URL) -&gt; DownloadTaskPublisher {
        DownloadTaskPublisher(session: self, request: URLRequest(url: url))
    }

    /// Returns a publisher that wraps a URL session download task for a given
    /// URL request.
    ///
    /// - Parameter request: The URL request for which to create a download task.
    /// - Returns: A publisher that wraps a download task for the URL request.
    func downloadTaskPublisher(for request: URLRequest) -&gt; DownloadTaskPublisher {
        DownloadTaskPublisher(session: self, request: request)
    }
}

public struct DownloadTaskPublisher {
    fileprivate let session: URLSession
    fileprivate let request: URLRequest
}

extension DownloadTaskPublisher: Publisher {
    public typealias Output = (URL, URLResponse)
    public typealias Failure = Error

    public func receive&lt;Subscriber&gt;(subscriber: Subscriber)
        where
        Subscriber: Combine.Subscriber,
        Subscriber.Failure == Failure,
        Subscriber.Input == Output
    {
        let subscription = Subscription(subscriber: subscriber, session: session, request: request)
        subscriber.receive(subscription: subscription)
    }
}

private extension DownloadTaskPublisher {
    final class Subscription {
        private let downloadTask: URLSessionDownloadTask

        init&lt;Subscriber&gt;(subscriber: Subscriber, session: URLSession, request: URLRequest)
            where
            Subscriber: Combine.Subscriber,
            Subscriber.Input == Output,
            Subscriber.Failure == Failure
        {
            downloadTask = session.downloadTask(with: request, completionHandler: { url, response, error in

                guard let url = url, let response = response else {
                    subscriber.receive(completion: .failure(error!))
                    return
                }

                _ = subscriber.receive((url, response))
                subscriber.receive(completion: .finished)
            })
        }
    }
}

extension DownloadTaskPublisher.Subscription: Subscription {
    fileprivate func request(_: Subscribers.Demand) {
        downloadTask.resume()
    }

    fileprivate func cancel() {
        downloadTask.cancel()
    }
}
</code></pre>
<p>This download function writes the episode to disk but is canceled when the app is suspended.</p>
<p>I would like to write something like</p>
<pre class=""lang-swift prettyprint-override""><code>func downloadFile(withUrl url: URL, andFilePath filePath: URL) {
        URLSession.init(configuration: URLSessionConfiguration.background(withIdentifier: &quot;background.download.session&quot;))
            .downloadTaskPublisher(for: url)
            .retry(4)
            .map(\.0)
            .receive(on: RunLoop.main)
            .sink(receiveCompletion: { [self] _ in
                      downloading = false
                      downloaded = true
                  },
                  receiveValue: { data in
                      do {
                          self.downloading = true
                          try FileManager.default.moveItem(atPath: data.path,
                                                           toPath: filePath.path)
                      } catch {
                          self.downloaded = false
                          print(&quot;Error: \(error.localizedDescription)&quot;)
                          print(&quot;an error happened while downloading or saving the file&quot;)
                      }
                  })
            .store(in: &amp;networkSubscription)
    }
</code></pre>
<p>However, this throws a runtime exception: <code>libc++abi.dylib: terminating with uncaught exception of type NSException *** Terminating app due to uncaught exception 'NSGenericException', reason: 'Completion handler blocks are not supported in background sessions. Use a delegate instead.' terminating with uncaught exception of type NSException</code></p>
<p>I would like to download files in the background using combine idioms and avoid have to attach an <code>AppDelegate</code> to my <code>@main struct: App</code>.</p>
","10106418","","10106418","","2021-06-06 22:21:03","2021-06-06 22:21:03","Background mp3 download on iOS 14 in a swift ui app","<ios><swift><swiftui><combine><urlsession>","1","0","1","","","CC BY-SA 4.0"
"67863183","1","67863493","","2021-06-06 19:56:10","","0","660","<p>I'm new to Combine and I'm trying to understand it by solving the &quot;old&quot; problems</p>
<p>My goal is to make the process cancelable, but even I called the <code>.cancel()</code> method right after (or with sort delay) the <code>printFizzbuzz()</code> method, the code still keeping running(around 3 secs) until finishing</p>
<p>I've tried the code below in the new Xcode project, still the same</p>
<pre><code>import Foundation
import Combine

enum PrinterError: Error {
    case indexError(String)
    case subscriptionError(String)
    
    var description: String {
        switch self {
        case .indexError(let descpription):
            return descpription
        case .subscriptionError(let description):
            return description
        }
    }
}

struct FizzbuzzPrinter {
    private var subscriptions = Set&lt;AnyCancellable&gt;()

    mutating func printFizzbuzz(fromIndex: Int, toIndex: Int, handler: @escaping (_ result: Result&lt;Int,PrinterError&gt;) -&gt; Void) {
        guard toIndex &gt; fromIndex else {
            handler(.failure(.indexError(&quot;toIndex must larger than fromIndex&quot;)))
            return
        }

        var currentIndex: Int = fromIndex
        
        Array&lt;Int&gt;(fromIndex ..&lt; toIndex).publisher
            .handleEvents(receiveOutput: { index in
                currentIndex = index
            }, receiveCancel: {
                handler(.failure(.subscriptionError(&quot;cancaled at \(currentIndex)&quot;)))
            })
            .map { number -&gt; String in
                switch (number.isMultiple(of: 3), number.isMultiple(of: 5) ) {
                case (true, true):
                    return &quot;fizzbuzz at \(number)&quot;
                case (true, false):
                    return &quot;fizz at \(number)&quot;
                case (false, true):
                    return &quot;buzz at \(number)&quot;
                case (false, false):
                    return String()
                }
            }
            .filter{ !$0.isEmpty }
            .sink { _ in
                handler(.success(currentIndex))
            } receiveValue: { print($0)}
            .store(in: &amp;subscriptions)
        
    }
    
    mutating func cancelAll() {
        subscriptions.forEach{ $0.cancel()}
    }
}

var fizzBuzzPrinter = FizzbuzzPrinter()

DispatchQueue.main.async {
    fizzBuzzPrinter.printFizzbuzz(fromIndex: 1, toIndex: 60001) { result in
        switch result {
        case .failure(let printerError):
            print(printerError.description)
        case .success(let finishedIndex):
            print(&quot;finished at \(finishedIndex)&quot;)
        }
    }
}
DispatchQueue.main.async {
    fizzBuzzPrinter.cancelAll()
}

DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
    fizzBuzzPrinter.cancelAll()
}
</code></pre>
<p>the code prints (last 10 lines):</p>
<pre><code>fizz at 59982
fizzbuzz at 59985
fizz at 59988
buzz at 59990
fizz at 59991
fizz at 59994
buzz at 59995
fizz at 59997
fizzbuzz at 60000
finished at 60000

</code></pre>
<p>I also tried to use the .switchToLatest() operator, still unable to cancel it</p>
<pre><code>struct FizzbuzzPrinter {
    private var subscriptions = Set&lt;AnyCancellable&gt;()
    
    private let publishers = PassthroughSubject&lt;AnyPublisher&lt;Int, Never&gt;, Never&gt;()
    private let finishPublisher = PassthroughSubject&lt;Int,Never&gt;()


    mutating func printFizzbuzz(fromIndex: Int, toIndex: Int, handler: @escaping (_ result: Result&lt;Int,PrinterError&gt;) -&gt; Void) {
        guard toIndex &gt; fromIndex else {
            handler(.failure(.indexError(&quot;toIndex must larger than fromIndex&quot;)))
            return
        }

        var currentIndex: Int = fromIndex
        
        publishers
            .switchToLatest()
            .handleEvents(receiveOutput: { index in
                currentIndex = index
            }, receiveCancel: {
                handler(.failure(.subscriptionError(&quot;cancaled at \(currentIndex)&quot;)))
            })
            .map { number -&gt; String in
                switch (number.isMultiple(of: 3), number.isMultiple(of: 5) ) {
                case (true, true):
                    return &quot;fizzbuzz at \(number)&quot;
                case (true, false):
                    return &quot;fizz at \(number)&quot;
                case (false, true):
                    return &quot;buzz at \(number)&quot;
                case (false, false):
                    return String()
                }
            }
            .filter{ !$0.isEmpty }
            .sink { _ in
                handler(.success(currentIndex))
            } receiveValue: { print($0)}
            .store(in: &amp;subscriptions)
        
        publishers.send(Array&lt;Int&gt;(fromIndex ..&lt; toIndex)
                            .publisher
                            .eraseToAnyPublisher())
        
    }
    
    mutating func cancel() {
        publishers.send(finishPublisher.eraseToAnyPublisher())
        finishPublisher.send(completion: .finished)
    }
}

var fizzBuzzPrinter = FizzbuzzPrinter()

DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
    fizzBuzzPrinter.cancel()
}
fizzBuzzPrinter.printFizzbuzz(fromIndex: 1, toIndex: 60001) { result in
    switch result {
    case .failure(let printerError):
        print(printerError.description)
    case .success(let finishedIndex):
        print(&quot;finished at \(finishedIndex)&quot;)
    }
}
</code></pre>
<p>I feel that I made a mistake somewhere but I couldn't figure it.</p>
<p>++++++++++++++++++Update: +++++++++++++++++++</p>
<p>Thanks @matt
I changed the publisher to a Timer based one and it works now</p>
<pre><code>        Timer.publish(every: 0.1, on: .main, in: .common)
            .autoconnect()
            .scan(fromIndex) { current, _ in
                current + 1
            }
            .prefix(toIndex - fromIndex)
</code></pre>
<p>++++++++++++++++++Update: 2 +++++++++++++++++++</p>
<p>based on @matt comment</p>
<pre><code>.subscribe(on: DispatchQueue(label: &quot;serial queue&quot;))
</code></pre>
<p>and @matt Link: <a href=""https://www.apeth.com/UnderstandingCombine/operators/operatorsTransformersBlockers/operatorsflatmap.html#SECexertingbackpressure"" rel=""nofollow noreferrer"">link</a> the last section &quot;Exerting Backpressure&quot;</p>
<pre><code>            .flatMap(maxPublishers: .max(1)){ num in
                Just(num).delay(for: .seconds(0.01), scheduler: DispatchQueue.main)
            }

</code></pre>
<p>both works</p>
<p>Thanks!!</p>
<p>++++++++++++++++++Update: 3 +++++++++++++++++++</p>
<p>I modified my previous codes to become a more generic one and found out using</p>
<pre><code>.subscribe(on: DispatchQueue.global(qos: .background))
</code></pre>
<p>and</p>
<pre><code>.receive(on: DispatchQueue.main)
</code></pre>
<p>works best for me, the speed will not limited by hard coded timeInterval limit, not blocking each other and individually cancelable</p>
<p>I called the below code (some unrelated logics not included)</p>
<pre><code>typealias CancelableIntTaskType = CancelableTask&lt;AnyPublisher&lt;Int, Never&gt;&gt;
var cancelableIntTasks = CancelableIntTaskType()
var taskIdArray = [UUID?]()

taskIdArray = [
    startFizzBuzzTask(50, -80, &amp;cancelableIntTasks),
    startFizzBuzzTask(100, 200, &amp;cancelableIntTasks),
    startFizzBuzzTask(600, 1000, &amp;cancelableIntTasks),
    startFizzBuzzTask(2000, 2600, &amp;cancelableIntTasks)
]

checkAllTasksStarted(taskIdArray)

DispatchQueue.main.asyncAfter(deadline: .now() + 0.0001) {
    if let id = taskIdArray.compactMap({$0}).first {
        cancelableIntTasks.cancelTaskWithID(id)
    }
}

DispatchQueue.main.asyncAfter(deadline: .now() + 0.0002) {
    cancelableIntTasks.cancelAll()
}
</code></pre>
<p>outputs</p>
<pre><code>*id 52F started
id:52F val: 100 progress 0.0%
id:52F val: 101 progress 1.0%
id:52F val: 102 progress 2.0%
id:52F val: 103 progress 3.0%
id:52F val: 104 progress 4.0%
id:52F val: 105 progress 5.0%
id:52F val: 106 progress 6.0%
id:52F val: 107 progress 8.0%
id:52F val: 108 progress 8.0%
id:52F val: 109 progress 9.0%
id:52F val: 110 progress 10.0%
id:52F val: 111 progress 11.0%
id:52F val: 112 progress 12.0%
*id 9EA started
id:52F val: 113 progress 13.0%
id:52F val: 114 progress 15.0%
id:52F val: 115 progress 15.0%
*id 97B started
id:52F val: 116 progress 16.0%
id:52F val: 117 progress 17.0%
id:52F val: 118 progress 18.0%
id:9EA val: 600 progress 0.0%
id:9EA val: 601 progress 1.0%
id:97B val: 2000 progress 0.0%
id:9EA val: 602 progress 1.0%
id:9EA val: 603 progress 1.0%
id:9EA val: 604 progress 1.0%
id:97B val: 2001 progress 1.0%
id:9EA val: 605 progress 2.0%
id:97B val: 2002 progress 1.0%
id:52F val: 119 progress 19.0%
id:9EA val: 606 progress 2.0%
4 tasks initiated 3 started
task at index 0 failed
id:97B val: 2003 progress 1.0%
id:52F val: 120 progress 20.0%
id:9EA val: 607 progress 2.0%
id:97B val: 2004 progress 1.0%
id:9EA val: 608 progress 2.0%
id:52F val: 121 progress 21.0%
id:97B val: 2005 progress 1.0%
id:9EA val: 609 progress 3.0%
id:97B val: 2006 progress 1.0%
id:9EA val: 610 progress 3.0%
id:97B val: 2007 progress 2.0%
id:9EA val: 611 progress 3.0%
id:97B val: 2008 progress 2.0%
id:9EA val: 612 progress 3.0%
id:97B val: 2009 progress 2.0%
id:9EA val: 613 progress 4.0%
id:97B val: 2010 progress 2.0%
id:9EA val: 614 progress 4.0%
id:97B val: 2011 progress 2.0%
id:52F val: 122 progress 22.0%
id:9EA val: 615 progress 4.0%
id:52F val: 123 progress 23.0%
id:9EA val: 616 progress 4.0%
id:52F val: 124 progress 24.0%
id:9EA val: 617 progress 5.0%
id:52F val: 125 progress 25.0%
id:97B val: 2012 progress 2.0%
id:9EA val: 618 progress 5.0%
**52F canceled at 125 progress: 25.0%
**97B canceled at 2012 progress: 2.0%
**9EA canceled at 619 progress: 5.0%
id:9EA val: 619 progress 5.0%
id:52F val: 126 progress 26.0%


</code></pre>
<p>+++++++++++++++++++update 4+++++++++++++++++++</p>
<p>Just made a project for learning ways to cancel / resume the tasks</p>
<p><a href=""https://github.com/hgtlzyc/PokemonDisplay"" rel=""nofollow noreferrer"">https://github.com/hgtlzyc/PokemonDisplay</a></p>
","15354305","","15354305","","2021-06-13 02:31:26","2021-06-13 02:31:26","Swift Combine, how to cancel the execution","<ios><swift><xcode><combine>","1","3","","","","CC BY-SA 4.0"
"67864691","1","67951416","","2021-06-07 00:20:31","","1","379","<p>I have a <code>SummaryView</code> with a <code>Report</code> as <code>@State</code>.</p>
<p>A <code>Report</code> is a protocol which includes some changes a user might want to make:</p>
<pre><code>protocol Report {
    var changeGroups: [ChangeGroup] { get set }
}
</code></pre>
<p>There are several kinds of reports; individual reports are implemented as a struct:</p>
<pre><code>struct RealEstateReport: Report {
    static let name = &quot;Real Estate Report&quot;
    
    var changeGroups = [ChangeGroup]()
}
</code></pre>
<p>A <code>ChangeGroup</code> is a struct with (among other stuff) a human-readable summary and a handful of proposed changes:</p>
<pre><code>struct ChangeGroup: Identifiable {
    var summary: String
    var proposedChanges = [ProposedChange]()
}
</code></pre>
<p>A <code>ProposedChange</code> is a <em>class</em> that represents one discrete change the app proposes to the user, which is <code>enabled</code> by default:</p>
<pre><code>class ProposedChange: ObservableObject, Identifiable {
    @Published var enabled = true
    let summary: String
</code></pre>
<p>(In a detail view, <code>enabled</code> is bound to a <code>Toggle</code> so a user can flip each proposed change on and off.)</p>
<p>So a <code>Report</code> has many <code>ChangeGroup</code>s which themselves have many <code>ProposedChange</code>s.</p>
<p>I'm trying to include some high level details on the <code>SummaryView</code>:</p>
<pre><code>struct SummaryView: View {
    @State var report: Report
    
    var body: some View {
        Text(&quot;Summary&quot;)
            .foregroundColor(…) // ???
    }
</code></pre>
<p>I want <code>foregroundColor</code> to be red, yellow, or green:</p>
<ul>
<li><strong>Red</strong> if <code>enabled</code> is <code>false</code> for <em>all</em> <code>ProposedChange</code>s in this <code>Report</code></li>
<li><strong>Green</strong> if <code>enabled</code> is <code>true</code> for <em>all</em> <code>ProposedChange</code>s in this <code>Report</code></li>
<li><strong>Yellow</strong> if <code>enabled</code> is mixed for different <code>ProposedChange</code>s in this <code>Report</code></li>
</ul>
<p>I've read a bit about Combine, and I think I need to create a new Combine subscription for each <code>ChangeGroup</code>, and map that to a new Combine subscription for each <code>ProposedChange</code>'s <code>enabled</code> property, flatten the values when one changes, and check if they're all the same.</p>
<p>I'm a little lost on the exact syntax I'd use. And also it seems like structs don't publish changes in the same way (I guess since the structs are value vs. reference types).</p>
<p><strong>How can I set the foregroundColor of the Text view based on the above logic?</strong></p>
","1445366","","1445366","","2021-06-07 02:23:45","2021-06-16 16:25:34","SwiftUI / Combine subscribe to updates in multiple nested collections","<swift><swiftui><combine>","2","12","","","","CC BY-SA 4.0"
"67874361","1","","","2021-06-07 15:20:29","","0","180","<p>I'm using <a href=""https://developer.apple.com/documentation/combine/future"" rel=""nofollow noreferrer"">Future</a> to create a publisher that returns a single value from outside of the future creation closure. For this, I store the <a href=""https://developer.apple.com/documentation/combine/future/promise"" rel=""nofollow noreferrer"">promise</a> property locally:</p>
<pre><code>return Future&lt;Something, Never&gt; { promise in
   self.somePromise = promise
}.eraseToAnyPublisher()
</code></pre>
<p>Then after some work is finished I resolve the promise:</p>
<pre><code>self.somePromise(.success(data))
</code></pre>
<p>I've searched the documentation and haven't found any references, is this a correct usage or is there a better way to do it?</p>
<p>To put it more into context, my idea is to have some kind of &quot;broker&quot; class, that returns promises and that at some time in the future will publish a result:</p>
<pre><code>class FruitBroker {
    
    // MARK: - Private Properties
    private var applePromise: Future&lt;[Apple], Never&gt;.Promise!
    private var orangePromise: Future&lt;[Orange], Never&gt;.Promise!
    
    // MARK: - Methods
    func getApples() -&gt; AnyPublisher&lt;[Apple], Never&gt; {
        return Future&lt;[Apple], Never&gt; { promise in
           self.applePromise = promise
        }.eraseToAnyPublisher()
    }
    
    func getBananas() -&gt; AnyPublisher&lt;[Orange], Never&gt; {
        return Future&lt;[Orange], Never&gt; { promise in
           self.orangePromise = promise
        }.eraseToAnyPublisher()
    }
    
    // MARK: - Private Methods
    private func onHarvestFinished() {
        applePromise(.success(apples))
        orangePromise(.success(oranges))
    }
}
</code></pre>
","2217859","","2217859","","2021-06-07 21:05:58","2021-10-06 08:45:17","Resolve combine future outside of future's closure","<ios><swift><combine>","2","6","","","","CC BY-SA 4.0"
"67879205","1","","","2021-06-07 22:06:24","","1","346","<p>Xcode Instruments detects memory leak in this simple Combine example:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation

func main() {
    print(&quot;Start&quot;)

    let publisher = CurrentValueSubject&lt;Bool, Never&gt;(false)
    var cancellable: AnyCancellable? = publisher
        .prefix(1)
        .sink(receiveValue: { _ in })

    cancellable?.cancel()
    cancellable = nil

    Thread.sleep(forTimeInterval: 10.0)         // wait for Instruments to make leak snapshot

    print(&quot;End&quot;)
}

main()
</code></pre>
<p>Memory leak is detected in <code>sink</code> call:</p>
<pre><code>   0 libsystem_malloc.dylib posix_memalign
   1 libswiftCore.dylib swift_slowAlloc
   2 Combine Publishers.Output.Inner.__allocating_init(downstream:range:)
   3 Combine Publishers.Output.receive&lt;A&gt;(subscriber:)
   4 Combine Publisher.subscribe&lt;A&gt;(_:)
   5 Combine Publisher&lt;&gt;.sink(receiveValue:)
   6 CombineLeak1 main() .../main.swift:24
   7 CombineLeak1 main .../main.swift:34
   8 libdyld.dylib start
</code></pre>
<p>If such publisher is flatmapped, it produces memory leak for every event.
If the operator <code>prefix(1)</code> is replaced by <code>first()</code>, memory leak disappear. What is wrong?</p>
<p><em>Note: Instruments was run properly via Profile build with Release configuration.</em></p>
","3082547","","","","","2021-06-07 22:06:24","Memory leak in Swift Combine sink","<swift><memory-leaks><combine>","0","3","","","","CC BY-SA 4.0"
"67907327","1","67911586","","2021-06-09 15:33:01","","0","125","<p>I have a login button named proceed, and have 2 <code>@Published</code> properties that represent current typed text in <code>UITextField</code>.
What i want is, to assign result of <code>.filter { !$0.0.isEmpty &amp;&amp; !$0.1.isEmpty}</code> to <code>Bool</code> variable <code>isEnabled</code> of my <code>UIButton</code></p>
<p>Currently i ended up with this:</p>
<pre><code>passwordTxtf.textView.$text
  .combineLatest(loginTxtf.textView.$text)
  .filter { !$0.0.isEmpty &amp;&amp; !$0.1.isEmpty}
  .sink(receiveValue: { [weak self] in
          guard let weakSelf = self else { return }
          weakSelf.loginEntered = $0
          weakSelf.passEntered = $1
          weakSelf.setProceedEnableState()
  })
  .store(in: &amp;subscriptions)
</code></pre>
<p>Where <code>setProceedEnableState()</code> is a function that checks class variables and therefore determine button enabled state.</p>
<p>But i want somehow assign that during &quot;pipeline&quot;, or do more elegant way</p>
","1451247","","","","","2021-06-10 07:15:50","Make button enabled depending on strings using Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"67920632","1","67921717","","2021-06-10 11:55:32","","0","185","<p>I'm fairly new to Combine declarative API. I'm trying to implement a generic network layer for a SwiftUI application. For all requests that receive data I understand how to structure the data flow.</p>
<p>My problem is that I have some HTTP POST requests that returns no data. Only a HTTP 200 on success. I can't figure out how to create a publisher that will handle a decoding that can fail since there could be not data in the body of the response. Here's what I tried:</p>
<pre><code>func postResource&lt;Resource: Codable&gt;(_ resource: Resource, to endpoint: Endpoint) -&gt; AnyPublisher&lt;Resource?, NetworkError&gt; {
        return Just(resource)
            .subscribe(on: queue)
            .encode(encoder: JSONEncoder())
            .mapError { error -&gt; NetworkError in
                return NetworkError.encoding(error)
            }
            .map { data -&gt; URLRequest in
                return endpoint.makeRequest(with: data)
            }
            .tryMap { request -&gt; Resource? in
                self.session.dataTaskPublisher(for: request)
                    .tryMap { data, response -&gt; Data in
                        guard let httpUrlResponse = response as? HTTPURLResponse else { throw NetworkError.unknown }
                        guard (200 ... 299).contains(httpUrlResponse.statusCode) else { throw NetworkError.error(for: httpUrlResponse.statusCode) }
                        return data
                    }
                    .tryMap { data -&gt; Resource? in
                        return try? JSONDecoder().decode(Resource.self, from: data)
                    }
            }
            .mapError({ error -&gt; NetworkError in
                switch error {
                case is Swift.DecodingError:
                    return NetworkError.decoding(error)
                case let urlError as URLError:
                    return .urlError(urlError)
                case let error as NetworkError:
                    return error
                default:
                    return .unknown
                }
            })
            .eraseToAnyPublisher()
    }
</code></pre>
<p>The compiler is complaining with the following error on tryMap row:
<code>Declared closure result 'Publishers.TryMap&lt;URLSession.DataTaskPublisher, Resource?&gt;' is incompatible with contextual type 'Resource?'</code></p>
<p>Anyone has an idea?
Thanks!</p>
","1919754","","","","","2021-06-10 13:03:05","HTTP POST request using Swift Combine","<swift><http-post><combine>","1","2","","","","CC BY-SA 4.0"
"67924925","1","67954464","","2021-06-10 16:14:59","","1","728","<p>I am trying to call a Swift 5.5 async throws method inside a method that should return an AnyPublisher but I am having trouble to achieve this. I tried using a <code>Future</code> (promise) which did not work and I only managed to find a Swift 5.5 API to convert closure based methods to async ones.</p>
<pre><code>class Loader {

    func loadSomeData() -&gt; async throws [String] {
        /// some code
    }
}

class Service {
   let loader: Loader
   init(loader: Loader) { 
      self.loader = loader
   }

   func someDataPublisher() -&gt; AnyPublisher&lt;[String], Error&gt; {
       // How can I convert this?
       try await loader.loadSomeData() 
   }
}
</code></pre>
","4945232","","","","","2021-06-13 03:01:52","Swift 5.5 async await method to AnyPublisher","<swift><async-await><combine>","1","0","","","","CC BY-SA 4.0"
"67949158","1","67950044","","2021-06-12 13:08:33","","0","182","<p>I decided to migrate a standard network call to one using combine and its operators.</p>
<p>Given the following code</p>
<pre><code>enum NetworkServiceError: Error{
   case badUrl
   case networkFail(String)
}

func getHtml(from url: String, completion: @escaping (Result&lt;String, NetworkServiceError&gt;) -&gt; ()) {
   guard let url = URL(string: url) else {
      completion(.failure(.badUrl))
      return
   }
   URLSession.shared.dataTask(with: url) { (data, _, error) in
      if let err = error{
         completion(.failure(.networkFail(err.localizedDescription)))
         return
      }
      guard let rawHtmlData = data else {
         completion(.failure(.networkFail(&quot;No data&quot;)))
         return
      }
      guard let html = String(data: rawHtmlData, encoding: .utf8) else {
         completion(.failure(.networkFail(&quot;String serialization failed&quot;)))
         return
      }
      completion(.success(html))
   }
   .resume()
}
</code></pre>
<p>I would like to have the same precise error handling in the combine counterpart.
Being honest, i can t figure out how to do so despite i watched tons of videos about combine.
Here is my attempt</p>
<pre><code>func combineHtml(url: String)-&gt; AnyPublisher&lt;String, NetworkServiceError&gt;{
   
   guard let safeUrl = URL(string: url) else {
      return Fail(error: NetworkServiceError.badUrl).eraseToAnyPublisher()
   }

   let publisher = URLSession.shared
      .dataTaskPublisher(for: safeUrl)
      .tryMap{ result-&gt; Data in
         guard !result.data.isEmpty else{throw NetworkServiceError.networkFail(&quot;No data&quot;)}
         return result.data
      }
      .tryMap{ data-&gt; String in
         guard let html = String(data: data, encoding: .utf8) else{
            throw NetworkServiceError.networkFail(&quot;String serialization failed&quot;)
         }
         return html
      }
//      .mapError{ error-&gt; NetworkServiceError in
//         return NetworkServiceError.networkFail(&quot;error&quot;)
//      }

 
      .receive(on: DispatchQueue.main)
      .eraseToAnyPublisher()
      
   return publisher
      
}
</code></pre>
<p>Im not sure how i should handle the different errors: the try operators should throw and the pipeline should cancel, which is what i want. However, if i dont map the error to NetworkServiceError, (commented code) i should change the return type which i d like to avoid.
There must be something which is not correct im my error handling.</p>
<p>What would be the best way to handle multiple errors in combine?
Im not really satisfied with this code.</p>
","4584610","","4584610","","2021-06-12 13:15:45","2021-06-12 14:59:17","Combine multiple errors handling","<swift><error-handling><combine>","1","2","","","","CC BY-SA 4.0"
"67950513","1","","","2021-06-12 15:50:51","","0","1020","<p>When I want to assign a subscriber to a publisher I get this error:</p>
<blockquote>
<p>No exact matches in call to instance method 'subscribe'</p>
</blockquote>
<p>I write the code in <code>ViewdidLoad</code>:</p>
<pre><code>let textPublisher = NotificationCenter.Publisher(center: .default, name: .labelChange).map({ ($0.object as! String) })
let textsubscriber = Subscribers.Assign(object: textLabel, keyPath: \.text)
textPublisher.subscribe(textsubscriber)
</code></pre>
","8137848","","4263824","","2021-06-12 15:57:12","2021-06-12 16:05:38","No exact matches in call to instance method 'subscribe', Combine Freamwork","<swift><combine>","1","0","","2021-06-12 20:05:04","","CC BY-SA 4.0"
"67963577","1","67964495","","2021-06-14 00:17:32","","1","179","<p>I have a listener that is registered/deregistered whenever user logs in and out. I have something analogous to the following code,</p>
<pre><code>import Foundation
import Combine

class X : ObservableObject {
    @Published var data: String? = nil
    
    func setData() {
        data = &quot;DATA&quot;
    }
}

let x = X()
var store = Set&lt;AnyCancellable&gt;()
x.$data.sink { v1 in  // I need to add .receive(on:) here
    print(v1)
    if v1 != nil {
        x.$data.sink { v2 in
            print(v2) // Why is this nil
        }.store(in: &amp;store)
    }
}.store(in: &amp;store)

x.setData()
</code></pre>
<p>I thought that <code>v2</code> will be <code>&quot;DATA&quot;</code>, but it isn't. I need to do a <code>.receive(on: DispatchQueue.main)</code> in the outer subscription to get them both to receive the &quot;after&quot; state.</p>
<p>My working theory is that the value isn't written after all the handlers are called, by I don't know how to verify it let alone if it's correct.</p>
<p>Why is <code>receive(on:)</code> necessary here?</p>
<blockquote>
<p>I know I could've used <code>flatMap</code>, but I didn't use it because I my state is delivered way too late, and I need to unsubscribe to the inner mapped publisher before the sign out code runs to avoid permission issues.</p>
</blockquote>
","789253","","","","","2021-06-14 03:29:44","Cannot get latest value when subscribing to the emitting Publisher","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"67970269","1","","","2021-06-14 12:31:12","","2","134","<p>I want to invoke a URLSession publisher based on a timer publisher every 60 minutes.</p>
<p>It seems like this should be possible but not aware how to do it:</p>
<p>For instance;</p>
<pre><code>
struct Response: Codable {
    // ... some fields here
}


class MyClass: ObservableObject {
  @Published var response: Response? = nil
  var cancelable : AnyCancelable? 
  func connectPoller() {
    let timer = Timer.TimerPublisher(interval: 60 * 60, runLoop: .main, mode: .default)
    // how to chain this?
    // want to connect the timer to invoke the data task
    URLSession.shared.dataTaskPublisher(for: URL(string: &quot;some-url-here&quot;)!).tryMap() { element -&gt; Data in
            guard let httpResponse = element.response as? HTTPURLResponse,
                httpResponse.statusCode == 200 else {
                    throw URLError(.badServerResponse)
                }
            return element.data
        }.decode(type: Response?.self, decoder: JSONDecoder()).eraseToAnyPublisher()
        .replaceError(with: nil).assign(to: \.response, on: self)
    }
}
</code></pre>
","1532045","","","","","2021-06-14 15:48:23","how to invoke a URLSession publisher when a timer publisher fires","<swift><combine>","2","1","","","","CC BY-SA 4.0"
"67971048","1","","","2021-06-14 13:23:05","","0","40","<p>The didSet observer does not fire when the value is changed due to the assignment. Is this a bug or a feature?</p>
<pre><code>struct ContentView: View {
    @StateObject var v = vm()
    var body: some View {
        Text(String(v.b))
            .padding()
    }
}

class vm: ObservableObject {
    @Published var b = false {
        didSet {
            print(&quot;hello didSet \(b)&quot;)
        }
    }
    
    let pub = CurrentValueSubject&lt;Bool, Never&gt;(false)
    
    init() {
        b = true
        pub.assign(to: &amp;$b)
        pub.send(true)
        pub.send(false)
    }
}
</code></pre>
<p>Expected output:</p>
<blockquote>
<p>hello didSet true</p>
<p>hello didSet false</p>
<p>hello didSet true</p>
<p>hello didSet false</p>
</blockquote>
<p>Actual output:</p>
<blockquote>
<p>hello didSet true</p>
</blockquote>
<p>Assigning the value with <code>.sink()</code> is a workaround but why doesn't <code>assign(to:)</code> trigger the <code>didSet</code> observer?</p>
","1817031","","1817031","","2021-06-14 13:29:01","2021-06-14 13:29:01","didSet does not fire on @Published property when assign(to:) is used","<swift><swiftui><combine>","0","2","","2021-06-14 13:28:49","","CC BY-SA 4.0"
"67976742","1","","","2021-06-14 20:23:11","","0","582","<p>I have a POST request to send a text message to the user that doesn't return anything, but the status code. I try to return AnyPublisher&lt;Void, CustomError&gt; but it won't work.
<a href=""https://i.stack.imgur.com/nBB5X.png"" rel=""nofollow noreferrer"">enter image description here</a></p>
<p>This is what my generic request method looks like:</p>
<pre><code>func request&lt;T&gt;(_ req: NetworkRequest) -&gt; AnyPublisher&lt;T, NetworkError&gt; where T: Decodable, T: Encodable {
    let sessionConfig = URLSessionConfiguration.default
    sessionConfig.timeoutIntervalForRequest = TimeInterval(req.requestTimeout ?? requestTimeout)

    guard let url = URL(string: req.url) else {
        // Return a fail publisher if the url is invalid
        return AnyPublisher(
            Fail&lt;T, NetworkError&gt;(error: NetworkError.badURL(&quot;Invalid Url&quot;))
        )
    }
    // We use the dataTaskPublisher from the URLSession which gives us a publisher to play around with.
    return URLSession.shared
        .dataTaskPublisher(for: req.buildURLRequest(with: url))
        .tryMap { output in
            // throw an error if response is nil
            guard output.response is HTTPURLResponse else {
                throw NetworkError.serverError(code: 0, error: &quot;Server error&quot;)
            }
            return output.data
        }
        .decode(type: T.self, decoder: JSONDecoder())
        .mapError { error in
            // return error if json decoding fails
            NetworkError.invalidJSON(String(describing: error))
        }
        .eraseToAnyPublisher()
}
</code></pre>
","16226336","","","","","2021-06-14 20:58:05","POST request using Swift Combine without return doesn't work with AnyPublisher<Void, Error>","<ios><swift><http><swiftui><combine>","1","4","1","","","CC BY-SA 4.0"
"68035367","1","","","2021-06-18 12:42:34","","0","256","<p>I have a collection view, and I am attempting to use Combine to keep a UILabel up to date on a cell in the collection view. However, if I use <code>receive(on: DispatchQueue.main)</code> (or <code>RunLoop.main</code>) to force messages to come on the UI thread (that's my understanding) then the update doesn't happen. If I remove that line, then everything works fine, but I fear I'd run into future problems with attempts to update the label off the UI thread.</p>
<p>Interestingly, I have the exact same setup on another page, and it works just fine. I can't find anything different as to why this one page won't work. I'm new to Combine, so there's a good chance I'm missing a fundamental element that maybe someone can point out.</p>
<p>Here's the setup...</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import UIKit

class MyViewCell: UICollectionViewCell {
    
    @IBOutlet weak var myLabel: UILabel!

    var subscriptions = Set&lt;AnyCancellable&gt;()
    weak var item: MyCoreDataItem!
    
    func setData(item: MyCoreDataItem) {
        self.item = item

        self.item.publisher(for: \.myStringProperty)
            .receive(on: DispatchQueue.main) // Removing this makes it work
            .assign(to: \.text, on: myLabel)
            .store(in: &amp;subscriptions)
    }
}
</code></pre>
<p>On the controller, I setup a diffable data source as such...</p>
<pre class=""lang-swift prettyprint-override""><code>let diffableDataSource = UICollectionViewDiffableDataSource&lt;Int, NSManagedObjectID&gt;(collectionView: collectionView) { [weak self] (collectionView, indexPath, objectID) -&gt; UICollectionViewCell? in
    guard let item = try? self?.app.persistentContainer.viewContext.existingObject(with: objectID) as? MyCoreDataItem else {
        print(&quot;Managed object not available&quot;)
    }
    
    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;MyViewCell&quot;, for: indexPath) as! MyViewCell
    cell.setData(item: item)
    return cell
}
</code></pre>
","762834","","","","","2021-06-18 12:42:34","UILabel text doesn't update when using Combine `receive(on:)`","<ios><swift><combine>","0","2","","","","CC BY-SA 4.0"
"68035492","1","68035814","","2021-06-18 12:51:58","","1","963","<p>I'm struggling to understand why no values are received to <code>sink</code> in the underlying code.</p>
<pre class=""lang-swift prettyprint-override""><code>func somePublisher() -&gt; AnyPublisher&lt;Bool, Never&gt; {
   let subject = PassthroughSubject&lt;Bool, Never&gt;()
   subject.send(true)
   subject.send(completion: .finished)
   return subject.eraseToAnyPublisher()
}

somePublisher()
   .first()
   .sink { _ in
      print(&quot;Completed&quot;)
   } receiveValue: {
      print(&quot;Received \($0)&quot;)
   }
   .store(in: &amp;sinks)
</code></pre>
<p>Output:</p>
<blockquote>
<p>Completed</p>
</blockquote>
<p>It looks like values are not received by the publishers down the stream if it was finished before it was connected. Is that right?
How could I fix that if my publisher can finish synchronously?</p>
","380014","","","","","2021-06-18 13:14:20","Sink does not receive values when connecting to finished a Publisher","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"68035745","1","","","2021-06-18 13:09:38","","0","23","<p>I have a view/view model that is supposed to show a current time period (a Season) based on a length of time (monthly or quarterly) specified by the user.</p>
<p>The flow to get this season is as follows:</p>
<ol>
<li>The seasonLength must be specified by the end user first. If none is found, they go to a screen where they pick monthly/quarterly.</li>
<li>Once there is a seasonLength stored (may have already been in the users profile), the app looks for a season in the database that includes the current date.</li>
<li>If none is found, it creates one.</li>
<li>The app takes the season found in #2 or #3, stores it as the featuredSeason (and defaultSeason) in the viewModel, and that should display to the end user.</li>
</ol>
<p>I use a property observer on seasonLength to trigger the flow to create the Season, and I use some Combine logic to respond to the season that is created/loaded by the repository.</p>
<p>The issue I'm running into is that my ViewModel is repeatedly running through the initialization methods, which is causing it to get stuck in an infinite loop of re-loading the Season.</p>
<p>My question is - what could lead to this ViewModel being recreated over and over again? (I think it's an issue with my logic, because I've been messing around with the downstream logic for steps 1-4 above, and sometimes this doesn't happen (although when it doesn't happen, the code flow hasn't worked properly)).</p>
<p>Here is the view that looks at the viewModel:</p>
<pre><code>struct SeasonView: View {
    
    @EnvironmentObject var currentUser: CurrentUserProfile
    @ObservedObject var seasonGoalsVM = SeasonGoalsViewModel()
    
    var body: some View {
        if seasonGoalsVM.seasonLength == nil {
            ChooseSeasonLength()
                .environmentObject(seasonGoalsVM)
        } else if seasonGoalsVM.featuredSeason != nil {
            SeasonView()
                .environmentObject(seasonGoalsVM)
        } else {
            LoadingScreen()
                .environmentObject(seasonGoalsVM)
        }
    }
}
</code></pre>
<p>And here is the flow for creating:</p>
<p>First, the list of variables in my ViewModel, with the property observer whenever seasonLength is updated - this is supposed to make sure it's not set to nil, or just showing it's old value, and if not, it will add that seasonLength to the user's profile, and then load or create a current season in the season repository:</p>
<pre><code>class SeasonGoalsViewModel: ObservableObject {
    @Published var seasonRepository: SeasonStoreType
    @Published var seasonLength: SeasonLength? {
        didSet {
            guard seasonLength != nil else {
                print(&quot;Season Length is nil - ending&quot;)
                return
            }
            
            guard seasonLength != oldValue else {
                print(&quot;Season Length was changed to the same value&quot;)
                return
            }
            
            if seasonLength != self.currentUser.currentUser?.seasonLength {
                self.currentUser.currentUser!.seasonLength = seasonLength
                self.currentUser.updateUser(self.currentUser.currentUser!)
            }
            
            guard self.defaultSeason == nil else {
                return
            }
            
            self.seasonRepository.loadOrCreateCurrentSeason()
        }
    }
    
    @Published var defaultSeason: Season?
    @Published var featuredSeason: Season?
    
    @Published var currentUser: CurrentUserType
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
</code></pre>
<p>And here is the initializer for my viewModel - it sets the seasonLength to that currently specified in the user's profile, which should trigger this whole flow. (If one is not found, there is a sub-view to the view specified above that will allow the user to select a seasonLength):</p>
<pre><code>    init(seasonRepository: SeasonStoreType = SeasonRepository(), currentUser: CurrentUserType = CurrentUserProfile.shared) {
        // self.goalRepository = GoalRepository()
        self.seasonRepository = seasonRepository
        self.currentUser = currentUser
        self.seasonLength = currentUser.currentUser?.seasonLength
        
        self.seasonRepository.currentSeasonPublisher
            .sink { [weak self] season in
                print(&quot;SeasonLength is \(String(describing: self?.seasonLength))&quot;)
                if season != nil {
                    self?.handleNewDefaultSeason(season!)
                }
            }
            .store(in: &amp;cancellables)
    }
</code></pre>
<p>I don't know if this is necessary to include, but once a seasonLength is specified, it calls a method in the repository that loads or creates the current season based on a method <code>loadMostRecentSeason() -&gt; Future&lt;Season, ErrorLoadingSeason&gt;</code>:</p>
<pre><code>    func loadOrCreateCurrentSeason() {
        var _ = loadMostRecentSeason()
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    print(error)
                    self.addSeasonToSubcollection(season: Season(lastOrder: 0))
                }
            }, receiveValue: { season in
                    if season.endDate &lt; Date() {
                        let oldOrder = season.order
                        self.currentSeason = self.createCurrentSeason(order: oldOrder)
                        self.addSeasonToSubcollection(season: Season(lastOrder: oldOrder))
                    } else {
                        self.currentSeason = season
                    }
                })
            .store(in: &amp;cancellables)
    }
</code></pre>
<p>That code should set the <code>self.seasonRepository.currentSeasonPublisher</code> that I am subscribed to in the init of the viewModel, which triggers this &quot;handleNewDefaultSeason&quot; code, which sets the defaultSeason/featuredSeason to the season identified in the repository, and makes sure the user's profile is updated to match that:</p>
<pre><code>    func handleNewDefaultSeason(_ season: Season) {
        let seasonId = season.id
        let userProfileDefaultSeason = currentUser.currentUser?.defaultSeason
        
        print(&quot;season ID is equal to \(String(describing: seasonId))&quot;)
        print(&quot;userProfileDefaultSeasonId is equal to \(String(describing: userProfileDefaultSeason))&quot;)
        print(&quot;SeasonLength is \(String(describing: seasonLength))&quot;)
        
        
        // Sets the default season in the view model to default.
        self.defaultSeason = season
        self.featuredSeason = season
        guard seasonId != userProfileDefaultSeason else {
            print(&quot;Season ID of \(String(describing: seasonId)) is already equal to user profile default season: \(String(describing: userProfileDefaultSeason))&quot;)
            return
        }
        guard self.currentUser.currentUser != nil else {
            fatalError(&quot;there is no current user&quot;)
        }
        
        self.currentUser.currentUser!.defaultSeason = seasonId
        self.currentUser.updateUser(self.currentUser.currentUser!)
    }
</code></pre>
<p>It seems to work all the way through, but I think something in here is leading the initializer to be re-run repeatedly, and I'm not sure what's causing that. Are there any common issues that could lead to something like this?</p>
","13831483","","","","","2021-06-18 13:09:38","Observable Object View Model Reinitialized repeatedly - infinite loop","<swift><initialization><infinite-loop><combine>","0","2","","2021-06-18 13:12:52","","CC BY-SA 4.0"
"68057329","1","68058316","","2021-06-20 15:23:40","","2","973","<p>I have an <code>ObservableObject</code> which inside has two more <code>ObservableObjects</code>. Each of these two <code>ObservableObject</code> has one or more <code>@Published</code> properties inside. My solution works but I'm 100% sure there must be another way. I have to copy/ paste everything in order to make it work. I tried two put those two publishers in the View but then I need to pass a lot of params to the child view. Any ideas how to simplify this?</p>
<pre><code>class PackageService: ObservableObject {
    @Published var package: Package
    @Published var error: Error?
    
    @Published var distance: Double?
    @Published var expectedTravelTime: String?
    
    @Published var amount: Int = 0
    @Published var cost: Double = 0
    
    @Published var annotations = [MKPointAnnotation]()

    @Published var isCalculating = true
    @Published var route: MKRoute?
    
    var amountService = AmountService()
    var routeService = RouteService()
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(package: Package) {
        self.package = package
        routeService.calcDirections(source: package.source.toCLLocationCoordinate2D, destination: package.destination.toCLLocationCoordinate2D)
        
        routeService.$route.sink { [self] route in
            self.route = route
            
            amountService.calc(distance: route?.distance)
            calc(route: route)
        }
        .store(in: &amp;cancellables)
        
        routeService.$isCalculating.sink { [self] isCalculating in
            self.isCalculating = isCalculating
        }
        .store(in: &amp;cancellables)
        
        
        routeService.$error.sink { [self] error in
            self.error = error
        }
        .store(in: &amp;cancellables)
        
        amountService.$amount.sink { [self] amount in
            self.amount = amount
        }
        .store(in: &amp;cancellables)
        
        amountService.$cost.sink { [self] cost in
            self.cost = cost
        }
        .store(in: &amp;cancellables)
        
        amountService.$error.sink { [self] error in
            self.error = error
        }
        .store(in: &amp;cancellables)
    }
</code></pre>
","2738166","","","","","2021-06-21 12:39:33","SwiftUI/ Combine Listen to multiple publishers inside an ObservableObject","<ios><swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68058135","1","68058323","","2021-06-20 16:55:44","","1","330","<p>I have the following code</p>
<pre><code> private var codeState : AnyPublisher&lt;((Bool,Bool,Bool,Bool),(Bool,Bool)), Never&gt; {
    let publ1 =  Publishers.CombineLatest4(firstCodeAnyPublisher,secondCodeAnyPublisher,thirdCodeAnyPublisher,fourthCodeAnyPublisher)
    let pub2 = Publishers.CombineLatest(fifthCodeAnyPublisher, sixthCodeAnyPublisher)
    return publ1.combineLatest(pub2)
        .eraseToAnyPublisher()
}
</code></pre>
<p>This operation produces any publisher with two boolean tuple
How can I convert them to a publisher with one tuple the following</p>
<pre><code>AnyPublisher&lt;(Bool,Bool,Bool,Bool,Bool,Bool), Never&gt;
</code></pre>
","7438106","","12299030","","2021-06-20 17:06:26","2021-06-20 17:17:09","How to FlatMap a Publisher of two Tuples into a Publisher with one Tuple","<ios><tuples><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"68086634","1","68087514","","2021-06-22 15:37:29","","1","98","<p>I have a subscriber to an @Published text field. I add the subscriber through the init() function of my class.</p>
<p>The map of this subscriber scans all users in Firebase and checks for the &quot;email&quot; field. If the email inputted by the user is in one of these fields, then I set valid to false (as the email is already in use).</p>
<p>However, when I run this code, the second print line is executed first, with the default value. Then, after some time, the print(&quot;This email is valid&quot;) line is run.</p>
<p>I believe this has to do with the fact that a Firebase call is an asynchronous task.</p>
<p>How can I solve this so that the return value returns the result of the Firebase call? I'm using Xcode Version 12.5.1.</p>
<p>Also, i'm not sure if this is the best way to check if an email is already in use, but it's the only solution I could find :)</p>
<p>Code:</p>
<pre><code>func addEmailSubscriber() {
        
        $email
            .debounce(for: .seconds(1.0), scheduler: DispatchQueue.main)
            .map { email -&gt; Bool in
                
                var valid: Bool = false
                
                Firestore.firestore()
                    .collection(&quot;users&quot;)
                    .whereField(&quot;email&quot;, isEqualTo: email)
                    .getDocuments { (snapshot, err) in
                        
                        guard let snapshot = snapshot else { print(&quot;Error getting snapshot&quot;); return }
                        
                        if err != nil {
                            print(&quot;Error occured&quot;)
                            return
                        }
                        
                        if snapshot.documents.count == 0 {
                            print(&quot;This email is valid&quot;) // This is successfully printed after some time
                            valid = true
                            return
                        }
                    }
                
                print(valid) // This gets printed first, with the value of &quot;false&quot;
                return valid
                
            }
            .sink { [weak self] isValid in
                self?.emailIsValid = isValid
                
            }
            .store(in: &amp;cancellabes)
        
    }
</code></pre>
<p>Log:
<a href=""https://i.stack.imgur.com/5d8P6.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5d8P6.png"" alt=""enter image description here"" /></a></p>
","15847296","","209103","","2021-06-22 16:28:48","2021-06-23 01:39:25","Subscriber returning value before Firebase returns a value in SwiftUI","<swift><firebase><google-cloud-firestore><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68096097","1","","","2021-06-23 08:17:40","","0","117","<pre><code>extension Bundle {
    func decode&lt;T: Codable&gt;(_ file: String) -&gt; T {

        guard let url = self.url(forResource: file, withExtension: nil) else {
            fatalError(&quot;Failed to locate \(file) in Bundle&quot;)
        }

        guard let data = try? Data(contentsOf: url) else {
            fatalError(&quot;Failed to load \(file) in Bundle&quot;)
        }

        let decoder = JSONDecoder()

        guard let decodedData = try? decoder.decode(T.self, from: data) else {
            fatalError(&quot;Failed to decode \(file) in Bundle&quot;)
        }

        return decodedData
    }
}
</code></pre>
<p>I am still getting my feet wet in swiftui and app development, above is my codable bundle extension, how do i add a urlsession to it or better yet with combine.  Thanks</p>
","15147805","","5044042","","2021-06-23 08:51:41","2021-06-23 08:51:41","How to use URLSession with codablebundle extension on a local json file in swiftui","<json><swiftui><codable><combine><urlsession>","0","2","","","","CC BY-SA 4.0"
"68103063","1","","","2021-06-23 15:41:56","","4","334","<p>I have an issue with propagating changes that happen to objects in the view model that are kept in an array.</p>
<p>I understand that <code>@Published</code> for a collection would work if the collection itself changes (eg. if elements were <code>struct</code> not <code>class</code>). Assuming that I need to preserve classes as classes. Is there a way to propagate events to a view, so that it knows it should be refreshed.</p>
<p>I have been trying all nasty ways like implementing <code>ObservableCollection</code> or <code>ObservableArray</code> but nothing seems to work.</p>
<p>Below an example of what I am struggling with.
Toggle is changing internally element of an array which has all the <code>ObservableObject</code> conformance and <code>@Published</code> annotation but still Text is not being refreshed.</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct ContentView: View {
    @StateObject var vm = ViewModel()
    
    var body: some View {
        Text(vm.texts.first!.text)
            .padding()
        
        Button(&quot;Toggle&quot;) {
            vm.texts.first?.toggle()
        }
    }
}

class ViewModel: ObservableObject {
    @Published var texts: [TextHolder] = [.init(), .init()]
}

class TextHolder: ObservableObject {
    @Published var text: String = &quot;&quot;
    
    func toggle() {
        text = UUID().uuidString
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
","1138916","","","","","2021-06-26 12:50:33","Publishing changes to a collection of observable objects","<swift><swiftui><combine>","3","1","1","","","CC BY-SA 4.0"
"68109898","1","68110210","","2021-06-24 05:04:24","","-3","168","<h2>Edited</h2>
<h3>Having multiple data sources for an app</h3>
<p>What is the best approach to <code>combine</code> all data sources together in one class and add it as one environment object, keeping in mind data might change, therefore objects update the views?</p>
<p>What are the appropriate Bindings to use for:</p>
<p><strong>Services</strong> (API fetches): @Published?</p>
<p><strong>Computed variables</strong>: Lazy var?</p>
<p>Please refer to the diagram as an example. Thanks.</p>
<p>These questions were good references:</p>
<p><a href=""https://stackoverflow.com/questions/58203531/an-equivalent-to-computed-properties-using-published-in-swift-combine"">An equivalent to computed properties using @Published in Swift Combine?</a></p>
<p><a href=""https://medium.com/genetec-tech/property-wrappers-in-swift-5-1-the-missing-published-implementation-1a466ebcf660"" rel=""nofollow noreferrer"">https://medium.com/genetec-tech/property-wrappers-in-swift-5-1-the-missing-published-implementation-1a466ebcf660</a></p>
<h3>diagram</h3>
<p><a href=""https://i.stack.imgur.com/5c6bk.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/5c6bk.jpg"" alt=""enter image description here"" /></a></p>
","14395202","","14395202","","2021-06-24 13:46:34","2021-06-24 13:46:34","MVVM in SwiftUI and the appropriate Bindings","<swift><core-data><swiftui><combine>","1","1","","2021-06-24 05:45:27","","CC BY-SA 4.0"
"68129303","1","68133969","","2021-06-25 10:10:15","","0","514","<p>I have network request that triggers every last cell in switui appearas. Sometimes if user scrolls fast enough down -&gt; up -&gt; request will trigger before first one finishes. Without combine or reactive approach I have completion block and bool value to handle this:</p>
<pre><code>public func load() {
        guard !isLoadingPosts else { return }
        isLoadingPosts = true
        postsDataProvider.loadMorePosts { _ in
            self.isLoadingPosts = false
        }
    }
</code></pre>
<p>I was wondering if with combine this can be resolved more elegantly, without the need to use bool value. For example execute request only if previous has finished?</p>
","744270","","560942","","2021-06-25 15:36:30","2021-06-25 23:52:44","iOS Combine Start new request only if previous has finished","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"68134333","1","","","2021-06-25 16:31:27","","1","213","<p>I'm trying to read this JSON data with Combine but I cannot make it work if I try to read the <strong>release</strong> field.
The address <a href=""https://amiiboapi.com/api/"" rel=""nofollow noreferrer"">https://amiiboapi.com/api/</a> returns something like this:</p>
<pre><code>{
&quot;amiibo&quot;: [
    {
      &quot;amiiboSeries&quot;: &quot;Super Smash Bros.&quot;, 
      &quot;character&quot;: &quot;Mario&quot;, 
      &quot;gameSeries&quot;: &quot;Super Mario&quot;, 
      &quot;head&quot;: &quot;00000000&quot;, 
      &quot;image&quot;: &quot;https://raw.githubusercontent.com/N3evin/AmiiboAPI/master/images/icon_00000000-00000002.png&quot;, 
      &quot;name&quot;: &quot;Mario&quot;, 
      &quot;release&quot;: {
        &quot;au&quot;: &quot;2014-11-29&quot;, 
        &quot;eu&quot;: &quot;2014-11-28&quot;, 
        &quot;jp&quot;: &quot;2014-12-06&quot;, 
        &quot;na&quot;: &quot;2014-11-21&quot;
      }, 
      &quot;tail&quot;: &quot;00000002&quot;, 
      &quot;type&quot;: &quot;Figure&quot;
    }, 
    {
      &quot;amiiboSeries&quot;: &quot;Super Mario Bros.&quot;, 
      &quot;character&quot;: &quot;Mario&quot;, 
      &quot;gameSeries&quot;: &quot;Super Mario&quot;, 
      &quot;head&quot;: &quot;00000000&quot;, 
      &quot;image&quot;: &quot;https://raw.githubusercontent.com/N3evin/AmiiboAPI/master/images/icon_00000000-00340102.png&quot;, 
      &quot;name&quot;: &quot;Mario&quot;, 
      &quot;release&quot;: {
        &quot;au&quot;: &quot;2015-03-21&quot;, 
        &quot;eu&quot;: &quot;2015-03-20&quot;, 
        &quot;jp&quot;: &quot;2015-03-12&quot;, 
        &quot;na&quot;: &quot;2015-03-20&quot;
      }, 
      &quot;tail&quot;: &quot;00340102&quot;, 
      &quot;type&quot;: &quot;Figure&quot;
    } 
  ] 
}
</code></pre>
<p>I have my model like this:</p>
<pre><code>// MARK: - Amiibo List
struct AmiibosList: Codable {
    let amiibo: [Amiibo]
}

 // MARK: - Amiibo
struct Amiibo: Codable {
    let amiiboSeries: String
    let character: String
    let gameSeries: String
    let head: String
    let image: String
    let name: String
    let release: Release
    let tail: String
    let type: String
}

// MARK: - Release
struct Release: Codable  {
    let au : String?
    let eu : String?
    let jp : String?
    let na : String?
}
</code></pre>
<p>And I'm trying to fetch the data like this:</p>
<pre><code>guard let url = URL(string: &quot;https://amiiboapi.com/api/&quot;) else {
    fatalError(&quot;Invalid URL&quot;)
}

var publisher = URLSession.shared.dataTaskPublisher(for: url)
    .receive(on: RunLoop.main)
    .map(\.data)
    .decode(type: AmiiboList.self, decoder: JSONDecoder())
    .sink(receiveCompletion: { completion in
        if case .failure(let err) = completion {
            print(&quot;Failed with error \(err)&quot;)
        }
    }, receiveValue: { value in
        print(&quot;Received \(value)&quot;)
        //        print(&quot; Received \(value.amiibo[0].release)&quot;)
    })
</code></pre>
<p>If I comment/remove the release from my amiibo struct, everything works. For some reason I cannot retrieve the data with the release dates and I can't figure why.
Do I need to do anything else for nested JSON data?</p>
","5163913","","5163913","","2021-06-25 16:45:17","2021-06-29 19:04:14","Fail to decode JSON with swift Combine","<json><swift><network-programming><combine>","1","4","","","","CC BY-SA 4.0"
"68145401","1","68146433","","2021-06-26 18:51:51","","0","1717","<p><strong>StepsEntity is a core data entity</strong></p>
<p>Receiving the following error when attempting to display a string value in a TextField: &quot;Cannot convert value of type 'Published&lt;[StepsEntity]&gt;.Publisher' to expected argument type 'Binding'&quot;</p>
<p>I know this is because StepsEntity in my core data model is @Published. @Published works great here as it allows all the data to be updated neatly. How can I display an @Published in a TextField?</p>
<p>Below is the piece where I am receiving the error:</p>
<pre><code>List {
            VStack(alignment: .center) {
                if let recipeSteps = (vm.recipes[vm.getRecordsCount() - 1].steps?.allObjects as? [StepsEntity])?.sorted { $0.stepNumber &lt; $1.stepNumber } {
                    
                    if (textFieldCount == 1) {
                        //do nothing
                    } else if (textFieldCount &gt; 1) {
                        ForEach(recipeSteps, id: \.stepNumber) { index in
                            HStack {
                               
                                Text(String(index.stepNumber) + &quot;.&quot;).bold()
                                TextField(&quot;&quot;, text: vm.$recipeSteps) //This is where the error is seen
                                
                            }
                        }.onDelete(perform: { index in
                            self.vm.deleteRecipeSteps(at: index, from: vm.recipes[vm.getRecordsCount() - 1])
                            })
                    }
                
                }
            }
</code></pre>
<p>vm.recipeSteps refers to my CoreDataRelationshipViewModel, which is where all core data functions are handled. this is declared in the view struct as:</p>
<pre><code>@StateObject var vm = CoreDataRelationshipViewModel()
</code></pre>
<p>Here is a snippet from the CoreDataRelationshipViewModel class:</p>
<pre><code>class CoreDataRelationshipViewModel: ObservableObject {

let manager = CoreDataManager.instance
@Published var recipes: [RecipeEntity] = []
@Published var recipeSteps: [StepsEntity] = []

init() {
    getRecipes()
}

func getRecipes() { ////more functions for retrieving, deleting, etc. in this section
</code></pre>
<p>I have tried converting the Published var to a binding but no luck:</p>
<pre><code>TextField(&quot;&quot;, text: Binding(vm.$recipeSteps)!)
</code></pre>
<p>I have also tried referencing the recipeSteps declared in the if let statement within the list, but that does not work either.</p>
<p>I have been at it for a few days, and I think I have exhausted all options. Open to all ideas here. Maybe I need to rebuild my model?</p>
<p>Thoughts?</p>
<p>--Edits--</p>
<p>Upper portion of struct, where variables are created:</p>
<pre><code>struct AddItemView: View {

@StateObject var viewModel = ViewModel()
@State var frameDimensions: CGFloat = 0
@State var imageButtonText: String = &quot;Click To Add Image&quot;
@State var imageToUpload: Data

@StateObject var vm = CoreDataRelationshipViewModel()
@Environment(\.presentationMode) var presentationMode
@State var stepInfo: String = &quot;&quot;
@State var textFieldCount: Int = 1
@State var stepNumber: [Int]
@State var recordsCount = 1
@State var errorText = &quot;&quot;
@State var stepErrorColor = Color.white.opacity(0)
@State var nameErrorColor = Color.white.opacity(0)

var body: some View {
    ZStack {
        HStack {
</code></pre>
","12053724","","12053724","","2021-06-26 19:22:51","2021-06-27 11:49:25","Cannot convert value of type 'Published<[StepsEntity]>.Publisher' to expected argument type 'Binding<String>'","<swift><swiftui><binding><combine>","2","3","1","","","CC BY-SA 4.0"
"68160383","1","68171854","","2021-06-28 08:54:32","","1","250","<p>I am developing an IOS app and as per the requirement I need to retry all failed api for 3 times with 3 seconds delay. In order to do that I have added an extension to a Publisher as follows, but there is one small problem with this code, after the last attempt if I get a failed response then it takes 3 seconds to execute the expected failure code. I need to show failure message as soon as last attempt fails, is there any way to handle this?</p>
<pre><code>public extension Publisher {
    func retryWithDelay&lt;S&gt;(
        retries: Int,
        delay: S.SchedulerTimeType.Stride,
        scheduler: S
    ) -&gt; AnyPublisher&lt;Output, Failure&gt; where S: Scheduler {
        
        self
            .delayIfFailure(for: delay, scheduler: scheduler)
            .retry(retries)
            .eraseToAnyPublisher()
    }

    private func delayIfFailure&lt;S&gt;(
        for delay: S.SchedulerTimeType.Stride,
        scheduler: S
    ) -&gt; AnyPublisher&lt;Output, Failure&gt; where S: Scheduler {
        self.catch { error in
            Future { completion in
                scheduler.schedule(after: scheduler.now.advanced(by: delay)) {
                    completion(.failure(error))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
</code></pre>
","5068344","","968155","","2021-06-28 13:09:21","2021-06-29 11:44:56","How to retry failed web service calls with time delay in ios app","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"68166444","1","","","2021-06-28 15:54:30","","1","376","<p>I'm migrating from RxSwift to Combine and ran into this issue related to error handling:</p>
<pre><code>func myMethod(firstName: String?) -&gt; Observable&lt;Data&gt; {
     guard let firstName = firstName else {
     return Observable.error(MyErrorEnum.error)
    }
    return someAPICall... 
}
</code></pre>
<p>I'm migrating to Combine as follows:</p>
<pre><code>func myMethod(firstName: String?) -&gt; AnyPublisher&lt;Data, Error&gt; {
     guard let firstName = firstName else {
     // can't quite figure out how to return an error here... 
    }
    return someAPICall... 
}
</code></pre>
<p>I normally don't struggle handling errors, specially when working with network calls, but for some reason this one is avoiding me.</p>
<p>Really appreciate any input!</p>
","14613107","","","","","2021-06-29 05:45:57","Migrating RxSwift to Combine","<ios><swift><rx-swift><combine>","1","3","","","","CC BY-SA 4.0"
"68180025","1","","","2021-06-29 13:48:58","","1","337","<p>In a SwiftUI subscriber, you would normally have this</p>
<pre><code>authenticate
    .receive(on: DispatchQueue.main) // Move to the main thread
    .sink(receiveCompletion: { completion in
        switch completion {
        case .failure(let error): ()
        case .finished: ()
        }
    }, receiveValue: { _ in })
</code></pre>
<p>I would like to extract the receiveCompletion code block to be shared between multiple subscribers expection the same completion i.e the below to be separated and used in multiple subscribers.</p>
<pre><code>receiveCompletion: { completion in
            switch completion {
            case .failure(let error): ()
            case .finished: ()
            }
</code></pre>
","4935761","","811405","","2021-06-30 08:20:01","2021-06-30 08:20:01","SwiftUI Combine Framework shared receiveCompletion code block","<ios><swift><swiftui><combine>","2","3","","","","CC BY-SA 4.0"
"68187173","1","68190530","","2021-06-30 00:39:20","","1","236","<p>I am having a username textField in swiftUI. I am trying to validate input with the help of publishers.</p>
<p>Here is my code:</p>
<pre><code>View

struct UserView: View {
    @StateObject private var userViewModel = UserViewModel()

    init(){
        UITextField.appearance().semanticContentAttribute = .forceRightToLeft
        UITextField.appearance().keyboardAppearance = .dark
    
    }

    var body: some View {
        SecureField(&quot;&quot;, text: $userViewModel.passwordText)
        Text(userViewModel.passwordError).foregroundColor(.red)
            .frame(width: 264, alignment: .trailing)
    }
}
</code></pre>
<p>The View Model</p>
<pre><code>ViewModel

final class UserViewModel: ObservableObject {

    private var cancellables = Set&lt;AnyCancellable&gt;()
    @Published var userText: String = &quot;&quot;
    @Published var userTextError = &quot;&quot;

    private var usernamevalidation: AnyPublisher&lt;(username:String, isValid: Bool), Never&gt; {
        return $userText
            .dropFirst()
            .map{(username:$0, isValid: !$0.isEmpty)}
            .eraseToAnyPublisher()
    }

    private var usernamevalidated: AnyPublisher&lt;Bool,Never&gt; {
        return usernamevalidation
            .filter{$0.isValid}
            .map{$0.username.isValidUserName()}
            .eraseToAnyPublisher()
    }


    init(){
        usernamevalidation.receive(on: RunLoop.main)
            .map{$0.isValid ? &quot;&quot;: &quot;Emptyusername &quot;}
            .assign(to: \.userTextError, on: self)
            .store(in: &amp;cancellables)
        usernamevalidated.receive(on: RunLoop.main)
            .map{$0 ? &quot;&quot; : &quot;wrong username &quot;}
            .assign(to: \.userTextError, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>Extension</p>
<pre><code> extension String {

     func isValidUserName() -&gt; Bool {
         let usernameRegex = &quot;^[a-zA-Z0-9_-]*$&quot;
         let usernamepred = NSPredicate(format:&quot;SELF MATCHES %@&quot;, usernameRegex)
         return usernamepred.evaluate(with: self)
   }
}
</code></pre>
<p>In the usernamevalidated in the init() block in the ViewModel I am assigning the error to userTextError property which should be reflected in the textview. This should happens if a special character such as @ or % .. etc are entered. What happens is that sometimes the error appears in red and other no even though I try to print value of string after map operator i can see the string in printing fine. It is just the error is sometimes reflected in the view and sometimes not. Am I missing something or doing something fundamentally wrong</p>
","7438106","","7948372","","2021-06-30 07:52:20","2021-06-30 07:52:20","Why my views are not Rendered in SwiftUI even though the Publisher emits a value","<swiftui><combine><publisher>","3","0","","","","CC BY-SA 4.0"
"68202367","1","","","2021-06-30 22:47:40","","0","519","<p>I'm getting an error - <code>Key path value type 'ReferenceWritableKeyPath&lt;Foo, [Bar]?&gt;' cannot be converted to contextual type 'WriteableKeyPath&lt;Foo, [Bar]?&gt;'</code> - trying to publish something from a repository class into an instance of my main data model struct, and not sure what to do with this error.</p>
<h2>The Situation</h2>
<p>I have a &quot;Foo&quot; which can have an array of &quot;Bars&quot; loaded in it, and they are loaded in separate repositories as separate collections in my database.</p>
<p>I have a <code>FooViewModel</code> which looks at one foo as a published property, and then I inject a <code>barRepository</code> into that ViewModel to load all the bars tied to that foo when the user presses a button.</p>
<p>My viewModel has a <code>subscribeToBarActions()</code> that gets called when the user presses this button, and this function attempts to subscribe to a <code>barsPublisher</code> variable within the repository, and to assign them to a <code>bars</code> property within the foo object in the ViewModel.</p>
<h2>My Code</h2>
<p>This method in the ViewModel is called when the user clicks on the &quot;Load Bars&quot; button in the Foo (the error is happening at the <code>.assign(...)</code> line). My goal here is to subscribe to the bar array, and map them to the bars property in the foo object in the ViewModel:</p>
<pre><code>    func subscribeToFooBars() {
        self.fooBarRepository.barPublisher
            .map { bars in
                .map { bar in
                    Bar.self
                }
            }
            .assign(to: \.bars, on: self.foo)
            .store(in: &amp;cancellables)
        
        self.fooBarRepository.loadData()
    }
</code></pre>
<p>Here is the Foo structure that has bars as a variable within it - when we initially load instances of Foo, bars is instantiated either as nil or as an empty array (I don't have a strong reason for doing one vs. the other right now).</p>
<pre><code>struct Foo: Codable, Identifiable, Equatable {
    // Identifiers
    @DocumentID var id: String?
    var title: String
    var description: String?
    var bars: [Bar]?
</code></pre>
<p>And my <code>fooBarRepository</code> just has this publisher that is supposed to load and store the bars that are published to the ViewModel, intended to save them to the bar property</p>
<pre><code>class BarRepository: ObservableObject, BarStoreType {
    
    @Published var bars = [Bar]()
    var barsPublished: Published&lt;[Bar]&gt; { _bars }
    var barsPublisher: Published&lt;[Bar]&gt;.Publisher { $bars }
</code></pre>
<p>My <code>foo</code> property within the ViewModel is published, but the <code>bars</code> property inside that structure is not published. I'm wondering if that might be the issue, or if it might have to do with the fact that the repository is a reference type while the Foo struct is a value type. Any thoughts on what is causing this?</p>
","13831483","","","","","2021-07-01 12:56:41","Combine - assigning class published properties to a property in a data model struct","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"68216267","1","","","2021-07-01 20:00:39","","1","241","<p>I have a search bar inside a view where I can search and the search will be passed to a REST api and the result will be showed on a tableView. Below are my different classes</p>
<p>Model:</p>
<pre><code>struct MovieResponse: Codable {
    
    var totalResults: Int
    var response: String
    var error: String
    var movies: [Movie]
    
    enum ConfigKeys: String, CodingKey {
        case totalResults
        case response = &quot;Response&quot;
        case error = &quot;Error&quot;
        case movies
    }
    
    init(totalResults: Int, response: String, error: String, movies: [Movie]) {
        self.totalResults = totalResults
        self.response = response
        self.error = error
        self.movies = movies
    }
    
    init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.totalResults = try values.decodeIfPresent(Int.self, forKey: .totalResults) ?? 0
        self.response = try values.decodeIfPresent(String.self, forKey: .response) ?? &quot;False&quot;
        self.error = try values.decodeIfPresent(String.self, forKey: .error) ?? &quot;&quot;
        self.movies = try values.decodeIfPresent([Movie].self, forKey: .movies) ?? []
    }
}

extension MovieResponse {
    struct Movie: Codable, Identifiable {
        var id = UUID()
        var title: String
        var year: Int8
        var imdbID: String
        var type: String
        var poster: URL
        
        enum EncodingKeys: String, CodingKey {
            case title = &quot;Title&quot;
            case year = &quot;Year&quot;
            case imdmID
            case type = &quot;Type&quot;
            case poster = &quot;Poster&quot;
        }
    }
}
</code></pre>
<p>ViewModel:</p>
<pre><code>final class MovieListViewModel: ObservableObject {

    @Published var isLoading: Bool = false
    @Published var movieObj = MovieResponse(totalResults: 0, response: &quot;False&quot;, error: &quot;&quot;, movies: [])

    var searchTerm: String = &quot;&quot;

    private let searchTappedSubject = PassthroughSubject&lt;Void, Error&gt;()
    private var disposeBag = Set&lt;AnyCancellable&gt;()
    private let service = OMDBService()

    init() {
        searchTappedSubject
        .flatMap {
            self.requestMovies(searchTerm: self.searchTerm)
                .handleEvents(receiveSubscription: { _ in
                    DispatchQueue.main.async {
                        self.isLoading = true
                    }
                },
                receiveCompletion: { comp in
                    DispatchQueue.main.async {
                        self.isLoading = false
                    }
                })
                .eraseToAnyPublisher()
        }
        .replaceError(with: [])
        .receive(on: DispatchQueue.main)
        .assign(to: \.movieObj.movies, on: self)
        .store(in: &amp;disposeBag)
    }

    func onSearchTapped() {
        searchTappedSubject.send(())
    }

    private func requestMovies(searchTerm: String) -&gt; AnyPublisher&lt;[MovieResponse.Movie], Error&gt; {
        guard let url = URL(string:&quot;\(Constants.HostName)/?s=\(searchTerm)&amp;apikey=\(Constants.APIKey)&quot;) else {
            fatalError(&quot;Something is wrong with URL&quot;)
        }
        return URLSession.shared.dataTaskPublisher(for: url)
            .tryMap() { element -&gt; Data in
                    guard let httpResponse = element.response as? HTTPURLResponse,
                        httpResponse.statusCode == 200 else {
                            throw URLError(.badServerResponse)
                        }
                    return element.data
                    }
               .mapError { $0 as Error }
            .decode(type: [MovieResponse.Movie].self, decoder: JSONDecoder())
               .eraseToAnyPublisher()
    }
}
</code></pre>
<p>And finally, the view &amp; search bar</p>
<pre><code>struct SearchView: View {

    @ObservedObject var viewModel = MovieListViewModel()
    
    @State private var searchText = &quot;&quot;
    
    var body: some View {
        ZStack {
            VStack {
                HStack {
                    Text(&quot;Search OMDB&quot;)
                        .font(.system(size: 25, weight: .black, design: .rounded))
                    Spacer()
                }
                .padding()
                Spacer()
                SearchBar(text: $viewModel.searchTerm,
                            onSearchButtonClicked: viewModel.onSearchTapped)
                List(viewModel.movieObj.movies) { movie in
                    Text(verbatim: movie.title)
                }
                .onAppear() {
                    print(&quot;Got the new data&quot;)
                }
            }
        }
    }
}

struct SearchBar: UIViewRepresentable {

    @Binding var text: String
    var onSearchButtonClicked: (() -&gt; Void)? = nil

    class Coordinator: NSObject, UISearchBarDelegate {

        let control: SearchBar

        init(_ control: SearchBar) {
            self.control = control
        }

        func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
            control.text = searchText
        }

        func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
            control.onSearchButtonClicked?()
        }
    }

    func makeCoordinator() -&gt; Coordinator {
        return Coordinator(self)
    }

    func makeUIView(context: UIViewRepresentableContext&lt;SearchBar&gt;) -&gt; UISearchBar {
        let searchBar = UISearchBar(frame: .zero)
        searchBar.delegate = context.coordinator
        return searchBar
    }
    func updateUIView(_ uiView: UISearchBar, context: UIViewRepresentableContext&lt;SearchBar&gt;) {
        uiView.text = text
    }
}
</code></pre>
<p>When I run the code, the REST api is returning the data, but I am not able to see the same in <code>Movie</code> array and <code>List</code> is not displaying anything.</p>
<p>EDIT:
Adding the sample json returned by the REST API</p>
<pre class=""lang-json prettyprint-override""><code>{
     &quot;Search&quot;: [
         {
             &quot;Title&quot;: &quot;What We Do in the Shadows&quot;,
             &quot;Year&quot;: &quot;2014&quot;,
             &quot;imdbID&quot;: &quot;tt3416742&quot;,
             &quot;Type&quot;: &quot;movie&quot;,
             &quot;Poster&quot;: &quot;https://m.media-amazon.com/images/M/MV5BMjAwNDA5NzEwM15BMl5BanBnXkFtZTgwMTA1MDUyNDE@._V1_SX300.jpg&quot;
         },
         {
             &quot;Title&quot;: &quot;I Know What You Did Last Summer&quot;,
             &quot;Year&quot;: &quot;1997&quot;,
             &quot;imdbID&quot;: &quot;tt0119345&quot;,
             &quot;Type&quot;: &quot;movie&quot;,
             &quot;Poster&quot;: &quot;https://m.media-amazon.com/images/M/MV5BZDI4ODJlNGUtNjFiMy00ODgzLWIzYjgtMzgyZTljZDQ2NGZiXkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg&quot;
         }
     ],
     &quot;totalResults&quot;: &quot;4365&quot;,
     &quot;Response&quot;: &quot;True&quot;
 }
</code></pre>
","2067791","","2067791","","2021-07-01 20:09:34","2021-07-02 00:10:16","Swift - JSONDecoder & Combine framework issue","<swiftui><combine><jsondecoder>","1","4","","","","CC BY-SA 4.0"
"68240150","1","68240945","","2021-07-03 21:41:24","","1","555","<p>Being a Swift newbie I am trying to download and parse a CSV file using the code:</p>
<pre><code>URLSession.shared.dataTaskPublisher(for: url)
    .tryMap(handleOutput)
    .sink { completion in
    } receiveValue: { csvWords in

        let lines = csvWords.split(separator: &quot;\n&quot;)
        for line in lines {
            let columns = line.split(separator: &quot;,&quot;)
            for column in columns {
                print(&quot;column: \(column)&quot;)
            }
        }
</code></pre>
<p>however I get the syntax error:</p>
<blockquote>
<p>Cannot convert value of type 'String' to expected argument type 'Data.Element' (aka 'UInt8')</p>
</blockquote>
<p><a href=""https://i.stack.imgur.com/mAZKB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mAZKB.png"" alt=""Xcode"" /></a></p>
<p>Please help me to understand, what is happening.</p>
<p>What value is returned by the <a href=""https://developer.apple.com/documentation/combine/fail/sink(receivevalue:)"" rel=""nofollow noreferrer"">receiveValue</a>, isn't it the remote file content as string?</p>
<p><strong>UPDATE:</strong></p>
<p>Here is the missing method</p>
<pre><code>func handleOutput(output: URLSession.DataTaskPublisher.Output) throws -&gt; Data {
    guard
        // as? means &quot;this might be nil&quot;
        let response = output.response as? HTTPURLResponse,
        response.statusCode &gt;= 200,
        response.statusCode &lt; 300
        else {
            throw URLError(.badServerResponse)
        }
    
    return output.data
}
</code></pre>
","165071","","165071","","2021-07-04 07:14:01","2021-07-04 16:21:58","URLSession.shared.dataTaskPublisher - how to convert received value to string?","<ios><swift><string><csv><combine>","1","7","","","","CC BY-SA 4.0"
"68292296","1","","","2021-07-07 19:54:45","","1","122","<p>I have a setup where a user can tap a button to start a series of multiple network requests via a flatMap.  I'd like to allow the user to cancel the network requests by tapping another button.  Calling cancel on the cancellables saved doesn't cancel the requests.  I have this class:</p>
<pre><code>class ImageService : ObservableObject, UrlBuildable {
    @Published var currentImage: DownloadImageEvent?
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    private var isCancelled: Bool = false
    
    func downloadImage(at: URL) -&gt; AnyPublisher&lt;UIImage, URLError&gt; {
        return URLSession.shared.dataTaskPublisher(for: at)
                .compactMap { UIImage(data: $0.data) }
                .receive(on: RunLoop.main)
                .eraseToAnyPublisher()
    }
    
    func cancel() {
        currentImage = nil
        cancellables.removeAll()
        self.isCancelled = true
        print(&quot;\(#function) isCancelled: \(isCancelled)&quot;)
    }
    
    typealias DownloadImageEventResult = Result&lt;DownloadImageEvent, URLError&gt;
    typealias DownloadImageEventResultPublisher = AnyPublisher&lt;DownloadImageEventResult, Never&gt;
    
    func downloadAllImages() -&gt;  DownloadImageEventResultPublisher {
        let urls = buildImagesUrls().compactMap{ URL(string: $0) }
        let pub: AnyPublisher&lt;URL, Never&gt; = urls.publisher.eraseToAnyPublisher()
        var index: Int = 0
        let delay: Int = 2
        
        return pub.flatMap(maxPublishers: .max(1)) { [isCancelled] url -&gt; DownloadImageEventResultPublisher in
            print(&quot;\(#function) \(url)&quot;)
            index += 1
            
            // download &amp; create event
            print(&quot;\(#function) isCancelled: \(isCancelled)&quot;)
            
            if (isCancelled) {
                let res = Result&lt;DownloadImageEvent, URLError&gt;.failure(URLError(URLError.Code(rawValue: 404)))
                
                return Just(res).eraseToAnyPublisher()
            } else {
                return self.downloadImage(at: url)
                    .print()
                    .map{ _ in DownloadImageEvent(
                            index: index,
                            total: urls.count,
                            url: url.absoluteString) }
                    .delay(for: RunLoop.SchedulerTimeType.Stride(TimeInterval(delay)),
                           scheduler: RunLoop.main)
                    .convertToResult()
                    .eraseToAnyPublisher()
            }
        }.eraseToAnyPublisher()
    }
}
</code></pre>
<p>I can see that when <code>cancel()</code> is called, <code>isCancelled</code> is updated but the <code>flatMap</code> sees the old value of <code>isCancelled</code> because it captured it initially.  So this approach isn't going to work.  I thought of using a private subject and have the <code>cancel()</code> send an event to the private subject but how do I get the <code>flatMap</code> to cancel in response to events sourced by the private subject?</p>
","6902806","","","","","2021-07-12 10:45:12","How to cancel a flatMap publisher from a user event","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"68308431","1","","","2021-07-08 20:44:19","","2","102","<p>What is the best practice or technique to keep a @Published property normalized? Supposed that we have a ViewModel which expose a @Published text property, which can be updated from the ViewModel / TextField (SwiftUI) and we want to remove any link that the user input in the field.</p>
<p>I wrote this example with test, but one of my issue is that on the subscription from the test, I'm receiving values in the wrong order (it sounds that mutating the text in the handleEvents is not so right)</p>
<pre><code>class ViewModel: ObservableObject {
    @Published var text: String?
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        setupObservers()
    }

    private func setupObservers() {
        $text
            .removeDuplicates() // use removeDuplicates to avoid infinite loop
            .compactMap({ $0 })
            .handleEvents(receiveOutput: { [weak self] in self?.cleanupLinks(from: $0) })
            .sink(receiveValue: { _ in })
            .store(in: &amp;cancellables)
    }

    private func cleanupLinks(from text: String) {
        //dummy implementation
        self.text = text.replacingOccurrences(of: &quot;https://any-url.com&quot;, with: &quot;&quot;)
    }
}

// TEST
class SimpleReproTests: XCTestCase {
    func test_text_cleanupLinks() {
        let sut = ViewModel()

        let exp = expectation(description: &quot;Wait for text updates&quot;)
        exp.expectedFulfillmentCount = 2
        var receivedValues = [String?]()
        let cancellable = sut.$text.dropFirst(2).sink {
            receivedValues.append($0)
            exp.fulfill()
        }
    
        sut.text = &quot;Hello World! https://any-url.com&quot;
        wait(for: [exp], timeout: 1.0)

        XCTAssertEqual(receivedValues, [&quot;Hello World! https://any-url.com&quot;, &quot;Hello World! &quot;])
        cancellable.cancel()
   }
}
</code></pre>
<p>Right now, when running the test I'm receiving the values out of order (which ofc doesn't match the expectation):</p>
<pre><code>[&quot;Hello World! &quot;, &quot;Hello World! https://any-url.com&quot;]
</code></pre>
","6909275","","","","","2021-07-09 19:12:53","How to keep a @Published property normalized in a two-way binding ViewModel/TextField (i.e keeping in lowercase, remove links, etc)?","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68319145","1","","","2021-07-09 15:18:58","","0","300","<p>I have <a href=""https://github.com/afarber/ios-questions/tree/master/Tops1"" rel=""nofollow noreferrer"">a small project at Github</a> which downloads <a href=""https://slova.de/ws/top"" rel=""nofollow noreferrer"">a JSON list of objects</a>, parses it and stores in Core Data:</p>
<p><a href=""https://i.stack.imgur.com/ycRem.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ycRem.png"" alt=""screenshot"" /></a></p>
<p>In the <a href=""https://github.com/afarber/ios-questions/blob/master/Tops1/Tops1/ViewModels/TopViewModel.swift"" rel=""nofollow noreferrer"">view model</a> I just iterate through the JSON list, create Core Data entities and then save the context:</p>
<pre><code>URLSession.shared.dataTaskPublisher(for: url)
    .tryMap(handleOutput)
    .decode(type: TopResponse.self, decoder: JSONDecoder())
    .sink { completion in
        print(&quot;fetchTopModels completion=\(completion)&quot;)
    } receiveValue: { fetchedTops in
        PersistenceController.shared.container.performBackgroundTask { backgroundContext in
            backgroundContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
            backgroundContext.automaticallyMergesChangesFromParent = true
            backgroundContext.perform {
                for topModel in fetchedTops.data {
                    let topEntity = TopEntity(context: backgroundContext)
                    topEntity.language = language
                    topEntity.uid = Int32(topModel.id)
                    // etc.
                }
                if (backgroundContext.hasChanges) {
                    do {
                        try backgroundContext.save()
</code></pre>
<p>This works well, but is very slow when I have a list with 100000 objects.</p>
<p>So I have decided to create <a href=""https://github.com/afarber/ios-questions/tree/master/TopsBatchInsert"" rel=""nofollow noreferrer"">another small project at Github</a>, which uses <a href=""https://developer.apple.com/documentation/coredata/nsbatchinsertrequest"" rel=""nofollow noreferrer"">NSBatchInsertRequest</a>.</p>
<p>And being a Swift newbie I already fail at the very first step :-)</p>
<p>I was thinking of casting the <a href=""https://github.com/afarber/ios-questions/blob/master/TopsBatchInsert/TopsBatchInsert/Models/TopModel.swift"" rel=""nofollow noreferrer"">TopResponse.data</a> to <code>[[String:Any]]</code></p>
<pre><code>struct TopResponse: Codable {
    let data: [TopModel]
}

struct TopModel: Codable, Identifiable {
    var id: Int { uid }
    let uid: Int
    // etc.
}
</code></pre>
<p>So in <a href=""https://github.com/afarber/ios-questions/blob/master/TopsBatchInsert/TopsBatchInsert/ViewModels/TopViewModel.swift"" rel=""nofollow noreferrer"">the new view model</a> I have tried the code:</p>
<pre><code>URLSession.shared.dataTaskPublisher(for: url)
    .tryMap(handleOutput)
    .decode(type: TopResponse.self, decoder: JSONDecoder())
    .sink { completion in
        print(&quot;fetchTopModels completion=\(completion)&quot;)
    } receiveValue: { topResponse in
        guard let fetchedTops = topResponse.data as? [[String: Any]] else { return }
        PersistenceController.shared.container.performBackgroundTask { backgroundContext in
            backgroundContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
            backgroundContext.automaticallyMergesChangesFromParent = true
            backgroundContext.perform {
                
                let batchInsert = NSBatchInsertRequest(entity: TopEntity.entity(), objects: fetchedTops)

                do {
                    try backgroundContext.execute(batchInsert)
</code></pre>
<p>but the casting fails and I see in debugger that <code>fetchedTops</code> has zero elements:</p>
<p><a href=""https://i.stack.imgur.com/vxjC1.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vxjC1.jpg"" alt=""Xcode screenshot"" /></a></p>
<p>Why is it happening? I was expecting the JSON list of objects to be casted perfectly to a <code>[[String:Any]]</code></p>
","165071","","165071","","2021-07-09 19:41:15","2021-07-09 19:41:15","Casting JSON list of objects for NSBatchInsertRequest to [[String:Any]] fails","<ios><swift><core-data><combine><batch-insert>","0","4","","","","CC BY-SA 4.0"
"68323705","1","","","2021-07-10 00:07:51","","0","443","<p>I am working with Swift Combine in a SwiftUI App. I've had success using it until recently. I am attempting to use a ViewModel to set value when using combine but it does not appear to be getting updated. What's odd is I have another ViewModel that is working. I am using Firebase as a database.</p>
<h3>ListingRepository</h3>
<p>This file starts a listener from Firestore and sets an <code>@Published</code> property with a array of listings.</p>
<pre><code>class ListingRepository: ObservableObject {
    let db = Firestore.firestore()
    
    @Published var listings = [Listing]()
    
    init() {
        startSnapshotListener()
    }
    
    func startSnapshotListener() {
        db.collection(FirestoreCollection.listings).addSnapshotListener { (querySnapshot, error) in
            if let error = error {
                print(&quot;Error getting documents: \(error)&quot;)
            } else {
                guard let documents = querySnapshot?.documents else {
                    print(&quot;No Listings.&quot;)
                    return
                }
                
                self.listings = documents.compactMap { listing in
                    do {
                        return try listing.data(as: Listing.self)
                    } catch {
                        print(error)
                    }
                    return nil
                }
            }
        }
    }
}
</code></pre>
<h3>Working ViewModel</h3>
<p>This is the ViewModel that is working. I am using Combine here to map over the listings and create <code>ListRowViewModel</code>s. The code works and I can populate the rows successfully.</p>
<pre><code>class MarketplaceViewModel: ObservableObject {
    @Published var listingRepository = ListingRepository()
    @Published var listingRowViewModels = [ListingRowViewModel]()
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        listingRepository
            .$listings
            .receive(on: RunLoop.main)
            .map { listings in
                listings.map { listing in
                    ListingRowViewModel(listing: listing)
                }
            }
            .assign(to: \.listingRowViewModels, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<h3>ViewModel Not Working</h3>
<p>This ViewModel is for an account view. I started simply by using the count() operator to try and capture the number of listings and then display this on the <code>AccountView</code>. When I build and run the view is not updated.</p>
<pre><code>class AccountViewModel: ObservableObject {
    @Published var listingRepository = ListingRepository()
    
    @Published var numberOfListings: Int = 0
    @
        
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        listingRepository
            .$listings
            .receive(on: RunLoop.main)
            .count()
            .assign(to: \.numberOfListings, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>Upon further inspection it appears the publisher is not being called. I used a sink to try and print the result of the count and nothing gets printed.</p>
<pre><code>class AccountViewModel: ObservableObject {
    @Published var listingRepository = ListingRepository()
    
    @Published var numberOfListings: Int = 0
    @
        
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        listingRepository
            .$listings
            .receive(on: RunLoop.main)
            .count()
            .sink {
                print(&quot;Number Of Listings: \($0)&quot;)
            }
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p><code>MarketplaceViewModel</code> and <code>AccountViewModel</code> are used in <code>MarketplaceView</code> and AccountView`.</p>
<h3>MarketplaceView</h3>
<pre><code>struct MarketplaceView: View {
    
    @ObservedObject var marketplaceViewModel = MarketplaceViewModel()
    
    
    var body: some View {
        
        Text(marketPlaceViewModel.listingRowViewModels[1].listing.name)
    }
}
</code></pre>
<h3>AccountView</h3>
<pre><code>struct AccountView: View {
    
    @ObservedObject var accountViewModel = AccountViewModel()
        
    var body: some View {
        Text(String(accountViewModel.numberOfListings)                     }
    }
}
</code></pre>
<p>These two views are presented in <code>ContentView</code></p>
<pre><code>struct ContentView: View {
    
    var body: some View {
        Group{
           
                TabView {
                    MarketplaceView()
                        .tabItem {
                            Image(systemName: &quot;shippingbox&quot;)
                            Text(&quot;Marketplace&quot;)
                        }.tag(0) // MarketplaceView
                    AccountView(user: testUser1)
                        .tabItem {
                            Image(systemName: &quot;person&quot;)
                            Text(&quot;Account&quot;)
                        }.tag(1) // AccountView
                } // TabView
                .accentColor(.white)
        }// Group
    }
}
</code></pre>
<p>I'm very puzzled why this is not working. Any help would be greatly appreciated.</p>
","4441627","","3141234","","2021-07-10 02:11:57","2022-08-10 15:58:16","Why Is My Swift Combine Publisher Not Publishing?","<swift><swiftui><combine>","1","18","","","","CC BY-SA 4.0"
"68328451","1","","","2021-07-10 14:07:57","","0","188","<p>Working on API, which uses Combine instead of closures. Fetching a resource with a closure using URLSession task and <code>.resume</code> gives no errors, while fetching with Combine gives:</p>
<pre><code>Connection 57: unable to determine fallback status without a connection
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>struct Item: View {
    @ObservedObject var item: Item
    @State var thumbnail: UIImage?
    
    var body: some View {
        NavigationLink(destination: ItemView(item: item, thumbnail: thumbnail)) {
            ItemRowView(item: item, thumbnail: thumbnail)
        }
        .onAppear {
             let url = URL(string: &quot;valid address&quot;)!
             let cancellable = URLSession.shared.dataTaskPublisher(for: url)
                 .receive(on: DispatchQueue.main)
                 .sink(receiveCompletion: { print (&quot;Received completion: \($0).&quot;) },
                       receiveValue: { print (&quot;Received data: \($0.data).&quot;)})
        }
    }
}
</code></pre>
<p>There's a similar question at <a href=""https://stackoverflow.com/questions/60666297/unable-to-determine-interface-type-without-an-established-connection-xcode"">Unable to determine interface type without an established connection Xcode</a>. However, there shouldn't be any TLS errors in my case as the endpoint has a valid certificate and works okay without Combine.</p>
<p>Could you please interpret the error itself as it's not clear what fallback status is missing and why there's no connection?</p>
","3984522","","3984522","","2021-07-10 21:39:45","2021-07-10 21:39:45","Connection <number>: unable to determine fallback status without a connection","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68337688","1","68338011","","2021-07-11 15:39:25","","0","72","<p>I want to keep track of the size of an array, I thought something like this would work:</p>
<pre><code>class CarListViewModel: ObservableObject {
    private var cancellables = Set&lt;AnyCancellable&gt;()   
    @Published var ownedCarLength = 0

    init(){     

        CarRepository.$ownedCars.sink { _ in
            self.ownedCarLength = CarRepository.ownedCars.count
        }
        .store(in: &amp;cancellables)
    }
</code></pre>
<p>as this is called each time the array <code>CarRepository.ownedCars</code> is modified, however the value returned from CarRepository.ownedCars.count evaluates to 0 for some reason. Is there a cleaner way of doing this?</p>
","10142976","","","","","2021-07-11 16:20:23","How can I subscribe to the size of an array in SwiftUI?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68351279","1","68351640","","2021-07-12 16:59:03","","-1","148","<p>In <a href=""https://github.com/afarber/ios-questions/blob/master/TopsBatchInsert/TopsBatchInsert/ViewModels/TopViewModel.swift"" rel=""nofollow noreferrer"">a simple test project at Github</a> I am downloading JSON file, parse it into <code>[[String:Any]]</code> and then would like to pass the data structure to Core Data's <code>NSBatchInsertRequest</code>:</p>
<pre><code>func fetchTopModels(language:String) {
    guard let url = urls[language] as? URL else { return }
    
    URLSession.shared.dataTaskPublisher(for: url)
        .tryMap(handleOutput)
        .tryMap { jsonData -&gt; [[String: Any]] in
            let json = try? JSONSerialization.jsonObject(with: jsonData, options: [])
            guard let jsonDict = json as? [String:Any],
                  let dataList = jsonDict[&quot;data&quot;] as? [[String:Any]]
                else { throw URLError(.badServerResponse) }
                return dataList
        }
        // TODO How to set language on each dataList member?
        //.map {
              //$0.language = language
        //}
        .sink { completion in
            print(&quot;fetchTopModels completion=\(completion)&quot;)
        } receiveValue: { fetchedTops in
            PersistenceController.shared.container.performBackgroundTask { backgroundContext in
                backgroundContext.mergePolicy = NSMergePolicy.mergeByPropertyObjectTrump
                backgroundContext.automaticallyMergesChangesFromParent = true
                backgroundContext.perform {
                    
                    let batchInsert = NSBatchInsertRequest(entity: TopEntity.entity(), objects: fetchedTops)
</code></pre>
<p>However the <code>[[String:Any]]</code> data structure is missing the <code>language</code> String property on each of its members. It is mandatory on the Core Data entity.</p>
<p>My question is how to iterate through the array and set the <code>language</code> on each member (for example to the value of <code>&quot;en&quot;</code>)?</p>
<p>I have searched, but it is difficult to find a good pointer because the search keywords are too common :-)</p>
","165071","","","","","2021-07-12 20:05:02","With Combine how to iterate through an array of dictionaries and set 1 additional property?","<ios><swift><dictionary><combine>","1","0","1","","","CC BY-SA 4.0"
"68381565","1","68381799","","2021-07-14 16:09:18","","2","860","<p>I am writing a SwiftUI app using the MVVM pattern.  I'm running into a situation where I am presenting an app setup screen and prompting the user for a password.  To perform password validation, I have a series of Combine <code>Publisher</code>s in my <code>ViewModel</code> that validate against numerous criteria.  If the password validates successfully, a &quot;Complete Registration&quot; button is enabled in my <code>View</code>, and upon tapping it the account is established.  If an error occurs while creating the account, an <code>Alert</code> is supposed to be displayed.  However, I am finding in my testing that when the alert is displayed it immediately dismisses itself.  Here's what my <code>ViewModel</code> looks like:</p>
<pre><code>struct ApplicationSetupState {
    
}

enum ApplicationSetupInput {
    case completeSetup
}

class ApplicationSetupViewModel: ViewModel {
    
    typealias ViewModelState = ApplicationSetupState
    typealias ViewModelInput = ApplicationSetupInput
    
    enum PasswordValidation {
        case valid
        case empty
        case noMatch
    }
    
    @Published var password: String = &quot;&quot;
    @Published var confirmPassword: String = &quot;&quot;
    @Published var useBiometrics: Bool = false
    
    @Published var isValid: Bool = false
    
    @Published var state: ApplicationSetupState
    @Published var errorMessage: String? = nil
    @Published var error: Bool = false
    
    private var cancellables: [AnyCancellable] = []
    
    private var isPasswordEmptyPublisher: AnyPublisher&lt;Bool, Never&gt; {
        $password
            .debounce(for: 0.8, scheduler: RunLoop.main)
            .removeDuplicates()
            .map { password in
                DDLogVerbose(&quot;Mapping password=\(password)&quot;)
                return password == &quot;&quot;
            }
            .eraseToAnyPublisher()
    }
    
    private var arePasswordsEqualPublisher: AnyPublisher&lt;Bool, Never&gt; {
        Publishers.CombineLatest($password, $confirmPassword)
            .debounce(for: 0.1, scheduler: RunLoop.main)
            .map { password, confirmPassword in
                DDLogVerbose(&quot;Mapping password=\(password), confirmPassword=\(confirmPassword)&quot;)
                return password == confirmPassword
            }
            .eraseToAnyPublisher()
    }
    
    private var isPasswordValidPublisher: AnyPublisher&lt;PasswordValidation, Never&gt; {
        Publishers.CombineLatest(isPasswordEmptyPublisher, arePasswordsEqualPublisher)
            .map { isPasswordEmpty, arePasswordsEqual in
                DDLogVerbose(&quot;Mapping isPasswordEmpty=\(isPasswordEmpty), arePasswordsEqual=\(arePasswordsEqual)&quot;)
                if isPasswordEmpty {
                    return .empty
                } else if !arePasswordsEqual {
                    return .noMatch
                }
                
                return .valid
            }
            .eraseToAnyPublisher()
    }
    
    private var isSetupValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
        isPasswordValidPublisher
            .map { isPasswordValid in
                return isPasswordValid == .valid
            }
            .eraseToAnyPublisher()
    }
    
    init() {
        self.state = ApplicationSetupState()
        
        self.isPasswordValidPublisher
            .receive(on: RunLoop.main)
            .map { passwordValidation in
                DDLogVerbose(&quot;Mapping passwordValidation=\(passwordValidation)&quot;)
                switch passwordValidation {
                case .empty:
                    return &quot;You must provide a master password&quot;
                case .noMatch:
                    return &quot;The passwords do not match.  Try again.&quot;
                default:
                    return &quot;&quot;
                }
            }
            .assign(to: \.errorMessage, on: self)
            .store(in: &amp;cancellables)
        
        self.isSetupValidPublisher
            .receive(on: RunLoop.main)
            .assign(to: \.isValid, on: self)
            .store(in: &amp;cancellables)
    }
    
    func trigger(_ input: ApplicationSetupInput) {
        switch input {
        case .completeSetup:
            self.completeApplicationSetup()
        }
    }
    
    // MARK: - Private methods
    
    private func completeApplicationSetup() {
        DDLogInfo(&quot;Completing application setup...&quot;)
        
        do {
            let status = try ApplicationSetupController.shared.completeApplicationSetup(withPassword: self.password,
                                                                                        useBiometrics: self.useBiometrics)
            DDLogVerbose(&quot;status=\(status)&quot;)
            if status == true {
                DDLogInfo(&quot;Application setup completed successfully.  Posting notification...&quot;)
                NotificationCenter.default.post(name: .didCompleteSetup, object: nil)
            } else {
                DDLogWarn(&quot;Application setup failed with no error message&quot;)
                self.error = true
                self.errorMessage = &quot;An unknown error occurred during setup.  Please try again.&quot;
            }
        } catch {
            DDLogError(&quot;ERROR while completing application setup - \(error)&quot;)
            self.error = true
            self.errorMessage = error.localizedDescription
        }
    }
    
}
</code></pre>
<p>As you can see, I have a <code>@State</code> variable called <code>error</code> that indicates whether or not there is an error situation.  My <code>View</code> looks something like this:</p>
<pre><code>struct MasterPasswordSetupView: View {
    
    @ObservedObject var viewModel: ApplicationSetupViewModel
    
    var body: some View {
        VStack(alignment: .center) {
            ...stuff...
        }
            .alert(isPresented: self.$viewModel.error) {
                Alert(title: Text(&quot;Error&quot;),
                      message: Text(self.viewModel.errorMessage ?? &quot;&quot;),
                      dismissButton: .default(Text(&quot;Ok&quot;)) {
                        DDLogVerbose(&quot;OK pressed!&quot;)
                      })
            }
    }
}
</code></pre>
<p>You'll notice that the <code>Alert</code> is displayed if error is true within my <code>ViewModel</code>.  However, I am seeing that as soon as the <code>Alert</code> is displayed it is immediately dismissed, even though I have not pressed the OK button to dismiss it.</p>
<p>I've added some logging, including a <code>didSet</code> method on <code>error</code>, and see that at some point error is, in fact, toggled back to false.  However, I am not explicitly doing this anywhere within my code, so I'm at a loss as to why it is happening.  Any thoughts?</p>
","331747","","","","","2021-07-14 16:24:28","SwiftUI: Alert dismissing itself automatically (when it shouldn't!)","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68382516","1","68383280","","2021-07-14 17:14:49","","0","234","<p>i am learning swiftui now and I am newbie for stackoverflow, I find a question,this is my code. I want to change the @State nopubName in sink ,but it's not work,the print is always &quot;Nimar&quot;, I don't know why</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
   
    @State var nopubName: String = &quot;Nimar&quot;
    private var cancellable: AnyCancellable?
    
    var stringSubject = PassthroughSubject&lt;String, Never&gt;()

    init() {
        cancellable = stringSubject.sink(receiveValue: handleValue(_:))
    }
    
    func handleValue(_ value: String) {
         print(&quot;handleValue: '\(value)'&quot;)
        self.nopubName = value
        print(&quot;in sink &quot;+nopubName)
     }
    
    var body: some View {
        VStack {
            Text(self.nopubName)
                .font(.title).bold()
                .foregroundColor(.red)
            Spacer()
 
            Button(&quot;sink&quot;){
                stringSubject.send(&quot;World&quot;)
                print(nopubName)

            }
        }
    }
}
</code></pre>
","16372603","","41116","","2021-07-14 18:24:08","2021-07-14 18:29:57","swiftui cannot change @State value in sink","<state><combine><sink>","2","0","","","","CC BY-SA 4.0"
"68395108","1","68396086","","2021-07-15 13:49:26","","0","84","<p>I have a longish list of API endpoints I need to call sequentially in a specific order to keep my app's state in sync with a server. I chose to use a Combine chain to implement this. Each operation calls a function that does some work (reads and writes some Core Data models) and returns the same type, something like: <code>-&gt; AnyPublisher&lt;SyncEvent?, Error&gt;</code></p>
<p>together it looks something like this:</p>
<pre class=""lang-swift prettyprint-override""><code>Timer.publish(every: interval, on: .current, in: .common)
  .receive(on: DispatchQueue.global(qos: .background))
  .flatMap(syncEndpointOne)
  .flatMap(syncEndpointTwo)
  .flatMap(syncEndpointThree)
  .flatMap(syncEndpointFour)
  ...
</code></pre>
<p>After adding more than a few of these functions the Swift compiler and language server just gives up and becomes unresponsive, it will hang forever. Commenting out individual lines verifies there are no issues with each line specifically - just that this is too complicated for the compiler to infer and reason about.</p>
<p>How can I rewrite this or give the compiler more information to fix this?</p>
<p>(xcode 12.5.1 and swift 5.4.2)</p>
","3003156","","","","","2021-07-15 14:51:57","Improving compile time of long combine chain","<swift><xcode><compilation><combine>","1","0","","","","CC BY-SA 4.0"
"68400530","1","","","2021-07-15 20:40:33","","2","1550","<p>When I have a nested ObservedObject, changes in a published property of a nested object do not updated the UI until something happens to the parent object. Is this a feature, a bug (in SwiftUI) or a bug in my code?</p>
<p>Here is a simplified example. Clicking the On/Off button for the parent immediately updates the UI, but clicking the On/Off button for the child does not update until the parent is updated.</p>
<p>I am running Xcode 12.5.1.</p>
<pre><code>import SwiftUI

class NestedObject: NSObject, ObservableObject {
    @Published var flag = false
}
class StateObject: NSObject, ObservableObject {
    @Published var flag = false
    @Published var nestedState = NestedObject()
}

struct ContentView: View {
    @ObservedObject var state = StateObject()
    var body: some View {
        VStack {
            HStack {
                Text(&quot;Parent:&quot;)
                Button(action: {
                    state.flag.toggle()
                }, label: {
                    Text(state.flag ? &quot;On&quot; : &quot;Off&quot;)
                })
            }
            HStack {
                Text(&quot;Child:&quot;)
                Button(action: {
                    state.nestedState.flag.toggle()
                }, label: {
                    Text(state.nestedState.flag ? &quot;On&quot; : &quot;Off&quot;)
                })
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
","1412763","","62576","","2021-07-16 01:56:21","2021-07-17 14:34:27","Changes in nested ObservedObject do not updated the UI","<swiftui><combine>","4","0","1","","","CC BY-SA 4.0"
"68415286","1","68426109","","2021-07-16 21:11:44","","0","231","<p>I'm observing an unexpected behavior regarding CombineLatest, if the inner publishers has <code>subscribe(on:)</code>, the CombineLatest stream is not emitting any value.</p>
<p>Notes:</p>
<ul>
<li>With Zip operator is working</li>
<li>Moving the subscribe(on:) / receive(on:) to the combineLatest stream also work. But in this particular use case, the inner publishers is defining their subscribe/receive
because are (re)used in other places.</li>
<li>Adding subscribe(on:)/receive(on:) to only one of the inner publishers also work, so the problem is just when both have it.</li>
</ul>
<pre><code>    func makePublisher() -&gt; AnyPublisher&lt;Int, Never&gt; {
        Deferred {
            Future { promise in
                DispatchQueue.global(qos: .background).asyncAfter(deadline: .now() + 3) {
                    promise(.success(Int.random(in: 0...3)))
                }
            }
        }
        .subscribe(on: DispatchQueue.global())
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
    }
    
    var cancellables = Set&lt;AnyCancellable&gt;()
    Publishers.CombineLatest(
        makePublisher(),
        makePublisher()
    )
    .sink { completion in
        print(completion)
    } receiveValue: { (a, b) in
        print(a, b)
    }.store(in: &amp;cancellables)
</code></pre>
<p>Is this a combine bug or expected behavior? Do you have any idea of how can be setup this kind of stream where the inners can define its own subscribe scheduler?</p>
","6909275","","6909275","","2021-07-17 21:20:46","2021-07-18 04:50:43","CombineLatest operator is not emitting when inners publishers use subscribe(on:)","<ios><swift><combine><combinelatest>","1","2","","","","CC BY-SA 4.0"
"68427812","1","68427882","","2021-07-18 09:35:41","","2","1275","<p>In my app, I am using the Combine framework to make network requests and it works fine for GET requests. But I am running into this issue with POST requests.</p>
<p>The following code (without Combine) works fine:</p>
<pre><code>let data = [&quot;statusTime&quot;: DateFormatter.iso8601Full.string(from: Date())]
let requestBody = try? JSONSerialization.data(withJSONObject: data, options: [])
let baseURL = &quot;my-api.amazonaws.com&quot;
let endpoint = &quot;/my/endpoint&quot;

var urlComponents = URLComponents()
urlComponents.scheme = &quot;https&quot;
urlComponents.host = baseURL
urlComponents.path = endpoint
let url = urlComponents.url!
var request = URLRequest(url: url)

request.httpMethod = &quot;POST&quot;
request.httpBody = requestBody

request.addValue(authorizationToken, forHTTPHeaderField: &quot;Authorization&quot;)
request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)

let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
    if let error = error {
        print(&quot;error: \(error)&quot;)
        return
    }
    print(&quot;Response: \((response as! HTTPURLResponse).statusCode)&quot;)
}
task.resume()
</code></pre>
<p>I get a 200 response code from the above code.</p>
<p>The same code with Combine:</p>
<pre><code>let data = [&quot;statusTime&quot;: DateFormatter.iso8601Full.string(from: Date())]
let requestBody = try? JSONSerialization.data(withJSONObject: data, options: [])
let baseURL = &quot;my-api.amazonaws.com&quot;
let endpoint = &quot;/my/endpoint&quot;

var urlComponents = URLComponents()
urlComponents.scheme = &quot;https&quot;
urlComponents.host = baseURL
urlComponents.path = endpoint
let url = urlComponents.url!
var request = URLRequest(url: url)

request.httpMethod = &quot;POST&quot;
request.httpBody = requestBody

request.addValue(authorizationToken, forHTTPHeaderField: &quot;Authorization&quot;)
request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)

let cancellable = URLSession.shared
    .dataTaskPublisher(for: request)
    .print()
    .sink(receiveCompletion: {
        if let error = $0.error {
            print(&quot;Failure: \(error)&quot;)
        }
    }, receiveValue: {
        print(&quot;\($0)&quot;)
    })
</code></pre>
<p>Here is the output I receive:</p>
<pre><code>receive subscription: (DataTaskPublisher)
request unlimited
receive cancel
</code></pre>
<p>Seems like the request with the Combine framework is somehow getting cancelled? I used a network tracing app and I can see the first request (without Combine), but not the second request.</p>
<p>I have looked at numerous posts and documentation, but can't see what's wrong with my code. What am I missing? Thanks in advance.</p>
","1121544","","","","","2021-07-18 09:45:09","Swift HTTP POST request with Combine","<swift><post><combine>","1","0","1","","","CC BY-SA 4.0"
"68439147","1","68439497","","2021-07-19 10:42:40","","0","482","<p>If I send to <code>PassthroughSubject&lt;Void, Error&gt;</code>, this process will run once, but if I send it more than once, the process in the flatMap will not run. Why is this?</p>
<pre><code>var testTappedSubject = PassthroughSubject&lt;Void, Error&gt;()

testTappedSubject
    .print(&quot;testTappedSubject&quot;)
    .flatMap({ () -&gt; AnyPublisher&lt;Int, Error&gt; in
        print(&quot;called test&quot;)
        return Fail(error: LoginError.someError(error: .unknown))
                .eraseToAnyPublisher()
    })            
    .sink { error in
        print(&quot;error&quot;, error)
    } receiveValue: { value in
        print(&quot;pressed&quot;, value)
    }
    .store(in: &amp;cancellables)
</code></pre>
","3688956","","1974224","","2021-10-26 05:44:38","2021-10-26 05:44:38","PassthroughSubject + flatMap cannot be called more than once?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"68471814","1","68474358","","2021-07-21 14:55:38","","1","343","<p>I have a child view that is given a binding from the parent view, which controls the app's sidebar menu. When I click the button to toggle showSidebar and open the menu, my vm is re-created because the view is re-rendered? Is there a way to do this without affecting the view model?</p>
<pre><code>struct OnboardingView: View {
    @Environment (\.presentationMode) var presentationMode
    @ObservedObject private var vm: OnboardingViewModel
    @State private var filtering = false
    @Binding var showSidebar: Bool

init(showSidebar: Binding&lt;Bool&gt;) {
    self._showSidebar = showSidebar
    self.vm = OnboardingViewModel()
}
</code></pre>
","2484049","","","","","2021-07-21 17:54:44","SwiftUI Binding to parent view re-renders child view","<mvvm><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68481386","1","68481695","","2021-07-22 08:13:35","","1","299","<p>We started using Combine for Networks calls in our Application. The user is supposed to input a code, and we want to validate that code via a network call, then perform actions based on the result of said network call.</p>
<p>To our understanding, if we had a published string variable and used that to lazily create another publisher in which we made the API call, we'd only make API calls every time the string changed.</p>
<p>However, the more SwiftUI views that listen to the publisher via <code>onReceive</code>, the more API calls get made. Here's a simplified example:</p>
<p><strong>View</strong></p>
<pre><code>struct ContentView: View {

    @ObservedObject var viewModel: ResultBenchmarkViewModel

    @State var one: String = &quot;ONE&quot;
    @State var two: String = &quot;TWO&quot;
    @State var three: String = &quot;THREE&quot;

    var body: some View {
        VStack {
        
            TextField(&quot;INPUT&quot;, text: $viewModel.inputString)
        
            Text(one)
                .onReceive(viewModel.inputStringPublisher, perform: { string in
                    one = string
                })
        
            Text(two)
                .onReceive(viewModel.inputStringPublisher, perform: { string in
                    two = string
                })
        
            Text(three)
                .onReceive(viewModel.inputStringPublisher, perform: { string in
                    three = string
                })
        }
    }
}
</code></pre>
<p><strong>ViewModel</strong></p>
<pre><code>class ResultBenchmarkViewModel: Identifiable, ObservableObject {

    @Published var inputString: String = &quot;&quot;

    lazy var inputStringPublisher: AnyPublisher&lt;String, Never&gt; = {
    
        return $inputString
            .map { string in
                print(&quot;API CALL&quot;)
                return string
            }
            .eraseToAnyPublisher()
    }()
}
</code></pre>
<p>Using <code>onReceive</code> three times also prints &quot;API CALL&quot; three times every time the user inputs a character. What we expected to happen was that &quot;API CALL&quot; would only be printed once, since <code>inputString</code> only changes once, and then the three views that use <code>onReceive</code> would only receive the final result published by the publisher.</p>
<p>A solution we're now implementing is listening to the inputString, making the api call and saving the result to a local published variable, which the views then update according to. However, that seems like boilerplate to me that could be obsolete if we properly implemented the original request.</p>
<p>Could we achieve our expected result with some minor changes to the implementation? Or is there a fundamental misunderstanding of combine/swiftui here?</p>
","4442731","","","","","2021-07-22 08:36:45","Multiple onReceive usages lead to duplicated API calls","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"68483865","1","68484941","","2021-07-22 11:16:23","","3","1229","<p>I have a SwiftUI Form with a backing ViewModel. I wish to enable a Save button when the ViewModel changed. I have the following code:</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObservableObject {
    @Published var didUpdate = false
    @Published var name = &quot;Qui-Gon Jinn&quot;
    @Published var color = &quot;green&quot;
    private var cancellables: [AnyCancellable] = []

    init() {
        self.name.publisher.combineLatest(self.color.publisher)
            .sink { _ in
                NSLog(&quot;Here&quot;)
                self.didUpdate = true
            }
            .store(in: &amp;self.cancellables)
    }
}

struct ContentView: View {
    @ObservedObject var viewModel = ViewModel()

    var body: some View {
        NavigationView {
            Form {
                Toggle(isOn: self.$viewModel.didUpdate) {
                    Text(&quot;Did update:&quot;)
                }
                TextField(&quot;Enter name&quot;, text: self.$viewModel.name)
                TextField(&quot;Lightsaber color&quot;, text: self.$viewModel.color)
            }
            .textFieldStyle(RoundedBorderTextFieldStyle())
            .navigationBarItems(
                trailing:
                Button(&quot;Save&quot;) { NSLog(&quot;Saving!&quot;) }
                    .disabled(!self.viewModel.didUpdate)
            )
        }
    }
}
</code></pre>
<p>There are two problems with this code.</p>
<p>First problem is that upon instantiation of the ViewModel, the log will show &quot;Here&quot;, and thus set <code>didUpdate</code> to true. The second problem is that when the user changes the viewmodel via the textfields, it doesn't actually fire the publishers.</p>
<p>How should these problems be fixed?</p>
<p>(I've thought of adding <code>didSet{}</code> to each property in the ViewModel but that is very ugly when there are lots of properties. I've also thought of adding modifiers to the textfields, but I really prefer putting this code in the ViewModel, because a network update could also change the ViewModel).</p>
","1085556","","1085556","","2021-07-22 12:24:15","2021-12-15 17:57:36","SwiftUI Combine observing updates","<swiftui><combine>","2","0","0","","","CC BY-SA 4.0"
"68493146","1","","","2021-07-23 01:50:38","","1","1743","<p>I'm working on a SwiftUI app using the MVVM architecture. I have the problem that I need to pass data from a parent View into its child viewModel, but I'm not sure how to pass a parameter from the view into the viewModel.</p>
<p>The child View which should own the viewModel is here:</p>
<pre><code>struct InstanceView: View {
    @ObservedObject var instance: Instance
    
    @StateObject var viewModel = InstanceViewViewModel(instance: instance)

    var body: some View {
        ...
    }
}
</code></pre>
<p>And this is the viewModel:</p>
<pre><code>class InstanceViewViewModel: ObservableObject {
    @ObservedObject var instance: Instance
    
    ...
}
</code></pre>
<p>Obviously the View doesn't work, I get the error <code>Cannot use instance member 'instance' within property initializer; property initializers run before 'self' is available</code></p>
<p>If I try using <code>init()</code> in the View to assign a value to <code>viewModel</code>:</p>
<pre><code>@ObservedObject var instance: Instance

@StateObject var viewModel: InstanceViewViewModel

init(instance: Instance) {
    self.instance = instance
    self.viewModel = InstanceViewViewModel(instance: instance)
}
</code></pre>
<p>But I get the error <code>Cannot assign to property: 'viewModel' is a get-only property</code>.</p>
<p>I have read that you should give the viewModel property (<code>instance</code>) a default value, and then set it in the View with <code>.onAppear()</code>. However, in my case, <code>Instance</code> is a Core Data object so I can't really create one to use as a default value.</p>
<p>I also read that I could maybe use <code>_instance = StateObject(wrappedValue: InstanceViewViewModel(instance: instance))</code> in the View's init, and swiftUI would be smart enough to only initialize the <code>StateObject</code> once. However I'm pretty sure this is a bad practice.</p>
<p>I also can't use <code>lazy</code> on a <code>StateObject</code></p>
<p>So is there any other way to achieve this? Could a solution be somehow getting the value InstanceView is being initialized with on this line:</p>
<pre><code>@StateObject var viewModel = InstanceViewViewModel(instance: instance)
</code></pre>
<p>, outside of an init, so I don't need to reference self, like you would do inside of an init? (this is probably a stupid idea)</p>
<p>Or should I be implementing MVVM in a different way?</p>
<p>Thanks!</p>
","15929200","","","","","2022-05-16 22:36:51","How to initialize StateObject within SwiftUI with parameter","<swift><mvvm><swiftui><combine><observableobject>","2","15","","","","CC BY-SA 4.0"
"68519595","1","","","2021-07-25 14:34:03","","0","141","<p>I'm trying to map a future I've received from one class to the new future with new output and failure. I've come up with a solution very similar to one proposed here: <a href=""https://stackoverflow.com/questions/60699070/mapping-swift-combine-future-to-another-future"">Mapping Swift Combine Future to another Future</a>.</p>
<pre><code>/// Extension to Combine's Future type
extension Future {
    /// Maps future result to new types
    ///
    /// - Parameters:
    ///     - _ transformOutput - transforms successful output from source Future to new output
    ///     - _ transformFailure - transforms failure from source Future to new failure
    ///
    /// - Returns: Future with new output and failure types
    func map&lt;NewOutput, NewFailure: Error&gt;(
        _ transformOutput: @escaping  (Output) -&gt; Result&lt;NewOutput, NewFailure&gt;,
        _ transformFailure: @escaping (Failure) -&gt; NewFailure) -&gt; Future&lt;NewOutput, NewFailure&gt; {
        var cancellable: AnyCancellable?
        return Future&lt;NewOutput, NewFailure&gt; { promise in
            cancellable = self.sink(receiveCompletion: { completion in
                if case .failure(let error) = completion {
                    promise(.failure(transformFailure(error)))
                }
            }, receiveValue: { value in
                promise(transformOutput(value))
            })
        }
    }
}
</code></pre>
<p>The problem, I have is with <code>cancellable</code> which is destroyed when the program exits the <code>map</code> function. What would be the best solution to extend the lifespan of this variable? The only solution I've come up with is to return to <code>AnyCancellable</code> object along with the newly created future but it leads to problems with where to store it and when to delete it. Maybe someone here had similar problems and come up with some brilliant solution :D</p>
","8990434","","","","","2021-07-25 14:34:03","Mapping combine's Future to new output and failure","<swift><combine>","0","4","","","","CC BY-SA 4.0"
"68527466","1","","","2021-07-26 09:26:10","","1","379","<p>Given the code below from a class:</p>
<pre><code>cancellable = input
    .receive(on: scheduler)
    .map { ... }
    .sink(receiveValue: { value in
        self.state = value
    })

</code></pre>
<p>where <code>input</code> is a PassthroughSubject.</p>
<p>Now, when <code>scheduler</code> is the main queue or the RunLoop.main AND input will be called from the main thread, does <code>receive(on: scheduler)</code> programmatically optimise away an explicit dispatch to the main queue?</p>
<p>So, basically something like this:</p>
<pre><code> if Thread.isMainThread { 
    /* execute closure */
 } else { 
    /* dispatch closure async to main */
 }

</code></pre>
<p>The documentation for <code>receive(on:)</code> gives a vague hint, that it might perform some optimisations:</p>
<p>&quot;Prefer receive(on:options:) over explicit use of dispatch queues&quot;</p>
<pre><code>pub.sink {
    DispatchQueue.main.async {
        // Do something.
    }
}
</code></pre>
","465677","","","","","2021-07-26 15:16:52","Behavior for receive(on:) for DispatchQueue.main","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"68552349","1","","","2021-07-27 22:19:03","","0","475","<p>Below is my code to draw a SwiftUI view that use a publisher to get its items that need drawing in a list. The items all have boolean values drawn with a <code>Toggle</code>.</p>
<p>My view is dumb so I can use any type of boolean value, perhaps UserDefaults backed, core data backed, or simply a boolean property somewhere... anyway, this doesn't redraw when updating a bool outside of the view when one of the booleans is updated.
The <code>onReceive</code> is called and I can see the output change in my console, but binding isn't a part of my struct of <code>ToggleItem</code> and so SwiftUI doesn't redraw.</p>
<p>My code...</p>
<p>I have a struct that looks like this, note the binding type here...</p>
<pre><code>struct ToggleItem: Identifiable, Equatable {
    let id: String
    let name: String
    let isOn: Binding&lt;Bool&gt;

    public static func == (lhs: ToggleItem, rhs: ToggleItem) -&gt; Bool {
        lhs.id == rhs.id
    }
}
</code></pre>
<p>And in my SwiftUI I have this...</p>
<pre><code>struct MyView: View {
    @State private var items: [ToggleItem] = []
    
    let itemsPublisher: AnyPublisher&lt;[ToggleItem], Never&gt;

    // ...

    var body: some View {
        List {

        // ...
        
        }
        .onReceive(itemsPublisher) { newItems in
            print(&quot;New items: \(newItems)&quot;)
            items.removeAll() // hacky redraw
            items = newItems
       }
}
</code></pre>
<p>I can see what's going on here, as <code>Binding&lt;Bool&gt;</code> isn't a value, so SwiftUI sees the array of <code>newItems</code> equal to the <code>items</code> it's already drawn, as a result, this doesn't redraw.</p>
<p>Is there something I'm missing, perhaps some ingenious bit of SwiftUI/Combine that redraws this for me?</p>
","1735584","","","","","2021-07-28 09:19:11","SwiftUI - @State property struct with binding doesn't cause redraw","<swiftui><combine><publisher>","2","4","","","","CC BY-SA 4.0"
"68554581","1","68555014","","2021-07-28 04:54:18","","0","543","<p>I'm trying to implement an async call to a function loadUserFromFirebase and populate and return an array based on user attributes that I then use to write to a firebase collection.</p>
<p>I'm trying to use the Combine framework from Swift using future and promises but for some reason, the receiveCompletion and receiveValue don't get called and thus I get an empty array from my async function call.</p>
<p>Here is my code:</p>
<pre><code>var cancellable = Set&lt;AnyCancellable&gt;()
    func loadUserFromFirebase(groupUserIds: [String], handler: @escaping ([groupMate]) -&gt; Void) {
        
        var groupmateID = 0
        var groupMates : [groupMate] = []
        print(&quot;groupUserIds: \(groupUserIds)&quot; )
        
        for groupUserUID in groupUserIds {
            print(&quot;groupUserUID: \(groupUserUID)&quot; )
            
            let future = Future&lt;groupMate, Never&gt; { promise in
                self.ref.collection(&quot;Users&quot;).document(groupUserUID).getDocument(){
                    
                    (friendDocument, err) in
                
                    if let err = err {
                            print(&quot;Error getting documents \(err)&quot;)
                    } else {
                      //  print(&quot;friendDocument: \(String(describing: friendDocument?.data()))&quot; )

                        let groupUsername = (friendDocument?.data()?[&quot;username&quot;]) as! String
                        let groupUID = (friendDocument?.data()?[&quot;uid&quot;]) as! String
                        let groupName = (friendDocument?.data()?[&quot;name&quot;]) as! String
                        let groupPic = (friendDocument?.data()?[&quot;imageurl&quot;]) as! String

                        promise(.success(groupMate(id: groupmateID, uid: groupUID , name: groupName , username: groupUsername, pic: groupPic)))
                    }
                    
                    groupmateID += 1
                }
            }
            print(&quot;in receiveCompletion&quot;)

            future.sink(receiveCompletion: { completion in
                print(&quot;in receiveCompletion&quot;)
                print(1, completion)
                switch completion {
                    case .failure(let error):
                        print(3, error)
                        handler([])
                        return
                    case .finished:
                        break
                }
            },
            receiveValue: {
                print(&quot;in receiveValue&quot;)
                groupMates.append($0)
                print(groupMates)
                handler(groupMates)
            }).store(in: &amp;cancellable)
        }
    }
    
    
    func creategroup(groupName: String){
        addedTogroupUsers.append(self.uid)
        
        print(&quot;here111&quot;)
        loadUserFromFirebase(groupUserIds: addedTogroupUsers) { groupMates in
            print(&quot;here222&quot;)

            let groupData: [String: Any] = [
                &quot;groupName&quot;: &quot;\(groupName)&quot;,
                &quot;groupmates&quot;: groupMates
            ]
            print(&quot;here333 \(groupData)&quot;)

            print(&quot;groupMates are \(self.groupMates)&quot;)
            
            
            var groupref: DocumentReference? = nil
                groupref = self.ref.collection(&quot;groups&quot;).addDocument(data: groupData) { err in
                if let err = err {
                    print(&quot;Error adding document: \(err)&quot;)
                } else {
                    print(&quot;Document added with ID: \(groupref!.documentID)&quot;)
                    for addedgroupUser in self.addedTogroupUsers {
                        self.ref.collection(&quot;Users&quot;).document(addedgroupUser).updateData([
                                &quot;groups&quot;: FieldValue.arrayUnion([groupref!.documentID])
                            ])
                    }
                }
            }
                print(&quot;groupName is \(groupName) and addedTogroup are \(self.addedTogroupUsers)&quot;)
        }
    }
</code></pre>
<p>I'm trying to see if AnyCancellable is the way to go but since I'm using a chained array of future promises, I'm not sure how to implement it. Please let me know how you'd solve this problem so that the array does get populated since the documents do exist and the print inside the method call work but the groupMates array in the createGroup function prints an empty array afterwards. Thanks!</p>
<p>Edit: Added AnyCancallable to Code along with completion handler as suggested</p>
","13111023","","13111023","","2021-07-28 07:03:57","2021-07-28 08:31:40","Async Future Promise not working in Swift 5","<swift><firebase><asynchronous><combine>","1","0","","","","CC BY-SA 4.0"
"68560348","1","","","2021-07-28 12:24:25","","1","345","<p>I am using <code>Combine</code> to fetch matches as the user types in the search field. It works great in terms of debouncing, deduplicating, and fetching the data. But I am unable to animate the entry of the items. When the matches arrive, the <code>ObservedObject</code> is updated in an instant and the UI is already showing the matches. I would prefer to animate the entry of the matches instead.</p>
<p>I think the problem is that the matches are set in the <code>assign</code> method, which lacks <code>withAnimation</code>. Is it possible to somehow add animation in a <code>Combine</code> pipeline? Should I use side effects for that instead?</p>
<p>Here is the code:</p>
<pre><code>class DictionarySearchViewModel: ObservableObject {        
        @Published var translationMatches = [TranslationMatch]()
        @Published var text: String = &quot;&quot;
        @Published var isLoading = true
        @Published var connectionError = false
        
        private var cancellable: AnyCancellable? = nil
        
        init() {
            cancellable = $text
                .debounce(for: .seconds(0.1), scheduler: DispatchQueue.main)
                .removeDuplicates()
                .map { [self] queryText -&gt; AnyPublisher&lt;[TranslationMatch], Never&gt; in
                    
                    if queryText.count &lt; 2 {
                        return Future&lt;[TranslationMatch], Never&gt; { promise in
                            promise(.success([TranslationMatch]()))
                        }
                        .eraseToAnyPublisher()
                    } else {
                            
                            return DictionaryService.sharedInstance()
                                .searchMatchesPublisher(queryText)
                                .retry(3)
                                .replaceError(with: [TranslationMatch]())
                                .eraseToAnyPublisher()
                        } else {
                            return Future&lt;[TranslationMatch], Never&gt; { promise in
                                promise(.success([TranslationMatch]()))
                            }
                            .eraseToAnyPublisher()
                        }
                    }
                }
                .switchToLatest()
                .eraseToAnyPublisher()
                .receive(on: DispatchQueue.main)
                .assign(to: \.translationMatches, on: self)
        }
}


struct DictionarySearchView: View {
    @ObservedObject var viewModel: DictionarySearchViewModel

    var body: some View {
        ScrollView(.vertical, showsIndicators: false) {
            VStack(alignment: .leading, spacing: 15) {
                ForEach(viewModel.translationMatches, id: \.id) { translationMatch in
                     Text(translationMatch.label)
                }
            }
        }
    }
}
</code></pre>
","659389","","","","","2021-07-28 13:43:09","SwiftUI + Combine: how to assign data to a model with animation","<ios><swift><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"68565266","1","68566047","","2021-07-28 17:56:13","","2","879","<p>Is there a way to mock the viewmodels of an application that uses SwiftUI and Combine? I always find articles about mocking services used by the viewmodel but never mocking a viewmodel itself.</p>
<p>I tried to create protocols for each viewmodel. Problem: the @Published wrapper cannot be used in protocols. It seems like there are no solutions...</p>
<p>Thanks for your help</p>
","8144073","","","","","2021-07-28 19:01:17","Mocking view model in swiftui with combine","<swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"68567716","1","68567824","","2021-07-28 21:46:59","","0","68","<p>I created a custom view, NetworkImage, to load image asynchronously.</p>
<pre><code>import Combine
import SwiftUI

struct NetworkImage&lt;Placeholder: View&gt;: View {
    @StateObject private var viewModel = NetworkImageViewModel()
    let url: String?
    let placeholder: Placeholder
    let saveLocally:Bool
    
    init(_ url: String?, @ViewBuilder placeholder: () -&gt; Placeholder, saveLocally:Bool = false) {
        self.url = url
        self.placeholder = placeholder()
        self.saveLocally = saveLocally
    }
    
    func loadImage(_ url:String?)  {
        if let url = url {
            viewModel.loadImage(from: url, saveLocally: saveLocally)
        }
    }
    
    var body: some View {
        Group {
            if let uiImage = viewModel.image {
                Image(uiImage: uiImage)
                    .resizable()
            } else {
                placeholder
            }
        }
        .onAppear {
            if let url = url {
                viewModel.loadImage(from: url, saveLocally: saveLocally)
            }
        }
    }
}

</code></pre>
<p>I use this in my views and it works really well. But now I would like to be able to replace the image with a new one each time the url change.
How can I do that? How can I pass a @Published property of my view's viewmodel to this NetworkImage view and make it work?</p>
<p>Thanks</p>
","8144073","","","","","2021-07-28 22:02:31","Observe property change in custom view SwiftUI","<view><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68581162","1","68582733","","2021-07-29 18:22:22","","0","236","<p>I'm having difficulty trying to figure out how to loop <code>TMDb</code> results from my publisher 1 and use the value I'm getting from key <code>id</code> for my second publisher. It's not looping through each result, it does get the proper URL inside my <code>func fetchVideos(_ id: Int)</code> but it's not calling each URL from <code>TMDb</code>'s results array. I'm not sure if it's because I'm also getting an Array of results from <code>Videos</code> Codable data?</p>
<p>I attempted to use <code>Publishers.MergeMany</code> in my first publisher's <code>flatMap</code>. I'm still definitely at a novice level for combine, any tips would help. I'm trying to get a list of movies, then from the movies get the <code>id</code> key then use that to fetch the movie trailer data for each movie.</p>
<p>print output</p>
<pre><code>https://api.themoviedb.org/3/movie/602223/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/459151/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/385128/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/522478/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/637693/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/529203/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/578701/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/631843/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/645856/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/581644/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/436969/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/568620/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/522931/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/681260/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/630586/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/671/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/618416/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/646207/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/550988/videos?api_key=API_KEY&amp;language=en-US
https://api.themoviedb.org/3/movie/482373/videos?api_key=API_KEY&amp;language=en-US


Videos(id: 459151, results: [themoviedb_demo.Video(id: 3F24D610-4261-4AEB-8906-A9D0E5FE8E4D, iso639_1: &quot;en&quot;, iso3166_1: &quot;US&quot;, key: &quot;CK6xdYIsaa0&quot;, name: &quot;DreamWorks\' The Boss Baby: Family Business | Official Trailer #3 | Peacock&quot;, site: &quot;YouTube&quot;, size: 1080, type: &quot;Trailer&quot;), themoviedb_demo.Video(id: 417EF49C-B983-4CC3-B435-7A902DECE917, iso639_1: &quot;en&quot;, iso3166_1: &quot;US&quot;, key: &quot;-rF2j6K5FoM&quot;, name: &quot;The Boss Baby 2: Family Business – Official Trailer 2 (Universal Pictures) HD&quot;, site: &quot;YouTube&quot;, size: 1080, type: &quot;Trailer&quot;), themoviedb_demo.Video(id: C34A3F5F-9429-4267-86F0-5506EF3E8281, iso639_1: &quot;en&quot;, iso3166_1: &quot;US&quot;, key: &quot;QPzy8Ckza08&quot;, name: &quot;THE BOSS BABY: FAMILY BUSINESS | Official Trailer&quot;, site: &quot;YouTube&quot;, size: 1080, type: &quot;Trailer&quot;)])
</code></pre>
<p>Codable data</p>
<pre class=""lang-swift prettyprint-override""><code>struct Videos: Codable {
    let id: Int
    let results: [Video]
}

struct Video: Codable {
    let id = Int
    let key: String
    let name: String

    enum CodingKeys: String, CodingKey {
        case id
        case key, name
    }
}


struct TMDb: Codable {
    let results: [Results]?
}

struct Results: Codable {
    let id: Int
    let releaseDate, title: String?
    let name: String?

    enum CodingKeys: String, CodingKey {
        case id
        case releaseDate = &quot;release_date&quot;
        case title
        case name
    }
}

</code></pre>
<pre class=""lang-swift prettyprint-override""><code>@Published var movies = TMDb(results: Array(repeating: Results(id: 1, releaseDate: &quot;&quot;, title: &quot;&quot;, name: &quot;&quot;) , count: 5))
@Published var videos = Videos(id: 1, results: Array(repeating: Video(id: 1, key: &quot;&quot;, name: &quot;&quot;) , count: 5))

func getUpcoming() {
    var request = URLRequest(url:URL(string:&quot;https://api.themoviedb.org/3/movie/upcoming?api_key=API_KEY&amp;language=en-US&amp;page=1&quot;)!)
    request.httpMethod = &quot;GET&quot;
    let publisher = URLSession.shared.dataTaskPublisher(for: request)
        .map{ $0.data }
        .decode(type: TMDb.self, decoder: JSONDecoder())
    let publisher2 = publisher
        .flatMap{
            // loop results from TMDb for id for publisher 2, only one is called
            Publishers.MergeMany($0.results!.map { item in
                return self.fetchVideos(item.id)
                    .map { $0 as Videos }
                    .replaceError(with: nil)
            })
        }
    // Publishers.CombineLatest
    Publishers.Zip(publisher, publisher2)
        .receive(on:  DispatchQueue.main)
        .sink(receiveCompletion: {_ in
        }, receiveValue: { movies, videos in
            self.movies = movies
            self.videos = videos
        }).store(in: &amp;cancellables)
}

func fetchVideos(_ id: Int) -&gt; AnyPublisher&lt;Videos, Error&gt; {
    let url = URL(string: &quot;https://api.themoviedb.org/3/movie/\(id)/videos?api_key=API_KEY&amp;language=en-US&quot;)!
    return URLSession.shared.dataTaskPublisher(for: url)
        .mapError { $0 as Error }
        .map{ $0.data }
        .decode(type: Videos.self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
}
</code></pre>
","14601731","","","","","2021-07-29 21:00:36","Chaining with flatMap","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"68582367","1","68584044","","2021-07-29 20:20:11","","0","440","<p>Can I add a tap publisher to a UIView or UILabel? UIButton has tapPublisher built in. I tried making an extension, but extensions can't store properties.</p>
<p>Also, is it bad practices to try and use a tap publisher on anything that isn't a button?</p>
<pre><code>    func bindViewModel() {
        cancellables = [
            continueButton.tapPublisher.sink { [unowned self] in
                viewModel.action
                    .send(.question)
            },
            headlineLabel.tapPublisher.sink {
                // Error: &quot;Value of type 'UILabel' has no member 'tapPublisher'...&quot;
            })
        ]
    }
</code></pre>
","7431741","","3585796","","2021-08-11 08:51:03","2021-08-11 08:51:03","Apple Combine add TapPublisher to UIView","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"68590136","1","","","2021-07-30 11:22:43","","-1","173","<p>I learn to use Combine and I wrote this code:</p>
<pre class=""lang-swift prettyprint-override""><code>        serviceAgent.podcasts()
            .sink(
                receiveCompletion: { cpl in
                    switch cpl {
                    case .failure(let error):
                        print(error.localizedDescription)
                    case .finished:
                       return
                    }
                },
                receiveValue: { [weak self] (model) in
                    self?.items = model.map({ podcast in
                        let item = PodcastCardItemViewModel(podcast)
                        item.clickPublisher.sink { value in
                            self?.clickPublisher.send(value)
                        }.store(in: &amp;(self!.cancelBag))
                        return item
                    })
                }
            ).store(in: &amp;cancelBag)
</code></pre>
<p>I'm pretty sure it's possible to simplify this code with map, catch and assign but I don't know how.
Any ideas?</p>
<p>Thanks</p>
","8144073","","","","","2021-07-30 11:48:49","Map, catch error and assign with Combine in SwiftUI","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"68601722","1","","","2021-07-31 11:36:49","","0","227","<pre><code>func httpLoginSignal() -&gt;  AnyPublisher&lt;NetResponse&lt;OauthToken&gt;, Error&gt;{
        return API.shared.combine_loadModelResource(GetOauthTokenAPI(ccCode: &quot;86&quot;, phone: &quot;332134&quot;, authType: &quot;password&quot;,password: &quot;123456a&quot;), type: OauthToken.self)

    }

func mqttLoginSignal(accessToken: String) -&gt;  AnyPublisher&lt;NetResponse&lt;MQTTToken&gt;, Error&gt;{
       return API.shared.combine_loadModelResource(GetMQTTTokenAPI(accessToken: accessToken), type: MQTTToken.self)

    }
</code></pre>
<p>When I use it ,it notice Type of expression is ambiguous without more context.</p>
<pre><code> httpLoginSignal().flatMap {
            return mqttLoginSignal(accessToken: $0.data?.access_token!)
        }
</code></pre>
","7260604","","7260604","","2021-07-31 11:49:02","2021-07-31 11:49:02","Swift flatMap Error Type of expression is ambiguous without more context","<swift><combine>","0","3","","","","CC BY-SA 4.0"
"68605557","1","68610203","","2021-07-31 20:16:12","","0","49","<p>I would like to create a module, that will refresh token if needed and repeat latest request using <code>Combine</code> from Apple.</p>
<p>For now, every part is works well, but not this one:</p>
<pre><code>  public func executeRequest&lt;T: Decodable, E: ServerErrorType&gt;(
    _ request: HTTPRequest,
    mapper: ObjectMapper&lt;T, E&gt;
  ) -&gt; AnyPublisher&lt;(T, HTTPResponse), Error&gt; {
        return authentificator // &lt;- handle refresh token stuff
          .refreshToken(force: false)
          .subscribe(on: DispatchQueue.global())
          .flatMap { token in // &lt;- on obtain token - transform it into request

---&gt; (here)
            session.publisher(for: request, mapper: mapper, token: token) // &lt;- create request 
---&gt; (here)
              .tryCatch({ error -&gt; AnyPublisher&lt;(T, HTTPResponse), Error&gt; in
                if let error = error as? ServerErrorType,
                   error.isAuthError {
                  
                  return authentificator
                    .refreshToken(force: true)
                    .subscribe(on: DispatchQueue.global())
                    .flatMap { token -&gt; AnyPublisher&lt;(T, HTTPResponse), Error&gt; in
                      session.publisher(for: request, mapper: mapper, token: token) //&lt;- repeat if token refreshed
                    }
                    .eraseToAnyPublisher()
                } else {
                  throw error
                }
              })
              .print()
          }
          .receive(on: DispatchQueue.main)
          .print()
          .eraseToAnyPublisher()
   }

</code></pre>
<p>In place where  I mark <code>(here)</code> when I have expired token, tryCatch wont works, instead &quot;received canceled&quot; printed in console. I'm not sure what I did wrong. Can any on advice?</p>
","2012219","","","","","2021-08-01 12:05:26","""Receive canceled"" when transform Publisher","<ios><swift><combine><urlsession>","1","2","","","","CC BY-SA 4.0"
"68613998","1","68616506","","2021-08-01 20:08:09","","0","70","<p>The execution of this code is confusing me:</p>
<pre><code>class RecipeListViewModel: ObservableObject {
    
    @Published var recipeList = [RecipeViewModel]()
    
    init(){

        RecipeRepository.$allRecipeVMs.map { recipes in
            recipes.map { recipe in
            recipe
            }
        }
        .assign(to: &amp;$recipeList)
    }
}
</code></pre>
<p>My understanding was that SwiftUI publishers are uni-directional, meaning that when <code>RecipeRepository.allRecipeVMs</code> is modified <code>recipeList</code> is too. However, the behaviour I'm seeing is that When <code>recipeList</code> is updated, <code>RecipeRepository.allRecipeVMs</code> is also updated. I've tried to find documentation on this but can't seem to find anything.</p>
<p>Here is the <code>RecipeViewModel</code> class, not sure if it's useful:</p>
<pre><code>class RecipeViewModel : Identifiable, ObservableObject, Hashable{
    
    var id = UUID().uuidString
    @Published var recipe: Recipe

    init(recipe: Recipe){

        self.recipe = recipe
    }
}
</code></pre>
","10142976","","","","","2021-08-02 04:53:42","SwiftUI/Combine Are publishers bi-directional?","<swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"68616549","1","","","2021-08-02 05:00:32","","-2","102","<p>When I add some operator,the return value will more long,like:</p>
<p><strong>Publishers.FlatMap&lt;Publishers.Map&lt;AnyPublisher&lt;NetResponse, Error&gt;, Token&gt;, AnyPublisher&lt;NetResponse, Error&gt;&gt;</strong></p>
<p>In fact, I hope users only need to know <strong>AnyPublisher&lt;Token, Error&gt;</strong>  is enough.</p>
<p>Is there any way for me to only return <strong>AnyPublisher&lt;Token, Error&gt;</strong> rather than <strong>Publishers.FlatMap&lt;Publishers.Map&lt;AnyPublisher&lt;NetResponse, Error&gt;, Token&gt;, AnyPublisher&lt;NetResponse, Error&gt;&gt;</strong></p>
<pre><code>public func singleHTTPLoginSignal(ccCode:String, phone: String, authType:String,password: String) -&gt;  AnyPublisher&lt;NetResponse&lt;OauthToken&gt;, Error&gt;{
    return API.shared.combine_loadModelResource(GetOauthTokenAPI(ccCode: ccCode, phone: phone, authType: authType,password: password), type: OauthToken.self)

}

///Map:NetResponse&lt;MQTTToken&gt; -&gt; Token
public func singleMQTTLoginSignal(oauthToken: OauthToken) -&gt;
    Publishers.Map&lt;AnyPublisher&lt;NetResponse&lt;MQTTToken&gt;, Error&gt;, Token&gt;{
        
    API.shared.combine_loadModelResource(GetMQTTTokenAPI(accessToken: oauthToken.access_token), type: MQTTToken.self).map({ response in
        return Token(oauthToken: oauthToken, mqttToken: response.data!)
    })
}


///AnyPublisher&lt;Token, Error&gt;
public func loginFullSignal(ccCode:String, phone: String, authType:String,password: String) -&gt; Publishers.FlatMap&lt;Publishers.Map&lt;AnyPublisher&lt;NetResponse&lt;MQTTToken&gt;, Error&gt;, Token&gt;, AnyPublisher&lt;NetResponse&lt;OauthToken&gt;, Error&gt;&gt;
{
    self.singleHTTPLoginSignal(ccCode:ccCode,phone:phone,authType:authType,password:password).flatMap{ response  in
        return self.singleMQTTLoginSignal(oauthToken: response.data!)
    }
}

</code></pre>
","7260604","","","","","2021-08-02 05:36:45","Swift combine add operator method,how to make return value simple and short,like Publishers.FlatMap<XXXPublisher<XXX>.XX> to AnyPublisher<XXX, Error>","<swift><combine>","1","1","0","","","CC BY-SA 4.0"
"68623753","1","68625818","","2021-08-02 14:56:02","","-1","193","<p>In my project i hold a large dict of items that are updated via grpc stream. Inside the app there are several places i am rendering these items to UI and i would like to propagate the realtime updates.</p>
<p>Simplified code:</p>
<pre class=""lang-swift prettyprint-override""><code>struct Item: Identifiable {
    var id:String = UUID().uuidString
    var name:String
    var someKey:String
    
    init(name:String){
        self.name=name
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>class DataRepository {
    public var serverSymbols: [String: CurrentValueSubject&lt;Item, Never&gt;] = [:]
    
    // method that populates the dict
    func getServerSymbols(serverID:Int){
        someService.fetchServerSymbols(serverID: serverID){ response in
            response.data.forEach { (name,sym) in
                self.serverSymbols[name] = CurrentValueSubject(Item(sym))
            }
        }
    }

    // background stream that updates the values
    func serverStream(symbols:[String] = []){
        someService.initStream(){ update in
            DispatchQueue.main.async {
                self.serverSymbols[data.id]?.value.someKey = data.someKey
            }
        }
    }
     
}
</code></pre>
<p>ViewModel:</p>
<pre class=""lang-swift prettyprint-override""><code>class SampleViewModel: ObservableObject {
    @Injected var repo:DataRepository   // injection via Resolver

    // hardcoded value here for simplicity (otherwise dynamically added/removed by user)
    @Published private(set) var favorites:[String] = [&quot;item1&quot;,&quot;item2&quot;]

    func getItem(item:String) -&gt; Item {         
        guard let item = repo.serverSymbols[item] else { return Item(name:&quot;N/A&quot;)}
        return ItemPublisher(item: item).data
    }
}

class ItemPublisher: ObservableObject {
    @Published var data:Item = Item(name:&quot;&quot;)
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(item:CurrentValueSubject&lt;Item, Never&gt;){
        item
            .receive(on: DispatchQueue.main)
            .assignNoRetain(to: \.data, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>Main View with subviews:</p>
<pre class=""lang-swift prettyprint-override""><code>struct FavoritesView: View {
    @ObservedObject var viewModel: QuotesViewModel = Resolver.resolve()
    var body: some View {
        VStack {
            ForEach(viewModel.favorites, id: \.self) { item in
                    FavoriteCardView(item: viewModel.getItem(item: item))
            }
        }
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>struct FavoriteCardView: View {
    var item:Item
    var body: some View {
        VStack {
            Text(item.name)
            Text(item.someKey)   // dynamic value that should receive the updates
        }
    }
}
</code></pre>
<p>I must've clearly missed something or it's a completely wrong approach, however my Item cards do not receive any updates (i verified the backend stream is active and serverSymbols dict is getting updated). Any advice would be appreciated!</p>
","1389597","","1389597","","2021-08-03 11:43:21","2021-08-03 11:43:21","SwiftUI+Combine - Dynamicaly subscribing to a dict of publishers","<swift><swiftui><combine>","1","7","","","","CC BY-SA 4.0"
"68625105","1","68625490","","2021-08-02 16:35:04","","0","103","<p>So I have a <code>View</code> with <code>List</code> of subviews that take an object. These objects come from array that is in my data manager.</p>
<pre><code>struct ContentView: View {
@ObservedObject var manager = AppConnectivityManager.shared

var body: some View {
    
        List {
            ForEach(manager.goals, id: \.id) { goal in
                let _ = print(&quot;goal in foreach: \(goal.goal.completitionCount) + title: \(goal.goal.title)&quot;)
                GoalView(goalWrapper:goal)
            }.listRowBackground(Color.clear)
        }
    
    }
}
</code></pre>
<p>This part works well and update is triggered every time I update the manager object.</p>
<p>The problem is that my <code>GoalView(goalWrapper:goal)</code> gets only updated once when the code runs first time but then when its supposed to be refreshed it stays the same. This <code>print(&quot;progress:</code> statement in the goal view prints always the same values but the print statement in the list gets the updates. I might be missing the concept but I though I can pass the <code>ObservedObject</code> down the subview and it will get updated when <code>manager</code> gets also updated but that is not the case.</p>
<pre><code>struct GoalView: View {

@ObservedObject var goalWrapper: GoalWrapper

var body: some View {
    let _ = print(&quot;progress: \(self.goalWrapper.goal.completitionCount) + daily: \(self.goalWrapper.goal.dailyNotificationCount) + title: \(self.goalWrapper.goal.title)&quot;)
    ZStack(content: {
        GoalAnimationView(goalWrapper: self.goalWrapper).cornerRadius(10)
        VStack(alignment: .leading, spacing: nil, content: {
            Text(goalWrapper.goal.title).foregroundColor(.black).padding(.leading, 8)
                .padding(.trailing, 8)
                .padding(.top, 4)
            HStack(alignment: .center,content: {
                Text(&quot;\(goalWrapper.goal.completitionCount)/\(goalWrapper.goal.dailyNotificationCount)&quot;).padding(.top, 2).padding(.trailing, 85).padding(.bottom, 6)
                Text(&quot;\(goalWrapper.goal.completitionCount)&quot;).padding(.top, 2).padding(.trailing, 12).padding(.bottom, 12).font(.title)
            }).frame(minWidth: 0, maxWidth: .infinity, minHeight: 0,maxHeight: 35,alignment: .trailing).background(Color.clear)


        }).listRowPlatterColor(Color.blue).frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, alignment: .leading).cornerRadius(10)
        
    })
  }
}
</code></pre>
<p>Here is the <code>GoalWrapper</code> class</p>
<pre><code>public class GoalWrapper: ObservableObject, Hashable {

    public static func == (lhs: GoalWrapper, rhs: GoalWrapper) -&gt; Bool {
        return lhs.goal.id == rhs.goal.id
    }

    public func hash(into hasher: inout Hasher) {
         hasher.combine(goal.id)
    }

    @Published var goal: Goal!
    let id: String
    init(goal: Goal) {
        self.goal = goal
        self.id = goal.id
   }
}
</code></pre>
<p>Is there some way How I can pass the updates to the list subviews? I have found some other people having issues with lists and passing a binding to the views in list. Is that the only way ?</p>
","4107264","","","","","2021-08-02 17:04:23","List item is not being updated","<swiftui><combine><swiftui-list>","1","1","","","","CC BY-SA 4.0"
"68625902","1","","","2021-08-02 17:42:22","","0","96","<p>I have a consistent crash that I cannot find the solution for. In one of the modal views in my application, the user could create several cards and when the user is &quot;DONE&quot;, I collect the created cards and POST them one by one(The modal view will dismissed). I have a Alamofire/ Combine POST call below that saves info on one card a user creates. When I try to post the data, I get a <code>EXC_BAD_ACCESS</code> on the commented line in the code.</p>
<p>I have many other GET and POST calls that work correctly that has very similar method bodies, this is the only method I know of that is throwing the error.</p>
<pre><code>class APIHandler {
    ...
    
    func postAdditionalCard(data: String) throws -&gt; AnyPublisher&lt;Card_AdditionalPostResponse, Error&gt; {
        
        let postCardAdditionalReq = Card_AdditionalPostRequest(data: data)
        
        let paramData = try JSONEncoder().encode(postCardAdditionalReq)
        let params = try JSONSerialization.jsonObject(with: paramData, options: [])
        
        return try networking.authorizationHeader() //Helper that fetches, either locally or remotely,
                // the Authorization token and creates a authorization header with it
            .flatMap { authHeader -&gt; AnyPublisher&lt;Card_AdditionalPostResponse, Error&gt; in
                
                self.networking.decodablePublisher(URL.cardAdditional, method: .post, parameters: params as? [String: Any], headers: [authHeader])
                    .mapError { _ in LANet.LANetError.genericError }
                    .eraseToAnyPublisher()
            }
            .eraseToAnyPublisher() //stack trace highlights this line with &quot;EXC_BAD_ACCESS&quot;
    }
    ...
}
</code></pre>
<p>The <code>Card_AdditionalPostRequest</code> struct</p>
<pre><code>public struct Card_AdditionalPostRequest: Codable {
    
    let ucc_id: Int?
    let ucc_user_id: String
    let ucc_created_time: String?
    let ucc_description: String?
    let ucc_type: String
    
    public init(createdCard: Common_UserCard, task: Common_Task) {
        
        self.ucc_id = createdCard.ucc_id?.intValue
        self.ucc_user_id = createdCard.ucc_user_id ?? &quot;&quot;
        self.ucc_created_time = createdCard.ucc_created_time?.yyyy_MM_dd_HH_mm_SecString
        self.ucc_description = createdCard.ucc_description
        self.ucc_type = createdCard.ucc_type ?? &quot;&quot;
    }
}
</code></pre>
<p>The exception as shown in the debug navigator</p>
<pre><code>#0  swift_release
#1  0x0000000103306c5f in outlined release of Card_AdditionalPostRequest ()
...
</code></pre>
<p>NOTE :</p>
<ol>
<li><code>networking</code> is a simple wrapper around Alamofire.</li>
<li>The class APIHandler is not tied to the lifecycle of a view, but to the entire app (i.e. created when the app is booted up).</li>
<li><code>Card_AdditionalPostResponse</code> is like any other model. A struct conforming to <code>Codable</code> and has some data in it.</li>
<li>the <code>parameters</code> variable is optional and if I remove <code>parameters: params as? [String: Any],</code> from the network call, the <code>EXC_BAD_ACCESS</code> exception vanishes, but the additional data would not be attached in the call.</li>
</ol>
","3970488","","3970488","","2021-08-03 02:53:24","2021-08-03 02:53:24","Cannot find root cause of an error ""outlined release of model""","<ios><swift><combine>","0","2","","","","CC BY-SA 4.0"
"68635359","1","","","2021-08-03 11:39:00","","0","234","<p>I made a simple Playground example trying to figure how connecting View Model to the View works with SwiftUI and Combine.
I believe I've done it by the book (check the code example below) but when I tap on the &quot;Increment&quot; button this print appears in the console:</p>
<pre><code> === AttributeGraph: cycle detected through attribute 22736 ===
 === AttributeGraph: cycle detected through attribute 18320 ===
 === AttributeGraph: cycle detected through attribute 17200 ===
 === AttributeGraph: cycle detected through attribute 18320 ===
 === AttributeGraph: cycle detected through attribute 21592 ===
 === AttributeGraph: cycle detected through attribute 21592 ===
 === AttributeGraph: cycle detected through attribute 21768 ===
 === AttributeGraph: cycle detected through attribute 21768 ===
 === AttributeGraph: cycle detected through attribute 18152 ===
 === AttributeGraph: cycle detected through attribute 21768 ===
 === AttributeGraph: cycle detected through attribute 20224 ===
 === AttributeGraph: cycle detected through attribute 18152 ===
 === AttributeGraph: cycle detected through attribute 18152 ===
 === AttributeGraph: cycle detected through attribute 18280 ===
 === AttributeGraph: cycle detected through attribute 22568 ===
 === AttributeGraph: cycle detected through attribute 22568 ===
 === AttributeGraph: cycle detected through attribute 22736 ===
 === AttributeGraph: cycle detected through attribute 22568 ===
 === AttributeGraph: cycle detected through attribute 22736 ===
 === AttributeGraph: cycle detected through attribute 22568 ===
</code></pre>
<p>After that, I started experimenting with the code and figured that delaying the call to the View Model's increment method fixes this issue. (Uncomment commented lines from the example to test this.)
What bothers me now is that I don't know why this warning happens or why delaying the method call fixes it.</p>
<p>I would be thankful if someone can explain what is going on behind the scene and why this happens.</p>
<p>Environment:</p>
<pre><code>macOS Big Sur Version 11.4
Xcode Version 12.5.1 (12E507)
</code></pre>
<p>Example code:</p>
<pre><code>import Combine
import SwiftUI
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

class ViewModel: ObservableObject {
    @Published private (set) var counter: Int = 0
    
    func increment() {
        counter += 1
    }
}

struct SomeView: View {
    @ObservedObject var viewModel: ViewModel
    
    var body: some View {
        VStack(alignment: .center, spacing: 8) {
            Text(&quot;Counter: \(viewModel.counter)&quot;)
                .padding()
            Button(&quot;Increment&quot;) {
                // uncomment to fix AttributeGraph cycle warning
//                DispatchQueue.main.asyncAfter(deadline: .now() + 0.001) {
                    self.viewModel.increment()
//                }
            }
            .padding()
        }
        .padding()
    }
}

let viewModel = ViewModel()
let view = SomeView(viewModel: viewModel)
PlaygroundPage.current.setLiveView(view)

</code></pre>
","2996397","","","","","2021-08-03 12:27:27","Changing View's ViewModel on button tap causes: ""AttributeGraph: cycle detected through attribute warning""","<swiftui><combine><observableobject><observedobject>","1","1","","","","CC BY-SA 4.0"
"68665260","1","68665913","","2021-08-05 10:55:16","","2","360","<p>I have some difficulty using Combine in SwiftUI with making an API request and then decoding the data and returning it. When calling the API Service, it states in the 'AnyPublisher&lt;UserLoginResponse, APIError&gt;' that the result will be of such type. However, I would want to reuse the API Service and decode the response to different model structures. How can I call the API Service while defining which data structure it has to decode the returned data to? For example, in another ViewModel I would want to decode the API data to a 'NewsUpdatesResponse' instead of 'UserLoginResponse'. The code I have now is as follows:</p>
<p>Most code comes from: <a href=""https://www.youtube.com/watch?v=M2psX-JwHdE&amp;t=1039s"" rel=""nofollow noreferrer"">tundsdev</a></p>
<p><strong>API Service</strong></p>
<pre><code>struct APIService {

func request(from endpoint: APIRequest, body: String) -&gt; AnyPublisher&lt;UserLoginResponse, APIError&gt; {
    
    var request = endpoint.urlRequest
    request.httpMethod = endpoint.method
    
    if endpoint.authenticated == true {
        request.setValue(&quot;testToken&quot;, forHTTPHeaderField: &quot;token&quot;)
    }
    if body != &quot;&quot; {
        let finalBody = body.data(using: .utf8)
        request.httpBody = finalBody
    }
    
    return URLSession
        .shared
        .dataTaskPublisher(for: request)
        .receive(on: DispatchQueue.main)
        .mapError { _ in APIError.unknown}
        .flatMap { data, response -&gt; AnyPublisher&lt;UserLoginResponse, APIError&gt; in
            
            guard let response = response as? HTTPURLResponse else {
                return Fail(error: APIError.unknown).eraseToAnyPublisher()
            }
            
            print(response.statusCode)
            
            if response.statusCode == 200 {
                let jsonDecoder = JSONDecoder()
                
                return Just(data)
                    .decode(type: UserLoginResponse.self, decoder: jsonDecoder)
                    .mapError { _ in APIError.decodingError }
                    .eraseToAnyPublisher()
            }
            else {
                return Fail(error: APIError.errorCode(response.statusCode)).eraseToAnyPublisher()
            }
        }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p><strong>Login ViewModel</strong></p>
<pre><code>class LoginViewModel: ObservableObject {

@Published var loginState: ResultState = .loading

private var cancellables = Set&lt;AnyCancellable&gt;()
private let service: APIService

init(service: APIService) {
    self.service = service
}

func login(username: String, password: String) {
    
    self.loginState = .loading
    
    let cancellable = service
        .request(from: .login, body: &quot;username=admin&amp;password=admin&quot;)
        .sink { res in
            print(res)
            switch res {
            case .finished:
                self.loginState = .success
            case .failure(let error):
                self.loginState = .failed(error: error)
            }
        } receiveValue: { response in
            print(response)
        }
    
    self.cancellables.insert(cancellable)
    }
}
</code></pre>
","14855422","","14855422","","2021-08-05 23:02:35","2021-08-05 23:02:35","SwiftUI Combine Publisher targetstruct for decoding data","<api><data-structures><swiftui><combine><publisher>","2","0","1","","","CC BY-SA 4.0"
"68666004","1","","","2021-08-05 11:47:11","","0","78","<p>I have an event bus that publishes events happening over a custom text field(a chat message input box), like attachMediaEvent, sendMessageEvent, selectTextEvent. I want to provide provide default actions for the events, but only in case downstream doesn't handle it(kind of like how one can provide protocol default implementation). Is there a way to check if the downstream handles the event and handle it if doesn't?</p>
<p>I know that I'm being loose with the phrase <code>handling the event</code> but it was intentional and I would like any sort of solution for it. And I'm not adding any code, but I can do so, if needed. It is a really simple publisher that pushes events, anyhow.</p>
<p>EDIT:
Ok, I dug deeper in SO and I started to get the idea that I had to implement custom operator. But I have hit the exact same roadblock. I have no idea how a downstream can speak to the upstream about how it has handled its values. Although I tried to create a protocol(<code>EventConsumer</code>) that one could check if implemented by a object that is passed to the subscriber, but which felt very wrong. Any help would be a godsend.</p>
<p>Here's the code I tried in playground.</p>
<pre><code>@objc protocol EventConsumer {

    @objc optional func sendEventAction()
    @objc optional func attachEventAction()
}
    
class DefaultEventConsumer: EventConsumer {

}

struct CustomPublisher&lt;Upstream: Publisher&gt;: Publisher where Upstream.Output == String, Upstream.Failure == Never {
    
    typealias Output = String
    
    typealias Failure = Never
    
    var upstreamEventPublisher: Upstream
//    var eventConsumer: EventConsumer
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Never == S.Failure, String == S.Input {
        
        let subscription = CustomSubscription&lt;S&gt;(/*eventHandler: eventConsumer*/)
        subscription.downstream = subscriber
        
        subscriber.receive(subscription: subscription)
        
        upstreamEventPublisher.sink { eventString in
            
            subscription.sendEvent(event: eventString)
        }
    }
}

class CustomSubscription&lt;Downstream: Subscriber&gt;: Subscription where Downstream.Input == String {
    
    var downstream: Downstream?
//    var eventHandler: EventConsumer
    
//    init(eventHandler: EventConsumer) {
//        self.eventHandler = eventHandler
//    }
    
    func request(_ demand: Subscribers.Demand) {
    }

    func cancel() {

        downstream = nil
    }
    
    func sendEvent(event: String) {
        
        //How do I check if downstream processes the event somehow and send event if it doesnt
        downstream?.receive(event)
    }
}
//
//
//extension AnyPublisher where Output == String, Failure == Never {
//
//    func checkAndPublishEvents(_ eventConsumer: EventConsumer) -&gt; Self {
//
//        CustomPublisher(upstreamEventPublisher: self/*, eventConsumer: eventConsumer*/)
//            .eraseToAnyPublisher()
//    }
//}
</code></pre>
","3970488","","3970488","","2021-08-05 14:20:14","2021-08-05 14:20:14","Is there a way to check if downstream handles a event a publisher publishes in Combine?","<swift><combine>","0","8","","","","CC BY-SA 4.0"
"68670444","1","68675191","","2021-08-05 16:40:17","","5","811","<p>I have a UIKit project with UIViewControllers, and I'd like to present an action sheet built on SwiftUI from my ViewController. I need to bind the appearance and disappearance of the action sheet back to the view controller, enabling the view controller to be dismissed (and for the display animation to happen only on viewDidAppear, to avoid some weird animation behavior that happens when using <code>.onAppear</code>). Here is a code example of how I expect the binding to work and how it's not doing what I'm expecting:</p>
<pre><code>import UIKit
import SwiftUI

class ViewController: UIViewController {
    let button = UIButton(type: .system)
    var show = true
    lazy var isShowing: Binding&lt;Bool&gt; = .init {
        self.show
    } set: { show in
        // This code gets called
        self.show = show
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        
        view.backgroundColor = .white
        button.setTitle(&quot;TAP THIS BUTTON&quot;, for: .normal)
        view.addSubview(button)
        button.translatesAutoresizingMaskIntoConstraints = false
        button.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true
        button.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true
        button.addTarget(self, action: #selector(tapped), for: .touchUpInside)
    }
    
    @objc private func tapped() {
        let vc = UIHostingController(rootView: BindingProblemView(testBinding: isShowing))
        vc.modalPresentationStyle = .overCurrentContext
        present(vc, animated: false)
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) { [self] in
            isShowing.wrappedValue.toggle()
            isShowing.update()
        }
    }
}

struct BindingProblemView: View {
    @Binding var testBinding: Bool
    @State var state = &quot;ON&quot;
    
    var body: some View {
        ZStack {
            if testBinding {
                Color.red.ignoresSafeArea().padding(0)
            } else {
                Color.green.ignoresSafeArea().padding(0)
            }
            
            Button(&quot;Test Binding is \(state)&quot;) {
                testBinding.toggle()
            }.onChange(of: testBinding, perform: { value in
                // This code never gets called
                state = testBinding ? &quot;ON&quot; : &quot;OFF&quot;
            })
        }
    }
}
</code></pre>
<p>What happens is that <code>onChange</code> never gets called after <code>viewDidAppear</code> when I set the binding value <code>true</code>. Am I just completely misusing the new combine operators?</p>
","381474","","381474","","2021-08-05 19:31:06","2021-08-06 01:46:55","How to bind SwiftUI and UIViewController behavior","<ios><swift><swiftui><uikit><combine>","1","4","2","","","CC BY-SA 4.0"
"68731053","1","","","2021-08-10 17:19:33","","-2","361","<p>good morning community,</p>
<p>I have a very good question that I try to implement in a project but I am something new to combine
I want to do a function to check some permissions, but I want to return an AnyPublisher with a tuple inside, could someone help me who has already done it or know how to do it?</p>
<p>I put my code below.</p>
<pre><code>func returnedPermisionReminderAuthorizationStatus(reminderPermission:EKAuthorizationStatus,calendarPermission:EKAuthorizationStatus) -&gt; AnyPublisher&lt;(EKAuthorizationStatus,EKAuthorizationStatus),Never&gt;{

    var reminderPermissionToPass:EKAuthorizationStatus =  .notDetermined
    var calendarPermissionToPass:EKAuthorizationStatus =  .notDetermined
    
    switch (reminderPermission){
    case .notDetermined:
      return Just(reminderPermissionToPass).eraseToAnyPublisher()
    case .restricted:
        reminderPermissionToPass = .restricted
        return Just(reminderPermissionToPass).eraseToAnyPublisher()
    case .denied:
        reminderPermissionToPass = .denied
        return Just(reminderPermissionToPass).eraseToAnyPublisher()
    case .authorized:
        reminderPermissionToPass = .authorized
        return Just(reminderPermissionToPass).eraseToAnyPublisher()
    @unknown default:
        reminderPermissionToPass = .notDetermined
        return Just(reminderPermissionToPass).eraseToAnyPublisher()
    }

}
</code></pre>
<p>Is it possible to send a tuple in a just?</p>
","","user13485448","9607863","","2021-08-10 17:36:28","2021-08-10 20:55:52","How to set a tuple in a AnyPublisher in SwiftUI","<swift><swiftui><combine>","2","4","0","","","CC BY-SA 4.0"
"68734145","1","68734227","","2021-08-10 22:36:43","","0","279","<p>I'm not very familiar with Combine's <code>Timer.publish(every:, on: , in: )</code>. Essentially I'm looking to run a timer to call a func in my <code>ObservableObject</code> class. Is there a better way of doing this, not sure if I'm doing so correctly or if there's a cleaner way of doing the same.</p>
<pre class=""lang-swift prettyprint-override""><code>class Example : ObservableObject {
    private var cancellables = Set&lt;AnyCancellable&gt;()
    var cancellable: AnyCancellable? = nil
    
    @Published var somedate: Date = Date()
    
    init() {
        cancellable = Timer
            .publish(every: 1, on: .main, in: .common)
            .autoconnect()
            .sink(receiveValue: { _ in
                self.update()
            })
    }
    
    func update() {
        let publisher =  Date()
        Just(publisher)
            .sink(receiveCompletion: { completion in
            }, receiveValue: { date in
                self.somedate = date
                print(self.somedate)
            }).store(in: &amp;cancellables)
    }
}
</code></pre>
<p>The output seems correct.</p>
<pre><code>2021-08-10 22:25:24 +0000
2021-08-10 22:25:25 +0000
2021-08-10 22:25:26 +0000
2021-08-10 22:25:27 +0000
2021-08-10 22:25:28 +0000
2021-08-10 22:25:29 +0000
2021-08-10 22:25:30 +0000
2021-08-10 22:25:31 +0000
2021-08-10 22:25:32 +0000
2021-08-10 22:25:33 +0000
2021-08-10 22:25:34 +0000
2021-08-10 22:25:35 +0000
2021-08-10 22:25:36 +0000
</code></pre>
","14601731","","","","","2021-08-10 22:49:33","Combine Timer - setting timer","<swiftui><timer><combine>","1","0","","","","CC BY-SA 4.0"
"68742369","1","68743922","","2021-08-11 12:49:21","","1","370","<p>I wonder if it is possible to access values in a combine-operator-chain that are used further up in the chain.</p>
<p>For example, if you have an array of strings, and you download a resource with each string, is it possible to access the string itself?</p>
<p>Maybe a pseudo-code example will help understand better:</p>
<pre><code>let strings = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

strings.publisher
    .compactMap{ str in
        URL(string: &quot;https://someresource/\(str)&quot;)
    }
    .flatMap { url  in
        URLSession.shared.dataTaskPublisher(for: url)
    }
    .map { $0.data}
    .map { data in
        // here I would need the &quot;str&quot; string from above
    }

</code></pre>
<p>Help is much appreciated</p>
<p>Thx, Gregor</p>
","12188194","","12188194","","2021-08-11 14:15:59","2021-08-11 15:12:32","Access used values in a combine-operator-chain","<swift><combine>","1","0","2","","","CC BY-SA 4.0"
"68745323","1","68745585","","2021-08-11 15:55:46","","4","4211","<p>A <code>ViewModel</code> class has a <code>sourceProperty</code> that is being edited by the <code>TextField</code>. That property is <code>@Published</code>. I'd like to pass it to the <code>Logic</code> class which has an initializer with <code>Binding&lt;String&gt;</code>. That class will be listening to the <code>sourceProperty</code> changes, react on them and set it's output to the <code>@Published output</code> property.</p>
<p>How can I pass <code>@Published sourceProperty</code> as an initializer parameter to the <code>Logic</code> class?</p>
<p>Relevant code:</p>
<pre><code>final class ViewModel {
    @Published var sourceProperty: String = &quot;&quot;
    private var logic: Logic?

    init() {
        self.logic = Logic(data: $sourceProperty)
        $logic.output.sink({result in 
            print(&quot;got result: \(result)&quot;)
        })
    }

}

final class Logic: ObservableObject {
    private var bag = Set&lt;AnyCancellable&gt;()
    @Published var output: String = &quot;&quot;
    @Binding var data: String
    init(data: Binding&lt;String&gt;) {
        self._data = data

        $data.sink({ newValue in 
            output = newvalue + &quot;ABCDE&quot;
        }).store(in: &amp;bag)
    }
}
</code></pre>
<p>So far I'm getting the following error:</p>
<blockquote>
<p>Cannot convert value of type 'Published.Publisher' to expected
argument type 'Binding'</p>
</blockquote>
<p>The goal is to use a change in the object's own property to trigger a method invocation in another object and then bind that second object's output to some view.</p>
<p>View Layer:</p>
<pre><code>public struct ViewLayer: View {
    @Binding private var sourceProperty: String

    public init(_ placeholder: String,
                sourceProperty: Binding&lt;String&gt;,
    ) {
        self.placeholder = placeholder
        self._sourceProperty = sourceProperty
    }

    public var body: some View {
        TextField(placeholder, text: $sourceProperty)
    }

 }
</code></pre>
","3667264","","3667264","","2021-08-11 16:11:38","2021-08-11 16:25:11","Pass @Published where @Binding is required (SwiftUI, Combine)","<data-binding><swiftui><binding><combine><publisher>","1","7","3","","","CC BY-SA 4.0"
"68748533","1","","","2021-08-11 20:23:59","","0","143","<p>I want to get the first 20 data for the first page from the url below. I want to get the next 20 data on the second page. I don't want to get all the data in the first time. I just want to get the first 20 data.</p>
<p><strong>URL:</strong></p>
<p><a href=""https://rss.itunes.apple.com/api/v1/us/books/top-free/all/%20100/non-explicit.json"" rel=""nofollow noreferrer"">https://rss.itunes.apple.com/api/v1/us/books/top-free/all/%20100/non-explicit.json</a></p>
<p><strong>JSON:</strong></p>
<pre><code>class BookProvider {

    // MARK: - Properties
    private let baseUrl = &quot;https://rss.itunes.apple.com/api/v1&quot;

    // MARK: - Life Cycle
    init() { }

    // MARK: Functions
    func loadTopCharts() -&gt; Future&lt;[Book], Error&gt; {
        let urlString = &quot;us/books/top-free/all/100/non-explicit.json&quot;

        if let data = getData(from: urlString) {
            if let songs = jsonDictionary(from: data)?[&quot;results&quot;] {
                do {
                    let data = try JSONSerialization.data(withJSONObject: songs, options: .fragmentsAllowed)
                    let bookDecoder = try JSONDecoder().decode([Book].self, from: data)

                    return Future { promixe in
                        promixe(.success(bookDecoder))
                    }
                }catch {
                    debugPrint(error.localizedDescription)
                }
            }
        }
        return Future{ _ in }
    }

    private func getData(from urlString: String) -&gt; Data? {
        guard let url = URL(string: baseUrl + &quot;/&quot; + urlString) else {
            fatalError(&quot;Couldn't load URL from provided string.&quot;)
        }

        do {
            return try Data(contentsOf: url)
        } catch {
            debugPrint(&quot;Couldn't load data from URL:\n\(error)&quot;)
            return nil
        }
    }

    private func jsonDictionary(from data: Data) -&gt; [String : Any]? {
        do {
            let dictionary = try JSONSerialization.jsonObject(with: data, options: .allowFragments)
            return (dictionary as? [String : Any])?[&quot;feed&quot;] as? [String : Any]
        }catch {
            debugPrint(error.localizedDescription)
            return nil
        }
    }
}
</code></pre>
","13125522","","","","","2021-08-11 20:23:59","JSON Pagination (20 data per page)","<json><swift><pagination><combine>","0","7","","","","CC BY-SA 4.0"
"68799895","1","68800184","","2021-08-16 08:51:07","","2","161","<p>So, I have few steps, last one contains <strong>EnvironmentObject</strong> and <strong>ObservedObject</strong>. The issue is, when I try to modify <strong>EnvironmentObject</strong> <strong>(lane 68)</strong>  it re-creates <strong>ObservedObject</strong>.
Can any one explain me why this happens? Any solution to keep my <strong>ObservedObject</strong> with original state?</p>
<p>As far as I know it possible to change ObservedObject to StateObject, but I am using iOS 13+ so... I need other solution.</p>
<p><a href=""https://i.stack.imgur.com/d73m1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/d73m1.png"" alt=""enter image description here"" /></a></p>
","9506836","","","","","2021-08-16 09:14:43","SwiftUI changing environment object re-created observed object in same view","<swiftui><environment><combine><observedobject><environmentobject>","1","0","","","","CC BY-SA 4.0"
"68803878","1","","","2021-08-16 13:44:33","","0","183","<p>In the following code I have a <code>List</code> of <code>Car</code>s and each <code>Car</code> from that list has its own list of <code>Service</code>s, I can add and delete <code>Car</code>s without a problem by calling <code>carViewModel.addNewCar(make:String, model:String)</code> and <code>carViewModel.deleteCar(at indexSet:IndexSet)</code>.</p>
<h2>Car.swift</h2>
<pre><code>    import RealmSwift
    final class Car: Object, ObjectKeyIdentifiable{

        @objc dynamic var make: String = &quot;&quot;
        @objc dynamic var model: String = &quot;&quot;
        // creation date, ID etc.
        dynamic var services = List&lt;CarService&gt;()
    }
</code></pre>
<h2>CarList.swift</h2>
<pre><code>    import RealmSwift

    final class CarList: Object, ObjectKeyIdentifiable{
        
        @objc dynamic var name: String = &quot;&quot;
        // creation date, ID etc.
        var cars = RealmSwift.List&lt;Car&gt;()
    }
</code></pre>
<h2>CarService.swift</h2>
<pre><code>    import RealmSwift

    final class CarService: Object, ObjectKeyIdentifiable{

        @objc dynamic var serviceName: String = &quot;&quot;
        // creation date, ID etc.
    }
</code></pre>
<h2>View Model</h2>
<pre><code>    import RealmSwift

    class CarViewModel: ObservableObject{
        @Published var cars = List&lt;Car&gt;()
        @Published var selectedCarList: CarList? = nil

        var token: NotificationToken? = nil
        
        init(){
            // Create a the default lists if they don't already exist.
            createDefaultCarList()
            createDefaultServiceList()
            
            // Initialize the SelectedCarList and the cars variables items from the Default Car List.
            if let list = realm?.objects(CarList.self).first{
                self.selectedCarList = list
                self.cars = list.cars
            }
            
            token = selectedCarList?.observe({ [unowned self] (changes) in
                switch changes{
                case .error(_): break
                case.change(_, _):self.objectWillChange.send()
                case.deleted: self.selectedCarList = nil
                }
            })
        }
        
        func addNewCar(make:String, model:String){
            if let realm = selectedCarList?.realm{
                try? realm.write{
                    let car = Car()
                    car.make = make
                    car.model = model
                    selectedCarList?.cars.append(car)
                }
            }
        }
        
        func deleteCar(at indexSet:IndexSet){
            if let index = indexSet.first,
            let realm = cars[index].realm{
                try? realm.write{
                    realm.delete(cars[index])
                }
            }
        }
        
        func addService(toCar: Car, serviceName: String){
            try? realm?.write{
                let service = CarService()
                service.serviceName = serviceName
                
                toCar.services.append(service)
            }
        }
        
        /// Creates the Default Car List if it doesn't already exists otherwise just prints the error.
        func createDefaultCarList(){
            do {
                if (realm?.objects(CarList.self).first) == nil{
                    try realm?.write({
                        let defaultList = CarList()
                        defaultList.name = &quot;Default Car List&quot;
                        realm?.add(defaultList)
                    })
                }
            }catch let error{
                print(error.localizedDescription)
            }
        }
        
        /// Creates the Default Serivice List if it doesn't already exists otherwise just prints the error.
        func createDefaultServiceList(){
            do {
                if (realm?.objects(ServiceList.self).first) == nil{
                    try realm?.write({
                        let defaultList = ServiceList()
                        defaultList.listName = &quot;Default Service List&quot;
                        realm?.add(defaultList)
                    })
                }
            }catch let error{
                print(error.localizedDescription)
            }
        }
    }
</code></pre>
<p>My issue is adding or deleting <code>Service</code>s to existing <code>Car</code>s. When I call <code>carViewModel.addService(toCar: Car, serviceName: String)</code> I get the error below...</p>
<h2>Calling the addService() method.</h2>
<pre><code>    struct NewServiceFormView: View {
        @ObservedObject var carViewModel: CarViewModel
        @State var selectedCar:Car // pass from other cars view
        
        var body: some View {
            NavigationView {
            Form {
                // fields
            }
            .navigationBarItems( trailing:Button(&quot;Save&quot;, action: addNewCar))
            }
        }

        func addNewCar(){
            carViewModel.addService(toCar: selectedCar, serviceName: &quot;Oil Change&quot;)
        }
    }
</code></pre>
<h2>Error</h2>
<blockquote>
<p>&quot;Cannot modify managed RLMArray outside of a write transaction.&quot;</p>
</blockquote>
<p>I can add new <code>Services</code> by explicitly selecting a <code>Car</code> from the <code>cars</code> list. I don't get any errors but the UI doesn't update; I don't see the newly added Service until the app is relaunched.</p>
<p>No errors doing it this way but the UI doesn't update.</p>
<pre><code>carViewModel.addService(toCar: carViewModel.cars[1], serviceName: &quot;Rotors&quot;)
</code></pre>
<p>How can I properly watch, delete and add <code>Service</code>s to existing <code>Car</code>s?</p>
<p><strong>EDIT</strong>: Added the following code per <code>Mahan</code>'s request.</p>
<h2>View to present the NewServiceFormView</h2>
<pre><code>    struct CarServicesView: View {
        @State var selectedCar:Car // a car from parent view
        @ObservedObject var carViewModel: CarViewModel
        
        var body: some View {
            VStack{

                List {
                    Section(header: Text(&quot;Services: \(selectedCar.services.count)&quot;)) {
                        ForEach(selectedCar.services) { service in
                        }
                    }
                }
                .listStyle(GroupedListStyle())
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button(action: openNewServiceForm) {
                            Image(systemName: &quot;plus&quot;)
                        }
                    }
                }
            }.sheet(isPresented: $newServiceFormIsPresented){
                NewServiceFormView(carViewModel: carViewModel, selectedCar: selectedCar)
            }
        }
        
        func openNewServiceForm() {
        newServiceFormIsPresented.toggle()
        }
    }
</code></pre>
","1577308","","1577308","","2021-08-16 14:01:59","2021-08-16 17:43:38","How to add and delete objects from a List from an object who's inside another List in SwiftUI and Realm","<swiftui><realm><combine><realm-list>","1","3","","","","CC BY-SA 4.0"
"68804927","1","","","2021-08-16 14:52:34","","2","322","<p>How to access achieveTo() inside @main struct from CustomInternalView()?</p>
<pre><code>@main
struct MyApp: App {
    
    var body: some Scene {
        WindowGroup {
            CustomInternalView()
        }
    }

    public func achieveTo() {
        // Do stuff
    }
}


struct CustomInternalView: View {
    var body: some View {
         Text(&quot;Some&quot;)
    }
    .onDisappear {
        // How to call &quot;achieveTo&quot; from here????????????
    }
}
</code></pre>
<p>In UIKit it is like <code>UIApplication.shared.windows.first!.rootViewController as! YourViewController</code>, How about SwiftUI?</p>
","5449670","","","","","2021-08-22 05:02:11","SwiftUI, iOS: How to access public function inside @main struct from custom internal View?","<ios><swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"68808409","1","68820035","","2021-08-16 19:41:36","","4","629","<p>I have a simple timer publisher that fires every 10 seconds.</p>
<pre><code>Timer
    .publish(every: 10, on: .main, in: .common)
    .autoconnect()
    .map { _ in ... }
    .sink(receiveValue: { [weak self] in
        ...
    })
    .store(in: &amp;subscriptions)
</code></pre>
<p>However, the first time it fires is in 10 seconds from now. Can I set it to fire its first value <em>now</em>?</p>
","10525140","","1974224","","2021-08-17 15:25:25","2021-08-17 15:25:25","Timer publisher with initial fire now","<ios><combine>","2","0","","","","CC BY-SA 4.0"
"68837874","1","","","2021-08-18 18:51:47","","-1","372","<p>It takes data in my <code>@Published</code> variable in CarDetailViewModel, but I could not pass the data inside this variable to the variable in the ViewController.</p>
<p><strong>ViewModel:</strong></p>
<pre><code>class CarDetailViewModel: ObservableObject {
    @Published var carDetail: Car = Car(brand: &quot;&quot;, features: CarFeatures(model: &quot;&quot;, km: 0, year: 0, price: 0, image: &quot;&quot;, gearType: &quot;&quot;, fuelType: &quot;&quot;, carVersion: &quot;&quot;))
    
    private var anyCancellable = Set&lt;AnyCancellable&gt;()
    var carSubject = PassthroughSubject&lt;Car, Never&gt;()
    
    func prepareCarDetail() {
        carSubject
            .sink {[weak self] car in
                self?.carDetail = car
                print(&quot;car: \(self?.carDetail)&quot;) // it is working.
            }
            .store(in: &amp;anyCancellable)
    }
}
</code></pre>
<p><strong>ViewController:</strong></p>
<p>When the assignmentDataToUI function runs, the <code>label</code> on the screen is <code>blank</code>.</p>
<pre><code>class CarDetailViewController: UIViewController {
    
    @IBOutlet weak var imageView: UIImageView!
    @IBOutlet weak var brandLabel: UILabel!
    @IBOutlet weak var modelLabel: UILabel!
    @IBOutlet weak var gearTypeLabel: UILabel!
    @IBOutlet weak var fuelTypeLabel: UILabel!
    @IBOutlet weak var priceLabel: UILabel!
    
    var carDetailViewModel = CarDetailViewModel()
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        carDetailViewModel.prepareCarDetail()
        assignmentDataToUI()
        
    }
    
    func assignmentDataToUI() {
        brandLabel.text = carDetailViewModel.carDetail.brand
    }
}
</code></pre>
","13125522","","","","","2021-08-18 20:37:40","How can I catch that @Published has changed with combine ? (UIKit)","<swift><uikit><combine>","1","12","","","","CC BY-SA 4.0"
"68849569","1","","","2021-08-19 14:15:34","","1","68","<p><strong>Question:</strong></p>
<p><em>I can't see the <code>km: Optional(33300)</code> data coming to the model on the UILabel, why? For example, when I select the Audi vehicle, I can see the <code>km</code>, but when I select the BMW vehicle, I cannot see the <code>km</code> value on the UILabel, why?</em></p>
<p>When I click on Cell, I move the data about the car to the detail page with combine.You can see the console output just below the code.</p>
<p><strong>I can see the <code>km</code> of other cars but not just one car's <code>km</code>. Why is that ?</strong></p>
<p><strong>didSelectRowAt:</strong></p>
<pre><code>func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let carDetailVC = CarDetailViewController()
        carListViewModel.$cars
            .receive(on: DispatchQueue.main)
            .sink { cars in
                carDetailVC.carDetailViewModel.carSubject
                    .send(cars[indexPath.row])
                print(&quot;Cell: \(cars[indexPath.row])&quot;) // PRINT
            }
            .store(in: &amp;anyCancelable)
        carListTableView.deselectRow(at: indexPath, animated: true)
        navigationController?.pushViewController(carDetailVC, animated: true)
    }
</code></pre>
<p><strong>Console Output:</strong></p>
<pre><code>Cell: Car(brand: Optional(&quot;BMW&quot;), features: Optional(CarList.CarFeatures(model: Optional(&quot;SERIES 3&quot;), km: Optional(33300), year: nil, price: Optional(400000), image: Optional(&quot;http://dreamsandbytes.com/carimages/carimage.jpeg&quot;), gearType: nil, fuelType: nil, carVersion: Optional(&quot;2.0 320D AUTO&quot;))))
</code></pre>
<p>As you can see in the console output, <code>km: Optional(33300)</code> data is displayed.</p>
<p>Now let's go to the ViewModel page of the Detail Page where we are moving the data.</p>
<p><strong>CarDetailViewModel:</strong></p>
<p>I printed the Car data coming to this page to the Console output again. You can see the console output below the code</p>
<pre><code>class CarDetailViewModel: ObservableObject {
    
    @Published private(set) var carDetail: Car?
    
    private var anyCancellable = Set&lt;AnyCancellable&gt;()
    var carSubject = PassthroughSubject&lt;Car, Never&gt;()
    
    func prepareCarDetail() {
        carSubject
            .receive(on: DispatchQueue.main)
            .sink {[weak self] car in
                self?.carDetail = car
                print(&quot;Car: \(car)&quot;) // PRINT
            }
            .store(in: &amp;anyCancellable)
    }
}
</code></pre>
<p><strong>Console Output:</strong></p>
<pre><code>Car: Car(brand: Optional(&quot;BMW&quot;), features: Optional(CarList.CarFeatures(model: Optional(&quot;SERIES 3&quot;), km: Optional(33300), year: nil, price: Optional(400000), image: Optional(&quot;http://dreamsandbytes.com/carimages/carimage.jpeg&quot;), gearType: nil, fuelType: nil, carVersion: Optional(&quot;2.0 320D AUTO&quot;))))
</code></pre>
<p>Here you can see the <code>km: Optional(33300)</code> data. However, I cannot see this data on the Label.</p>
<p><strong>I can see the <code>km</code> of other cars but not just one car's <code>km</code>. Why is that ?</strong></p>
<p><strong>DetailViewController:</strong></p>
<pre><code>override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    
    carDetailViewModel.prepareCarDetail()
    carDetailViewModel.$carDetail
        .sink {[weak self] car in
            guard let self = self else { return }
            self.assignmentDataToUI()
            self.prepareUIAnchor()
        }
        .store(in: &amp;anyCancelable)
    
    
}

func assignmentDataToUI() {
    if let image = carDetailViewModel.carDetail?.features?.image { imageView.loadImage(url: image) } else { imageView.image = nil }
    if let brand = carDetailViewModel.carDetail?.brand { brandLabel.text = brand } else { brandLabel.text = &quot;No Data&quot; }
    if let model = carDetailViewModel.carDetail?.features?.model { modelLabel.text = model } else { modelLabel.text = &quot;No Data&quot; }
    if let km = carDetailViewModel.carDetail?.features?.km { kmLabel.text = &quot;\(km)km&quot; } else { kmLabel.text = &quot;No Data&quot; }
    if let year = carDetailViewModel.carDetail?.features?.year { yearLabel.text = &quot;\(year)&quot; } else { kmLabel.text = &quot;No Data&quot; }
    if let version = carDetailViewModel.carDetail?.features?.carVersion { versionLabel.text = version } else { versionLabel.text = &quot;No Data&quot;}
    if let gearType = carDetailViewModel.carDetail?.features?.gearType { gearTypeLabel.text = gearType } else { gearTypeLabel.text = &quot;No Data&quot; }
    if let fuelType = carDetailViewModel.carDetail?.features?.fuelType { fuelTypeLabel.text = fuelType } else { fuelTypeLabel.text = &quot;No Data&quot;}
    if let price = carDetailViewModel.carDetail?.features?.price { priceLabel.text = &quot;\(price)&quot; } else { priceLabel.text = &quot;No Data&quot; }
}
</code></pre>
","13125522","","","","","2021-08-19 14:19:40","Why data existing in model cannot be displayed in UILabel","<swift><combine>","0","4","","","","CC BY-SA 4.0"
"68874223","1","69198997","","2021-08-21 15:08:37","","1","147","<p>There are several methods within Combine like...</p>
<ul>
<li><code>breakpointOnError()</code></li>
<li><code>breakpoint(receiveSubscription:receiveOutput:receiveCompletion:)</code></li>
</ul>
<p>What happens if you forget to remove these and it goes into a release build? Does the compiler pass them over because there's a release flag on the build or do I risk an exception?</p>
","4475605","","","","","2021-11-18 05:37:52","Using breakpointOnError() in Combine","<ios><swift><debugging><combine>","2","3","","","","CC BY-SA 4.0"
"68903699","1","","","2021-08-24 07:50:24","","0","180","<p>I have a source publisher, and have an another publisher rely source publisher.
This is playground test code for my situation:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

typealias Image = Int

enum NetError: Error {
    case invalidImage
}

func convertImageToVideo(_ image: Image) -&gt; AnyPublisher&lt;Image, NetError&gt; {
    Future { promise in
        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
            if image == 20 {
                promise(.failure(.invalidImage))
            } else {
                promise(.success(image))
            }
        }
    }
    .eraseToAnyPublisher()
}

var image = PassthroughSubject&lt;Image, NetError&gt;()

let subscription = image
    .map { image in
        convertImageToVideo(image)
    }
    .switchToLatest()
    .sink { completion in
        if case let .failure(error) = completion {
            print(&quot;Receive error: \(error)&quot;)
        }
    } receiveValue: { video in
        print(&quot;Receive new video: \(video)&quot;)
    }

image.send(0)
image.send(20)
image.send(40)

DispatchQueue.main.async {
    image.send(20)
}

DispatchQueue.main.asyncAfter(deadline: .now() + 4) {
    print(&quot;Send 50 into image.&quot;)
    image.send(50)
}
</code></pre>
<p>But I only receive one error in console:</p>
<pre><code>Receive error: invalidImage
</code></pre>
<p>This is not ideal, I want continue receive value even if convertImageToVideo method occur an error.
So I change code:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine
import PlaygroundSupport

PlaygroundPage.current.needsIndefiniteExecution = true

typealias Image = Int

enum NetError: Error {
    case invalidImage
}

func convertImageToVideo(_ image: Image) -&gt; AnyPublisher&lt;Image, NetError&gt; {
    Future { promise in
        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
            if image == 20 {
                promise(.failure(.invalidImage))
            } else {
                promise(.success(image))
            }
        }
    }
    .eraseToAnyPublisher()
}

var image = PassthroughSubject&lt;Image, NetError&gt;()

let subscription = image
    .map { image -&gt; AnyPublisher&lt;Result&lt;Image, NetError&gt;, Never&gt; in
        convertImageToVideo(image)
            .map { video in
                .success(video)
            }
            .catch({ error in
                Just(.failure(error))
            })
            .eraseToAnyPublisher()
    }
    .switchToLatest()
    .sink { completion in
        if case let .failure(error) = completion {
            print(&quot;Receive error: \(error)&quot;)
        }
    } receiveValue: { video in
        print(&quot;Receive new video: \(video)&quot;)
    }

image.send(0)
image.send(20)
image.send(40)

DispatchQueue.main.async {
    image.send(20)
}

DispatchQueue.main.asyncAfter(deadline: .now() + 4) {
    print(&quot;Send 50 into image.&quot;)
    image.send(50)
}
</code></pre>
<p>This time output is ideal:</p>
<pre><code>Receive new video: failure(__lldb_expr_64.NetError.invalidImage)
Send 50 into image.
Receive new video: success(50)
</code></pre>
<p>But the error not come from <code>completion</code> closure, instead of it come from <code>new value</code> closure, I must handle error from <code>complete</code> closure and <code>new value</code> closure.
Anyone has good idea? Thanks!</p>
","7969929","","","","","2021-09-25 00:35:05","Combine map with switchToLatest confuse","<swift><combine>","1","4","","","","CC BY-SA 4.0"
"68910423","1","68910499","","2021-08-24 15:51:49","","-1","838","<p>I am trying to fetch data by Restcountries API, but there is a problem. When I try to fetch data the error immediately shows up:</p>
<blockquote>
<p>2021-08-24 17:36:44.851463+0200 Countries[1498:19786] Task &lt;3FF6E673-52AD-47FE-9342-229E2CE99859&gt;.&lt;1&gt; finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 &quot;cancelled&quot; UserInfo={NSErrorFailingURLStringKey=https://restcountries.eu/rest/v2/all, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=https://restcountries.eu/rest/v2/all}</p>
</blockquote>
<p>It shows every single time. Any idea how to resolve that?</p>
<p>APIService:</p>
<pre><code>final class APIService: APIServiceProtocol {


func fetchAllCountries(url: URL) -&gt; AnyPublisher&lt;[Country], APIError&gt; {
    
    let request = URLRequest(url: url)
    
    return URLSession.DataTaskPublisher.init(request: request, session: .shared)
        .tryMap { data, response in
            guard let httpResponse = response as? HTTPURLResponse, 200..&lt;300 ~= httpResponse.statusCode else {
                throw APIError.unknown
            }
            
            return data
    }
    .decode(type: [Country].self, decoder: JSONDecoder())
    .mapError { error in
        if let error = error as? APIError {
            return error
        } else {
            return APIError.apiError(reason: error.localizedDescription)
        }
    }
    .eraseToAnyPublisher()
}

}
</code></pre>
<p>ListViewModel:</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

class ListViewModel: ObservableObject {
    
    private let apiService: APIServiceProtocol
    @Published var countries = [Country]()
    
    init(apiService: APIServiceProtocol = APIService()) {
        self.apiService = apiService
    }
    
    func fetchCountries() {
        
        guard let url = URL(string: &quot;https://restcountries.eu/rest/v2/all&quot;) else { return }
        
        let publisher = apiService.fetchAllCountries(url: url)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    print(error.localizedDescription)
                }
            }, receiveValue: { data in
                self.countries = data
                print(data)
        })
        publisher.cancel()
    }
    
}
</code></pre>
","11056400","","366492","","2021-08-31 10:50:23","2021-08-31 10:50:23","Swift Combine: finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 ""cancelled""","<ios><swift><nsurl><combine>","1","0","","","","CC BY-SA 4.0"
"68922703","1","","","2021-08-25 12:12:15","","0","198","<p>I made a custom SearchBar with SwiftUI and put it in the view, having <code>BookListViewModel</code> as <code>@ObservedObject</code>, but how do it call <code>fetchBooks()</code> from <code>BookListViewModel</code> and show as list?</p>
<p>Here is my <code>SearchView()</code></p>
<pre><code>struct SearchView: View {
    @ObservedObject var bookListVM : BookListViewModel
    
    var body: some View {
        VStack {
            SearchBar(searchText: $bookListVM.keyword)
            Text(&quot;\(bookListVM.keyword)&quot;)
        
            if bookListVM.keyword.count &gt; 0 {
                List(bookListVM.books, id: \.id) { bookVM in
                    NavigationLink(
                        destination: BookDetailView(id: bookVM.id),
                        label: {
                            Text(&quot;\(bookVM.title)&quot;)
                        })
                }                
            } else {
                Text(&quot;Please Search Your Item&quot;)
                Spacer()
            }
        }
    }
}
</code></pre>
<p>and in the <code>BookListViewModel</code>,</p>
<pre><code>class BookListViewModel: ObservableObject {
    @Published public private(set) var books: [BookViewModel] = []
    private var cancellable: AnyCancellable?
    @Published var keyword : String = &quot;&quot;
    
    init() {
        self.keyword = keyword
        self.fetchBooks()
    }
    
    func fetchBooks() {
        self.cancellable = Webservice().getSearchBooks(keyword: self.keyword).map { books in
            books.map { BookViewModel(book: $0) }
        }
            .sink(receiveCompletion: { completion in
                if case .failure(let err) = completion {
                    print(&quot;Retrieving data failed with error \(err)&quot;)
                }
            }, receiveValue: { bookViewModel in
                self.books = bookViewModel
                print(bookViewModel)
            })
    }
}

class BookViewModel: ObservableObject {
    let book: Book
    let id: String
    var title: String
    
    init(book: Book){
        self.book = book
        self.id = book.isbn13
        self.title = book.title
    }
}
</code></pre>
<p>and my <code>Webservice</code>, function <code>getSearchBooks()</code></p>
<pre><code>func getSearchBooks(keyword: String) -&gt; AnyPublisher&lt;[Book], Error&gt; {
        URLSession.shared.dataTaskPublisher(for: EndPoint.books(keyword).url)
            .receive(on: RunLoop.main)
            .map{ $0.data }
            .decode(type: BooksData.self, decoder: JSONDecoder())
            .map{$0.books}
            .catch { _ in Empty&lt;[Book], Error&gt;()}
            .eraseToAnyPublisher()
    
    }
</code></pre>
<p>What did I do wrong? Any advice will be appreciated. Thanks in advance!</p>
","16750205","","","","","2021-08-25 13:28:35","SwiftUI SearchBar keyword not publishing value to viewModel","<ios><json><swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"68928354","1","68942288","","2021-08-25 18:47:11","","2","172","<p>I have a somewhat complicated architecture for a feature in my app.</p>
<p>Sample code is below. My original expectation was that this would only print once, because I call <code>cancellableSet.removeAll()</code>. But this actually ends up being called twice, which creates problems in my application.</p>
<p>How do I get this so it only fires what's in the <code>sink</code> after the subscription is stored in the cancellable set.</p>
<p>Note that I have a few restrictions here that I'll mention. My sample code is just simplifying this.</p>
<ul>
<li>Can't use a <code>take</code> or <code>drop</code> operation, as this may get called an undetermined amount of times.</li>
</ul>
<pre><code>import Combine

enum State {
    case loggedOut
    case doingSomething
}

let aState = CurrentValueSubject&lt;State, Never&gt;(.doingSomething)
private var cancellableSet: Set&lt;AnyCancellable&gt; = []

func logUserOut() {
    cancellableSet.removeAll()
    aState.send(.loggedOut)
}

func doSomethingElse() { }
aState.sink { newState in
    print(&quot;numberOfSubscriptions is: \(cancellableSet.count)&quot;)
    switch newState {
    case .loggedOut:
        doSomethingElse()
    case .doingSomething:
        logUserOut()
    }
    
}
.store(in: &amp;cancellableSet)
</code></pre>
","9718260","","9718260","","2021-08-25 20:15:23","2021-08-26 16:31:23","How do I cancel a combine subscription within a sink?","<swift><combine>","2","9","","","","CC BY-SA 4.0"
"68938792","1","68939264","","2021-08-26 12:46:58","","0","187","<p>I'm currently trying to modify an upcoming value from a textField which is using a <code>Binding&lt;Double&gt;</code>, but haven't found any working solution yet. It's only been infinite loops (Like the example below) and other solutions which didn't work in the end anyway. So, for example, if an user inputs an amount which is too low, I would want to change the upcoming value to the minimum and vice verse if the value is higher than the maximum value.</p>
<p>I also want to present the <code>modified</code> value (if needed) for the user, so I can't just store it in another variable.</p>
<p>Any ideas on how to solve this?</p>
<h3>Example</h3>
<pre><code>class ViewModel: ObservableObject {
    @Published var amount: Double

    private var subscriptions: Set&lt;AnyCancellable&gt; = []
    private let minimum: Double = 10_000
    private let maximum: Double = 100_000

    init() {
        $amount
            .sink {
                if $0 &lt; self.minimum {
                    // Set minimum value
                    self.amount = self.minimum
                } else if $0 &gt; self.maximum {
                    // Set maximum value
                    self.amount = self.maximum
                }

                // If `Else` is implemented it will just be an infinite loop...
                else {
                    self.amount = $0
                }
            }
            .store(in: &amp;subscriptions)
    }

    func prepareStuff() {
        // Start preparing
        let chosenAmount = amount
    }
}
</code></pre>
","7653367","","7653367","","2021-08-26 12:52:09","2021-08-26 13:49:12","Update upcoming values in sink if needed","<swift><swiftui><combine>","1","0","0","","","CC BY-SA 4.0"
"68957875","1","","","2021-08-27 18:20:35","","0","747","<p>Given an hierarchical structure of <code>@OberservableObject</code>s - I often find myself in a situation where I need a publisher which provides some kind of updated aggregate of the entire structure (the example below calculates a sum, but it could be anything)</p>
<p>Below is the solution I have come up with - which kinda works, but also not... :)</p>
<p>Problem #1: It looks way to complicated - and I feel I am missing something...</p>
<p>Problem #2: It does not work as the $foo publisher on top does emit changes to foo before foo changes, which are then not present in the second self.$foo publisher (which shows the old state).</p>
<p>Sometimes I need the aggregate in sync with swiftUI view updates - so that I need to utilize the @Published value and no separate publisher that emits during didSet of the variable.</p>
<p>I did not find a good solution... So how would you guys resolve this?</p>
<pre><code>class Foo:ObservableObject {
    @Published var bar:Int = 0
}


class Foobar:ObservableObject {
    
    @Published var foo:[Foo] = []
    
    var sumPublisher:AnyPublisher&lt;Int,Never&gt; {
        
        // Whenever the foo array or one of the foo.bar values change
        //
        $foo
            .map { fooArray in
                Publishers.MergeMany( fooArray.map { foo in foo.$bar } )
            }
            .switchToLatest()
            
            // Calclulate a new sum by collecting and reducing all foo.bar values.
            //
            .map { [unowned self] _ in
                self.$foo // &lt;--- in case of a foo change, this is still the unchanged foo, therefore not correct.
                    .map { fooArray -&gt; AnyPublisher&lt;Int,Never&gt; in
                        Publishers.MergeMany( fooArray.map { foo in foo.$bar.first() } )
                            .collect()
                            .map { barArray -&gt; Int in
                                barArray.reduce(0, { $0 + $1 })
                            }
                            .eraseToAnyPublisher()
                    }
                    .switchToLatest()
            }
            .switchToLatest()
            .removeDuplicates()
            .eraseToAnyPublisher()
    }
    
}
</code></pre>
","10851991","","","","","2021-08-28 16:16:01","How to best create a publisher aggregate of @Published values in Combine?","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"68962229","1","","","2021-08-28 07:30:00","","1","626","<p>I'm working on some code and trying to use Combine to streamline the process. So far I have a list of objects, each of which has a property that returns a <code>Publisher</code>. The objects conform to a protocol and I'm trying to do something like this:</p>
<pre class=""lang-swift prettyprint-override""><code>protocol StringPublisher {
    var stringValues: AnyPublisher&lt;String, Error&gt; { get }
}

let objArray:[StringPublisher] = [StringPublisher1(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), StringPublisher2(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;)]

let results: [String] = objArray.?
</code></pre>
<p>So what I'm trying to do with this is to read the <code>objArray</code> instances in sequence, get each one's <code>stringValues</code> publisher and process the values it produces until it finishes, then listen for values from the next one until it finishes and so on. So the above would give:</p>
<pre><code>a
b
c
x
y
z
</code></pre>
<p>I think I need to do something like this:</p>
<pre class=""lang-swift prettyprint-override""><code>let results:[String] = objArray.flatMap(maxPublishers: .max(1)) { $0.stringValues }.sink { value in
    print(value)
}
</code></pre>
<p>But I'm still trying to get this all to compile and work.</p>
<p>Has anyone tried something like this and how did you combine the results from publishers in multiple objects?</p>
","247090","","","","","2021-08-28 07:52:25","Swift Combine: How do I merge the results from several nested Publishers?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"68962673","1","69322063","","2021-08-28 08:36:17","","1","460","<p>I have some code like this</p>
<pre class=""lang-swift prettyprint-override""><code>func a() -&gt; AnyPublisher&lt;Void, Never&gt; {
    Future&lt;Void, Never&gt; { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            print(1)
            promise(.success(()))
        }
    }
    .eraseToAnyPublisher()
}

func b() -&gt; AnyPublisher&lt;Void, Never&gt; {
    Future&lt;Void, Never&gt; { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            print(2)
            promise(.success(()))
        }
    }
    .eraseToAnyPublisher()
}

var tempBag = Set&lt;AnyCancellable&gt;()

let subject = CurrentValueSubject&lt;Int, Never&gt;(1)

subject
    .flatMap({ _ in a() })
    .flatMap({ _ in b() })
    .print()
    .sink(receiveCompletion: { _ in
        tempBag.removeAll()
    }, receiveValue: {  })
    .store(in: &amp;tempBag)
</code></pre>
<p>So, I have some uncompletable subject in the root of the stream and some completable publishers in flatMap operator. I want the overall stream to complete when the last flatMap's publisher completes. So, I want the console to look like this:</p>
<pre><code>receive subscription: (FlatMap)
request unlimited
1
2
receive value: (())
receive finished
</code></pre>
<p>but actual result is</p>
<pre><code>receive subscription: (FlatMap)
request unlimited
1
2
receive value: (())
</code></pre>
<p>How can I achieve this?</p>
","9174707","","","","","2021-09-24 23:48:15","How make Combine's flatMap to complete overall stream?","<ios><swift><combine>","1","1","0","","","CC BY-SA 4.0"
"68988218","1","68988332","","2021-08-30 17:37:25","","0","167","<p>I have the following model:</p>
<pre><code>struct Book: Codable, Identifiable {
    var id: Int
    var title: String
    var author: String
}

struct BookWrapper: Codable {
    var books: [Book]

}
</code></pre>
<p>and JSON:</p>
<pre><code>{
  &quot;books&quot;: [
    {
        &quot;id&quot;:     1,
        &quot;title&quot;:  &quot;Nineteen Eighty-Four: A Novel&quot;,
        &quot;author&quot;: &quot;George Orwell&quot;
    }, {
        &quot;id&quot;:     2,
        &quot;title&quot;:  &quot;Animal Farm&quot;,
        &quot;author&quot;: &quot;George Orwell&quot;
    }
  ],
  &quot;errMsg&quot;: null
}
</code></pre>
<p>I'm trying to grab data using Combine, but cannot find a way how to go around that books array. In case of <em>flat</em> data I would use following:</p>
<pre><code>func fetchBooks() {
        URLSession.shared.dataTaskPublisher(for: url)
            .map{ $0.data }
            .decode(type: [Book].self, decoder: JSONDecoder())
            .replaceError(with: [])
            .eraseToAnyPublisher()
            .receive(on: DispatchQueue.main)
            .assign(to: &amp;$books)
    }   
</code></pre>
<p>I tried to use BookWrapper.self, but it doesn't make sense. Is there any elegant way how to solve it?</p>
","183112","","9607863","","2021-08-30 18:25:52","2021-08-30 18:25:52","Combine and nested JSON objects","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"68998373","1","69013828","","2021-08-31 12:05:06","","3","1370","<p>This is a general question about SwiftUI and the architecture, so I'll take a simple but problematic example.</p>
<h1>Initial project :</h1>
<p>I have a first <code>View</code> which displays a list of <code>Item</code>s. This list is managed by a class (which I called <code>ListViewModel</code> here). In a second view I can modify one of these <code>Item</code>s, and save these modifications with a &quot;save&quot; button. In a simplified version, I can do this easily using <code>@Binding</code>. Thanks SwiftUI:</p>
<pre><code>struct ListView: View {
    @StateObject var vm = ListViewModel()
    var body: some View {
        NavigationView {
            List(Array(vm.data.enumerated()), id: \.1.id) { index, item in
                NavigationLink(destination: DetailView(item: $vm.data[index])) {
                    Text(item.name)
                }
            }
        }
    }
}

struct DetailView: View {
    @Binding var initialItem: Item
    @State private var item: Item
    init(item: Binding&lt;Item&gt;) {
        _item = State(initialValue: item.wrappedValue)
        _initialItem = item
    }
    var body: some View {
        VStack {
            TextField(&quot;name&quot;, text: $item.name)
            TextField(&quot;description&quot;, text: $item.description)
            Button(&quot;save&quot;) {
                initialItem = item
            }
        }
    }
}

struct Item: Identifiable {
    let id = UUID()
    var name: String
    var description: String
    static var fakeItems: [Item] = [.init(name: &quot;My item&quot;, description: &quot;Very good&quot;), .init(name: &quot;An other item&quot;, description: &quot;not so bad&quot;)]
}

class ListViewModel: ObservableObject {
    @Published var data: [Item] = Item.fakeItems
    func fetch() {}
    func save() {}
    func sort() {}
}
</code></pre>
<h1>Problem :</h1>
<p>Things get more complicated when the detail / edit view gets more complex. Its number of properties increases, we must set up code that does not concern the <code>View</code> (networking, storage, etc.), possibly an FSM, so we have another <code>class</code> to manage the <code>DetailView</code> (in my example: <code>DetailViewModel</code>).</p>
<p>And now the communication between the two Views, which was so easy with the <code>@Binding</code> becomes complicated to set up. In our example, these two elements are not linked, so we have to set up a two-way-binding :</p>
<pre><code>class ListViewModel: ObservableObject {
    @Published var data: [Item]     &lt;-----------
    func fetch() {}                             |
    func save() {}                              |
    func sort() {}                              |
}                                               | /In Search Of Binding/
                                                |
class DetailViewModel: ObservableObject {       |
    @Published var initialItem: Item &lt;----------
    @Published var item: Item
                                                
    init(item: Item) {
        self.initialItem = item
        self.item = item
    }
    func fetch() {}
    func save() {
        self.initialItem = item
    }
}
</code></pre>
<h1>Attempts</h1>
<h2>1. An array of DetailViewModels in the ListViewModel + Combine</h2>
<p>Rather than storing an <code>Array</code> of <code>Item</code>, my <code>ListViewModel</code> could store a <code>[DetailViewModel]</code>. So during initialization it could subscribe to changes on <code>DetailViewModel</code>s :</p>
<pre><code>class ListViewModel: ObservableObject {
    @Published var data: [DetailViewModel]
    var bag: Set&lt;AnyCancellable&gt; = []

    init(items: [Item] = Item.fakeItems) {
        data = items.map(DetailViewModel.init(item:))
        subscribeToItemsChanges()
    }
    func subscribeToItemsChanges() {
        data.enumerated().publisher
            .flatMap { (index, detailVM) in
                detailVM.$initialItem
                    .map{ (index, $0 )}
            }
            .sink { [weak self] index, newValue in
                self?.data[index].item = newValue
                self?.objectWillChange.send()
            }
            .store(in: &amp;bag)
    }
}
</code></pre>
<p><strong>Results :</strong>
Ok, that works, although it's not really a two-way-binding.
But is it really relevant that a ViewModel contains an array of other ViewModels?
a) It smells weird. b) We have an array of references (and no data types). c) we end up with that in the View:</p>
<pre><code>List(Array(vm.data.enumerated()), id: \.1.item.id) { index, detailVM in
                NavigationLink(destination: DetailView(vm: detailVM)) {
                    Text(detailVM.item.name)
                }
            }
</code></pre>
<h2>2. Give to DetailViewModel the reference of ListViewModel (Delegate style)</h2>
<p>Since the <code>DetailViewModel</code> does not contain the array of <code>Item</code>s, and since the <code>Item</code> it handles no longer has a <code>@Binding</code>: we could pass the <code>ListViewModel</code> (which contains the array) to each <code>DetailViewModel</code>.</p>
<pre><code>protocol UpdateManager {
    func update(_ item: Item, at index: Int)
}

class ListViewModel: ObservableObject, UpdateManager {
    @Published var data: [Item]
    init(items: [Item] = Item.fakeItems) {
        data = items
    }
    func update(_ item: Item, at index: Int) {
        data[index] = item
    }
}

class DetailViewModel: ObservableObject {
    @Published var item: Item
    private var updateManager: UpdateManager
    private var index: Int
    init(item: Item, index: Int, updateManager: UpdateManager) {
        self.item = item
        self.updateManager = updateManager
        self.index = index
    }
    func fetch() {}
    func save() {
        updateManager.update(item, at: index)
    }
}
</code></pre>
<p><strong>Results :</strong>
It works but : 1) It seems like an old way which doesn't quite match the style of SwiftUI. 2) We must pass the index of the Item to the DetailViewModel.</p>
<h2>3. Use a closure</h2>
<p>Rather than passing a reference to the entire <code>ListViewModel</code>, we could pass a closure (<code>onSave</code>) to the <code>DetailViewModel</code>.</p>
<pre><code>class ListViewModel: ObservableObject {
    @Published var data: [Item]
    init(items: [Item] = Item.fakeItems) {
        data = items
    }
    func update(_ item: Item, at index: Int) {
        data[index] = item
    }
}

class DetailViewModel: ObservableObject {
    @Published var item: Item
    var update: (Item) -&gt; Void
    init(item: Item, onSave update: @escaping (Item) -&gt; Void) {
        self.item = item
        self.update = update
    }
    func fetch() {}
    func save() {
        update(item)
    }
}
</code></pre>
<p><strong>Results:</strong>
On one hand it still looks like an old approach, on the other hand it seems to match the &quot;one view - one ViewModel&quot; approach. If we use an FSM we could imagine sending an Event / Input.</p>
<p><em><strong>Variant:</strong></em>
We can use Combine and pass a <code>PassthroughSubject</code> rather than a closure :</p>
<pre><code>class ListViewModel: ObservableObject {
    @Published var data: [Item]
    var archivist = PassthroughSubject&lt;(Int, Item), Never&gt;()
    var cancellable: AnyCancellable?
    init(items: [Item] = Item.fakeItems) {
        data = items
        cancellable = archivist
            .sink {[weak self ]index, item in
                self?.update(item, at: index)
            }
    }
    func update(_ item: Item, at index: Int) {
        data[index] = item
    }
}

class DetailViewModel: ObservableObject {
    @Published var item: Item
    var index: Int
    var archivist: PassthroughSubject&lt;(Int, Item), Never&gt;
    init(item: Item, saveWith archivist: PassthroughSubject&lt;(Int, Item), Never&gt;, at index: Int) {
        self.item = item
        self.archivist = archivist
        self.index = index
    }
    func fetch() {}
    func save() {
        archivist.send((index, item))
    }
}
</code></pre>
<h1>Question :</h1>
<p>I could also have used an <code>@Binding</code> in my <code>ObservableObject</code>, or even wrapped my <code>Item</code> array in an other <code>ObservableObject</code> (and therefore have an OO in an OO). But it seems even less relevant to me.</p>
<p>In any case, everything seems very complicated as soon as we leave a simple Model-View architecture: where a simple <code>@Binding</code> is enough.</p>
<p>So I ask for your help :
What do you recommend for this kind of scenario?
What do you think is the most suitable for SwiftUI?
Can you think of a better way?</p>
","16125496","","","","","2021-09-01 13:04:49","Communication between ViewModels with SwiftUI and Combine (ObservableObject vs Binding)","<swift><swiftui><combine>","1","2","2","","","CC BY-SA 4.0"
"69003260","1","69003276","","2021-08-31 17:48:27","","-1","154","<p>I have a custom Publisher that takes in a String key and emits values when data for that key changes. Say it's called <code>MyCustomPublisher</code>.</p>
<p>I have a function that I want to take in an instance of <code>MyCustomPublisher</code>, transform the value into a different key, and then create a separate instance of <code>MyCustomPublisher</code>. This looks like this:</p>
<pre><code>    let myInfoProvider: MyCustomPublisher = ...
    myInfoProvider.tryMap { v -&gt; Database in
        guard let value = v else { throw &quot;No value provided&quot; }
        return value
    }
    .map { v in
        MyCustomPublisher(key: v)
    }
    .switchToLatest()
    .tryMap { v -&gt; String in
        guard let value = v else {
            throw &quot;No value found&quot;
        }
        
        return value
    }
</code></pre>
<p>Given that the data is a String, I would like the output type to be <code>AnyPublisher&lt;String, Error&gt;</code>, but the actual type reported by Swift is <code>Publishers.TryMap&lt;Publishers.SwitchToLatest&lt;MyCustomPublisher, Publishers.TryMap&lt;MyCustomPublisher, MyCustomPublisher&gt;&gt;, String&gt;</code>. How can I make this conform to AnyPublisher&lt;String, Error&gt;?</p>
","887128","","","","","2021-08-31 17:50:24","Is there a way to simplify Swift combine types?","<swift><combine>","1","0","","2021-08-31 17:55:38","","CC BY-SA 4.0"
"69015207","1","69015951","","2021-09-01 13:57:45","","2","230","<p>I'm developing an existing Android Kotlin app for IOS Swift UI.</p>
<p>In Kotlin when using Gson, I had a Client model class:</p>
<pre><code>abstract class Client(
        @SerializedName(&quot;nombre&quot;)
        var name: String? = null,
        @SerializedName(value=&quot;cliente_id&quot;, alternate = [&quot;id&quot;])
        var client_id: Int = -1,
)
</code></pre>
<p>As you can see, I use <code>@SerializedName()</code> to give Client property <code>name</code> or <code>client_id</code> an alter name. I do this because when I get the data from the API, Client Json has &quot;nombre&quot; and not &quot;name&quot; as I want. So <code>@SerializedName()</code> makes possible to detect &quot;nombre&quot; in JSON as &quot;name&quot; or detect &quot;cliente_id&quot; as &quot;client_id&quot; in Kotlin model Classes. This way I can read data from API using my own property names.</p>
<p>Well, now I'm facing the same issue in Swift. I want to use my own property names and not the API JSON property names.</p>
<p>My swift Client model class looks like this:</p>
<pre><code>class Client: Identifiable, Decodable{
    
    init(id: Int, token: String) {
        self.cliente_id = id
        self.token = token
    }
    
    let cliente_id: Int
    let token: String
}
</code></pre>
<p>And I get client data from API like this:</p>
<pre><code>let request = AF.request(
    url, method: .post,
    parameters: parameters,
    encoder: JSONParameterEncoder.default
)

request.validate(statusCode: 200...299)
request.responseDecodable(of: Client.self) { response in
    if let loginResponse = response.value{//Success
        loginPublisher.send(loginResponse)
    }
    else{//Failure
        loginPublisher.send(completion: Subscribers.Completion&lt;NetworkError&gt;.failure(.thingsJustHappen))
    }
}
</code></pre>
<p>In order to be able to use <code>Client</code> a decodable, <code>Client</code> has to implement <code>Decodable</code>. Well, all I want is Client to has <code>id</code> and not <code>cliente_id</code> as a property name.</p>
<p>Something like</p>
<pre><code>class Client: Identifiable, Decodable{

    init(id: Int, token: String) {
        self.id = id
        self.token = token
    }

    @NameforDecode(&quot;cliente_id&quot;)
    let id: Int
    let token: String
}
</code></pre>
<p>Is this possible?</p>
","15860448","","","","","2021-09-01 17:54:31","Set an Alter name for property in Decodable class | Swift","<swift><kotlin><alamofire><combine><decodable>","1","1","","","","CC BY-SA 4.0"
"69015928","1","","","2021-09-01 14:42:28","","0","566","<p>I have a publisher that never emits items and only completes or fails with an error (<code>AnyPublisher&lt;Never, Error&gt;</code>). I want to transform that publisher into a publisher that emits a value when the first publisher completes (<code>AnyPublisher&lt;Value, Error&gt;</code>), or passes through any error. I want to create that value after completion of the first publisher. I could do something like this, but it seems quite messy:</p>
<pre class=""lang-swift prettyprint-override""><code>func demo() -&gt; AnyPublisher&lt;Int, Error&gt; {
    // Using Empty just for demo purposes
    let firstPublisher = Empty&lt;Never, Error&gt;(completeImmediately: true).eraseToAnyPublisher()
    var cancellable: AnyCancellable?
    return Future&lt;Int, Error&gt; { promise in
        cancellable = firstPublisher
            .sink { completion in
                switch completion {
                case .failure(let error):
                    promise(.failure(error))
                case .finished:
                    // some operation that generates value
                    let value:Int = 1
                    promise(.success(value))
                }
            } receiveValue: { _ in
            }
    }
    .handleEvents(receiveCancel: {
        cancellable?.cancel()
    })
    .eraseToAnyPublisher()
}
</code></pre>
<p>Can this be done a better way? Something like:</p>
<pre><code>extension AnyPublisher {
    func completionMap&lt;T, P&gt;(_: (_ completion: Subscribers.Completion&lt;Self.Failure&gt;) -&gt; P) -&gt; P where P: Publisher, T == P.Output, Self.Failure == P.Failure {
        /// ???
    }
}
func demo() -&gt; AnyPublisher&lt;Int, Error&gt; {
    // Using Empty just for demo purposes
    let firstPublisher = Empty&lt;Never, Error&gt;(completeImmediately: true).eraseToAnyPublisher()
    return firstPublisher
        .completionMap { completion -&gt; AnyPublisher&lt;Int, Error&gt; in
            switch completion {
            case .failure(let error):
                return Fail(error: error).eraseToAnyPublisher()
            case .finished:
                // some operation that generates value
                let value:Int = 1
                return Just(value).setFailureType(to: Error.self).eraseToAnyPublisher()
            }
    }.eraseToAnyPublisher()
}
</code></pre>
","392986","","392986","","2021-09-01 15:30:48","2021-09-03 06:55:50","Create a publisher that emits a value on completion of another publisher","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"69016576","1","","","2021-09-01 15:22:07","","1","183","<p>I have a <code>Set&lt;AnyCancellable&gt;</code> that is tied to the user's session. Any subscriptions tied to the user session get added to this set. I'd like to be able to pass this set around so other things can tie their logic to the user's session. The issue I'm having is that Set is struct that passing it via <code>inout</code> won't really work. Is there a better way to share a <code>Set&lt;AnyCancellable&gt;</code>?</p>
<p>Here is an example of what I'd like to do:</p>
<pre><code>class UserManager {
  private var cancellable: Set&lt;AnyCancellable&gt;

  init(cancellable: Set&lt;AnyCancellable&gt;) {
    self.cancellable = cancellable
  }
}

class UserFeedManager {
  private var cancellable: Set&lt;AnyCancellable&gt;

  init(cancellable: Set&lt;AnyCancellable&gt; {
     self.cancellable = cancellable
  }
}

let cancellable = Set&lt;AnyCancellable&gt;()
let userManager = UserManager(cancellable)
let userFeedManager = UserFeedManager(cancellable)

// ... Later, once the user signs out, clean up any work 
// started by the UserManager or the UserFeedManager
cancellable.forEach { $0.cancel() }
cancellable.removeAll()
</code></pre>
","887128","","887128","","2021-09-01 15:37:11","2021-09-03 18:41:27","How to share a Set<AnyCancellable>?","<swift><combine>","2","4","","","","CC BY-SA 4.0"
"69050183","1","","","2021-09-03 20:18:09","","0","188","<p>Premis. I have a BLE (Bluetooth low energy) peripheral that will stream some data that it has recorded. I am using the BlueJay (<a href=""https://github.com/steamclock/bluejay"" rel=""nofollow noreferrer"">https://github.com/steamclock/bluejay</a>) package to interface with the BLE peripheral.</p>
<p>the peripheral will start streaming after I write to its &quot;startDownload&quot; characteristic, I will also need to subscribe to its download service before calling &quot;startDownload&quot; characteristic.</p>
<p>Goal:
I want to do this using combine as it will make my life easier as the app is made using SwiftUI. I have started to use combine recently and I am not as proficient with it as I would like to be (still a combine noob, leaving the world of old UIKit is hard :) ).</p>
<p>So BluJay will update my code using a callback closure and I want to wrap it in a publisher that will send an update every time I get a new block of data in. Bonus would be to add a progress report somewhere in the chain of operators.</p>
<p>this is how I would like it to be used</p>
<pre><code>BLEmanager.startDownload()
   .someOperator{ dataBlock in
       //validate that block is valid 
   }
   .someOperator{ progress in // optional and not currently needed
       self.progress = progress
   }
   .sink{ completion in
       switch completion{
       case .finished:
           //update ui as download is completed
       case .failure(let error):
           // deal with error
   } receiveValue:{
        //add the data to already received data
   }.store(in: &amp;storage) 
</code></pre>
<p>(Edit: added the receiveValue block)</p>
<p>ok so a BlueJay IPA looks like this :</p>
<pre><code>let characteristic = CharacteristicIdentifier(uuid: BLEModel.FileDownload.Characteristics.dataUUID,
                                                      service: ServiceIdentifier(uuid: BLEModel.FileDownloadInfo.serviceUUID))
    
        startListen(characteristic) {(result: ReadResult&lt;Data&gt;) in
            switch result {
            case .success(_):
                //we got new data to process and concatenated to previously received data. 
            case .failure(let error):
                // fire error
            }
        }
</code></pre>
<p>and this code would sit inside the startDownload() method.
every time a new block of data is received we report it to the downstream publisher and then it gets validated, then again passed down the chain, optionally the progress is reported and then the new block is added to the previous data collected.</p>
<p>I saw this <a href=""https://stackoverflow.com/questions/62131257/swift-combine-future-with-multiple-values"">Swift Combine Future with multiple values?</a> but it only sends progress and internally stacks the frames/data. This is kind of close to what I need but I am not sure how to change it to make it do what I need it to do.</p>
<p>Initially, I was hoping to be able to just use Future to report on every update but it looks like this is only good for 1 shot of data.</p>
<pre><code>func startDownload() -&gt; AnyPublisher&lt;Data, Error&gt; {
    Future{ callback in
        // BlueJay API calls 
        // but calling callback(.success(newData)) would as I understand it 
        // stop after the first time I report a success.. 
    }
    ereaseToAnyPublisher()
}
</code></pre>
<p>So I need to bridge from making a simple report using a Future publisher to making some streaming publisher.</p>
<p>Edit (09/09/2021):</p>
<p>So following New Dev's comment I coded this function.</p>
<pre><code>func startListenFileTransfer(rideSize size: UInt32, blockSize block: UInt32 = 200 ) -&gt; AnyPublisher&lt;Data, Error&gt;{
        let publisher = PassthroughSubject&lt;Data, Error&gt;()
        let characteristic = CharacteristicIdentifier(uuid: BikeBLEModel.FileDownloadInfo.Characteristics.dataUUID,
                                                      service: ServiceIdentifier(uuid: BikeBLEModel.FileDownloadInfo.serviceUUID))
        var fetchPageStartIndex: UInt32 = 0
        setFileDownloadStart()
        setReadSegment()
            startListen(characteristic) {[unowned self](result: ReadResult&lt;Data&gt;) in
                debugPrint(&quot;DEBUG listen result in page \(fetchPageStartIndex + 1)&quot;)
                switch result {
                case .success(let data):
                    publisher.send(data)
                    fetchPageStartIndex += 1
                    if fetchPageStartIndex &gt;= size {
                        debugPrint(&quot;DEBUG download done page recieved \(fetchPageStartIndex)&quot;)
                        publisher.send(completion: Subscribers.Completion.finished)
                        stopFileDownload()
                    }
                    else if fetchPageStartIndex % block == 0 {
                        fetchPageStartIndex += 1
                        debugPrint(&quot;DEBUG: - set meme segment at \(fetchPageStartIndex)&quot;)
                        setReadSegment(fetchPageStartIndex)
                    }
                case .failure(let error):
                    debugPrint(&quot;DEBUG Error: \(error)&quot;)
                    publisher.send(completion: Subscribers.Completion.failure(error))
                    stopFileDownload()
                }
            }
                        
        return publisher.eraseToAnyPublisher()
    }
</code></pre>
","796060","","796060","","2021-09-09 14:38:35","2021-09-09 14:38:35","Swift Combine: Publisher for recording BLE peripheral data stream","<swift><bluetooth-lowenergy><combine>","0","2","","","","CC BY-SA 4.0"
"69057605","1","69061704","","2021-09-04 17:34:17","","1","881","<p>I have an API Service handler implemented which uses an authentication token in the header of the request. This token is fetched when the user logs in at the launch of the application. After 30 minutes, the token is expired. Thus, when a request is made after this timespan, the API returns an 403 statuscode. The API should then login again and restart the current API request.</p>
<p>The problem I am encountering is that the login function to fetch a new token, makes use of a completion handler to let the calling code know if the asynchronous login procedure has been successful or not. When the API gets a 403 statuscode, it calls the login procedure and and when that is complete, it should make the current request again. But this repeated API request should return some value again. However, returning a value is not possible in a completion block. Does anyone know a solution for the problem as a whole?</p>
<p>The login function is as follows:</p>
<pre><code>func login (completion: @escaping (Bool) -&gt; Void) {
    
    self.loginState = .loading
    
    let preparedBody = APIPrepper.prepBody(parametersDict: [&quot;username&quot;: self.credentials.username, &quot;password&quot;: self.credentials.password])

    let cancellable = service.request(ofType: UserLogin.self, from: .login, body: preparedBody).sink { res in
        switch res {
        case .finished:
            if self.loginResult.token != nil {
                self.loginState = .success
                self.token.token = self.loginResult.token!

                _ = KeychainStorage.saveCredentials(self.credentials)
                _ = KeychainStorage.saveAPIToken(self.token)

                completion(true)
            }
            else {
                (self.banner.message, self.banner.stateIdentifier, self.banner.type, self.banner.show) = (&quot;ERROR&quot;, &quot;TOKEN&quot;, &quot;error&quot;, true)
                self.loginState = .failed(stateIdentifier: &quot;TOKEN&quot;, errorMessage: &quot;ERROR&quot;)
                completion(false)
            }
        case .failure(let error):
            (self.banner.message, self.banner.stateIdentifier, self.banner.type, self.banner.show) = (error.errorMessage, error.statusCode, &quot;error&quot;, true)
            self.loginState = .failed(stateIdentifier: error.statusCode, errorMessage: error.errorMessage)
            completion(false)
        }
    } receiveValue: { response in
        self.loginResult = response
    }
    
    self.cancellables.insert(cancellable)
}
</code></pre>
<p>The API service is as follows:</p>
<pre><code>func request&lt;T: Decodable&gt;(ofType type: T.Type, from endpoint: APIRequest, body: String) -&gt; AnyPublisher&lt;T, Error&gt; {
    
    var request = endpoint.urlRequest
    request.httpMethod = endpoint.method
    
    if endpoint.authenticated == true {
        request.setValue(KeychainStorage.getAPIToken()?.token, forHTTPHeaderField: &quot;token&quot;)
    }
    
    if !body.isEmpty {
        let finalBody = body.data(using: .utf8)
        request.httpBody = finalBody
    }
    
    return URLSession
        .shared
        .dataTaskPublisher(for: request)
        .receive(on: DispatchQueue.main)
        .mapError { _ in Error.unknown}
        .flatMap { data, response -&gt; AnyPublisher&lt;T, Error&gt; in
            
            guard let response = response as? HTTPURLResponse else {
                return Fail(error: Error.unknown).eraseToAnyPublisher()
            }
            
            let jsonDecoder = JSONDecoder()
            
            if response.statusCode == 200 {
                return Just(data)
                    .decode(type: T.self, decoder: jsonDecoder)
                    .mapError { _ in Error.decodingError }
                    .eraseToAnyPublisher()
            }
            else if response.statusCode == 403 {
                
                let credentials = KeychainStorage.getCredentials()
                let signinModel: SigninViewModel = SigninViewModel()
                signinModel.credentials = credentials!
        
                signinModel.login() { success in
                    
                    if success == true {
-------------------&gt;    // MAKE THE API CALL AGAIN AND THUS RETURN SOME VALUE
                    }
                    else {
-------------------&gt;    // RETURN AN ERROR
                    }
        
                }
    
            }
            else if response.statusCode == 429 {
                return Fail(error: Error.errorCode(statusCode: response.statusCode, errorMessage: &quot;Oeps! Je hebt teveel verzoeken gedaan, wacht een minuutje&quot;)).eraseToAnyPublisher()
            }
            else {
                do {
                    let errorMessage = try jsonDecoder.decode(APIErrorMessage.self, from: data)
                    return Fail(error: Error.errorCode(statusCode: response.statusCode, errorMessage: errorMessage.error ?? &quot;Er is iets foutgegaan&quot;)).eraseToAnyPublisher()
                }
                catch {
                    return Fail(error: Error.decodingError).eraseToAnyPublisher()
                }
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
","14855422","","560942","","2021-09-04 18:24:58","2021-09-06 11:46:34","Swift Combine Completion Handler with return of values","<swift><asynchronous><combine><completionhandler>","1","0","0","","","CC BY-SA 4.0"
"69066375","1","69067346","","2021-09-05 18:59:53","","0","96","<p>I have a NavigationManager to handle changing SwiftUI tab bar selection.</p>
<p>It work if it is set as a <code>@EnvironmentObject</code> in my SwiftUI views, but not when the NavigationManager is called as a service in my view models. The thing is that I would like to use a simpler solution than passing around <code>@EnvironmentObject var navigationManager</code> around and pass them inside view model initializer as I have a lot of them and I am looking for a cleaner approach.</p>
<p>How can I use my NavigationManager to change tabs from inside my view models without passing it in init()?</p>
<pre><code>import SwiftUI

struct ContentView: View {

  @StateObject var navigationManager = NavigationManager()

  var body: some View {
    TabView(selection: $navigationManager.selection) {
      AccountView()
        .tabItem {
          Text(&quot;Account&quot;)
          Image(systemName: &quot;person.crop.circle&quot;) }
        .tag(NavigationItem.account)

      SettingsView()
          .tabItem {
            Text(&quot;Settings&quot;)
            Image(systemName: &quot;gear&quot;) }
          .tag(NavigationItem.settings)
          .environmentObject(navigationManager)
    }
  }
}
</code></pre>
<p>The navigation manager that I would like to use within view models.</p>
<pre><code>class NavigationManager: ObservableObject {

  @Published var selection: NavigationItem = .account
}

enum NavigationItem {
  case account
  case settings
}
</code></pre>
<p>My AccountViewModel and Settings View Model:</p>
<pre><code>class AccountViewModel: ObservableObject {

  let navigationManager = NavigationManager()
}

struct AccountView: View {

  @StateObject var viewModel = AccountViewModel()

  var body: some View {
    VStack(spacing: 16) {
    Text(&quot;AccountView&quot;)
        .font(.title3)

      Button(action: {
        viewModel.navigationManager.selection = .settings
      }) {
        Text(&quot;Go to Settings tab&quot;)
          .font(.headline)
      }
      .buttonStyle(.borderedProminent)
    }
  }
}


class SettingsViewModel: ObservableObject {

  let navigationManager = NavigationManager()
}

struct SettingsView: View {

  @EnvironmentObject var navigationManager: NavigationManager

  @StateObject var viewModel = SettingsViewModel()

  var body: some View {
    VStack(spacing: 16) {
    Text(&quot;SettingsView&quot;)
        .font(.title3)

      Button(action: {
        navigationManager.selection = .account
      }) {
        Text(&quot;Go to Account tab&quot;)
          .font(.headline)
      }
      .buttonStyle(.borderedProminent)
    }
  }
}
</code></pre>
","10408494","","10408494","","2021-09-06 12:00:41","2021-09-06 12:00:41","How to create a NavigationManager that would change tab within view models?","<mvvm><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"69079152","1","69080024","","2021-09-06 18:53:36","","0","98","<p>I am fairly acquainted with memory management in swift, and I know that if in the capturing closure we use [unowned self] code will break, if self becomes nil and we call some method on self. Still I have been dabbling in combine and have found curios case, self becomes nil, but code never breaks. I tried to test it some more, to explain what is happening, but could not. Here is the example:</p>
<pre><code>class DetailsViewController: UIViewController {

var subject: PassthroughSubject&lt;Int, Never&gt;!
var localIntHolder: Int!
private var subscriptions = Set&lt;AnyCancellable&gt;()

override func viewDidLoad() {
    super.viewDidLoad()
    
    subject
        .flatMap { [unowned self] value in
            self.completionPublisher()
        }
        .map({ [unowned self] value in
            self.increaseValue(value)
        })
        .sink { [unowned self] value in
            print(&quot;\(value)&quot;)
            self.localIntHolder = value
        }
        .store(in: &amp;subscriptions)
    
    subject.send(22)
    
    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
        self.dismiss(animated: true, completion: nil)
    }
}

private func increaseValue(_ value: Int) -&gt; Int {
    return value + 1
}

deinit {
    print(&quot;deinit&quot;)
}

private func completionPublisher() -&gt; AnyPublisher&lt;Int, Never&gt; {
    return Future&lt;Int, Never&gt; { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            promise(.success(10))
        }
    }
    .eraseToAnyPublisher()
}
}
</code></pre>
<p>Here is setup from main view controller:</p>
<pre><code>let subjectInt = PassthroughSubject&lt;Int, Never&gt;()

override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        let controller = DetailsViewController()
        controller.subject = subjectInt
        present(controller, animated: true, completion: nil)
    }
</code></pre>
<p>Now this is simple example, sender will send value, future will delay it for 10 seconds. While this is happening I deallocate controller in the middle of it. I imagine that code will break, but nothing happens, controller is deallocated, rest of the pipeline never executed.</p>
<p>Is there some combine magic that I am missing?</p>
","744270","","9607863","","2021-09-06 19:11:53","2021-09-06 20:32:58","Unowned self does not cause runtime to break when self is deallocated?","<swift><memory-management><automatic-ref-counting><combine>","1","2","","","","CC BY-SA 4.0"
"69084289","1","69085801","","2021-09-07 07:49:39","","0","782","<p>I'm developing a MVVM structure with API calls.
I have this structure now:</p>
<pre><code>    //Get publisher
    loginPublisher = LoginService.generateLoginPublisher()
        
    //Create a subscriber
    loginSubscriber = loginPublisher!
        .sink { error in
            print(&quot;Something bad happened&quot;)
            self.isLoading = false
        } receiveValue: { value in               
            
            self.saveClient(value)
            self.client = value
            self.isLoading = false
        }
    
    //Asking service to start assync task and notify its result on publisher
    LoginService.login(email, password, loginPublisher!)
</code></pre>
<p>Basically what I do is obtain certain publisher from a <code>LoginService</code>, then I create a subscriber on <code>loginPublisher</code>, and then I tell <code>LoginService</code> to make some assync logic and send it result to <code>loginPublisher</code> this way I manage sent data with <code>loginSubscriber</code>.</p>
<p>I would like to execute LoginService.login() internally when I execute <code>LoginService.generateLoginPublisher()</code>, but if I do that, there is a chance that <code>LoginService.login()</code> logic finish before I create <code>loginSubscriber</code>, that's why I was forced to control when to call <code>LoginService.login()</code>.</p>
<p><strong>How could I detect from LoginService when its publisher has a new subscriber?</strong></p>
<p>This is my <code>LoginService</code> class:</p>
<pre><code>class LoginService{
static func generateLoginPublisher() -&gt; PassthroughSubject&lt;Client, NetworkError&gt;{
    return PassthroughSubject&lt;Client, NetworkError&gt;()
}

static func login(_ email: String,_ password: String,_ loginPublisher: PassthroughSubject&lt;Client, NetworkError&gt;){
    let url = NetworkBuilder.getApiUrlWith(extraPath: &quot;login&quot;)
    
    print(url)
    
    let parameters: [String: String] = [
        &quot;password&quot;: password,
        &quot;login&quot;: email
    ]
    
    print(parameters)
    
    let request = AF.request(
        url, method: .post,
        parameters: parameters,
        encoder: JSONParameterEncoder.default
    )
    
    request.validate(statusCode: 200...299)
    request.responseDecodable(of: Client.self) { response in
        if let loginResponse = response.value{//Success
            loginPublisher.send(loginResponse)
        }
        else{//Failure
            loginPublisher.send(completion: Subscribers.Completion&lt;NetworkError&gt;.failure(.thingsJustHappen))
        }
    }
}
</code></pre>
<p>}</p>
","15860448","","","","","2021-09-08 06:35:17","Is there a way to detect when a publisher has a new subscriber? | Swift, Combine","<swift><swiftui><combine>","3","1","","","","CC BY-SA 4.0"
"69089955","1","","","2021-09-07 14:22:35","","0","389","<p>I'm trying to write a custom publisher that generates some values. Something like this:</p>
<pre class=""lang-swift prettyprint-override""><code>class MyPublisher: Publisher {

    typealias Output = Int
    typealias Failure = Never

    private let subject = PassThroughSubject&lt;Int, Never&gt;()

    func receive&lt;S&gt;(subscriber: S) where S: Subscriber, S.Failure == Failure, S.Input == Output {
        subject.receive(subscriber: subscriber)
        startSending()
    }

    func startSending() {
        subject.send(1)
        subject.send(2)
        subject.send(3)
        subject.send(completion: .finished)
    }
}
</code></pre>
<p>I'm trying to figure out how to call <code>startSending()</code> automatically after a subscribing attaches, but I'm not sure if I'm doing it right.</p>
<p>I've just been reading about <code>ConnectablePublisher</code> and was wondering if that might help, but I'm not sure how.</p>
<p>Has anyone tried something like this? How did you do it?</p>
","247090","","247090","","2021-09-08 15:02:40","2021-09-08 15:02:40","Swift Combine: Waiting until subscribed to generate values","<swift><combine>","1","10","","","","CC BY-SA 4.0"
"69095798","1","69096758","","2021-09-08 00:40:25","","0","466","<p>I have a Publisher</p>
<p><code>var subject = PassthroughSubject&lt;Int, Error&gt;()</code></p>
<p>I want to convert it to</p>
<p><code>PassthroughSubject&lt;Int, Never&gt;</code></p>
<p>Is there anyway to achieve this ?</p>
<p>Edit - More Details</p>
<p>I do not want the Publisher to complete and the linked answer did not work because catch still completes the publisher.</p>
","11975968","","11975968","","2021-09-08 00:59:32","2021-09-08 03:47:36","Converting Publisher's error type to Never in Combine","<ios><swift><combine>","1","9","","","","CC BY-SA 4.0"
"69099734","1","","","2021-09-08 08:39:52","","-1","152","<p>When I add <code>print(&quot;value == \(value)&quot;)</code> in <code>Just{}</code>, I get a compile error:</p>
<blockquote>
<p>Generic parameter 'Output' could not be inferred</p>
</blockquote>
<p>My code:</p>
<pre><code>import Foundation
import Combine
class JustViewObservableObject: ObservableObject {
    
    var cancellable: AnyCancellable?
    
    struct Student: Decodable {
        let name: String
    }
    
    let json = &quot;&quot;&quot;
    [{
    &quot;name&quot;: &quot;李雷&quot;
    }]
    &quot;&quot;&quot;
    init() {
        let publisher = PassthroughSubject&lt;String, Never&gt;()
        publisher.flatMap { value -&gt; Just in
            print(&quot;value == \(value)&quot;)
            return Just(value.data(using: .utf8)!)
                .decode(type: [Student].self, decoder: JSONDecoder())
                .catch { _ in
                    Just([Student(name: &quot;无名氏&quot;)])
                }
        }
        publisher.send(json)
    }
}
</code></pre>
","16858903","","1974224","","2021-09-14 16:35:41","2021-09-14 16:35:41","Generic parameter 'Output' could not be inferred","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"69112120","1","69112333","","2021-09-09 04:07:25","","1","407","<p>I am trying to return just a string from my node.js Express server. It's a basic server that returns &quot;hello, world!&quot; but not as a <code>JSON</code> object but as a regular string. Here is my code from my request.</p>
<pre><code>URLSession
    .shared
    .dataTaskPublisher(for: request)
    .map(\.data)
    .decode(type: String.self, decoder: decoder)
    .receive(on: DispatchQueue.main)
</code></pre>
<p>I think I'm doing it right but I get this but when I run it, I get this error: <code>The data couldn't be read because it isn't in the correct format.</code></p>
<p><strong>Update</strong></p>
<p>So, as per the comments, I am not returning <code>JSON</code> so I can't use the <code>JSONDecoder</code>. That said, I wanted to use this in a generic fashion and some APIs will return <code>JSON</code> some will return <code>String</code>s and some will return <code>Int</code>s and some will return <code>Array&lt;Codable&gt;</code>. Is there a way to use combine to try and get these values back from my various API endpoints?</p>
<p>I know that I can do something like this:</p>
<pre><code>URLSession
    .shared
    .dataTaskPublisher(for: request)
    .map(\.data)
    .compactMap { String(data: $0, encoding:. utf8) }
    .receive(on: DispatchQueue.main)
</code></pre>
<p>but I want to be able to call each of my endpoints with this function. Can anybody help?</p>
","5863650","","5863650","","2021-09-13 17:42:50","2022-01-15 21:34:01","Retrieve String from `.dataTaskPublisher`","<ios><json><swift><combine><urlsession>","2","7","","","","CC BY-SA 4.0"
"69125885","1","69125941","","2021-09-10 00:07:27","","1","63","<p>I'm not sure why I'm not getting any data returned back.   I know the API key and URL is working properly. Below is the Struct and my class I'm using. I also included what I'm doing in my SwiftUI file.</p>
<p>In the response I can see that I am getting back a 200.  I've tried a few different ways to mapping the data to my view, but so far no luck.</p>
<pre><code>// MARK: - Welcome
struct WeatherDataModel: Codable, Identifiable {
    let id = UUID()
    let lat, lon: Double
    let timezone: String
    let current: Current
    let daily: [Daily]

    enum CodingKeys: String, CodingKey {
        case lat, lon, timezone
        case current, daily
    }
}

// MARK: - Current
struct Current: Codable {
    let dt, sunrise, sunset: Int
    let temp, feelsLike: Double
    let pressure, humidity: Int
    let dewPoint: Double
    let uvi, clouds, visibility: Int
    let windSpeed: Double
    let windDeg: Int
    let weather: [Weather]

    enum CodingKeys: String, CodingKey {
        case dt, sunrise, sunset, temp
        case feelsLike = &quot;feels_like&quot;
        case pressure, humidity
        case dewPoint = &quot;dew_point&quot;
        case uvi, clouds, visibility
        case windSpeed = &quot;wind_speed&quot;
        case windDeg = &quot;wind_deg&quot;
        case weather
    }
}

// MARK: - Weather
struct Weather: Codable {
    let id: Int
    let main, weatherDescription, icon: String

    enum CodingKeys: String, CodingKey {
        case id, main
        case weatherDescription = &quot;description&quot;
        case icon
    }
}

// MARK: - Daily
struct Daily: Codable {
    let dt, sunrise, sunset, moonrise: Int
    let moonset: Int
    let moonPhase: Double
    let temp: Temp
    let feelsLike: FeelsLike
    let pressure, humidity: Int
    let dewPoint, windSpeed: Double
    let windDeg: Int
    let windGust: Double
    let weather: [Weather]
    let clouds: Int
    let pop: Double
    let rain: Double?
    let uvi: Double

    enum CodingKeys: String, CodingKey {
        case dt, sunrise, sunset, moonrise, moonset
        case moonPhase = &quot;moon_phase&quot;
        case temp
        case feelsLike = &quot;feels_like&quot;
        case pressure, humidity
        case dewPoint = &quot;dew_point&quot;
        case windSpeed = &quot;wind_speed&quot;
        case windDeg = &quot;wind_deg&quot;
        case windGust = &quot;wind_gust&quot;
        case weather, clouds, pop, rain, uvi
    }
}

// MARK: - FeelsLike
struct FeelsLike: Codable {
    let day, night, eve, morn: Double
}

// MARK: - Temp
struct Temp: Codable {
    let day, min, max, night: Double
    let eve, morn: Double
}

typealias weatherData = [WeatherDataModel]

class DownloadWeatherData: ObservableObject {

    @Published var weatherdata: [WeatherDataModel] = []
    var weatherCancellabes = Set&lt;AnyCancellable&gt;()

    init() {
        print(&quot;loading weather init&quot;)

        getWeather(weatherUrl: &quot;&lt;my url&gt;&quot;)
    }

    func getWeather(weatherUrl: String) {

        guard let weatherUrl = URL(string: weatherUrl) else { return }

        URLSession.shared.dataTaskPublisher(for: weatherUrl)
            .subscribe(on: DispatchQueue.global(qos: .background))
            .receive(on: DispatchQueue.main)
            .tryMap { (data, response) -&gt; Data in
                print(response)
                guard
                    let response = response as? HTTPURLResponse,
                      response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else {
                    throw URLError(.badServerResponse)
                }
                print(&quot;data \(data)&quot;)
                return data
            }
            .decode(type: [WeatherDataModel].self, decoder: JSONDecoder())
            .sink { (completion) in
            } receiveValue: { [weak self] (returnedWeatherData) in
                self?.weatherdata = returnedWeatherData
                print(&quot;returnedWeatherData \(returnedWeatherData)&quot;)
            }
            .store(in: &amp;weatherCancellabes)
    }
}


struct WeatherView: View {

    @StateObject var weatherData = DownloadWeatherData()

    var body: some View {
        VStack {
            ForEach(weatherData.weatherdata) { day in
                Text(day.timezone)
            }
        }
    }
}
</code></pre>
<p>The error I'm getting here is <code>No exact matches in call to initializer </code></p>
","1165268","","","","","2021-09-10 01:49:27","OpenWeather data not returning using SwiftUI and Combine","<swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"69138592","1","","","2021-09-10 22:35:42","","1","218","<p>I came across some unexpected behavior in Combine that i'm hoping someone may be able to explain. I would expect the following code to create an infinite loop, but it actually only runs through the stream once.</p>
<pre><code>let pub1 = PassthroughSubject&lt;Int, Never&gt;()
let pub2 = PassthroughSubject&lt;Int, Never&gt;()

pub1
    .handleEvents(receiveOutput: { print(&quot;Received new pub1 value: \($0)&quot;) })
    .combineLatest(pub2)
    .handleEvents(receiveOutput: { print(&quot;Received new combined value: \($0)&quot;) })
    .sink { value in
        print(value)
        pub1.send(value.0)
    }.store(in: &amp;subscriptions)

print(&quot;sending 1&quot;)
pub1.send(1)
print(&quot;sending 2&quot;)
pub2.send(2)
</code></pre>
<p>Generates the following output:</p>
<pre><code>Received new pub1 value: 1
sending 2
Received new combined value: (1, 2)
(1, 2)
Received new pub1 value: 1
</code></pre>
<p>Since the value inside pub1 feeds back into itself I would expect sink to be called over and over. What's interesting is that if I get rid of the combineLatest , then this code will create an infinite loop. Something about the combineLatest operator is preventing it and I have no idea what.</p>
<p>I also noticed that adding <code>.receive(on: DispatchQueue.main)</code> before or after the <code>combineLatest</code> will also trigger a loop. I guess I'm not understanding something about how threads are handled in Combine. I'm not seeing this non-looping behavior with other operators. For instance <code>merge(with:)</code> will also create a loop, as expected.</p>
","6030546","","415303","","2021-09-23 02:56:08","2022-02-28 17:42:55","Recursively sending values to combineLatest publisher","<swift><multithreading><combine><combinelatest>","2","3","","","","CC BY-SA 4.0"
"69162812","1","","","2021-09-13 12:37:08","","2","585","<p>I am trying to use Publisher instead of completion closure for a button action of an UITableviewCell.</p>
<p><strong>My custom cell</strong>:</p>
<pre><code>import UIKit
import Combine

class PostTVCell: UITableViewCell {
    
    @IBOutlet private var lblTitle: UILabel!
    
    private var postModel: PostModel?
    public var showDetailsPublisher = PassthroughSubject&lt;PostModel, Never&gt;()
    
    public func load(with model: PostModel) {
        self.postModel = model
        lblTitle.text = model.title
    }
    
    @IBAction
    private func showDetails(_ sender: UIButton) {
        showDetailsPublisher.send(postModel!)
    }
}
</code></pre>
<p><strong>UITableviewDataSource code from ViewController</strong>:</p>
<pre><code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;cell&quot;, for: indexPath) as! PostTVCell
        let post = postList[indexPath.row]
        cell.load(with: post)
        cell.showDetailsPublisher
            .sink { postModel in
                print(&quot;Closure called&quot;)
            }
            .store(in: &amp;subscriptions)
        return cell
    }
</code></pre>
<p>It's working and subscriber closure is being called.
But problem is if I scroll tableView and then press button of a cell, subscriber closure called several times.
Is there have any default operator or any other mechanism, through which I can confirm, that a cell's publisher will receive subscriber only once.</p>
","4644528","","","","","2022-07-27 13:40:22","UITableviewCell Publisher emits value multiple times","<ios><swift><uitableview><combine>","2","2","","","","CC BY-SA 4.0"
"69164401","1","69168294","","2021-09-13 14:25:30","","1","167","<p>I am new to Combine, please help. I need to combine 2 URL requests to receive complete data. First one with ids, and second request should use these ids in their request. I need it in one publisher.
So I perform first:</p>
<pre><code>func getDataFromServer(request: Request) -&gt; AnyPublisher&lt;MyData, NetworkError&gt; {
    return networking.xml(request)
        .mapError { NetworkError.invalidData) }
        .flatMap { response -&gt; AnyPublisher&lt; MyData, NetworkError&gt; in
            return Future&lt; MyData, NetworkError&gt;.init { promise in
                guard let data = MyData.from(response: response) else {
                    return promise(.failure(NetworkError.parseError))
                }
                if data.myID.count &gt; 0 {
                    **// Perform second request with data.myID as parameter
                    // receive and fill additional fields data in 'data' object**
                }
                promise(.success(MyData))
            }.eraseToAnyPublisher()
        }
        .eraseToAnyPublisher()
}
</code></pre>
","377760","","","","","2021-09-13 20:17:57","Combine perform nested requests","<ios><swift><networking><combine>","1","0","","","","CC BY-SA 4.0"
"69170111","1","69170254","","2021-09-13 23:27:14","","0","498","<p>I'm just getting started with Combine. I have these questions for this situation:</p>
<ol>
<li>Is it accepted to have a tuple as a PassthroughSubject output?</li>
<li>Is it accepted to have a completion handler as part of the PassthroughSubject output?</li>
</ol>
<p>Example situation:</p>
<p>A SwiftUI log in view where I hand off logging in to another class and expect a result back:</p>
<pre><code>struct LogInView: View {
    var loginSubject = PassthroughSubject&lt;(username: String, password: String, completion: (Error?) -&gt; Void), Never&gt;()         

    var body: some View {
        Button {
            loginSubject.send((username: &quot;Jim&quot;, password: &quot;qwerty123&quot;, completion: { error in
                if let error = error {
                    // handle error
                } else {
                    // navigate to app
                }
            }))
        } label: {
            Text(&quot;Log in&quot;)
        }
    }
}
</code></pre>
<p>I would like to know other possible solutions to this scenario (I'm not able to use the 'login helper' class directly in the SwiftUI view due to 'LogInView' being in a package and the 'log in helper' being in the main app) and/or if this would be generally accepted as a solution.</p>
","2237587","","","","","2021-09-13 23:53:01","PassthroughSubject with completion handler output?","<ios><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"69181841","1","","","2021-09-14 17:01:32","","0","143","<p>How can I optimize the searches in the list. I have two thousand records. I don't want to do a search through NSPredicate, because I want to pass what is in the field through a function that cleans up the numbers and reduces the letters, before comparing. Can you somehow give a delay so that it does not search immediately but after some time or if the user finishes typing. I also heard about something like Combine, but I have no idea how to use it.</p>
<p>Songbook List</p>
<pre><code>import CoreData
import SwiftUI

struct SongbookView: View {
    @State var searchText: String = &quot;&quot;
    @Environment(\.managedObjectContext) var managedObjectContext
    @FetchRequest(
        entity: Song.entity(),
        sortDescriptors: [NSSortDescriptor(keyPath: \Song.number, ascending: true)]
    ) var songs: FetchedResults&lt;Song&gt;
    
    var body: some View {
        NavigationView{
            VStack{
                SearchBar(text: $searchText)
                Spacer()
                List(songs.filter({searchText.isEmpty ? true : removeNumber(str: $0.content!.lowercased()).contains(searchText.lowercased()) || String($0.number).contains(searchText)}), id:\.objectID) { song in
                    NavigationLink(destination: DetailView(song: song, isSelected: song.favorite)) {
                        HStack{
                            Text(&quot;\(String(song.number)). &quot;) .font(.headline) + Text(song.title ?? &quot;Brak tytułu&quot;)
                            if song.favorite {
                                Spacer()
                                Image(systemName: &quot;heart.fill&quot;)
                                    .accessibility(label: Text(&quot;To jest ulubiona pieśń&quot;))
                                    .foregroundColor(.red)
                            }
                        }.lineLimit(1)
                    }
                }.id(UUID())
                .listStyle(InsetListStyle())
                .animation(.default)
            }
            .padding(.top, 10)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .principal) {
                    Text(&quot;Śpiewnik&quot;)
                        .font(.system(size: 20))
                        .bold()
                }
            }
        }
    }
    
    func removeNumber(str: String) -&gt; String {
        var result = str
        let vowels: Set&lt;Character&gt; = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;]
        result.removeAll(where: { vowels.contains($0) })
        return result
    }
}
</code></pre>
<p>Search Bar</p>
<pre><code>import SwiftUI

struct SearchBar: View {
    @Binding var text: String

    @State var isEditing = false
        
    var body: some View {
        HStack {
            
            TextField(&quot;Szukaj ...&quot;, text: $text)
                .padding(7)
                .padding(.horizontal, 25)
                .background(Color(.systemGray6))
                .cornerRadius(8)
                .overlay(
                    HStack {
                        Image(systemName: &quot;magnifyingglass&quot;)
                            .foregroundColor(.gray)
                            .frame(minWidth: 0, maxWidth: .infinity, alignment: .leading)
                            .padding(.leading, 8)
                        
                        if isEditing {
                            Button(action: {
                                self.text = &quot;&quot;
                                
                            }) {
                                Image(systemName: &quot;multiply.circle.fill&quot;)
                                    .foregroundColor(.gray)
                                    .padding(.trailing, 8)
                            }
                        }
                    }
                )
                .padding(.horizontal, 10)
                .onTapGesture {
                    self.isEditing = true
                }
            
            if isEditing {
                Button(action: {
                    self.isEditing = false
                    self.text = &quot;&quot;
                    UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
                }) {
                    Text(&quot;Anuluj&quot;)
                }
                .padding(.trailing, 10)
                .transition(.move(edge: .trailing))
                .animation(.default)
            }
        }
    }
}

</code></pre>
","16512335","","","","","2021-09-15 01:47:01","Optimize list searches","<list><search><filter><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"69189862","1","","","2021-09-15 08:46:09","","0","657","<p>I am using the debounce Operator of the iOS Combine Framework.</p>
<pre><code>var subject = PassthroughSubject&lt;Void, Never&gt;()
var cancellable: Cancellable!
cancellable = subject
    .debounce(for: .seconds(0.1), scheduler: RunLoop.main)
    .sink {
        // doSomething
    }
</code></pre>
<p>Now I want to &quot;fire the event&quot; to doSomething before the timer (0.1 seconds) ends.
Is there a method which can invoke this?</p>
","7405518","","","","","2021-09-15 09:54:57","iOS Combine debounce fire manually","<ios><swift><combine><debouncing>","1","0","","","","CC BY-SA 4.0"
"69191003","1","","","2021-09-15 10:04:41","","0","57","<p>i have a problem with merged stream and StreamBuilder.
im trying to merge multiple streams from firestore that each one represents a grocery list.
my result should be a ListView that combines all list in a some group.
from some reason,my StreamBuilder shows a single stream list in one tab but doesnt show it in another.</p>
<p><a href=""https://i.stack.imgur.com/lS0nS.jpg"" rel=""nofollow noreferrer"">group list app photo</a>
<a href=""https://i.stack.imgur.com/909BY.jpg"" rel=""nofollow noreferrer"">personal list app photo</a></p>
<p>code:</p>
<pre><code>  Stream&lt;QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt;&gt; getPesonalStream&lt;T&gt;() {
final userGroceries =
    _fireStore.collection(&quot;users&quot;).doc(email).collection(&quot;groceries&quot;);
return userGroceries.snapshots();


}

  Stream&lt;QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt;&gt; getGroupStream&lt;T&gt;() {
    List&lt;Stream&lt;QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt;&gt;&gt; list = [];
_fireStore
    .collection(&quot;groups&quot;)
    .doc(gid)
    .snapshots()
    .forEach(((docSnapshot) {
  List&lt;dynamic&gt; members = docSnapshot.data()![&quot;members&quot;];

  list = members
      .map((member) =&gt; _fireStore
          .collection(&quot;users&quot;)
          .doc(member)
          .collection(&quot;groceries&quot;)
          .snapshots())
      .toList();
}));
return CombineLatestStream(list,
        (values) =&gt; values.last as QuerySnapshot&lt;Map&lt;String, dynamic&gt;&gt;)
    .asBroadcastStream();
// return StreamGroup.merge(list).asBroadcastStream();


}
</code></pre>
<p>as you can see iv tried a few ways to combine my streams and non workes</p>
<p>body:</p>
<pre><code>  body: TabBarView(children: [
        _buildContent(
          context,
          db.getGroupStream(),
        ),
        _buildContent(
          context,
          db.getPesonalStream(),
        ),
      ]),
</code></pre>
<p>my builder:</p>
<pre><code> Widget _buildContent(BuildContext context, Stream&lt;QuerySnapshot&gt; stream) {
return StreamBuilder&lt;QuerySnapshot&gt;(
  stream: stream,
  builder: (context, snapshot) {
    if (snapshot.hasData) {
      final docs = snapshot.data!.docs;
      if (docs.isEmpty) {
        return Center(
            child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              &quot;The list is empty&quot;,
              style: TextStyle(fontSize: 32, color: Colors.black54),
            ),
            Text(
              &quot;Add a new item to get started&quot;,
              style: TextStyle(fontSize: 16, color: Colors.black54),
            ),
          ],
        ));
      }
      int index = -1;
      final cards = docs
          .map((doc) =&gt; CrossableListTile(
              doc, _showSetGroceryButtomSheetForm, index++))
          .toList();
      return Container(
        padding: EdgeInsets.symmetric(vertical: 20, horizontal: 10),
        child: ListView(
          children: cards,
        ),
      );
    } else if (snapshot.hasError) {
      return Center(
        child: Column(
          children: [Text(&quot;An error has occured while loading you'r list&quot;)],
        ),
      );
    }
    return Center(
        child: CircularProgressIndicator(
      color: Colors.black,
    ));
  },
);
</code></pre>
<p>}</p>
","16759856","","","","","2021-09-15 10:04:41","flutter: StreamBuilder doesn't accept merged stream","<flutter><stream><builder><combine><stream-builder>","0","4","","","","CC BY-SA 4.0"
"69191212","1","","","2021-09-15 10:18:40","","-1","1098","<p>I'm using Combine and UIKit, and I want UIButton to be publisher.</p>
<p>Is there any way to achieve this like RxSwift does?</p>
<pre class=""lang-swift prettyprint-override""><code>button.rx.tap.subscribe(onNext: { weak self } _ in )
</code></pre>
","16739565","","1974224","","2021-09-24 21:13:57","2021-09-30 19:02:17","Create a Publisher for a UIButton","<swift><uikit><combine>","2","3","","","","CC BY-SA 4.0"
"69210973","1","69212888","","2021-09-16 15:10:53","","-1","294","<p>I recently started to study the Combine and ran into a certain problem.
First, I will describe what I am doing.
I trying to use Clean Architecture
Here you can see my Repository</p>
<pre><code>protocol Repository {
    func test()
}

class MockRepository: Repository {
    func test() {
        sleep(3)
    }
}
</code></pre>
<p>Then I created UseCase</p>
<pre><code>class UseCaseBase&lt;TInput, TOutput&gt; {
    var task: TOutput? { return nil }

    var repository: Repository

    init(_ repository: Repository) {
        self.repository = repository
    }

    func execute(with payload: TInput) -&gt; AnyPublisher&lt;TOutput, Never&gt; {
        return AnyPublisher(Future&lt;TOutput, Never&gt; { promise in
            promise(.success(self.task!))
        })
            .eraseToAnyPublisher()
    }
}

class MockUseCase: UseCaseBase&lt;String, Int&gt; {
    override var task: Int? {
        repository.test()
        return 1
    }
}
</code></pre>
<p>And then in a init block ContentView I did something like that</p>
<pre><code>init() {
        let useCase = MockUseCase(MockRepository())
        var cancellables = Set&lt;AnyCancellable&gt;()
        
        useCase.execute(with: &quot;String&quot;)
            .sink(receiveValue: { value in
                print(value)
            })
            .store(in: &amp;cancellables)
        
        print(&quot;Started&quot;)
        
    }
</code></pre>
<p>At first, I want to get
&quot;Started&quot;
and then after <code>sleep(3)</code>
value &quot;1&quot;</p>
<p><em>Now I get
&quot;1&quot; and then &quot;Started&quot;</em></p>
","10662610","","","","","2021-09-16 17:36:55","Executing a task asynchronously using Combine with Swift","<swift><asynchronous><swiftui><combine>","2","5","","","","CC BY-SA 4.0"
"69231728","1","","","2021-09-18 04:58:42","","-1","389","<p>In swiftui, I have a presenter here,</p>
<pre><code>class Presenter {

     @Published private(set) var viewModel: ContentViewModel

     @ObservedObject private(set) var viewModel: ContentViewModel
}
</code></pre>
<p>ContentViewModel conforms ObservableObject.</p>
<p>Which one is correct? Why?</p>
","2537867","","","","","2021-09-18 05:29:41","@ObservedObject or @Published","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"69241272","1","69291680","","2021-09-19 07:39:09","","1","712","<p>I'd like to display some Realm objects in a read-only view (SwiftUI), and as far as I've understood, Realm objects should be frozen for such views.</p>
<p>But where should I call <code>.freeze()</code>? On the <code>Results</code>-object or the publisher?</p>
<pre class=""lang-swift prettyprint-override""><code>Realm().objects(Contact.self)
    .freeze()
    .publisher
    .[...]
</code></pre>
<p>vs.</p>
<pre class=""lang-swift prettyprint-override""><code>Realm().objects(Contact.self)
    .publisher
    .freeze()
    .[...]
</code></pre>
<p>Or does it make no difference?</p>
","15978784","","15978784","","2021-09-21 20:41:46","2021-09-22 21:50:47","Where to call freeze() when working with Realm collections and Combine?","<swift><realm><combine>","1","6","","","","CC BY-SA 4.0"
"69262534","1","69262812","","2021-09-21 01:50:07","","0","223","<p>I have an <code>enum</code> case which is a <code>@Published</code> var in an <code>ObservableObject</code> class. What I'm trying to do is observe changes to the <code>term</code> var defined below and update an <code>annualRate</code> publisher.</p>
<p>Below is the <code>@Published</code> var</p>
<pre><code>@Published var term: MortgageTerm = .thirtyYear
</code></pre>
<p>The <code>MortgageTerm</code> enum is defined as follows:</p>
<pre><code>public enum MortgageType: Int, CaseIterable {
    case tenYear     = 10
    case fifteenYear = 15
    case twentyYear  = 20
    case thirtyYear  = 30
}
</code></pre>
<p>I'm trying to get this <code>annualRate</code> defined so it observes changes to the <code>term</code> var above:</p>
<pre><code>public lazy var annualRate: AnyPublisher&lt;Double, Never&gt; = {
    var output: Double
    $term
        .map { switchCase -&gt; Double in
            switch switchCase {
            case .tenYear:
                output = self.rates.tenYearFix
            case .fifteenYear:
                output = self.rates.fifteenYearFix
            case .twentyYear:
                output = self.rates.twentyYearFix
            case .thirtyYear:
                output = self.rates.thirtyYearFix
            }
            
            return output * 0.01
        }
        // FIXME: Result of call to `eraseToAnyPublisher()` is unused
        .eraseToAnyPublisher()
}()
</code></pre>
<p>I'm getting this warning at the line for <code>.eraseToAnyPublisher()</code>. What am I mucking up and how do I fix it?</p>
<p>This is where the <code>rates</code> are coming from:</p>
<pre><code>private lazy var rates: AverageRate = {
    let rateMock = AverageRate(thirtyYearFha: 2.873,
                                thirtyYearVa: 2.858,
                                tenYearFix: 2.068,
                                fifteenYearFix: 2.358,
                                thirtyYearFix: 3.054,
                                fiveOneArm: 2.898,
                                sevenOneArm: 2.972,
                                twentyYearFix: 2.756)
    
    return rateMock
}()
</code></pre>
","4475605","","","","","2021-09-21 02:42:51","Using a Published var to observe a switch case in a Publisher with Combine","<swift><enums><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"69274848","1","","","2021-09-21 19:56:01","","2","776","<p>After running a background-context core data task, Xcode displays the following purple runtime warning when the updates are published in a SwiftUI view:</p>
<p><code>&quot;[SwiftUI] Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.&quot;</code></p>
<p>Besides the <code>ContentView.swift</code> code below, I also added <code>container.viewContext.automaticallyMergesChangesFromParent = true</code> to <code>init</code> in the default <code>Persistence.swift</code> code.</p>
<p>How can I publish the background changes on the main thread to fix the warning? (iOS 14, Swift 5)</p>
<p><strong>Edit: I've changed the code below, in response to the first answer, to clarify that I'm looking for a solution that doesn't block the UI when a lot of changes are saved.</strong></p>
<pre><code>struct PersistenceHelper {
    private let context: NSManagedObjectContext
    
    init(context: NSManagedObjectContext = PersistenceController.shared.container.viewContext) {
        self.context = context
    }
    
    public func fetchItem() -&gt; [Item] {
        do {
            let request: NSFetchRequest&lt;Item&gt; = Item.fetchRequest()
            var items = try self.context.fetch(request)
            if items.isEmpty { // Create items if none exist
                for _ in 0 ..&lt; 250_000 {
                    let item = Item(context: context)
                    item.timestamp = Date()
                    item.data = &quot;a&quot;
                }
                try! context.save()
                items = try self.context.fetch(request)
            }
            return items
        } catch { assert(false) }
    }

    public func updateItemTimestamp(completionHandler: @escaping () -&gt; ()) {
        PersistenceController.shared.container.performBackgroundTask({ backgroundContext in
            let start = Date(), request: NSFetchRequest&lt;Item&gt; = Item.fetchRequest()
            do {
                let items = try backgroundContext.fetch(request)
                for item in items {
                    item.timestamp = Date()
                    item.data = item.data == &quot;a&quot; ? &quot;b&quot; : &quot;a&quot;
                }
                try backgroundContext.save() // Purple warning appears here

                let interval = Double(Date().timeIntervalSince(start) * 1000) // Artificial two-second delay so cover view has time to appear
                if interval &lt; 2000 { sleep(UInt32((2000 - interval) / 1000)) }
                
                completionHandler()
            } catch { assert(false) }
        })
    }
}
</code></pre>
<pre><code>// A cover view with an animation that shouldn't be blocked when saving the background context changes
struct CoverView: View {
    @State private var toggle = true
    var body: some View {
        Circle()
            .offset(x: toggle ? -15 : 15, y: 0)
            .frame(width: 10, height: 10)
            .animation(Animation.easeInOut(duration: 0.25).repeatForever(autoreverses: true))
            .onAppear { toggle.toggle() }
    }
}
</code></pre>
<pre><code>struct ContentView: View {
    @State private var items: [Item] = []
    @State private var showingCoverView = false
    @State private var refresh = UUID()

    let persistence = PersistenceHelper()
    let formatter = DateFormatter()
    var didSave = NotificationCenter.default
        .publisher(for: .NSManagedObjectContextDidSave)
        // .receive(on: DispatchQuene.main) // Doesn't help
    
    var body: some View {
        ScrollView {
            LazyVStack {
                Button(&quot;Update Timestamp&quot;) {
                    showingCoverView = true
                    persistence.updateItemTimestamp(completionHandler: { showingCoverView = false })
                }
                ForEach(items, id: \.self) { item in
                    Text(formatter.string(from: item.timestamp!) + &quot; &quot; + (item.data ?? &quot;&quot;))
                }
            }
        }
        .id(refresh)
        .onAppear {
            formatter.dateFormat = &quot;HH:mm:ss&quot;
            items = persistence.fetchItem()
        }
        .onReceive(didSave) { _ in
            items = persistence.fetchItem()
        }
        .fullScreenCover(isPresented: $showingCoverView) {
            CoverView().onDisappear { refresh = UUID() }
        }
    }
}
</code></pre>
","1232814","","1232814","","2021-09-25 03:20:07","2021-12-22 04:49:53","Publish background context Core Data changes in a SwiftUI view without blocking the UI","<core-data><swiftui><publish><combine><background-thread>","2","0","0","","","CC BY-SA 4.0"
"69277972","1","69310575","","2021-09-22 03:50:40","","5","300","<p>I'm building a mortgage calculator as an exercise to learn <code>Combine</code>. Everything has been going swimmingly until I encountered a situation where I'm not getting deterministic published output from one of my <code>Publishers</code> when I unit test it. I'm not making any asynchronous calls. This is the problematic <code>AnyPublisher</code>:</p>
<pre><code>public lazy var monthlyPayment: AnyPublisher&lt;Double, Never&gt; = {
    Publishers.CombineLatest3(financedAmount, monthlyRate, numberOfPayments)
        .print(&quot;montlyPayment&quot;, to: nil)
        .map { financedAmount, monthlyRate, numberOfPayments in
            let numerator = monthlyRate * pow((1 + monthlyRate), Double(numberOfPayments))
            let denominator = pow((1 + monthlyRate), Double(numberOfPayments)) - 1
            
            return financedAmount * (numerator / denominator)
        }
        .eraseToAnyPublisher()
}()
</code></pre>
<p>Let's say I change the mortgage type from a 30 year to a 15 year, a few things happen:</p>
<ol>
<li>the <code>numberOfPayments</code> changes due to the change in the mortgage term (length)</li>
<li>the <code>monthlyRate</code> due to a change in the mortgage term (length)</li>
</ol>
<h2>End Goal</h2>
<p>My end goal is to wait for <code>financedAmount</code>, <code>monthlyRate</code>, and <code>numberOfPayments</code> publishers to finish doing their thing and when they're ALL done, THEN compute the monthly payment. Merge 3 seems to pick up changes in each of the publishers and for each change, it computes and spits out output I don't want.</p>
<p><a href=""https://github.com/AdrianBinDC/MortgageCalcIssue"" rel=""nofollow noreferrer"">Repo with problematic class and associated unit tests</a></p>
<h2>What I've Tried</h2>
<p>I've tried mucking around with <code>MergeMany</code>, <code>Merge3</code>, <code>.collect()</code>, but I can't get the syntax right. I've Googled the snot out of this and looked for examples in public GitHub repos, but I'm coming up with nothing that's germane to my situation. I'm trying to figure out what I'm mucking up and how to fix it.</p>
<h2>Supporting Declarations</h2>
<p>These are my declarations for the other publishers upon which <code>monthlyPayment</code> relies:</p>
<pre><code>@Published var principalAmount: Double
@Published var mortgageTerm: MortgageTerm = .thirtyYear
@Published var downPaymentAmount: Double = 0.0

// monthlyRate replies upon annualRate, so I'm including annualRate above
internal lazy var monthlyRate: AnyPublisher&lt;Double, Never&gt; = {
  annualRate
      .print(&quot;monthlyRate&quot;, to: nil)
      .map { rate in
          rate / 12
      }
      .eraseToAnyPublisher()
}()

public lazy var annualRate: AnyPublisher&lt;Double, Never&gt; = {
  $mortgageTerm
      .print(&quot;annualRate&quot;, to: nil)
      .map { value -&gt; Double in
          switch value {
          case .tenYear:
              return self.rates.tenYearFix
          case .fifteenYear:
              return self.rates.fifteenYearFix
          case .twentyYear:
              return self.rates.twentyYearFix
          case .thirtyYear:
              return self.rates.thirtyYearFix
          }
      }
      .map { $0 * 0.01 }
      .eraseToAnyPublisher()
}()

public lazy var financedAmount: AnyPublisher&lt;Double, Never&gt; = {
  Publishers.CombineLatest($principalAmount, $downPaymentAmount)
      .map { principal, downPayment in
          principal - downPayment
      }
      .eraseToAnyPublisher()
}()

public lazy var numberOfPayments: AnyPublisher&lt;Double, Never&gt; = {
  $mortgageTerm
      .print(&quot;numberOfPayments: &quot;, to: nil)
      .map {
          Double($0.rawValue * 12)
      }
      .eraseToAnyPublisher()
}()
</code></pre>
<h2>Update</h2>
<p>I attempted to use <code>Merge3</code> with <code>.collect()</code>, but my unit test is timing out on it. Here's the updated <code>monthlyPayment</code> declaration:</p>
<pre><code> public lazy var monthlyPayment: AnyPublisher&lt;Double, Never&gt; = {
     Publishers.Merge3(financedAmount, monthlyRate, numberOfPayments)
         .collect()
         .map { mergedArgs in
             let numerator = mergedArgs[1] * pow((1 + mergedArgs[1]), mergedArgs[2])
             let denominator = pow((1 + mergedArgs[1]), mergedArgs[2]) - 1
             
             return mergedArgs[0] * (numerator / denominator)
         }
         .eraseToAnyPublisher()
 }()
</code></pre>
<p>The test now fails with a timeout and the <code>.sink</code> code is never called:</p>
<pre><code> func testMonthlyPayment() {
     // sut is initialized w/ principalAmount of $100,000 &amp; downPaymentAmount of $20,000
     let sut = calculator
     
     let expectation = expectation(description: #function)
     
     let expectedPayments = [339.62, 433.97, 542.46]
     
     sut.monthlyPayment
         .collect(3)
         .sink { actualMonthlyPayment in
             XCTAssertEqual(actualMonthlyPayment.map { $0.roundTo(places: 2) }, expectedPayments)
             expectation.fulfill()
         }
         .store(in: &amp;subscriptions)
     
     // Initialized with 30 year fix with 20% down
     // Change term to 20 years
     sut.mortgageType = .twentyYear
     
     // Change the financedAmount
     sut.downPaymentAmount.value = 0.0
     
     waitForExpectations(timeout: 5, handler: nil)     
}
</code></pre>
","4475605","","4475605","","2021-09-24 04:57:57","2021-09-26 09:41:38","Unexpected Combine Publisher Behavior","<swift><combine><publisher>","1","7","","","","CC BY-SA 4.0"
"69282714","1","","","2021-09-22 10:46:56","","0","232","<p>First of all, sorry about the post length but I am very new to iOS and SwiftUI development and I don't want to miss any details. I did some small projects with Kotlin on Android and Flutter, so I had some experience in app development.</p>
<h3>Context</h3>
<p>I trying to create a simple app that persists the user data on CoreData and I trying to follow MVVM architecture to develop the app. I was inspired by the following <a href=""https://betterprogramming.pub/swiftui-and-coredata-the-mvvm-way-ab9847cbff0f"" rel=""nofollow noreferrer"">post</a> on Medium. And I have the following files:</p>
<ul>
<li><em>DataSource.swift</em>: Class that abstracts the initialization of <code>NSPersistentContainer</code>.</li>
<li><em>Entity.swift</em>: Protocol for CoreData entity class standardization.</li>
<li><em>ProductEntity.swift</em>: Particular CoreData class definition that conforms <em>Entity</em> protocol.</li>
<li><em>Model.swift</em>: Class with Entity generic that abstracts the model instantiation and updating process.</li>
<li><em>ProductModel.swift</em>: Particular CoreData entity model definition that inherits <em>Model&lt;ProductEntity&gt;</em> (<strong>where exception raises</strong>).</li>
</ul>
<h3>The exception</h3>
<p>I got an exception initializing the <code>ProductsModel</code> class (<em>ProductsModel.swift</em>, check it below) and I don't have any idea about where are the error source and its reason.</p>
<pre class=""lang-sh prettyprint-override""><code>Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'An instance of NSFetchedResultsController requires a fetch request with sort descriptors'
</code></pre>
<p>I hope you can give me some clues! :)</p>
<h3>The code</h3>
<p><strong>DataSource.swift</strong>:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import CoreData

let defaultDatabase = &quot;DB&quot;

class DataSource {
    static let shared = DataSource()
    public let container: NSPersistentContainer
    
    init(dbName: String = defaultDatabase) {
        container = NSPersistentContainer(name: dbName)
        container.loadPersistentStores { (_, err) in
            if let error = err as NSError? {
                print(&quot;NSError \(error) - \(error.userInfo)&quot;)
                return
            }
        }
    }
    
    func save() {
        do {
            print(&quot;Saving context&quot;)
            try self.container.viewContext.save()
            print(&quot;Successfully saved context&quot;)
        } catch {
            print(&quot;ERROR: \(error as NSObject)&quot;)
        }
    }
}
</code></pre>
<p><strong>Entity.swift</strong>:</p>
<pre class=""lang-swift prettyprint-override""><code>import CoreData

protocol Entity: NSFetchRequestResult {
    associatedtype CurrentEntity: NSManagedObject
    static var name: String { get }
}
</code></pre>
<p><strong>ProductEntity.swift</strong>:</p>
<pre class=""lang-swift prettyprint-override""><code>import os
import CoreData

@objc(ProductEntity)
public class ProductEntity: NSManagedObject, Entity {
    typealias CurrentEntity = ProductEntity
    static let name: String = &quot;Product&quot;
}

extension ProductEntity : Identifiable {
    public var ID: String {
        self.objectID.uriRepresentation().absoluteString
    }
}

extension ProductEntity {
    @NSManaged public var desc: String?
    @NSManaged public var name: String
    @NSManaged public var price: Double
    @NSManaged public var rations: Int16
    @NSManaged public var shoppingList: NSSet?
}
</code></pre>
<p><strong>Model.swift</strong>:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import CoreData
import os

class Model&lt;T: Entity&gt;: NSObject, ObservableObject, NSFetchedResultsControllerDelegate {
    var records = CurrentValueSubject&lt;[T.CurrentEntity], Never&gt;([])
    private let controller: NSFetchedResultsController&lt;T.CurrentEntity&gt;
    
    override init() {
        controller = NSFetchedResultsController(
            fetchRequest: NSFetchRequest&lt;T.CurrentEntity&gt;(entityName: T.name),
            managedObjectContext: DataSource.shared.container.viewContext,
            sectionNameKeyPath: nil, cacheName: nil
        )
        
        super.init()
        
        controller.delegate = self
        
        do {
            try controller.performFetch()
            records.value = (controller.fetchedObjects ?? []) as [T.CurrentEntity]
        } catch {
            NSLog(&quot;Error: could not fetch objects&quot;)
        }
    }
    
    public func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
        guard let records = controller.fetchedObjects as? [T.CurrentEntity] else { return }
        self.records.value = records
    }
    
    public func save() {
        DataSource.shared.save()
    }
}
</code></pre>
<p><strong>ProductModel.swift</strong>:</p>
<pre class=""lang-swift prettyprint-override""><code>import os

class ProductsModel: Model&lt;ProductEntity&gt; {
    static let shared: ProductsModel = ProductsModel() // &lt;-- This line raise the exception
}
</code></pre>
","1888108","","","","","2021-09-28 09:02:29","Problems creating a generic MVVM connector to CoreData","<ios><swift><core-data><mvvm><combine>","1","1","","","","CC BY-SA 4.0"
"69288505","1","","","2021-09-22 17:07:52","","0","421","<p>I'm working on an iOS app (utilizing Swift, XCTest, and Combine) trying to test a function within my view model, which is calling and setting a <code>sink</code> on a publisher. I'd like to test the view model, <em>not</em> the publisher itself. I really don't want to use <code>DispatchQueue.asyncAfter(</code> because theoretically I don't know how long the publisher will take to respond. For instance, how would I test XCTAssertFalse(viewModel.isLoading)</p>
<pre><code>class ViewModel: ObservableObject {
  @Published var isLoading: Bool = false
  @Published var didError: Bool = false
  var dataService: DataServiceProtocol

  init(dataService: DataServiceProtocol) {
    self.dataService = dataService
  }

  func getSomeData() { // &lt;=== This is what I'm hoping to test
    isLoading = true
    dataService.getSomeData() //&lt;=== This is the Publisher
      .sink { (completion) in
        switch completion {
          case .failure(_):
            DispatchQueue.main.async {
              self.didError = true
            }
          case .finished:
            print(&quot;finished&quot;)
         }
                        
       DispatchQueue.main.async {
         self.isLoading = false
       }
     } receiveValue: { (data) in
         print(&quot;Ok here is the data&quot;, data)
    }
  }
}

</code></pre>
<p>I'd like to write a test that might look like:</p>
<pre><code>func testGetSomeDataDidLoad() {
  // this will test whether or not getSomeData
  // loaded properly

  let mockDataService: DataServiceProtocol = MockDataService
  let viewModel = ViewModel(dataService: mockDataService)

  viewModel.getSomeData()

  // ===== THIS IS THE PROBLEM...how do we know to wait for getSomeData? ======
  // It isn't a publisher...so we can't listen to it per se... is there a better way to solve this?

  XCTAssertFalse(viewModel.isLoading)
  XCTAssertFalse(viewModel.didError)
}
</code></pre>
<p>Really hoping to refactor our current tests so we don't utilize a <code>DispatchQueue.asyncAfter(</code></p>
","15794863","","15794863","","2021-09-22 19:02:29","2021-09-22 19:19:51","XCTest testing asyncronous Combine @Publishers","<ios><swift><testing><xctest><combine>","1","0","","2021-09-22 20:14:42","","CC BY-SA 4.0"
"69311371","1","69312040","","2021-09-24 07:46:58","","6","2331","<p>Consider the following code:</p>
<pre><code>        CurrentValueSubject&lt;Void, Error&gt;(())
            .eraseToAnyPublisher()
            .sink { completion in

                switch completion {
                case .failure(let error):
                    print(error)
                    print(&quot;FAILURE&quot;)
                case .finished:
                    print(&quot;SUCCESS&quot;)
                }
            } receiveValue: { value in
                // this should be ignored
            }
</code></pre>
<p>Just by looking at the <code>CurrentValueSubject</code> initializer, it's clear that the value is not needed / doesn't matter.</p>
<p>I'm using this particular publisher to make an asynchronous network request which can either pass or fail.</p>
<p>Since I'm not interested in the value returned from this publisher (there are none), how can I get rid of the <code>receiveValue</code> closure?</p>
<p>Ideally, the call site code should look like this:</p>
<pre><code>        CurrentValueSubject&lt;Void, Error&gt;(())
            .eraseToAnyPublisher()
            .sink { completion in

                switch completion {
                case .failure(let error):
                    print(error)
                    print(&quot;FAILURE&quot;)
                case .finished:
                    print(&quot;SUCCESS &quot;)
                }
            }
</code></pre>
<p>It also might be the case that I should use something different other than <code>AnyPublisher</code>, so feel free to propose / rewrite the API if it fits the purpose better.</p>
<p>The closest solution I was able to find is <a href=""https://developer.apple.com/documentation/combine/publisher/ignoreoutput()"" rel=""noreferrer"">ignoreOutput</a>, but it still returns a value.</p>
","3667264","","","","","2021-09-24 09:09:51","Combine sink: ignore receiveValue, only completion is needed","<swift><swiftui><reactive-programming><combine>","2","3","","","","CC BY-SA 4.0"
"69356976","1","69360140","","2021-09-28 06:48:08","","1","164","<p>I have two functions with the following signatures:</p>
<pre><code>import Combine

func firstCall() -&gt; Future&lt;Result&lt;Void, Error&gt;, Never&gt; {
    return Future { promise in
        promise(.success(.success(())))
    }
}



func secondCall() -&gt; Future&lt;Result&lt;Void, Error&gt;, Never&gt; {
    return Future { promise in
        promise(.success(.success(())))
    }
}


// Execute 1st call, then if it succeeds, execute the 2nd call
</code></pre>
<p>How can I execute the 2nd function only after the 1st one completes successfully?</p>
<p>Ideally, I'm looking to something like this:</p>
<pre><code>executeInSequence([firstCall(), secondCall()])
.onResult( { finalResult in
print(finalResult)
})
</code></pre>
<p>Feel free to slightly adjust API signatures if that helps the call site.</p>
<p>More information: one of the calls is actually a converted synchronous method call with a signature of:</p>
<pre><code>func secondSynchronousCall() throws {
}

    private func secondCall() -&gt; Future&lt;Result&lt;Void, Error&gt;, Never&gt; {
        return Future { [weak self] promise in
            do {
                try self?.secondSynchronousCall()
                promise(.success(.success(())))
            } catch {
                promise(.success(.failure(error)))
            }
        }
    }
</code></pre>
","3667264","","3667264","","2021-09-28 06:58:13","2021-09-28 10:33:56","Execute two promises in sequence in Swift / Combine","<swift><promise><functional-programming><combine>","1","4","","","","CC BY-SA 4.0"
"69366353","1","","","2021-09-28 17:50:29","","4","2823","<p>I am working on a SwiftUI project that pulls data from Firebase Firestore using Combine. Each user has the ability to create &quot;Offers&quot; in the app. In order to list their offers on their account page I am using onAppear to pass the currentUserUid to my View Model so I can filter the database results using the currentUserUid. The OfferHistoryView is below. This works great the when the view first appears. My issue is when I return from the OfferDetailView, I received the following message.</p>
<blockquote>
<p>ForEach&lt;Array, String, NavigationLink&lt;OfferRowView,
ModifiedContent&lt;OfferDetailView,
_EnvironmentKeyWritingModifier&lt;Optional&gt;&gt;&gt;&gt;: the ID  occurs multiple times within the collection, this will give undefined
results!</p>
</blockquote>
<p>While this is not crashing the app it is not ideal. I'v tried, deleting all items from the collection each time the view loads, and each time combine is called and this does not resolve the issue. I've also added print statements to try and catch the duplicates but I never see a duplicate. You can see my print statements and the rest of the corresponding files below. Any help would be appreciated.</p>
<p><strong>OfferViewHistory - Where the message is originating from.</strong></p>
<pre><code>struct OfferHistoryView: View {
    let db = Firestore.firestore()
    
    @EnvironmentObject var authSession: AuthSession
    @EnvironmentObject var offerHistoryViewModel: OfferHistoryViewModel
    
    var body: some View {
        
        return VStack {
            List {
                ForEach(self.offerHistoryViewModel.offerRowViewModels, id: \.id) { offerRowViewModel in
                    NavigationLink(destination: OfferDetailView(offerDetailViewModel: OfferDetailViewModel(offer: offerRowViewModel.offer, listing: offerRowViewModel.listing ?? testListing1))
                                    .environmentObject(authSession)
                    ) {
                        OfferRowView(offerRowViewModel: offerRowViewModel)
                    }
                } // ForEach
            } // List
            .navigationBarTitle(&quot;Offer History&quot;)
        } // VStack
        .onAppear(perform: {
            for offerRowViewModel in self.offerHistoryViewModel.offerRowViewModels {
                print(&quot;Before startCombine: \(offerRowViewModel.id)&quot;)
            }
            self.offerHistoryViewModel.startCombine(currentUserUid: self.authSession.currentUserUid)
            for offerRowViewModel in self.offerHistoryViewModel.offerRowViewModels {
                print(&quot;After startCombine: \(offerRowViewModel.id)&quot;)
            }
        })
    } // View
}
</code></pre>
<p><strong>OfferHistoryViewModel - where combine is called.</strong></p>
<pre><code>class OfferHistoryViewModel: ObservableObject {
    var offerRepository: OfferRepository

    // Published Properties
    @Published var offerRowViewModels = [OfferRowViewModel]()
    
    // Combine Cancellable
    private var cancellables = Set&lt;AnyCancellable&gt;()
        
    // Intitalizer
    init(offerRepository: OfferRepository) {
        self.offerRepository = offerRepository
    }
    
    // Starting Combine - Filter results for offers created by the current user only.
    func startCombine(currentUserUid: String) {
        for offerRowViewModel in self.offerRowViewModels {
            print(&quot;Before startCombine func: \(offerRowViewModel.id)&quot;)
        }
        offerRepository
            .$offers
            .receive(on: RunLoop.main)
            .map { offers in
                offers
                    .filter { offer in
                        (currentUserUid != &quot;&quot; ? offer.userId == currentUserUid : false)
                    }
                    .map { offer in
                        OfferRowViewModel(offer: offer, listingRepository: ListingRepository())
                    }
            }
            .assign(to: \.offerRowViewModels, on: self)
            .store(in: &amp;cancellables)
        
        for offerRowViewModel in self.offerRowViewModels {
            print(&quot;After startCombine func: \(offerRowViewModel.id)&quot;)
        }
    }
}
</code></pre>
<p><strong>OfferRowView</strong></p>
<pre><code>struct OfferRowView: View {
    @ObservedObject var offerRowViewModel: OfferRowViewModel
    
    var body: some View {
        // Convenience variable for accessing the offer &amp; listing.
        let offer = offerRowViewModel.offer
        let listing = offerRowViewModel.listing
        
        return VStack {
            Text(offer.id ?? &quot;ID&quot;)
            Text(listing?.id ?? &quot;ID&quot;)
            } // VStack
    } // View
}
</code></pre>
<p><strong>OfferRowViewModel</strong></p>
<pre><code>class OfferRowViewModel: ObservableObject, Identifiable {
    // Properties
    var id: String = &quot;&quot;
    var listingRepository: ListingRepository
    
    // Published Properties
    @Published var offer: Offer
    @Published var listing: Listing?
    
    // Combine Cancellable
    private var cancellables = Set&lt;AnyCancellable&gt;()
        
    // Initializer
    init(offer: Offer, listingRepository: ListingRepository) {
        self.offer = offer
        self.listingRepository = listingRepository
        self.startCombine()
    }
    
    // Starting Combine
    func startCombine() {
        // Get Offer
        $offer
            .receive(on: RunLoop.main)
            .compactMap { offer in
                offer.id
            }
            .assign(to: \.id, on: self)
            .store(in: &amp;cancellables)
        
        // Get Connected Listing
        listingRepository
            .$listings
            .receive(on: RunLoop.main)
            .map { listings in
                listings
                    .first(where: { $0.id == self.offer.listingId})
            }
            .assign(to: \.listing, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
","4441627","","","","","2022-08-30 04:18:57","SwiftUI List Repeating ID Value","<google-cloud-firestore><swiftui><combine><swiftui-list>","1","6","1","","","CC BY-SA 4.0"
"69371982","1","69372727","","2021-09-29 07:18:16","","0","287","<p>For scientific reasons I've created a <strong>Publisher</strong> and a <strong>Subscriber</strong> so I can dive into Combine.</p>
<p>The <strong>Publisher</strong> has been converted from a <strong>never failing</strong> to the <strong>failing</strong> one.</p>
<pre class=""lang-swift prettyprint-override""><code>enum IntegerError: String, Error {
    case miltupleOf2 = &quot;We are sorry but the number is a multiple of 2, therefore cannot be used in the process&quot;
}

let integerPublisher = [1,3,3,3,3,3,5,6,7,7].publisher
    .setFailureType(to: IntegerError.self)

let subscribtion = integerPublisher
    .tryMap { intValue in
        if intValue.isMultiple(of: 2) {
            throw IntegerError.miltupleOf2
        } else {
            return intValue
        }
    }
    .sink { completion in
        switch completion {
        case .finished:
            print(&quot;success&quot;)
        case .failure(let error):
            if let error = error as? IntegerError {
                print(error.rawValue)
            } else {
                print(error)
            }
        }
    } receiveValue: { value in
        print(value)
    }
</code></pre>
<p>My question is: when using <strong>sink</strong>, the error type is <strong>Error</strong>. Why is it not the custom <strong>IntegerError</strong> that I've used within the <strong>.setFailureType</strong> modifier?</p>
<p>The need of casting my error to the type that I specified earlier seems a little redundant.</p>
<p>Thank you.</p>
","14880022","","","","","2021-09-29 08:12:50","Swift Combine framework setFailureType error operator","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"69377180","1","","","2021-09-29 13:16:41","","1","50","<p>I am using the code here. But I couldn't figure out how to use the code here.</p>
<p><strong>Stack Overflow <a href=""https://stackoverflow.com/questions/65126447/error-is-not-triggering-on-url-session-using-combine"">link</a></strong></p>
<p>How can I run this function with combine?
How can I run a function with return type <code>AnyPublisher&lt;T, NetworkingError&gt;</code> with combine and catch errors.
my apikey is faulty and i want to catch this error.</p>
<p><strong>Function:</strong></p>
<pre><code>private func performOperation&lt;T: Decodable&gt;(requestUrl: URLRequest, responseType: T.Type) -&gt; AnyPublisher&lt;T, NetworkingError&gt; {
        URLSession.shared.dataTaskPublisher(for: requestUrl)
            .jsonDecodingPublisher(type: T.self)
    }
</code></pre>
<p><strong>My Code:</strong></p>
<pre><code>class MovieService {
    
    private let baseURL = &quot;https://api.themoviedb.org/3/movie&quot;
    private let apiKey = &quot;594b8eb4999a8b44ad5136ee3ed1ebdb31&quot;
    private let language = &quot;language=en-US&quot;
    var anyCancellable = Set&lt;AnyCancellable&gt;()
    init() { }
    
    func loadAllMovie(categoryType: CategoryType, page: Int) -&gt; Future&lt;Movie, Error&gt; {
        
        
        if let url = URL(string: baseURL + &quot;/&quot; + categoryType.rawValue + &quot;?&quot; + &quot;api_key=&quot; + apiKey + &quot;&amp;&quot; + language + &quot;&amp;&quot; + &quot;page=&quot; + &quot;\(page)&quot;) {
            
            let foo = performOperation(requestUrl: URLRequest(url: url), responseType: Movie.self)
            foo
                .receive(on: DispatchQueue.main)
                .sink { error in
                    switch error {
                        
                    case .finished:
                        print(&quot;end&quot;)
                    case .failure(let error):
                        print(error.localizedDescription)
                    }
                } receiveValue: { movie in
                    print(movie)
                }
                .store(in: &amp;anyCancellable)
            
        } else {
            print(&quot;url sıkıntılı&quot;)
        }
        
        
        
        if let data = getData(from: baseURL, categoryType: categoryType, page: page) {
            do {
                
                let bookDecoder = try JSONDecoder().decode(Movie.self, from: data)
                
                return Future { promixe in
                    promixe(.success(bookDecoder))
                }
            }catch {
                debugPrint(error.localizedDescription)
                debugPrint(&quot;errrrr: \(error)&quot;)
                print(&quot;olmadı&quot;)
            }
        }
        return Future{ _ in }
    }
    
    private func performOperation&lt;T: Decodable&gt;(requestUrl: URLRequest, responseType: T.Type) -&gt; AnyPublisher&lt;T, NetworkingError&gt; {
        URLSession.shared.dataTaskPublisher(for: requestUrl)
            .jsonDecodingPublisher(type: T.self)
    }
    
    private func getData(from urlString: String, categoryType: CategoryType, page: Int) -&gt; Data? {
        
        guard let url = URL(string: urlString + &quot;/&quot; + categoryType.rawValue + &quot;?&quot; + &quot;api_key=&quot; + apiKey + &quot;&amp;&quot; + language + &quot;&amp;&quot; + &quot;page=&quot; + &quot;\(page)&quot;) else {
            fatalError(&quot;Couldn't load URL from provided string.&quot;)
        }
        
        do {
            return try Data(contentsOf: url)
        } catch {
            debugPrint(&quot;Couldn't load data from URL:\n\(error)&quot;)
            return nil
        }
    }
}

enum NetworkingError: Error {
    case decoding(DecodingError)
    case incorrectStatusCode(Int)
    case network(URLError)
    case nonHTTPResponse
    case unknown(Error)
}

extension Publisher {
    func mapErrorToNetworkingError() -&gt; AnyPublisher&lt;Output, NetworkingError&gt; {
        mapError { error -&gt; NetworkingError in
            switch error {
            case let decodingError as DecodingError:
                return .decoding(decodingError)
            case let networkingError as NetworkingError:
                return networkingError
            case let urlError as URLError:
                return .network(urlError)
            default:
                return .unknown(error)
            }
        }
        .eraseToAnyPublisher()
    }
}

extension URLSession.DataTaskPublisher {
    func emptyBodyResponsePublisher() -&gt; AnyPublisher&lt;Void, NetworkingError&gt; {
        httpResponseValidator()
            .map { _ in Void() }
            .eraseToAnyPublisher()
    }
}

extension URLSession.DataTaskPublisher {
    func httpResponseValidator() -&gt; AnyPublisher&lt;Output, NetworkingError&gt; {
        tryMap { data, response in
            guard let httpResponse = response as? HTTPURLResponse else { throw NetworkingError.nonHTTPResponse }
            let statusCode = httpResponse.statusCode
            guard (200..&lt;300).contains(statusCode) else { throw NetworkingError.incorrectStatusCode(statusCode) }
            return (data, httpResponse)
        }
        .mapErrorToNetworkingError()
    }
    
    func httpResponseValidatorDataPublisher() -&gt; AnyPublisher&lt;Data, NetworkingError&gt; {
        httpResponseValidator()
            .map(\.data)
            .eraseToAnyPublisher()
    }
    
    func jsonDecodingPublisher&lt;T:Decodable&gt;(type: T.Type) -&gt; AnyPublisher&lt;T, NetworkingError&gt; {
        httpResponseValidatorDataPublisher()
            .decode(type: T.self, decoder: JSONDecoder())
            .mapErrorToNetworkingError()
    }
}
</code></pre>
","13125522","","","","","2021-09-29 13:16:41","wrong url is not triggering error using combine","<swift><error-handling><combine>","0","1","","","","CC BY-SA 4.0"
"69389169","1","","","2021-09-30 08:51:48","","-1","136","<p>I have zipped two publishers in the function, which downloads users and vehicles with a backend API:</p>
<pre class=""lang-swift prettyprint-override""><code>   func fetchUserAndvehicles() {
       Publishers.Zip(UserApiClient().getUser(), VehicleApiClient().getVehicles())
           .eraseToAnyPublisher()
           .receive(on: DispatchQueue.main)
           .sink(receiveCompletion: { [weak self] completion in
               switch completion {
               case .failure(let error):
                   self?.errorHandling.showErrorAlert(error)
               case .finished:
                   break
               }
               }, receiveValue: { [weak self] user, vehicles in
                   // store vehicles in the user object
           })
           .store(in: &amp;subscriptions)
   }
</code></pre>
<p>Each of the vehicles have an <code>imageUrl</code> that can be used to download an image of the vehicle. This works fine. But I would like to download the images, if any, before I store the vehicles in the user object. Is it possible to use the same combine pipeline to do this? I tried with a <code>flatMap</code>, but that resulted in a compile error.</p>
<p>The following is following the excellent answer from Cristik. It looks ok, but Xcode flags the <code>flatMap</code> line with <code>No exact matches in call to instance method 'flatMap'</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>let vehiclesPublisher = VehicleApiClient().getVehicles()
    .flatMap { vehicles in
        Publishers.Zip(Just(vehicles).setFailureType(to: Error.self), Publishers.MergeMany(vehicles.map { VehicleApiClient().getImage(at: $0.url)}).collect())
    }
    .map {
        return $0.0
    }
</code></pre>
<p>The vehicles have an optional property that needs to be unwrapped, but that isn't the cause of the compile error.</p>
","6394244","","6394244","","2021-10-01 15:04:27","2021-10-01 15:04:27","Combine pipeline to download image from Zipped publishers","<swift><combine>","1","2","1","","","CC BY-SA 4.0"
"69400510","1","","","2021-10-01 04:45:12","","0","204","<p>So I am posting this notification:</p>
<pre><code>NotificationCenter.default.post(name: .helloStack, object: obj)
</code></pre>
<p><strong>I am posting it only once</strong>.</p>
<p>I have a model class that is subscribing to it like so:</p>
<pre><code>helloSubscriber = NotificationCenter.default.publisher(for: .helloStack)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] notification in

                // this is called more than once (twice)

                ....
            }
</code></pre>
<p>So, the closure, <strong>is called more than once</strong> and I checked to make sure that the notification is only posted once.</p>
<p>Why am I getting the closure called twice?</p>
","728246","","728246","","2021-10-01 04:55:09","2021-10-01 10:52:37","Swift NotificationCenter publisher subscriber called more than once?","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"69403867","1","","","2021-10-01 09:49:20","","4","363","<p>I get an unexpected result by using Combine's <code>assign(to:)</code> directly after <code>compactMap</code>. Here the code, it's 100% reproducible for me in Xcodes Playground, Xcode Version 13.0 (13A233).</p>
<pre><code>import Combine
import Foundation

class Test {
    @Published var current: String?
    @Published var latest1: String?
    @Published var latest2: String?
    @Published var latest3: String?
    
    init() {
        // Broken? - compactMap passes nil downstream
        self.$current
           .compactMap { $0 }
           .assign(to: &amp;self.$latest1)
        
        // Fixed by specifying the transform closure type explicitely
        self.$current
            .compactMap { value -&gt; String? in value }
            .assign(to: &amp;self.$latest2)
        
         // Fixed by an additional map inbetween
         self.$current
            .compactMap { $0 }
            .map { $0 }
            .assign(to: &amp;self.$latest3)
    }
}

let obj = Test()

obj.current = &quot;success&quot;

print(&quot;current: \(String(describing: obj.current))&quot;)
print(&quot;latest1: \(String(describing: obj.latest1))&quot;)
print(&quot;latest2: \(String(describing: obj.latest2))&quot;)
print(&quot;latest3: \(String(describing: obj.latest3))&quot;)
print(&quot;&quot;)

obj.current = nil

print(&quot;current: \(String(describing: obj.current))&quot;)
print(&quot;latest1: \(String(describing: obj.latest1))&quot;) // nil shouldn't arrive here
print(&quot;latest2: \(String(describing: obj.latest2))&quot;)
print(&quot;latest3: \(String(describing: obj.latest3))&quot;)

// Output:
//current: Optional(&quot;success&quot;)
//latest1: Optional(&quot;success&quot;)
//latest2: Optional(&quot;success&quot;)
//latest3: Optional(&quot;success&quot;)
//
//current: nil
//latest1: nil
//latest2: Optional(&quot;success&quot;)
//latest3: Optional(&quot;success&quot;)
</code></pre>
<p>Maybe I miss something obvious here? Or could this be a bug in Combine?. Thanks for your attention.</p>
<hr />
<p>Update: I updated the example code with a more concise version</p>
","2664531","","2664531","","2021-10-01 15:21:58","2021-10-01 15:47:57","Swift Combine compactMap does not work (Xcode 13)","<ios><swift><xcode><combine>","1","1","2","","","CC BY-SA 4.0"
"69407381","1","","","2021-10-01 14:16:08","","0","166","<p>I would like to run some function when the <strong>Entity</strong> is not only loaded bout also has been successfully appended to the <strong>AnchorEntity</strong></p>
<p>Right now my entity is being loaded asynchronously.</p>
<pre class=""lang-swift prettyprint-override""><code> func addModel(to planeAnchor: AnchorEntity) {
        Entity.loadAsync(named: &quot;SomeUSDZModel&quot;)
            .sink { completion in
                switch completion {
                case .finished:
                    print(&quot;Ok&quot;)
                case .failure(let error):
                    print(error.localizedDescription)
                }
            } receiveValue: { model in
                // Entity should be added before the animation is started.
                planeAnchor.addChild(model)
                if let walkingAnimation = model.availableAnimations.first {
                    model.playAnimation(walkingAnimation.repeat(duration: .infinity),
                                        transitionDuration: 1.25,
                                        blendLayerOffset: 0,
                                        separateAnimatedValue: false,
                                        startsPaused: false)

                }
                self.model = model
                
            }
            .store(in: &amp;subscriptions)
            doSomething()
    }
</code></pre>
<p>Method <strong>doSomething()</strong> fires off too early. I want to fire it off upon some conditional check.</p>
","14880022","","","","","2021-10-03 06:01:17","iOS, RealityKit. How would you check if the Entity is appended to EntityAnchor","<swift><arkit><combine><realitykit>","1","0","","","","CC BY-SA 4.0"
"69416170","1","69419852","","2021-10-02 10:46:00","","1","99","<p>I'd like to combine two dataframes d1 and d2 in R. It should be grouped by &quot;ID&quot;, but at the end there should only exist one column &quot;date&quot; so that further analysis are possible (It is important to know if the &quot;number&quot;-entry (d2) is linked to the &quot;type&quot;-entry (d1) or how close it is to it)</p>
<p>Lets say d1 and d2 is</p>
<pre><code>d1 &lt;- data.frame(ID = c(1,1,2,2,2,3), 
                 sex = c(&quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;),
                 date = c(&quot;2016-06-21 08:15:00&quot;, &quot;2016-06-21 23:00:00&quot;,
                          &quot;2017-04-19 07:15:00&quot;, &quot;2017-04-20 07:15:00&quot;, &quot;2017-04-20 08:15:00&quot;,
                          &quot;2017-08-20 23:15:00&quot; ),
                 type = c(&quot;horse&quot;, &quot;snake&quot;, &quot;horse&quot;, &quot;horse&quot;, &quot;monkey&quot;, &quot;fish&quot;))

d2 &lt;- data.frame(ID = c(1,1,1,2,2,3,3), 
                 date = c(&quot;2016-06-20 08:15:00&quot;, &quot;2016-06-21 22:15:00&quot;, &quot;2016-06-22 08:45:00&quot;,
                          &quot;2017-04-19 07:15:00&quot;, &quot;2017-04-19 09:30:00&quot;,
                          &quot;2017-08-19 08:15:00&quot;, &quot;2017-08-21 06:30:00&quot;),
                 number = c(65,234,64,234,6243,23,243))
</code></pre>
<p>My desired output would be</p>
<pre><code>d12 &lt;- data.frame(ID = c(1,1,1,1,1,2,2,2,2,3,3,3),
                  sex = c(NA, &quot;male&quot;, NA, &quot;male&quot;, NA, &quot;male&quot;, NA, &quot;male&quot;, &quot;male&quot; , NA, &quot;female&quot;, NA),
                  date = c(&quot;2016-06-20 08:15:00&quot;,&quot;2016-06-21 08:15:00&quot;, &quot;2016-06-21 22:15:00&quot;, &quot;2016-06-21 23:00:00&quot;, &quot;2016-06-22 08:45:00&quot;,
                          &quot;2017-04-19 07:15:00&quot;, &quot;2017-04-19 09:30:00&quot;, &quot;2017-04-20 07:15:00&quot;, &quot;2017-04-20 08:15:00&quot;,
                          &quot;2017-08-19 08:15:00&quot;, &quot;2017-08-20 23:15:00&quot;, &quot;2017-08-21 06:30:00&quot; ),
                  type = c(NA, &quot;horse&quot;, NA, &quot;snake&quot;, NA, &quot;horse&quot;, NA, &quot;horse&quot;, &quot;monkey&quot;, NA, &quot;fish&quot;, NA),
                  number= c(65, NA, 234, NA, 64, 234, 6243, NA, NA, 23, NA, 243))

</code></pre>
<p>I tried doing this</p>
<pre><code>d12 &lt;- full_join(
  d1 %&gt;% group_by(ID) %&gt;% mutate(time=row_number()),
  d2 %&gt;% group_by(ID) %&gt;% mutate(time=row_number()),
by = c(&quot;ID&quot;, &quot;time&quot;))
</code></pre>
<p>But more or less I just added some columns, I don't really come closer to my desired output. I am very looking forward to your help.</p>
","17057491","","17057491","","2021-10-02 20:31:40","2021-10-02 20:31:40","How to combine two data-frames by group and date","<r><dataframe><group-by><merge><combine>","1","6","","","","CC BY-SA 4.0"
"69417754","1","69419750","","2021-10-02 14:21:28","","2","312","<p>This code does not compile on iOS 13 because flatMap is available only in iOS 14. How to extend SubscribeOn to have flatMap operator?</p>
<pre><code>func f1(_ value: Int) -&gt; Future&lt;Int, Error&gt; {
    Future { promise in
        print(&quot;\(Thread.current): f1() value = \(value)&quot;)
        promise(.success(value + 1))
    }
}

func f2(_ value: Int) -&gt; Future&lt;Int, Error&gt; {
    Future { promise in
        print(&quot;\(Thread.current): f2() value = \(value)&quot;)
        promise(.success(value + 1))
    }
}

let a1 = Just(0)
    .subscribe(on: DispatchQueue.global())
    .flatMap(f1)
    .flatMap(f2)
    .receive(on: DispatchQueue.main)
    .sink { _ in
        print(&quot;\(Thread.current): completed&quot;)
    } receiveValue: { value in
        print(&quot;\(Thread.current): sink() value = \(value)&quot;)
    }
</code></pre>
<p>UPDATE
Here is how my solution looks like now:</p>
<pre><code>extension Publishers.SubscribeOn {
    func myFlatMap&lt;P&gt;(_ transform: @escaping (Self.Output) -&gt; P) -&gt; Publishers.FlatMap&lt;P, Publishers.SetFailureType&lt;Self, P.Failure&gt;&gt; where P: Publisher {
        Publishers.FlatMap&lt;P, Publishers.SetFailureType&lt;Self, P.Failure&gt;&gt;(
            upstream: Publishers.SetFailureType&lt;Self, P.Failure&gt;(upstream: self),
            maxPublishers: .unlimited,
            transform: transform
        )
    }
}
</code></pre>
","2464355","","2464355","","2021-10-02 16:48:47","2021-10-02 19:54:10","How to get SubscribeOn flatMap operator for iOS 13?","<swift><ios13><combine>","1","0","","","","CC BY-SA 4.0"
"69422869","1","","","2021-10-03 07:24:40","","0","169","<p>I have built a simplified combine pipeline in my Xcode Playground, to make car objects <code>[CarWithImage]</code> from an array of cars, <code>[Car]</code>. That seems to work fine. But I would like the pipeline to check each car object for <code>imageString</code>, and if it isn't nil fetch it with the function <code>getImage(_:)</code>. I have commented that code out, because I get the error <code>type of expression is ambiguous without more context</code> and I don't know how to fix that. I would also like to introduce a delay in the pipeline to more realistically simulate a network download of cars and images, and set the <code>CarWithImage</code> image property to nil if the image fetching fails.</p>
<p>I have a Xcode Playground repository on GitHub where you can test out my code. First page is with the original class, the second page is with trying out compactMap: <a href=""https://github.com/imyrvold/CarsPlayground.git"" rel=""nofollow noreferrer"">Cars Playground</a></p>
<p>The code will run in Xcode Playground:</p>
<pre class=""lang-swift prettyprint-override""><code>import UIKit
import Combine

struct Car {
    let name: String
    let imageString: String?
}

struct CarWithImage {
    let name: String
    let image: UIImage?
}

final class CarClass {
    let myCars = [Car(name: &quot;Tesla&quot;, imageString: &quot;car&quot;), Car(name: &quot;Volvo&quot;, imageString: nil)]
    let delayCar = 4
    let delayImage = 6
    
    func getVehicles() -&gt; AnyPublisher&lt;[CarWithImage], Error&gt; {
        myCars.publisher
            .flatMap { car in
//                if let imageString = car.imageString {
//                    getImage(imageString)
//                        .flatMap { image in
//                            return Just(CarWithImage(name: car.name, image: image))
//                        }
//                }
                return Just(CarWithImage(name: car.name, image: nil))
            }
            .collect()
            .flatMap { cars in
                cars.publisher.setFailureType(to: Error.self)
            }
            .collect()
            .eraseToAnyPublisher()
    }
    
    func getImage(_ string: String) -&gt; AnyPublisher&lt;UIImage, Error&gt; {
        Just(UIImage(systemName: string)!)
            .flatMap { image in
                Just(image).setFailureType(to: Error.self)
            }
            .eraseToAnyPublisher()
    }
}

let carClass = CarClass()
carClass.getVehicles()
    .sink(receiveCompletion: { print($0)}) { cars in
        cars.forEach { car in
            let haveImage = car.image != nil
            let string = haveImage ? &quot;and it have an image&quot; : &quot;&quot;
            print(&quot;The car is&quot;, car.name, string)
        }
    }

// This is just to check that the getImage function works
carClass.getImage(&quot;car&quot;)
    .sink(receiveCompletion: { print($0)}) { image in
        print(&quot;Got image&quot;, image)
    }
</code></pre>
<p>After suggestion to use compactMap, I have modified the class, but now I only get cars when the car have an image:</p>
<pre class=""lang-swift prettyprint-override""><code>final class CarClass {
    let myCars = [Car(name: &quot;Tesla&quot;, imageString: &quot;bolt.car&quot;), Car(name: &quot;Volvo&quot;, imageString: nil)]
    let delayCar = 4
    let delayImage = 6
    
    func getVehicles() -&gt; AnyPublisher&lt;[CarWithImage], Error&gt; {
        myCars.publisher
            .flatMap { car in
                self.getImage(car.imageString)
                    .compactMap { $0 }
                    .flatMap { image in
                        return Just(CarWithImage(name: car.name, image: image))
                    }
            }
            .collect()
            .flatMap { cars in
                cars.publisher.setFailureType(to: Error.self)
            }
            .collect()
            .eraseToAnyPublisher()
    }
    
    func getImage(_ string: String?) -&gt; AnyPublisher&lt;UIImage?, Error&gt; {
        guard let imageString = string else { return Just(nil).setFailureType(to: Error.self).eraseToAnyPublisher() }
        return Just(UIImage(systemName: imageString))
            .flatMap { image in
                Just(image).setFailureType(to: Error.self)
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>
","6394244","","6394244","","2021-10-03 08:54:32","2021-10-03 12:36:30","Combine pipeline for object with image","<swift><combine>","3","1","","","","CC BY-SA 4.0"
"69424516","1","69425705","","2021-10-03 11:41:05","","2","240","<p>I'm trying to use Combine to do several millions concurrent request through the network. Here is a mock up of the naive approach I'n using:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

let cancellable = (0..&lt;1_000_000).publisher
  .map(some_preprocessing)
  .flatMap(maxPublishers: .max(32)) { request in
    URLSession.dataTaskPublisher(for: request)
      .map(\.data)
      .catch { _ in
        return Just(Data())
      }
  }
  .sink { completion in
    print(completion)
  } receiveValue: { value in
    print(value)
  }

// Required in a command line tool
sleep(100)
</code></pre>
<p>This pipeline first creates a request, the the request is done in <code>flatMap</code> to confine errors. Also, <code>flatMap</code> merges several requests to they are effectively done concurrently, which is great.</p>
<p>The issue is that it will literally make 1,000,000 requests concurrently, so I added the parameter <code>maxPublishers</code> which limits the number of publishers that are subscribed at the same time in <code>flatMap</code>. This kind of work, only 32 publishers are active at the same time, but unfortunately <code>some_preprocessing</code> will still be performed 1,000,000 times before <code>flatMap</code> will be executed.</p>
<p>I expected <code>flatMap(maxPublishers: .max(32))</code> to apply some back pressure, i.e. only requesting items from the upstream publisher <code>map</code> when <code>maxPublishers</code> &lt; 32. This does not seem to be the case, and it fills up the RAM rapidly and delays the processing.</p>
<p>I then tried to use the <code>buffer</code> operator that is used to introduce back pressure between a producer and a consumer, but Apple documentation is so poor I don't understand its functioning (more specifically the <code>prefechStrategy</code> argument).</p>
<p>So I tried different combinations such as:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

let cancellable = (0..&lt;1_000_000).publisher
  .map(some_preprocessing)
  .buffer(size: 32, prefetch: .byRequest, whenFull: .dropNewest)
  .flatMap(maxPublishers: .max(32)) { request in
    URLSession.dataTaskPublisher(for: request)
      .map(\.data)
      .catch { _ in
        return Just(Data())
      }
  }
  .sink { completion in
    print(completion)
  } receiveValue: { value in
    print(value)
  }

// Required in a command line tool
sleep(100)
</code></pre>
<p>This does not seem to do anything useful though, <code>flatMap</code> still requests as much element as it can.</p>
<p><strong>How to properly apply back pressure in this case? I.e I need the upstream <code>map</code> publisher to &quot;wait&quot; for demand asked by the downstream publisher <code>flatMap</code>, which should only ask items when it as an empty slot.</strong></p>
","6324055","","","","","2021-10-05 15:18:21","How to apply back pressure with Combine buffer operator to avoid flatMap to ask an infinite demand upstream?","<swift><reactive-programming><combine>","1","5","","","","CC BY-SA 4.0"
"69441902","1","69444427","","2021-10-04 20:13:24","","1","1002","<p>I have a strange infinite loop when using onAppear and I cannot identify the root of the problem. It only happens when the view is the detail view of a navigation view, but it works fine when it's the root view.
Another interesting thing is that if I wrap the detail view in a NavigationView (so, now we have a navigation view inside a navigation view), then the issue does not appear anymore. Is this a bug in SwiftUI? Is conceptually my design OK? I mean, using onAppear like viewDidLoad to trigger the initial sequence.
Thanks for suggestions.</p>
<p>Here is the source code.
ContentView.swift:</p>
<pre><code>import SwiftUI

struct ContentView: View {

    @StateObject var viewModel = ContentViewModel()

    var body: some View {
        NavigationView {
            VStack {
                Group {
                    switch viewModel.state {
                    case .loading:
                        Text(&quot;Loading...&quot;)
                    case .loaded:
                        HStack {
                            Text(&quot;Loaded&quot;)
                            Button(&quot;Retry&quot;) {
                                viewModel.fetchData()
                            }
                        }
                    }
                }
                .padding(.bottom, 20)
                NavigationLink(&quot;Go to detail screen&quot;, destination: DetailView())
            }
        }
        .onAppear() {
            viewModel.fetchData()
        }
    }
}

class ContentViewModel: ObservableObject  {

    enum State {
        case loading
        case loaded
    }

    @Published var state: State = .loading

    func fetchData() {
        state = .loading
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.state = .loaded
        }
    }
}
</code></pre>
<p>And here the code of the detail view:</p>
<pre><code>import SwiftUI

struct DetailView: View {

    @StateObject var viewModel = DetailViewModel()

    var body: some View {
        Group {
            switch viewModel.state {
            case .loading:
                Text(&quot;Loading...&quot;)
            case .loaded:
                HStack {
                    Text(&quot;Loaded&quot;)
                    Button(&quot;Retry&quot;) {
                        viewModel.fetchData()
                    }
                }
            }
        }
        .onAppear() {
            print(&quot;infinite loop here&quot;)
            viewModel.fetchData()
        }
    }
}

class DetailViewModel: ObservableObject  {

    enum State {
        case loading
        case loaded
    }

    @Published var state: State = .loading

    func fetchData() {
        state = .loading
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            self.state = .loaded
        }
    }
}
</code></pre>
<p>Here I attach the project:
<a href=""https://www.dropbox.com/s/5alokj3q81jbpj7/TestBug.zip?dl=0"" rel=""nofollow noreferrer"">https://www.dropbox.com/s/5alokj3q81jbpj7/TestBug.zip?dl=0</a></p>
<p>I'm using Xcode Version 12.5.1 (12E507) and iOS 14.5</p>
<p>Thanks a lot.</p>
","917338","","","","","2022-02-08 19:58:45","Infinite loop when using onAppear in SwiftUI","<swiftui><combine>","2","5","1","","","CC BY-SA 4.0"
"69442617","1","","","2021-10-04 21:31:54","","0","68","<p>There are three textFields.</p>
<p>Q1: How to move cursor (change firstResponder) to the first textField when backward deletion pressed in the empty second one.</p>
<p>Q2: Is there a way to subscribe to deleteBackward() event with Combine?</p>
<p>Q3: My code works fine on iOS 14.5, but on 15.0 catches &quot;AttributeGraph: cycle detected through attribute&quot;. Any ideas why and how to fix it?</p>
<pre><code>struct ContentView: View {
    
    @State var text1 = &quot;&quot;
    @State var text2 = &quot;&quot;
    @State var text3 = &quot;&quot;
    
    @State private var isFirstResponder: [Bool] = [true, false, false]
    
    var body: some View {
        HStack {
            CustomTextField(text: $text1, tag: 0, returnValue: .next, isFirstResponder: $isFirstResponder)
                .modifier(TextFieldStyle())
            CustomTextField(text: $text2, tag: 1, returnValue: .next, isFirstResponder: $isFirstResponder)
                .modifier(TextFieldStyle())
            CustomTextField(text: $text2, tag: 2, returnValue: .next, isFirstResponder: $isFirstResponder)
                .modifier(TextFieldStyle())
        }
            .frame(height: 40)
            .padding()
    }
}

struct TextFieldStyle: ViewModifier {
    
    func body(content: Content) -&gt; some View {
        content
            .padding(.all, 10)
            .background(RoundedRectangle(cornerRadius: 5).fill(Color.white))
            .overlay(
                RoundedRectangle(cornerRadius: 5)
                    .stroke(lineWidth: 1)
            )
            .foregroundColor(Color.black.opacity(0.7))
    }
}

private class CustomUITextField: UITextField {
    override public func deleteBackward() {
        print(&quot;deleteBackward&quot;)
        super.deleteBackward()
        if text == &quot;&quot; {
            print(&quot;deleteBackward on empty&quot;)
        }
    }
}

struct CustomTextField: UIViewRepresentable {
    
    @Binding var text: String
    let tag: Int
    let returnValue: UIReturnKeyType
    @Binding var isFirstResponder: [Bool]
    
    func makeUIView(context: Context) -&gt; UITextField {
        let textField = CustomUITextField(frame: .zero)
        
        textField.keyboardType = .numberPad
        textField.autocorrectionType = .no
        textField.returnKeyType = returnValue
        textField.tag = tag
        textField.delegate = context.coordinator
        
        return textField
    }
    
    func updateUIView(_ uiView: UITextField, context: Context) {
        if isFirstResponder[tag] {
            uiView.becomeFirstResponder()
        } else {
            uiView.resignFirstResponder()
        }
    }
    
    func makeCoordinator() -&gt; Coordinator {
        Coordinator(text: $text, self)
    }
    
    class Coordinator: NSObject, UITextFieldDelegate {
        
        @Binding var text: String
        var parent: CustomTextField
        
        init(text: Binding&lt;String&gt;, _ textField: CustomTextField) {
            _text = text
            parent = textField
        }
        
        func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool {
            let currentText = textField.text ?? &quot;&quot;
            var isDeleting = string.count == 0
            
            if (currentText + string).count == 1 &amp;&amp; !isDeleting {
                parent.isFirstResponder = [false, false, false]
                parent.isFirstResponder[min(parent.tag + 1, 2)] = true
            } else if currentText.count &lt;= 1 &amp;&amp; isDeleting {
                parent.isFirstResponder = [false, false, false]
                parent.isFirstResponder[max(parent.tag - 1, 0)] = true
            } else if (currentText + string).count &gt; 3 {
                return false
            }
            
            print(&quot;textField \(currentText) -&gt; \(string)&quot;)
            return true
        }
    }
}
</code></pre>
","5571441","","5571441","","2021-10-05 12:29:06","2021-10-05 12:29:06","How to change firstResponder on deleteBackward in empty textField","<ios><swift><combine>","0","1","","","","CC BY-SA 4.0"
"69449662","1","","","2021-10-05 11:31:46","","0","206","<p>So this is basically how my code looks. I run a request, when it's finished and i get some result, i run the next. I do this 3 times, however, it just dies efter the first one and wont continue.</p>
<pre><code>private func getSomething(with model: SomeModel) {
        networker.runRequest(.getSomething, model: Something.self)
            .receiveOnMain()
            .sink { [weak self] completion in
                self?.handleCompletion(completion: completion)
            } receiveValue: { [weak self] model in
                self?.getData(with: model)
                
            }
            .store(in: &amp;cancellableSet)
    }
    
    func getData(with model: SomeModel) {
        networker.runRequest(.getData, model: DataModel.self)
            .recieveOnMain()
            .sink { [weak self] completion in
                self?.handleCompletion(completion: completion)
            } receiveValue: { secondaryModel in
                print(&quot;complete&quot;)
            }
            .store(in: &amp;cancellableSet)
    }

    func getSomethingElse(with somethingElse: SomeModel) {
        networker.runRequest(.getSomethingElse, model: SomethingElse.self)
            .recieveOnMain()
            .sink { [weak self] completion in
                self?.handleCompletion(completion: completion)
            } receiveValue: { secondaryModel in
                print(&quot;complete&quot;)
            }
            .store(in: &amp;cancellableSet)
    }
</code></pre>
<p>the networker looks like this:</p>
<pre><code>func executeRequest&lt;T: Decodable&gt;(requestModel: NewRequestable, triesLeft: Int, model: T.Type) -&gt; AnyPublisher&lt;T, Error&gt; {
    urlSession.createDataTaskPublisher(for: requestModel.buildRequest())
        .mapError { $0 as Error }
        .flatMap({
            self.publisher(forDataTaskOutput: $0, requestModel: requestModel, triesLeft: triesLeft, model: model)
        })
        .eraseToAnyPublisher()
}
</code></pre>
<p>where the self.publisher func looks like:</p>
<pre><code>private func publisher&lt;T: Decodable&gt;(forDataTaskOutput output: URLSession.DataTaskPublisher.Output, requestModel: NewRequestable, triesLeft: Int, model: T.Type) -&gt; AnyPublisher&lt;T, Error&gt; {
    switch (output.response as? HTTPURLResponse)?.statusCode {
    case .some(200...399):
        return Just(output.data)
            .decode(type: T.self, decoder: JSONDecoder())
            .mapError { error -&gt; APIError in
                APIError.apiError(reason: error.localizedDescription)
            }
            .eraseToAnyPublisher()
    case .some(401) where triesLeft &gt; 0:
        return authenticator.updateToken()
            .flatMap { tokenResponse -&gt; AnyPublisher&lt;T, Error&gt; in
                self.authenticator.token = .OAuth2(tokenResponse.access_token)
                return self.executeRequest(requestModel: requestModel, triesLeft: triesLeft - 1, model: model) }
            .eraseToAnyPublisher()
    default:
        return Result.failure(NSError(domain: &quot;&quot;, code: 1, userInfo: nil)).publisher.eraseToAnyPublisher()
    }
}
</code></pre>
<p>It however the second request never gets to the publisher func. Why is this? Is it queing up something somehow?</p>
<p>Edit:
According to charles proxy, the second request is never executed at all.</p>
<p>Edit 2: I noticed it works if i remove the <code>.recieveOnMain()</code> from each publisher. But then it complains that i have to run the recieveValue in the sink on main thread. so kinda stuck</p>
","4757272","","4757272","","2021-10-05 12:05:36","2021-10-05 13:14:50","Swift combine sequence of requests stop","<swift><request><combine><networkextension>","1","1","","","","CC BY-SA 4.0"
"69461976","1","","","2021-10-06 08:08:02","","1","1072","<p>I'm having a hard time figuring out how to create a Swift Combine pipeline that contains a <code>.flatMap</code> which has a reference to <code>self</code>. In order to prevent a retain cycle, this should be a <code>[weak self]</code> reference, but this does not work with a <code>.flatMap</code>.</p>
<p>Here is a simplified example showing my problem:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class SomeService {
    func someOperation(label: String) -&gt; Future&lt;String, Never&gt; {
        Future { promise in
            print(&quot;Starting work for&quot;, label)
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                print(&quot;Finished work for&quot;, label)

                promise(.success(label))
            }
        }
    }
}

class SomeDataSource {
    let someService = SomeService()
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    deinit {
        print(&quot;Deinit SomeDataSource&quot;)
    }
    
    func complexOperation() {
        // First part 'defined' is inside the complexOperation method:
        someService.someOperation(label: &quot;First part&quot;)
            // Second part is 'defined' in another method (it is shared with other tasks)
            .flatMap { _ in self.partOfComplexOperation(label: &quot;Second part&quot;) } // &lt;--- This creates a retain cycle
            .sink { label in
                print(&quot;Received value in sink&quot;, label)
            }
            .store(in: &amp;cancellables)
    }
    
    func partOfComplexOperation(label: String) -&gt; Future&lt;String, Never&gt; {
        someService.someOperation(label: label)
    }
}

var someDataSource: SomeDataSource? = SomeDataSource()
someDataSource?.complexOperation()
someDataSource = nil
</code></pre>
<p>Output:</p>
<pre><code>Starting work for First part
Finished work for First part
Starting work for Second part
Finished work for Second part
Received value in sink Second part
Deinit SomeDataSource
</code></pre>
<p>The problem here is that I want my <code>SomeDataSource</code> to be deinitialised right after starting the &quot;First part&quot; and not even starting the second part. So the output I'm looking for is:</p>
<pre><code>Starting work for First part
Deinit SomeDataSource
Finished work for First part
</code></pre>
<p>I'm looking for some kind of combination of <code>.flatMap</code> and <code>.compactMap</code>. Does this exist? If I first <code>.compactMap { [weak self] _ in self }</code> I get the expected result, but maybe there is a better way?</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import Combine

class SomeService {
    func someOperation(label: String) -&gt; Future&lt;String, Never&gt; {
        Future { promise in
            print(&quot;Starting work for&quot;, label)
            
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                print(&quot;Finished work for&quot;, label)

                promise(.success(label))
            }
        }
    }
}

class SomeDataSource {
    let someService = SomeService()
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    deinit {
        print(&quot;Deinit SomeDataSource&quot;)
    }
    
    func complexOperation() {
        // First part 'defined' is inside the complexOperation method:
        someService.someOperation(label: &quot;First part&quot;)
            .compactMap { [weak self] _ in self }
            // Second part is 'defined' in another method (it is shared with other tasks)
            .flatMap { dataSource in dataSource.partOfComplexOperation(label: &quot;Second part&quot;) }
            .sink { label in
                print(&quot;Received value in sink&quot;, label)
            }
            .store(in: &amp;cancellables)
    }
    
    func partOfComplexOperation(label: String) -&gt; Future&lt;String, Never&gt; {
        someService.someOperation(label: label)
    }
}

var someDataSource: SomeDataSource? = SomeDataSource()
someDataSource?.complexOperation()
someDataSource = nil
</code></pre>
<p>Output:</p>
<pre><code>Starting work for First part
Deinit SomeDataSource
Finished work for First part
</code></pre>
","14419315","","","","","2021-10-06 11:00:43","Prevent self retain cycle in combine flatMap","<swift><memory-management><memory-leaks><combine>","1","0","","","","CC BY-SA 4.0"
"69469448","1","69469572","","2021-10-06 16:32:43","","4","308","<p>I have a <code>@Published</code> string in my view model. I want to receive updates on its value in my view controller so that I can update the UI.</p>
<p>I am able to successfully get the updates through use of the <code>sink</code> subscriber. This works fine:</p>
<pre><code>viewModel.$buttonText.sink { [weak self] buttonText in
      self?.buttonOutlet.setTitle(buttonText, for: .normal)
}.store(in: &amp;cancellables)
</code></pre>
<p>But I am looking for a one line approach. Something more like what you are able to do with UILabels using the <code>assign</code> subscriber:</p>
<pre><code>viewModel.$title.assign(to: \.text, on: titleLabel).store(in: &amp;cancellables)
</code></pre>
<p>I've tried accessing the <code>buttonOutlet.titleLabel</code> directly, but this of course doesn't work since we can't directly update the text (<code>UIButton.titleLabel</code> is read-only). And it also introduces the issue of unwrapping the <code>titleLabel</code> property:</p>
<pre><code>viewModel.$buttonText.assign(to: \.!.text, on: buttonOutlet.titleLabel).store(in: &amp;cancellables)
</code></pre>
<p>I don't know if I'm just struggling to find the correct syntax or if this is simply a limitation of Combine for the time being.</p>
","4959716","","4959716","","2021-10-06 16:39:29","2021-10-06 19:02:43","Is there a way to update UIButton's titleLabel text using Combine's .assign instead of .sink?","<swift><uikit><combine>","3","0","","","","CC BY-SA 4.0"
"69476218","1","","","2021-10-07 06:12:07","","0","179","<p>Hei, I have a SwiftUI with its viewModel. When the user taps on the Login button I run the <code>viewModel.registerAccount</code> function.</p>
<pre><code>func registerAccount() {
    authService.registerAccount(params: params)
        .sink { (dataResponse) in
            if let error = dataResponse.error {
                //
            } else {
                //
            }
        }.store(in: &amp;cancellableSet)
}
</code></pre>
<p>In this function I make a call to my <code>AuthService</code> where I want to save some values and change the response.</p>
<pre><code>class AuthService {
    private let apiClient: APIClient = APIClient()
    private var guid: String?

    func registerAccount(params: [String: Any]) -&gt; AnyPublisher&lt;DataResponse&lt;RegisterAccountResponse, Error&gt;, Never&gt; {
        let registerRequest = RegisterAccountRequest(params: params) // (url + method + params + ...)
        let apiRequest = apiClient.request(request: registerRequest)
        // i would like to read response, save guid
        // change response type and return only Error?
        return apiRequest
    }
}
</code></pre>
<p>Also the <code>APIClient</code> definition.</p>
<pre><code>class APIClient {
    private let session: Session = Session(configuration: URLSessionConfiguration.default)
    func request&lt;T: APIRequest&gt;(request: T) -&gt; AnyPublisher&lt;DataResponse&lt;T.Response, Error&gt;, Never&gt; {
        request
            .dataRequest(session: session)
            .publishDecodable(type: T.Response.self)
            .map { response in
                response.mapError { error in
                    return error
                }
            }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>But this doesn't solve my needs. What would I like is to know if there is a way to read the response in <code>AuthService</code>, and return a response of type <code>Error?</code>.</p>
<p>At one point I had this in mind, to listed also in <code>AuthService</code> but I want to change the response and send only an object of format <code>Error?</code>.</p>
<pre><code>func registerAccount(params: [String: Any]) -&gt; 
AnyPublisher&lt;DataResponse&lt;RegisterAccountResponse, Error&gt;, Never&gt; {
    let registerRequest = RegisterAccountRequest(params: params)
    let apiRequest = apiClient.request(request: registerRequest)
        
    apiRequest.sink { dataResponse in
        if let guid = dataResponse.value?.guidFlow {
            self.guid = guid
        }
    }.store(in: &amp;cancellableSet)
        
    return apiRequest
}
</code></pre>
<p>I also thought at this, but I was looking for a more Combine/SwiftUI approach.</p>
<pre><code>func registerAccount(params: [String: Any], completion: @escaping (Error?) -&gt; Void) {
    let registerRequest = RegisterAccountRequest(params: params)
    let apiRequest = apiClient.request(request: registerRequest)
    
    apiRequest.sink { dataResponse in
        if let value = dataResponse.value {
            // save guid and return nill or backend error (format Error)
        } else {
            completion(dataResponse.error)
        }
    }.store(in: &amp;cancellableSet)
}
</code></pre>
","4122175","","4122175","","2021-10-07 06:28:51","2021-10-08 19:30:56","Combine return request response with different format","<ios><swift><alamofire><combine>","1","1","","","","CC BY-SA 4.0"
"69477691","1","69481117","","2021-10-07 08:17:57","","1","746","<p>How can I validate the email inside view model combining that two codes using combine?</p>
<p>This is inside my RegisterViewModel</p>
<pre><code>private var isEmailValidPublisher: ValidatePublisher {
        $email
            .removeDuplicates()
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines).count &gt;= 10}
            .handleEvents(receiveOutput: { [weak self] in $0 ? (self?.emailMessage = &quot;&quot;) : (self?.emailMessage = &quot;Invalid email&quot;)})
            .eraseToAnyPublisher()
    }
</code></pre>
<p>I want to add this validation inside isEmailValidPublisher.</p>
<pre><code>func isValidEmail() -&gt; Bool {
        let emailRegEx = &quot;(?:[\\p{L}0-9!#$%\\&amp;'*+/=?\\^_`{|}~-]+(?:\\.[\\p{L}0-9!#$%\\&amp;'*+/=?\\^_`{|}&quot; + &quot;~-]+)*|\&quot;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\&quot; + &quot;x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\&quot;)@(?:(?:[\\p{L}0-9](?:[a-&quot; + &quot;z0-9-]*[\\p{L}0-9])?\\.)+[\\p{L}0-9](?:[\\p{L}0-9-]*[\\p{L}0-9])?|\\[(?:(?:25[0-5&quot; + &quot;]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-&quot; + &quot;9][0-9]?|[\\p{L}0-9-]*[\\p{L}0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21&quot; + &quot;-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])&quot;
        
        let emailValidation = NSPredicate(format:&quot;SELF MATCHES[c] %@&quot;, emailRegEx)
        return emailValidation.evaluate(with: self)
    }
</code></pre>
<p>how can I mix both of them inside isEmailValidPublisher so that I can use that info in my signupview like below</p>
<pre><code> Image(systemName: &quot;envelope&quot;)
                    .foregroundColor(registerVM.emailMessage != &quot;&quot; ? .red: .blue)
</code></pre>
","8418174","","","","","2021-10-07 12:25:20","SwiftUI Combine ViewModel Email Validation","<validation><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"69483090","1","","","2021-10-07 14:38:53","","0","102","<p>In my application I have two View Models that make some work and publish their result via the <code>@Published</code> property. To simplify some code, I use another property alongside the published value to check if the work is complete.</p>
<p><strong>EDIT</strong>: I misused the <code>Result</code> object, forgetting it is present in the swift standard library. Here now I use the <code>Dummy</code> object to represent the data. Furthermore, I've added some code in <code>receiveValue</code> to justify it's presence</p>
<p>For example:</p>
<pre class=""lang-swift prettyprint-override""><code>class FirstViewModel: ObservableObject {
    var subscriptions: Set&lt;AnyCancellable&gt; = []

    @Published private(set) var results: [Dummy]?
    @Published private(set) var isComplete: Bool = false

    func fetch() {
        self.isLoading = true
        self.isComplete = false

        APIService.fetch()
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { [weak self] value in
                guard let self = self else { return }
                if case let .failure(error) = value {
                    print(error)
                }
            }, receiveValue: { (data: [Dummy]) in
                // make some work
                data.forEach { d in 
                    print(d.title)
                }

                self.results = data

                self.isComplete = true
            })
            .store(in: &amp;self.subscriptions)
    }
}
</code></pre>
<p>(the other one is almost identical)</p>
<p><strong>EDIT</strong>: here's the <code>APIService.fetch</code> implementation</p>
<pre class=""lang-swift prettyprint-override""><code>struct Agent {
    func fetch&lt;T: Decodable&gt;(_ request: URLRequest) -&gt; AnyPublisher&lt;T, Error&gt; {
        let decoder = JSONDecoder()
       
        return URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { response in
                if let httpURLResponse = response.response as? HTTPURLResponse, !(200 ... 299 ~= httpURLResponse.statusCode) {
                    throw Error.message(&quot;Got an HTTP \(httpURLResponse.statusCode) error.&quot;)
                }
                return response.data
            }
            .decode(type: T.self, decoder: decoder)
            .mapError { Error.map($0) }
            .eraseToAnyPublisher()
    }
}

enum APIService {
    static let agent = Agent()
    
    static func fetch(languageCode: String) -&gt; AnyPublisher&lt;[Dummy], Error&gt; {
        let request = URLRequest(url: &quot;https://example.com/dummy&quot;)
        
        let res: AnyPublisher&lt;[Dummy], Error&gt; = agent.fetch(request)
        
        return res.eraseToAnyPublisher()
    }
}
</code></pre>
<p>Somewhere in my code I consume both of them like this
<strong>EDIT</strong>: forgot to add the code to call the various <code>$isComplete</code></p>
<pre class=""lang-swift prettyprint-override""><code>@EnvironmentObject var firstViewModel: FirstViewModel
@EnvironmentObject var secondViewModel: SecondViewModel

...

@State private var subscriptions: Set&lt;AnyCancellable&gt; = []

...

Button(&quot;Press me with no reason&quot;) {
    // I FORGOT TO ADD THE CALLERS
    self.firstViewModel.fetch()
    self.secondViewModel.fetch()

    Publishers.CombineLatest(
        self.firstViewModel.$isComplete.first { $0 == true }, 
        self.secondViewModel.$isComplete.first { $0 == true }
    ) 
    .receive(on: DispatchQueue.main)
    .sink { firstComplete, secondComplete in
        print(&quot;is first complete: \(firstComplete) - is second complete: \(secondComplete)&quot;)
    }
    .store(in: &amp;self.subscriptions)
}

</code></pre>
<p>This code works flawlessly.</p>
<p>Where is the strange behaviour? Imagine this use case: the device is offline, i.e. because of airplane mode and you clicked the button. In the console you can see the error that says you're offline.</p>
<p>Then you toggle the airplane mode (or go online whatever), click again the button and the <code>print</code> is called twice.</p>
<p>Seems like is cached instead of completed. I haven't tried yet, but I think that any error will trigger this problem (FWIW).</p>
<p>Any idea?</p>
<p><strong>EDIT</strong>:</p>
<p>I forgot to cancel the <code>Publishers.CombineLatest</code> after the failed execution. So instead of</p>
<pre class=""lang-swift prettyprint-override""><code>@State private var subscriptions: Set&lt;AnyCancellable&gt; = []

...

.store(in: &amp;self.subscriptions)
</code></pre>
<p>I now use</p>
<pre class=""lang-swift prettyprint-override""><code>@State private var subscription: AnyCancellable?

...

self.subscription = Publishers.CombineLatest(...)
</code></pre>
<p>and cancel it when the error raises, resolving the issue</p>
","813728","","813728","","2021-10-11 07:51:33","2021-10-11 07:51:33","Swift Combine weird behaviour when returning from offline mode","<ios><swift><combine>","0","12","","","","CC BY-SA 4.0"
"69495351","1","69495505","","2021-10-08 11:47:22","","0","242","<p>I'm creating a login token validity timer, and I figured it needs to be a singleton that ticks and every second (or every minute or whatever), checks to see whether the login token is still valid.</p>
<p>But I can't even get the singleton to print a message every second. Why not?</p>
<pre><code>import SwiftUI
import Combine

class TokenObserver: ObservableObject {
    private let publisher = Timer.TimerPublisher(interval: 1.0, runLoop: .main, mode: .default)
    private let cancellable: AnyCancellable?
    static let instance = TokenObserver()
    let uuid = UUID()

    private init() {
        NSLog(&quot;TokenObserver.init()&quot;)
        self.cancellable = self.publisher.sink(receiveCompletion: { completion in
            NSLog(&quot;TokenObserver \(completion)&quot;)
        }, receiveValue: { date in
            NSLog(&quot;TokenObserver timestamp=&quot; + ISO8601DateFormatter().string(from: date))
        })
    }

    deinit {
        NSLog(&quot;TokenObserver.deinit()&quot;)
        self.cancellable?.cancel()
    }
}

struct ContentView: View {
    var body: some View {
        Text(&quot;Hello, world! Instance = &quot; + TokenObserver.instance.uuid.uuidString)
            .padding()
    }
}
</code></pre>
","12811732","","","","","2021-10-08 11:59:56","Combine Timer.TimerPublisher not starting","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"69505246","1","","","2021-10-09 09:04:47","","3","1700","<p>I've been trying to find a good way to connect a <code>TextField</code> with a viewmodel, so that the inputs to the <code>TextField</code> don't immediately update the view.</p>
<p>Here is a working example:</p>
<pre class=""lang-swift prettyprint-override""><code>struct TextFieldSamples: View {
    @StateObject var vm = TFViewModel()

    var body: some View {
        print(Self._printChanges())
        return VStack {
            TextField(&quot;placeholder&quot;,
                      text: Binding(
                        get: { vm.outputText },
                        set: { vm.subject.value = $0 }
                      ))
            Text(vm.outputText) // this will only update when the textfield holds &gt;5 characters
        }
    }
}

class TFViewModel: ObservableObject {
    @Published var outputText: String = &quot;&quot;
    let subject = CurrentValueSubject&lt;String, Never&gt;(&quot;&quot;)

    var subscriptions = Set&lt;AnyCancellable&gt;()

    init() {
        subject
            .filter({ $0.count &gt; 5 })
            .sink { self.outputText = $0 }
            .store(in: &amp;subscriptions)
    }
}
</code></pre>
<p>However, I came across the propertyWrapped <code>CurrentValueSubject</code> below on the swiftbysundell.com blog</p>
<pre class=""lang-swift prettyprint-override""><code>@propertyWrapper
struct Input&lt;Value&gt; {
    var wrappedValue: Value {
        get { subject.value }
        set { subject.send(newValue) }
    }

    var projectedValue: AnyPublisher&lt;Value, Never&gt; {
        subject.eraseToAnyPublisher()
    }

    private let subject: CurrentValueSubject&lt;Value, Never&gt;

    init(wrappedValue: Value) {
        subject = CurrentValueSubject(wrappedValue)
    }
}
</code></pre>
<p>Trying to use it, will result in the error <code>Binding&lt;String&gt; action tried to update multiple times per frame</code>.<br />
(Not only that, the input behavior of the <code>TextField</code> gets messed up. This shows especially with Japanese input where the character transformations don't are not working most of the time.)</p>
<p>Here's a example showing this behavior:</p>
<pre class=""lang-swift prettyprint-override""><code>struct TextFieldSamples: View {
    @StateObject var vm = TFViewModel()

    var body: some View {
        print(Self._printChanges())
        return VStack {
            TextField(&quot;placeholder&quot;, text: $vm.inputText)
            Text(vm.outputText)
        }
    }
}

class TFViewModel: ObservableObject {
    @Input var inputText: String = &quot;&quot;
    @Published var outputText: String = &quot;&quot;

    var subscriptions = Set&lt;AnyCancellable&gt;()

    init() {
        $inputText
            .filter({ $0.count &gt; 5 })
            .sink { self.outputText = $0 }
            .store(in: &amp;subscriptions)
    }
}
</code></pre>
<p>I don't quite understand why the PropertyWrapper version is not working as expected.</p>
","2064473","","","","","2021-10-11 14:58:04","""Binding<String> action tried to update multiple times per frame"" on TextField with CurrentValueSubject binding","<ios><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"69545349","1","69579673","","2021-10-12 18:26:35","","0","348","<p>I'm trying to query HealthKit for heart rate values and steps in the time interval defined by a <a href=""https://developer.apple.com/documentation/healthkit/hkworkoutevent#"" rel=""nofollow noreferrer""><code>HKWorkoutEvent</code></a> to fill a custom local model I have defined to store multiple variables, it's defined below.</p>
<pre class=""lang-swift prettyprint-override""><code>struct SGWorkoutEvent: Identifiable {
    let id = UUID()
    let type: HKWorkoutEventType
    let splitActiveDurationQuantity: HKQuantity?
    let splitDistanceQuantity: HKQuantity?
    let totalDistanceQuantity: HKQuantity?
    let splitMeasuringSystem: HKUnit

    let steps: HKQuantity?
    let heartRate: HKQuantity?
}
</code></pre>
<p>Al properties except <code>steps</code> and <code>heartRate</code> can be extracted from a <code>HKWorkoutEvent</code>. However, I am trying to build a Combine pipeline that would let me create an array of publishers to query in parallel for heart rate, steps and also pass the workout event so in the <code>sink</code> I receive a 3-element tuple with these values so I can populate the model above. What I  currently have is below,</p>
<pre class=""lang-swift prettyprint-override""><code>// Extract the workout's segments (defined automatically by an Apple Watch)
let workoutSegments = (workout.workoutEvents ?? []).filter({ $0.type == .segment })

// For each of the workout segments defined above create a HKStatisticQuery that starts on the interval's
// beginning and ends on the interval's end so the HealthKit query is properly defined to be
// executed between that interval.
let segmentsWorkoutPublisher = Publishers.MergeMany(workoutSegments.map({ $0.dateInterval }).map({
    healthStore.statistic(for: HKQuantityType.quantityType(forIdentifier: HKQuantityTypeIdentifier.heartRate)!, with: .discreteAverage, from: $0.start, to: $0.end)
}))
.assertNoFailure()

// Do the same logic as above in `segmentsWorkoutPublisher` but for steps
let stepsPublisher = Publishers.MergeMany(workoutSegments.map({ $0.dateInterval }).map({

    healthStore.statistic(for: HKObjectType.quantityType(forIdentifier: HKQuantityTypeIdentifier.stepCount)!, with: .cumulativeSum, from: $0.start, to: $0.end)
}))
.assertNoFailure()

Publishers.Zip3(workoutSegments.publisher, stepsPublisher, segmentsWorkoutPublisher)
    
    .receive(on: DispatchQueue.main)
    .sink(receiveValue: { pace, steps, hrs in
        
        let d = SGWorkoutEvent(type: pace.type,
                               splitActiveDurationQuantity: pace.splitDuration,
                               splitDistanceQuantity: pace.splitDistance,
                               totalDistanceQuantity: pace.totalDistanceQuantity,
                               splitMeasuringSystem: pace.splitMeasuringSystem,
                               steps: steps.sumQuantity(),
                               heartRate: hrs.averageQuantity())
        
        self.paces.append(d)
    })
    .store(in: &amp;bag)
</code></pre>
<p><code>HKHealthStore.statistic(for:...)</code> is nothing but a Combine wrapper for <code>HKStatisticsQuery</code> defined on a <code>HKHealthStore</code> extension, see below.</p>
<pre class=""lang-swift prettyprint-override""><code>public func statistic(for type: HKQuantityType, with options: HKStatisticsOptions, from startDate: Date, to endDate: Date, _ limit: Int = HKObjectQueryNoLimit) -&gt; AnyPublisher&lt;HKStatistics, Error&gt; {
    
    let subject = PassthroughSubject&lt;HKStatistics, Error&gt;()
    
    let predicate = HKStatisticsQuery.predicateForSamples(withStart: startDate, end: endDate, options: [.strictEndDate, .strictStartDate])
    
    let query = HKStatisticsQuery(quantityType: type, quantitySamplePredicate: predicate, options: options, completionHandler: { (query, statistics, error) in
        
        guard error == nil else {
            hkCombineLogger.error(&quot;Error fetching statistics \(error!.localizedDescription)&quot;)
            return
        }
        
        subject.send(statistics!)
        subject.send(completion: .finished)
    })
    
    self.execute(query)
    
    return subject.eraseToAnyPublisher()
}
</code></pre>
<p>What I am seeing here is some sort of race condition where both steps and heart rate retrieved is not returning ad the same time. As a result I see values that don't make sense like on one 1K split of 5' 200steps and another one of the same duration 700steps. The real case should be that those two intervals should show a value around 150 but it seems that I am probably not using the correct Combine operator.</p>
<p>The expected behavior I would hope to see is for every publisher on <code>Publishers.Zip</code> to have each 3-item tuple have finished its query in order (1st interval, 2nd interval...) rather than this non-replicable race condition.</p>
<p>To try and give more context I think this is akin to having a model with temperature, humidity and chance of rain for different timestamps and querying three different API endpoints to retrieve the three different values and merge them in the model.</p>
","4296481","","4296481","","2021-10-12 18:50:21","2021-10-15 03:36:06","Executing Combine Publishers in parallel creates race condition","<swift><combine><healthkit>","1","1","","","","CC BY-SA 4.0"
"69556770","1","","","2021-10-13 13:48:39","","0","120","<p>i'm currently struggling to fetch any changes from an published variable in SwiftUI. Most of the code is created after <a href=""https://www.youtube.com/watch?v=HDde7TqKCpk&amp;t=2621s"" rel=""nofollow noreferrer"">this tutorial</a> on YouTube.</p>
<p>It's basically an app, that fetches cryptos from a firebase database. To avoid high server costs I want to update any changes of the coins to the database but not have an observer to lower the download rate.</p>
<p><strong>What's the bug?</strong></p>
<p>When I'm adding a coin to my favorites, it sends the data correctly to the database and updates the UI. However when I try to filter the coins the Coin-array switches back to it's previous state. I also added a breakpoint on the <code>CoinCellViewModel(coin: coin)</code>-Line but it only gets executed when I change the <code>filterBy</code>. Here's a little visualisation of the bug:</p>
<img src=""https://i.stack.imgur.com/TgDiu.gif"" width=""250"" />
<p><strong>Repository</strong></p>
<pre><code>class CoinsRepository: ObservableObject {
    
    @Published var coins = [Coin]()
    
    var ref: DatabaseReference!
    
    init() {
        self.ref = Database.database().reference()
        
        loadDatabase(ref)
        
    }

    func loadDatabase(_ ref: DatabaseReference) {
        ref.child(&quot;coins&quot;).observeSingleEvent(of: .value) { snapshot in
            guard let dictionaries = snapshot.value as? [String: Any] else { return }
            var coinNames: [String] = []
            
            self.coins = dictionaries.compactMap({ (key: String, value: Any) in
                guard let dic = value as? [String: Any] else { return nil }
                coinNames.append(dic[&quot;name&quot;] as? String ?? &quot;&quot;)
                return Coin(dic)
            })
        }
    }
    
    func updateFavorite(_ coin: Coin, state: Bool) {
        let path = ref.child(&quot;coins/\(coin.name)&quot;)
        var flag = false
        
        path.updateChildValues([&quot;favorite&quot;: state]) { err, ref in
            if let err = err {
                print(&quot;ERROR: \(err.localizedDescription)&quot;)
            } else {
                
                var i = 0
                var newCoinArray = self.coins
                for coinA in newCoinArray {
                    if coinA.name == coin.name {
                        newCoinArray[i].favorite = state
                    }
                    i += 1
                }
                
                // I guess here's the error
                DispatchQueue.main.async {
                    self.objectWillChange.send()
                    self.coins = newCoinArray
                }
            }
        }
    }

}
</code></pre>
<p><strong>ViewModel</strong></p>
<pre><code>class CoinListViewModel: ObservableObject {
    
    @Published var coinRepository = CoinsRepository()
    @Published var coinCellViewModels = [CoinCellViewModel]()

    @Published var filterBy: [Bool] = UserDefaults.standard.array(forKey: &quot;filter&quot;) as? [Bool] ?? [false, false, false]
    @Published var fbPrice: Double = 0.00
    @Published var searchText: String = &quot;&quot;

    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        
        $searchText
            .combineLatest(coinRepository.$coins, $fbPrice, $filterBy)
            .map(filter)
            .sink { coins in

                self.coinCellViewModels = coins.map { coin in
                    CoinCellViewModel(coin: coin)
                }

            }
            .store(in: &amp;cancellables)
   
    }

    ...

}
</code></pre>
<p><code>updateFavorite(_ coin: Coin, state: Bool)</code> get's called in the <code>CoinCellViewModel()</code> but I guess the code isn't necessary here...</p>
<p>I'm fairly new to the Combine topic and not quite getting all the new methods, so any help is appreciated!</p>
","13618212","","","","","2021-10-13 13:48:39","@Published Array is not updating","<swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"69568041","1","69571321","","2021-10-14 09:10:41","","0","103","<p>If I have a combine pipeline, that prints changes to an array, is it then possible to update that array without having the pipeline run?</p>
<pre class=""lang-swift prettyprint-override""><code>class ObserveableTest: ObservableObject {
    private var cancellables: Set&lt;AnyCancellable&gt; = []
    @Published var items: [Int] = []
    init() {
        $items
            .debounce(for: 0.6, scheduler: RunLoop.main)
            .sink {
                print($0)
            }
            .store(in: &amp;cancellables)
    }
    
    func pleaseDoNotNotifyPipeline() {
        items.append(1)
    }
}
</code></pre>
<p><strong>Update:</strong>
The code provided is a simplified version of what I work on.
In short, I work on a basket manager, and whenever the user changes the quantity of a product (or in another way changes the basket) a request will need to be sent to the backend, why the debounce. In the code above, it is simply shown with changes to an array instead.</p>
<p>The case is, that the changes the user makes to the basket should run the the pipeline, however, it can also be that the system (from a web-response etc.) updates the local basket itself, and in that case the pipeline should not run.</p>
<p>I fear that cancelation and resubscribing to the pipeline in rare cases can mean that, changes from the user is lost.
But im also maybe realising the cancel/resub is the only solution, and I will need to take care of that rare situation. Or do you see other solutions now that I have elaborated a bit?</p>
","1838231","","1838231","","2021-10-14 09:38:47","2021-10-14 13:29:04","Update property without running combine pipeline","<swift><combine>","3","1","","","","CC BY-SA 4.0"
"69573072","1","","","2021-10-14 15:06:30","","0","184","<p>I have an images carousel that fetching heavy images from a few URLs and displaying asynchronously when user is going to the next page. And the problem is that user need to see a waiting wheel and wait to see the next image.</p>
<p>So the ideal case would be to eliminate the waiting wheel by loading the next image while user still seeing the fist image and I don't know how to do it properly.</p>
<p>If you know the solution please let me know, I will mean a lot to me.</p>
<p>Here's the code:</p>
<pre><code>struct ContentView: View {
    @State private var selectedImageToSee: Int = 0
    private let imagesUrl: [String] = [
        &quot;https://images.unsplash.com/photo-1633125195723-04860dde4545?crop=entropy&amp;cs=tinysrgb&amp;fit=crop&amp;fm=jpg&amp;h=4032&amp;ixid=MnwxfDB8MXxyYW5kb218MHx8fHx8fHx8MTYzNDIyMDUyMQ&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=3024&quot;,
        &quot;https://images.unsplash.com/photo-1633090332452-532d6b39422a?crop=entropy&amp;cs=tinysrgb&amp;fit=crop&amp;fm=jpg&amp;h=4032&amp;ixid=MnwxfDB8MXxyYW5kb218MHx8fHx8fHx8MTYzNDIyMDI1Ng&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=3024&quot;,
        &quot;https://images.unsplash.com/photo-1591667954789-c25d5affec59?crop=entropy&amp;cs=tinysrgb&amp;fit=crop&amp;fm=jpg&amp;h=4032&amp;ixid=MnwxfDB8MXxyYW5kb218MHx8bmF0dXJlLGNhcnN8fHx8fHwxNjM0MjIwNzU1&amp;ixlib=rb-1.2.1&amp;q=80&amp;utm_campaign=api-credit&amp;utm_medium=referral&amp;utm_source=unsplash_source&amp;w=3024&quot;,
        &quot;https://images.unsplash.com/photo-1580316576539-aee1337e80e8?crop=entropy&amp;cs=tinysrgb&amp;fit=crop&amp;fm=jpg&amp;h=4032&amp;ixid=MnwxfDB8MXxyYW5kb218MHx8bmF0dXJlLGNhcnN8fHx8fHwxNjM0MjIwNzk5&amp;ixlib=rb-1.2.1&amp;q=80&amp;utm_campaign=api-credit&amp;utm_medium=referral&amp;utm_source=unsplash_source&amp;w=3024&quot;,
        &quot;https://images.unsplash.com/photo-1484976063837-eab657a7aca7?crop=entropy&amp;cs=tinysrgb&amp;fit=crop&amp;fm=jpg&amp;h=4032&amp;ixid=MnwxfDB8MXxyYW5kb218MHx8bmF0dXJlLGNhcnN8fHx8fHwxNjM0MjIwNjky&amp;ixlib=rb-1.2.1&amp;q=80&amp;utm_campaign=api-credit&amp;utm_medium=referral&amp;utm_source=unsplash_source&amp;w=3024&quot;
        ]
    
    var body: some View {
        ImagesCaruselView(selectedImageToSee: $selectedImageToSee, urls: imagesUrl)
    }
}

struct ImagesCaruselView: View {
    @Binding var selectedImageToSee: Int
    let urls: [String]
    
    var body: some View {
        TabView(selection: $selectedImageToSee) {
            ForEach(0..&lt;urls.count, id: \.self) { url in
                AsyncImageView(
                    url: URL(string: urls[url])!,
                    placeholder: { ProgressView().scaleEffect(1.5).progressViewStyle(CircularProgressViewStyle(tint: .gray)) },
                    image: { Image(uiImage: $0) }
                )
                    .padding()
            }
        }
        .tabViewStyle(.page)
        .indexViewStyle(.page(backgroundDisplayMode: .always))
    }
}

struct AsyncImageView&lt;Placeholder: View&gt;: View {
    @StateObject private var loader: ImageLoader
    private let placeholder: Placeholder
    private let image: (UIImage) -&gt; Image
    
    init(
        url: URL,
        @ViewBuilder placeholder: () -&gt; Placeholder,
        @ViewBuilder image: @escaping (UIImage) -&gt; Image = Image.init(uiImage:)
    ) {
        self.placeholder = placeholder()
        self.image = image
        _loader = StateObject(wrappedValue: ImageLoader(url: url, cache: Environment(\.imageCache).wrappedValue))
    }
    
    var body: some View {
        content
            .onAppear(perform: loader.load)
    }
    
    private var content: some View {
        Group {
            if loader.image != nil {
                image(loader.image!)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
            } else {
                placeholder
            }
        }
    }
}

protocol ImageCache {
    subscript(_ url: URL) -&gt; UIImage? { get set }
}

struct TemporaryImageCache: ImageCache {
    private let cache: NSCache&lt;NSURL, UIImage&gt; = {
        let cache = NSCache&lt;NSURL, UIImage&gt;()
        cache.countLimit = 100 // 100 items
        cache.totalCostLimit = 1024 * 1024 * 200 // 200 MB
        return cache
    }()
    
    subscript(_ key: URL) -&gt; UIImage? {
        get { cache.object(forKey: key as NSURL) }
        set { newValue == nil ? cache.removeObject(forKey: key as NSURL) : cache.setObject(newValue!, forKey: key as NSURL) }
    }
}

import Combine

class ImageLoader: ObservableObject {
    @Published var image: UIImage?
    
    private(set) var isLoading = false
    
    private let url: URL
    private var cache: ImageCache?
    private var cancellable: AnyCancellable?
    
    private static let imageProcessingQueue = DispatchQueue(label: &quot;image-processing&quot;)
    
    init(url: URL, cache: ImageCache? = nil) {
        self.url = url
        self.cache = cache
    }
    
    deinit {
        cancel()
    }
    
    func load() {
        guard !isLoading else { return }

        if let image = cache?[url] {
            self.image = image
            return
        }
        
        #warning(&quot;Caching the image are disabled&quot;)
        cancellable = URLSession.shared.dataTaskPublisher(for: url)
            .map { UIImage(data: $0.data) }
            .replaceError(with: nil)
            .handleEvents(receiveSubscription: { [weak self] _ in self?.onStart() },
//                          receiveOutput: { [weak self] in self?.cache($0) },
                          receiveCompletion: { [weak self] _ in self?.onFinish() },
                          receiveCancel: { [weak self] in self?.onFinish() })
            .subscribe(on: Self.imageProcessingQueue)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] in self?.image = $0 }
    }
    
    func cancel() {
        cancellable?.cancel()
    }
    
    private func onStart() {
        isLoading = true
    }
    
    private func onFinish() {
        isLoading = false
    }
    
    private func cache(_ image: UIImage?) {
        image.map { cache?[url] = $0 }
    }
}

import SwiftUI

struct ImageCacheKey: EnvironmentKey {
    static let defaultValue: ImageCache = TemporaryImageCache()
}

extension EnvironmentValues {
    var imageCache: ImageCache {
        get { self[ImageCacheKey.self] }
        set { self[ImageCacheKey.self] = newValue }
    }
}
</code></pre>
","14553245","","415303","","2021-10-14 17:27:16","2021-10-14 17:27:16","How to load next Image while user is looking at first image in the TabView pages carousel with AsyncImageView In SwiftUI?","<swift><swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"69578970","1","69580805","","2021-10-15 01:21:56","","0","66","<p>My goal: Retrieve data from firestore and display said data once.</p>
<p>Problem: Same data is retrieving multiple times. If there is 5 rows of data, the array of my model retrieves 5 times. Why is this happening?</p>
<p>Here is my firestore model:</p>
<pre><code>&quot;Users - Investors&quot;
   &quot;currentUser.uid&quot;
      &quot;id&quot;: currentUser
      &quot;fullName&quot;: fullName,
      &quot;username&quot;: username,
      &quot;userLocation&quot;: userLocation,
      &quot;birthday&quot;: birthday
</code></pre>
<p>Here is my model:</p>
<pre><code>struct InvestorModel: Identifiable {
    let id: String
    let fullName: String
    let username: String
    let userLocation: String
    let birthday: Date
}
</code></pre>
<p>Here is my vm:</p>
<pre><code>class InvestorProfileViewModel: ObservableObject {
    @Published var investorProfile: [InvestorModel] = []
    
    private var auth = Auth.auth()
    private var store = Firestore.firestore()
    
    func getUserInfo() {
        let currentUser = auth.currentUser?.uid ?? &quot;&quot;
        store.collection(&quot;Users - Investors&quot;).document(currentUser).addSnapshotListener { snapshot, error in
            guard let data = snapshot?.data(), error == nil else {
                print(&quot;NO INVESTOR DATA, TRYING ARTIST DATA&quot;)
                return
            }

            DispatchQueue.main.async {
                self.investorProfile = data.map { (dataSnapshot) -&gt; InvestorModel in
                    return InvestorModel(
                        id: currentUser,
                        fullName: data[&quot;fullName&quot;] as? String ?? &quot;&quot;,
                        username: data[&quot;username&quot;] as? String ?? &quot;&quot;,
                        userLocation: data[&quot;userLocation&quot;] as? String ?? &quot;&quot;,
                        birthday: data[&quot;birthday&quot;] as? Date ?? Date()
                    )
                }
                print(self.investorProfile)
            }
        }
    }
}
</code></pre>
<p>Here is my view:</p>
<pre><code>struct HomeView: View {
    @EnvironmentObject var hvm: HomeViewModel
    @EnvironmentObject var ipvm: InvestorProfileViewModel
    @Environment(\.colorScheme) var colorScheme
    
    let devInvestor = DeveloperPreview.instance.investor
    
    var body: some View {
        ZStack {
            Color.theme.background.ignoresSafeArea(.all)
            VStack {
                ForEach(ipvm.investorProfile) { investor in
                    MenuContent(investor: investor, menuWidth: menuWidth)
                }
            }
            .padding(.vertical, 20)
            .padding(.horizontal, 30)
        }
        .onAppear {
            self.ipvm.getUserInfo()
        }
    }
}
</code></pre>
<p>The print call inside of getUserInfo() returns:</p>
<p>[musifi.InvestorModel(id: &quot;F65D7CB4-25B3-47C5-9A26-78C645916AAC&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000),</p>
<p>[musifi.InvestorModel(id: &quot;F65D7CB4-25B3-47C5-9A26-78C645916AAC&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000),</p>
<p>musifi.InvestorModel(id: &quot;2B4AE47A-4C55-4229-AB9F-1F2BA9983B44&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000),</p>
<p>musifi.InvestorModel(id: &quot;E8F87591-DC12-4068-958E-D2DA9025C316&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000),</p>
<p>musifi.InvestorModel(id: &quot;95C8B099-C753-410E-AF7D-72EDD8FB0E7D&quot;, fullName: &quot;John Doe&quot;, username: &quot;johnn&quot;, userLocation: &quot;Lake Elsinore, CA, USA&quot;, birthday: 2021-10-15 00:59:47 +0000)]</p>
<p>4 types of data: fullName, username, userLocation, birthday - and 4 times it was called. This number always correlates. I am only calling the function once.</p>
","16653398","","16653398","","2021-10-15 06:08:41","2021-10-15 06:41:11","iOS - Firestore same data retrieving multiple times","<ios><swift><firebase><google-cloud-firestore><combine>","1","7","","","","CC BY-SA 4.0"
"69580706","1","","","2021-10-15 06:30:24","","1","131","<p>I am a beginner in iOS development, and trying to follow a best practice for error management in Combine framework for some use case when working with MVVM pattern in your project.</p>
<p>So let’s imagine a use case.<br />
We have repository that has several methods, each try different sources to find some data.<br />
So, we have some data that can be found in different sources, let's say sourceA, sourceB and sourceC, etc... and each source can produce its own Error type errorA, errorB, errorC, etc...</p>
<p>Repository.methodX</p>
<ul>
<li>try sourceA -&gt; can produce errorA</li>
<li>try sourceB -&gt; can produce errorB</li>
<li>try sourceC -&gt; can produce errorC</li>
</ul>
<p>Repository.methodY</p>
<ul>
<li>try sourceA -&gt; can produce errorA</li>
<li>try sourceD -&gt; can produce errorD</li>
<li>try sourceC -&gt; can produce errorC</li>
</ul>
<p>Repository.methodZ</p>
<ul>
<li>... and so on</li>
</ul>
<p>So in the repository .. we can at the end of the stream make mapError to some kind of general error type.<br />
So this kind of <em>general error type</em>, what it should be? a one big error type for all methods in the repository? .. or an small error type for each method?</p>
<p>How to think about it .. I am asking so I can learn how to accomplish error management in Combine in a clean way.</p>
<p><strong>NOTE:</strong> Picture included with the style I follow in MVVM pattern
<a href=""https://i.stack.imgur.com/Lx3cw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Lx3cw.png"" alt=""https://developer.android.com/topic/libraries/architecture/images/final-architecture.png"" /></a></p>
","4538920","","","","","2021-10-15 16:43:20","Best practice: Error management in Combine Framework when there are different Error types in the stream","<mvvm><combine>","1","0","","","","CC BY-SA 4.0"
"69581918","1","","","2021-10-15 08:31:57","","2","2089","<p>I am having difficulties fully understanding Combine. Here I have an issue where I can't seem to return the correct Output type.</p>
<p>How can I do this?</p>
<pre><code>func test(ticketId: String) -&gt; AnyPublisher&lt;Void, Error&gt; {

    campaignByTicketIdUseCase.execute(ticketId: ticketId)     // this is AnyPublisher&lt;Campaign,Error&gt;
    .flatMap { (campaign) -&gt; AnyPublisher&lt;Void, Error&gt; in     // this is where the error is thrown

        guard let url = URL(string: &quot;url&quot;),
        validator.isParticipationValid(campaignIdentifier: campaign.identifier) else {
            return Result&lt;Void, Error&gt;.failure(HttpError()).publisher.eraseToAnyPublisher()
        }

        var request = URLRequest(url: url)
        request.httpMethod = &quot;POST&quot;

        return AuthSession.shared.doRequest(request: request)
        .tryMap({ (_: Data, response: URLResponse) -&gt; Void in
            if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                throw HttpError()
            }
        }).eraseToAnyPublisher()
    }
}
</code></pre>
","12393459","","1271826","","2021-10-15 09:16:22","2021-10-15 09:16:22","Cannot convert return expression of type 'Publishers.FlatMap<AnyPublisher<>, AnyPublisher<>>' to return type 'AnyPublisher<>'","<swift><reactive-programming><combine>","1","1","1","","","CC BY-SA 4.0"
"69582148","1","","","2021-10-15 08:49:52","","0","955","<p>Is there a way to create a <code>CurrentValueSubject</code> that is read-only?</p>
<p>So you could <code>sink</code> it publicly, read <code>value</code> publicly, but could only <code>send</code> values to it internally/privately. Want to use it in a library module.</p>
","215282","","1974224","","2021-10-15 13:47:08","2022-07-08 21:54:43","Read only CurrentValueSubject?","<swift><combine>","4","12","1","","","CC BY-SA 4.0"
"69592408","1","69592471","","2021-10-16 03:27:04","","2","196","<p>I have the following function:</p>
<pre><code>func generateIn() -&gt; Future&lt;Int,Never&gt; {
    return Future{ promise in
        promise(.success(Int.random(in: 1...10)))
    }
}
</code></pre>
<p>and I'm calling that function from this variable:</p>
<pre><code>let sub2 = generateIn()
    .map { value in
        print(value)
        return Int(value)
    }
</code></pre>
<p>But I'm getting this error:</p>
<pre><code>Unable to infer complex closure return type; add explicit type to disambiguate
</code></pre>
<p><a href=""https://i.stack.imgur.com/8UWO5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8UWO5.png"" alt=""enter image description here"" /></a></p>
<p>Any of you knows why I'm getting this error or how can fix it?</p>
<p>I'll really appreciate your help</p>
","2924482","","","","","2021-10-16 03:42:12","Swift Combine: Unable to infer complex closure return type error","<ios><swift><xcode><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"69592738","1","","","2021-10-16 04:45:38","","0","338","<p>I have a data model in my SwiftUI app that looks something like this:</p>
<pre><code>struct Entry: Identifiable{
  var id = UUID().uuidString
  var name = &quot;&quot;

  var duration: Int{
    //An SQLite query that returns the total of the &quot;duration&quot; column
    let total = try! dbc.scalar(tableFlight.filter(db.entry == id).select(db.duration.total))
    return Int(total)
  }
}

struct Flight: Identifiable{
  var id = UUID().uuidString
  var duration = 0
  var entry: String?
}
</code></pre>
<p>I have an <code>ObservableObject</code> view model that produces the entries like this:</p>
<pre><code>class EntryModel: ObservableObject{
  static let shared = EntryModel()
  @Published var entries = [Entry]()

  init(){
    get()
  }

  func get(){
    //Stuff to fetch the entries
    entries = //SQLite query that returns an array of Entry objects
  }
}
</code></pre>
<p>Then finally, in my <code>View</code>, I list all the entry names and their associated <code>duration</code> like this:</p>
<pre><code>ForEach(modelEntry.entries){ entry in
  VStack{
    Text(entry.name) //&lt;-- Updates fine
    Text(entry.duration) //&lt;-- Gets set initially, but no updates
  }
}
</code></pre>
<p>The issue I'm having is that when I update a <code>Flight</code> for that <code>Entry</code>, the <code>duration</code> in my view doesn't update. I know that won't happen because only the <code>entries</code> will redraw when they are changed.</p>
<p>But even if I manually call the <code>get()</code> function in my <code>EntryModel</code>, the associated <code>duration</code> <em>still</em> doesn't update.</p>
<p>Is there a better way to do this? How do I get the parent's computed properties to recalculate when its child element is updated?</p>
","1142348","","","","","2021-10-16 05:33:02","Computed Property from Child Struct Not Updating in SwiftUI","<swift><swiftui><combine><observableobject>","1","7","","","","CC BY-SA 4.0"
"69608460","1","","","2021-10-17 20:47:07","","0","163","<p>I have the following implementation:</p>
<pre><code>var flag = CurrentValueSubject&lt;Bool,Never&gt;(false)
    var flagChange = PassthroughSubject&lt;Bool,Never&gt;()
    var subscriptions = Set&lt;AnyCancellable&gt;()
    
    init() {
        flagChange.sink { [unowned self] value in
            print(&quot;value \(value)&quot;)
            print(&quot;current value \(self.flag)&quot;)
        } receiveValue: { [unowned self] value in
            print(&quot;value received \(value)&quot;)
            self.flag.send(value)
        }.store(in: &amp;subscriptions)
    }
</code></pre>
<p>When I execute in the playground I'm getting this error/warnings:</p>
<p><a href=""https://i.stack.imgur.com/YDVkO.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YDVkO.png"" alt=""enter image description here"" /></a></p>
<p>Any of you knows why and how can avoid it or fix it?</p>
<p>I'll really appreciate your help.</p>
","2924482","","560942","","2021-10-17 23:00:29","2021-10-17 23:00:29","Swift Combine: PassthroughSubject UnsafeMutablePointer","<ios><swift><xcode><combine>","1","0","","","","CC BY-SA 4.0"
"69618911","1","69635093","","2021-10-18 15:41:48","","0","484","<p>I have numerous pages where users may input information. They may input the fields with dates, numbers, or text.</p>
<p>I am trying to receive all changes in Combine and get their outputs as <code>Encodable</code> so I can easily upload the results to the network.</p>
<p>A <code>String</code> is <code>Encodable</code>, so I thought this would be easy but I cannot get this to work in Combine. I get a compiler error:</p>
<blockquote>
<p>Cannot convert return expression of type 'Publishers.Map&lt;Published.Publisher, Encodable&gt;' to return type 'Published.Publisher'</p>
</blockquote>
<p>There is a workaround where I add another property in <code>SampleTextHandler</code> that is <code>@Published var userTextEncodable: Encodable</code> but that's not what I want to do.</p>
<pre><code>import Combine

protocol FieldResponseModifying {
    var id: String { get }
    var output: Published&lt;Encodable&gt;.Publisher { get }
}


struct SampleTextWrapper {
    var output: Published&lt;Encodable&gt;.Publisher {
        // Cannot convert return expression of type 'Publishers.Map&lt;Published&lt;String&gt;.Publisher, Encodable&gt;' to return type 'Published&lt;Encodable&gt;.Publisher'
        handler.$userTextOutput.map { $0 as Encodable}
    }
    
    let id = UUID().uuidString
    let handler = SampleTextHandler()
}

class SampleTextHandler {
   @Published var userTextOutput = &quot;&quot;
    init () { }
}
</code></pre>
","9718260","","","","","2021-10-19 17:10:39","How can I map to a type in Combine?","<swift><combine>","1","5","","","","CC BY-SA 4.0"
"69634368","1","69641278","","2021-10-19 16:14:21","","0","147","<p>I have the following code:</p>
<pre><code>class Stuff {
    var str: String?
    var num = 0
}

class MyStuff:ObservableObject {
    @Published var stuff:Stuff?
    @Published var numer: Int?
}

class DoSomething {
    let observedObject = MyStuff()
    var cancellableBag = Set&lt;AnyCancellable&gt;()
    
    init() {
        observedObject.objectWillChange.sink { value in
            print(value)
            print(&quot;Object has changed&quot;)
        }.store(in: &amp;cancellableBag)
        observedObject.$stuff.sink { value in
            print(value?.str ?? &quot;&quot;)
        }.store(in: &amp;cancellableBag )
    }
}
</code></pre>
<p>But when I execute:</p>
<pre><code>let doSomething = DoSomething()
doSomething.observedObject.stuff?.str = &quot;Doing something&quot;
doSomething.observedObject.stuff?.num = 2
</code></pre>
<p>, the notifications never trigger:</p>
<p><a href=""https://i.stack.imgur.com/0g3tK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0g3tK.png"" alt=""enter image description here"" /></a></p>
<p>Any of you knows why the notifications never trigger? Or how can I make it happen?</p>
","2924482","","1974224","","2021-10-20 06:32:59","2021-10-20 06:32:59","Notifications not sent when changing an ObservedObject","<swift><swiftui><combine><observableobject>","2","3","","","","CC BY-SA 4.0"
"69637090","1","","","2021-10-19 20:09:35","","0","603","<p>I have the following implementation:</p>
<pre><code>final class Article: NSManagedObject {
    @NSManaged var title: String!
    @NSManaged var summary: String!
}

class someOtherClass {
    @ObservedObject var article: Article?
}
</code></pre>
<p>But I'm getting this error:</p>
<pre><code>Unknown attribute 'ObservedObject'
</code></pre>
<p><a href=""https://i.stack.imgur.com/VSIpK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VSIpK.png"" alt=""enter image description here"" /></a></p>
<p>My question is how can I fix this error? or any of you knows a work around.</p>
","2924482","","","","","2021-10-19 20:24:13","Swift Combine: Unknown attribute 'ObservedObject' error","<ios><swift><xcode><core-data><combine>","1","5","","","","CC BY-SA 4.0"
"69638458","1","69640580","","2021-10-19 22:56:56","","2","1521","<p>I'm trying to observer any changes in object in the core data instance. Here is my code:</p>
<pre><code>class MyClass {
    @objc dynamic var str: String?
}

final class Article: NSObject {
    @objc dynamic var title: String?
    @objc dynamic var summary: String?
    var myVar: MyClass?
}
</code></pre>
<p>Here is were I'm implementing the observers:</p>
<pre><code>func update(article: Article) {
    titleSubscription = article.publisher(for: \.title).sink { value in
        print(value)
    } receiveValue: { _ in
        print(&quot;I got something&quot;)
    }
    summarySubscription = article.publisher(for: \.myVar?.str).sink{ _ in
        
    } receiveValue: { _ in
        
    }
}
</code></pre>
<p>But I'm getting this error:</p>
<pre><code>Thread 1: Fatal error: Could not extract a String from KeyPath Swift.KeyPath&lt;Examples.Article, Swift.Optional&lt;Swift.String&gt;&gt;
</code></pre>
<p><a href=""https://i.stack.imgur.com/Wn8ML.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Wn8ML.png"" alt=""enter image description here"" /></a></p>
<p>Any of you knows why I'm getting this error or if there is any work around ?</p>
<p>I'll really appreciate your help.</p>
","2924482","","9223839","","2021-10-20 07:49:52","2021-10-20 07:49:52","Swift Combine: Could not extract a String from KeyPath Swift.KeyPath","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"69645185","1","69645369","","2021-10-20 11:31:06","","1","281","<p>When some calculation happens in viewModel I want to present modal view. Normally I need to set some boolean binding for method:</p>
<pre><code>.fullScreenCover(isPresented: $isGalleryPresented) {
    GalleryPickerView())
}
</code></pre>
<p>where isGalleryPresented, is @State definied in view. However browsing SO, i have found out that I could have property in viewModel:</p>
<pre><code>@Published var isGalleryPresented = false
</code></pre>
<p>and then do something like this:</p>
<pre><code>.fullScreenCover(isPresented: $viewModel.isGalleryPresented) {
    GalleryPickerView()
}
</code></pre>
<p>And this works just fine, although I don't know how. <code>fullScreenCover</code> method argument of type <code>isPresented: Binding&lt;Bool&gt;</code>, and I pass as far as I can tell a publisher. How does this work?</p>
","744270","","1359088","","2022-07-12 13:42:33","2022-07-12 13:42:33","Passing @Published property where @Binding is expected?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"69678394","1","69682065","","2021-10-22 14:13:30","","0","107","<p>Goal to make retry with different input data.</p>
<pre><code>func generateRandomName() -&gt; Int { ... }

checkIfNameIsAvailable(generateRandomName())
   .retry(10) // &lt;- Makes 10 attempts with same link
   .sink(
       receiveCompletion: { completion in
            },
            receiveValue: { value in
                // Do things
            }
          )
          .store(in: &amp;cancellables)
</code></pre>
<p>How can I modify <code>retry</code> to retry with different upstream (request different query parameter) and 10 attempts?</p>
","4314758","","3141234","","2021-10-22 19:18:23","2021-10-22 19:18:23","How to retry a request with different input?","<ios><swift><combine>","2","1","","","","CC BY-SA 4.0"
"69681567","1","69681693","","2021-10-22 18:27:16","","0","792","<p>I have a parent state that <em>might</em> exist:</p>
<pre><code>class Model: ObservableObject {
    @Published var name: String? = nil
}
</code></pre>
<p><em>If</em> that state exists, I want to show a child view. In this example, showing <code>name</code>.</p>
<p>If <code>name</code> is visible, I'd like it to be shown and editable. I'd like this to be two-way editable, that means if <code>Model.name</code> changes, I'd like it to push to the ChildUI, if the ChildUI edits this, I'd like it to reflect back to <code>Model.name</code>.</p>
<p>However, if <code>Model.name</code> becomes <code>nil</code>, I'd like <code>ChildUI</code> to hide.</p>
<p>When I do this, via unwrapping of the <code>Model.name</code>, then only the first value is captured by the <code>Child</code> who is now in control of that state. Subsequent changes will not push upstream because it is not a <code>Binding</code>.</p>
<p><strong>Question</strong></p>
<p>Can I have a non-optional upstream bind to an optional when it exists? (are these the right words?)</p>
<p><strong>Complete Example</strong></p>
<pre><code>import SwiftUI

struct Child: View {
    // within Child, I'd like the value to be NonOptional
    @State var text: String
    
    var body: some View {
        TextField(&quot;OK: &quot;, text: $text).multilineTextAlignment(.center)
    }
}

class Model: ObservableObject {
    // within the parent, value is Optional
    @Published var name: String? = nil
}

struct Parent: View {
    @ObservedObject var model: Model = .init()
    
    var body: some View {
        VStack(spacing: 12) {
            Text(&quot;Demo..&quot;)

            // whatever Child loads the first time will retain
            // even on change of model.name
            if let text = model.name {
                Child(text: text)
            }
            
            // proof that model.name changes are in fact updating other state
            Text(&quot;\(model.name ?? &quot;&lt;waiting&gt;&quot;)&quot;)
        }
        .onAppear {
            model.name = &quot;first change of optionality works&quot;
            loop()
        }
    }
    
    @State var count = 0
    func loop() {
        async(after: 1) {
            count += 1
            model.name = &quot;updated: \(count)&quot;
            loop()
        }
    }
}

func async(_ queue: DispatchQueue = .main,
           after: TimeInterval,
           run work: @escaping () -&gt; Void) {
    queue.asyncAfter(deadline: .now() + after, execute: work)
}

struct OptionalEditingPreview: PreviewProvider {
    static var previews: some View {
        Parent()
    }
}
</code></pre>
","2611971","","","","","2021-10-22 21:06:12","Bridging Optional Binding to Non-Optional Child (SwiftUI)","<swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"69684714","1","69690691","","2021-10-23 02:47:17","","2","770","<p>Overall use case is 4 network requests</p>
<ul>
<li>A. Request 1 and 2 need to be in parallel and wait for both to
complete</li>
<li>B. Request 3 happens after 1 and 2 complete</li>
<li>C. Request 4
happens after 3 completes</li>
</ul>
<p>After C the final output should be of a <code>AnyPublisher</code> type</p>
<p>I am trying to use Combine to achieve the above and so far I am able to do A using <code>Publishers.Zip</code> and C using <code>flatMap</code>. What I am struggling with is B. I can do that using nested completion handlers but not using <code>flatMap</code></p>
<p>This is the sample code with Strings (not actual code)</p>
<pre><code>func overallFunc(arg1: &quot;arg1&quot;, arg2: &quot;arg2&quot;, arg3: &quot;arg3&quot;, arg4: &quot;arg4&quot; ) -&gt; AnyPublisher&lt;String?, Error&gt; {
let pub1 = func1(arg1: arg1, arg2: arg2)
let pub2 = func2(arg1: arg3, arg2: arg4)

let combinedPub = Publishers.Zip(pub1, pub2)

combinedPub
   .flatMap {(response1, response2) in
     return func3(arg1: response1.attribute1, arg2: response2.attribute2)
   }
}
</code></pre>
<p>The <code>func1</code>, <code>func2</code> and <code>func3</code> all return <code>URLSession.shared.dataTaskPublisher</code> with return type say  <code>AnyPublisher&lt;String?, Error&gt;</code></p>
<p>Now I am struggling with completing the code for <code>overallFunc</code>. The complier gives the following error around <code>flatMap</code>.</p>
<p><code>Type of expression is ambiguous without more context</code></p>
<p>If I add an extra return in the last line of <code>overallFunc</code> then the error changes to
<code>No 'flatMap' candidates produce the expected contextual result type 'AnyPublisher&lt;String?, Error&gt;'</code></p>
<p>In short I want to use <code>flatMap</code> on the result of <code>Publishers.Zip</code> and return another publisher so that I can add another <code>flatMap</code> to do the 4th request but am not able to figure out the right syntax and order of things to do that.</p>
","5721193","","","","","2021-10-23 17:52:09","Chaining + zipping multiple network requests using Swift and Combine","<swift><combine>","2","5","","","","CC BY-SA 4.0"
"69725699","1","69728617","","2021-10-26 15:14:26","","4","525","<p>After switching our API Client to Combine we start to receive reports from our users about error &quot;The operation couldn’t be completed (NSURLErrorDomain -1.)&quot; which is the <code>error.localizedDescription</code> forwarded to UI from our API client.</p>
<p>Top level api call looks like this:</p>
<pre><code>class SomeViewModel {
  private let serviceCategories: ICategoriesService
  private var cancellables = [AnyCancellable]()

  init(service: ICategoriesService) {
    self.serviceCategories = service
  }

  // ...

  // Yes, the block is ugly. We are only on the half way of the migration to Combine
  func syncData(force: Bool = false, _ block: @escaping VoidBlock) {
    serviceCategories
      .fetch(force: force)
      .combineLatest(syncOrders(ignoreCache: force))
      .receive(on: DispatchQueue.main)
      .sink { [unowned self] completion in
        // bla-bla-bla
        // show alert on error
      }
      .store(in: &amp;cancellables)
  }
}
</code></pre>
<p>Low level API Client call looks like:</p>
<pre><code>func fetch&lt;R&gt;(_ type: R.Type, at endpoint: Endpoint, page: Int, force: Bool) -&gt; AnyPublisher&lt;R, TheError&gt; where R : Decodable {
  guard let request = request(for: endpoint, page: page, force: force) else {
    return Deferred { Future { $0(.failure(TheError.Network.cantEncodeParameters)) } }.eraseToAnyPublisher()
  }

  let decoder = JSONDecoder()
  decoder.keyDecodingStrategy = .convertFromSnakeCase

  return URLSession.shared
      .dataTaskPublisher(for: request)
      .subscribe(on: DispatchQueue.background)
      .tryMap { element in
        guard
          let httpResponse = element.response as? HTTPURLResponse,
          httpResponse.statusCode == 200 else
        { throw URLError(.badServerResponse) }
        
        return element.data
      }
      .decode(type: type, decoder: decoder)
      .mapError { error in
        // We map error to present in UI
        switch error {
        case is Swift.DecodingError:
          return TheError.Network.cantDecodeResponse
          
        default:
          return TheError(title: nil, description: error.localizedDescription, status: -2)
        }
      }
      .eraseToAnyPublisher()
}
</code></pre>
<p>In our analytics we can clearly see chain of events:</p>
<ul>
<li>application updated</li>
<li>application opened</li>
<li>main screen shown</li>
<li>alert shown (NSURLErrorDomain -1)</li>
<li>application backgrounded
then user fall into loop &quot;opened, alert, backgrounded&quot; trying to restart or reinstall the app without success.</li>
</ul>
<p>First sought was it may be some garbage sent from backend to the client, but our server logs have records for api calls correlated to analytics logs by date and time with <strong>http status code 499</strong>.<br />
So we can clearly determine this is not a server problem.
We also do not have reports or analytics records from users before this update.</p>
<p>All points to new API client switched to Combine.</p>
<p>It looks like session dropped by the client for some reason but at the same time it does not relates to a memory release cycle since if cancellable where released <code>sink</code> closure will never be executed and alert message will not be shown.</p>
<p><strong>Questions:</strong></p>
<ul>
<li>What can be wrong with this URLSession setup?</li>
<li>Did you faced similar behavior and managed to solve it?</li>
<li>Do you have ideas how to reproduce or at least simulate such error with URLSession?</li>
</ul>
<p>Notes:</p>
<ul>
<li>We do not use SwiftUI</li>
<li>iOS version vary from 14.8 to 15.0</li>
<li>From 5 to 10% of users affected</li>
<li>We never faced such error during development or testing</li>
</ul>
","1522697","","","","","2021-10-26 19:03:17","Swift Combine in UIKit. URLSession dataTaskPublisher NSURLErrorDomain -1 for some users","<ios><swift><combine><urlsession><nsurlsessiondatatask>","1","4","","","","CC BY-SA 4.0"
"69731160","1","69737763","","2021-10-26 23:52:38","","0","109","<p>Does anyone know how to recreate sampling behavior in Combine?</p>
<p>Here's a diagram of the sample's behavior in RXMarbles</p>
<p><a href=""https://i.stack.imgur.com/0S80B.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0S80B.png"" alt=""enter image description here"" /></a></p>
<p>The gist of sample() is that there are two streams, when one is triggered, the latest value of the other stream is sent if it already hasn't been sent.</p>
","465446","","","","","2021-10-27 18:07:24","Does Swift's Combine framework have a sample(on:) operator similar to those in RXSwift or Reactive Swift?","<rx-swift><reactive><sample><combine>","2","0","","","","CC BY-SA 4.0"
"69746741","1","69746865","","2021-10-27 23:54:56","","1","524","<p>After subscribing, I completed the subscription with the send method.<br />
I subscribed again, but it's finished.
How can I subscribe again?</p>
<pre><code>import Combine

let subject = PassthroughSubject&lt;String, Never&gt;()

subject
.sink(receiveCompletion: { completion in
    print(&quot;Received completion:&quot;, completion)
}, receiveValue: { value in
    print(&quot;Received value:&quot;, value)
})

subject.send(&quot;test1&quot;)
subject.send(completion: .finished)


subject
.sink(receiveCompletion: { completion in
    print(&quot;Received completion:&quot;, completion)
}, receiveValue: { value in
    print(&quot;Received value:&quot;, value)
})

subject.send(&quot;test2&quot;)
</code></pre>
<p>The output result is as follows.</p>
<blockquote>
<p>Received value: test1<br />
Received completion: finished<br />
Received completion: finished</p>
</blockquote>
<p>How can I get &quot;Received value: test2&quot;?</p>
","17149583","","","","","2021-10-28 00:15:49","How can I subscribe again after finishing with Combine?","<swift><combine><completion>","2","0","","","","CC BY-SA 4.0"
"69747746","1","","","2021-10-28 02:57:20","","0","78","<p>(note: I'm a beginner to programming) I just have a semantic question regarding Combine. I was under the impression that Combine was always required for serial HTTP requests but while experimenting I found that the following worked just fine:</p>
<pre><code>// this function works even though it depends on the output of the first HTTP request
    @available(iOS 15.0, *)
    func displayPictures(completion: @escaping ([(AsyncImage&lt;Image&gt;, UUID)]) -&gt; Void) throws {
        do {
            try getPictures { urls in
                var tempImageArr = [(AsyncImage&lt;Image&gt;, UUID)]()
                for url in urls {
                    guard let url = URL(string: url) else {
                        print(&quot;Invalid URL&quot;)
                        return
                    }
                    let image = AsyncImage(url: url)
                    let id = UUID()
                    tempImageArr.append((image, id))
                }
                completion(tempImageArr)
            }
        } catch {
        throw NetworkError.failedToGetPictures
    }
}
    
    func getPictures(completion: @escaping ([String]) -&gt; Void) throws {
        guard let url = URL(string: &quot;https://randomuser.me/api/?results=10&amp;inc=picture&quot;) else {
            print(&quot;Invalid URL&quot;)
            return
        }
        URLSession.shared.dataTask(with: url) { data, response, error in
            let decoder = JSONDecoder()
            let decodedResponse = try! decoder.decode(RandomUserModel.self, from: data!)
            completion(decodedResponse.pictures)
        }.resume()
    }

</code></pre>
<p>I'm hoping someone can clear up my confusion.</p>
<p>Thanks everyone.</p>
","16179605","","","","","2021-10-28 02:57:20","Is Combine always required to make serial HTTP requests?","<swift><networking><swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"69760771","1","","","2021-10-28 20:50:16","","1","109","<p>I’m building a macOS app based on data from CloudKit. I’m running into an issue where one of the <code>String</code>s in my UI is not being updated as I would expect it to.</p>
<h1>Model</h1>
<p>I have an <code>Event</code> <code>struct</code>, which has an ID and a timestamp:</p>
<pre><code>struct Event: Identifiable, Hashable {
    let id: UUID
    let timestamp: Date
    
    init(id: UUID = UUID(),
         timestamp: Date) {
        self.id = id
        self.timestamp = timestamp
    }
}
</code></pre>
<p>Periodically, my app fetches updated <code>Event</code> data from CloudKit. This is handled in an <code>ObservedObject</code> called <code>DataStore</code>.</p>
<p>For example, the fetch happens when the <code>DataStore</code> is initialized, and when a push notification comes from the server to indicate there is new information.</p>
<p>The function <code>updateLocalEvents()</code> in <code>DataStore</code> is called to actually update the local in-memory <code>@Published</code> <code>Array</code>, which calls <code>fetchEvents()</code> to actually get the current set of last 10 events data from CloudKit.</p>
<pre><code>class DataStore: ObservableObject {
    
    @Published var recentEvents: [Event] = []
    
    init() {
        
        updateLocalEvents()
    }
    
    func updateLocalEvents() {
        
        print(&quot;updateLocalEvents()&quot;)
        
        fetchEvents()
            .receive(on: RunLoop.main)
            .assign(to: &amp;$recentEvents)
    }
    
    private func fetchEvents() -&gt; AnyPublisher&lt;[Event],Never&gt; {
        
        let predicate = NSPredicate(value: true)
        
        let query = CKQuery(recordType: &quot;Event&quot;,
                            predicate: predicate)
        
        query.sortDescriptors = [NSSortDescriptor(key: &quot;timestamp&quot;,
                                                  ascending: false)]
        
        let operation = CKQueryOperation(query: query)
        operation.resultsLimit = 10
        operation.qualityOfService = .userInitiated
        
        var events = [Event]()
        
        operation.recordFetchedBlock = { record in
            
            if let id = UUID(uuidString: record.recordID.recordName),
               let timestamp = record.object(forKey: &quot;timestamp&quot;) as? Date
            {
                events.append(Event(id: id,
                                timestamp: timestamp))
            }
        }
        
        return Future&lt;[Event],Never&gt; { promise in
            
            operation.completionBlock = {
                promise(.success(events))
            }
            
            CKConstants.container
                .privateCloudDatabase
                .add(operation)
        }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<h1>View</h1>
<p>In my view, I show a <code>String</code> to indicate the time since the last event. For example, it may say <em>1 hour ago</em> or <em>3 hours ago</em> using a <code>RelativeDateTimeFormatter</code>.</p>
<p>This is stored in a <code>timeAgo</code> <code>@State</code> variable of type <code>String?</code>.</p>
<p>There is a <code>Timer</code> that attempts to update the <code>timeAgo</code> <code>String?</code> every minute, using an <code>.onReceive</code> modifier for the <code>Timer</code>, and another <code>.onReceive</code> modifier that uses the <code>@Published</code> <code>Array</code> of <code>Event</code>s to update the <code>timeAgo</code> <code>String?</code>. Here is my view code:</p>
<pre><code>struct EventsView: View {
    
    @EnvironmentObject var store: DataStore
    
    @State private var timer: Publishers.Autoconnect&lt;Timer.TimerPublisher&gt; = Timer
        .publish(every: 60,
                 on: .main,
                 in: .common)
        .autoconnect()
    
    @State private var timeAgo: String?
    
    var body: some View {
        
        VStack {
            if let mostRecentEvent = store.recentEvents.first {
                
                Text(timeAgo ?? relativeTimeFormatter.localizedString(for: mostRecentEvent.timestamp, relativeTo: Date()))
                    .fontWeight(.bold)
                    .font(.system(.largeTitle,
                                  design: .rounded))
                    .onReceive(timer) { _ in
                        timeAgo = relativeTimeFormatter
                            .localizedString(for: mostRecentEvent.timestamp, relativeTo: Date())
                    }
                    .onReceive(store.$recentEvents) { recentEvents in
                        print(&quot;.onReceive(store.$recentEvents)&quot;)
                        if let mostRecentEvent = recentEvents.first {
                            timeAgo = relativeTimeFormatter
                                .localizedString(for: mostRecentEvent.timestamp, relativeTo: Date())
                        }
                    }
            } else {
                Text(&quot;No Event Data&quot;)
            }
        }
        .frame(minWidth: 250,
               maxWidth: 250,
               minHeight: 200,
               maxHeight: 200)
    }
}

private let relativeTimeFormatter: RelativeDateTimeFormatter = {
    let formatter = RelativeDateTimeFormatter()
    formatter.dateTimeStyle = .numeric
    return formatter
}()
</code></pre>
<p>The problem is that, sometimes, there is a push notification indicating new data, and the <code>updateLocalEvents()</code> function is called, updating the <code>recentEvents</code> variable, which also triggers <code>.onReceive(store.$recentEvents)</code>. I can see this is happening with my <code>print</code> statements. However, the <code>timeAgo</code> variable does not always get updated, and the view still shows the old string.</p>
<p>How should I change this to get my desired result of always keeping the <code>timeAgo</code> <code>String?</code> up-to-date based on the current value of <code>@Published var recentEvents</code>?</p>
<p>I’m also open to any other suggestions to simplify or improve any of this code I shared! Thanks!</p>
","241163","","","","","2021-10-29 15:44:41","How can I reliably update a String in SwiftUI based on a @Published Array from an ObservableObject?","<swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"69762275","1","69762412","","2021-10-29 00:16:05","","5","1023","<p>I have a publisher when the sink, scans for a list of wifi.  I only want to scan for about 10 seconds and stop.</p>
<p>Is there a way to do this within the publisher chain of calls?</p>
","1454604","","","","","2021-11-04 21:38:09","How do you run a Swift Combine Publisher for a certain amount of time?","<swift><combine><publisher>","2","6","","","","CC BY-SA 4.0"
"69762481","1","","","2021-10-29 00:58:44","","0","389","<pre><code>func fetchData(from endpoint:ScrapeAPI )-&gt;AnyPublisher&lt;T, APIError&gt;{
    
    return AF.request(endpoint.mockurl,
                      method: .post,
                      parameters: endpoint.parameters,
                      encoder: JSONParameterEncoder.prettyPrinted,
                      headers: endpoint.headers)
        
        .validate()
        .publishDecodable(type:T.self)
        .value()
        .mapError{_ in APIError.unknown}
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
    }

enum APIError:Error {
    case decodingError
    case errorCOde(Int)
    case unknown
}

extension APIError: LocalizedError{
    var errorDescription: String? {
        switch self {
        case .decodingError:
            return &quot;Failed to decode the object from the service&quot;
        case .errorCOde(let code ):
            return &quot;\(code)- Something went wrong&quot;
        case .unknown:
            return &quot;the error is unknown&quot;
        }
    }
}

var subscriptions = Set&lt;AnyCancellable&gt;()

fetchData(from:ScrapeAPI.getScrape).sink(
    receiveCompletion: { completion in
        switch completion {
        case .failure(let error):
            print(error)
        case .finished:
            print(&quot;Success&quot;)
        }
    },
    receiveValue: { value in
        print(value)}

).store(in: &amp;subscriptions)
</code></pre>
<p>This prints error &quot;unknown&quot;. It reaches the  API and API responds with a body. It seems it is not getting published to T. Interestingly, Alamofire .responseJSON works. Ideally, I would like to verify T has new JSON data from API. How do I go about it?</p>
","15483404","","","","","2021-10-29 00:58:44","Swift 5, Alamofire, Combine, MVVM throws error","<ios><swift><mvvm><alamofire><combine>","0","3","","","","CC BY-SA 4.0"
"69774495","1","69774881","","2021-10-29 20:32:40","","0","622","<p>I am trying to chain <code>n</code> requests with <code>Combine</code>.</p>
<p>Let's assume I have 50 users and for each of them I need to do a single request to get a users data. I know that with <code>flatMap</code> you can pass one <code>Publisher</code> result into the next. But does that work with loops as well?</p>
<p>That's my function to fetch a user:</p>
<pre><code>func fetchUser(for id: Int) -&gt; AnyPublisher&lt;User, Error&gt; {
    let url = &quot;https://user.com/api/user/\(id)&quot;
    return URLSession.shared.dataTaskPublisher(for: url)
        .mapError { $0 as Error }
        .map { $0.data }
        .decode(type: User.self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
}
</code></pre>
<p>So basically I need another function, which loops this over this <code>fetchUser</code> and returns all users in one result array. The requests should not all run at the same time, but rather start one after the previous one has finished.</p>
","2128765","","","","","2021-10-29 21:19:45","Chaining n requests in Combine","<swift><combine><urlsession>","1","0","","2021-10-30 19:04:24","","CC BY-SA 4.0"
"69778523","1","","","2021-10-30 09:55:35","","0","584","<p>I'm building an app using SwiftUI / Combine and trying to do so in an MVVM pattern. I'm getting a little confused as to how best to expose certain properties and in particular, in relation to the Core Data implementation.</p>
<p>In the main app file, I have set up an environmnt object as follows (I'll come to why later):</p>
<pre><code>struct Football_GuruApp: App {
    let persistenceController = PersistenceController.shared
    @StateObject var favouritePlayers = FavouritePlayersViewModel()

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(\.managedObjectContext, persistenceController.container.viewContext)
                .environmentObject(favouritePlayers)
        }
    }
}
</code></pre>
<p>The app has 3 main views:</p>
<p>ContentView: this contains a TabView with 2 subviews: FetchedResultsView() and FavouritesView()</p>
<p>FetchedResultsView: this contains a subview FetchedPlayers() which looks like this:</p>
<pre><code>struct FetchedPlayersView: View {
    @EnvironmentObject var fetchedResultsVM: FetchedResultsViewModel
    
    var body: some View {
        Section(header: Text(&quot;Players&quot;)) {
            ForEach(fetchedResultsVM.fetchedPlayers, content: { player in
                PlayerView(player: player)
            })
            
            if fetchedResultsVM.playersExpandable {
                MoreResultsButton(action: fetchedResultsVM.getMorePlayers, buttonTitle: &quot;More players&quot;)
            }
        }
    }
}
</code></pre>
<p>And finally FavouritesView:</p>
<pre><code>struct FavouritesView: View {
    @EnvironmentObject var favouritePlayersVM: FavouritePlayersViewModel
    var context = PersistenceController.shared.container.viewContext
    
    var body: some View {
        List {
            ForEach(context.fetchAll(PlayerCD.self)) { player in
                PlayerView(player: PlayerViewModel.mapFromCoreData(player: player))
            }
        }
    }
}
</code></pre>
<p>Within the PlayerView() (subview of FetchedPlayersView) we have a button:</p>
<pre><code>FavouritesButton(playerViewModel: player)
</code></pre>
<p>When tapped we set a property on the PlayerViewModel to true:</p>
<pre><code>playerViewModel.favourite = true
</code></pre>
<p>And then a didSet method on PlayerViewModel triggers the player to be stored to core data:</p>
<pre><code>var favourite = false {
    didSet {
        self.mapToCoreData()
    }
}

   func mapToCoreData() {
        let storedPlayer = PlayerCD(context: context)
        
        storedPlayer.id = self.id
        storedPlayer.firstName = self.firstName
        storedPlayer.secondName = self.secondName
        
        try? PersistenceController.shared.container.viewContext.save()
        favouritePlayersVM.updateFavourites()
    }
</code></pre>
<p>We have the following env object on the PlayerViewModel</p>
<pre><code>@EnvironmentObject var favouritePlayersVM: FavouritePlayersViewModel
</code></pre>
<p>Finally, FavouritePlayersViewModel looks like this:</p>
<pre><code>class FavouritePlayersViewModel: ObservableObject {
    @Published var players = [PlayerViewModel]()

func updateFavourites() {
    let context = PersistenceController.shared.container.viewContext
    let savedPlayers = context.fetchAll(PlayerCD.self)
    self.players = [PlayersViewModel]()
    
    savedPlayers.forEach {
        players.append(PlayerViewModel.mapFromCoreData(player: $0))
        }
    }
}
</code></pre>
<p>So the idea is that when the button is tapped, we store to core data and then at the same time we update the players list on FavouritePlayersViewModel which should then update the FavouritesView with the latest players. However, clearly I am struggling with the implementation of the environment object. I had thought that by exposing this at the root of the app, I would be able to access everywhere, but I guess that as PlayerViewModel, for example, is not a direct descendent, I can't access (as I'm getting a crash).</p>
<p>Perhaps using the env object is not the best fit here, but I'm struggling to work out how best to have it so that I can update the FavouritesViewModel players list from the PlayerViewModel whilst using the same instance of this FavouritesViewModel to update the FavouritesView.</p>
<p>By the same token, I'm also not able to access the NSManagedObjectContext that I set as @Environment in the root file in the view models either which is why I'm using the singleton of the persistent container to store my core data, which is not what I really wanted to do.</p>
","7188537","","","","","2021-10-30 09:55:35","SwiftUI: unable to access @EnvironmentObject in view model","<core-data><mvvm><swiftui><viewmodel><combine>","0","3","","","","CC BY-SA 4.0"
"69778621","1","69779157","","2021-10-30 10:11:01","","1","264","<p>I have a parent view and a child view, each with their own viewModels. The parent view injects the child view's viewModel.</p>
<p><strong>The parent view does not correctly react to the changes on the child's computed property <code>isFormInvalid</code> (the child view does).</strong></p>
<p>@Published cannot be added to a computed property, and other questions/answers I've seen around that area have not focused on having separate viewModels as this question does. I want separate viewModels to increase testability, since the child view could become quite a complex form.</p>
<p>Here is a file to minimally reproduce the issue:</p>
<pre><code>import SwiftUI

extension ParentView {
    final class ViewModel: ObservableObject {
        @ObservedObject var childViewViewModel: ChildView.ViewModel

        init(childViewViewModel: ChildView.ViewModel = ChildView.ViewModel()) {
            self.childViewViewModel = childViewViewModel
        }
    }
}

struct ParentView: View {
    @ObservedObject private var viewModel: ViewModel

    init(viewModel: ViewModel = ViewModel()) {
        self.viewModel = viewModel
    }

    var body: some View {
        ChildView(viewModel: viewModel.childViewViewModel)
        .navigationBarTitle(&quot;Form&quot;, displayMode: .inline)
        .toolbar {
            ToolbarItem(placement: .confirmationAction) {
                addButton
            }
        }
    }

    private var addButton: some View {
        Button {
            print(&quot;======&quot;)
            print(viewModel.childViewViewModel.$name)
        } label: {
            Text(&quot;ParentIsValid?&quot;)
        }
        .disabled(viewModel.childViewViewModel.isFormInvalid) // FIXME: doesn't work, but the actual fields work in terms of two way updating
    }
}

struct ParentView_Previews: PreviewProvider {
    static var previews: some View {
        let childVm = ChildView.ViewModel()
        let vm = ParentView.ViewModel(childViewViewModel: childVm)

        NavigationView {
            ParentView(viewModel: vm)
        }
    }
}

// MARK: child view

extension ChildView {
    final class ViewModel: ObservableObject {

        // MARK: - public properties

        @Published var name = &quot;&quot;
        
        var isFormInvalid: Bool {
            print(&quot;isFormInvalid&quot;)
            return name.isEmpty
        }
    }
}

struct ChildView: View {
    @ObservedObject private var viewModel: ViewModel
    
    init(viewModel: ViewModel = ViewModel()) {
        self.viewModel = viewModel
    }
    
    var body: some View {
        Form {
            Section(header: Text(&quot;Name&quot;)) {
                nameTextField
            }
            Button {} label: {
                Text(&quot;ChildIsValid?: \(String(!viewModel.isFormInvalid))&quot;)
            }
            .disabled(viewModel.isFormInvalid)
        }
    }
    
    private var nameTextField: some View {
        TextField(&quot;Add name&quot;, text: $viewModel.name)
            .autocapitalization(.words)
    }
}

struct ChildView_Previews: PreviewProvider {
    static var previews: some View {
        let vm = ChildView.ViewModel()
        ChildView(viewModel: vm).preferredColorScheme(.light)
    }
}
</code></pre>
<p>Thank you!</p>
","9946657","","9946657","","2021-10-31 06:10:09","2021-10-31 06:10:09","Computed Property from Child's ViewModel does not update @ObservedObject Parent's ViewModel","<ios><swift><mvvm><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"69780705","1","69782757","","2021-10-30 17:47:44","","0","468","<p>I'm building a network API.
I'm new to Combine and I'm having some troubles with it, I'm trying to chain publish network requests, in this case I'm forming an URLRequest publisher and dispatching it on another publisher, the problem is that I cant make the flatMap work on the second publisher.</p>
<p>First I assemble the <code>URLRequest</code> with the Auth token:</p>
<pre><code>func asURLRequest(baseURL: String) -&gt; AnyPublisher&lt;URLRequest, NetworkRequestError&gt; {
        
        return Deferred {
            Future&lt;URLRequest, NetworkRequestError&gt; { promise in
                if var urlComponents = URLComponents(string: baseURL) {
                    urlComponents.path = &quot;\(urlComponents.path)\(path)&quot;
                    urlComponents.queryItems = queryItemsFrom(params: queryParams)
                    if let finalURL = urlComponents.url {
                        if let user = Auth.auth().currentUser {
                            print(&quot;##### final url -&gt; \(finalURL)&quot;)
                            // Retrieves the Firebase authentication token, possibly refreshing it if it has expired.
                            user.getIDToken(completion: { (token, error) in
                                if let fbToken = token {
                                    var request = URLRequest(url: finalURL)
                                    request.httpMethod = method.rawValue
                                    request.httpBody = requestBodyFrom(params: body)
                                    let defaultHeaders: HTTPHeaders = [
                                        HTTPHeaderField.contentType.rawValue: contentType.rawValue,
                                        HTTPHeaderField.acceptType.rawValue: contentType.rawValue,
                                        HTTPHeaderField.authentication.rawValue: fbToken
                                    ]
                                    request.allHTTPHeaderFields = defaultHeaders.merging(headers ?? [:], uniquingKeysWith: { (first, _) in first })
                                    print(&quot;##### API TOKEN() SUCCESS: \(defaultHeaders)&quot;)
                                    promise(.success(request))
                                }
                                
                                if let fbError = error {
                                    print(&quot;##### API TOKEN() ERROR: \(fbError)&quot;)
                                    promise(.failure(NetworkRequestError.decodingError))
                                }
                            })
                        }
                    } else {
                        promise(.failure(NetworkRequestError.decodingError))
                    }
                } else {
                    promise(.failure(NetworkRequestError.decodingError))
                }
            }
        }.eraseToAnyPublisher()
    }
</code></pre>
<p>Then I'm trying to dispatch a request (publisher) and return another publisher, the problem is that the .flatMap is not getting called:</p>
<pre><code>struct APIClient {
    var baseURL: String!
    var networkDispatcher: NetworkDispatcher!
    init(baseURL: String,
         networkDispatcher: NetworkDispatcher = NetworkDispatcher()) {
        self.baseURL = baseURL
        self.networkDispatcher = networkDispatcher
    }
    /// Dispatches a Request and returns a publisher
    /// - Parameter request: Request to Dispatch
    /// - Returns: A publisher containing decoded data or an error
    func dispatch&lt;R: Request&gt;(_ request: R) -&gt; AnyPublisher&lt;R.ReturnType, NetworkRequestError&gt; {
        print(&quot;##### --------&gt; \(request)&quot;)
        //typealias RequestPublisher = AnyPublisher&lt;R.ReturnType, NetworkRequestError&gt;
        return request.asURLRequest(baseURL: baseURL)
            .flatMap { request in
                //NOT GETTING CALLED
                self.networkDispatcher.dispatch(request: request)
            }.eraseToAnyPublisher()

}
</code></pre>
<p>The final publisher that is not being called is the following:</p>
<pre><code>struct NetworkDispatcher {
    let urlSession: URLSession!
    public init(urlSession: URLSession = .shared) {
        self.urlSession = urlSession
    }
    /// Dispatches an URLRequest and returns a publisher
    /// - Parameter request: URLRequest
    /// - Returns: A publisher with the provided decoded data or an error
    func dispatch&lt;ReturnType: Codable&gt;(request: URLRequest) -&gt; AnyPublisher&lt;ReturnType, NetworkRequestError&gt; {
        return urlSession
            .dataTaskPublisher(for: request)
        // Map on Request response
            .tryMap({ data, response in
                // If the response is invalid, throw an error
                if let response = response as? HTTPURLResponse,
                   !(200...299).contains(response.statusCode) {
                    throw httpError(response.statusCode)
                }
                // Return Response data
                return data
            })
        // Decode data using our ReturnType
            .decode(type: ReturnType.self, decoder: JSONDecoder())
        // Handle any decoding errors
            .mapError { error in
                handleError(error)
            }
        // And finally, expose our publisher
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>Running the code:</p>
<pre><code> struct ReadUser: Request {
        typealias ReturnType = UserData
        var path: String
        var method: HTTPMethod = .get
        init(_ id: String) {
            path = &quot;users/\(id)&quot;
        }
    }
    
    let apiClient = APIClient(baseURL: BASE_URL)
    var cancellables = [AnyCancellable]()
    
    apiClient.dispatch(ReadUser(Auth.auth().currentUser?.uid ?? &quot;&quot;))
        .receive(on: DispatchQueue.main)
        .sink(
            receiveCompletion: { result in
                switch result {
                case .failure(let error):
                    // Handle API response errors here (WKNetworkRequestError)
                    print(&quot;##### Error loading data: \(error)&quot;)
                default: break
                }
            },
            receiveValue: { value in
            })
        .store(in: &amp;cancellables)
</code></pre>
","1065307","","1065307","","2021-10-30 18:27:37","2021-10-31 12:10:14","FlatMap with Generic ReturnType using Combine","<ios><swift><xcode><combine><urlsession>","2","5","","","","CC BY-SA 4.0"
"69797116","1","","","2021-11-01 12:44:44","","0","538","<p>I'm experimenting with SwiftUI and Combine, and wanted to be able to receive notification whenever an array of struct items changes (either changes within items, or changes to the array, i.e. append, remove).</p>
<p>I tried the following code, but all I get, given an input array of three elements, is a receiveValue for each of those three initials, and nothing else even when changes are made to the array through the UI (which correctly reflects the changes).  It's as if its a fire once publisher.</p>
<pre><code>struct Item: Identifiable {
    var id = UUID()
    var title: String
}

class ItemStore: ObservableObject {
    @Published var items: [Item]

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(items: [Item] = []) {
        self.items = items

        self.items.publisher
            .sink(receiveValue: {
                print(&quot;save=\($0)&quot;)
            })
            .store(in: &amp;cancellables)
    }

}
</code></pre>
<p>After some playing around, I tried the following, which then receives a receiveValue containing the entire array, and does so for each futher update.  This would actually suffice for my current experiment, but doesn't seem like how it should be done, poking into the internals of the @Published array.</p>
<pre><code>struct Item: Identifiable {
    var id = UUID()
    var title: String
}

class ItemStore: ObservableObject {
    @Published var items: [Item]

    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(items: [Item] = []) {
        self.items = items

        self._items.projectedValue
            .sink(receiveValue: {
                print(&quot;save=\($0)&quot;)
            })
            .store(in: &amp;cancellables)
    }

}
</code></pre>
<p>I guess the crux of the question is, what is the right way to receive notifications over the lifecycle of the app for:</p>
<ol>
<li>An array</li>
<li>The elements of an array</li>
</ol>
<p>NB: I'm aware that I can suppress the initial assignment using the .dropFirst method (optionally specifying the number of elements to skip).</p>
<p>The ItemStore instance is passed in using environmentObject and accessed using @EnvironmentObject.</p>
<p>I'm aware there might be much better ways to respond to changes for persisting state, but this still seems valid for a trivial app.</p>
","327598","","","","","2022-07-20 22:49:07","SwiftUI/Combine: Subscribing to array updates vs element updates","<swiftui><combine><publisher><subscriber>","1","2","1","","","CC BY-SA 4.0"
"69807263","1","69816371","","2021-11-02 08:23:27","","1","114","<p>I have a bottom view with a textField. This bottom view will show up on the action of a button. But the bottom view does not move up on taps of a text field. I have added the code for this.</p>
<p>This is ContentView where the button is displayed.</p>
<pre><code>struct ContentView: View {
    @State var cardShown = false
    @State var cardDismissal = false

    var body: some View {
        NavigationView {
            ZStack {
                Button(action: {
                    cardShown.toggle()
                    cardDismissal.toggle()
                }, label: {
                    Text(&quot;Show Card&quot;)
                        .bold()
                        .foregroundColor(Color.white)
                        .background(Color.blue)
                        .frame(width: 200, height: 50)
                })
                BottomCard(cardShown: $cardShown, cardDismissal: $cardDismissal, height: 300, content: {
                    CardContent()
                        .padding()
                })
            }
        }
    }
}
</code></pre>
<p>This is the bottom card content view. This needs to be up on tap on the text field. There is a TextField. I have added keyboardAdaptive modifier to recieve the keyboard height but not working.</p>
<pre><code>struct CardContent: View {
    
    @State private var text = &quot;&quot;
    
    var body: some View {
        
        VStack {
            
            Text(&quot;Photo Collage&quot;)
                .bold()
                .font(.system(size: 30))
                .padding()
            
            Text(&quot;You can create awesome photo grids and share them with all of your friends&quot;)
                .font(.system(size: 18))
                .multilineTextAlignment(.center)
            
            TextField(&quot;Enter something&quot;, text: $text)
                .textFieldStyle(RoundedBorderTextFieldStyle())
        }
        .padding()
        .keyboardAdaptive() // Apply the modifier
    }
}


struct BottomCard&lt;Content: View&gt;: View {
    let content: Content
    @Binding var cardShown: Bool
    @Binding var cardDismissal: Bool
    let height: CGFloat
    init(cardShown: Binding&lt;Bool&gt;, cardDismissal: Binding&lt;Bool&gt;, height: CGFloat, @ViewBuilder content: () -&gt; Content) {
        _cardShown = cardShown
        _cardDismissal = cardDismissal
        self.height = height
        self.content = content()
    }
    
    var body: some View {
        ZStack {
            // Dimmed
            GeometryReader { _ in
                EmptyView()
            }
            .background(Color.gray.opacity(0.5))
            .opacity(cardShown ? 1: 0)
            .animation(Animation.easeIn, value: 0.9)
            
            .onTapGesture {
                // Dismiss
                dismiss()
            }
            
            // Card
            
            VStack {
                Spacer()
                
                VStack {
                  content
                    
                    Button(action: {
                        // Dismiss
                        dismiss()
                    }, label: {
                        Text(&quot;Dismiss&quot;)
                            .foregroundColor(Color.white)
                            .frame(width: UIScreen.main.bounds.width/2, height: 50)
                            .background(Color.pink)
                            .cornerRadius(8)

                    })
                     .padding()
                }
                .background(Color(UIColor.secondarySystemBackground))
                .frame(height: height)
                .offset(y: (cardShown &amp;&amp; cardShown) ? 0 : 500)
                .animation(Animation.default.delay(0.2), value: 0.2)
            }
        }
        .edgesIgnoringSafeArea(.all)
    }
    
    func dismiss() {
        cardDismissal.toggle()
        DispatchQueue.main.asyncAfter(deadline: .now()+0.25) {
            cardShown.toggle()
        }

    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
extension Publishers {
    // 1.
    static var keyboardHeight: AnyPublisher&lt;CGFloat, Never&gt; {
        // 2.
        let willShow = NotificationCenter.default.publisher(for: UIApplication.keyboardWillShowNotification)
            .map { $0.keyboardHeight }
        
        let willHide = NotificationCenter.default.publisher(for: UIApplication.keyboardWillHideNotification)
            .map { _ in CGFloat(0) }
        
        // 3.
        return MergeMany(willShow, willHide)
            .eraseToAnyPublisher()
    }
}
extension Notification {
    var keyboardHeight: CGFloat {
        return (userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect)?.height ?? 0
    }
}

struct KeyboardAdaptive: ViewModifier {
    @State private var bottomPadding: CGFloat = 0
    
    func body(content: Content) -&gt; some View {
        // 1.
        GeometryReader { geometry in
            content
                .padding(.bottom, self.bottomPadding)
                // 2.
                .onReceive(Publishers.keyboardHeight) { keyboardHeight in
                    // 3.
                    let keyboardTop = geometry.frame(in: .global).height - keyboardHeight
                    // 4.
                    let focusedTextInputBottom = UIResponder.currentFirstResponder?.globalFrame?.maxY ?? 0
                    // 5.
                    self.bottomPadding = max(0, focusedTextInputBottom - keyboardTop - geometry.safeAreaInsets.bottom)
            }
            // 6.
                .animation(.easeOut, value: 0.16)
        }
    }
}
extension View {
    func keyboardAdaptive() -&gt; some View {
        ModifiedContent(content: self, modifier: KeyboardAdaptive())
    }
}
extension UIResponder {
    static var currentFirstResponder: UIResponder? {
        _currentFirstResponder = nil
        UIApplication.shared.sendAction(#selector(UIResponder.findFirstResponder(_:)), to: nil, from: nil, for: nil)
        return _currentFirstResponder
    }

    private static weak var _currentFirstResponder: UIResponder?

    @objc private func findFirstResponder(_ sender: Any) {
        UIResponder._currentFirstResponder = self
    }

    var globalFrame: CGRect? {
        guard let view = self as? UIView else { return nil }
        return view.superview?.convert(view.frame, to: nil)
    }
}
</code></pre>
","1960279","","","","","2021-11-03 11:56:45","unable to move bottom view up on tap of TextField in swiftui?","<swiftui><keyboard><combine><publisher><viewbuilder>","1","0","","","","CC BY-SA 4.0"
"69847772","1","69849312","","2021-11-05 01:38:59","","0","271","<p>I wrote a Combine Publisher wrapper class for some old code that used delegation.</p>
<p>TLDR; Can someone improve how I manage the lifetime of my custom publisher. Preferrable by making it behave like normal publishers, where you can just sink to it and not have to worry about retaining that instance.</p>
<p><strong>Details</strong>
I encountered a problem where I have to keep a reference to my Publisher wrapper for it to work. Every example of a custom publisher doesn't have this requirement, though their publishers were structs and were fairly different from mine.</p>
<p>Here's a simplified version of the problem that I'm having. Note the commented out section in doSomething()</p>
<pre><code>import Foundation
import Combine

// Old code that uses delegate
protocol ThingDelegate: AnyObject {
    func delegateCall(number: Int)
}

class Thing {
    weak var delegate: ThingDelegate?
    var name: String = &quot;Stuff&quot;

    init() {
        Swift.print(&quot;thing init&quot;)
    }

    deinit {
        Swift.print(&quot;☠️☠️☠️☠️☠️☠️ thing deinit&quot;)
    }

    func start() {
        Swift.print(&quot;Thing.start()&quot;)

        DispatchQueue.main.async {
            self.delegate?.delegateCall(number: 99)
        }
    }
}

// Combine Publisher Wrapper
class PublisherWrapper: Publisher {
    typealias Output = Int
    typealias Failure = Error

    private let subject = PassthroughSubject&lt;Int, Failure&gt;()

    var thing: Thing

    init(thing: Thing) {
        Swift.print(&quot;wrapper init&quot;)
        self.thing = thing
        self.thing.delegate = self
    }

    deinit {
        Swift.print(&quot;☠️☠️☠️☠️☠️☠️ wrapper deinit&quot;)
    }

    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Int == S.Input {
        self.subject.subscribe(subscriber)
        self.thing.start()
    }
}

extension PublisherWrapper: ThingDelegate {
    func delegateCall(number: Int) {
        Swift.print(&quot;publisher delegate call: \(number)&quot;)
        self.subject.send(number)
        self.subject.send(completion: .finished)
    }
}

class Test {
    var cancellables = Set&lt;AnyCancellable&gt;()

    var wrapper: PublisherWrapper?

    func doSomething() {
        Swift.print(&quot;doSomething()&quot;)
        let thing = Thing()
        let wrapper = PublisherWrapper(thing: thing)
        self.wrapper = wrapper

        // Take a look over here
        //
        // if you comment out the line above where I set self.wrapper = wrapper
        // it prints out the following
        //
        //start
        //doSomething()
        //thing init
        //wrapper init
        //Thing.start()
        //☠️☠️☠️☠️☠️☠️ wrapper deinit
        //☠️☠️☠️☠️☠️☠️ thing deinit
        //


        // But if you uncomment the line and retain it and you'll get the following
        //start
        //doSomething()
        //thing init
        //wrapper init
        //Thing.start()
        //publisher delegate call: 99
        //value: 99
        //finished
        //release wrapper: nil
        //☠️☠️☠️☠️☠️☠️ wrapper deinit
        //☠️☠️☠️☠️☠️☠️ thing deinit

        // we get the value and everything works as it should


        wrapper.sink { [weak self] completion in
            print(completion)
            self?.wrapper = nil
            print(&quot;release wrapper: \(self?.wrapper)&quot;)
        } receiveValue: {
            print(&quot;value: \($0)&quot;)
        }.store(in: &amp;self.cancellables)
    }
}

print(&quot;start&quot;)
let t = Test()
t.doSomething()

</code></pre>
<p>Is there an approach that avoids retaining the publisher like this? I ask because this can get pretty ugly when using flatMap.</p>
","465446","","465446","","2021-11-05 20:18:13","2021-11-06 04:08:04","Custom Combine Publisher wrapper class does not work unless retained","<swift><combine><publisher>","1","4","","","","CC BY-SA 4.0"
"69851185","1","69851238","","2021-11-05 09:39:36","","-1","56","<p>If I have an <code>ObservableObject</code> like...</p>
<pre><code>class Foo: ObservableObject {
  @Published var value: Int = 1

  func update() {
    value = 1
  }
}
</code></pre>
<p>And then a view like...</p>
<pre><code>struct BarView: View {
  @ObservedObject var foo: Foo

  var body: some View {
    Text(&quot;\(foo.value)&quot;)
      .onAppear { foo.update() }
  }
}
</code></pre>
<p>Does this cause the view to constantly refresh? Or does SwiftUI do something akin to <code>removeDuplicates</code> in the subscribers that it creates?</p>
<p>I imagine the latter but I've been struggling to find any documentation on this.</p>
","421018","","","","","2021-11-05 09:47:41","Does SwiftUI removeDuplicates from a subscriber to an @Published property?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"69852510","1","","","2021-11-05 11:24:17","","1","832","<p>Could you help me with a Combine issue?</p>
<p>I'd like to make a Publisher which sends multiple values during its lifetime. In more detail, I want to wrap a method with a completion handler into a Publisher, and the completion handler is supposed to be called multiple times. For example, it's a method used for receiving messages via WebSocket like this:</p>
<pre class=""lang-swift prettyprint-override""><code>webSocketClient.receiveMessage { message, error in
    // this closure is called multiple times, everytime a message comes
    ...
}
</code></pre>
<p>How can I wrap this into a Publisher? I want something like <code>AnyPublisher&lt;String, Error&gt;</code> in the end.</p>
<p>Wrapping these is super easy when I use other FRP libraries. For example, in ReactiveSwift, it can be achieved by using <a href=""https://github.com/ReactiveCocoa/ReactiveSwift/blob/master/Sources/SignalProducer.swift#L68-L79"" rel=""nofollow noreferrer""><code>SignalProducer.init(_ startHandler:)</code></a>. In RxSwift, it's <a href=""https://github.com/ReactiveX/RxSwift/blob/main/RxSwift/Observables/Create.swift#L20"" rel=""nofollow noreferrer""><code>Observable.create</code></a> method.</p>
<p>In Combine, I found <code>Future</code> can be used when there's only one value to emit, but it doesn't suit my current case. I couldn't find any initializer for Publisher for this use case.</p>
<p>Also, I found <a href=""https://github.com/pointfreeco/swift-composable-architecture/blob/main/Sources/ComposableArchitecture/Effect.swift#L179-L183"" rel=""nofollow noreferrer"">Effect.run</a> in TCA (The Composable Architecture) which can be used for this case. It seems custom publishers are used in its implementation, which seems a bit complicated for simple usage, but is this the only way? Are there any other easy ways to achieve the similar behavior?</p>
<p>I feel this is a quite common scenario, so I'd like to know how Combine users are handling this case in practice.</p>
<p>Thank you in advance!</p>
","6459480","","","","","2021-11-05 11:46:52","How to make a Publisher that sends multiple values in Combine","<swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"69859348","1","69859604","","2021-11-05 21:19:16","","2","410","<p>I currently have code like...</p>
<pre><code>var isFetching = false

func fetch() {
  guard !isFetching else { return }
  fetching = true

  apiPublisher
    .receive(on: .main)
    .handleEvents(receiveCompletion: { [weak self] _ in
      self?.fetching = false
    })
    .assign(to: \.foo, on: self)
    .store(in: &amp;cancellables)
}
</code></pre>
<p>But I'm not happy with the way I'm stopping multiple requests happening like this. It works but feels clunky.</p>
<p>I feel like there should be a more &quot;Combine-y&quot; way of doing this.</p>
<p>Is there a more elegant/Combine-y way of doing this?</p>
","421018","","","","","2021-11-05 21:49:19","Is there a Combine-y way to stop multiple requests being triggered?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"69872377","1","69878975","","2021-11-07 12:22:04","","0","321","<p>I want to use <code>@resultbuilder</code> and <code>Combine</code> to create my own reactive and declarative UICollectionView List in UIKit, similiar to what we get with <code>List {}</code> in SwiftUI.</p>
<p>For that, i am using a resultbuilder to create a Snapshot like this:</p>
<pre class=""lang-swift prettyprint-override""><code>@resultBuilder
struct SnapshotBuilder {
    
    static func buildBlock(_ components: ListItemGroup...) -&gt; [ListItem] {
        return components.flatMap { $0.items }
    }
    
    // Support `for-in` loop
    static func buildArray(_ components: [ListItemGroup]) -&gt; [ListItem] {
        return components.flatMap { $0.items }
    }
    
    static func buildFinalResult(_ component: [ListItem]) -&gt; NSDiffableDataSourceSectionSnapshot&lt;ListItem&gt; {
        var sectionSnapshot = NSDiffableDataSourceSectionSnapshot&lt;ListItem&gt;()
        sectionSnapshot.append(component)
        return sectionSnapshot
    }
}
</code></pre>
<p>I also need to use the following extensions to pass <code>ListItemGroup</code> to SnapshotBuilder and get <code>[ListItem]</code></p>
<pre class=""lang-swift prettyprint-override""><code>struct ListItem: Hashable {
    
    let title: String
    let image: UIImage?
    var children: [ListItem]
    
    init(_ title: String, children: [ListItem] = []) {
        self.title = title
        self.image = UIImage(systemName: title)
        self.children = children
    }
}

protocol ListItemGroup {
    var items: [ListItem] { get }
}

extension Array: ListItemGroup where Element == ListItem {
    var items: [ListItem] { self }
}

extension ListItem: ListItemGroup {
    var items: [ListItem] { [self] }
}
</code></pre>
<p>My <code>List</code> Class looks like this:</p>
<pre class=""lang-swift prettyprint-override""><code>final class List: UICollectionView {
    
    enum Section {
        case main
    }
    
    var data: UICollectionViewDiffableDataSource&lt;Section, ListItem&gt;!
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(_ items: Published&lt;[String]&gt;.Publisher, style: UICollectionLayoutListConfiguration.Appearance = .insetGrouped, @SnapshotBuilder snapshot: @escaping () -&gt; NSDiffableDataSourceSectionSnapshot&lt;ListItem&gt;) {
        super.init(frame: .zero, collectionViewLayout: List.createLayout(style))
    
        configureDataSource()
        data.apply(snapshot(), to: .main)
        
        items
            .sink { newValue in
                let newSnapshot = snapshot()
                self.data.apply(newSnapshot, to: .main, animatingDifferences: true)
            }
            .store(in: &amp;cancellables)
    }
    
    required init(coder: NSCoder) {
        super.init(coder: coder)!
    }
    
    private static func createLayout(_ appearance: UICollectionLayoutListConfiguration.Appearance) -&gt; UICollectionViewLayout {
        let layoutConfig = UICollectionLayoutListConfiguration(appearance: appearance)
        return UICollectionViewCompositionalLayout.list(using: layoutConfig)
    }
    
    private func configureDataSource() {
        let cellRegistration = UICollectionView.CellRegistration&lt;UICollectionViewListCell, ListItem&gt; {
            (cell, indexPath, item) in
            
            var content = cell.defaultContentConfiguration()
            content.image = item.image
            content.text = item.title
            cell.contentConfiguration = content
        }
        
        data = UICollectionViewDiffableDataSource&lt;Section, ListItem&gt;(collectionView: self) {
            (collectionView: UICollectionView, indexPath: IndexPath, identifier: ListItem) -&gt; UICollectionViewCell? in
            
            let cell = collectionView.dequeueConfiguredReusableCell(using: cellRegistration, for: indexPath, item: identifier)
            cell.accessories = [.disclosureIndicator()]
            return cell
        }
    }
}
</code></pre>
<p>And i am using it in my ViewControllers like this:</p>
<pre class=""lang-swift prettyprint-override""><code>class DeclarativeViewController: UIViewController {
    
    @Published var testItems: [String] = []
    
    var collectionView: List!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        navigationController?.navigationBar.sizeToFit()
        title = &quot;Settings&quot;

        navigationItem.rightBarButtonItem = UIBarButtonItem(image: UIImage(systemName: &quot;plus&quot;), style: .plain, target: self, action: #selector(addItem))
        
        view.backgroundColor = .systemBackground
        
        collectionView = List($testItems) {
            for item in self.testItems {
                ListItem(item)
            }
        }
        
        collectionView.frame = view.bounds
        collectionView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        view.addSubview(collectionView)
    }
    
    @objc func addItem() {
        testItems.append(&quot;Item \(testItems.count)&quot;)
    }
}
</code></pre>
<p>As you can see, i initialize my <code>List</code> with the <code>@Published var testItems</code> variable. In my <code>init()</code> func, i setup a subscriber and store them in <code>cancellables</code>, so i can react on changes.</p>
<p>If i add an item to <code>testItems</code> array, the <code>sink</code> callback is exectued to create a new snapshot and apply them to <code>data</code>. It works, but i need to tap the navigation button twice, to see an item on the list. Two questions:</p>
<ol>
<li>Why this is happen and how can i solve this? (so i only need to tap the button once to see changes in my list)</li>
<li>and how can i improve my code? (currently I always create a new snapshot instead of extending the already created one)</li>
</ol>
","10183816","","","","","2021-11-08 05:37:54","How can i use Combine with @resultbuilder to build a dynamic collectionview list?","<swift><uicollectionview><uikit><combine><swift5>","1","0","","","","CC BY-SA 4.0"
"69877801","1","","","2021-11-08 01:19:29","","-1","522","<p>My App uses SwiftUI, targets iOS 15+ and is governed by an <code>ObservableObject</code>, <code>AppState</code>, which serves as the source of truth throughout the app. I use <code>@Published var</code>s to manage the state of overlays (e.g. while loading data) in various places without problems.</p>
<p>Simplified <code>AppState</code>:</p>
<pre class=""lang-swift prettyprint-override""><code>class AppState:ObservableObject {
  @Published var showLoadingOverlay = false

  func loadData() {
    self.showLoadingOverlay = true
    // fech data
    self.showLoadingOverlay = false
  }
}
</code></pre>
<p>Within views I inject the <code>AppState</code> via <code>@EnvironmentObject</code> and use the published variables to control <code>fullScreenCover</code>.</p>
<p>Simplified example:</p>
<pre class=""lang-swift prettyprint-override""><code>struct MyDataView:View {
  @EnvironmentObject var state:AppState

  var body: some View {
    ScrollView {
      VStack {
        ForEach(Array(zip(state.dataSets.indices, state.dataSets)), id: \.0) { (dataSetIndex, dataSet) in
          MirrorChartView(dataSet: dataSet)
        }
      }
    }
    .onAppear {
      state.loadData()
    }
    .fullScreenCover(isPresented: $state.showLoadingOverlay) {
      LoadingOverlay()
    }
  }
}
</code></pre>
<p><strong>The problem</strong> I'm encountering is that one overlay remains shown while the binding value changes to <code>false</code>. This <em>&quot;getting stuck&quot;</em> only occurs in cases where <code>loadData()</code> completes very fast and the overlay would virtually get dismissed before being fully shown.</p>
<p>Adding a debug monitor to the view confirms that the binding to <code>AppState</code> is properly propagated:</p>
<pre class=""lang-swift prettyprint-override""><code>struct MyDataView:View {
  @EnvironmentObject var state:AppState

  var body: some View {
    VStack {
      // draw stuff
    }
    .onAppear {
      state.loadData()
    }
    .onChange(of: state.showLoadingOverlay) { showOverlay in
      print(&quot;show overlay: \(showOverlay)&quot;)
    }
    .fullScreenCover(isPresented: $state.showLoadingOverlay) {
      LoadingOverlay()
    }
  }
}
</code></pre>
<p>I.e. I can see the log <code>show overlay: false</code> while the overlay is sliding up, but it doesn't get dismissed.</p>
<p>Even adding an indirection via a <code>@State</code> local binding does not reliably fix the issue:</p>
<pre class=""lang-swift prettyprint-override""><code>struct MyDataView:View {
  @EnvironmentObject var state:AppState
  @State var showLoadingOverlay = false

  var body: some View {
    VStack {
      // draw stuff
    }
    .onAppear {
      state.loadData()
    }
    .onChange(of: state.showLoadingOverlay) { showOverlay in
      self.showLoadingOverlay = showOverlay
    }
    .fullScreenCover(isPresented: self.$showLoadingOverlay) {
      LoadingOverlay()
    }
  }
}

</code></pre>
<p><strong>Update: more testing has shown that even an in-place binding being false does not dismiss the <code>fullScreenCover</code>:</strong></p>
<p>Replacing the state binding with an in-place custom binding shows my state to be properly propagated and causing a view update. The sheet, however, still stays presented.</p>
<pre class=""lang-swift prettyprint-override""><code>struct MyDataView:View {
  @EnvironmentObject var state:AppState

  var body: some View {
    VStack {
      // draw stuff
    }
    .onAppear {
      state.loadData()
    }
    .fullScreenCover(isPresented: .init(
      get: {
        print(&quot;recomputing binding: \(state.showOverlay)&quot;)
        return state.showOverlay
      }, set: { newValue in
        state.showOverlay = newValue
      }
    )) {
      LoadingOverlay()
    }
  }
}
</code></pre>
<p>This results in the following log message chronology:</p>
<pre><code>recomputing binding: false
recomputing binding: true
recomputing binding: false
</code></pre>
<p><strong>Update: further findings</strong></p>
<p>I'm not sure what to make of it, but adding a log message to the <code>LoadingOverlay</code>'s <code>.onAppear()</code> shows, that it appears <em>after</em> the binding has changed to false:</p>
<pre class=""lang-swift prettyprint-override""><code>struct MyDataView:View {
  @EnvironmentObject var state:AppState

  var body: some View {
    ScrollView {
      VStack {
        ForEach(Array(zip(state.dataSets.indices, state.dataSets)), id: \.0) { (dataSetIndex, dataSet) in
          MirrorChartView(dataSet: dataSet)
        }
      }
    }
    .onAppear {
      state.loadData()
    }
    .onChange(of: state.showLoadingOverlay) { show in
      print(&quot;show loading overlay \(show)&quot;)
    }
    .fullScreenCover(isPresented: $state.showLoadingOverlay) {
      LoadingOverlay()
        .onAppear {
          print(&quot;loading overlay appears&quot;)
        }
    }
  }
}
</code></pre>
<p>This results in the following log message chronology:</p>
<pre><code>show loading overlay: true
show loading overlay: false
loading overlay appears
</code></pre>
<p><strong>What ways are there to resolve this issue?</strong></p>
","5061949","","5061949","","2021-11-10 18:47:56","2021-11-10 18:47:56","SwiftUI/iOS 15: fullScreenCover not dismissing with binding on published var","<ios><swift><swiftui><combine>","1","8","1","","","CC BY-SA 4.0"
"69879943","1","","","2021-11-08 07:32:37","","0","73","<p>I have been trying to asynchronously load an image in my app using combine. Currently all the other pieces of data are loading fine, but my image seem to be stuck in a progress view. Why? I am not too familiar with how combine works as I have been trying to follow a tutorial and adapting it to fit my needs, which is why I ran into this problem.</p>
<p>This is my code:</p>
<p>Main View:</p>
<pre><code>import SwiftUI

struct ApodView: View {
    @StateObject var vm = ApodViewModel()
    
    var body: some View {
        ZStack {
            // Background Layer
            Color.theme.background
                .ignoresSafeArea()
            
            // Content Layer
            VStack() {
                Text(vm.apodData?.title ?? &quot;Placeholder&quot;)
                    .font(.title)
                    .fontWeight(.bold)
                    .multilineTextAlignment(.center)
                    .foregroundColor(Color.theme.accent)
                
                ApodImageView(apodData: vm.apodData ?? ApodModel(date: &quot;&quot;, explanation: &quot;&quot;, url: &quot;&quot;, thumbnailUrl: &quot;&quot;, title: &quot;&quot;))
           
                ZStack() {
                    
                    Color.theme.backgroundTextColor
                    
                    ScrollView(showsIndicators: false) {
                        Text(vm.apodData?.explanation ?? &quot;Loading...&quot;)
                            .font(.body)
                            .fontWeight(.semibold)
                            .foregroundColor(Color.theme.accent)
                            .multilineTextAlignment(.center)
                            .padding()
                    }
                }
                .cornerRadius(10)
            }
            .padding()
        }
    }
}
</code></pre>
<p>ImageView:</p>
<pre><code>import SwiftUI

struct ApodImageView: View {
    
    @StateObject var vm: ApodImageViewModel
    
    init(apodData: ApodModel) {
        _vm = StateObject(wrappedValue: ApodImageViewModel(apodData: apodData))
    }
    
    var body: some View {
        ZStack {
            if let image = vm.image {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFit()
            } else if vm.isLoading {
                ProgressView()
            } else {
                Image(systemName: &quot;questionmark&quot;)
                    .foregroundColor(Color.theme.secondaryText)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: 250)
        .cornerRadius(10)
    }
}
</code></pre>
<p>Image ViewModel:</p>
<pre><code>import Foundation
import SwiftUI
import Combine

class ApodImageViewModel: ObservableObject {
    
    @Published var image: UIImage?
    @Published var isLoading: Bool = false
    
    private let apodData: ApodModel
    private let dataService: ApodImageService
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(apodData: ApodModel) {
        self.apodData = apodData
        self.dataService = ApodImageService(apodData: apodData)
        self.addSubscribers()
        self.isLoading = true
    }
    
    private func addSubscribers() {
        dataService.$image
            .sink { [weak self] _ in
                self?.isLoading = false
            } receiveValue: { [weak self] returnedImage in
                self?.image = returnedImage
            }
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>Networking For Image:</p>
<pre><code>import Foundation
import SwiftUI
import Combine

class ApodImageService: ObservableObject {
    
    @Published var image: UIImage?
    
    private var imageSubscription: AnyCancellable?
    private let apodData: ApodModel
    
    init(apodData: ApodModel) {
        self.apodData = apodData
        getApodImage()
    }
    
    private func getApodImage() {
        guard let url = URL(string: apodData.thumbnailUrl ?? apodData.url) else { return }
        imageSubscription = NetworkingManager.download(url: url)
            .tryMap({ data -&gt; UIImage? in
                return UIImage(data: data)
            })
            .sink(receiveCompletion: NetworkingManager.handleCompletion, receiveValue: { [weak self] returnedImage in
                self?.image = returnedImage
                self?.imageSubscription?.cancel()
            })
    }
}
</code></pre>
<p>General Networking Code:</p>
<pre><code>import Foundation
import Combine

class NetworkingManager {
    
    enum NetworkingError: LocalizedError {
        case badURLResponse(url: URL)
        case unknown
        
        var errorDescription: String? {
            switch self {
            case .badURLResponse(url: let url): return &quot;Bad response from URL: \(url)&quot;
            case .unknown: return &quot;Unknown Error Returned&quot;
            }
        }
    }
    
    static func download(url: URL) -&gt; AnyPublisher&lt;Data, Error&gt; {
        return URLSession.shared.dataTaskPublisher(for: url)
            .subscribe(on: DispatchQueue.global(qos: .background))
            .tryMap({ try handleURLResponse(output: $0, url: url) })
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
</code></pre>
","17355032","","","","","2021-11-08 22:59:55","SwiftUI Image in App not loading when using Combine","<swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"69889949","1","","","2021-11-08 21:07:19","","0","237","<p>I'm trying to create an animation in my app when a particular action happens which will essentially make the background of a given element change colour and back x number of times to create a kind of 'pulse' effect. The application itself is quite large, but I've managed to re-create the issue in a very basic app.</p>
<p>So the ContentView is as follows:</p>
<pre><code>struct ContentView: View {
    struct Constants {
        static let animationDuration = 1.0
        static let backgroundAlpha: CGFloat = 0.6
    }
    
    @State var isAnimating = false
    @ObservedObject var viewModel = ContentViewViewModel()
    private let animation = Animation.easeInOut(duration: Constants.animationDuration).repeatCount(6, autoreverses: false)
    
    var body: some View {
        VStack {
            Text(&quot;Hello, world!&quot;)
                
                .padding()
            Button(action: {
                animate()
            }) {
                Text(&quot;Button&quot;)
                    .foregroundColor(Color.white)
            }
        }
        .background(isAnimating ? Color.red : Color.blue)
        .onReceive(viewModel.$shouldAnimate, perform: { _ in
            if viewModel.shouldAnimate {
                withAnimation(self.animation, {
                    self.isAnimating.toggle()
                })
            }
        })
    }
    
    func animate() {
        self.viewModel.isNew = true
    }
}
</code></pre>
<p>And then my viewModel is:</p>
<pre><code>import Combine
import SwiftUI

class ContentViewViewModel: ObservableObject {
    @Published var shouldAnimate = false
    @Published var isNew = false
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        $isNew
            .sink { result in
                if result {
                    self.shouldAnimate = true
                }
            }
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>So the logic I am following is that when the button is tapped, we set 'isNew' to true. This in turn is a publisher which, when set to true, sets 'shouldAnimate' to true. In the ContentView, when shouldAnimate is received and is true, we toggle the background colour of the VStack x number of times.</p>
<p>The reason I am using this 'shouldAnimate' published property is because in the actual app, there are several different actions which may need to trigger the animation, and so it feels simpler to have this tied to one variable which we can listen for in the ContentView.</p>
<p>So in the code above, we should be toggling the isAnimating bool 6 times. So, we start with false then toggle as follows:</p>
<p>1: true, 2: false, 3: true, 4: false, 5: true, 6: false</p>
<p>So I would expect to end up on false and therefore have the background white. However, this is what I am getting:</p>
<p><a href=""https://i.stack.imgur.com/TKSZv.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TKSZv.gif"" alt=""enter image description here"" /></a></p>
<p>I tried changing the repeatCount (in case I was misunderstanding how the count works):</p>
<pre><code>private let animation = Animation.easeInOut(duration: Constants.animationDuration).repeatCount(7, autoreverses: false)
</code></pre>
<p>And I get the following:</p>
<p><a href=""https://i.stack.imgur.com/PW25Z.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/PW25Z.gif"" alt=""enter image description here"" /></a></p>
<p>No matter the count, I always end on true.</p>
<p>Update:</p>
<p>I have now managed to get the effect I am looking for by using the following loop:</p>
<pre><code>for i in 0...5 {
                    DispatchQueue.main.asyncAfter(deadline: .now() + Double(i), execute: {
                        withAnimation(self.animation, {
                            self.isAnimating.toggle()
                        })
                    })
                }
</code></pre>
<p>Not sure this is the best way to go though....</p>
","7188537","","7188537","","2021-11-08 22:55:45","2021-11-08 22:55:45","SwiftUI animation - toggled Boolean always ends up as true","<animation><swiftui><toggle><combine>","1","4","","","","CC BY-SA 4.0"
"69895122","1","69895565","","2021-11-09 08:45:26","","2","675","<p>If I have a Set of AnyCancellable:</p>
<pre><code>var observations: Set&lt;AnyCancellable&gt; = []
</code></pre>
<p>What's the difference between removing all the objects from the set:</p>
<pre><code>observations.removeAll()
</code></pre>
<p>or cancel each subscription:</p>
<pre><code>observations.forEach { $0.cancel() }
</code></pre>
<p>do they have the same effect? or in case that there is a strong reference in any of the subscription if <code>.removeAll()</code> is called the strong references will be not eliminated?
In case that they have the same effect I guess it will be a good practice to use the first approach as you don't need to traverse all the Set.</p>
","4102381","","","","","2021-11-09 09:21:15","Combine: Cancel a Set<AnyCancellable> or remove all its stored objects to stop the subscriptions","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"69905140","1","","","2021-11-09 21:10:01","","0","266","<p>I am currently creating a SwiftUI tvOS UI component that is meant to be autonomous (for possible reuse). We can think of it as a small module. The container view that will inject this component needs to know where the focus is within that component. (The container will change other UI elements based on this focus state).</p>
<p>I tried:</p>
<ul>
<li>adding the modifier <code>focusable</code> on the view that gets the focus</li>
</ul>
<pre><code>            .focusable(true, onFocusChange: { focused in
                if focused {
                    aClosure() // or a publisher?
                }
            })
</code></pre>
<p>but then the button style doesn't react to the focus state. (The style changes like this: <code>view.background(isFocused ? buttonStyle.backgroundColor.active : buttonStyle.backgroundColor.normal)</code>, which is hooked to <code>@Environment(\.isFocused) var isFocused</code>).</p>
<ul>
<li>That method, as you might point out, is deprecated starting tvOS 15, but the suggested alternatives don't fill my need. (You can point out I'm wrong about this, though!)</li>
<li>The .isFocused environment var (<code>@Environment(\.isFocused) var isFocused</code>) doesn't seem to change outside of a view modifier (which would make sense given its purpose, but I'm not 100% sure about this)
- I tried hooking up to the notifications of the focus, but that block will execute at each focus change for every view that registers to that notification. Also, because we're dealing with structs, managing identity comparisons is not trivial and I need an info from the view that gets the focus. Here's code:</li>
</ul>
<pre><code>        NotificationCenter.default.addObserver(forName: UIFocusSystem.didUpdateNotification,
                                               object: nil,
                                               queue: OperationQueue.main) { notification in
            
            if let context = notification.userInfo?[&quot;UIFocusUpdateContextKey&quot;] as? UIFocusUpdateContext {
                print(&quot;[Focus] context next item: \(context.nextFocusedItem)&quot;)
                someCompletionBlock()
            }
        }
</code></pre>
<ul>
<li>Focus state (<code>@FocusState</code>) is tvOS 15+ and I need tvOS 14 compatibility. Also, I tried to hook a <code>didSet</code> block to it but did not get executed. Is it normal?</li>
</ul>
<p>We thought the solution could be to create our own Property Wrapper but it's not even clear how to go about it. I guess it would need to listen to a focus property anyway?</p>
<p>Can a Combine Publisher &quot;listen&quot; to changes in focus, so that change can be propagated to the correct container? Something in the spirit of:</p>
<pre><code>    var onFocusPublisher: Publisher&lt;Bool, Never&gt; {
        $isFocused // where isFocused is the @Environment var
    }
</code></pre>
<p>Thank you for any feedback / suggestions / possible answers!</p>
<p>Note: I added <code>-UIFocusLoggingEnabled YES</code> to the passed arguments list of my scheme and I confirmed the view gets the focus as expected.</p>
","873436","","873436","","2021-11-09 21:17:16","2021-11-12 19:59:04","Is it possible to subscribe to a view's focus status from a viewModel?","<swiftui><tvos><combine>","1","2","1","","","CC BY-SA 4.0"
"69910951","1","69921995","","2021-11-10 09:43:25","","1","78","<p>It's not clear to me how you would combine the output of the following computed property, to the UI.</p>
<pre><code>var isComplete: Bool {
    Set([.givenName, .familyName]).isSubset(of: elements)
}
</code></pre>
<p>I essentially want the user interface to update if the above changes. How would I do this using Combine?</p>
<p>Reactive programming demands that I now think backwards and I'm having trouble thinking about model &lt;&lt;&lt; UI rather than model &gt;&gt;&gt; UI.</p>
<p>Here is the code in context.</p>
<pre><code>struct EditPersonView: View {
    
    let model: ViewModel
            
    private var captionView: some View {
        HStack {
        /*
          stuff
        */
            if submitted &amp;&amp; model.name.isComplete {
                Spacer()
                Text(&quot;select&quot;.localizedCapitalized) + Text(&quot; &quot;) + Text(&quot;save&quot;) + Text(&quot; &quot;) + Text(&quot;👆&quot;)
            }
        }
    }

    var body: some View {
    /*
    stuff - including captionView
    */
    }
}

extension EditPersonView {
    
    final class ViewModel {
        
        let name: PersonName
        
        init(person: Person) {
            self.name = PersonName(for: person)
        }
    }
}

extension EditPersonView.ViewModel {
    
    final class PersonName {
        
        let person: Person
        
        private let formatter = PersonNameComponentsFormatter()
        
        init(for person: Person) {
            self.person = person
        }
        
        var text: String {
            get { person.name ?? &quot;&quot; }
            set { person.name = newValue }
        }
        
        private var components: PersonNameComponents? {
            formatter.personNameComponents(from: text)
        }
        
        var givenName: String? {
            components?.givenName
        }
        
        var familyName: String? {
            components?.familyName
        }
        
        private func isValid(component: String?) -&gt; Bool {
            if let name = component, name.count &gt; 1 {
                return true
            }
            return false
        }
        
        var elements: Set&lt;Elements&gt; {
            var collection = Set&lt;Elements&gt;()
            if isValid(component: givenName) { collection.insert(.givenName) }
            if isValid(component: familyName) { collection.insert(.familyName) }
            return collection
        }
        
        var isComplete: Bool {
            Set([.givenName, .familyName]).isSubset(of: elements)
        }
    }
}

extension EditPersonView.ViewModel.PersonName {
    
    enum Elements {
        case givenName, familyName
    }
}
</code></pre>
","9400730","","","","","2021-11-11 00:51:28","How to re-render UI in response to computed property buried in a nested class?","<swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"69921644","1","69922582","","2021-11-10 23:59:34","","0","489","<p>According to the swift combine documentation, the proper way to connect a subscriber to a publisher is with the publishers <code>subscribe&lt;S&gt;(S)</code> protocol extension method.  Then the publisher creates a subscription and passes that subscription on to the subscriber.  All's well and good so far.</p>
<p>What I can't seem to figure out is how to gain access to that subscription and retain it in the calling code.  How is <code>sink()</code> implemented such that it can return that subscription?  Unless I'm mistaken, the subscription is responsible for retaining its subscriber, which means I can't store a reference to the subscription in the subscriber.  And since Subscription isn't class bound, it can't be weak.</p>
","1022456","","","","","2021-11-11 02:39:34","Store subscription from custom Combine subscriber?","<swift><subscription><combine>","2","1","","","","CC BY-SA 4.0"
"69926092","1","","","2021-11-11 09:39:56","","0","167","<p>While using <code>RxSwift</code> with tableView cells we all have to deal with <code>disposable</code> in <code>prepareForReuse</code> method.</p>
<p>Should we work with <code>Combine</code> subscriptions in the same way?</p>
<pre><code>override func prepareForReuse() {
        super.prepareForReuse()
        subscriptions.forEach { $0.cancel() }
    }
</code></pre>
","12504168","","","","","2021-11-11 09:39:56","How to deal with Swift Combine subscriptions in TableView Cells","<ios><swift><combine>","0","1","","","","CC BY-SA 4.0"
"69931486","1","69935963","","2021-11-11 16:10:21","","0","1685","<p><strong>Current (working) situation:</strong></p>
<p>In our app we have several publishers of type <code>PassthroughSubject&lt;Void, Never&gt;</code>.
The subscriber of this publisher send out the same type of publisher within the <code>.sink()</code> closure. In a simple playground it would look like that:</p>
<pre><code>//: A UIKit based Playground for presenting user interface

import UIKit
import PlaygroundSupport
import Combine

class MyViewController : UIViewController {

    // MARK: - Observables
    let initialPublisher: PassthroughSubject = PassthroughSubject&lt;Void, Never&gt;()
    let rePublisher = PassthroughSubject&lt;Void, Never&gt;()

    // MARK: - Observer
    private var cancellableSubscriber = Set&lt;AnyCancellable&gt;()

    override func loadView() {
        // MARK: - View Setup
        let view = UIView()
        let button = UIButton(type: .system)
        button.frame = CGRect(x: 100, y: 100, width: 200, height: 20)
        button.setTitle(&quot;Button&quot;, for: .normal)
        button.addTarget(self, action: #selector(buttonAction), for: .touchUpInside)
        view.addSubview(button)
        self.view = view

        // MARK: - Subscriptions

        // Event of initial publisher is received and re-published using another subject.
        initialPublisher
            .sink { [weak self] in
                self?.rePublisher.send()
            }
            .store(in: &amp;cancellableSubscriber)

        // The re-published event is received.
        rePublisher
            .sink {
                print(&quot;Received!&quot;)
            }
            .store(in: &amp;cancellableSubscriber)
    }

    @objc private func buttonAction() {
        self.initialPublisher.send()
    }
}
// Present the view controller in the Live View window
PlaygroundPage.current.liveView = MyViewController()
</code></pre>
<p><strong>Prefered (non-working) solution:</strong></p>
<p>Instead of subscribing and re publishing using the <code>.sink()</code> closure and another <code>PassthroughSubject</code> I wanted to re-publish the initial publisher using <code>.receive(subscriber: AnySubscriber)</code> However somehow it doesn't seem to work or maybe I'm understanding the <code>.receive</code> method wrong. I tried the following without luck.</p>
<p><strong>Question:</strong></p>
<p>How can I make the below code work, or is it even the correct way? If not, are there more elegant ways to re-publish than in our code above?</p>
<p><strong>Clarification:</strong></p>
<p>If something is unclear or of you need further examples please leave a comment below and I will try to update my question.</p>
<pre><code>class MyViewController : UIViewController {

    // MARK: - Observables
    let initialPublisher: PassthroughSubject = PassthroughSubject&lt;Void, Never&gt;()
    let rePublisher = PassthroughSubject&lt;Void, Never&gt;()
    var subscriber = AnySubscriber&lt;Void, Never&gt;()

    // MARK: - Observer
    private var cancellableSubscriber = Set&lt;AnyCancellable&gt;()

    override func loadView() {
        // MARK: - View Setup
        let view = UIView()
        let button = UIButton(type: .system)
        button.frame = CGRect(x: 100, y: 100, width: 200, height: 20)
        button.setTitle(&quot;Button&quot;, for: .normal)
        button.addTarget(self, action: #selector(buttonAction), for: .touchUpInside)
        view.addSubview(button)
        self.view = view

        // MARK: - Subscriptions

        //Republishing
        subscriber = AnySubscriber(initialPublisher)

        // Event of initial publisher is received and re-published.
        rePublisher.receive(subscriber: subscriber)

        // // The re-published event is received.
        rePublisher
            .sink {
                print(&quot;Received!&quot;) // &lt;-- does not work!
            }
            .store(in: &amp;cancellableSubscriber)
    }

    @objc private func buttonAction() {
        self.initialPublisher.send()
    }
}
</code></pre>
","12764795","","","","","2021-11-11 22:58:15","How to re-publish a PassthroughSubject using another publisher in Combine","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"69943029","1","69949223","","2021-11-12 12:33:40","","1","121","<p>I've been working with RxSwift for a while now, just switched to Combine and I am trying to wrap my head around this specific <code>.filter</code> behaviour. Here's a short playground example:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine

let publisher = [1, 2, 3, 4, 5]
    .publisher
    .share()

let filter1 = publisher
    .filter { $0 == 1 }
    .print(&quot;filter1&quot;)

let filter2 = publisher
    .filter { $0 == 2 }
    .print(&quot;filter2&quot;)

Publishers
    .Merge(filter1, filter2)
    .sink {
        print(&quot;Result is: \($0)&quot;)
    }
</code></pre>
<p>the output is</p>
<pre><code>filter1: receive subscription: (Multicast)
filter1: request unlimited
filter1: receive value: (1)
Result is: 1
filter1: receive finished
filter2: receive subscription: (Multicast)
filter2: request unlimited
filter2: receive finished
</code></pre>
<p>What surprises me is that <code>Result is: 2</code> is never called because the stream finishes. I could remove <code>.share()</code> operator which would result in receiving both values as I'd expect</p>
<pre><code>filter1: receive subscription: ([1])
filter1: request unlimited
filter1: receive value: (1)
Result is: 1
filter1: receive finished
filter2: receive subscription: ([2])
filter2: request unlimited
filter2: receive value: (2)
Result is: 2
filter2: receive finished
</code></pre>
<p>But what if my publisher is an API call and I don't want to create a duplicate network request? Which is exactly the case I am trying to handle now and it's also why I need to use <code>.share()</code> operator.</p>
<p>Any better explanation why is this happening and how to handle a case where you want to filter a stream, do a separate logic in each stream and then merge the results back together?</p>
","1092167","","","","","2021-11-12 21:24:57","Combine - merging multiple shared filters","<ios><asynchronous><rx-swift><combine>","1","0","","","","CC BY-SA 4.0"
"69961903","1","","","2021-11-14 09:49:41","","0","111","<p>I have an old callback API, which has a <code>newValue</code> callback handler emitting one value at a time, and a <code>completion</code> callback, containing an <code>Error</code> or nil, if success.</p>
<p>Unfortunately, calling <code>collecting</code> blocks until the API sent all values!</p>
<pre class=""lang-swift prettyprint-override""><code>func&lt;T&gt; collecting(newValue: @escaping (T) -&gt; Void, completion: @escaping (Error?) -&gt; Void) { ... }

func publisher&lt;T&gt;(_ type: T.Type) -&gt; AnyPublisher&lt;T, Error&gt; {
    let subject = PassthroughSubject&lt;T, Error&gt;()
        
    collecting(newValue: { value: T -&gt; Void in
        subject.send(value)
    } completionHandler: { error: Error? -&gt; Void in
        if let error = error {
            subject.send(completion: .failure(error))
        } else {
            subject.send(completion: .finished)
        }
    }
    return subject.eraseToAnyPublisher()
}
</code></pre>
<p>This code above does not work, because calling <code>collecting</code> blocks, and the return statement is only called with <code>finished</code>.</p>
<p>How can you implement such API in Combine?
I don't want to use any <code>DispatchQueue.async</code>, because scheduling should be handled by Combine.</p>
","6862985","","6862985","","2021-11-14 10:47:14","2021-11-19 21:47:16","Create publisher from blocking callback","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"69978018","1","69987492","","2021-11-15 16:51:15","","3","1349","<p>Let's say that we have a following code written in Swift that uses Combine:</p>
<pre><code>import UIKit
import Combine

class Test {
  @Published var array: [Int] = [] {
    willSet {
      print(&quot;willSet \(newValue.count)&quot;)
    }
    didSet {
      print(&quot;didSet \(array.count)&quot;)
    }
  }
}

var test = Test()
var subscriber = test.$array.sink { values in
  print(&quot;arrayCount: \(test.array.count) valuesCount: \(values.count)&quot;)
}

print(&quot;1 arrayCount \(test.array.count)&quot;)
test.array = [1, 2, 3]
print(&quot;2 arrayCount \(test.array.count)&quot;)
test.array = [1]
print(&quot;3 arrayCount \(test.array.count)&quot;)
</code></pre>
<p>This code prints following result on the console (it can be quickly tested in playground):</p>
<pre><code>arrayCount: 0 valuesCount: 0
1 arrayCount 0
willSet 3
arrayCount: 0 valuesCount: 3
didSet 3
2 arrayCount 3
willSet 1
arrayCount: 3 valuesCount: 1
didSet 1
3 arrayCount 1
</code></pre>
<p>As we can see the code given to sink method is executed after willSet and before didSet of given property. Now my question is: is there any way to create this publisher or subscribe to it in such way that the code given to sink is executed after didSet and not before it (so that arrayCount and valuesCount would be the same when print from sink is executed in above example)?</p>
","2102779","","","","","2022-09-03 12:06:09","Observe change on a @Published var in Swift Combine after didSet?","<ios><swift><combine>","3","1","","","","CC BY-SA 4.0"
"69982541","1","70090260","","2021-11-16 00:39:32","","0","1816","<p>I am getting an array from a Firestore table. Obviously is in real time so any newly added document or modifications to an existing document are reflected in the view. This works for simple properties like strings and numbers but I need to display and refresh other data too.</p>
<p>I'm storing the coordinates also and if the coordinates change I need to call <code>geocoder.reverseGeocodeLocation()</code> in order to get the Placemark out of this location and display the address as a string. For this I have created a service called <code>PlacemarkService (code provided below).</code></p>
<p>The issue is this. Whenever a model is modified the data comes through <code>PackagesViewModel</code> which has a <code>@Published var results = [Package]()</code> This is modified on the fly by Firestore (codable). Then, any changes caused to array this will cause the <code>List</code> inside <code>PackagesView</code> to be refreshed and this will cause a new instance of <code>PackageView(packageService: PackageService(package: package))</code> to be created and since the <code>PackageService</code> is passed as a param here a new instance of <code>PackageService</code> will be created. Finally this will trigger the init() inside this service to be called.</p>
<p><code>@Published var results = [Package]() -&gt; List -&gt; PackageView(packageService: PackageService(package: package)) -&gt; init()</code></p>
<p>So now if I follow this flow and I trigger <code>getPlacemarks()</code> inside init everything works (most of the time) and if the package model changes this function will be called on init and will reverseGeocodeLocation of the modified location. But there is a big problem here and here is why. I can not put this logic on init since I can not geocode hundreds of locations inside a for loop. I have multiple packages displayed on a list and MapKit won't allow this.</p>
<p>So obviously this logic needs to be triggered after the <code>PackageView</code> is shown, so when one of those packages is selected.</p>
<p>If I call <code>packageService.getPlacemarks()</code> when PackageView appears this works fine the first time but... onAppear won't be triggered when <code>@Published var results = [Package]()</code> is updated.</p>
<p>So finally the question is:</p>
<p><em><strong>Where to call <code>packageService.getPlacemarks()</code> so it gets called whenever a <code>Package</code> inside <code>@Published var results = [Package]</code> is updated</strong></em></p>
<p>but not on init of PlacemarkService for the reason I explained above.</p>
<p>Sorry for the long explanation, I am just trying to be clear.</p>
<pre><code>class PackageService: ObservableObject {
    var package: Package
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    @Published var sourcePlacemarkService = PlacemarkService()
    @Published var destinationPlacemarkService = PlacemarkService()
    
    var cancellable: AnyCancellable? = nil
    
    init(package: Package) {
        self.package = package
        startListening()
    }
    
    func startListening() {
        // Listen to placemark changes.
        cancellable = Publishers.CombineLatest(sourcePlacemarkService.$placemark, destinationPlacemarkService.$placemark).sink(receiveValue: {_ in
            
            // Publish changes manually to the view.
            self.objectWillChange.send()
        })
    }
    
    // Get placemarks from locations
    func getPlacemarks() {
        sourcePlacemarkService.reverseGeocodeLocation(location: package.source.toCLLocation)
        destinationPlacemarkService.reverseGeocodeLocation(location: package.destination.toCLLocation)
    }
}

class PackagesViewModel: ObservableObject {
    @Published var results = [Package]()
    
    func load() {
        query.addSnapshotListener { (querySnapshot, error) in 
            // updates results array when a document is modified.
        }
    }
}


struct PackagesView: View {
    @StateObject var packagessViewModel = PackagesViewModel()

    var body: some View {
        List(packagessViewModel.results, id: \.self) { package in
            NavigationLink(destination: PackageView(packageService: PackageService(package: package))) {
                Text(package.title)
            }
        }
    }
}

struct PackageView: View {
    @ObservedObject var packageService: PackageService

    func onAppear() {
        packageService.getPlacemarks()
    }
    
    var body: some View {
        // show the address from placemark after it is geocoded.
        VStack {
            Text(packageService.sourcePlacemarkService.placemark.title)
            Text(packageService.destinationPlacemarkService.placemark.title)
        }
        .onAppear(perform: onAppear)
    }
}

class PlacemarkService: ObservableObject {
    @Published var placemark: CLPlacemark?
    
    init(placemark: CLPlacemark? = nil) {
        self.placemark = placemark
    }
    
    func reverseGeocodeLocation(location: CLLocation?) {
        if let location = location {
            geocoder.reverseGeocodeLocation(location, completionHandler: { (placemark, error) in
                // some code here
                self.placemark = placemark
            })
        }
    }
}

struct Package: Identifiable, Codable {
    @DocumentID var id: String?
    var documentReference: DocumentReference
    
    var uid: String
    var title: String
    var description: String
    var source, destination: GeoPoint
    var amount: Double
    
    var createdAt: Timestamp = Timestamp()
    var paid: Bool = false
}
</code></pre>
","2738166","","2738166","","2021-11-16 00:51:07","2021-11-24 03:01:16","SwiftUI trigger function when model updates inside @Published property","<ios><swift><swiftui><swift5><combine>","2","1","","","","CC BY-SA 4.0"
"70003892","1","","","2021-11-17 11:50:46","","0","193","<p>I have an @Published field that dictates whether the user is currently in offline mode.</p>
<pre><code>class RequestStatus: ObservableObject {
    
    static var shared = RequestStatus()
    
    @Published var offlineModeActive: Bool = false
    
    private init() {}
    
}
</code></pre>
<p>Throughout my app, I use the Combine framework to subscribe to changes in this field and perform some work.</p>
<pre><code>import Combine

class ExampleClass {
        
     var offlineModeCancellable: AnyCancellable

     init() {

          self.offlineModeCancellable = RequestStatus.shared.$offlineModeActive.sink(receiveValue: { offlineModeActive in
                
               // Perform work
                
          })
     }
}
</code></pre>
<p>This works fine, however, when I run unit tests I do not want changes on this field to be published because I want to set up the environment of the test manually.</p>
<p>Therefore, I added in a field called <code>shouldPublishChanges</code> that defines whether changes should be published. If this is set to true, only then will I manually call the <code>objectWillChange.send()</code> method.</p>
<pre><code>class RequestStatus: ObservableObject {
    
    static var shared = RequestStatus()
    
    var shouldPublishChanges: Bool = false
    
    var offlineModeActive: Bool = false {
        willSet {
            if shouldPublishChanges {
                objectWillChange.send()
            }
        }
    }
    
    
    private init() {}
    
}
</code></pre>
<p>I then updated my Combine subscriber to subscribe to changes on the <code>RequestStatus.shared.objectwillChange</code> value meaning it should only receive a value when shouldPublishChanges is set to true (or so I thought).</p>
<pre><code>import Combine

class ExampleClass {
        
     var offlineModeCancellable: AnyCancellable

     init() {

          self.offlineModeCancellable = RequestStatus.shared.objectWillChange.sink(receiveValue: {
                
               // Perform work
                
          })
     }
}
</code></pre>
<p>However, even though <code>shouldPublishChanges</code> is set to <code>shouldPublishChanges</code>, if I change the <code>offlineModeActive</code> value, the value is published and the subscriber still receives the update and performs the work.</p>
<p>So, how do I conditionally publish changes to a Combine subscriber?</p>
<p>The only other idea I have is to have one field that stores the value and another field for the publisher. Then, only when I want to publish changes to this field will I update the published value.</p>
<pre><code>import Combine

class RequestStatus: ObservableObject {
    
    private init() {}
    
    static var shared = RequestStatus()
    
    var shouldPublishChanges: Bool = false
    
    private(set) var offlineModeActivePublisher = CurrentValueSubject&lt;Bool, Never&gt;(false)
    
    private(set) var offlineModeActive: Bool = false
    
    func updateOfflineModeActive(offlineModeActive: Bool) {
        
        self.offlineModeActive = offlineModeActive
        
        if shouldPublishChanges {
            offlineModeActivePublisher.value = offlineModeActive
        }
        
    }
    
}
</code></pre>
<p>However:</p>
<ol>
<li><p>Requires a lot of boiler-plate code for each field I want to do this for</p>
</li>
<li><p>I have two values that can be out of sync (this is less of a concern as <code>shouldPublishChanges</code> is set once and never changed)</p>
</li>
<li><p>I feel like there is a better way of achieving the same thing.</p>
</li>
</ol>
<p>Any ideas?</p>
","7775692","","","","","2021-11-17 11:50:46","Conditionally publish changes to a Combine subscriber?","<swift><combine>","0","3","","","","CC BY-SA 4.0"
"70018765","1","70019447","","2021-11-18 11:07:26","","1","170","<p>Consider the following code:</p>
<pre><code>class MyController: NSObject, ObservableObject {

    //...

    @Published var myRapidlyChangingVar: MyEnum? = nil

    //...

    func calledAtHighFrequencyByExternalEvents(value: MyEnum) {
        myRapidlyChangingVar = value
    }
}
</code></pre>
<p>The value of <code>myRapidlyChangingVar</code> needs to be set to <code>nil</code> if no calls to <code>calledAtHighFrequencyByExternalEvents()</code> have been made for 1 second.</p>
<p>What is the simplest and cleanest approach to adopt to achieve this?</p>
<p>Strikes me as the sort of thing which Reactive programming should make incredibly simple, but unsure where to start or what to search for.</p>
","233602","","","","","2021-11-20 16:40:44","Setting an @Published var to nil after no more events are received","<swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"70024619","1","","","2021-11-18 17:59:40","","0","172","<p>I had</p>
<pre><code>class PackageModel: ObservableObject {
let id = UUID()
@Published var name: String
@Published var rateLimit: CGFloat

init(name: String, rateLimit: CGFloat) {
    self.name = name
    self.rateLimit = rateLimit
}
</code></pre>
<p>}</p>
<p>and viewModel class which contains array of Packages</p>
<pre><code>   final class PackagesListViewModel: ObservableObject {

@Published var packages: [PackageModel] = []

private func startTimerForPackagesLiveUpdates() {
    self.packagesRateLimitUpdateTimer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true, block: { [weak self] _ in
        self?.packages.forEach({ package in
            let rateLimit = calculateRateLimit()
            package.rateLimit = CGFloat(rateLimit)
        })
    })
}
</code></pre>
<p>}</p>
<p>Timer updates every package rateLimit value with some calculated arbitrary value</p>
<p>From this ViewModel connected view i opened another view with one of the package instances</p>
<pre><code>class PackageInfoViewModel: ObservableObject {
@ObservedObject var package: PackageModel

package.$rateLimit.sink { (value) in
        debugPrint(value)
    }.store(in: &amp;bag)
</code></pre>
<p>}</p>
<p>In Sink closure I get updates not for package that is in this ViewModel but for all PackageModel class instances.</p>
<p>Im new with SwiftUI and Combine. I don't expect this behaviour. Will be thankful for explanation of how is this working, and how i should work around this problem?</p>
","7981687","","","","","2021-11-18 17:59:40","SwiftUI get sink notification on every update of class ModelObject @Published property","<swiftui><combine><observedobject>","0","3","","","","CC BY-SA 4.0"
"70033897","1","","","2021-11-19 11:09:59","","0","176","<p>I'm new in SwiftUI. I'm worked with UIKit and Combine framework building an architecture with ViewModel, UseCases and Repositories. All my architecture is based on the loading states. My loading states are build in this way:</p>
<pre><code>/// Equivalent to @Published with `LoadingState&lt;T, E&gt;` property wrapper
@propertyWrapper public class Loading&lt;T, E: Swift.Error&gt; {
public typealias State = LoadingState&lt;T, E&gt;

public var wrappedValue: State {
    willSet {
        subject.send(newValue)
    }
}

public init(wrappedValue: State) {
    self.wrappedValue = wrappedValue
}

private lazy var subject = CurrentValueSubject&lt;State, Never&gt;(wrappedValue)

public var projectedValue: AnyPublisher&lt;State, Never&gt; {
    return subject.eraseToAnyPublisher()
}
}
</code></pre>
<p>and my ViewModel works in this way:</p>
<pre><code>@Loading&lt;MyData, MyError&gt; var myDataLoadingState = .idle
public func getMyData(ID: String) {
    myDataLoadingState = .loading
    
    myDataUseCase.execute(ID: ID)
        .receive(on: DispatchQueue.main)
        .sink { completion in
            guard case .failure(let error) = completion else { return }
            myDataLoadingState = .failure(error)
        } receiveValue: { myData in
            self. myDataLoadingState = .success(myData)
        }
        .store(in: &amp;self.cancellables)
}
</code></pre>
<p>The controller works in this way:</p>
<pre><code>viewModel.$myDataLoadingState
       .sink { state in
           switch state {
           case .idle:
            break
           case .loading:
             self.showLoader()
           case .success(let myData):
            print(myData)
           case .failure(let error):
            self.print(error)
            self.hideLoader()
           }
       }
       .store(in: &amp;cancellables)
</code></pre>
<p>Can I use the loading state and my ViewModel in SwiftUI? I tried in this way but seems not works:</p>
<pre><code>struct ContentView: View {
@StateObject var viewModel: MyViewModel

var body: some View {
    switch viewModel.loadingState {
    case .idle:
        Text(&quot;Idle&quot;)
    case .loading:
        Text(&quot;Loading&quot;)
    case .success(let myData):
        Text(myData.name)
    case .failure(let error):
        Text(error.localizedDescription)
    }
}
}
</code></pre>
<p>The ViewModel now is an <code>ObservableObject</code></p>
<pre><code>public class MyViewModel: ObservableObject {

}
</code></pre>
<p>Thanks in advance</p>
","6761616","","","","","2021-11-19 11:52:48","SwiftUI CurrentValueSubject Behavior","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"70034331","1","70034718","","2021-11-19 11:44:36","","0","262","<p>I am following Stanford's CS193p Developing Apps for iOS online course.
I'm trying to do the <a href=""https://cs193p.sites.stanford.edu/sites/g/files/sbiybj16636/files/media/file/assignment_6.pdf"" rel=""nofollow noreferrer"">Assignment 6 (Memorize Themes.pdf)</a>.</p>
<p>When I run my app in simulator and in edit mode tap on a list row to bring up the sheet, I get the following fatal error:
Thread 1: Fatal error: Unexpectedly found nil while unwrapping an Optional value</p>
<p><strong>Question: Why the index matching</strong> <code>themeToEdit</code> <strong>inside themes array is nil?</strong></p>
<p>Please help me.</p>
<pre><code>import SwiftUI

// Required Task 3: Your Memorize application should now show a “theme chooser” UI when it launches.

struct ThemeChooserView: View {
    @EnvironmentObject var themeStore: ThemeStore
    
    @State private var editMode: EditMode = .inactive
        
    var body: some View {
        NavigationView {
            List {
                ForEach(themeStore.themes) { theme in
                    NavigationLink(destination: EmojiMemoryGameView(game: EmojiMemoryGame(theme: theme))) {
                        VStack(alignment: .leading) {
                            Text(theme.name)
                                .foregroundColor(theme.color)
                                .font(.title)
                            Text(themeCardsDescription(theme: theme))
                        }
                        .gesture(editMode == .active ? tapGesture(theme: theme) : nil)
                    }
                }
                .onDelete { indexSet in
                    themeStore.themes.remove(atOffsets: indexSet)
                }
                .onMove { indexSet, newOffset in
                    themeStore.themes.move(fromOffsets: indexSet, toOffset: newOffset)
                }
            }
            .sheet(isPresented: $isEditing) {
                let currentThemeIndex = themeStore.themes.firstIndex(where: {$0.id == themeToEdit?.id})
                ThemeEditor(theme: $themeStore.themes[currentThemeIndex!]) // ERROR: - 🛑 Thread 1: Fatal error: Unexpectedly found nil while unwrapping an Optional value
            }
            .navigationTitle(&quot;Memorize&quot;)
            .toolbar {
                ToolbarItemGroup(placement: .navigationBarLeading) {
                    plusButton
                }
                ToolbarItemGroup {
                    EditButton()
                }
            }
            .environment(\.editMode, $editMode)
        }
    }
    
    @State private var isEditing: Bool = false
    
    @State private var themeToEdit: Theme?

    private func tapGesture(theme: Theme) -&gt; some Gesture {
        TapGesture().onEnded { _ in
            themeToEdit = theme
            isEditing = true
        }
    }
    
    private func themeCardsDescription(theme: Theme) -&gt; String {
        let numberOrAll = theme.numberOfPairsOfCards == theme.emojis.count ? &quot;All&quot; : &quot;\(theme.numberOfPairsOfCards)&quot;
        return numberOrAll + &quot; pairs from \(theme.emojis.joined(separator: &quot;&quot;))&quot;
    }
    
    private var plusButton: some View {
        Button {
            let theme = Theme(name: &quot;New Theme&quot;, emojis: [&quot;🐵&quot;, &quot;🐿&quot;], numberOfPairsOfCards: 2, color: .black)
            themeStore.themes.append(theme)
        } label: {
            Image(systemName: &quot;plus&quot;)
        }
    }
}
</code></pre>
","14119170","","8160613","","2021-11-19 12:27:06","2021-11-19 12:30:12","SwiftUI: Unexpectedly found nil while unwrapping an Optional value","<swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"70063022","1","","","2021-11-22 08:44:36","","0","311","<p>I have a flow where I should get posts from web, and save them on user defaults as test, if there is some issue, load the list from users default instead from web. now I have two emitters, I think I should perform a check in my repository, something like if gateposts emits error, put to the error decide to show local cached posts. How to catch the error? they told me I could use combine latest or mergeMany but Im totally new and have no idea how to perform this check</p>
<p>I have this hint, but is not working</p>
<pre><code>dataSource.getPosts().catch {sharedPreferenceDataSource.getLocalPosts()}
</code></pre>
<p>this seems to work, but still not getting with error or using combine latest</p>
<pre><code>return dataSource.getPosts().catch { error in
    return self.sharedPreferenceDataSource.getLocalPosts()
}.eraseToAnyPublisher()
</code></pre>
<p>my func</p>
<pre><code> func getPosts() -&gt; AnyPublisher&lt;[Post], Error&gt; {
        
        //posts from web
        dataSource.getPosts() //emits AnyPublisher&lt;[Post], Error&gt;
        //posts on usersDeafault
        sharedPreferenceDataSource.getLocalPosts() //emits AnyPublisher&lt;[Post], Error&gt;
        
        //here someone told me I should perform a catch,I get something likeMyEnumeError.networkError, then I should emit local posts
        
        //my latest attempt
        return Publishers.CombineLatest(dataSource.getPosts(), sharedPreferenceDataSource.getLocalPosts())

//        but I think I could do something like
//        perform a catch on the error from network, in that case perform a catch and send local data
//        Publishers.MergeMany([dataSource.getPosts(),dataSource.getLocalPosts(defaults: defaults, key: UserDefaultKeys.allPost.rawValue)])
}
</code></pre>
<p>my call</p>
<pre><code>enum NetworkError: Error {
    case genericError(code: Int)
    case invalidResponseCode
    case decodingFailure(reason: String)
}

func getPosts() -&gt; AnyPublisher&lt;[Post], Error&gt; {


let session = URLSession.shared
let url = URL(string: &quot;https://jsonplaceholder.typicode.com/posts&quot;)!


return Future&lt;[Post], Error&gt;() { promise in
    
    //***********************************************
    let task = session.dataTask(with: url, completionHandler: { data, response, error in
        
        if error != nil {
            print(error ?? &quot;N/D&quot;)
            promise(Result.failure(NetworkError.invalidResponseCode))
            return
        }
        
        
        guard let response = response as? HTTPURLResponse, response.statusCode == 200 else {
            promise(Result.failure(NetworkError.invalidResponseCode))
            return
        }
        
        do {
            let posts = try JSONDecoder().decode([Post].self, from: data! )
            promise(Result.success(posts))
            //saving on local disk
            self.saveLocalPosts(defaults: self.defaults, data: AllPosts(Posts: posts))
        } catch {
            print(&quot;Error during JSON serialization: \(error.localizedDescription)&quot;)
            promise(Result.failure(NetworkError.decodingFailure(reason: error.localizedDescription)))
                
        }
        
    })
    task.resume()
    //***********************************************

}
//            .receive(on: DispatchQueue.main)
//            .subscribe(on: DispatchQueue.init(label: &quot;test&quot;, qos: .default))
//            .map { value -&gt; [Post] in
//                let c = value
//                return []
//            }
.eraseToAnyPublisher()


 
}
</code></pre>
","4846391","","4846391","","2021-11-22 09:30:53","2021-11-22 09:48:51","in Swift Combine how to use combine latest or catch to check error?","<swift><combine><combinelatest>","1","4","","","","CC BY-SA 4.0"
"70063678","1","","","2021-11-22 09:42:15","","1","25","<p>I am trying to understand the Combine Empty publisher and his impact on a subscriber. I have created a publisher which produces a stream of two values followed by <code>.append(Empty(completeImmediately: false))</code> and <code>replaceEmpty(with: 3)</code>. I don't understand why a value from <code>replaceEmpty</code> is not present in a sink receiveValue closure. I tried to set <code>true</code> to <code>completeImmediately</code> but it doesn't send a value from <code>replaceEmpty</code>. My question is: Why <code>replaceEmpty</code> is not called ?</p>
<pre><code>[1,2].publisher
    .append(Empty(completeImmediately: false))
    .replaceEmpty(with: 3)
    .sink { completion in
        print(completion)
    } receiveValue: { value in
        print(value)
    }
</code></pre>
","1180728","","","","","2021-11-22 09:42:15","replaceEmpty not called","<ios><combine>","0","0","","","","CC BY-SA 4.0"
"70071858","1","","","2021-11-22 20:13:50","","-1","220","<p>Currently, I am using this <code>Combine</code> code to fetch data from an API:</p>
<pre><code>        URLSession.shared.dataTaskPublisher(for: url)
            // fetch on background thread
            .subscribe(on: DispatchQueue.global(qos: .background))
            // receive response on main thread
            .receive(on: DispatchQueue.main)
            // ensure there is data
            .tryMap { (data, response) in
                guard
                    let httpResponse = response as? HTTPURLResponse,
                    httpResponse.statusCode == 200 else {
                    throw URLError(.badServerResponse)
                }
                NetworkTimer.shared.stop()
                return data
            }
            // decode JSON data to WeatherAPIDecoder
            .decode(type: WeatherAPIDecoder.self, decoder: JSONDecoder())
            // Handle results
            .sink { (result) in
                // will return success or failure
                //                NSLog(&quot;completion: \(result)&quot;)
            } receiveValue: { [self] (weatherAPI) in
                // if success, will return wsWeather
                // here you can update your view
                //                NSLog(&quot;value: \(wsWeather)&quot;)
                processWeatherData(weatherAPI)
            }
            // After receiving response, the URLSession is no longer needed &amp; we can cancel the publisher
            .cancel()
</code></pre>
<p>This works fine, but now I need to make two network requests, one for current data and one for historical data. I would then like to await the results of these two requests and put them together into one struct, and I can't wrap my head around how to change the <code>URLSession.shared.dataTaskPublisher</code> to return just the decoded data. I intend to call the <code>dataTaskPublisher</code> from another function with an Async Await and then create one object from the data and pass it on. Any assistance would be appreciated. This has to be for iOS 14+.</p>
<p>Edit:</p>
<p>I don't have the code together yet, my idea is something along these lines:</p>
<p>func update() {
async let (current, _) = URLSession.shared.dataTaskPublisher(for: currentURL)
async let (historical, _) = URLSession.shared.dataTaskPublisher(for: historicalURL)</p>
<p>guard let combinedData = CombinedData(current: current, historical: historical) else { throw error }
...
}</p>
","7129318","","7129318","","2021-11-22 21:50:51","2021-11-22 21:50:51","Combine: Outputting Decoded Data from URLSession.shared.dataTaskPublisher","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"70077441","1","","","2021-11-23 08:17:02","","-1","64","<p>I've just spent far too long trying to fix a release build because of a segmentation fault 11.</p>
<p>In the end the code change was from this...</p>
<pre><code>fetchValue
    .receive(on: scheduler)
    .store(in: &amp;subscriptions)
    .sink { [weak self] completion in
        switch completion {
        case .failure(let error):
            self?.state = .error(error.localizedDescription)
        case .finished:
            return
        }
    } receiveValue: { [weak self] value in
        self?.state = .someValue(value)
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>to this...</p>
<pre><code>fetchValue
    .map(State.someValue)
    .catch { error in Just(State.error(error.localizedDescription)) }
    .receive(on: scheduler)
    .assign(to: \.state, on: self)
    .store(in: &amp;subscriptions)
</code></pre>
<p>And specifically it was the <code>catch</code> line that was causing the issue.</p>
<p>In the above <code>fetchValue</code> is defined as a <code>Future&lt;SomeValue, Error&gt;</code>.</p>
<p>And <code>self.state</code> is defined as an enum like...</p>
<pre><code>enum State {
  case someValue(SomeValue)
  case error(String)
}
</code></pre>
<p>It built for debug and testing with no issues at all.</p>
<p>But when building for release (archiving) with Xcode 13.0 and 13.1 it caused a segmentation fault 11 and I just have no idea why?</p>
","421018","","421018","","2021-11-23 08:23:08","2021-11-24 12:09:20","Why would using Combine's `catch` cause a segmentation fault?","<swift><segmentation-fault><combine>","1","0","","","","CC BY-SA 4.0"
"70078154","1","","","2021-11-23 09:15:01","","1","39","<p>I fetch a data from RestAPI and after receiving a value I have to send another network request which has an important delay and has no impact on first fetch. I would like to use <code>handleEvents</code> publisher operator but this one is in Apple documentation in Debugging section. If I use <code>flatMap</code> then my sink will wait a result of second fetch but it has no impact on my main stream. Is there any other way to start a network call which has no impact on main stream/pipeline ?</p>
<p>Example 1: This one looks fine but <code>handleEvents</code> is in Debugging section of Apple documentation</p>
<p><a href=""https://i.stack.imgur.com/WJpaQ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WJpaQ.png"" alt=""enter image description here"" /></a></p>
<pre><code>    cancellable = URLSession.shared.dataTaskPublisher(for: .init(string: &quot;http://httpbin.org/delay/1&quot;)!)
        .handleEvents(receiveOutput: { _ in
             cancellable2 = URLSession.shared.dataTaskPublisher(for: .init(string: &quot;http://httpbin.org/delay/10&quot;)!)
                .sink(receiveCompletion: { completion in
                    print(completion)
                }, receiveValue: { value in
                    print(value)
                })
        }
        .sink { completion in
            print(completion)
        } receiveValue: { value in
            print(value)
        }
</code></pre>
<hr />
<p>Example 2: this one makes my main stream to wait of result of second resumed from <code>flatMap</code> which makes my stream to wait for finished signal</p>
<pre><code>    cancellable = URLSession.shared.dataTaskPublisher(for: .init(string: &quot;http://httpbin.org/delay/1&quot;)!)
        .flatMap { _ in
            URLSession.shared.dataTaskPublisher(for: .init(string: &quot;http://httpbin.org/delay/10&quot;)!)
        }
        .sink { completion in
            print(completion)
        } receiveValue: { value in
            print(value)
        }
</code></pre>
","1180728","","","","","2021-11-26 06:24:30","Side effect network request","<ios><combine>","1","1","","","","CC BY-SA 4.0"
"70088401","1","","","2021-11-23 22:03:33","","2","751","<p>I have a view created through a ForEach loop which needs to take a variable count within the ForEach itself i.e. I need the app to react to a dynamic count and change the UI accoridngly.</p>
<p>Here is the view I am trying to modify:</p>
<pre><code>struct AnimatedTabSelector: View {
    let buttonDimensions: CGFloat
    @ObservedObject var tabBarViewModel: TabBarViewModel
    
    var body: some View {
        HStack {
            Spacer().frame(maxWidth: .infinity).frame(height: 20)
                .background(Color.red)
            
            ForEach(1..&lt;tabBarViewModel.activeFormIndex + 1) { _ in
                Spacer().frame(maxWidth: buttonDimensions).frame(height: 20)
                    .background(Color.blue)
                Spacer().frame(maxWidth: .infinity).frame(height: 20)
                    .background(Color.green)
            }
            
            Circle().frame(
                width: buttonDimensions,
                height: buttonDimensions)
                .foregroundColor(
                    tabBarViewModel.activeForm.loginFormViewModel.colorScheme
                )
            
            ForEach(1..&lt;tabBarViewModel.loginForms.count - tabBarViewModel.activeFormIndex) { _ in
                Spacer().frame(maxWidth: .infinity).frame(height: 20)
                    .background(Color.red)
                Spacer().frame(maxWidth: buttonDimensions).frame(height: 20)
                    .background(Color.blue)
            }
            
            Spacer().frame(maxWidth: .infinity).frame(height: 20)
                .background(Color.gray)
        }
    }
}
</code></pre>
<p>And the viewModel I am observing:</p>
<pre><code>class TabBarViewModel: ObservableObject, TabBarCompatible {
    var loginForms: [LoginForm]
    @Published var activeForm: LoginForm
    @Published var activeFormIndex = 0
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init(loginForms: [LoginForm]) {
        self.loginForms = loginForms
        self.activeForm = loginForms[0] /// First form is always active to begin
        setUpPublisher()
    }
    
    func setUpPublisher() {
        for i in 0..&lt;loginForms.count {
            loginForms[i].loginFormViewModel.$isActive.sink { isActive in
                if isActive {
                    self.activeForm = self.loginForms[i]
                    self.activeFormIndex = i
                }
            }
            .store(in: &amp;cancellables)
        }
    }
}
</code></pre>
<p>And finally the loginFormViewModel:</p>
<pre><code>class LoginFormViewModel: ObservableObject {
    @Published var isActive: Bool
    
    let name: String
    let icon: Image
    let colorScheme: Color
    
    init(isActive: Bool = false, name: String, icon: Image, colorScheme: Color) {
        self.isActive = isActive
        self.name = name
        self.icon = icon
        self.colorScheme = colorScheme
    }
}
</code></pre>
<p>Basically, a button on the login form itself sets its viewModel's isActive property to true. We listen for this in TabBarViewModel and set the activeFormIndex accordingly. This index is then used in the ForEach loop. Essentially, depending on the index selected, I need to generate more or less spacers in the AnimatedTabSelector view.</p>
<p>However, whilst the activeIndex variable is being correctly updated, the ForEach does not seem to react.</p>
<p>Update:</p>
<p>The AnimatedTabSelector is declared as part of this overall view:</p>
<pre><code>struct TabIconsView: View {
    
    struct Constants {
        static let buttonDimensions: CGFloat = 50
        static let buttonIconSize: CGFloat = 25
        static let activeButtonColot = Color.white
        static let disabledButtonColor = Color.init(white: 0.8)
        
        struct Animation {
            static let stiffness: CGFloat = 330
            static let damping: CGFloat = 22
            static let velocity: CGFloat = 7
        }
    }
    
    @ObservedObject var tabBarViewModel: TabBarViewModel
    
    var body: some View {
        ZStack {
            AnimatedTabSelector(
                buttonDimensions: Constants.buttonDimensions,
                tabBarViewModel: tabBarViewModel)
            
            HStack {
                Spacer()
                
                ForEach(tabBarViewModel.loginForms) { loginForm in
                    Button(action: {
                        loginForm.loginFormViewModel.isActive = true
                    }) {
                        loginForm.loginFormViewModel.icon
                            .font(.system(size: Constants.buttonIconSize))
                            .foregroundColor(
                                tabBarViewModel.activeForm.id == loginForm.id ? Constants.activeButtonColot : Constants.disabledButtonColor
                            )
                    }
                    .frame(width: Constants.buttonDimensions, height: Constants.buttonDimensions)
                    Spacer()
                }
            }
        }
        .animation(Animation.interpolatingSpring(
            stiffness: Constants.Animation.stiffness,
            damping: Constants.Animation.damping,
            initialVelocity: Constants.Animation.velocity)
        )
    }
}
</code></pre>
<p>UPDATE:</p>
<p>I tried another way by adding another published to the AnimatedTabSelector itself to check that values are indeed being updated accordingly. So at the end of the HStack in this view I added:</p>
<pre><code>.onAppear {
            tabBarViewModel.$activeFormIndex.sink { index in
                self.preCircleSpacers = index + 1
                self.postCircleSpacers = tabBarViewModel.loginForms.count - index
            }
            .store(in: &amp;cancellables)
        }
</code></pre>
<p>And of course I added the following variables to this view:</p>
<pre><code>@State var preCircleSpacers = 1
@State var postCircleSpacers = 6
@State var cancellables = Set&lt;AnyCancellable&gt;()
</code></pre>
<p>Then in the ForEach loops I changed to:</p>
<pre><code>ForEach(1..&lt;preCircleSpacers)
</code></pre>
<p>and</p>
<pre><code>ForEach(1..&lt;postCircleSpacers)
</code></pre>
<p>respectively.</p>
<p>I added a break point in the new publisher declaration and it is indeed being updated with the expected figures. But the view is still failing to reflect the change in values</p>
","7188537","","7188537","","2021-11-23 23:25:54","2021-11-23 23:51:48","SwiftUI - using variable count within ForEach","<swift><swiftui><combine>","1","7","1","","","CC BY-SA 4.0"
"70088508","1","","","2021-11-23 22:14:45","","1","287","<p>I have a lot (~200) urls for images, and I need to download each one, then process (resize) it, then update the cache. The thing is - I only want to have at max 3 requests at once, and since the images are heavy, I also don't want a lot of responses &quot;hanging&quot; waiting to be processed (and taking memory...).</p>
<p>TLDR I want to call the next (4th) network request only after the <code>receiveValue</code> in the <code>sink</code> is called on one of the first 3 requests... (ie after the network response &amp; processing are both done...).</p>
<p>Will this flow work, and will it hold on to the waiting urls and not drop them on the floor?</p>
<p>Also do I need that <code>buffer()</code> call? I use it after seeing this answer: <a href=""https://stackoverflow.com/a/67011837/2242359"">https://stackoverflow.com/a/67011837/2242359</a></p>
<pre class=""lang-swift prettyprint-override""><code>wayTooManyURLsToHandleAtOnce // this is a `[URL]`
    .publisher
    .buffer(size: .max, prefetch: .byRequest, whenFull: .dropNewest) // NEEDED?
    .flatMap(maxPublishers: .max(3)) { url in
       URLSession.shared
           .dataTaskPublisher(for: url)
           .map { (data: Data, _) -&gt; Picture in
               Picture(from: data)
           }
    }
    .tryCompactMap {
        resizeImage(picture: $0) // takes a while and might fail
    }
    .receive(on: DispatchQueue.main)
    .sink { completion
        // handling completion... 
    } receiveValue: { resizedImage
        self.cache.append(resizedImage)
    }
    .store(...)
</code></pre>
","2242359","","","","","2021-11-24 11:30:11","How to limit concurrent live URLSessions with Combine?","<swift><combine><urlsession>","1","5","1","","","CC BY-SA 4.0"
"70101933","1","","","2021-11-24 19:33:09","","2","225","<p>I want to create a sort of queue where I can append work-items which can fail and retry or just succeed and are removed from the queue.</p>
<p>Basically what I am looking for a <code>SomeQueue</code> which should kind of work like:</p>
<pre class=""lang-swift prettyprint-override""><code>let Task = (Data)-&gt;Result
    
let queue = SomeQueue(from: [task1, task2])
    .execute()
    .retry(3)
    .onFailure { failcount++ }
    
// Some other piece of code that kind of needs to work
Button(action: {
    queue.appendWorkItems([Task]())
})

Text(queue.remaining) // way to show unfinished items
</code></pre>
<p>I looked into OperationQueue, that kind of looked like it could work. I want it to be as modern and up to date swift as possible and I like the combine publish-subscribe stuff (it has to integrate with swiftUI). This looked like that was a better approach.</p>
<p>Do you have hints / ideas on how I could make this work?</p>
","3696798","","","","","2021-11-24 19:33:09","Structuring multiple upload tasks using combine","<swift><combine>","0","3","0","","","CC BY-SA 4.0"
"70106876","1","70107274","","2021-11-25 06:48:46","","1","390","<p>I have written a couple of view models for my SwiftUI project. It turns out that they share quite a lot of properties and code and I wanted to pull this code into a generic view model and then user class inheritance to specialize the real view models. Unfortunately this turns out quite difficult. Here's a simplified example:</p>
<pre><code>class viewModelA: ObservableObject {
    enum Animal {
        case cat
        case dog
    }

    @published var selected: Animal?

    func select(_ animal: Animal?) {
        self.selected = animal
    }
    ...
}

class viewModelB: ObservableObject {
    enum Animal {
        case lion
        case tiger
    }

    @published var selected: Animal?

    func select(_ animal: Animal?) {
        self.selected = animal
    }
    ...
}
</code></pre>
<p>The first thing I've tried is to create a protocol and use a protocol with an associatedtype for Animal, but then I struggled with the property that has @published. Swift doesn't allow to have property wrappers in protocols...</p>
<p>How could I generalize those 2 classes?</p>
","10826194","","10826194","","2021-11-25 07:41:08","2021-11-25 07:41:08","Generalizing multiple view models","<swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"70118808","1","70119000","","2021-11-26 01:42:01","","0","58","<p>I'm trying to parse stock data from the website alphavantage.com using the combine frame work. I keep getting this <code>error Swift.DecodingError.Context(codingPath: [], debugDescription: &quot;No value associated with key CodingKeys(stringValue: \&quot;bestMatches\&quot;, intValue: nil) (\&quot;bestMatches\&quot;).&quot;, underlyingError: nil))</code> despite my data model having the correct values to match during with the json. How do I fix this ?</p>
<pre><code>struct SearchResults: Decodable{
    let bestMatches : [SearchResult]
    
    enum CodingKeys: String, CodingKey{
        case bestMatches =  &quot;bestMatches&quot;
    }
}

struct SearchResult : Decodable{
    let symbol : String?
    let name : String?
    let type : String?
    let currency :String?
    
    enum CodingKeys:String, CodingKey{
       case symbol = &quot;1. symbol&quot;
       case  name = &quot;2. name&quot;
       case type = &quot;3. type&quot;
       case currency = &quot;8. currency&quot;
    }
}

struct APIservice{
    let apiKey = &quot;U893NJLDIREGERHB&quot;
    
    func fetchSymbols(keyword:String)-&gt; AnyPublisher&lt;SearchResults,Error&gt;{
        let urlSTring = &quot;https://www.alphavantage.co/query?function=\(keyword)H&amp;keywords=tesco&amp;apikey=U893NJLDIREGERHB&quot;
        let url = URL(string: urlSTring)!
        return URLSession.shared.dataTaskPublisher(for: url)
            .map({$0.data})
            .decode(type: SearchResults.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
    }
}

   func performSearch(){
        apiSerivice.fetchSymbols(keyword: &quot;S&amp;P500&quot;).sink { (completion) in
            switch completion {
            case .failure(let error):
                print(error)
            case . finished:
                break
            }
        } receiveValue: { (SearchResults) in
            print(SearchResults.bestMatches)
        }.store(in: &amp;subcribers)
</code></pre>
","16693060","","","","","2021-11-26 21:54:25","How do I fix the error described during json parsing using combine?","<json><swift><combine>","1","3","","","","CC BY-SA 4.0"
"70122824","1","70123056","","2021-11-26 10:19:14","","0","98","<p>I'm playing with Combine to learn it and improve my reactive programming skills, and I'm trying to create some generic class that convert data to my <em>T</em> type</p>
<p>I have this error, and I don't understand why</p>
<blockquote>
<p><em>Key path value type '[T]' cannot be converted to contextual type 'T'</em></p>
</blockquote>
<pre><code>class Fetcher&lt;T: Codable&gt;: ObservableObject {
    private var task: AnyCancellable?
    @Published var result = [T]()

    init&lt;T: Codable&gt; (type: T.Type) {
    guard let url = URL(string: &quot;https://api.example.com&quot;) else { return }
    task = URLSession.shared.dataTaskPublisher(for: url)
        .map{$0.data}
        .decode(type: T.self, decoder: JSONDecoder())
        .receive(on: DispatchQueue.global(qos: .background))
        .replaceError(with: T.self as! T)
        .assign(to: \.result, on: self)
    }
}
</code></pre>
<p><a href=""https://i.stack.imgur.com/lKv1M.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lKv1M.png"" alt=""enter image description here"" /></a></p>
","11734662","","12299030","","2021-11-26 10:44:55","2021-11-26 10:47:23","Generic Func: Key path value type '[T]' cannot be converted","<swift><combine>","1","7","","","","CC BY-SA 4.0"
"70128744","1","70129071","","2021-11-26 18:35:34","","2","935","<p>When hitting the button, a player is added to the game and I want to observe the changes in the game through the view model. When I hit the button, the counter doesn't change.</p>
<p>It's almost as if I need the game within the <code>ContentViewModel</code> to be both <code>@ObservedObject</code> and <code>@Published</code>.</p>
<p>Can someone help me understand the fundamentals of why this is setup wrong and how I can fix it?</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

class Game: ObservableObject {
    @Published var players: [String] = []

    func addPlayer(_ player: String) {
        players.append(player)
    }
}

class ContentViewModel: ObservableObject {
    @Published var game: Game {
        didSet {
            subscription = game.objectWillChange.sink { [weak self] _ in
                self?.objectWillChange.send()
            }
        }
    }
    var subscription: AnyCancellable?

    init(game: Game) {
        self.game = game
    }
}

struct ContentView: View {
    @ObservedObject var viewModel: ContentViewModel

    var body: some View {
        Text(&quot;Num players: \(viewModel.game.players.count)&quot;)
            .padding()

        Button(&quot;Add player&quot;) {
            viewModel.game.addPlayer(&quot;player&quot;)
        }
    }
}
</code></pre>
","174507","","","","","2021-11-26 19:11:38","SwiftUI observe published object of published object","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"70140208","1","","","2021-11-28 02:26:24","","0","34","<p>I have two dataframes:
df1 has columns - id, Text, imageid, label
df2 has columns - imageid, imageurl</p>
<p>I want to combine both the dataframes such that the imageurl should be linked to their corresponding imageid in df1.</p>
<p>Can someone guide me how to do this?</p>
","15501476","","","","","2021-11-28 02:47:34","Combine two dataframes","<dataframe><combine>","1","0","","2021-11-28 02:47:17","","CC BY-SA 4.0"
"70145402","1","","","2021-11-28 16:31:52","","0","102","<p>I'm trying to call a publisher every second for a specified time interval. I'm not sure how to do it. I show you my code:</p>
<pre class=""lang-swift prettyprint-override""><code>
func readValue(_ peripheral: CombineCoreBluetooth.Peripheral,
 characteristic: CBCharacteristic,
 service: CBService,
 timeout: Int = 1) -&gt; AnyPublisher&lt;BluetoothActionResult, BluetoothError&gt; {
    
    print(&quot;BluetoothManager | readValue&quot;)
    
    return Timer.publish(every: 1, tolerance: nil, on: .main, in: .common)
        .autoconnect()
        .mapError({ error in
            return BluetoothError.readFailed
        })
        .map { output in
            return peripheral.readValue(forCharacteristic: characteristic.uuid, inService: service.uuid)
                .mapError { error in
                    return BluetoothError.readFailed
                }
                .map { data -&gt; BluetoothActionResult in
                    if let data = data {
                        return BluetoothActionResult.create(readValue: data)
                    } else {
                        return BluetoothActionResult.create()
                    }
                }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>This is not compiling, as I get <code>Cannot convert value of type 'Publishers.Map&lt;Publishers.MapError&lt;AnyPublisher&lt;Data?, Error&gt;, BluetoothError&gt;, BluetoothActionResult&gt;' to closure result type 'BluetoothActionResult'</code> at the level of the last <code>map</code>.</p>
<p>What I need to achieve is to create a stream that emits value every 1 second, for <code>timeout</code> seconds and then stops.</p>
","588967","","","","","2021-11-28 16:31:52","Call publisher every second for a specific time interval","<swift><timer><combine>","0","1","","","","CC BY-SA 4.0"
"70146538","1","","","2021-11-28 19:00:35","","2","332","<p>I have a singleton that's in charge of handling user parameter changes for logic operations across my app. The parameters are divided into two types, &quot;influencing&quot; and &quot;steering&quot;, and each is represented by a <code>CurrentValueSubject</code>.</p>
<p>In my central controller class I use <code>CombineLatest</code> to update all my parameters whenever either type of parameter changes. From the controller's <code>init()</code>:</p>
<pre><code>Publishers
    .CombineLatest(
        InteractionParameters.sharedInstance.influenceParameters,
        InteractionParameters.sharedInstance.steeringParameters
    )
    .debounce(for: 0.3, scheduler: DispatchQueue.main)
    .sink { (influencing, steering) in
        print(&quot;influencing params: \(influencing), steering: \(steering)&quot;)
    }
    .store(in: &amp;subscriptions)
</code></pre>
<p>This works, in that I do get the changes as they're made by the user. But I always get <em>all</em> the parameters twice, in immediate succession — i.e., the output here is always printed twice. I've double-checked the debounce, which seems to work as expected — the value being sent twice is always the <em>last</em> value to hit the debounce.</p>
<p>I'm sure it's some simple mistake/misunderstanding, but not sure how to fix it.</p>
<p>Thanks in advance.</p>
","4321521","","4321521","","2021-11-28 19:07:50","2021-11-28 20:53:10","Swift Combine CombineLatest always fires twice","<swift><combine><combinelatest>","1","1","","","","CC BY-SA 4.0"
"70179092","1","","","2021-12-01 04:20:48","","0","146","<p>I can't update the color of my Text base on the current status of my object.
The text should change color base on the variable status true or false.</p>
<p>I try below to simplify the code of where the data come from.</p>
<p>My contentview:</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
  @StateObject var gm = GameManager()

  @State var openSetting = false
  
  var body: some View {
    Button {
      openSetting.toggle()
    } label: {
      Text(&quot;Setting&quot;)
    }
  }
}

</code></pre>
<p>ContentView has a SettingView where I'm selecting setting and where I want to update my textColor based on the status of object</p>
<pre class=""lang-swift prettyprint-override""><code>struct SettingView: View {
  @StateObject var gm : GameManager
  
  var body: some View {
    ScrollView(.horizontal, showsIndicators: true) {
      HStack(spacing: 20) {
        ForEach(gm.cockpit.ecamManager.door.doorarray) { doorName in
          Button {
            gm.close(door: doorName.doorName)
          } label: {
            Text(doorName.doorName)
            // Here where I want to change color
              .foregroundColor(doorName.isopen ? .orange : .green)
          }
        }
      }
    }
  }
}

</code></pre>
<p>The data come from GameManager which inside has a variable called cockpit:</p>
<pre><code>class GameManager: NSObject, ObservableObject, ARSessionDelegate, ARSCNViewDelegate {

@Published var cockpit = MakeCockpit() // create the cockpit
  // do other stuff
}

</code></pre>
<p>MakeCockpit :</p>
<pre><code>class MakeCockpit: SCNNode, ObservableObject {
  @Published var ecamManager = ECAMManager()

  // do other stuff
</code></pre>
<p>ECAMManager:</p>
<pre><code>class ECAMManager: ObservableObject {
  @Published var door = ECAMDoor()
  @Published var stanby = ECAMsby()    
}

</code></pre>
<p>And Finally... the Array I want to watch is in ECAMDoor class:</p>
<pre><code>class ECAMDoor: ObservableObject {
  @Published var doorarray : [Door] = [] // MODEL
}

</code></pre>
<p>Now everything work fine as expected but the @Publish of the door array  not update my color in the setting view. I need to close the view and open again to se the color update.</p>
<p>Is someone can tell me where I mistake? I probably missed something .. hope I been clear (to many instance of class inside other class)</p>
","9962676","","2048453","","2021-12-01 09:25:55","2021-12-01 09:25:55","SwiftUI not update view using @Published","<swift><swiftui><view><combine>","0","2","","","","CC BY-SA 4.0"
"70198655","1","","","2021-12-02 11:32:24","","0","114","<p>I am trying to parse below josn, but not able to parse (using Combine for service API).</p>
<pre><code>{
  &quot;data&quot;: {
    &quot;user_data&quot;: {
      &quot;u_id&quot;: 14252,
      &quot;first_name&quot;: &quot;Amar&quot;,
      &quot;last_name&quot;: &quot;&quot;,
      &quot;email&quot;: &quot;sample@gmail.com&quot;,
      &quot;birth_date&quot;: &quot;&quot;,
      &quot;status&quot;: 1,
      &quot;SubscriptionPlanId&quot;: null,
      &quot;subscriptionexpireddate&quot;: &quot;2021-11-09T10:40:02.000Z&quot;,
      &quot;stripe_customer_id&quot;: &quot;&quot;,
      &quot;stripe_customer_token&quot;: &quot;&quot;,
      &quot;image&quot;: &quot;dfdfcf7.jpg&quot;,
      &quot;password&quot;: &quot;anypassword&quot;,
      &quot;country&quot;: &quot;&quot;,
      &quot;gender&quot;: &quot;&quot;,
      &quot;token&quot;: &quot;eyJ0eXAiOiJKVI1NiJ9.eyJpc3N1ZWQiOiIyMDIxLTEyLTAyVDEwOjE0OjA1Wjk3In0.MznqecyVK6sozp6Fo3em8Ze_ZqSuE3YR2j_oCb1HsZc&quot;,
      &quot;dance_org&quot;: &quot;&quot;,
      &quot;create_time&quot;: &quot;2022-02-10T16:14:56.000Z&quot;,
      &quot;facebook_id&quot;: &quot;&quot;,
      &quot;google_id&quot;: &quot;11600922982196&quot;,
      &quot;twitter_id&quot;: &quot;&quot;,
      &quot;apple_id&quot;: &quot;&quot;,
      &quot;inapp_product_id&quot;: &quot;com.amar.purchase.key&quot;,
      &quot;device&quot;: &quot;ios&quot;,
      &quot;receipt_data&quot;: null,
      &quot;original_transaction_id&quot;: &quot;&quot;,
      &quot;promo_applied&quot;: null,
      &quot;notes&quot;: null,
      &quot;wallet&quot;: 0,
      &quot;referral&quot;: &quot;Ms2dJEqU&quot;,
      &quot;group_name&quot;: null,
      &quot;version&quot;: &quot;iOS 3.1.6 (5)&quot;
    }
  },
  &quot;success&quot;: true,
  &quot;current_time&quot;: &quot;2021-12-02T10:14:05.953Z&quot;,
  &quot;error&quot;: 1000
}
</code></pre>
<p><strong>Getting below Error</strong></p>
<pre><code>keyNotFound(CodingKeys(stringValue: &quot;user_data&quot;, intValue: nil), Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue: &quot;data&quot;, intValue: nil)], debugDescription: &quot;No value associated with key CodingKeys(stringValue: \&quot;user_data\&quot;, intValue: nil) (\&quot;user_data\&quot;).&quot;, underlyingError: nil))
</code></pre>
<p>For testing purpose, I comment data and create_time then working fine, but I comment only data then also getting error for current_time.</p>
<pre><code>keyNotFound(CodingKeys(stringValue: &quot;current_time&quot;, intValue: nil), Swift.DecodingError.Context(codingPath: [], debugDescription: &quot;No value associated with key CodingKeys(stringValue: \&quot;current_time\&quot;, intValue: nil) (\&quot;current_time\&quot;).&quot;, underlyingError: nil))
</code></pre>
<p>Here is my Response model</p>
<pre><code>public struct UserLoginResponse: Decodable {
    enum CodingKeys: String, CodingKey {
        case success, error, data
        case currentTime = &quot;current_time&quot;
    }

    let success: Bool
    let currentTime: String? //&quot;: &quot;2021-11-20T13:00:54.654Z&quot;,
    let error: Int
    let data: LoggedInUserData

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        data = try container.decode(LoggedInUserData.self, forKey: .data)
        success = try container.decode(Bool.self, forKey: .success)
        currentTime = try container.decode(String.self, forKey: .currentTime)
        error = try container.decode(Int.self, forKey: .error)
    }
}

public struct LoggedInUserData: Decodable {
    
    enum CodingKeys: String, CodingKey {
        case userData = &quot;user_data&quot;
    }
    
    let userData: LoginedInUserInfo
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        userData = try container.decode(LoginedInUserInfo.self, forKey: .userData)
    }
}

public struct LoginedInUserInfo: Decodable {
    
    enum CodingKeys: String, CodingKey {
        case userID = &quot;u_id&quot;
        case firstName = &quot;first_name&quot;
        case lastName = &quot;last_name&quot;
        case email //= &quot;email&quot;
        case birthDate = &quot;birth_date&quot;
        case status //= &quot;status&quot;
        case subscriptionPlanId = &quot;SubscriptionPlanId&quot;
        case subscriptionexpireddate //= &quot;subscriptionexpireddate&quot;
        case stripeCustomerId = &quot;stripe_customer_id&quot;
        case stripeCustomerToken = &quot;stripe_customer_token&quot;
        case image //= &quot;image&quot;
        case password //= &quot;password&quot;
        case country //= &quot;country&quot;
        case gender //= &quot;gender&quot;
        case token //= &quot;token&quot;
        case danceOrg = &quot;dance_org&quot;
        case createTime = &quot;create_time&quot;
        case facebookId = &quot;facebook_id&quot;
        case googleId = &quot;google_id&quot;
        case twitterId = &quot;twitter_id&quot;
        case appleId = &quot;apple_id&quot;
        case inappProductId = &quot;inapp_product_id&quot;
        case device //= &quot;device&quot;
        case receiptData = &quot;receipt_data&quot;
        case originalTransactionId = &quot;original_transaction_id&quot;
        case promoApplied = &quot;promo_applied&quot;
        case notes //= &quot;notes&quot;
        case wallet //= &quot;wallet&quot;
        case referral //= &quot;referral&quot;
        case groupName = &quot;group_name&quot;
        case version //= &quot;version&quot;
    }

    let userID: Int
    var firstName: String
    let lastName: String?
    let email: String?
    let birthDate: String?
    let status: Int
    let subscriptionPlanId: String?
    let subscriptionexpireddate: String?
    let stripeCustomerId: String?
    let stripeCustomerToken: String?
    let image: String?
    let password: String
    let country: String?
    let gender: String?
    let token: String?
    let danceOrg: String?
    let createTime: String?
    let facebookId: String?
    let googleId: String?
    let twitterId: String?
    let appleId: String?
    let inappProductId: String
    let device: String?
    let receiptData: String?
    let originalTransactionId: String?
    let promoApplied: String?
    let notes: String?
    var wallet: Int
    let referral: String?
    let groupName: String?
    let version: String?
    
    public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

        userID = try container.decode(Int.self, forKey: .userID)
        firstName = try container.decode(String.self, forKey: .firstName)
        lastName = try container.decode(String.self, forKey: .lastName)
        email = try container.decode(String.self, forKey: .email)
        birthDate = try container.decode(String.self, forKey: .birthDate)
        status = try container.decode(Int.self, forKey: .status)
        subscriptionPlanId = try? container.decode(String.self, forKey: .subscriptionPlanId)
        subscriptionexpireddate = try container.decode(String.self, forKey: .subscriptionexpireddate)
        stripeCustomerId = try container.decode(String.self, forKey: .stripeCustomerId)
        stripeCustomerToken = try container.decode(String.self, forKey: .stripeCustomerToken)
        image = try container.decode(String.self, forKey: .image)
        password = try container.decode(String.self, forKey: .password)
        country = try container.decode(String.self, forKey: .country)
        gender = try container.decode(String.self, forKey: .gender)
        token = try container.decode(String.self, forKey: .token)
        danceOrg = try container.decode(String.self, forKey: .danceOrg)
        createTime = try container.decode(String.self, forKey: .createTime)
        facebookId = try container.decode(String.self, forKey: .facebookId)
        googleId = try container.decode(String.self, forKey: .googleId)
        twitterId = try container.decode(String.self, forKey: .twitterId)
        appleId = try container.decode(String.self, forKey: .appleId)
        inappProductId = try container.decode(String.self, forKey: .inappProductId)
        device = try container.decode(String.self, forKey: .device)
        receiptData = try? container.decode(String.self, forKey: .receiptData)
        originalTransactionId = try container.decode(String.self, forKey: .originalTransactionId)
        promoApplied = try? container.decode(String.self, forKey: .promoApplied)
        notes = try? container.decode(String.self, forKey: .notes)
        wallet = try container.decode(Int.self, forKey: .wallet)
        referral = try? container.decode(String.self, forKey: .referral)
        groupName = try? container.decode(String.self, forKey: .groupName)
        version = try? container.decode(String.self, forKey: .version)
        }
}
</code></pre>
<p>Here is my service manager API body</p>
<pre><code>static func fetch&lt;T: Decodable&gt;(with request: URLRequest, session: URLSessionType) -&gt; AnyPublisher&lt;T, MusicNetworkError&gt;  {
        return  session.sessionWithConfig().dataTaskPublisher(for: request)
              .tryMap { (data: Data, response: URLResponse) in //tryMap validate provide feature to validate first, if ok then return data oterwise error. while Map does not provide any validation
                  guard let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 else {
                      throw URLError(.badServerResponse)
                  }
                  return data
              }
              .decode(type: T.self, decoder: JSONDecoder()) //
              .mapError({ error in
                switch error {
                case is Swift.DecodingError:
                    print(&quot;Error while fetch = \(error)&quot;) **//failing always**
                  return .decodingFailed
                case let urlError as URLError:
                  return .sessionFailed(error: urlError)
                default:
                  return .other(error)
                }
              })
              .eraseToAnyPublisher()
    }
</code></pre>
<p>Please suggest, where I am doing wrong.</p>
<p>I tried with HARD coded string, same Decodable class working fine.</p>
<pre><code>static func testFunction()  {
            
        let jsonData = &quot;&quot;&quot;
        {
          &quot;data&quot;: {
            &quot;user_data&quot;: {
              &quot;u_id&quot;: 14252,
              &quot;first_name&quot;: &quot;Amar&quot;,
              &quot;last_name&quot;: &quot;&quot;,
              &quot;email&quot;: &quot;a@gmail.com&quot;,
              &quot;birth_date&quot;: &quot;&quot;,
              &quot;status&quot;: 1,
              &quot;SubscriptionPlanId&quot;: null,
              &quot;subscriptionexpireddate&quot;: &quot;2021-11-09T10:40:02.000Z&quot;,
              &quot;stripe_customer_id&quot;: &quot;&quot;,
              &quot;stripe_customer_token&quot;: &quot;&quot;,
              &quot;image&quot;: &quot;3dd3b-a95522a0fcf7.jpg&quot;,
              &quot;password&quot;: &quot;mypass&quot;,
              &quot;country&quot;: &quot;&quot;,
              &quot;gender&quot;: &quot;&quot;,
              &quot;token&quot;: &quot;eyJ0eXAiOiJKVdR_lEw&quot;,
              &quot;dance_org&quot;: &quot;&quot;,
              &quot;create_time&quot;: &quot;2022-02-10T16:14:56.000Z&quot;,
              &quot;facebook_id&quot;: &quot;&quot;,
              &quot;google_id&quot;: &quot;1d2196dd&quot;,
              &quot;twitter_id&quot;: &quot;&quot;,
              &quot;apple_id&quot;: &quot;&quot;,
              &quot;inapp_product_id&quot;: &quot;com.my.company&quot;,
              &quot;device&quot;: &quot;ios&quot;,
              &quot;receipt_data&quot;: null,
              &quot;original_transaction_id&quot;: &quot;&quot;,
              &quot;promo_applied&quot;: null,
              &quot;notes&quot;: null,
              &quot;wallet&quot;: 0,
              &quot;referral&quot;: &quot;Ms2dJEqU&quot;,
              &quot;group_name&quot;: null,
              &quot;version&quot;: &quot;iOS 30.6 (5)&quot;
            }
          },
          &quot;success&quot;: true,
          &quot;current_time&quot;: &quot;2021-11-20T13:00:54.654Z&quot;,
          &quot;error&quot;: 1000
        }
&quot;&quot;&quot;.data(using: .utf8)!
            
        let decoder = JSONDecoder()
          let user = try? decoder.decode(T.self, from: jsonData)
        print(&quot;User is = \(user)&quot;) **//This is working fine with same UserLoginResponse**
</code></pre>
<p>but not working with below line</p>
<pre><code>.decode(type: T.self, decoder: JSONDecoder())
</code></pre>
","6995801","","6995801","","2021-12-02 12:09:26","2021-12-02 12:09:26","Combine frame: Generic Parsing No value associated with key CodingKeys using","<ios><swift><combine>","0","8","","","","CC BY-SA 4.0"
"70210706","1","70609561","","2021-12-03 07:14:05","","0","207","<p>Below is the SwiftUI view which owns a ViewModel and the logic is if the <code>viewModel.authenticationService.user</code> contains a user object then it will show the HomeView, else case will be asked for Login. So initially the <code>viewModel.authenticationService.user</code> is nil and user logins successful the user object in no more nil.</p>
<p><strong>View</strong></p>
<pre><code>struct WelcomeView: View {
    
    @ObservedObject private var viewModel: WelcomeView.Model
    @State private var signInActive: Bool = false
    
    init(viewModel: WelcomeView.Model) {
        self.viewModel = viewModel
    }
    
    var body: some View {
        if viewModel.authenticationService.user != nil {
            HomeView()
        } else { 
            LoginView()
        }
    } 
</code></pre>
<p><strong>ViewModel</strong></p>
<pre><code>extension WelcomeView {
    
    final class Model: ObservableObject {
        
        @ObservedObject var authenticationService: AuthenticationService
        
        init(authenticationService: AuthenticationService) {
            self.authenticationService = authenticationService
        }
    }
}
</code></pre>
<p><strong>AuthenticationService</strong></p>
<pre><code>final class AuthenticationService: ObservableObject {
    
    @Published var user: User?
    private var authenticationStateHandle: AuthStateDidChangeListenerHandle?
    
    init() {
        addListeners()
    }
    
    private func addListeners() {
        if let handle = authenticationStateHandle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
        
        authenticationStateHandle = Auth.auth()
            .addStateDidChangeListener { _, user in
                self.user = user
            }
    }
    
    static func signIn(email: String, password: String, completion: @escaping AuthDataResultCallback) {
        if Auth.auth().currentUser != nil {
            Self.signOut()
        }
        Auth.auth().signIn(withEmail: email, password: password, completion: completion)
    }
}
</code></pre>
<p>However, when the user object is updated with some value it does not update the View. I am not sure as I am new to reactive way of programming. There is a chain of View -&gt; ViewModel -&gt; Service and the published user property is in the Service class which gets updated successfully once user login.</p>
<p>Do I need to add a listener in the ViewModel which reacts to Service published property? Or is there any direct way for this scenario to work and get the UI Updated?</p>
","4715546","","","","","2022-01-07 05:33:21","View not reacting to changes of Published property when its chained from another ObservedObject","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"70220286","1","70258563","","2021-12-03 20:26:04","","-1","98","<p>Server I work with accepts:</p>
<pre><code>  curl -X 'POST' \
  'https://some.url' \
  -H 'accept: application/json' \
  -H 'authorization: Bearer YOUR_TOKEN' \
  -H 'Content-Type: multipart/form-data' \
  -F 'data=@your-image.jpg;type=image/jpeg'
</code></pre>
<p>All I can find is examples with parameters. I have tried everything, alamofire and standard url sessions</p>
","6850173","","","","","2021-12-07 10:32:02","Swift upload UIImage with multipart form without parameters","<swift><swiftui><alamofire><combine>","1","1","","","","CC BY-SA 4.0"
"70238101","1","","","2021-12-05 20:06:26","","0","57","<p>I have this ugly construction of returning generic type as solid model, does anyone have ideas on refactoring to be more declarative?</p>
<pre><code>extension NetworkingService {
    
    func login(email: String, password: String) -&gt; AnyPublisher&lt;UserModel, APIError&gt; {
        func convertToModel() -&gt; AnyPublisher&lt;ResponseObject&lt;UserResponse&gt;, APIError&gt; {
            return request(with: AuthRequests.login(email: email, password: password)).eraseToAnyPublisher()
        }
        return convertToModel().map { UserModel(with: $0.data!) }.eraseToAnyPublisher()
    }
    
    func request&lt;T&gt;(with endpoint: Endpoint) -&gt; AnyPublisher&lt;T, APIError&gt; where T : Decodable {
        //... returning any publisher with Decodable
    }
}
</code></pre>
","1025569","","","","","2021-12-06 12:31:10","How to refactor converting Generic typed results to Solid struct in Combine","<ios><swift><generics><refactoring><combine>","1","0","","","","CC BY-SA 4.0"
"70244290","1","","","2021-12-06 10:49:24","","0","308","<p>I have several steps need to be processed synchronously. And the value resulted from the process are consumed by the view. It's working on iOS 14, but <strong>it's crashing on iOS 13</strong>. I use a Combine to publish an event to update the value stored inside the view model.</p>
<p>This is the PublisherManager:</p>
<pre><code>final class PublisherManager {
    static let shared = PublisherManager()
    private var cancellable = Set&lt;AnyCancellable&gt;()

    func mainPublisher() -&gt; AnyPublisher&lt;MainInput, Never&gt; {
        mainSubject
            .eraseToAnyPublisher()
    }

    let mainSubject = PassthroughSubject&lt;MainInput, Never&gt;()

    enum MainInput {
        case updateValue()
    }
}
</code></pre>
<p>This is the view model:</p>
<pre><code>final class ViewModel: ObservableObject {

    @Published var status: Status = .checking

    init() {
        setObserver()
        start()
    }

    private func setObserver() {
        PublisherManager.shared.mainPublisher()
            .receive(on: RunLoop.main)
            .sink { [weak self] action in
                guard let self = self else { return }
                switch action {
                case .updateValue:
                    self.updateValue()
                }
            }.store(in: &amp;cancellable)
    }

    func start() {
        let dispatchGroup = DispatchGroup()
        let dispatchSemaphore = DispatchSemaphore(value: 1)

        dispatchGroup.enter()
        dispatchQueue.asyncAfter(deadline: DispatchTime.now() + 1) {
            dispatchSemaphore.wait()
            self.getValues { //--&gt; A process to call API
                PublisherManager.shared.pushNotificationTroubleshooterSubject.send(.updateValue())
                dispatchSemaphore.signal()
                dispatchGroup.leave()
            }
        }
        
        dispatchGroup.notify(queue: .main) {
            // Notify
        }
    }
    
    private func updateValue() {
        status = .active
    }
}
</code></pre>
<p>When I run it, I got EXC_BAD_ACCESS in the AppDelegate but it doesn't print any error at all on the debugger. If I comment the <code>status = .active</code> code, it doesn't crash.</p>
<p>What am I doing wrong and how can I solve the problem?</p>
","897733","","897733","","2021-12-07 10:10:02","2021-12-07 10:10:02","Swift crashes when update published value inside a thread synchronously on iOS 13","<ios><swift><multithreading><asynchronous><combine>","1","4","","","","CC BY-SA 4.0"
"70281648","1","70297495","","2021-12-08 21:00:09","","0","269","<p>Like the title says I would like to make custom publisher that will basically function like deffered future. Normally when I want to encapsulate code in some Future, but want it to execute on subscription, I would need to write something like this:</p>
<pre><code>Deffered {
    Future { promise in
    }
}
</code></pre>
<p>Now I was thinking of making custom publisher, something along the lines DefferedFuture that will have exact same functionality as Future, but will execute promise only on subscription?</p>
","744270","","","","","2021-12-09 22:26:53","Making custom Deffered Future Publisher in Swift Combine?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"70299903","1","","","2021-12-10 04:54:46","","2","473","<p>I am using Combine to send values from a view model to a view. The code for view model class:</p>
<pre><code>var subject = PassthroughSubject&lt;User,Error&gt;()
func validate login(username: String, password: String){
    let url = &quot;someurl&quot;
    let httpRequest = MerchantLogin(username: username, password: password)
    let httpBody = try! JSONEncoder().encode(httpRequest)
    cancellable = webservice.apiRequest(url: URL(string: url)!, resultType: User.self, httpMethodType: .post, requestBody: httpBody)
    receive(on: RunLoop.main)
        .sink { [weak self]completion in
            switch completion{
            case .failure(let error ):
                 print(error)
                 self?.subject.send(completion:.failure(error))

            case .finished :
                 print(&quot;finished&quot;)
            }
            
        } receiveValue: { user in
            self.subject.send(user)
            
        }
}
</code></pre>
<p>code for view class:</p>
<pre><code>private var binding = Set&lt;AnyCancellable&gt;()
var viewModel: LoginViewModel!

override func viewDidLoad() {
    super.viewDidLoad()
    setupBinding()
}
func setupBinding(){
    viewModel.subject
        .receive(on: RunLoop.main)
        .sink { [weak self] completion in
            switch completion{
                
            case .finished:
                print(&quot;&quot;)
            case .failure(let error):
               
                let message = &quot;\(error)&quot;
                self?.presentAlert(withTitle: &quot;Oh snap!&quot;, message: message)
            }
        } receiveValue: { [weak self] user in
           print(user)
        }.store(in: &amp;binding) 
}   

@IBAction func loginAction(_ sender: Any) {
    self.viewModel.validateLogin(username: self.usernameTextFiled.text!, password: self.passwordTextField.text!)
}
</code></pre>
<p>On the first button press I am receiving the value and event in the view controller but when I try to press the button again the execution ends in the view model and I am not receiving any events in the view controller.</p>
","12478078","","3585796","","2021-12-18 01:20:09","2021-12-18 01:20:09","Not receiving value from PassthroughSubject on second try","<swift><uikit><combine>","0","3","","","","CC BY-SA 4.0"
"70307714","1","","","2021-12-10 16:37:46","","1","42","<p>I have a timer scheduled as following:</p>
<pre><code>private var timerCancellable: Cancellable?

timerCancellable = Timer
        .publish(every: 1.0, on: .current, in: .common)
        .autoconnect()
        .scan(-1) { counter, _ in counter + 1 }
        .sink { counter in
            print(&quot;\(counter)&quot;)
            
        }
</code></pre>
<p>This works fine (print out 0 1 2 3 ...) when I test it on any normal view controller. But in a specific view controller which I a live camera feed with Metal shaders (and several different DispatchQueue instances), it gives this output:</p>
<p>0
0
1
2
3
...</p>
<p>0 is repeated twice. I tried .main for RunLoop but the result is the same. Can anyone help?</p>
","4490923","","4490923","","2021-12-10 18:18:23","2021-12-10 18:18:23","Swift - Timer.publish(:) misfires","<swift><objective-c><swiftui><combine><runloop>","0","5","","","","CC BY-SA 4.0"
"70314142","1","70315261","","2021-12-11 09:56:04","","0","368","<p>I've got this network call for fetching images.</p>
<pre class=""lang-swift prettyprint-override""><code>func load() {
        guard let url = URL(string: urlString)
        else { return }

        subscription = URLSession.shared.dataTaskPublisher(for: url)
            .map({ UIImage(data: $0.data) })
            .replaceError(with: nil)
            .receive(on: RunLoop.main)
            .sink(receiveValue: { [weak self] in self?.image = $0 })
    }
</code></pre>
<p>This is triggered by the text field being filled. After each letter is typed, I would like my publisher to wait with the execution for let's say 2 seconds, unless a user typed another letter. If that happens, I'd like the timer to reset to 2 seconds again.</p>
<p>Is there any on the fly <strong>cancel</strong> operator if the new request has been sent in the meanwhile?</p>
<p>Thanks for all the help.</p>
","14880022","","14880022","","2021-12-11 10:37:53","2021-12-11 13:36:14","Swift, Combine, cancel on the flight and replace with the new request operator","<ios><swift><combine>","1","7","","","","CC BY-SA 4.0"
"70325844","1","","","2021-12-12 17:10:26","","0","104","<p>My View show some data subscribed to a realm publisher. So if I insert some new objects to the realm db, the realm publisher will send a new data list to the subscriber and the view will be refreshed.</p>
<p>The problem is that when I insert N data into realm db, the publisher will send a new data list to the subscriber for each inserted object. As a result, the view will be refreshed N times which will cause a CPU peek.</p>
<p>Is there any method to control the frequency of the realm publisher?</p>
<p>Thanks</p>
","11487785","","11487785","","2021-12-12 17:16:00","2021-12-13 12:28:36","Is there any method to control the frequency of the realm publisher?","<swift><realm><combine>","1","3","","","","CC BY-SA 4.0"
"70335850","1","","","2021-12-13 13:58:14","","1","335","<p>I recently started using swift's <a href=""https://developer.apple.com/documentation/combine"" rel=""nofollow noreferrer"">Combine</a> (I've used ReactiveCocoa before), I'm wondering if there is a concept of cold and hot signals also in Combine?  Dose <code>Publisher</code> is equal to cold signals(SignalProducers), and No hot signal in Combine? Thanks~</p>
","4254676","","4254676","","2021-12-13 14:00:04","2021-12-13 20:56:50","Is there a cold/hot signal in swift Combine（likes SignalProducers /Signals in ReactiveCocoa）?","<ios><swift><combine><reactive-swift>","1","3","","","","CC BY-SA 4.0"
"70354240","1","70356271","","2021-12-14 18:57:57","","0","107","<p>I'm currently trying to load JSON in Swift to use it in my UI. I think I've managed to get the JSON to load properly, but I can't test it due to the multiple errors I'm getting in my code.</p>
<p>JSONReader.swift:</p>
<pre><code>import Foundation

struct DatabaseObject: Decodable {
    let name: String
    let books: Books
    let memoryVerses: MemoryVerses
    
    struct Books: Codable {
        let Romans: Book
        let James: Book
        
        struct Book: Codable {
            let abbreviation: String
            let chapters: [Chapter]
            
            struct Chapter: Codable {
                let sections: [Section]
                let footnotes: Footnotes
                
                struct Section: Codable {
                    let title: String
                    let verses: [String]
                }
                
                struct Footnotes: Codable {
                    let a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z: String
                }
                
            }
            
        }
        
    }
    struct MemoryVerses: Codable {
        let singles: [String]
        let multiples: [String]
    }
}

public class JSONReaderSuperclass {
    @Published var contentData: (status: String, result: DatabaseObject?)
    init() {
        contentData = (status: &quot;loading&quot;, result: nil)
    }
}

public class JSONReader: JSONReaderSuperclass, ObservableObject {
    
    private func parse(jsonData: Data) -&gt; (status: String, result: DatabaseObject?) {
        do {
            let decodedData = try JSONDecoder().decode(DatabaseObject.self, from: jsonData)
            print(decodedData)
            return (status: &quot;success&quot;, result: decodedData)
        } catch {
            return (status: &quot;fail&quot;, result: nil)
        }
    }
    private func loadJson(fromURLString urlString: String,
                          completion: @escaping (Result&lt;Data, Error&gt;) -&gt; Void) {
        if let url = URL(string: urlString) {
            let urlSession = URLSession(configuration: .default).dataTask(with: url) { (data, response, error) in
                if let error = error {
                    completion(.failure(error))
                }
                
                if let data = data {
                    completion(.success(data))
                }
            }
            urlSession.resume()
        }
    }
    override init() {
        super.init()
        DispatchQueue.main.async {
            self.loadJson(fromURLString: &quot;redacted for anonymity&quot;) { result in
                switch result {
                    case .success(let data):
                        self.contentData = self.parse(jsonData: data)
                    case .failure:
                        self.contentData = (status: &quot;fail&quot;, result: nil)
                }
            }
        }
    }
}
</code></pre>
<p>ContentView.swift:</p>
<pre><code>import SwiftUI

struct ContentView: View {
    @StateObject var databaseObject = JSONReader()
    var body: some View {
        switch ($databaseObject.status) {
            case &quot;loading&quot;:
                Text(&quot;Loading...&quot;)
            case &quot;success&quot;:
                VersePicker(databaseObject: $databaseObject.result)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .navigationTitle(&quot;Content Judge&quot;)
                    .navigationBarTitleDisplayMode(.inline)
            case &quot;fail&quot;:
                Text(&quot;An unknown error occured. Check your internet connection and try again.&quot;)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
<p>VersePicker.swift:</p>
<pre><code>import SwiftUI

enum Book: String, CaseIterable, Identifiable {
    case romans
    case james

    var id: String { self.rawValue }
}

struct VersePicker: View {
    var databaseObject: DatabaseObject
    @State private var selectedBook = Book.romans
    @State private var selectedChapter: Int = 1
    @State private var selectedVerse: Int = 1
    
    var body: some View {
        VStack {
            Picker(&quot;Book&quot;, selection: $selectedBook) {
                ForEach(Book.allCases) { book in
                    Text(book.rawValue.capitalized)
                        .tag(book)
                }
            }
            HStack {
                Picker(&quot;Chapter&quot;, selection: $selectedChapter) {
                    ForEach(1...100, id: \.self) { number in
                        Text(&quot;\(number)&quot;)
                    }
                }
                Picker(&quot;Verse&quot;, selection: $selectedVerse) {
                    ForEach(1...100, id: \.self) { number in
                        Text(&quot;\(number)&quot;)
                    }
                }
            }
            .frame(maxHeight: .infinity)
            Spacer()
            NavigationLink(destination: VerseDisplay()) {
                Label(&quot;Go&quot;, systemImage: &quot;arrow.right.circle&quot;)
            }
        }
        .padding()
    }
}

struct VersePicker_Previews: PreviewProvider {
    static var previews: some View {
        VersePicker(databaseObject: JSONReader().result)
    }
}
</code></pre>
<p>I'm getting the following errors:</p>
<ul>
<li><strong>ContentView.swift:13</strong> - &quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'status'
using key path from root type 'JSONReader'&quot;</li>
<li><strong>ContentView.swift:17</strong> - &quot;Cannot convert value of type 'Binding' to expected argument type 'DatabaseObject'&quot;</li>
<li><strong>ContentView.swift:17</strong> - &quot;Value of type 'ObservedObject.Wrapper' has no dynamic member 'result'
using key path from root type 'JSONReader'&quot;</li>
<li><strong>VersePicker.swift:55</strong> - &quot;Value of type 'JSONReader' has no member 'result'&quot;</li>
</ul>
<p>Any idea what I'm doing wrong? I'm completely new to Swift, so I'm at a loss.</p>
","14496190","","","","","2021-12-14 22:27:34","How to use StateObject and Combine with JSON loader?","<json><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"70415608","1","70415697","","2021-12-19 21:51:10","","-2","1188","<p>Could someone explain why I get this warning: <strong>Publishing changes from background threads is not allowed; make sure to publish values from the main thread (via operators like receive(on:)) on model updates.</strong></p>
<p>I'm know that if I wrap the changes in <code>DispatchQueue.main.async</code> the problem goes away. Why does it happen with some view modals and not others? I thought that since the variable has <code>@Published</code> it's automatically a publisher on main thread?</p>
<pre class=""lang-swift prettyprint-override""><code>class VM: ObservableObject {
    
    private let contactsRepo = ContactsCollection()
    
    @Published var mutuals: [String]?
    
    func fetch() {
        contactsRepo.findMutuals(uid: uid, otherUid: other_uid, limit: 4) { [weak self] mutuals in
            guard let self = self else { return }
            if mutuals != nil {
                self.mutualsWithHost = mutuals // warning...
            } else {
                self.mutualsWithHost = []
            }
        }
    }
}
</code></pre>
","7451631","","","","","2021-12-19 22:06:01","SwiftUI @Published and main thread","<swift><swiftui><combine>","2","1","","","","CC BY-SA 4.0"
"70442054","1","70538361","","2021-12-21 22:02:06","","0","87","<p>I've posted a minimal example to <a href=""https://github.com/SaganRitual/Vai"" rel=""nofollow noreferrer"">github</a>.</p>
<p><a href=""https://stackoverflow.com/questions/61025239/weird-behaviour-in-swiftuicombine-when-class-struct"">This question</a> seems like it might be related, but I couldn't make any progress.</p>
<p>I have an <code>@ObservableObject</code> class that contains a <code>@Published</code> struct. I have a <code>Slider</code> bound to a field in that struct, and two observers on the struct. One of the observers makes a change to a different field in the struct. When I read the updated struct during notification, everything looks right. After the notification, my struct has been overwritten. I can't find where it's happening in the debugger; it breaks on <code>@main</code>. I've put diagnostics all over the place in my real app, and can't figure out where it's being set to the wrong value.</p>
<p>It seems like what's happening is that SwiftUI is making copies of the struct. I could understand making copies if the struct weren't part of an object, but I don't get why it would do it here.</p>
<p>Changing my struct to a class causes the overwrite to stop. But my struct really shouldn't be a class; it's kind of like <code>CGRect</code> in my example. So I wonder:</p>
<ul>
<li>Why does it behave this way with a struct?</li>
<li>Is this a misuse of Combine or SwiftUI or Swift?</li>
<li>Is something I'm doing here generally a bad practice?</li>
<li>Is there a better way to do it?</li>
</ul>
<p>Here's the main app module:</p>
<pre><code>@ObservedObject var arena = Arena()

var body: some Scene {
    WindowGroup {
        ContentView(arena: arena).onAppear { arena.postInit() }
    }
}
</code></pre>
<p>Here's <code>ContentView</code>:</p>
<pre><code>@ObservedObject var arena: Arena

func bind() -&gt; Binding&lt;Double&gt; {
    // A sanity check of sorts, to verify that I'm really
    // reading and writing the slider values.
    Binding(
        get: { arena.frame.origin.x },
        set: {
            arena.frame.origin.x = $0
            print(&quot;Binding (x: \(arena.frame.origin.x), y: \(arena.frame.origin.y))&quot;)
        }
    )
}

var body: some View {
    // Slide this slider around; it will write to the X in the
    // frame struct.
    Slider(
        value: bind(), in: -1.0...1.0,
        label: { Text(&quot;Origin.x \(arena.frame.origin.x)&quot;) }
    )

    Button(&quot;Check values&quot;) {
        print(&quot;Button (x: \(arena.frame.origin.x), y: \(arena.frame.origin.y))&quot;)
    }
}
</code></pre>
<p>And here's <code>Arena</code>:</p>
<pre><code>@Published var frame: CGRect = .zero

var xObserver: AnyCancellable?

func postInit() {
    // Whenever the X is changed, update the Y
    xObserver = $frame
        .removeDuplicates {
            $0.origin.x == $1.origin.x
        }
        .sink { [weak self] in
            guard let myself = self else { return }
            myself.frame.origin.y = $0.origin.x
            print(&quot;Writing (x: \(myself.frame.origin.x), y: \(myself.frame.origin.y))&quot;)
        }
}
</code></pre>
<p>If you run the app and move the slider around, you can see in the console output that I'm writing to the x/y values in the rectangle, but when you click the button you can see that we're reading the rectangle values and getting zeros.</p>
<p>One clue is that if I add <code>RunLoop.main</code> or <code>DispatchQueue.main</code> to my observer as shown below, the correct values are read back when clicking the button, although they're not correct while the slider is being moved around.</p>
<pre><code>// In the Arena class
func postInit() {
    xObserver = $frame
        .removeDuplicates {
            $0.origin.x == $1.origin.x
        }

        // Adding this line changes the behavior; it
        // doesn't seem to clear up the whole issue, but it's a
        // clue. Note that this works the same using
        // DispatchQueue.main, but not using ImmediateScheduler.shared
        .receive(on: RunLoop.main)

        .sink { [weak self] in
            guard let myself = self else { return }
            myself.frame.origin.y = $0.origin.x
            print(&quot;Writing (x: \(myself.frame.origin.x), y: \(myself.frame.origin.y))&quot;)
        }
}
</code></pre>
","1610473","","1610473","","2021-12-22 09:15:55","2021-12-31 01:58:31","SwiftUI/Combine notification overwrites my struct with incorrect values","<swift><class><struct><swiftui><combine>","1","7","","","","CC BY-SA 4.0"
"70454265","1","70518109","","2021-12-22 19:34:39","","-2","151","<p>I have two publishers, one that gathers messages based on a state, and the second which is a Timer. I want these to fire in order - so first gather data, then start a timer. How can I do this? This is my current code:</p>
<pre><code>let messagesPublisher = OnboardingStateLogic.publisher(
  forState: state,
  nextState: nextState
)

messagesPublisher
  .sink { completion in 
    print(&quot;completed&quot;)
  } receiveValue: { [weak self] messages in
    messages.forEach { message in
      self?.queue.enqueue(message)
    }
  }

timer = Timer
  .publish(every: 2, on: .main, in: .default)
  .autoconnect()
  .sink { _ in
    self.dequeueMessages()
  }
</code></pre>
","362840","","","","","2021-12-29 10:25:53","How to fire one publisher after another?","<ios><swift><combine>","2","2","","","","CC BY-SA 4.0"
"70477318","1","","","2021-12-25 00:27:43","","-1","38","<p>Given, I have</p>
<pre><code>let minMaxPublisher = [[10,-19,100,-34],[-100,3,2,11],[100,200,-101]].publisher
</code></pre>
<p>how would you get the min max of the whole thing?</p>
","14934238","","","","","2021-12-31 02:20:14","Min Max in Combine on an Array","<combine>","1","3","","","","CC BY-SA 4.0"
"70481696","1","70481978","","2021-12-25 17:32:22","","0","160","<p>I want to debounce a batch of events and process them after a delay of ~1.5 seconds. Here's what I've done.</p>
<pre><code>class ViewModel: ObservableObject {

    @Published var pending: [TaskInfo]
    private var cancellable: AnyCancellable? = nil

    init() {
        processPendingTasks()
    }

    func queueTask(task: TaskInfo) { 
        pending.append(task)
    }

    private func processPendingTasks() {
        cancellable = $pendingTasks
                .debounce(for: 1.5, scheduler: RunLoop.main)
                .sink(receiveValue: { batch in 
                    // Iterate though elements and process events.
                })           
    }
}
</code></pre>
<p><strong>Issue:</strong> This works fine, but the issue that I've is that it performs unnecessary view updates since the array is tagged <code>@Published</code>.</p>
<p><strong>What I'm looking for:</strong> The ideal approach would be a streaming setup where I get all events (in a batched fashion) but the <code>sink</code> should wait exactly for 1.5 seconds after the last event was added.</p>
<p>I tried <code>PassthroughSubject</code>, but it seems like it only gets me the last event that happened in the last 1.5 seconds.</p>
","3437352","","","","","2021-12-25 18:28:33","Creating a sequential publisher in Swift Combine","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"70498732","1","","","2021-12-27 17:44:30","","3","1344","<p>I am trying to create a view like Audio message view as shows in WhatsApp.</p>
<p>Player code.</p>
<pre><code>struct AudioPlayerControlsView: View {
    private enum PlaybackState: Int {
        case waitingForSelection
        case buffering
        case playing
    }
    
    let player: AVPlayer
    let timeObserver: PlayerTimeObserver
    let durationObserver: PlayerDurationObserver
    let itemObserver: PlayerItemObserver
    @State private var currentTime: TimeInterval = 0
    @State private var currentDuration: TimeInterval = 0
    @State private var state = PlaybackState.waitingForSelection
    
    var body: some View {
        VStack {
            if state == .waitingForSelection {
                Text(&quot;Select a song below&quot;)
            } else if state == .buffering {
                Text(&quot;Buffering...&quot;)
            } else {
                Text(&quot;Great choice!&quot;)
            }
            
            Slider(value: $currentTime,
                   in: 0...currentDuration,
                   onEditingChanged: sliderEditingChanged,
                   minimumValueLabel: Text(&quot;\(Utility.formatSecondsToHMS(currentTime))&quot;),
                   maximumValueLabel: Text(&quot;\(Utility.formatSecondsToHMS(currentDuration))&quot;)) {
                    // I have no idea in what scenario this View is shown...
                    Text(&quot;seek/progress slider&quot;)
            }
            .disabled(state != .playing)
        }
        .padding()
        // Listen out for the time observer publishing changes to the player's time
        .onReceive(timeObserver.publisher) { time in
            // Update the local var
            self.currentTime = time
            // And flag that we've started playback
            if time &gt; 0 {
                self.state = .playing
            }
        }
        // Listen out for the duration observer publishing changes to the player's item duration
        .onReceive(durationObserver.publisher) { duration in
            // Update the local var
            self.currentDuration = duration
        }
        // Listen out for the item observer publishing a change to whether the player has an item
        .onReceive(itemObserver.publisher) { hasItem in
            self.state = hasItem ? .buffering : .waitingForSelection
            self.currentTime = 0
            self.currentDuration = 0
        }
        // TODO the below could replace the above but causes a crash
//        // Listen out for the player's item changing
//        .onReceive(player.publisher(for: \.currentItem)) { item in
//            self.state = item != nil ? .buffering : .waitingForSelection
//            self.currentTime = 0
//            self.currentDuration = 0
//        }
    }
    
    // MARK: Private functions
    private func sliderEditingChanged(editingStarted: Bool) {
        if editingStarted {
            // Tell the PlayerTimeObserver to stop publishing updates while the user is interacting
            // with the slider (otherwise it would keep jumping from where they've moved it to, back
            // to where the player is currently at)
            timeObserver.pause(true)
        }
        else {
            // Editing finished, start the seek
            state = .buffering
            let targetTime = CMTime(seconds: currentTime,
                                    preferredTimescale: 600)
            player.seek(to: targetTime) { _ in
                // Now the (async) seek is completed, resume normal operation
                self.timeObserver.pause(false)
                self.state = .playing
            }
        }
    }
}
</code></pre>
<p>Now I am trying to add it to cells of list in SwiftUI.</p>
<pre><code>struct Audiomessage : Identifiable {
    var id: UUID
    var url : String
    var isPlaying : Bool
}

struct ChatView : View {
    let player = AVPlayer()
    private let items = [ Audiomessage(id: UUID(), url: &quot;https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3&quot;, isPlaying: false),Audiomessage(id: UUID(), url: &quot;https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3&quot;, isPlaying: false)]
    
    
    var body: some View {
        VStack{
            LazyVStack {
                ForEach(items) { reason in
                    AudioPlayerControlsView(player: player,
                                            timeObserver: PlayerTimeObserver(player: player),
                                            durationObserver: PlayerDurationObserver(player: player),
                                            itemObserver: PlayerItemObserver(player: player)).onTapGesture {
                        guard let url = URL(string: reason.url) else {
                            return
                        }
                        let playerItem = AVPlayerItem(url: url)
                        self.player.replaceCurrentItem(with: playerItem)
                        self.player.play()

                    }

                }
            }
            .padding(.bottom,37)
            .padding()
        }
        .padding(.horizontal,10)
    }
}
</code></pre>
<p>The out for this is like below:</p>
<p><img src=""https://i.stack.imgur.com/xkKG9.png"" width=""300""></p>
<p>Both starts playing on Tap. I want to play one song at a time. How Can I achieve this in SwiftUI?</p>
","1051816","","3585796","","2021-12-31 02:56:55","2022-01-12 08:11:08","Create Audio Player cell with slider in SwiftUI","<swift><swiftui><avplayer><combine><swiftui-list>","1","2","2","","","CC BY-SA 4.0"
"70511582","1","","","2021-12-28 19:20:42","","2","228","<p>I have a caching system that works. I have a property wrapper. Now I want to turn that into a property wrapper that publishes for use in a <code>SwiftUI</code> view but I can't work that out.</p>
<p>Here is my code for the property wrapper (that doesn't successfully publish). This was sort of taken from another answer on stack overflow, where I've defined an internal <code>CurrentValueSubject</code> that gets fired every time a new value is set to the <code>wrappedValue</code>:</p>
<pre><code>import UIKit
import Combine

@propertyWrapper final class CachedPublisher&lt;Value: Codable&gt; {
  enum Key: String, Codable {
    case user
  }

  let key: Key
  let cache: Cache&lt;Key, Value&gt;
  private let defaultValue: Value
  private var cancellables = Set&lt;AnyCancellable&gt;()
  private lazy var subject = CurrentValueSubject&lt;Value, Error&gt;(wrappedValue)

  var wrappedValue: Value {
    get {
      let value = cache[key]
      return value ?? defaultValue
    }
    set {
      cache[key] = newValue
      subject.send(newValue)
    }
  }

  var projectedValue: AnyPublisher&lt;Value, Error&gt; {
    return subject.eraseToAnyPublisher()
  }

  init(
    wrappedValue defaultValue: Value,
    key: Key
  ) {
    self.key = key
    self.defaultValue = defaultValue
    if let cache = try? Cache&lt;Key, Value&gt;.retrieveFromDisk(withName: key.rawValue) {
      self.cache = cache
    } else {
      cache = Cache&lt;Key, Value&gt;()
    }
  }
}

// MARK: - ExpressibleByNilLiteral
extension CachedPublisher where Value: ExpressibleByNilLiteral {
  convenience init(key: Key) {
    self.init(wrappedValue: nil, key: key)
  }
}
</code></pre>
<p>This is to be specified like this inside an <code>ObservableObject</code>:</p>
<pre><code>@CachedPublisher(key: .user)
var user: User?
</code></pre>
<p>Then I want to use it in a <code>SwiftUI</code> view so my view updates whenever <code>user</code> changes.</p>
<hr />
<p>Update in response to Asperi:</p>
<p>I have an @EnvironmentObject that is my source of truth:</p>
<pre><code>final class MyTruthObject: ObservableObject {
    @CachedPublisher(key: .user)
    var user: User? = User(name: &quot;Unknown&quot;)
}


struct DemoView: View {
    @EnvironmentObject private var myTruth: MyTruthObject

    var body: some View {
        VStack {
            Text(&quot;User: \(myTruth.user?.name ?? &quot;&quot;)&quot;)
            Divider()
            Button(&quot;Update&quot;) {
                myTruth.user = User(name: &quot;John Smith&quot;)
            }
            Button(&quot;Reset&quot;) {
                myTruth.user = nil
            }
        }
    }
}
</code></pre>
<p>Would your answer work with this layout?</p>
","362840","","362840","","2022-01-01 17:36:09","2022-01-01 17:36:09","How to create a publishing property wrapper that also caches","<ios><swiftui><combine>","1","4","1","","","CC BY-SA 4.0"
"70533831","1","70533906","","2021-12-30 15:51:49","","-3","240","<p>I have the following function <code>loadData</code> and I want to use it within <code>refreshable</code> of a SwiftUI list. For this I need to make it an <code>async</code> function:</p>
<pre><code>func loadData() {
  // Publishers
  let followersPublisher = modelLoader.loadAllFollowers(withId: id)
  let followingPublisher = modelLoader.loadAllFollowing(withId: id)
  let friendshipsPublisher = Publishers.Zip(followersPublisher, followingPublisher)
    .share()
    .eraseToAnyPublisher()

  // Sinks
  getFollowers(from: followersPublisher)
  getFollowerChange(
    from: followersPublisher,
    cachedFollowers: followers
  )
  getFollowing(from: followingPublisher)
  getNotFollowingUserBack(from: friendshipsPublisher)
  getUserNotFollowing(from: friendshipsPublisher)

  followersPublisher
    .connect()
    .store(in: &amp;cancellables)
  followingPublisher
    .connect()
    .store(in: &amp;cancellables)
}
</code></pre>
<p>Within this function, all the separate functions use <code>Publisher</code> sinks. For example:</p>
<pre><code>private func getFollowing(from publisher: Publishers.MakeConnectable&lt;AnyPublisher&lt;Set&lt;User&gt;, Never&gt;&gt;) {
  publisher
    .sink(
      receiveCompletion: { _ in },
      receiveValue: { [weak self] following in
        self?.following = following
      }
    )
    .store(in: &amp;cancellables)
}
</code></pre>
<p>How can I turn it into an <code>async</code> function so I can use <code>await</code> with it?</p>
","362840","","362840","","2021-12-30 15:58:01","2021-12-30 23:19:06","Turning function that has a combination of publishers/sinks into an async function","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"70559235","1","70559539","","2022-01-02 19:50:04","","0","744","<p>I'm doing login using SwiftUI and Combine. Could you please give me some idea how can I decode and show json error when user types incorrect email or password? I can only get token.</p>
<p>When I'm doing the same login request with incorrect email or password, server returns me this error message:</p>
<pre><code>{
&quot;code&quot;: &quot;[jwt_auth] incorrect_password&quot;,
&quot;message&quot;: &quot;Incorrect password!&quot;,
&quot;data&quot;: {
    &quot;status&quot;: 403
}
</code></pre>
<p>}</p>
<p>The problem is that I can't understand how can I decode two different json responses when doing one request in Combine? I can only get token.</p>
<p>Here's model for login request:</p>
<pre><code>struct LoginResponse: Decodable {
let token: String }

struct ErrorResponse: Decodable {
    let message: String
}
struct Login: Codable {
    let username: String
    let password: String
}

static func login(email: String, password: String) -&gt; AnyPublisher&lt;LoginResponse, Error&gt; {
    let url = MarketplaceAPI.jwtAuth!
    var request = URLRequest(url: url)

    let encoder = JSONEncoder()
    let login = Login(username: email, password: password)
    let jsonData = try? encoder.encode(login)
    
    request.httpBody = jsonData
    request.httpMethod = HTTPMethod.POST.rawValue
    request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
    
    return URLSession.shared
        .dataTaskPublisher(for: request)
        .print()
        .receive(on: DispatchQueue.main)
        .map(\.data)
        .decode(
          type: LoginResponse.self,
          decoder: JSONDecoder())
        .eraseToAnyPublisher()
}
</code></pre>
<p>And in viewModel:</p>
<pre><code>MarketplaceAPI.login(email: email, password: password)
        .sink(
          receiveCompletion: { completion in
              switch completion {
              case .finished:
                  print(&quot;finished&quot;)
              case .failure(let error):
                  print(&quot;Failure error:&quot;, error.localizedDescription) // This's returning token error 
              }
          },
          receiveValue: { value in
              print(&quot;Token:&quot;, value.token)
             }
          })
        .store(in: &amp;subscriptions)
}
</code></pre>
","10949504","","12299030","","2022-01-02 19:57:35","2022-01-02 20:29:31","How to decode error response message in Combine?","<swift><combine>","2","4","","","","CC BY-SA 4.0"
"70564097","1","70564279","","2022-01-03 10:01:00","","0","147","<p>The example code here is very simple. Sliders update double values but not the other way around. Using Combine how to update two or more sliders on each other?</p>
<pre class=""lang-swift prettyprint-override""><code>struct Centimeters {
    var value: Double
    
    func updateInches() -&gt; Double {
        return value / 2.54
    }
}

struct Inches {
    var value: Double
    
    func updateCentimeters() -&gt; Double {
        return value * 2.54
    }
}

class SizeValueModel: ObservableObject {
    @Published var centimeters: Centimeters
    @Published var inches: Inches
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        self.centimeters = Centimeters(value: 1.0)
        self.inches = Inches(value: 0.393701)
        
        $centimeters.sink {
            self.inches.value = $0.updateInches()
        }.store(in: &amp;cancellables)
        
//        $inches.sink {
//            self.centimeters.value = $0.updateCentimeters()
//        }.store(in: &amp;cancellables)
    }
}

struct ContentView: View {
    @StateObject var model = SizeValueModel()
    var body: some View {
        Slider(value: $model.centimeters.value, in: 0...100, label: {
            Text(&quot;\(model.centimeters.value)&quot;)
        })
        Slider(value: $model.inches.value, in: 0...39.3701, label: {
            Text(&quot;\(model.inches.value)&quot;)
        })
    }
}
</code></pre>
","5941807","","","","","2022-01-03 11:07:43","Combine: update values each other","<swift><swiftui><combine>","2","2","","","","CC BY-SA 4.0"
"70567804","1","70568210","","2022-01-03 15:14:56","","0","151","<p>I have the following extension on a <code>Publisher</code> which allows me to paginate a URL request. I originally used this in a specific use case, where the <code>Output</code> of the publisher was of type <code>CustomType</code>.</p>
<pre><code>extension Publisher where Output == CustomType,
                          Failure == Error {
  func paginate(pageIdPublisher: CurrentValueSubject&lt;String?, Never&gt;) -&gt; AnyPublisher&lt;[User], Never&gt; {
    return self
      .handleEvents(receiveOutput: { response in
        if let maxId = response.pageId {
          pageIdPublisher.send(maxId)
        } else {
          pageIdPublisher.send(completion: .finished)
        }
      })
      .reduce([]) { allUsers, response in
        return response.users + allUsers
      }
      .catch { error in
        Just([])
      }
      .eraseToAnyPublisher()
  }
}

struct CustomType: Codable {
  let users: [User]
  let pageId: String?
}
</code></pre>
<p>This is called like this:</p>
<pre><code>func loadItem() async throws -&gt; [String] {
  let pageIdPublisher = CurrentValueSubject&lt;String?, Never&gt;(nil)

  return try await pageIdPublisher
    .flatMap { pageId in
      urlSession
        .publisher(
          for: .item(pageId: pageId),
          receiveOn: queue
        )
    }
    .paginate(pageIdPublisher: pageIdPublisher) // &lt;- This part
    .singleOutput()
}
</code></pre>
<p>However, I now want to make it generic so that it can be used on any <code>Output</code> type, so long as it has a <code>pageId</code> and some kind of array.</p>
<p>I tried using a protocol <code>Pageable</code> like this:</p>
<pre><code>protocol Pageable {
  associatedtype T

  var pageId: String? {get}
  var items: [T] {get}
}
</code></pre>
<p>But I can't use that with the extension because <code>Output</code> can't have be used with a protocol that contains an <code>associatedType</code>.</p>
<p>Is this possible?</p>
","362840","","362840","","2022-01-03 15:25:49","2022-01-03 16:02:39","How to make this publisher extension generic","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"70569603","1","","","2022-01-03 17:48:37","","1","52","<p>I have a function that updates different <code>@Published</code> variables within an <code>ObservableObject</code>. They aren't updated all at the same time due to processing times of my algorithm between assignments.</p>
<p>Is there any clever way to delay the publishing of updates of variables to observers of my class? Something like manually blocking the publishing and then manually publishing when the function has finished?</p>
<p>Another way could be to do all the calculations and then assign the values to the variables at the end, but even then I'm assuming it probably won't be an exactly synchronised update?</p>
","362840","","","","","2022-01-04 01:45:37","Synchronise the update of all @Published items in an ObservableObject at the same time","<ios><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"70591138","1","70592267","","2022-01-05 10:14:19","","1","686","<p>Does anyone know how to chain together two publishers with Swift + Combine and keep the cancellable so that I can cancel the pipeline later?
I have a method that accepts input from a publisher and outputs to a publisher:</p>
<pre><code>static func connect(inputPublisher: Published&lt;String&gt;.Publisher, outputPublisher: inout Published&lt;String&gt;.Publisher) -&gt; AnyCancellable {
    inputPublisher.assign(to: &amp;outputPublisher)

    // Unfortunately assign consumes cancellable
}
</code></pre>
<p>Note that this method cannot access the wrapped properties directly. The publishers must be passed as arguments.</p>
","1040079","","","","","2022-01-05 11:41:58","How to chain together two Combine publishers in Swift and keep the cancellable object","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"70596542","1","","","2022-01-05 16:47:58","","1","118","<p>I'm using Alamofire for data downloading and passing the data by using Future Publisher and in another class I'm accessing that data and decoding the JsonData and again passing it by using another future. But some times I'm successfully showing in UI and sometimes it's not working.</p>
<p>extension HTTPManager: NetworkManager {</p>
<pre><code>fun getData(from urlString: String) -&gt; Future&lt;Data, Error&gt; {
    return Future { promise in
        AF.request(urlString).response { responseData in
            switch responseData.result {
            case .failure(let error):
                promise(.failure(error))
            case .success(let data):
                guard let data = data else { return }
                promise(.success(data))
            }
        }
    }
}
</code></pre>
<p>}</p>
<pre><code>fun fetchDetailData() -&gt; Future&lt;[DetailViewModel], Error&gt; {
    return Future { [self] promise in
        let resultData = self.networkManager.getData(from: self.urlString)
            .subscribe(on: DispatchQueue.global(qos: .background))
        resultData.sink { (completion) in
            switch completion {
            case .failure(let error):
                promise(.failure(error))
            case .finished:
                debugPrint(&quot;api call successful&quot;)
            }
        } receiveValue: { (data) in
            do {
                let detailData = try JSONDecoder().decode([Detail].self, from: data)
                let detailsData = detailData.map {
                    DetailViewModel(with: $0)
                }
                promise(.success(detailsData))
            }
            catch let jsonError {
                promise(.failure(jsonError))
            }
        }.store(in: &amp;subscriptions)
    }
}


fun fetchDetailsData() {
    self.subscriber = DetailServiceManager().fetchDetailData()
        .receive(on: DispatchQueue.main)
        .sink { completion in
            switch completion {
            case .failure(let error):
                debugPrint(&quot;Error Occured&quot;, error)
            case .finished:
                debugPrint(&quot;Api call is successful&quot;)
            }
        } receiveValue: { detailData in
            DispatchQueue.main.async {
                self.detailsData = detailData
            }
        }
}
</code></pre>
","7341245","","7341245","","2022-01-05 16:53:27","2022-01-05 16:53:27","Not able to pass the Data by using Future COMBINE iOS Swift","<ios><swift><cocoa-touch><alamofire><combine>","0","1","","","","CC BY-SA 4.0"
"70606132","1","70606343","","2022-01-06 11:03:49","","1","411","<p>I've created this publisher chain:</p>
<pre><code>enum ViewState {
  case loading, loaded([Person]), error(String)
}

var viewStatePublisher: AnyPublisher&lt;ViewState, Never&gt; {
  service.fetchPeople()
    .map { ViewState.loaded($0) }
    .eraseToAnyPublisher()
}
</code></pre>
<p><code>fetchPeople</code> can fail, and I'd like to propagate that down the publisher chain as a <code>ViewState.error(String)</code> value. Here's a rough idea of what I'm trying to do:</p>
<pre><code>service.fetchPeople()
  .mapError { error -&gt; AnyPublisher&lt;ViewState, Never&gt; in
    ViewState.error(error.localizedDescription)
  }
  .map { ViewState.loaded($0) }
  .eraseToAnyPublisher()
</code></pre>
<p>However, <code>mapError</code> doesn't work that way. I'm having trouble finding other alternatives to doing this.</p>
","6567226","","","","","2022-01-06 11:57:41","Combine - mapping errors to different types","<swift><combine>","2","0","1","","","CC BY-SA 4.0"
"70623080","1","","","2022-01-07 14:56:17","","0","31","<p>I have been noticing the following since long time, and I am sure that's how it is supposed to work. But I still don't get why.</p>
<p>Imagine you have a view and its viewModel (conforming to <code>ObservableObject</code>). I write often this kind of code, where the view observes a given <code>Published</code> property of its viewModel.</p>
<pre><code>.onReceive(viewModel.$publishedProperty) { value in
    // Do something
}

</code></pre>
<p>Very often I need to <code>if-else</code> on <code>value</code> and even more often, I only need one of the 2 conditional paths. Example: a viewModel that defines <code>@Published private(set) var errorText: String?</code> and you need to perform some actions only when that text is not nil.
One way it works is</p>
<pre><code>.onReceive(viewModel.$errorText) { text in
    if text != nil {
       // Do something
    }
}
</code></pre>
<p>When <code>errorText</code> goes from <code>nil</code> to <code>&quot;foo&quot;</code>, the <code>onReceive</code> triggers once. Expected behavior. Life could not be better!</p>
<p>I do prefer though to write the above in another form, with a more succinct closure, where the <code>if</code> check is expressed with a Combine operator, like this</p>
<pre><code>.onReceive(viewModel.$errorText.compactMap { $0 }) { text in
    // Do something
}
</code></pre>
<p>or</p>
<pre><code>.onReceive(viewModel.$errorText.compactMap { $0 }, perform: doSomething(_:))
</code></pre>
<p>But then life stops being cool because I would expect just one invocation of the closure. But no, the <code>onReceive</code> closure is called twice. Noticed that behavior with other operators too, e.g. <code>filter</code> or <code>map</code>, etc.</p>
<p>Can someone explain me why adding a simple operator, causes that difference?</p>
<p>P.S.
I tripled checked the view setup and its life cycle and all follows Apple guidelines. The viewModel is not constantly recreated or things like that.</p>
","6004854","","","","","2022-01-07 14:56:17","SwiftUI onReceive fires twice when chaining Combine operators","<ios><swift><swiftui><combine>","0","0","","","","CC BY-SA 4.0"
"70629654","1","","","2022-01-08 04:42:02","","2","441","<p>I keep the Model as a Published var in the ViewModel and Observe it from the View.</p>
<p>When the model process goes into a background thread, if you publish the model value, the Xcode thread checker will react.</p>
<blockquote>
<p>Publishing changes from background threads is not allowed; make sure to publish values ​​from the main thread (via operators like receive (on :)) on model updates.</p>
</blockquote>
<p>Is issued.</p>
<pre><code>@StateObject var viewModel = ViewModel()
</code></pre>
<pre><code>class ViewModel: ObservableObject {

    @Published var model = Model()
    var thisValue:String {
        return model.thisValue // I want to use this value in view
    }
</code></pre>
<pre><code>struct Model {
    var thisValue:String = &quot;value&quot; // I want to change this value on background threads.
</code></pre>
<p>I'd like to know how to receive the model value in the main thread, but
I didn't quite understand and asked a question.</p>
<p>I would be very happy if you could tell me.</p>
","13037010","","","","","2022-07-04 16:48:20","How to receive @Published var in main thread","<ios><swift><swiftui><combine><property-wrapper>","1","3","","","","CC BY-SA 4.0"
"70631279","1","","","2022-01-08 10:00:51","","0","126","<p>I consider how I can make stream that merges outputs from database and network request together in the following way:</p>
<ol>
<li>returns current state from database</li>
<li>makes request, saved data to database, and returns them do caller via combine publisher</li>
</ol>
<pre><code>let cachePublisher = dao.read().eraseToAnyPublisher()
let networkPublisher = service.fetch()
    .flatMap { response in 
         // here i can return network fetched data back but I prefer not to do it 
         dao.update(with: response) 
         // maybe .map { _ in response } 
    }
    .eraseToAnyPublisher()
 return Publishers.MergeMany(cachePublisher, networkPublisher).eraseToAnyPublisher()
</code></pre>
<p>Is there any better solution or operator in Combine that I can do side effects?
I consider <code>handleEvents(receiveOutput: )</code> but <code>dao.update(with: response)</code> returns publisher so it doesn't execute without subscriber subscribing to it in such handleEvents.</p>
","4415642","","466862","","2022-01-08 10:11:45","2022-01-08 10:11:45","Combine merging database and network request outputs together","<swift><combine>","0","4","","","","CC BY-SA 4.0"
"70652026","1","70652184","","2022-01-10 11:57:13","","0","709","<p>Is there a way to pass a <code>@Published</code> variable as parameter to a function that needs access to both the current value of the variable and listen to any changes to the value?</p>
<p>Sample code:</p>
<pre><code>import Foundation
import Combine

class Player {
    @Published var progress = 0
}

class PlayerHandler {
    var cancellable: AnyCancellable?
    func send(progress: Int, progressPublisher: Published&lt;Int&gt;.Publisher) {
        print(&quot;Do something with current progress: \(progress)&quot;)

        cancellable = progressPublisher.sink {
            progr in
            print(&quot;Do something else with: \(progr)&quot;)
        }
    }
}

let handler = PlayerHandler()
let player = Player()
handler.send(progress: player.progress, progressPublisher: player.$progress)//Can I send this variable only once?
player.progress = 1
player.progress = 2
</code></pre>
<p>Here, I pass the <code>progress</code> variable as both an <code>Int</code> and as a <code>Published&lt;Int&gt;.Publisher</code>. Is there a way to pass the variable only once? How can I do that?</p>
<p>(I know, I could have used a <code>CurrentValueSubject</code> instead of a <code>@Published</code> variable, but I really like being able to access <code>progress</code> directly as allowed by @Published, instead of having to use <code>progress.value</code>)</p>
","653003","","","","","2022-01-10 12:11:00","Sending @Published variable as both value and Publisher","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"70655316","1","","","2022-01-10 15:58:08","","2","65","<p>I need to implement something like &quot;that particular value was emitted by publisher at least once in the past&quot;. So basically true/false.
As an example to answer if zero was ever send here:</p>
<pre><code>let publisher = PassthroughSubject&lt;Int, Never&gt;()
...
for _ in 1...3 {
    publisher.send(Int.random(in: 0...2))
}
</code></pre>
<p>I came up only with the following options and both feels unnatural somehow:</p>
<pre><code>//Option #1 Using scan
let hadZero = publisher
    .scan(false) { $0 || $1 == 0 }

//Option #2 Merging with CurrentValueSubject
let hadZero = Publishers.Merge(
    CurrentValueSubject&lt;Bool, Never&gt;(false),
    publisher.contains { $0 == 0 }
)
</code></pre>
<p>Is there any better way to do it?</p>
","4442651","","4442651","","2022-01-10 20:57:56","2022-01-10 20:57:56","The best way to implement ""I saw it at least once"" in Combine","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"70664311","1","70748916","","2022-01-11 09:23:06","","0","224","<p>ObservableObject doesn't emit change events for nested observables by default. Here a nested settings object within a view model, which is then observed by a view.</p>
<p>In this small example, the <code>menu</code> doesn't see changes of <code>settings</code> (<code>enable</code> value). How to handle this behavior with Combine to propagate changes upwards in <code>ContentView</code>?</p>
<p>In other words, how to manually pipe changes from your nested models upwards to the dependent view: maybe introduce property wrappers in between to reduce the boiler plating involved?</p>
<pre class=""lang-swift prettyprint-override""><code>// Wrapper
@propertyWrapper struct UserDefault&lt;T: Codable&gt; {
    private let key: String
    private let defaultValue: T

    init(_ key: String, defaultValue: T) {
        self.key = key
        self.defaultValue = defaultValue
    }

    var wrappedValue: T {
        get {
            guard let data = UserDefaults.standard.object(forKey: key) as? Data else {
                return defaultValue
            }
            let value = try? JSONDecoder().decode(T.self, from: data)
            return value ?? defaultValue
        }
        set {
            let data = try? JSONEncoder().encode(newValue)
            UserDefaults.standard.set(data, forKey: key)
        }
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>// Values
final class UserSettings: ObservableObject {
    @UserDefault(&quot;itemA&quot;, defaultValue: true)
    var itemA: Bool { willSet { objectWillChange.send() } }

    @UserDefault(&quot;itemB&quot;, defaultValue: true)
    var itemB: Bool { willSet { objectWillChange.send() } }
    
    @UserDefault(&quot;itemC&quot;, defaultValue: true)
    var itemC: Bool { willSet { objectWillChange.send() } }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>// Model
struct Language: Identifiable, Hashable {
    var id: String
    var enable: Bool
}

enum Item: Identifiable, Hashable {
    var id: String {
        switch self {
        case .item(let language): return language.id
        }
    }
    case item(Language)
}

// ModelView
class ViewModel: ObservableObject {
    let settings = UserSettings()
    @Published var menu: [Item]
    var cancellables: [AnyCancellable] = []

    init() {
        menu = [.item(Language(id: &quot;a&quot;, enable: settings.itemA)),
                .item(Language(id: &quot;b&quot;, enable: settings.itemB)),
                .item(Language(id: &quot;c&quot;, enable: settings.itemC))]
    
        settings.objectWillChange.sink { [unowned self] in
            self.objectWillChange.send()
        }
        .store(in: &amp;cancellables)
    }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>// View
struct ContentView: View {
    @StateObject var model = ViewModel()

    var body: some View {
        HStack() {
            Button(&quot;toggle a \(model.settings.itemA.description)&quot;) { model.settings.itemA.toggle() }
            Button(&quot;toggle b \(model.settings.itemB.description)&quot;) { model.settings.itemB.toggle() }
            Button(&quot;toggle c \(model.settings.itemC.description)&quot;) { model.settings.itemC.toggle() }
        }
        Menu {
            ForEach(model.menu, id:\.self) { content in //// model.menu is not updated
                switch content {
                case let .item(language):
                    if language.enable { // the value doesn't update
                        Button(&quot;Item \(language.id)&quot;, action: {
                            print(language.id)
                        })
                    }
                }
            }
        } label: { Text(&quot;menu&quot;) }
    }
}
</code></pre>
","5941807","","5941807","","2022-01-13 20:44:02","2022-01-18 00:19:30","Updates changes for nested models","<swift><swiftui><combine>","1","6","","","","CC BY-SA 4.0"
"70678178","1","","","2022-01-12 08:10:14","","0","255","<pre><code>// get handle of native data task publisher
    let publisher = URLSession.shared.dataTaskPublisher(for: URL)
        .handleEvents(
            receiveSubscription: { _ in
                activityIndicatorPublisher.send(true)
            }, receiveCompletion: { _ in
                activityIndicatorPublisher.send(false)
            }, receiveCancel: {
                activityIndicatorPublisher.send(false)
            })
        .tryMap { data, response -&gt; Data in
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                      throw NetworkError.httpError
                  }
            return data
        }
        .decode(type: Repository.self, decoder: JSONDecoder())
    .map { $0 }
        .catch { err in
            return Just([])
        }
        .eraseToAnyPublisher()
    return publisher
</code></pre>
<p>I am new to Combine and I can´t figure out what should I put inside the .map{} closure in order to return an array of Repository objects. The error I get at compile time is: <strong>Cannot convert value of type 'Repository' to closure result type '[Any]'</strong></p>
<p>P.S. return type here should be:</p>
<pre><code>-&gt; AnyPublisher&lt;[Repository], Never&gt;
</code></pre>
<p>Can anyone share a light here? Many thanks in advance.</p>
","720648","","","","","2022-01-12 09:21:05","Combine: How to stream an array of parsed objects via a publisher?","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"70687443","1","70687707","","2022-01-12 19:37:33","","4","716","<p>I am listening for changes of a publisher, then fetching some data asynchronously in my  pipeline and updating the view with the result. However, I am unsure how to make this testable. How can I best wait until the expectation has been met?</p>
<h2>View</h2>
<pre><code>struct ContentView: View {
    @StateObject var viewModel = ContentViewModel()

    var body: some View {
        NavigationView {
            List(viewModel.results, id: \.self) {
                Text($0)
            }
            .searchable(text: $viewModel.searchText)
        }
    }
}
</code></pre>
<h2>ViewModel</h2>
<pre><code>final class ContentViewModel: ObservableObject {
    @Published var searchText: String = &quot;&quot;
    @Published var results: [String] = []
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init() {
        observeSearchText()
    }

    func observeSearchText() {
        $searchText
            .dropFirst()
            .debounce(for: 0.8, scheduler: DispatchQueue.main)
            .sink { _ in
                Task {
                    await self.fetchResults()
                }
            }.store(in: &amp;cancellables)
    }

    private func fetchResults() async {
        do {
            try await Task.sleep(nanoseconds: 1_000_000_000)
            self.results = [&quot;01&quot;, &quot;02&quot;, &quot;03&quot;]
        } catch {
            // 
        }
    }
}
</code></pre>
<h2>Tests</h2>
<pre><code>class ContentViewTests: XCTestCase {
    func testExample() {
        // Given
        let viewModel = ContentViewModel()

        // When
        viewModel.searchText = &quot;123&quot;

        // Then (FAILS - Not waiting properly for result/update)
        XCTAssertEqual(viewModel.results, [&quot;01&quot;, &quot;02&quot;, &quot;03&quot;])
    }
}
</code></pre>
<h2>Current Workaround</h2>
<p>If I make <code>fetchResults()</code> available I can async/await which works for my unit and snapshot tests, but I was worried that:</p>
<ol>
<li>It is bad practice to expose if it isn't to be called externally?</li>
<li>I'm not testing my publisher pipeline</li>
</ol>
<pre><code>func testExample_Workaround() async {
    // Given
    let viewModel = ContentViewModel()

    // When
    await viewModel.fetchResults()

    // Then
    XCTAssertEqual(viewModel.results, [&quot;01&quot;, &quot;02&quot;, &quot;03&quot;])
}
</code></pre>
","15477973","","","","","2022-08-23 13:50:39","SwiftUI Combine - How to test waiting for a publisher's async result","<swiftui><combine><swift-concurrency>","1","0","1","","","CC BY-SA 4.0"
"70688771","1","","","2022-01-12 21:39:31","","1","242","<p>I need a way to make a ViewModel wait for a View's async operation to complete before continuing while keeping context.</p>
<p>The view has a reference to the ViewModel but the ViewModel does not have a reference to the view, instead the view is updated via binding using Combine.</p>
<p>There are plenty of cases where this problem could apply, one such is:</p>
<pre><code>protocol ViewModelInterface: ObservableObject {
  associatedtype Model: ModelInterface
  
  var model: Model { get set }
}

class SplashViewModel: ViewModelInterface {
  internal var model: Model
  private let authProvider: AuthProvider

  @Published internal var viewState = ViewState()

  init(model: Model, authProvider: AuthProvider) {
    self.model = model
    self.authProvider = authProvider

    guard let refreshToken = keychain.refreshToken else {
      viewState.isPlayingAnimation = true
      //Need to wait for animation to finish before routing to screen B
      return
    }

    authProvider.login(refreshToken: refreshToken)
    .onSuccess { [weak self] _ in
      self?.viewState.isPlayingAnimation = true
      //Need to wait for animation to finish before routing to screen A
    }.onFailure { [weak self] error in
      self?.viewState.isPlayingAnimation = true
      //Need to wait for animation to finish before routing to screen B
    }
  }
}
</code></pre>
<pre><code>import Combine

class View&lt;M&gt;: UIView where M: ViewModelInterface {
  @IBOutlet var view: UIView! //Set via Xib

  internal let viewModel: M
  internal var cancellables = Set&lt;AnyCancellable&gt;()

  required init(viewModel: M) {
    self.viewModel = viewModel
    super.init(frame: .zero)
    
    //Constrain view to self    

    viewModel.objectWillChange
      .receive(on: DispatchQueue.main)
      .sink(receiveValue: refresh)
      .store(in: &amp;cancellables)
  }

  required init?(coder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented&quot;)
  }
  
  internal func refresh(output: M.ObjectWillChangePublisher.Output) {
    fatalError(&quot;init(coder:) has not been implemented&quot;)
  }
}
</code></pre>
<pre><code>import Lottie

class SplashView: View&lt;SplashViewModel&gt; {
  var animation: AnimationView?

  required init(viewModel: SplashViewModel) {
    super.init(viewModel: viewModel)
    setupAnimation()
  }

  required init?(coder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented&quot;)
  }
  
  override func refresh(output: Void) {
    super.refresh(output: output)
    refreshAnimation()
  }

  func refreshAnimation() {
    if viewModel.viewState.isPlayingAnimation {
      animation?.play()
    } else {
      animation?.stop()
    }
  }

  func setupAnimation() {
    //Configure animation and constrain to view
  }
}
</code></pre>
<p>In this situation it uses the authProvider to make a call for a new access token using the refresh token, then once the request comes back it plays a short animation before routing to the next screen. If the user cannot be authenticated then it goes to screen B, if the user successfully authenticates then it goes to screen A.</p>
<p>My question is how can the ViewModel be made to only do the appropriate routing once the Views animation completes?
The View could call a function on the ViewModel to tell it that the animation has completed, however if we use that approach then the ViewModel loses context on what particular leaf in the decision tree caused the animation in the first place and therefore it won't know what screen to route to.</p>
<p>We can solve this by storing every single possible decision the logic flow could take in a struct, then setting those values and reading them. However that would be very messy and I don't think it's a good solution.</p>
<p>But how else can this be done?</p>
","6229384","","6229384","","2022-01-12 22:17:32","2022-01-12 22:17:32","Make ViewModel Wait for Views Async to Complete (Combine)","<swift><mvvm><combine>","0","2","","","","CC BY-SA 4.0"
"70703336","1","","","2022-01-13 21:31:21","","0","56","<p>I have a View, which is a list of transactions. i.e.</p>
<pre><code>LazyVStack {
     ForEach($viewModel.displayTransactions, id \.id) { $transaction in 
          TransactionView(transaction)
     }
}
</code></pre>
<p><code>displayTransactions</code> is populated by a transactionStore. In the viewModel, a user can filter transactions based on a variable.</p>
<pre><code>class ViewModel: ObservableObject {
     @Published var selectedFilterType: [TransactionFilterType] = .allCases
     @ar transactionStore = TransactionStore()

     var cancellables = Set&lt;AnyCancellable&gt;()

     init() {
          self.listenToFilterChanges()
     }


     func listenToFilterChanges() {

        self.$selectedFilterType
            .receive(on: DispatchQueue.main)
            .sink { [self] filterType in
                let filteredTransactions = transactionStore.userTransactions.filter { transaction in
                    let isYourTransaction = transaction.id == self.accountID
                    let isPartnerTransaction = transaction.id == self.partnerID
                    if isYourTransaction &amp;&amp; self.selectedFilterType.contains(.me) { return true }
                    if isPartnerTransaction &amp;&amp; self.selectedFilterType.contains(.partner) { return true }
                    return false
                }

                self.displayTransactions = filteredTransactions.sorted(by: {
                    $0.ledgerEntryID &gt; $1.ledgerEntryID
                })
            }
            .store(in: &amp;cancellables)
        }


}
</code></pre>
<p>On the view, there is as button to filter transactions, which changes the state of selectedFilterType. Everything works correctly, but if I tap the filter button many times quickly, the app freezes after a certain point. Is this the right way to set up the receiver? Should it run on DispatchQueue.main?</p>
<p>Thanks</p>
","9307138","","","","","2022-01-13 21:31:21","Combine Publisher receiving many events freezes app (SwiftUI)","<ios><swift><swiftui><combine>","0","1","","","","CC BY-SA 4.0"
"70715862","1","70716974","","2022-01-14 19:51:18","","0","162","<p>I'm trying to dynamically update a reference to an <code>@Published var</code>, but I'm not sure how to do it. Returning the value only is just a bool value and loses it's reference to the publisher and doesn't work. I tried returning the publisher itself (<code>$self.isBig</code>) but I can't seem to figure out how to update the value once I have the publisher instead of the @Published property.</p>
<p>I'm basically just trying to treat an <code>@Published</code> as a reference and update the reference on the class instead of copying the publisher's value.</p>
<p>This is a contrived example just trying to get the point across, what I want to do is:</p>
<pre><code>import UIKit
import Combine

class MyClass {
    
    struct MyData {
        enum MyDataType {
            case big
            case yellow
            case bird
        }
        var type: MyDataType
        var isEnabled: Bool
    }
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    @Published var isBig: Bool = false
    @Published var isYellow: Bool = false
    @Published var isBird: Bool = false
    
    var mySwitch = UISwitch()
    
    init() {
        // Add mySwitch and setupSubscribers...
    }

    func updatePublishers(from data: MyData) {
        let publisherForData = specificPublisherForData(data)
        // I want to access the underlying value for the @Published and set it here
//        publisherForData = data.isEnabled
    }

    func specificPublisherForData(_ data: MyData) -&gt; Published&lt;Bool&gt;.Publisher {
        switch data.type {
        case .big: return self.$isBig
        case .yellow: return self.$isYellow
        case .bird: return self.$isBird
        }
     }
    
    func setupSubscribers() {
        $isBig.sink { [weak self] isBig in
            guard let self = self else { return }
            
            self.mySwitch.isOn = isBig
        }.store(in: &amp;cancellables)
        
        // ... add subscribers for the other ones
    }
}
</code></pre>
","2338279","","560942","","2022-01-14 21:55:58","2022-01-14 21:58:47","Get reference for an @Published that can update the value","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"70720545","1","","","2022-01-15 10:17:48","","-1","166","<p>I am quite new using Combine and frankly I don't know whether this question is silly or not, anyway I have a publisher which I then return to the caller with an array of objects retrieved from a RESTful operation in the following way:</p>
<pre><code>       let publisher = URLSession.shared.dataTaskPublisher(for: URL)
        .handleEvents(
            receiveSubscription: { _ in
                activityIndicatorPublisher.send(true)
            }, receiveCompletion: { _ in
                activityIndicatorPublisher.send(false)
            }, receiveCancel: {
                activityIndicatorPublisher.send(false)
            })
        .tryMap { data, response -&gt; Data in
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                      throw NetworkError.httpError
                  }
            print(String(data: data, encoding: .utf8) ?? &quot;&quot;)
            return data
        }
        .decode(type: [ShowElement].self, decoder: JSONDecoder())
        .flatMap { $0.publisher }
        .map(\.show?.image?.medium)
        .flatMap(maxPublishers:.max(1)) { url in
            URLSession.shared.dataTaskPublisher(for: url)
                .map(\.data)
                .replaceError(with: Data())
        }
        .map{ imageData, item -&gt; ShowElement in
            var mutableItem = item
            mutableItem.imageData = imageData
            return mutableItem
        }
        .collect()
        .catch { error -&gt; Just&lt;[ShowElement]&gt; in
            print(error)
            return Just([])
        }
        .eraseToAnyPublisher()
    return publisher
}
</code></pre>
<p>When I do the dataTaskPublisher I receive the error: &quot;No exact match in call to instance methode dataTaskPublisher, and when I do the mapping of the imageData I receive another error: &quot;Contextual closure type '(Publishers.FlatMap&lt;Publishers.SetFailureType&lt;Publishers.ReplaceError&lt;Publishers.MapKeyPath&lt;URLSession.DataTaskPublisher, Data&gt;&gt;, Error&gt;, Publishers.MapKeyPath&lt;Publishers.FlatMap&lt;Publishers.SetFailureType&lt;Publishers.Sequence&lt;[ShowElement], Never&gt;, Error&gt;, Publishers.Decode&lt;Publishers.TryMap&lt;Publishers.HandleEvents&lt;URLSession.DataTaskPublisher&gt;, JSONDecoder.Input&gt;, [ShowElement], JSONDecoder&gt;&gt;, String?&gt;&gt;.Output) -&gt; ShowElement' (aka '(Data) -&gt; ShowElement') expects 1 argument, but 2 were used in closure body&quot;</p>
","720648","","720648","","2022-01-16 05:43:27","2022-01-20 00:49:48","Combine, retrieve array of images from array of URLs and assign them to corresponding object","<json><swift><asynchronous><combine>","1","0","","","","CC BY-SA 4.0"
"70727200","1","","","2022-01-16 03:40:02","","2","371","<p>I'm trying to leverage combine when making some API calls and I'm at a loss for why the sink methods are not being called.</p>
<p>I've included what I believe are all the relevant parts of the code and also the output in the logs.</p>
<p>What should I be doing differently?</p>
<pre class=""lang-swift prettyprint-override""><code>    private var authorization: GTMAppAuthFetcherAuthorization?
    private let service = GTLRGmailService()
    private var cancellables = Set&lt;AnyCancellable&gt;()

...

    private func executeQuery(query: GTLRGmailQuery) -&gt; AnyPublisher&lt;Any, Error&gt; {
        print(&quot;in executeQuery&quot;)
        return Future&lt;Any, Error&gt; { promise in
            self.service.executeQuery(query) {ticket, result, error in
                if let error = error {
                    return promise(.failure(error))
                } else {
                    print (&quot;GOT ME SOME RESULTS&quot;)
                    print(result!)
                    return promise(.success(result!))
                }
            }
        }.eraseToAnyPublisher()
    }
    
    func getThreads() {
        print(&quot;in getThreads&quot;)
        let query = GTLRGmailQuery_UsersThreadsList.query(
            withUserId: authorization?.userEmail ?? &quot;me&quot;
        )
        
        print(&quot;getting threads&quot;)
        self.executeQuery(query: query)
            .sink(
                receiveCompletion: { completion in
                    print(&quot;GOT COMPLETION&quot;)
                    print(completion)
                    switch completion {
                    case .failure(let error):
                        print(&quot;ERROR EXECUTING QUERY&quot;)
                        print(error)
                    case .finished:
                        break
                    }
                },

                receiveValue: { value in
                    print(&quot;VALUE FROM QUERY&quot;)
                    print(value)
                }
            )
            .store(in: &amp;cancellables)
    }
</code></pre>
<p>Log output:</p>
<pre><code>in getThreads
getting threads
in executeQuery
2022-01-15 22:27:57.875615-0500 mail[30582:6728076] GTMSessionFetcher invoking fetch callbacks, data {length = 32719, bytes = 0x7b227468 72656164 73223a5b 7b226964 ... 7465223a 3533387d }, error (null)
2022-01-15 22:27:57.878231-0500 mail[30582:6728134] Executing GTLRGmailQuery_UsersThreadsList has additional pages of results not fetched because shouldFetchNextPages is not enabled
GOT ME SOME RESULTS
GTLRGmail_ListThreadsResponse 0x600000c4fc30: {nextPageToken:&quot;...&quot; resultSizeEstimate:538 threads:[100]}
</code></pre>
","568398","","568398","","2022-01-16 21:16:24","2022-01-16 21:16:24","receiveCompletion and receiveValue are not being called","<ios><swift><macos><combine>","1","3","1","","","CC BY-SA 4.0"
"70736625","1","70740875","","2022-01-17 04:44:31","","0","133","<p>Could anyone please help me with configuring the Firebase signInAnonymously? In fact, I am able to login anonymously. However, whenever I start a new simulator I get the error &quot;There is no user logged in&quot;. The error disappears when restarting this new simulator, and then I am able to get the userId.</p>
<p>This is my initial code:</p>
<pre><code>import SwiftUI
import Firebase

@main
struct DyeNotesApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    var body: some Scene {
        WindowGroup {
            ContentView() 
        }
    }
}

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions laychOptions:
        [UIApplication.LaunchOptionsKey : Any]? = nil) -&gt; Bool {
        
        FirebaseApp.configure()
            if Auth.auth().currentUser == nil {
                Auth.auth().signInAnonymously()
            }
        
        return true
    }
}
</code></pre>
<p>This is the class talking to Firebase:</p>
<pre><code>class MainRepository: ObservableObject {
    private let path:String = &quot;MainCollection&quot;
    private let db = Firestore.firestore()
    @Published var model:[Model] = []
    
    init() {
        getData()
    }
    
    func getData() {
        if let userId = Auth.auth().currentUser?.uid {
            db.collection(path)
                .order(by: &quot;createdTime&quot;, descending: true)
                .whereField(&quot;userId&quot;, isEqualTo: userId)
                .addSnapshotListener { (snapshot, error) in
                    if let snapshot = snapshot {
                        self.model = snapshot.documents.compactMap{ document in
                            do {
                                let x = try document.data(as: Model.self)
                                return x
                            }
                            catch {
                                print(error)
                            }
                            return nil
                        }
                    }
                }
        } else {
            print(&quot;There is no user logged in&quot;)
        }
    }
</code></pre>
<p>I found a solution in a youtube video comment: &quot; ... capture the user id change via combine and trigger the snapshot monitoring when the user changes&quot;.
But I don't know how to implement it.</p>
<p>Could anyone help me with the code for this solution? How can I implement a snapshot to monitoring when user changes?</p>
","16471331","","209103","","2022-01-17 04:58:35","2022-01-18 12:12:11","Firebase signInAnonymously using SwiftUI","<google-cloud-firestore><swiftui><firebase-authentication><combine>","2","1","","","","CC BY-SA 4.0"
"70739978","1","70743653","","2022-01-17 10:38:57","","1","715","<p>Consider the following synthetic scenario:</p>
<pre><code>import Combine

let publisher1 = PassthroughSubject&lt;Int, Never&gt;().eraseToAnyPublisher()
let publisher2 = PassthroughSubject&lt;Int, Never&gt;()


publisher1.sink { value in
    publisher2.send(value)
}

</code></pre>
<p>We have 2 publishers, I'd like to propagate any value of the <code>publisher1</code> to the <code>publisher2</code>. The code I've shown does the job, but I'm interested whether there is a cleaner, declarative approach to this.</p>
<p>Note: both <code>publisher1</code> and <code>publisher2</code> are of the same type.</p>
<p><strong>Details on the problem</strong></p>
<p><code>publisher2</code> is a part of the API that is exposed by the &quot;core&quot; class. The &quot;core&quot; class has a &quot;has a&quot; relationship to a &quot;child&quot; class which in turn has a <code>publisher1</code> as it's API.</p>
<p>Over the lifetime of the &quot;core&quot; class, the &quot;child&quot; class can be allocated and deallocated multiple times. This should be transparent to the subscribers of the &quot;core&quot; class which won't need to subscribe to the <code>publisher2</code>.</p>
<p><strong>Code:</strong></p>
<pre><code>import UIKit
import Combine


class ChildClass {
    let publisher1 = PassthroughSubject&lt;Int, Never&gt;().eraseToAnyPublisher()
}

class CoreClass {
    let publisher2 = PassthroughSubject&lt;Int, Never&gt;()

    private var childClass: ChildClass?

    init() {
        allocateChildClass()
    }

    func allocateChildClass() {
        let child = ChildClass()
        childClass = child
        // Any way to simplify this?
        child.publisher1.sink { value in
            publisher2.send(value)
        }
    }

    func deallocateChildClass() {
        childClass = nil
    }
}


class Client {
    let core = CoreClass()

    init() {
        // Doesn't care about allocating or deallocating of the ChildClass
        core.publisher2.sink { value in
            print(value)
        }
    }
}

</code></pre>
<p>Trying to subscribe one publisher to another doesn't work:</p>
<pre><code>publisher2
    .subscribe(publisher1)

</code></pre>
<blockquote>
<p>No exact matches in call to instance method 'subscribe'</p>
</blockquote>
<p><a href=""https://i.stack.imgur.com/T8OIs.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/T8OIs.png"" alt=""enter image description here"" /></a></p>
","3667264","","3667264","","2022-01-17 14:29:02","2022-01-17 15:18:18","Swift Combine: direct output of one Publisher to the input of another","<ios><swift><combine><publisher>","1","14","","","","CC BY-SA 4.0"
"70741355","1","","","2022-01-17 12:28:29","","4","218","<p>Here are the three points I want to achieve:</p>
<ol>
<li>I want to emit a specific value in a random interval</li>
<li>I want to emit only if upstream has a specific value</li>
<li>I want to cancel the random time interval and re-start it if there is a new value upstream</li>
</ol>
<p>To put it more into context:</p>
<p>I want to toggle a state on tap from A to B, B to C and then back C to A. However, if the current state is B and there is no user input, I want to toggle the state to C after a random time interval. If the current state is B and the user taps the screen, I do not want to toggle the state to C anymore, with the exception if the user toggled often enough to be on B again, in which case I would want a new random interval to be used.</p>
<p>I have some (more or less) pseudo code to clarify my problem further.</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel {
    var state: State

    private var stateSubject: CurrentValueSubject&lt;State, Never&gt;
    private var cancellables: Set&lt;AnyCancellable&gt; = []

    init(initialState: State) {
        state = initialState
        stateSubject = CurrentValueSubject(state)

        // Pipe to store new state
        stateSubject
            .sink { [unowned self] in
                self.state = $0
            }
            .store(in: &amp;cancellables)

        // Logic to switch specific state after interval

        // Approach 1
        stateSubject
            .debounce(for: .seconds(randomInterval), scheduler: RunLoop.main)
            .filter { $0 == .B }
            .sink { [unowned self] _ in
                stateSubject.send(.C)
            }
            .store(in: &amp;cancellables)

        // --------------------------------

        // Approach 2
        stateSubject
            .flatMap(maxPublishers: .max(1)) { state in
                Future { [unowned self] promise in
                    DispatchQueue.main.asyncAfter(deadline: .now() + randomInterval) {
                        promise(.success(state))
                    }
                }
            }
            .filter { $0 == .B }
            .sink { [unowned self] _ in
                stateSubject.send(.C)
            }
            .store(in: &amp;cancellables)

    }

    var randomInterval: Double { Double.random(in: 1...4) }

    // Called on tap
    func toggleState() {
        state = state.toggle()
    }
}

extension ViewModel {
    enum State {
        case A, B, C

        func toggle() -&gt; Self {
            switch self {
                case .A:
                    return .B
                case .B:
                    return .C
                case .C:
                    return .A
            }
        }
    }
}
</code></pre>
<p>Approach 1:
This seems reasonable, however, as the <code>.debounce</code> operator is only created once and therefore only accesses <code>randomInterval</code> once, resulting in always debouncing the same amount of time.</p>
<p>Approach 2:
This works fairly well, except if the user is toggling the state a little too often. I could not find the cause of the issue, but found the state toggling even on State.A</p>
<p>Thank you for your help and let me know if you have any further questions.</p>
","3809430","","3809430","","2022-01-21 15:46:19","2022-02-02 08:54:09","Emit value in random intervals if condition applies","<ios><swift><reactive><combine>","1","2","","","","CC BY-SA 4.0"
"70763820","1","70764516","","2022-01-18 23:59:35","","0","75","<p>I am totally new at using the Combine framework.
The struct I am using:</p>
<pre><code>enum AuthenticateResponse: Decodable, Hashable {
    struct Success: Decodable, Hashable {
        let url, id, firstName, lastName: String
        let email, phone: String
    }

    struct Failure: Decodable, Hashable {
        struct Errors: Decodable, Hashable {
            let code: [String]?
            let username: [String]?
            let password: [String]?
        }
        let message: String
        let errors: Errors
    }

    case success(Success)
    case failure(Failure)
    init(from decoder: Decoder) throws {
        do {
            let success = try Success(from: decoder)
            self = .success(success)
        } catch {
            let failure = try Failure(from: decoder)
            self = .failure(failure)
        }
    }
}
</code></pre>
<p>I am getting this response from server:</p>
<pre><code>failure(demo.AuthenticateResponse.Failure(
    message: &quot;Invalid data..&quot;, 
    errors: demo.AuthenticateResponse.Failure.Errors(
        code: Optional([&quot;The code does not exist.&quot;]), 
        username: nil, 
        password: nil)
    )
)
</code></pre>
<p>I am trying to get this value <code>code: Optional([&quot;The code does not exist.&quot;]),</code> from above response using combine but I couldn’t</p>
<p>I am using below code to get that value:</p>
<pre><code>func syncOnlineData() {
    print(&quot;I am here&quot;)
    viewModel.authenticateResponse
        .sink { result in
            print(&quot;result: \(result)&quot;)
        } receiveValue: { res in
            print(&quot;value: \(String(describing: res))&quot;)
        }
} 
</code></pre>
<p>main response from server:</p>
<pre><code>[&quot;errors&quot;: {
    code =     (
        &quot;The code does not exist.&quot;
    );
}, &quot;message&quot;: Invalid data.]
</code></pre>
<p>How I will get the value from <code>code</code> ?</p>
","3231139","","465446","","2022-01-19 01:57:57","2022-01-20 01:03:40","How to get unwrap value using combine framework","<json><swift><combine>","2","2","","","","CC BY-SA 4.0"
"70781918","1","","","2022-01-20 06:57:42","","0","159","<p>I would like to enable &quot;Proceed&quot; button when every checkbox buttons are selected using combine and publisher.</p>
<p>There must be the way to zip those multiple UIButtons(works on UIKit) isSelected status are all true.</p>
<p><a href=""https://i.stack.imgur.com/pM4mM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pM4mM.png"" alt=""enter image description here"" /></a></p>
","8051392","","12892553","","2022-01-20 08:59:39","2022-02-23 15:17:04","Swift Combine: is it available to obeserve zip multiple UIbuttons status?","<ios><swift><combine>","1","5","","","","CC BY-SA 4.0"
"70782894","1","70787272","","2022-01-20 08:28:17","","1","279","<p>How to make a mechanism similar to binding in the view that refers to the Published in the ObservableObject class, but between 2 classes? That is, from class A, call the class B constructor, passing the prop1 from class A. And in class B prop2 exists, and these prop1 and prop2 should mirror each other.</p>
<p>PS: Attached code does not work, just visually show what I want ...</p>
<p>PPS: prop1 in ClassA and prop2 in ClassB, must be Published by condition. It's own views are also subscribed on it.</p>
<p>PPPS: Important to have any binding logic inside the ClassB, for easy reuse.</p>
<pre><code>class ClassA: ObservableObject {
    @Published var prop1: Bool = false //When prop1 changed, it must be reflected in prop2
    let classB: ClassB

    init() {
        classB = .init(prop2: _prop1) //Should stay that simple, no setup here, passing only property, ClassB doesn't know about ClassA.
    }
}

class ClassB: ObservableObject {
    @Published var prop2: Bool //When prop2 changed, it must be reflected in prop1

    init(prop2: Published&lt;Bool&gt;) {
        _prop2 = prop2
    }
}
</code></pre>
","7147231","","7147231","","2022-01-20 15:08:29","2022-01-21 15:21:18","How to bind properties between two classes with Combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"70793168","1","70804428","","2022-01-20 20:45:33","","1","149","<p>I have a view model, that has multiple child view models. I am fairly new to watchOS, SwiftUI and Combine - taking this opportunity to learn.</p>
<p>I have a watchUI where it has</p>
<ol>
<li>Play Button (View) - <code>SetTimerPlayPauseButton</code></li>
<li>Text to show Time (View) - <code>TimerText</code></li>
<li>View Model - that has 1 <code>WatchDayProgramViewModel</code> - N: <code>ExerciseTestClass</code> - N: <code>SetInformationTestClass</code>. For each ExerciseSets, there is a <code>watchTimer &amp; watchTimerSubscription</code> and I have managed to run the timer to update remaining rest time.</li>
<li>ContentView - that has been injected the ViewModel as <code>EnvironmentObject</code></li>
</ol>
<p>If I tap <code>SetTimerPlayPauseButton</code> to start the timer, timer is running, working and changing the remainingRestTime(property within the child view model <code>SetInformationTestClass</code>) correctly, <strong>but the updates/changes are not being &quot;published&quot; to the <code>TimerText</code> View</strong>.</p>
<p>I have done most, if not all, the recommendation in other SO answers, <strong>I even made all my <code>WatchDayProgramViewModel</code> and <code>ExerciseTestClass</code>,<code>SetInformationTestClass</code> properties <code>@Published</code>, but they are still not updating the View</strong>, when the view model properties are updated as shown in the Xcode debugger below.</p>
<p><a href=""https://i.stack.imgur.com/bNYuI.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bNYuI.png"" alt=""enter image description here"" /></a></p>
<p>Please review my code and give me some advice on how to improve it.</p>
<p><em><strong>ContentView</strong></em></p>
<pre><code>struct ContentView: View {
    @State var selectedTab = 0
    @StateObject var watchDayProgramVM = WatchDayProgramViewModel()
    
    var body: some View {
        
        TabView(selection: $selectedTab) {
            
            SetRestDetailView().id(2)
    
        }
        .environmentObject(watchDayProgramVM)
        .tabViewStyle(PageTabViewStyle())
        .indexViewStyle(.page(backgroundDisplayMode: .automatic))
        
    }
}

    
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView(watchDayProgramVM: WatchDayProgramViewModel())
        }
    }
}
</code></pre>
<p><em><strong>SetRestDetailView</strong></em></p>
<pre><code>import Foundation
import SwiftUI
import Combine

struct SetRestDetailView: View {
    
    @EnvironmentObject var watchDayProgramVM: WatchDayProgramViewModel
    
    var setCurrentHeartRate: Int = 120
    @State var showingLog = false
    
    
    var body: some View {


                    HStack {
         
                        let elapsedRestTime = watchDayProgramVM.exerciseVMList[0].sets[2].elapsedRestTime
                        let totalRestTime = watchDayProgramVM.exerciseVMList[0].sets[2].totalRestTime
                        
                        TimerText(elapsedRestTime: elapsedRestTime, totalRestTime: totalRestTime, rect: rect)
                            .border(Color.yellow)

                    }
                    
                    HStack {
                        
                        SetTimerPlayPauseButton(isSetTimerRunningFlag: false,
                                                playImage: &quot;play.fill&quot;,
                                                pauseImage: &quot;pause.fill&quot;,
                                                bgColor: Color.clear,
                                                fgColor: Color.white.opacity(0.5),
                                                rect: rect) {
                            
                            print(&quot;playtimer button tapped&quot;)
                            self.watchDayProgramVM.exerciseVMList[0].sets[2].startTimer()
                            
                            
                            let elapsedRestTime = watchDayProgramVM.exerciseVMList[0].sets[2].elapsedRestTime
                            let totalRestTime = watchDayProgramVM.exerciseVMList[0].sets[2].totalRestTime
                            print(&quot;printing elapsedRestTime from SetRestDetailView \(elapsedRestTime)&quot;)
                            print(&quot;printing elapsedRestTime from SetRestDetailView \(totalRestTime)&quot;)
                            
                        }
                            .border(Color.yellow)

                    }

 }

}
</code></pre>
<p><em><strong>TimerText</strong></em></p>
<pre><code>struct TimerText: View {
    var elapsedRestTime: Int
    var totalRestTime: Int
    var rect: CGRect
    
    var body: some View {
        VStack {
            Text(counterToMinutes())
                .font(.system(size: 100, weight: .semibold, design: .rounded))
                .kerning(0)
                .fontWeight(.semibold)
                .minimumScaleFactor(0.25)
                .padding(-1)
        }
    }
    
    func counterToMinutes() -&gt; String {
        let currentTime = totalRestTime - elapsedRestTime
        let seconds = currentTime % 60
        let minutes = Int(currentTime / 60)
        
        if currentTime &gt; 0 {
            return String(format: &quot;%02d:%02d&quot;, minutes, seconds)
        }
        
        else {
            return &quot;&quot;
        }
    }
}
</code></pre>
<p><em><strong>ViewModel</strong></em></p>
<pre><code>import Combine

final class WatchDayProgramViewModel: ObservableObject {
    
    @Published var exerciseVMList: [ExerciseTestClass] = [
 (static/hard-coded values for testing)
]

class ExerciseTestClass: ObservableObject {
    
    init(exercise: String, sets: [SetInformationTestClass]) {
        
        self.exercise = exercise
        self.sets = sets
        
    }
    
        var exercise: String
        @Published var sets: [SetInformationTestClass]
    
    }

class SetInformationTestClass: ObservableObject {
    
    init(totalRestTime: Int, elapsedRestTime: Int, remainingRestTime: Int, isTimerRunning: Bool) {
        
        self.totalRestTime = totalRestTime
        self.elapsedRestTime = elapsedRestTime
        self.remainingRestTime = remainingRestTime
        self.isTimerRunning = isTimerRunning
        
    }
    
    @Published var totalRestTime: Int
    @Published var elapsedRestTime: Int
    @Published var remainingRestTime: Int
    
    @Published var isTimerRunning = false
    @Published var watchTimer = Timer.publish(every: 1.0, on: .main, in: .default)
    @Published var watchTimerSubscription: AnyCancellable? = nil
    
    @Published private var startTime: Date? = nil
    
    
    func startTimer() {
        
        print(&quot;startTimer initiated&quot;)
        self.watchTimerSubscription?.cancel()
        
        if startTime == nil {
            startTime = Date()
        }
        
        self.isTimerRunning = true
        
        self.watchTimerSubscription = watchTimer
            .autoconnect()
            .sink(receiveValue: { [weak self] _ in
                
                guard let self = self, let startTime = self.startTime else { return }
                
                let now = Date()
                let elapsedTime = now.timeIntervalSince(startTime)
                
                self.remainingRestTime = self.totalRestTime - Int(elapsedTime)
                
                self.elapsedRestTime = self.totalRestTime - self.remainingRestTime
                                                    
                guard self.remainingRestTime &gt; 0 else {
                        self.pauseTimer()
                        return
                    }

self.objectWillChange.send()
                
                print(&quot;printing elapsedRest Time \(self.elapsedRestTime) sec&quot;)
                print(&quot;printing remaining Rest time\(self.remainingRestTime)sec &quot;)
                
            })
    }
    
    func pauseTimer() {
        //stop timer and retain elapsed rest time
        
        print(&quot;pauseTimer initiated&quot;)
        self.watchTimerSubscription?.cancel()
        self.watchTimerSubscription = nil
        self.isTimerRunning = false
        self.startTime = nil
        
    }
    
        
</code></pre>
","9104286","","9104286","","2022-01-21 16:07:05","2022-01-21 16:23:11","Timer within EnvironmentObject view model not updating the View","<mvvm><swiftui><combine><observableobject><environmentobject>","1","8","0","","","CC BY-SA 4.0"
"70794156","1","","","2022-01-20 22:24:06","","0","234","<p>I have the following publisher:</p>
<pre><code>    func publisher&lt;T: NSManagedObject&gt;(for managedObject: T, in context: NSManagedObjectContext, changeTypes: [ChangeType]) -&gt; AnyPublisher&lt;(object: T, type: ChangeType), Never&gt; {

        let notification = NSManagedObjectContext.didSaveObjectIDsNotification
//        let notification = NSManagedObjectContext.didMergeChangesObjectIDsNotification
        return NotificationCenter.default.publisher(for: notification, object: context)
            .compactMap({ notification in
                for type in changeTypes {
                    if let object = self.managedObject(with: managedObject.objectID, changeType: type, from: notification, in: context) as? T {
                        return (object, type)
                    }
                }
                return nil
            })
            .eraseToAnyPublisher()
    }
</code></pre>
<p>This allows me to observe around the app a certain change type affecting a certain NSManagedObject when the object is saved on the given context. So I can either be notified of a save on that context for the object or be notified of the merge into that context. I cannot be notified for both at the same time.</p>
<p>If I want to observe the object when it changes on a different context and it is then merged into the context I pass in then I can do that by using the other notification:</p>
<pre><code>let notification = NSManagedObjectContext.didMergeChangesObjectIDsNotification
</code></pre>
<p>I would like to modify this function so that it can be used to be notified on both notifications types, meaning both on <code>NSManagedObjectContext.didSaveObjectIDsNotification</code> and <code>NSManagedObjectContext.didMergeChangesObjectIDsNotification</code> at the same time.</p>
<p>The function used inside the call is this:</p>
<pre><code>private func managedObject(with id: NSManagedObjectID, changeType: ChangeType, from notification: Notification, in context: NSManagedObjectContext) -&gt; NSManagedObject? {
    guard let objects = notification.userInfo?[changeType.userInfoKey] as? Set&lt;NSManagedObjectID&gt;, objects.contains(id) else { return nil }
    return context.object(with: id)
}
</code></pre>
<p>and ChangeType:</p>
<pre><code>enum ChangeType {
    
    case inserted, deleted, updated
    
    var userInfoKey: String {
        switch self {
        case .inserted: return NSInsertedObjectIDsKey
        case .deleted: return NSDeletedObjectIDsKey
        case .updated: return NSUpdatedObjectIDsKey
        }
    }
}
</code></pre>
<p>I tried to combine the two by creating two publishers in the function, one for each notification and then using <code>merge</code> to combine them, but, I couldn't get it working.</p>
<p>How can I combine the two notifications as publishers to be notified of both <code>NSManagedObjectContext.didSaveObjectIDsNotification</code> and <code>NSManagedObjectContext.didMergeChangesObjectIDsNotification</code> cases?</p>
","728246","","","","","2022-01-20 22:24:06","Combine two publishers in swift to observe NSManagedObjects?","<swift><core-data><combine>","0","2","","","","CC BY-SA 4.0"
"70809030","1","70814658","","2022-01-22 00:29:25","","3","460","<p>I am trying to acquaint myself with unit testing some view models in SwiftUI. The view model currently has two <code>@Published</code> boolean values that publish changes when an underlying <code>UserDefaults</code> property changes. For my unit tests, I have followed <a href=""https://www.swiftbysundell.com/tips/avoiding-mocking-userdefaults/"" rel=""nofollow noreferrer"">this guide</a> on how to setup <code>UserDefaults</code> for testing so my production values are not modified. I am able to test the default value as such:</p>
<pre><code>func testDefaultValue() {
     XCTAssertFalse(viewModel.canDoThing)
}
</code></pre>
<p>How would I go about toggling the <code>@Published</code> value then ensuring my view model has received the changes? So for instance, I have a reference to my mock user defaults in my XCTestCase. I attempted to do the following with zero success:</p>
<pre><code>func testValueTogglesToTrue() {
     defaults.canDoThing = true
     XCTAssertTrue(viewModel.canDoThing)
</code></pre>
<p>}</p>
<p>The thought being that updating the underlying user defaults value that is publishing changes to the published value in the view model will notify our view model. The above does not do anything to the view model variable. Do I need to subscribe to the publisher and use sink to accomplish this?</p>
","1009085","","1009085","","2022-01-22 03:16:51","2022-01-23 00:46:13","Unit testing SwiftUI/Combine @Published boolean values","<unit-testing><swiftui><combine>","1","1","1","","","CC BY-SA 4.0"
"70857920","1","70863905","","2022-01-26 02:04:36","","0","294","<p>I am trying to figure out why the last .eraseToAnyPublisher() is giving the aforementioned error, to me it seems all the types are well specified, aren't they?</p>
<pre><code>static func searchUsers(query: String) -&gt; AnyPublisher&lt;[UserViewModel], Never&gt; {
            // prepare URL
            let urlString = &quot;\(baseURL)/search/users?q=\(query)&quot;
            guard let url = URL(string: urlString) else  {
                return Just([]).eraseToAnyPublisher()
            }
            // get handle of native data task publisher
            let publisher = URLSession.shared.dataTaskPublisher(for: url)
                .handleEvents(
                    receiveSubscription: { _ in
                        activityIndicatorPublisher.send(true)
                    }, receiveCompletion: { _ in
                        activityIndicatorPublisher.send(false)
                    }, receiveCancel: {
                        activityIndicatorPublisher.send(false)
                    })
                .tryMap { data, response -&gt; Data in
                    guard let httpResponse = response as? HTTPURLResponse,
                          httpResponse.statusCode == 200 else {
                              throw NetworkError.httpError
                          }
                    print(String(data: data, encoding: .utf8) ?? &quot;&quot;)
                    return data
                }
                .decode(type: SearchUserResponse.self, decoder: JSONDecoder())
                .map { $0.items }
                .flatMap({ users in
                    var userViewModels = [UserViewModel]()
                    users.forEach { user in
                        userViewModels.append(contentsOf: UserViewModel(with: user))
                    }
                    return userViewModels
                })
                .catch { err -&gt; Just&lt;[UserViewModel]&gt; in
                    print(err)
                    return Just([])
                }
                .eraseToAnyPublisher() // &lt;-- HERE IS THE ERROR
            return publisher
        }
</code></pre>
","720648","","","","","2022-01-26 13:08:12","Combine conversion from model to viewModel gives error ""Type of expression is ambiguous without more context when running .eraseToAnyPublisher()","<ios><swift><combine><publisher>","1","4","","","","CC BY-SA 4.0"
"70866241","1","","","2022-01-26 15:47:51","","1","531","<p>I have a publisher which returns an array of RetailStoreSlotDay objects. I need to separate these out based on a certain property and then assign to separate publishers within the view model.</p>
<p>So, my publisher is:</p>
<pre><code>@Published var selectedDaySlot: RetailStoreSlotDay?
</code></pre>
<p>Within the RetailStoreSlotDay object I have a property called 'daytime' which is set to either:</p>
<pre><code>&quot;morning&quot;
&quot;afternoon&quot;
&quot;evening&quot;
</code></pre>
<p>I then have these separate publishers that I need to assign values to when the selectedDaySlot is amended:</p>
<pre><code>@Published var morningTimeSlots = [RetailStoreSlotDayTimeSlot]()
@Published var afternoonTimeSlots = [RetailStoreSlotDayTimeSlot]()
@Published var eveningTimeSlots = [RetailStoreSlotDayTimeSlot]()
</code></pre>
<p>At the moment, I have the following subscription set up and declared in the init of the view model:</p>
<pre><code>private func setupDeliveryDaytimeSectionSlots() {
        $selectedDaySlot
            .map { timeSlot in
                return timeSlot?.slots
            }
            .replaceNil(with: [])
            .sink(receiveValue: { slots in
                self.morningTimeSlots = slots.filter { $0.daytime == &quot;morning&quot; }
                self.afternoonTimeSlots = slots.filter { $0.daytime == &quot;afternoon&quot; }
                self.eveningTimeSlots = slots.filter { $0.daytime == &quot;evening&quot; }
            })
            .store(in: &amp;cancellables)
    }
</code></pre>
<p>This works fine, but I'm sure there must be an operator which will perform this in a more sophisticated way, whereby I can assign the values without using sink. Wondering if there is a better way around this.</p>
","7188537","","","","","2022-01-26 16:23:44","Swift Combine: Separate published array and then assign","<swift><swiftui><subscription><combine><publisher>","1","1","","","","CC BY-SA 4.0"
"70892046","1","71288172","","2022-01-28 10:16:05","","1","472","<p>I'm trying to make <code>Zip</code> two <code>Publishers</code> with two different functions, but it's not working as expected. I have a chance to one may failure and one success. but even one is successful I'm not getting a successful response in the <code>sink</code>. Here is my code, help is greatly appreciated.</p>
<pre class=""lang-swift prettyprint-override""><code>
struct ContentView: View {
    @State var buttonTapped = false
    @State var cancellable = Set&lt;AnyCancellable&gt;()

    var body: some View {
        Group {
           Text(&quot;Home&quot;)
        }.onAppear {
            Publishers.Zip(fetchData1(), fetchData2())
                .sink(receiveCompletion: { first in
                switch first {
                case .failure(let er):
                    print(er)
                case .finished:
                    print(&quot;ss&quot;)
                }
            }, receiveValue: { (a, b) in
               print(a, b)
             // Not printing success value
            }).store(in: &amp;cancellable)
        }
    }

    func fetchData1() -&gt; Future&lt;Bool, ErrorType&gt; {
        return Future { promise in
            promise(.failure(.error(&quot;fetchData1 failed&quot;)))
        }
    }
    
    func fetchData2() -&gt; Future&lt;String, ErrorType&gt; {
        return Future { promise in
            promise(.success(&quot;fetchData success &quot;))
        }
    }
}

enum ErrorType: Error {
    case error(String)
}


</code></pre>
","11997939","","","","","2022-08-24 07:52:34","How to make Combine.Zip work with failure and success of two `Publishers`","<ios><swift><combine>","2","4","","","","CC BY-SA 4.0"
"70901675","1","","","2022-01-29 01:30:26","","0","45","<p>I've been racking my head for the last day trying to figure out why I'm getting the error below.  I've tried changing from an array to a dictionary and no luck.</p>
<pre><code>failure(Swift.DecodingError.keyNotFound(CodingKeys(stringValue: &quot;datalist&quot;, intValue: nil), Swift.DecodingError.Context(codingPath: [], debugDescription: &quot;No value associated with key CodingKeys(stringValue: \&quot;datalist\&quot;, intValue: nil) (\&quot;datalist\&quot;).&quot;, underlyingError: nil)))
</code></pre>
<p>I'm using <code>Combine</code> and I can see that I'm getting data pack using Postman.</p>
<p>Here's the beginning part of my struct</p>
<pre><code>struct WelcomeList: Codable , Identifiable {
    let id = UUID()
    let datalist: [DATUMVAList]
    let links: Links
    let meta: MetaVAList
}

// MARK: - DATUMVAList
struct DATUMVAList: Codable {
    let id, type: String
    let attributes: AttributesVAList
}
</code></pre>
<p>Here's my function and I'm failing at the completion part.</p>
<pre><code>typealias vaNearbyList = [WelcomeList]

    class VAFacilityNearbyList: ObservableObject {
        struct AppError {
            // swiftlint:disable:next identifier_name
            let errorString: String
        }
    
        @Published var vaNearbyList: [WelcomeList] = []
        @Published var errorResponse: String = &quot;&quot;
        var locationIDData: [String] = []
        var cancellabes = Set&lt;AnyCancellable&gt;()
        var appError: AppError? = nil
    
        enum UserFetchError: Error {
            case badServerResponse
            case urlEmpty
            case other
        }
    
        func getNearByVAFacilitiesInfo(idArray: [String]) {
            // We need to create the URL to get the list of facilities
            var vaURL = &quot;https://sandbox-api.va.gov/services/va_facilities/v0/facilities?ids=&quot;
            for vaID in idArray {
                vaURL += &quot;,\(vaID)&quot;
            }
            print(&quot;\(#function) vaURL \(vaURL)&quot;)
    
            var URLBuilder = URLComponents(string: vaURL) //vha_659BZ,vha_544gc
            guard let url = URLBuilder?.url else { return }
    
            var request = URLRequest(url: url)
    //        request.httpMethod = &quot;GET&quot;
            request.setValue(VA_API_Key, forHTTPHeaderField: &quot;apikey&quot;)
    
            URLSession.shared.dataTaskPublisher(for: request)
                .subscribe(on: DispatchQueue.global(qos: .background))
                .receive(on: DispatchQueue.main)
                .tryMap { (returnData, response) -&gt; Data in
                    guard
                        let response = response as? HTTPURLResponse,
                          response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else {
                              self.appError = AppError(errorString: &quot;\(UserFetchError.badServerResponse)&quot;)
                              throw UserFetchError.badServerResponse
                    }
                    print(&quot;\(#function) response \(response.statusCode)&quot;)
                    print(&quot;\(#function) returning data \(returnData)&quot;)
                    return returnData
                }
                .decode(type: WelcomeList.self, decoder: JSONDecoder())
                .sink { (completion) in
                    print(&quot;\(#function) completion - \(completion)&quot;)
                } receiveValue: { [weak self] (returnedVAListData) in
                    print(&quot;\(#function) returnedData - \(returnedVAListData)&quot;)
                    self?.vaNearbyList = [returnedVAListData]
                }
                .store(in: &amp;cancellabes)
        }
    }
</code></pre>
<p>Here's the data I'm getting back.  Thanks!</p>
<pre><code>{
    &quot;data&quot;: [
        {
            &quot;id&quot;: &quot;vha_544GC&quot;,
            &quot;type&quot;: &quot;va_facilities&quot;,
            &quot;attributes&quot;: {
                &quot;name&quot;: &quot;Rock Hill VA Clinic&quot;,
                &quot;facility_type&quot;: &quot;va_health_facility&quot;,
                &quot;classification&quot;: &quot;Primary Care CBOC&quot;,
                &quot;website&quot;: &quot;https://www.columbiasc.va.gov/locations/RockHill.asp&quot;,
                &quot;lat&quot;: 34.97720057,
                &quot;long&quot;: -81.02445796,
                &quot;time_zone&quot;: &quot;America/New_York&quot;,
                &quot;address&quot;: {
                    &quot;mailing&quot;: {},
                    &quot;physical&quot;: {
                        &quot;zip&quot;: &quot;29732-1836&quot;,
                        &quot;city&quot;: &quot;Rock Hill&quot;,
                        &quot;state&quot;: &quot;SC&quot;,
                        &quot;address_1&quot;: &quot;2670 Mills Park Drive&quot;,
                        &quot;address_2&quot;: null,
                        &quot;address_3&quot;: null
                    }
                },
                &quot;phone&quot;: {
                    &quot;fax&quot;: &quot;803-325-1612&quot;,
                    &quot;main&quot;: &quot;803-366-4848&quot;,
                    &quot;pharmacy&quot;: &quot;888-651-2683&quot;,
                    &quot;after_hours&quot;: &quot;803-776-4000 x57200&quot;,
                    &quot;patient_advocate&quot;: &quot;803-776-4000 x56937&quot;,
                    &quot;mental_health_clinic&quot;: &quot;803-325-9526&quot;,
                    &quot;enrollment_coordinator&quot;: &quot;803-776-4000 x55815&quot;
                },
                &quot;hours&quot;: {
                    &quot;friday&quot;: &quot;800AM-430PM&quot;,
                    &quot;monday&quot;: &quot;800AM-430PM&quot;,
                    &quot;sunday&quot;: &quot;Closed&quot;,
                    &quot;tuesday&quot;: &quot;800AM-430PM&quot;,
                    &quot;saturday&quot;: &quot;Closed&quot;,
                    &quot;thursday&quot;: &quot;800AM-430PM&quot;,
                    &quot;wednesday&quot;: &quot;800AM-430PM&quot;
                },
                &quot;operational_hours_special_instructions&quot;: null,
                &quot;services&quot;: {
                    &quot;other&quot;: [],
                    &quot;health&quot;: [
                        &quot;Audiology&quot;,
                        &quot;Dermatology&quot;,
                        &quot;MentalHealthCare&quot;,
                        &quot;PrimaryCare&quot;,
                        &quot;SpecialtyCare&quot;
                    ],
                    &quot;last_updated&quot;: &quot;2022-01-16&quot;
                },
                &quot;satisfaction&quot;: {
                    &quot;health&quot;: {
                        &quot;primary_care_urgent&quot;: 0.7400000095367432,
                        &quot;primary_care_routine&quot;: 0.8500000238418579
                    },
                    &quot;effective_date&quot;: &quot;2021-03-05&quot;
                },
                &quot;wait_times&quot;: {
                    &quot;health&quot;: [
                        {
                            &quot;service&quot;: &quot;Audiology&quot;,
                            &quot;new&quot;: 52.25,
                            &quot;established&quot;: 2.35
                        },
                        {
                            &quot;service&quot;: &quot;Dermatology&quot;,
                            &quot;new&quot;: 0.125,
                            &quot;established&quot;: 2.333333
                        },
                        {
                            &quot;service&quot;: &quot;MentalHealthCare&quot;,
                            &quot;new&quot;: 30.17647,
                            &quot;established&quot;: 4.017241
                        },
                        {
                            &quot;service&quot;: &quot;PrimaryCare&quot;,
                            &quot;new&quot;: 14.3125,
                            &quot;established&quot;: 1.52759
                        },
                        {
                            &quot;service&quot;: &quot;SpecialtyCare&quot;,
                            &quot;new&quot;: 38.133333,
                            &quot;established&quot;: 3.304347
                        }
                    ],
                    &quot;effective_date&quot;: &quot;2022-01-16&quot;
                },
                &quot;mobile&quot;: false,
                &quot;active_status&quot;: &quot;A&quot;,
                &quot;operating_status&quot;: {
                    &quot;code&quot;: &quot;NORMAL&quot;
                },
                &quot;detailed_services&quot;: null,
                &quot;visn&quot;: &quot;7&quot;
            }
        }
    ],
    &quot;links&quot;: {
        &quot;self&quot;: &quot;https://sandbox-api.va.gov/services/va_facilities/v0/facilities?ids=vha_544GC&amp;page=1&amp;per_page=10&quot;,
        &quot;first&quot;: &quot;https://sandbox-api.va.gov/services/va_facilities/v0/facilities?ids=vha_544GC&amp;page=1&amp;per_page=10&quot;,
        &quot;prev&quot;: null,
        &quot;next&quot;: null,
        &quot;last&quot;: &quot;https://sandbox-api.va.gov/services/va_facilities/v0/facilities?ids=vha_544GC&amp;page=1&amp;per_page=10&quot;
    },
    &quot;meta&quot;: {
        &quot;pagination&quot;: {
            &quot;current_page&quot;: 1,
            &quot;per_page&quot;: 10,
            &quot;total_pages&quot;: 1,
            &quot;total_entries&quot;: 1
        },
        &quot;distances&quot;: []
    }
}
</code></pre>
","1165268","","1165268","","2022-01-29 02:07:40","2022-02-27 16:26:17","I'm racking my head and can't figure out why I'm getting No value associated with key CodingKeys error","<swift><combine>","1","5","","","","CC BY-SA 4.0"
"70922400","1","70922870","","2022-01-31 07:21:35","","1","1505","<p>I'd like to be notified the moment all Combine publishers have done their work like <code>DispatchGroup</code> and <code>.notify</code> do.</p>
<p>For example, at the below codes, I want to show <code>ProgressView</code> while publishers(<code>pub1</code>, <code>pub2</code>) doing their job.</p>
<pre><code>import Combine
import Foundation
import SwiftUI

struct SwiftUIView: View {
    @State var isFinished = false
    let pub1 = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;].publisher
    let pub2 = [&quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;].publisher
    var subscriptions = Set&lt;AnyCancellable&gt;()

    var body: some View {
        if isFinished {
            Text(&quot;Hello, World!&quot;)
        } else {
            ProgressView()
        }
    }
    
    init() {
        pub1
            .sink { print($0) }
            .store(in: &amp;subscriptions)
        pub2
            .sink { print($0) }
            .store(in: &amp;subscriptions)
        
//         Where should I write this code?
//         isFinished = true
    }
}
</code></pre>
<p><strong>My question is</strong> that how can I wait until publishers finish and show &quot;Hello world&quot; at the right time?</p>
<p>Is there anything I should know? If so, please let me know. Thank you!</p>
","11768262","","","","","2022-01-31 08:37:28","How can I wait until all Combine publishers finished their jobs in Swift?","<ios><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"70942952","1","70943016","","2022-02-01 15:14:48","","1","952","<p>Consider the following example:</p>
<pre><code>struct TestView: View {
    @Binding private var value: String
    init(value: Binding&lt;String&gt;) {
        self._value = value
    }
}
</code></pre>
<p>How can I initialize the <code>TestView</code> without any <code>Binding</code>, i.e. just bind it to an empty string (if the caller doesn't need to connect that property)?</p>
<p>Ideally I'd be able to use the <code>TestView</code> like this (sometimes):</p>
<pre><code>TestView()
</code></pre>
<p>I've tried setting a default value in the initializer, but obviously, it fails:</p>
<pre><code>init(value: Binding&lt;String&gt; = Binding&lt;Strings&gt;(&quot;&quot;)) {
</code></pre>
<p>Any approaches on how to tackle this API issue?</p>
","3667264","","","","","2022-02-01 15:19:17","SwiftUI: Binding in initializer: default value","<ios><swift><swiftui><binding><combine>","1","0","","2022-02-01 15:50:40","","CC BY-SA 4.0"
"70993274","1","70993353","","2022-02-04 21:57:20","","0","763","<p>I am subscribing to a @Published array in my view model so I can .map every object appended as an array of PostAnnotations...</p>
<p>I am not able to map the post array into an array of PostAnnotations and get the error:</p>
<p><strong>ERROR MESSAGE: Declared closure result '()' is incompatible</strong></p>
<p>What am I doing wrong??</p>
<pre><code>class UserViewModel: ObservableObject {
    var subscriptions = Set&lt;AnyCancellable&gt;()
    let newPostAnnotationPublisher = PassthroughSubject&lt;[PostAnnotation], Never&gt;()

    @Published var currentUsersPosts: [Posts] = []
  
    func addCurrentUsersPostsSubscriber() {
        $currentUsersPosts
             // convert each post into a PostAnnotation
            .map { posts -&gt; [PostAnnotation] in
                 // ^ERROR MESSAGE: Declared closure result '()' is incompatible 
                //with contextual type '[SpotAnnotation]'
                posts.forEach { post in
                    let postAnnotation = PostAnnotation(post: post)
                    return postAnnotation
                }
            }
            .sink { [weak self] postAnnotations in
                guard let self = self else { return }
                // send the array of posts to all subscribers to process
                self.newPostAnnotationsPublisher.send(postAnnotations)
            }
            .store(in: &amp;subscriptions)
    }

     func loadCurrentUsersPosts() {
         PostApi.loadCurrentUsersPosts { response in
             switch response {
             case .success(let posts):
                 self.currentUsersPosts.append(contentsOf: spots)
             case .failure(let error):
                 //////
             }
         }
     }

}
</code></pre>
","16636751","","","","","2022-02-04 22:06:27","Map array of objects into another array with Combine not working?","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"70994774","1","70994804","","2022-02-05 02:08:47","","2","343","<p>I'm trying to trigger an alert when is an error in the model but it never get updated to show the alert:</p>
<p>Here is my implementation in the view:</p>
<pre><code>struct ContentView: View {
    @ObservedObject var viewModel: ViewModel
    @State var showAlert = false
    init() {
        viewModel = ViewModel()
        showAlert = viewModel.showAlert
    }
    var body: some View {
        NavigationView {
            Text(&quot;Hello, world!&quot;)
                .padding()
        }
        .alert(isPresented: $showAlert) {
            Alert(title: Text(&quot;This works&quot;),
                  message: Text(&quot;Hello&quot;),
                  dismissButton: .default(Text(&quot;got it&quot;))
        )}
    }
}
</code></pre>
<p>Here is my models:</p>
<pre><code>class ViewModel: ObservableObject {
    @Published var showAlert = false
    var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        DoSomething.shared.showAlert.sink { _ in
            print(&quot;got new Value&quot;)
        } receiveValue: {[weak self] value in
            print(&quot;value&quot;)
            self?.showAlert = value
        }.store(in: &amp;cancellables)
    }
}
class DoSomething {
    let showAlert = PassthroughSubject&lt;Bool, Never&gt;()
    static let shared = DoSomething()
    private init() {
        checkToShowAlert()
    }
    func checkToShowAlert() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) { [weak self] in
            print(&quot;change value&quot;)
            self?.showAlert.send(true)
        }
    }
}
</code></pre>
<p>Any of you knows why the <code>showAlert</code> variable it never gets updated?</p>
<p>I'll really appreciate your help</p>
","2924482","","","","","2022-09-06 15:13:37","SwiftUI: @State variable never get updated from @Published","<ios><swift><swiftui><combine><xcode13.2>","2","0","","","","CC BY-SA 4.0"
"71021492","1","","","2022-02-07 15:54:39","","-2","52","<p>I have an token publisher. It returns a token value as string. I want to make a request using this token in request publisher. I have no idea how to do it. Maybe these codes will help.</p>
<p>Token Transactions:</p>
<pre><code>// Token Publisher
func getAccessToken() -&gt; AnyPublisher&lt;String, Error&gt; {
    let url = &quot;it doesn't matter&quot;
    var urlRequest = URLRequest(url: url)
    // some url request setups
    // ...
    return URLSession.shared
        .dataTaskPublisher(for: urlRequest)
        .map(\.data)
        .decode(type: AccessToken.self, decoder: JSONDecoder())
        .map({ $0.token ?? &quot;&quot; })
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p>Generic Request Transactions:</p>
<pre><code>// Request Publisher (The T is decodable generic type.)
func request&lt;T: Decodable&gt;(ofType: T.Type, apiURL: APIURL, method: HTTPMethods) -&gt; AnyPublisher&lt;T, Error&gt; {
    // This flatMap is not invoked. :/
    AuthManager.shared.getAccessToken()
        .flatMap({ accessToken -&gt; AnyPublisher&lt;T, Error&gt; in
            guard let url = URL(string: apiURL.url) else {
                return Fail(error: NSError(domain: &quot;Missing API URL&quot;, code: -10001, userInfo: nil)).eraseToAnyPublisher()
            }
            var urlRequest = URLRequest(url: url)
            urlRequest.httpMethod = method.rawValue
            urlRequest.setValue(&quot;Authorization&quot;, forHTTPHeaderField: &quot;Bearer &quot; + accessToken)
            return URLSession.shared
                .dataTaskPublisher(for: urlRequest)
                .map(\.data)
                .decode(type: T.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
        }).eraseToAnyPublisher()
}
</code></pre>
<p>Example Request Transactions:</p>
<pre><code>// Example Request
private var cancellables = Set&lt;AnyCancellable&gt;()

func getExampleRequest(id: String) {
    let url = &quot;it doesn't matter&quot;
    APIManager.shared.request(ofType: ExampleModel.self, apiURL: url, method: .get).sink { completion in
        switch completion {
        case .finished:
            break
        case .failure(let error):
            print(error)
        }
    } receiveValue: { exampleModelData in
        // print(exampleModelData)
    }.store(in: &amp;cancellables)
}
</code></pre>
<p>Thanks in advance.</p>
","11769979","","","","","2022-02-11 12:04:07","How to merge two publishers with Combine?","<ios><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"71021923","1","","","2022-02-07 16:26:50","","1","579","<p>I'm an experienced RxSwift user, and had a good working MVVM structure in RxSwift. I'm new to Combine, but I can't for the love of God figure out how to do something similar in Combine. The biggest blocker is a <code>bind(to:)</code> equivalent in Combine. I don't know how to chain the result of 1 variable to another.</p>
<p>Here is what I would do in RxSwift:</p>
<pre><code>protocol UseCase {
  func execute(id: Int) -&gt; Single&lt;CustomClass&gt;
}

class DefaultUseCase: UseCase {
  func execute(id: Int) -&gt; Single&lt;CustomClass&gt; {
    // Do network call and return in Single format
  }
}


class ViewModel {

  struct Input {
    let load = PublishRelay&lt;Void&gt;()
  }

  struct Output {
    let isButtonEnabled: Driver&lt;Bool&gt;
  }

  let disposeBag = DisposeBag()
  let input = Input()
  let output: Output

  init(id: Int, useCase: UseCase = DefaultUseCase()) {
    let isButtonEnabled = BehaviorRelay&lt;Bool&gt;(value: false)

    let action = Action&lt;Void, CustomClass&gt; { id in 
      return useCase.execute(id: id)
    }

    self.output = Output(isButtonEnabled: isButtonEnabled.asDriver())

    input
      .load
      .bind(to: useCase.inputs)
      .disposed(by: disposeBag)

    action
      .elements
      .map { // map CustomClass to Bool }
      .bind(to: isButtonEnabled)
      .disposed(by: disposeBag)
  }
}
</code></pre>
<p>The action class is from this framework: <a href=""https://github.com/RxSwiftCommunity/Action"" rel=""nofollow noreferrer"">https://github.com/RxSwiftCommunity/Action</a></p>
<p>I cannot figure out how to do something similar in Combine, I've already read some tutorials, but it doesn't make sense to me. It looks like you need what feels like a thousand variables to just put through 1 value to your view/viewController with a viewModel.</p>
<p>I a seeking a piece of code that does exactly the same as the piece of RxSwift code above, but in Combine with some explanation.</p>
","4347007","","472495","","2022-03-13 07:38:00","2022-07-09 05:43:46","Combine equivalent of RxSwift's bind(to:)","<swift><mvvm><rx-swift><combine>","2","11","","","","CC BY-SA 4.0"
"71035657","1","","","2022-02-08 14:32:25","","0","46","<p>I have <em>RestManager</em> class which is used to fetch data from Internet</p>
<pre><code>class RestManager {

func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;T, ErrorType&gt; {
 
     URLSession.shared
        .dataTaskPublisher(for: url)
        .map { $0.data }
        .decode(type: T.self, decoder: JSONDecoder())
        .mapError({ error in
            if let error = error as? URLError {
                switch error.code {
                case .notConnectedToInternet, .timedOut, .networkConnectionLost:
                    return .noInternetConnection
                case .cannotDecodeRawData, .cannotDecodeContentData:
                    return .empty
                default:
                    return .general
                }
            }
            return .general
        })
        .eraseToAnyPublisher()
}
}
</code></pre>
<p>In Repository class there is function <em>getCountriesList</em> which, using <em>RestManager</em> is returning <em>AnyPublisher&lt;[Country], ErrorType&gt;</em> where <em>ErrorType</em> represents enum with custom cases for error handling (.noInternetConnection, .general, .empty)</p>
<pre><code>class Covid19RepositoryImpl: Covid19Repository {

func getCountriesList() -&gt; AnyPublisher&lt;[Country], ErrorType&gt; {
    let url = RestEndpoints.countriesList.endpoint()
    return RestManager().fetchData(url: url)
}
}
</code></pre>
<p>In viewModel class, in function <em>getAllCountries</em>, pipeline is created for fetching and saving data in <em>countries</em> variable, and in <em>.sink</em> in <em>completion</em> I tried to save <em>ErrorType</em> (if there is any error) in specific variable called <em>error</em></p>
<p>I tried to use like this</p>
<pre><code>class CountriesViewModelImpl: CountriesViewModel {

var repository: Covid19Repository

@Published var countries: [Country] = []
@Published var error: ErrorType?
@Published var loader: Bool = true

private var cancellables: Set&lt;AnyCancellable&gt; = .init()

init(repository: Covid19Repository){
    self.repository = repository
    getAllCountries()
}

func getAllCountries() {
            
   repository
        .getCountriesList()
        .receive(on: RunLoop.main)
        .sink { error in
            self.error = error
            }
        } receiveValue: { [unowned self] newCountries in
            self.countries = newCountries
            self.error = nil
            self.loader = false
        }
        .store(in: &amp;cancellables)
}
}
</code></pre>
<p>But it returns <em>Cannot assign value of type 'Subscribers.Completion' to type 'ErrorType'</em></p>
<p>Is there any other way I can handle error?</p>
","16366914","","","","","2022-02-08 14:43:10","custom error type handling after receiving data from internet","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"71050664","1","71050850","","2022-02-09 13:43:18","","0","32","<p>In RestManager class, using URLSession I want to return <em>AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;</em>.</p>
<p>So I made this code</p>
<pre><code>class RestManager {

func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt; {
    
    return Future&lt;Result&lt;T, ErrorType&gt;, Never&gt; { promise in
        URLSession
            .shared
            .dataTask(with: url) { data, response, error in
                if let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 {
                    if let data = try? JSONDecoder().decode(T.self, from: data!){
                        promise(.success(.success(data)))
                    }else {
                        promise(.success(.failure(.empty)))
                    }
                }
                else if let error = error as? URLError {
                    switch error.code {
                    case .notConnectedToInternet, .networkConnectionLost, .timedOut:
                        promise(.success(.failure(.noInternetConnection)))
                    case .cannotDecodeRawData, .cannotDecodeContentData:
                        promise(.success(.failure(.empty)))
                    default:
                        break
                }
                }else {
                    promise(.success(.failure(.general)))
                }
            }
    }
    .eraseToAnyPublisher()
}
}
</code></pre>
<p>But when I call this function in viewModel it returns empty array, but there is not any error thrown.
I used breakpoints on <em>if</em> and <em>else</em> statements and program is actually not executing them.</p>
","16366914","","12299030","","2022-02-09 13:57:42","2022-02-09 13:57:42","dataTask in networking is not executing","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71058511","1","71330621","","2022-02-10 00:40:48","","-1","189","<p>I have customized UITextfield which has clear textfield button on right accessory view.
clearbutton has textfield.text.removeAll() or textfield.text = &quot;&quot;</p>
<p>To monitor text changing on this textfield, I have added textPublisher like this.</p>
<pre><code>var textPublisher: AnyPublisher&lt;String, Never&gt; {
    NotificationCenter.default.publisher(
        for: UITextField.textDidChangeNotification,
        object: self
    )
    .compactMap { ($0.object as? UITextField)?.text }
    .eraseToAnyPublisher()
}
</code></pre>
<p>I would take UIButton enable assign with textfield text length.</p>
<pre><code>let button = UIButton()

textPublisher.sink { text in
     button.isEnabled = text.count &gt;= 2
}.store(in: &amp;cancellableSet)
</code></pre>
<p>This code is worked on UIKeyboardAction but not working on redeclare UITextfield.text programmatically. like clear button action what I added.
seems textDidChangeNotification event not fired when I put textfield.text = &quot;&quot;</p>
<p>where should I adapt combine publisher to monitor UITextfield text changed?</p>
","8051392","","","","","2022-03-03 00:00:58","where should I adapt combine publisher to monitor UITextfield text changed?","<swift><uitextfield><combine>","1","2","","","","CC BY-SA 4.0"
"71060365","1","71087788","","2022-02-10 05:49:49","","3","396","<p>Based on this answer: <a href=""https://stackoverflow.com/questions/62544115/what-is-the-difference-between-observedobject-and-stateobject-in-swiftui"">What is the difference between ObservedObject and StateObject in SwiftUI</a></p>
<p>And the Apple documentation code here: <a href=""https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/swiftui/managing-model-data-in-your-app</a></p>
<p>In SwiftUI app, a <code>@StateObject</code> property wrapper should be used when a <code>View</code> instantiates the object itself, so that the object won't be recreated during a view update.</p>
<p>If the object is instantiated somewhere else, an <code>@ObservedObject</code> wrapper should be used instead.</p>
<p>However, there is a fine line which makes it a bit unclear: what if the object is instantiated somewhere else, but &quot;injected&quot; to the <code>View</code> and then the view is the sole owner / holder of that object? Should it be <code>@StateObject</code> or <code>@ObservedObject</code>?</p>
<p>Sample code to get the point illustrated:</p>
<pre><code>import SwiftUI
import Combine
import Foundation


struct ViewFactory {
    func makeView() -&gt; some View {
        let viewModel = ViewModel()
        return NameView(viewModel)
    }
}


final class ViewModel: ObservableObject {
    @Published var name = &quot;&quot;
    init() {}
}


struct NameView: View {

    // Should this be an `@ObservedObject` or `@StateObject`?
    @ObservedObject var viewModel: ViewModel

    init(_ viewModel: ViewModel) {
        self.viewModel = viewModel
    }

    var body: some View {
        Text(viewModel.name)
    }
}
</code></pre>
<p>Based on this article: <a href=""https://www.hackingwithswift.com/quick-start/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject"" rel=""nofollow noreferrer"">https://www.hackingwithswift.com/quick-start/swiftui/whats-the-difference-between-observedobject-state-and-environmentobject</a></p>
<p>There is one important difference between @StateObject and @ObservedObject, which is ownership – which view created the object, and which view is just watching it.</p>
<p><em>The rule is this: whichever view is the first to create your object must use @StateObject, to tell SwiftUI it is the owner of the data and is responsible for keeping it alive. All other views must use @ObservedObject, to tell SwiftUI they want to watch the object for changes but don’t own it directly.</em></p>
<p>it appears that if the <code>View</code> to instantiate the <code>ViewModel</code>, it has to be declared with <code>@StateObject</code>. My code is very similar, the only difference is that the <code>ViewModel</code> is created elsewhere, but the <code>View</code> &quot;owns&quot; it after the initialization.</p>
","3667264","","","","","2022-02-11 23:53:08","@StateObject vs @ObservedObject when passed externally but owned by the view","<ios><swift><xcode><swiftui><combine>","1","10","","","","CC BY-SA 4.0"
"71064735","1","71069201","","2022-02-10 11:59:33","","0","680","<p>I need to apply some validations in my form like remove <em>special character</em>, accept only <em>number</em>, <em>alphabets</em>, <em>alphanumeric</em>, and only specific <em>length</em> of a string.</p>
<p>I have many text fields, in many places in my app. So that I'm creating extensions to Binding, and trying to apply conditions when editing.</p>
<p>These filters/conditions using for <code>@State</code>, <code>@Published</code>, and <code>@Binding</code> variables.</p>
<p>Here is my code:</p>
<pre class=""lang-swift prettyprint-override""><code>
struct ContentView: View {
    @State var name = &quot;&quot;
    var body: some View {
        InputField(text: $name)
    }
}

struct InputField: View {
    @Binding var text: String
    var body: some View {
        VStack {
            TextField(&quot;Name here...&quot;, text: $text.limit(6).alphaNumeric)
                .frame(maxWidth: .infinity, minHeight: 48,  alignment: .leading)
        }.padding()
    }
}

extension Binding where Value == String {
    
    var alphaNumeric: Binding&lt;String&gt; {
        Binding&lt;String&gt;(get: { self.wrappedValue },
                        set: {
            self.wrappedValue = $0.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)})
    }
    
    func limit(_ length: Int) -&gt; Binding&lt;String&gt; {
        Binding&lt;String&gt;(get: { self.wrappedValue },
                        set: {
            print($0.prefix(length))
            self.wrappedValue = String($0.prefix(length))
        })
    }
}
</code></pre>
<p>Here in the above code <code>$text.limit(6).alphaNumeric</code>, I'm trying to limit the <strong>length</strong> to <strong>6 characters</strong> and only allow the <strong>alphaNumeric</strong> string.</p>
","11997939","","11997939","","2022-02-10 16:30:00","2022-02-10 19:20:25","How to remove special characters from the `TextField` in SwiftUI","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"71096170","1","71096196","","2022-02-12 21:52:55","","0","703","<p>Have the following situation.  I have a view model that is an observable object with a computed property of type Bool.  I want to be able to enable/disable a navigation link based on the computed property, but I need a binding to do so.  Here a simplified example:</p>
<pre><code>struct Project {
    var name: String
    var duration: Int
}

class MyViewModel: Observable Object {
    @Published var project: Project

    var isProjectValid: Bool {
        return project.name != &quot;&quot; &amp;&amp; project.duration &gt; 0
    }
}

struct MyView: View {
    @EnvironmentObject var myVM: MyViewModel

    var body: some View {
        ...
        NavigationLink(&quot;Click Link&quot;, isActive: ?????, destination: NextView())
        ...
    }
}
</code></pre>
<p>Since isActive expects a binding I am not able to access computed property such as myVM.isProjectValid.  Tried also with the computed property in project class, still same problem.</p>
<p>Also considered creating custom binding related to the computed property, but not quite sure if/how to go about it.</p>
<p>First question I have posted, so if I am missing some details please be kind :)</p>
","10303930","","10303930","","2022-02-12 22:09:18","2022-02-13 00:09:01","Swift binding to a computed property","<swift><swiftui><binding><combine><computed-properties>","2","0","1","","","CC BY-SA 4.0"
"71097740","1","71097813","","2022-02-13 03:44:50","","0","1120","<p>If I have an array:</p>
<pre class=""lang-swift prettyprint-override""><code>var arr = [0,1,2]
</code></pre>
<p>And a Combine publisher for it:</p>
<pre class=""lang-swift prettyprint-override""><code>arr.publisher
    .sink { completion in print(&quot;Completed with \(completion)&quot;)
    } receiveValue: { val in
        print(&quot;Received value \(val)&quot;)
    }
arr.append(3)
</code></pre>
<p>Why does it finish right away with:</p>
<pre class=""lang-swift prettyprint-override""><code>Received value 0
Received value 1
Received value 2
Completed with finished
</code></pre>
<p>How can I make Combine execute the code every time I append values to the array?</p>
","17421862","","","","","2022-02-13 04:00:45","How to observe array's new values with combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71105944","1","71106071","","2022-02-14 00:09:26","","3","1354","<p>I'd like to trigger a &quot;change&quot; event on every change of either the <code>username</code> or <code>password</code> published properties and set a new <code>Credentials</code> published property derived of those two and emit an event.</p>
<p>What would be the simplest solution to achieve this result using SwiftUI &amp; Combine?</p>
<p>Some sample code with the idea I'm trying to achieve:</p>
<pre><code>import SwiftUI
import Combine
import Foundation

struct Credentials {
    let username: String
    let password: String

    init(username: String = &quot;&quot;,
         password: String = &quot;&quot;) {
        self.userName = username
        self.password = password
    }
}

final class ViewModel: ObservableObject {
    @Published var username = &quot;&quot;
    @Published var password = &quot;&quot;

    @Published var credentials = Credentials()


    init() {
        [$username, $password]// ..... What to do here? 
// How to &quot;subscribe&quot; each of those properties to emit an event
// so that I get notified each time one of them changes

        credentials = Credentials(username: $username, password: $password)
    }
}

</code></pre>
<p>Essentially, I'm looking to something similar to this answer:
<a href=""https://stackoverflow.com/questions/56782078/swift-combine-how-to-create-a-single-publisher-from-a-list-of-publishers"">Swift Combine: How to create a single publisher from a list of publishers?</a></p>
<p>But with the notification should be triggered each time any of the publishers produce a value, not all of them.</p>
","3667264","","3667264","","2022-02-14 00:14:53","2022-02-14 00:38:14","Combine publishers: notify when ANY of the publishers changes a value","<swift><swiftui><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"71121496","1","71164243","","2022-02-15 05:30:26","","1","167","<p>I want to observe changes on <strong>UISearchController</strong>'s text, here is my setup (and I'm pretty new to <code>Combine</code>):</p>
<pre><code>private var searchQuery: String? {
    didSet {
        print(searchQuery)
    }
}

private var disposable: AnyCancellable?


func bindSearchQuery() {
    disposable = searchController.searchBar.publisher(for: \.text)
        .debounce(for: .milliseconds(300), scheduler: DispatchQueue.main)
        .sink { value in
            if let _value = value {
                self.searchQuery = _value
            }
        }
}
</code></pre>
<p>And I see this once only in the console, on load:</p>
<blockquote>
<p>Optional(&quot;&quot;)</p>
</blockquote>
","689779","","11905533","","2022-02-15 15:54:12","2022-02-17 19:24:09","Combine: Publisher sends text change even once","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"71149340","1","71200554","","2022-02-16 21:13:58","","-3","127","<p>Hi I'm fetching data from a local api in a <code>LocationsDataService</code> class and assigning this as a <code>@Published var</code> in the data service and then using this in my <code>LocationsViewModel</code>. If I wait for my api request to complete, for example;</p>
<pre><code> DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
            let locations = dataService.locations
            self.locations = locations
        }
</code></pre>
<p>Then the locations are rendered on the screen.</p>
<p>This is my data service class;</p>
<pre><code>//
//  LocationsDataService.swift
//  MapTest
//
//

import Foundation
import MapKit
import Combine

class LocationsDataService: ObservableObject {
    
    let token = &quot;2|asOnUG27uCrcVuGxOO65kS25mX0nUSls5ApfemQy&quot;;
    @Published var locations: [Location] = []
    public var cancellable: AnyCancellable?
    enum HTTPError: LocalizedError {
        case statusCode
    }
    
    init() {
        fetch()
    }
    
    func fetch() {
        
        guard let url = URL(string: &quot;http://localhost:8080/api/locations&quot;) else {
            print(&quot;Invalid url...&quot;)
            return
        }
        var urlRequest = URLRequest(
            url: url
        )
        urlRequest.setValue(
            &quot;Bearer \(token)&quot;,
            forHTTPHeaderField: &quot;Authorization&quot;
        )
        
        self.cancellable = URLSession.shared.dataTaskPublisher(for: urlRequest)
                .tryMap { output in
                    guard let response = output.response as? HTTPURLResponse, response.statusCode == 200 else {
                        throw HTTPError.statusCode
                    }
                    return output.data
                }
                .decode(type: [Location].self, decoder: JSONDecoder())
                .receive(on: DispatchQueue.main)
                .eraseToAnyPublisher()
                .sink(receiveCompletion: { completion in
                    switch completion {
                    case .finished:
                        break
                    case .failure(let error):
                        fatalError(error.localizedDescription)
                    }
                }, receiveValue: { locations in
                    self.locations = locations
                })
        
    }
    
}
</code></pre>
<p>And this is my view model</p>
<pre><code>//
//  LocationsViewModel.swift
//  CoffeeShops
//
//

import Foundation
import MapKit
import SwiftUI

class LocationsViewModel: ObservableObject {
    
    // all loaded locations
    @Published var locations: [Location]
    
   
    init() {
        let dataService = LocationsDataService() // the init function will do the api call
        
        self.locations = [Location(
            name: &quot;Amsterdam&quot;,
            address: &quot;Amsterdam&quot;,
            latitude: 52.3721009,
            longitude:  4.8912196,
            description: &quot;Amsterdam&quot;,
            imageNames: [],
            link: &quot;https://en.wikipedia.org/wiki/Colosseum&quot;)]
        

        DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
            let locations = dataService.locations
            self.locations = locations
            print(locations)
        }
        
    }
    

}
</code></pre>
<p>I'm not sure why I need to explicitly wait for the api before assigning it to the locations in the <code>LocationsViewModel</code> as the <code>LocationsDataService.locations</code> is <code>@Published var locations: [Location] = []</code>, therefore I thought it would be observed. Obviously it wouldn't be great to have to put in a time limit before I can update the screen as it could be done in 1 second or 5 seconds. Any ideas what I'm doing wrong?</p>
","1165028","","3585796","","2022-02-21 09:12:29","2022-02-21 09:12:29","Swift api observable not working without wait","<ios><swift><observable><combine>","1","2","","","","CC BY-SA 4.0"
"71167519","1","","","2022-02-18 01:49:50","","1","70","<p>I'm not really sure how to properly title the question, so hopefully it is made clear here.</p>
<p>the use case is mostly hypothetical at the moment, but if I have an array of published objects where <code>Child</code> is itself an <code>ObservableObject</code>:</p>
<pre><code>@Published var children: [Child]
</code></pre>
<p>then, if I update an individual <code>Child</code>'s property which is also published, I'd like the publisher to fire.</p>
<p>(if we use value types, it triggers the entire array and functions easily, this is best for most solutions in my experience)</p>
<p>TestCase</p>
<pre><code>import XCTest
import Combine

final class CombineTests: XCTestCase {
    final class RefChild: ObservableObject {
        @Published var name: String = &quot;&quot;
    }
    
    struct ValueChild {
        var name: String = &quot;&quot;
    }
    
    final class Parent: ObservableObject {
        @Published var refChildren: [RefChild] = []
        @Published var refNames: String = &quot;&quot;
        
        @Published var valueChildren: [ValueChild] = []
        @Published var valueNames: String = &quot;&quot;
        
        init() {
            $refChildren.map { $0.map(\.name).joined(separator: &quot;.&quot;) } .assign(to: &amp;$refNames)
            $valueChildren.map { $0.map(\.name).joined(separator: &quot;.&quot;) } .assign(to: &amp;$valueNames)
        }
    }
    
    func testChildPublish() {
        let parent = Parent()
        parent.refChildren = .init(repeating: .init(), count: 5)
        parent.valueChildren = .init(repeating: .init(), count: 5)
        XCTAssertEqual(parent.refNames, &quot;....&quot;)
        XCTAssertEqual(parent.valueNames, &quot;....&quot;)
        
        parent.refChildren[0].name = &quot;changed&quot;
        // FAILS
        XCTAssertEqual(parent.refNames, &quot;changed....&quot;)
        
        parent.valueChildren[0].name = &quot;changed&quot;
        // PASSES
        XCTAssertEqual(parent.valueNames, &quot;changed....&quot;)
    }
}
</code></pre>
","2611971","","","","","2022-02-18 01:49:50","How to get @Published updates in Combine with a Nested ObservableObject Array (Replicate ValueType Behavior)","<swift><combine><observableobject>","0","0","","","","CC BY-SA 4.0"
"71184061","1","71184397","","2022-02-19 10:23:49","","-2","400","<p>How do I get the data returned from a combine publisher, to a view?</p>
<p><a href=""https://i.stack.imgur.com/GZdER.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GZdER.png"" alt=""enter image description here"" /></a></p>
<p>There are many examples of this that show sink -&gt; print. There is nothing that clearly shows how to do anything other than print.</p>
","9400730","","9400730","","2022-02-25 13:07:34","2022-02-25 13:07:34","Populating a SwiftUI view with output from a combine publisher","<ios><swift><combine>","2","2","","2022-02-21 14:14:03","","CC BY-SA 4.0"
"71189403","1","","","2022-02-19 21:35:43","","0","101","<h2>Basic approach</h2>
<p>I am currently tring to clean up my Core Data/SwiftUI code, and part of that is moving code out of my Views and into my ViewModels. Since it seems that <code>@FetchRequest</code> does not work in VMs, I tried to create something similar that works in VMs (basically a wrapper around <code>NSFetchedResultsController</code>):</p>
<pre><code>class FetchedData&lt;ResultType: NSManagedObject&gt;: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, NSFetchedResultsControllerDelegate, ObservableObject {
    
    @Published var value: [ResultType] = []
    
    convenience init(entity: ResultType.Type) {
         let request = NSFetchRequest&lt;NSFetchRequestResult&gt;()
         request.entity = ResultType.entity()
         request.sortDescriptors = []

         super.init(
            fetchRequest: request,
            managedObjectContext: PersistenceController.shared.context,
            sectionNameKeyPath: nil, 
            cacheName: nil
         )

         self.delegate = self
        
         do {
            try self.performFetch()
            value = (self.fetchedObjects as? [ResultType]) ?? []
         } catch {
            print(&quot;Could not perform fetch&quot;)
         }
     }
    
    internal func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) {
        guard let newValue = controller.fetchedObjects as? [ResultType] else {
            return
        }
        
        value = newValue
    }
}
</code></pre>
<p>So far so good, I can use this as follows:</p>
<pre><code>struct ContentView: View {

    class ViewModel: ObservableObject {
        private var cancellables: [AnyCancellable] = []
        var data = FetchedData(entity: Element.self)
        
        init() {
            data.$value.sink { _ in
                self.objectWillChange.send()
            }
            .store(in: &amp;cancellables)
        }
    }

    @StateObject var viewModel = ViewModel()

    var body: some View {
        List {
            ForEach(viewModel.data.value, id: \.self) { element in
                // show UI for element
            }
        }
    }
}
</code></pre>
<h2>Making FetchedData a collection</h2>
<p>Now I wanted to simplify the usage of this a bit, and make <code>FetchedData</code> a collection so I can use it directly and don't have to use <code>value</code>. I added this:</p>
<pre><code>extension FetchedData: RandomAccessCollection {

    typealias Element = ResultType
    typealias Index = Int
    typealias Indices = Range&lt;Int&gt;
    typealias Iterator = IndexingIterator&lt;[Element]&gt;

    subscript(position: Int) -&gt; ResultType {
        return value[position]
    }

    var startIndex: Int {
        return value.startIndex
    }

    var endIndex: Int {
        return value.endIndex
    }

    __consuming func makeIterator() -&gt; IndexingIterator&lt;[Element]&gt; {
        return value.makeIterator()
    }
}
</code></pre>
<p>and then changed my View to this:</p>
<pre><code>struct ContentView: View {

    class ViewModel: ObservableObject {
        let data = LiveData(entity: Element.self)
    }

    @StateObject var viewModel = ViewModel()

    var body: some View {
        Group {
            List {
                ForEach(viewModel.data, id: \.self) { element in
                    // show UI for element
                }
            }
        }
    }
}
</code></pre>
<h2>The Issue</h2>
<p>It... kind of works. It will show and updated my data, and I can add <code>Element</code>s and the view will update just fine. The problem occurs when I try to delete data using this:</p>
<pre><code>.onDelete { indexSet in
    indexSet.forEach { index in
        let element = viewModel.data[index]
        viewContext.delete(element)
    }
                            
    try? viewContext.save()
}
</code></pre>
<p>My app will crash with a <code>Fatal error: Index out of range</code> exception in the <code>subscript</code> method of my extension.</p>
<p>For example, if I had 5 elements in my collection and delete one, first the deletion happens and then SwiftUI apparently queries index 4 from <code>viewModel.data</code> (which doesn't exist anymore, since only 4 elements are left). The strange thing is that SwiftUI seems to query <code>endIndex</code> before that, which returns the correct value, so I don't know why it would query something it knows is out of bounds. Also, it seems that for some reason, deleting the last element seems to work just fine.</p>
<p>I can't really make heads or tails of this. Since it works using <code>viewModel.data.values</code> instead of just <code>viewModel.data</code> I suppose there is something wrong in my <code>extension FetchedData: RandomAccessCollection</code>, but I do not understand the issue here.</p>
<p>Any help would be appreciated!</p>
","1421550","","","","","2022-05-18 11:26:41","Crash when deleting an item from List in SwiftUI with custom RandomAccessCollection","<swift><core-data><swiftui><combine><observableobject>","1","1","2","","","CC BY-SA 4.0"
"71194633","1","","","2022-02-20 12:56:31","","2","424","<p>So I'm getting started with Combine, and I want to have a component which publishes events like a simple event emitter.</p>
<p>So in other words, I want to have a model like this (pseudocode):</p>
<pre><code>class MyModel {
   var onNewEvent: EventPublisher

   func foo(bar: Bar) {
       onNewEvent.publish(Event(bar))
   }
}

let model: MyModel...

model.onNewEvent.sink(
    receiveValue: { event in print(event) }
)

</code></pre>
<p>I can achieve something like this using a notification center publisher, but I want to avoid this unnecessary step if possible.</p>
<p>Is there such a thing as a simple publisher which just publishes values on command, or else what would be the idiomatic way to handle this in combine?</p>
","814570","","","","","2022-02-22 04:07:22","How to implement a simple event emitter style publisher in Combine?","<swift><swiftui><combine>","1","4","","","","CC BY-SA 4.0"
"71210296","1","","","2022-02-21 17:07:18","","0","129","<p>I want to debounce a stream of values, and add a flush signal to it. When the flush signal comes, debounce should immediately emit its last received value and clear its buffer. If there is no value in debounce's buffer, the flush signal does nothing. Basically, the flush signal temporarily sets the debounce time to 0:</p>
<pre><code>values: -- 1 -- 2 -- 3 ---------- 4 -- 5 -- 6 --------------------

flush:  --------------------------------- * -------------- * -----

output: ------------------- 3 ----------- 5 ------- 6 ------------
</code></pre>
<p>I tried the following approach, mimicking <code>debounce</code> with <code>delay</code> and <code>switchToLatest</code>, but couldn't figure out how to do <code>flushedValues</code>, which should emit the last value, if any, that comes within 2 seconds before a flush signal.</p>
<pre><code>// valuesSubject: Publisher&lt;Int, Never&gt; is the value stream
// flushSubject: Publisher&lt;Void, Never&gt; is the flush stream

let valuesWithDelay = valuesSubject.map { $0.delay(for: 2, scheduler: ...) }
let flushedValues = // somehow combine valuesSubject and flushSubject
let output = Publishers.Merge(valuesWithDelay, flushedValues).switchToLatest()
</code></pre>
","3808183","","","","","2022-02-24 21:31:18","debounce with a flush switch","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71234044","1","","","2022-02-23 09:05:58","","1","280","<p>I'm trying to show array values, which I get from API call. I'm making <code>addToCart</code> request in one view and need to show its result in other view.</p>
<pre><code>class Cart: ObservableObject {

@Published var data: ShoppingCartContent?
@Published var sections: [SectionContent] = []
private var subscriptions = Set&lt;AnyCancellable&gt;() }

extension Cart {

func addToCart(productId: Int, productQty: Int) {
    
    guard let token = UserDefaults.standard.string(forKey: &quot;token&quot;) else { return }
    NetworkManager.addProductToCart(token: token, productId: productId, productQty: productQty)
        .sink(
          receiveCompletion: { completion in
              switch completion {
              case .finished:
                  print(&quot;finished&quot;)
              case .failure(let error):
                  print(&quot;AddToCart error&quot;, error)
              }
          },
          receiveValue: { value in
              print(&quot;Success:&quot;, value.success)
              print(&quot;Data:&quot;, value.data)
              self.data = value.data
              self.sections = value.data.sections
              print(&quot;Sections:&quot;, self.sections)
          })
        .store(in: &amp;subscriptions) }}
</code></pre>
<p>I'm getting data from API, save them in @Published var sections, but I can't show them in other view, print shows it's nil.</p>
<pre><code>struct ShoppingView: View {

@EnvironmentObject var viewModel: Cart

var body: some View {
    ScrollView {
    VStack(alignment: .leading) {
        
    HStack {
        Text(&quot;Delivery:&quot;)
            .foregroundColor(Color.textFieldGrayColor)
          
        ForEach(viewModel.sections, id: \.self) { section in
            ForEach(section.items, id: \.self) { product in
                Text(product.product_name)
            }
        }
}

}.onAppear {
 print(&quot;My cart arr:&quot;, cartViewModel.data?.sections)
}
}
}
</code></pre>
<p>P.S. <code>ShoppingView</code> - is one of the tabs, I added (environmentObject) in <code>MainView</code></p>
<pre><code>@EnvironmentObject var viewModel: Cart
ShoppingView().environmentObject(viewModel)
</code></pre>
<p>I also tried to access array with <code>@ObservedObject var viewModel = Cart()</code> but it also shows empty array.</p>
","1377855","","13942891","","2022-03-27 09:14:41","2022-03-27 09:14:41","How to show array in other view SwiftUI","<arrays><swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"71235657","1","71235830","","2022-02-23 10:58:20","","-1","38","<p>i am new to the entity framework.
i want so find a spezific database item...</p>
<p>i used this code</p>
<pre><code>using (var db = new DatabaseX(_connectionVar))
            {
                try
                {
                    var data = from test in db.X where test.Y== Y &amp;&amp; test.z== z &amp;&amp; test.s== s select test;

                }
            }
</code></pre>
<p>but how can i combine this parameters? With the sign &quot;&amp;&amp;&quot; it doesn´t work...</p>
<p>I hope someone can help me.</p>
","11400394","","11400394","","2022-02-23 11:04:40","2022-02-23 11:10:54","Query many values into one request - entity framework","<sql><database><entity-framework-core><request><combine>","1","1","","2022-02-23 15:33:29","","CC BY-SA 4.0"
"71247573","1","","","2022-02-24 05:36:35","","0","220","<p>So I am working on a view where I want to load state from an EnvironmentObject which acts something like a database.</p>
<p>I would like to achieve something like this:</p>
<pre><code>class MyDB: ObservableObject {
    func getName(_ id: RecordID) -&gt; String { ... }
    func getChildren(_ id: RecordID) -&gt; [RecordID] { ... }
    var didUpdate: PassthroughSubject...

}

struct TreeView: View {
    let id: RecordID
    @EnvironmentObject var db: DB
    @State var name: String
    @State var children: [RecordID]

    func loadState() {
        self.name = db.getName(id)
        self.children = db. getChildren(id)
    }

    var body: some View {
        Text(self.name)
        List(self.children) { child in
            TreeView(id: child)
        }
        .onReceive(self.db.didUpdate) { _ in
            self.loadState()
        }
    }

}

</code></pre>
<p>So basically I would like to just pass the id of the node in the tree view to the child view, and then load the state from this environment object with the <code>loadState</code> function before the view is displayed.</p>
<p>Is there any way to achieve this?  For instance, is there some kind of lifecycle function I could implement which will be called after the environment is bound?</p>
<p>Or for example can I implement loadState inside a custom init?</p>
<p>What would be the idiomatic way to handle this?</p>
","814570","","814570","","2022-02-24 06:14:12","2022-02-24 07:31:10","How can I load state from en EnvironmentObject in SwiftUI?","<ios><swift><swiftui><combine><swiftui-environment>","2","4","","","","CC BY-SA 4.0"
"71253992","1","","","2022-02-24 15:01:07","","0","106","<p>I have a scenario whereby I have a list of items which all have NavigationLinks embedded. However, the destination of that link should vary depending on the item selected. The added complication though is that the value which I need to check will only be known once the item has been selected. So, here is the stack with the NavigationLinks:</p>
<pre><code>LazyVStack(alignment: .center) {
                Section(header: storeStatusOpenHeader()) {
                    ForEach(viewModel.shownOpenStores, id: \.self) { details in
                        
                        StoreCardInfoView(storeDetails: details)
                        
                        NavigationLink(destination:
                                        FulfilmentTimeSlotSelectionView(viewModel: .init(container: viewModel.container))
                                        .onAppear {
                            viewModel.selectStore(id: details.id)
                        }) {
                            StoreCardInfoView(storeDetails: details)
                        }
                    }
                }
            }
</code></pre>
<p>Currently we redirect directly to FulfilmentTimeSlotSelectionView. However, in the viewModel when selectStore() is called, we a key property that we need to check before knowing where to redirect the user. Firstly, we call an endpoint which returns a bunch of available delivery days for the store selected. Using Combine, we listen for the response here with the following subscription (the selectedOrderMethod is incidental with regards to this question so can be ignored):</p>
<pre><code>private func setupSelectedRetailsStoreDetails() {
        $selectedRetailStoreDetails
            .sink { [weak self] details in
                guard let self = self else { return }

                switch self.selectedOrderMethod {
                case .delivery:
                    if let deliveryDays = details.value?.deliveryDays {
                        self.futureFulfilmentAvailable = !(deliveryDays.count == 1 &amp;&amp; deliveryDays[0].date == &quot;2022-02-24&quot;) // hard coded for now i.e. today
                    }
                case .collection:
                    if let collectionDays = details.value?.collectionDays {
                        self.futureFulfilmentAvailable = !(collectionDays.count == 1 &amp;&amp; collectionDays[0].date == &quot;2022-02-24&quot;) // hard coded for now i.e. today
                    }
                default:
                    print(&quot;***&quot;) // TBC
                }
            }
            .store(in: &amp;cancellables)
    }
</code></pre>
<p>So here on the viewModel, we set a key Boolean futureFulfilmentAvailable. If this value is true, I want to redirect the user to one view (where they would select a timeslot), but if it is false, I would want to direct them to a different view.</p>
<p>Obviously the issue with the NavigationLink here is that when it is tapped, the call has not yet been made and so the Bool has not been set, meaning we don't know where to redirect the user.</p>
<p>Is there a clean way around this that I am not seeing yet?</p>
","7188537","","","","","2022-02-24 15:26:17","SwiftUI: NavigationLink which performs a function first and then dynamically navigates","<swift><swiftui><combine><swiftui-navigationlink>","0","2","","","","CC BY-SA 4.0"
"71254656","1","71259063","","2022-02-24 15:46:39","","0","96","<p>I'm trying to wrap my head around this call in Combine.</p>
<p>I have two models and calls. One is an array of place data, the second an array for the OpenWeather response. What I need is to pass the latitude and longitude from my first call response into the second call. At the same time I need to keep the response for both calls.</p>
<p>Bear in mind that this is my first chained request.</p>
<pre><code>enum callAPI {
static let agent = Agent()
static let url1 = URL(string: &quot;**jsonURL**&quot;)!
static let url2 = URL(string: &quot;https://api.openweathermap.org/data/2.5/weather?lat=\(latitude)&amp;lon=\(longitude)&amp;APPID=**APIkey**&amp;unites=metric&quot;)! }

extension callAPI {
    
static func places() -&gt; AnyPublisher&lt;[Place], Error&gt; {
    return run(URLRequest(url: url1))
}

static func weather(latitude: Double, longitude: Double) -&gt; AnyPublisher&lt;[ResponseBody], Error&gt; {
    return run(URLRequest(url: url2))
}

static func run&lt;T: Decodable&gt;(_ request: URLRequest) -&gt; AnyPublisher&lt;T, Error&gt; {
    return agent.run(request)
        .map(\.value)
        .eraseToAnyPublisher()
}}

func chain() {
let places = callAPI.places()
let firstPlace = places.compactMap { $0.first }
let weather = firstPlace.flatMap { place in
    callAPI.weather(latitude: place.latitude, longitude: place.longitude)
}

let token = weather.sink(receiveCompletion: { _ in },
                        receiveValue: { print($0) })

RunLoop.main.run(until: Date(timeIntervalSinceNow: 10))

withExtendedLifetime(token, {})}
</code></pre>
<p>This is the model:</p>
<pre><code>struct Place: Decodable, Identifiable {
let id: Int
let name: String
let description: String
let latitude, longitude: Double
let imageURL: String }

struct ResponseBody: Decodable {
var coord: CoordinatesResponse
var weather: [WeatherResponse]
var main: MainResponse
var name: String
var wind: WindResponse

    struct CoordinatesResponse: Decodable {
    var lon: Double
    var lat: Double
}

    struct WeatherResponse: Decodable {
    var id: Double
    var main: String
    var description: String
    var icon: String
}

    struct MainResponse: Decodable {
    var temp: Double
    var feels_like: Double
    var temp_min: Double
    var temp_max: Double
    var pressure: Double
    var humidity: Double
}

    struct WindResponse: Decodable {
    var speed: Double
    var deg: Double
}}

extension ResponseBody.MainResponse {
var feelsLike: Double { return feels_like }
var tempMin: Double { return temp_min }
var tempMax: Double { return temp_max }}
</code></pre>
","18300482","","4667835","","2022-02-24 15:59:35","2022-02-26 16:56:15","Combine: Chain requests with dependency, keep both responses","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"71275145","1","71332106","","2022-02-26 08:29:21","","0","223","<p>EDIT:
I am trying my level best to make my question simpler,
here what I am trying to get a solution for is, I have an API and if my data is valid the API will give the correct response, for which I need to decode with the respective struct in swift.</p>
<p>also if my data is wrong the API will fail and it will produce an error response which is a different struct.</p>
<p>with the use of combine, I only could decode a single struct type.</p>
<p>SO how do I make my decode accept any type?
Generics is one way I hoped to solve but here the protocol that I need to implement is an issue I believe restricting me from using generics.</p>
<p>thanks for giving it a try.</p>
<p>// MARK: - ResponseStruct Model</p>
<pre><code>struct ResponseStruct: Codable {
   
}

</code></pre>
<p>//MARK: -Protocol</p>
<pre><code>public protocol RequestProtocol{
    associatedtype ResponseOutput 
    func fetchFunction() -&gt; AnyPublisher&lt;ResponseOutput, Error&gt;
}

</code></pre>
<p>//Mark: - Implementation</p>
<pre><code>struct RequestStruct: Codable, RequestProtocol {
    typealias ResponseOutput = ResponseStruct

    
    func fetchFunction() -&gt; AnyPublisher&lt;ResponseOutput, Error&gt;  {
        let networkManager = NetworkManager()
        do {
            return try networkManager.apiCall(url: url, method: .post, body: JSONEncoder().encode(self))
                .decode(type: ResponseStruct.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
        } catch {
            
        }
    }
}



</code></pre>
<p>Above this is the code, and this is fine if the API call works but if the call fails I will get an error response, so how to decode that struct in a combined way? I don't want to write another call for that and I am hoping to get something to do with Failure in the combine. or CAN I MAKE THE associated type (see protocol) generic?</p>
","16906745","","16906745","","2022-02-28 03:12:27","2022-03-03 04:19:42","How to Implement API for both Success and Failure Response with Combine Swift","<swift><generics><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"71276105","1","","","2022-02-26 11:02:56","","1","963","<p>I'm having difficulties testing Combine. I'm following:</p>
<ul>
<li><a href=""https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/"" rel=""nofollow noreferrer"">https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code/</a></li>
</ul>
<p>Which tests:</p>
<pre class=""lang-swift prettyprint-override""><code>final class ViewModel {
    @Published private(set) var tokens = [String]()
    @Published var string = &quot;&quot;
 
    private let tokenizer = Tokenizer()

    init () {
        $string
            .flatMap(tokenizer.tokenize)
            .replaceError(with: [])
            .assign(to: &amp;$tokens)
    }
}

struct Tokenizer {
    func tokenize(_ string: String) -&gt; AnyPublisher&lt;[String], Error&gt; {
        let strs = string.components(separatedBy: &quot; &quot;)
        return Just(strs)
            .setFailureType(to: Error.self)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>with the following:</p>
<pre><code>func testTokenizingMultipleStrings() throws {
    let viewModel = ViewModel()
    let tokenPublisher = viewModel.$tokens
        .dropFirst()
        .collect(2)
        .first()
    viewModel.string = &quot;Hello @john&quot;
    viewModel.string = &quot;Check out #swift&quot;
    let tokenArrays = try awaitPublisher(tokenPublisher)
    XCTAssertEqual(tokenArrays.count, 2)
    XCTAssertEqual(tokenArrays.first, [&quot;Hello&quot;, &quot;john&quot;])
    XCTAssertEqual(tokenArrays.last, [&quot;Check out&quot;, &quot;swift&quot;])
}
</code></pre>
<p>And the following helper function:</p>
<pre class=""lang-swift prettyprint-override""><code>extension XCTestCase {
    func awaitPublisher&lt;T: Publisher&gt;(
        _ publisher: T,
        timeout: TimeInterval = 10,
        file: StaticString = #file,
        line: UInt = #line
    ) throws -&gt; T.Output {
        var result: Result&lt;T.Output, Error&gt;?
        let expectation = self.expectation(description: &quot;Awaiting publisher&quot;)
        let cancellable = publisher.sink(
            receiveCompletion: { completion in
                switch completion {
                case .failure(let error):
                    result = .failure(error)
                case .finished:
                    break
                }
                expectation.fulfill()
            },
            receiveValue: { value in
                result = .success(value)
            }
        )
        waitForExpectations(timeout: timeout)
        cancellable.cancel()
        let unwrappedResult = try XCTUnwrap(
            result,
            &quot;Awaited publisher did not produce any output&quot;,
            file: file,
            line: line
        )
        return try unwrappedResult.get()
    }
}
</code></pre>
<p>Here <code>receiveValue</code> is never called so the test doesn't complete.
How can I get this test to pass?</p>
","11076699","","5626568","","2022-02-26 11:05:25","2022-05-02 19:29:54","Unit Testing Combine","<swift><xctest><combine>","2","1","","","","CC BY-SA 4.0"
"71285136","1","","","2022-02-27 13:28:33","","0","157","<p>So I am working on a view in SwiftUI which will update its state when an event is published.</p>
<p>The view looks like this:</p>
<pre><code>struct MyView: View {
    
    @EnvironmentObject var dataSource: DataSource
    @State var data: [Model] = []
    

    func refreshData() {
        self.data = dataSource.getData()
    }
    
    var body: some View {
        VStack {
            List(self.data) { model in
                Row(model: model)
            }
        }
        .onAppear {
            self.refreshData()
        }
        .onReceive(self.dataSource.didUpdate) { _ in
            print(&quot;on receive&quot;)
            self.refreshData()
        }
    }
}

class DataSource: ObservableObject {
    var didUpdate: PassthroughSubject&lt;Model,Never&gt; ...
}

</code></pre>
<p>So with this setup, the <code>onAppear</code> block is called and works as expected.  But the <code>onReceive</code> callback is never called.  I have been able to verify that <code>.send</code> is being called correctly on the <code>DataSource.didUpdate</code> subject, but it appears the subscriber is not being notified.</p>
<p>Is there something I am missing to make this work?</p>
","814570","","","","","2022-02-27 14:19:53","onReceive callback not executing","<ios><swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"71305954","1","","","2022-03-01 08:59:20","","-1","216","<p>(You can skip this part and just look at the code.) I'm creating a complicated form. The form creates, say, a Post object, but I want to be able to create several Comment objects at the same time. So I have a Post form and a Comment form. In my Post form, I can fill out the title, description, etc., and I can add several Comment forms as I create more comments. Each form has an <code>@ObservedObject viewModel</code> of its own type. So I have one parent Post <code>@ObservedObject viewModel</code>, and another <code>@ObservedObject viewModel</code> for the array of the Comment objects which is also a <code>@ObservedObject viewModel</code>.</p>
<p>I hope that made some sense -- here is code to minimally reproduce the issue (unrelated to Posts/Comments). The objective is to make the count of the &quot;Childish&quot; viewModels at the parent level count up like how they count up for the &quot;Child&quot; view.</p>
<pre><code>import Combine
import SwiftUI

final class ParentScreenViewModel: ObservableObject {
    @Published var childScreenViewModel = ChildScreenViewModel()
}

struct ParentScreen: View {
    @StateObject private var viewModel = ParentScreenViewModel()

    var body: some View {
        Form {
            NavigationLink(destination: ChildScreen(viewModel: viewModel.childScreenViewModel)) {
                Text(&quot;ChildishVMs&quot;)
                Spacer()
                Text(&quot;\(viewModel.childScreenViewModel.myViewModelArray.count)&quot;) // FIXME: this count is never updated
            }
        }
    }
}

struct ParentScreen_Previews: PreviewProvider {
    static var previews: some View {
        ParentScreen()
    }
}

// MARK: - ChildScreenViewModel

final class ChildScreenViewModel: ObservableObject {
    @Published var myViewModelArray: [ChildishViewModel] = []
    
    func appendAnObservedObject() {
        objectWillChange.send() // FIXME: does not work
        myViewModelArray.append(ChildishViewModel())
    }
}

struct ChildScreen: View {
    @ObservedObject private var viewModel: ChildScreenViewModel
    
    init(viewModel: ChildScreenViewModel = ChildScreenViewModel()) {
        self.viewModel = viewModel
    }

    var body: some View {
        Button {
            viewModel.appendAnObservedObject()
        } label: {
            Text(&quot;Append a ChildishVM (current num: \(viewModel.myViewModelArray.count))&quot;)
        }
    }
}

struct ChildScreen_Previews: PreviewProvider {
    static var previews: some View {
        ChildScreen()
    }
}

final class ChildishViewModel: ObservableObject {
    @Published var myProperty = &quot;hey!&quot;
}
</code></pre>
<p>ParentView:
<a href=""https://i.stack.imgur.com/khqrj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/khqrj.png"" alt=""ParentView does not update count"" /></a></p>
<p>ChildView:
<a href=""https://i.stack.imgur.com/g3IFM.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/g3IFM.png"" alt=""ChildView does update count"" /></a></p>
<p>I can't run this in previews either -- seems to need to be run in the simulator. There are lots of questions similar to this one but not quite like it (e.g. the common answer of manually subscribing to the child's changes using Combine does not work). Would using <code>@EnvironmentObject</code> help somehow? Thanks!</p>
","9946657","","","","","2022-03-01 10:15:46","SwiftUI parent viewModel containing a nested array of observed objects does not update","<swiftui><combine><observedobject>","1","0","","","","CC BY-SA 4.0"
"71316038","1","71316316","","2022-03-02 00:12:48","","0","1625","<p>I'm trying to implement Combine framework with Alamofire. But I have problems with generics, can you help me improving my code.
So, my APIRouter class:</p>
<pre><code>import Alamofire
import Foundation

public protocol APIConfiguration: URLRequestConvertible {
    var method: HTTPMethod { get }
    var baseURL: String { get }
    var path: String { get }
    var parameters: Parameters? { get }
    
    func asURLRequest() throws -&gt; URLRequest
}


public enum APIRouter: APIConfiguration {
    
    case getPopularRequests
    case getRegionAndCity
    case getCities
    case getComparableCities
    case getSuggests(_ parameters: [String: String])
    case getDrugs(_ parameters: [String: String])
    
    // MARK: - HTTPMethod
    public var method: HTTPMethod {
        switch self {
            
        case .getPopularRequests:
            return .get
        case .getRegionAndCity:
            return .get
        case .getCities:
            return .get
        case .getComparableCities:
            return .get
        case .getSuggests:
            return .get
        case .getDrugs:
            return .get
        }
    }
    
    // MARK: - BaseURL
    public var baseURL: String {
        return &quot;https://example.com/api&quot;
    }
    
    // MARK: - Path
    public var path: String {
        switch self {
            
        case .getPopularRequests:
            return &quot;/goods/search/popular&quot;
        case .getRegionAndCity:
            return &quot;/handbooks/cities?q=&amp;intersect_operation=&amp;need_data=true&amp;need_count=true&amp;take=1000&amp;skip=0&amp;sort_by=name&amp;sort_direction=asc&quot;
        case .getCities:
            return &quot;/handbooks/cities/&quot;
        case .getComparableCities:
            return &quot;/handbooks/cities?q=&amp;intersect_operation=&amp;need_data=true&amp;need_count=true&amp;take=1000&amp;skip=0&amp;sort_by=name&amp;sort_direction=asc&quot;
        case .getSuggests:
            return &quot;/goods/search/suggests&quot;
        case .getDrugs:
            return &quot;/goods/search/global&quot;
        }
    }
    
    // MARK: - Parameters
    public var parameters: Parameters? {
        switch self {
            
        case .getPopularRequests:
            return nil
        case .getRegionAndCity:
            return nil
        case .getCities:
            return nil
        case .getComparableCities:
            return nil
        case .getSuggests(let parameters):
            return parameters
        case .getDrugs(let parameters):
            return parameters
        }
    }
    
    // MARK: - URLRequestConvertible
    public func asURLRequest() throws -&gt; URLRequest {
        let urlWithPathValue = baseURL + path
        var url = try urlWithPathValue.asURL()
        var urlRequest = URLRequest(url: url)
        urlRequest.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        urlRequest.httpMethod = method.rawValue
        
        if let parameters = parameters {
            switch self {
                
            case .getPopularRequests, .getRegionAndCity, .getCities, .getComparableCities:
                return urlRequest
            case .getSuggests, .getDrugs:
                var urlComponents = URLComponents(string: urlWithPathValue)!
                urlComponents.queryItems = []
                
                _ = parameters.map { (key, value) in
                    let item = URLQueryItem(name: key, value: value as? String)
                    urlComponents.queryItems?.append(item)
                }
                
                url = urlComponents.url!
                urlRequest.url = url
            }
        }

        return urlRequest
    }
}
</code></pre>
<p>Than I have API Client class:</p>
<pre><code>public protocol APICitiesScreenClientProtocol: AnyObject {
    func getCities(completion: @escaping (Result&lt;CitiesScreenModel, AFError&gt;) -&gt; Void)
    func getCitiesWithCombine() -&gt; AnyPublisher&lt;Result&lt;CitiesScreenModel, AFError&gt;, Never&gt; 
}

public final class APIClient {
    
    @discardableResult
    private func performRequest&lt;T: Decodable&gt;(route: APIRouter, decoder: JSONDecoder = JSONDecoder(), completion: @escaping (Result&lt;T, AFError&gt;) -&gt; Void) -&gt; DataRequest {
        return AF.request(route).responseDecodable(of: T.self, decoder: decoder) { response in
            completion(response.result)
        }
    }
    
    private func performCombineRequest&lt;T: Decodable&gt;(route: APIRouter, decoder: JSONDecoder = JSONDecoder()) -&gt; AnyPublisher&lt;Result&lt;T, AFError&gt;, Never&gt; {
        return AF.request(route).publishDecodable(type: T.self, decoder: decoder).result()
    }
}

// MARK: - APICitiesScreenClientProtocol
extension APIClient: APICitiesScreenClientProtocol {
    
    public func getCities(completion: @escaping (Result&lt;CitiesScreenModel, AFError&gt;) -&gt; Void) {
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
        performRequest(route: .getCities, decoder: jsonDecoder, completion: completion)
    }
    
    public func getCitiesWithCombine() -&gt; AnyPublisher&lt;Result&lt;CitiesScreenModel, AFError&gt;, Never&gt; {
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
        performCombineRequest(route: .getCities, decoder: jsonDecoder)
//      return AF.request(APIRouter.getCities).publishDecodable(type: CitiesScreenModel.self, decoder: jsonDecoder).result()
    }
}
</code></pre>
<p>And I am planning it to use like this:</p>
<pre><code>APIClient().getCitiesWithCombine()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] result in
                switch result {
                    
                case .success(let data):
                    self?.prepareTableViewModel(for: data.data.elements)
                    self?.requestError = nil
                case .failure(let error):
                    self?.requestError = error
                }
            }
            .store(in: &amp;cancellables)
</code></pre>
<p>When I use this line of code</p>
<pre><code>return AF.request(APIRouter.getCities).publishDecodable(type: CitiesScreenModel.self, decoder: jsonDecoder).result()
</code></pre>
<p>, but if I try</p>
<pre><code>performCombineRequest(route: .getCities, decoder: jsonDecoder)
</code></pre>
<p>I got &quot;Generic parameter 'T' could not be inferred&quot;.
Thank you for help.</p>
","13781815","","13781815","","2022-03-02 02:14:15","2022-03-02 05:23:39","Alamofire with Swift Combine","<ios><swift><alamofire><combine>","1","2","","","","CC BY-SA 4.0"
"71319628","1","71319837","","2022-03-02 08:35:33","","-4","41","<p>So let's say I have a data type like this:</p>
<pre><code>struct Foo {
   var isOn: Bool
}
</code></pre>
<p>And I want to have a toggle which operates on the <code>isOn</code> member - something like this:</p>
<pre><code>struct MyView: View {

    @Binding var model: Foo

    var body: some View {
        Toggle(&quot;is on?&quot;, $model.isOn)
    }
}
</code></pre>
<p>Is there any way to achieve this, or would I have to make <code>Foo</code> an observable object with each member being published?</p>
","814570","","","","","2022-03-02 08:52:57","Is there any way for a toggle to operate on a member of a binding?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"71321715","1","71323471","","2022-03-02 11:14:15","","-1","169","<p>I need to test the code:</p>
<pre><code>func ourFunc() -&gt; AnyPublisher&lt;Void, Never&gt; {
       model: OurModel = OurModel()
       Just(model).eraseToAnyPublisher()
    }
</code></pre>
<p>An error occurs:
<code>Cannot convert value of type OurModel to expected type Void</code></p>
<p>How we can typecast <code>OurModel</code> type to <code>Void</code>?</p>
","14991757","","415303","","2022-03-03 04:30:11","2022-03-03 04:30:11","Combine: Casting AnyPublisher<Void, Error> to AnyPublisher<""OurType"", Error>","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"71360487","1","","","2022-03-05 08:01:45","","0","32","<p>So let's say I have a view like this:</p>
<pre><code>struct MyView {
    @Binding var inEditMode: Bool
    ...
}
</code></pre>
<p>In some cases, I want this view to be able to swap in and out of edit mode, but in other cases, I only want it to be read-only.</p>
<p>Now I can avhieve this by creating a State var in the view containing this view that just never gets edited:</p>
<pre><code>struct MyContainer {
    @State alwaysFalse: Bool = false

    var view: some View {
        MyView(inEditMode: $alwaysFalse)
    }
}
</code></pre>
<p>But it seems a little unnecessary to introduce a state var here.  Is there any way to skip this and do something like this?</p>
<pre><code>struct MyContainer {
    var view: some View {
        MyView(inEditMode: ConstBinding&lt;Bool&gt;(false))
    }
}
</code></pre>
<p>I think it would make the intent a bit clearer.</p>
","814570","","","","","2022-03-05 08:01:45","Is there a way to pass a constant as a binding in SwiftUI?","<swiftui><combine>","0","2","","2022-03-05 08:30:32","","CC BY-SA 4.0"
"71369916","1","71370379","","2022-03-06 11:39:43","","0","315","<p>So I am working on a view where I want to have editable text which is only made editable via a button press.  So basically, when pressing the &quot;edit&quot; button, a text field should be made editable, and the focus should be sent to the text field.</p>
<p>Here's how I have attempted to implement this:</p>
<pre><code>struct MyView: View {
    @Binding var text: String
    @FocusState var isEditing
    var body: some View {
        HStack {
            TextField(&quot;Text&quot;, text: $text)
                .disabled(!isEditing)
                .focused($isEditing)
            Spacer()
            
            Button(isEditing ? &quot;Done&quot; : &quot;Edit&quot;) {
                isEditing.toggle()
            }
        }
    }
}
</code></pre>
<p>So if I comment out the <code>.disabled</code> line, the focus behavior works as intended.  However when the disabled call is there, pressing the edit button does not enable or focus the text field.</p>
<p>My best guess is that maybe the field cannot be focused because it's initially disabled?</p>
<p>Is there any way to achieve this behavior?  I've also tried using a separate @State var for disabled and this has the same result.</p>
","814570","","","","","2022-03-06 15:34:41","Problem enabling and focusing a text field at the same time","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"71372191","1","","","2022-03-06 16:38:52","","1","691","<p>I want to show a sheet, and immediately put the text field inside in focus when the sheet is shown, so the user can immediately start typing without tapping on the sheet separately.</p>
<p>I have tried the solutions in this thread: <a href=""https://developer.apple.com/forums/thread/681962"" rel=""nofollow noreferrer"">https://developer.apple.com/forums/thread/681962</a></p>
<p>But none of them are working.  Here's my current code:</p>
<pre><code>struct MySheet: View {
    @State var text: String
    @FocusState var focusedField: FocusField?
    var body: some View {
        VStack {
            TextField(&quot;&quot;, text: $text)
                .focused($focusedField, equals: .field)
                .padding()
                .task {
                    self.focusedField = .field
                }
        }
    }
}
</code></pre>
<p>It seems like this should be very simple and a common use-case.  How can I achieve this?</p>
","814570","","","","","2022-03-06 17:33:39","How do I make a text field focused when the sheet containing it appears","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"71374690","1","","","2022-03-06 22:26:11","","0","86","<p>I'm seeing very strange behavior within a view.  Here's my layout:</p>
<pre><code>struct EventDetailViewContainer: View {
    
    let eventID: EventRecord.ID
    
    @State var event: EventRecord = EventRecord(keyResults: [], text: &quot;&quot;, achievesKR: false)
    @State var editing: Bool = true
    
    var body: some View {
        if #available(iOS 15.0, *) {
            VStack {
                HStack {
                    Spacer()
                    Toggle(&quot;Editing&quot;, isOn: $editing)
                        .padding()
                }
                EventDetailView(event: $event, editing: $editing)
            }
            
        } else {
            // Fallback on earlier versions
        }
    }
}

@available(iOS 15.0, *)
struct EventDetailView: View {
    
    @Binding var event: EventRecord
    
    @Binding var editing: Bool
    @FocusState var textIsFocused: Bool
    
    
    var body: some View {
        VStack {
            TextField(
                &quot;Event text&quot;,
                text: $event.text
            )
                .focused($textIsFocused)
                .disabled(!editing)
                .padding()
            DatePicker(&quot;Event Date:&quot;, selection: $event.date)
                .disabled(!editing)
                .padding()
            Toggle(&quot;Goal is Reached?&quot;, isOn: $event.achievesKR)
                .disabled(!editing)
                .padding()
            HStack {
                Text(&quot;Notes:&quot;)
                Spacer()
            }
            .padding()
            TextEditor(text: $event.notes)
                .disabled(!editing)
                .padding()
            Spacer()
        }
    }
}

struct EventRecord: Identifiable, Equatable {
    
    typealias ID = Identifier
    
    struct Identifier: Identifiable, Equatable, Hashable {
        typealias ID = UUID
        let id: UUID = UUID()
    }
    
    let id: ID
    
    var keyResults: [KeyResult.ID]
    
    var date: Date
    var text: String
    var notes: String
    var achievesKR: Bool
    
    init(
        id: ID = ID(),
        keyResults: [KeyResult.ID],
        date: Date = Date(),
        text: String,
        notes: String = &quot;&quot;,
        achievesKR: Bool
        
    ) {
        self.id = id
        self.keyResults = keyResults
        self.date = date
        self.text = text
        self.notes = notes
        self.achievesKR = achievesKR
    }
    
}


</code></pre>
<p>So this works perfectly when I run it as an iPad app, but when I run it on the simulator, the the top toggle doesn't respond to text input.</p>
<p>The strange thing is, when I simply duplicate the toggle, the top one doesn't work and the bottom one works perfectly:</p>
<pre><code>struct EventDetailViewContainer: View {
    
    let eventID: EventRecord.ID
    
    @State var event: EventRecord = EventRecord(keyResults: [], text: &quot;&quot;, achievesKR: false)
    @State var editing: Bool = true
    
    var body: some View {
        if #available(iOS 15.0, *) {
            VStack {
                HStack {
                    Spacer()
                    Toggle(&quot;Editing&quot;, isOn: $editing)
                        .padding()
                }
                HStack {
                    Spacer()
                    Toggle(&quot;Editing&quot;, isOn: $editing)
                        .padding()
                }
                EventDetailView(event: $event, editing: $editing)
            }
            
        } else {
            // Fallback on earlier versions
        }
    }
}
</code></pre>
<p>It seems like this should be totally unrelated to the touch behavior of the other views.</p>
<p>Btw this is being displayed in the context of a navigation view.</p>
<p>Is there anything that can explain this?  And how can I get it working without adding this extra view on top?</p>
<p><strong>edit</strong>: Here's a gif of this behavior being demonstrated.  The two controls are exactly the same, but the lower one responds to touch and the upper one does not.</p>
<p><a href=""https://i.stack.imgur.com/vo4ty.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vo4ty.gif"" alt=""enter image description here"" /></a></p>
","814570","","814570","","2022-03-07 16:26:30","2022-03-07 16:26:30","Touch events seemingly not registering at top of screen","<swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"71389196","1","","","2022-03-08 01:55:57","","0","62","<p>because of a requirement to auto remove <code>Text</code> after its appearance in 2 seconds, I want to write this operator but still cannot figure out the best way to implement.</p>
<p><a href=""https://i.stack.imgur.com/TsLL1.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TsLL1.jpg"" alt=""enter image description here"" /></a></p>
<p>We can put a timespan parameter and get a new stream, here are two interfaces need to implement</p>
<pre><code>extension Publisher {
    func reset&lt;T, S: Scheduler&gt;(
        after: S.SchedulerTimeType.Stride,
        on scheduler: S
    ) -&gt; AnyPublisher&lt;T, Failure&gt; where Output == Optional&lt;T&gt; {
        // implementation
    }
    
    func autoToggle&lt;S: Scheduler&gt;(
        after: S.SchedulerTimeType.Stride,
        on scheduler: S
    ) -&gt; AnyPublisher&lt;Bool, Failure&gt; {
        // implementation
    }
}
</code></pre>
<p>Really appreciate your help.</p>
","1615838","","1615838","","2022-03-09 00:15:17","2022-04-29 05:56:32","How to write auto-toggle Publisher operator?","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"71392402","1","","","2022-03-08 09:02:23","","0","87","<p>I have my ContentView with 2 tabs.</p>
<pre><code>struct ContentView: View {
    var formViewModel = ViewModel()

    var body: some View {
        TabView {
            HomeTab()
                .environmentObject(formViewModel)
                .tabItem {
                    Label(&quot;Home&quot;, systemImage: &quot;house&quot;)
                }


            SettingsTab()
                .tabItem {
                    Label(&quot;Settings&quot;, systemImage: &quot;gear&quot;)
                }
        }
    }
}
</code></pre>
<p>HomeTab is a simple view with a button that moves to the detail page. Same as the SettingsTab.</p>
<pre><code>struct HomeTab: View {
    @EnvironmentObject var formViewModel: ViewModel

    var body: some View {
        NavigationView {
            NavigationLink(destination: DetailView().environmentObject(formViewModel)) {
                Text(&quot;Move to Detail Page&quot;)
            }
        }
    }
}
</code></pre>
<p>SettingsTab:</p>
<pre><code>struct SettingsTab: View {
    var body: some View {
        NavigationView {
            Text(&quot;Settings&quot;)
        }
    }
}
</code></pre>
<p>Inside DetailView is a single Textfield binded to a Published String? in the ViewModel. setInitialValues gives it a value and deactivate sets the value to nil</p>
<pre><code>struct DetailView: View {
    @EnvironmentObject var vm: ViewModel

    var body: some View {
        TextField(&quot;Enter stuff&quot;, text: Binding&lt;String&gt;(
            get: { vm.password ?? &quot;&quot; },
            set: { vm.password = $0 }
        ))
            .padding()
            .onAppear {
                vm.activate()
                vm.setInitialValues(&quot;Solar Power&quot;)
            }
            .onDisappear {
                vm.deactivate()
            }
    }

}
</code></pre>
<p>Naturally, when you move from HomeTab to the DetailView and switch tabs to the SettingsTab, you should be able to switch back to the DetailView in the previous tab. But in this case, the screen freezes. This only occurs on iPhone X + devices.</p>
<p>When you set the textfield's text property to a .constant(&quot;details&quot;), it works alright (You are able to switch between tabs without it freezing).</p>
<p>I should add that, onAppear of DetailView is being called when you switch back. The data is also present as I can log it. But the screen just freezes.</p>
<p><strong>Edit</strong>:</p>
<p>I've realized its freezing from the textfield's binding. Logs from the getter and setter keep showing like this (while the screen is stuck):</p>
<p><a href=""https://i.stack.imgur.com/jgeZj.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jgeZj.gif"" alt=""Log from switching tabs"" /></a></p>
","8694980","","8694980","","2022-03-08 09:46:47","2022-03-08 09:55:23","TabView freezes when navigating back to initial tab","<swiftui><combine><swiftui-tabview>","1","0","","","","CC BY-SA 4.0"
"71394852","1","","","2022-03-08 12:12:29","","2","242","<p>Imagine, we have a <code>sut</code> as a publisher which publishes values continuously and never finishes. On change of some input (ex: we change some mocked @Published property which our <code>sut</code> depends on), it emits an event.</p>
<p>We're collecting these events in <code>results</code> array and then checking if there is an exact expected number of events, not less and not more.</p>
<p>The problem is - how to check there are no more events after what we expect to be emitted? Without <code>wait</code> method we don't know when it's time to check the <code>results</code> array.</p>
<p><code>wait</code> will work but it feels for me like a crutch for Combine. Because the good unit tests should be fast (see F.I.R.S.T principles of unit testing). And these <code>wait</code>s looks more like anti-pattern.</p>
<p>I also couldn't find an Apple's recommendation on this.</p>
","667483","","667483","","2022-03-10 10:31:02","2022-03-10 10:31:02","How to write unit tests for continuous Combine publisher without using wait(for:timeout:)?","<ios><swift><unit-testing><combine>","1","2","1","","","CC BY-SA 4.0"
"71400120","1","","","2022-03-08 18:52:00","","0","536","<p>I'm learning Combine and how it can update a value using publishers. Currently I have created a variable that updates itself when validation fails.</p>
<pre><code>var nameError: AnyPublisher&lt;String, Never&gt; {
    $name
        .dropFirst()
        .debounce(for: 0.2, scheduler: RunLoop.main)
        .removeDuplicates()
        .map {
            if $0.isEmpty || !self.isValidName() {
                return &quot;Name not valid&quot;
            }
            return &quot;Name&quot;
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>I want to attach this to a Text() label so that it updates. Before Combine I would have an <code>var error: String</code> that I would check against. But now I get the error <code>Cannot convert value of type 'AnyPublisher&lt;String, Never&gt;' to expected argument type 'String'</code></p>
<p>How do I convert a <code>var error: String</code> message to receive an AnyPublisher&lt;String, Never&gt;?</p>
","4891259","","","","","2022-03-09 05:15:51","SwiftUI Combine How to update textfield","<swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"71406915","1","","","2022-03-09 09:18:35","","0","58","<p>If i run the code below:</p>
<pre><code>import Foundation
import Combine
import UIKit

let textField = UITextField()
let array = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;]
let publisher = array.publisher
    
//Statement 1
textField.publisher(for: \.text).sink{ print(&quot;Sink for .text property on textfield: \($0!)&quot;)}
    
//Statement 2
let subscriber = publisher.compactMap {$0}.assign(to: \.text, on: textField)

let _ = publisher.dropFirst(2).sink{print(&quot;Sink for array: \($0)&quot;)}
</code></pre>
<p>I get the output:</p>
<pre><code>sink for .text property on textfield: 1
sink for .text property on textfield: 2
sink for .text property on textfield: 3
sink for .text property on textfield: 4
sink for .text property on textfield: 5
sink for .text property on textfield: 6
sink for .text property on textfield: 7
Sink for array: 3
Sink for array: 4
Sink for array: 5
Sink for array: 6
Sink for array: 7
</code></pre>
<p>But if I flip the order of the statements 1 and 2, the output becomes much different:</p>
<pre><code>Sink for .text property on textfield: 7
Sink for array: 3
Sink for array: 4
Sink for array: 5
Sink for array: 6
Sink for array: 7
</code></pre>
<p>Why is that?
I tried to look into Combine documentation but couldn't find an answer that makes sense.</p>
","1200174","","","","","2022-03-10 13:46:38","Significance of order of statements when writing Combine code?","<ios><swift><swiftui><reactive><combine>","1","1","","","","CC BY-SA 4.0"
"71410117","1","","","2022-03-09 13:27:52","","0","254","<p>I am developing a swift UI project with Viper architecture.
The presenter has an observable object where all states are kept.
While the view is created, I inject the observable presenter into the view.</p>
<p>When I'm going to read a state. This is how it arrives.</p>
<pre><code>presenter.state.isEnable
or
presenter.isEnable
</code></pre>
<p>Everything is working. If I close the view all viper components and all views are cleared from memory.</p>
<p>The problem is, obviously only traces of @Published values remain. Does anyone know the reason for this?</p>
<p>Example View Init Code:</p>
<pre><code>let viewController = ExampleUIHostingController(rootView: ExampleSwiftUIView(presenter: presenter))
self.present(controller, animated: true)
</code></pre>
<p>Example Presenter Code:</p>
<pre><code>final class ExamplePresenter: ObservablePresenter {
    @Published var datasource: [Items] = []
    // OR
    @Published var states: ViewStates = ViewStates()
}
</code></pre>
<p>Example View Code:</p>
<pre><code>struct ExampleViewView&lt;T: ObservablePresenter&gt;: View where T.ViewStates == ExampleStates  {
    @ObservedObject var presenter: T

    var body: some View {
        if !presenter.isReminderActive {
           Color.red
        }
    }
}
</code></pre>
<p>In such an environment, if I close a presented view.
All components are removed from memory. Except for @Published property keypaths.</p>
<p>Xcode memory debug ss: <a href=""https://i.stack.imgur.com/ETr17.jpg"" rel=""nofollow noreferrer"">enter image description here</a></p>
","4890466","","259521","","2022-03-09 13:55:55","2022-03-09 13:55:55","SwiftUI @Published properties - why does it leave traces in memory? Is this a memory leak?","<swift><swiftui><combine>","0","11","","","","CC BY-SA 4.0"
"71416836","1","71424330","","2022-03-09 22:43:09","","0","128","<p>I'm using Combine for networking and I want to have some of the combine operations executed only if a certain condition is present, for instance if a local boolean variable <code>needsDecoding</code> is true I want to add <code>.decode(type:,decoder:)</code>:</p>
<pre><code>if (needsDecoding) {
   return URLSession.shared.dataTaskPublisher(for: request)
                .map(\.data)
                .decode(type: T.self, decoder: JSONDecoder())
                .eraseToAnyPublisher()
} else {
    return URLSession.shared.dataTaskPublisher(for: request)
                .map(\.data)
                .eraseToAnyPublisher()
}
</code></pre>
<p>That code above works but is it possible to conditionally add <code>.decode()</code> to the chain?</p>
","689779","","","","","2022-03-10 12:40:56","Swift: execute an operation conditionally on Publisher","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"71422429","1","71422756","","2022-03-10 10:16:16","","0","38","<p>I am new to Combine, so I wanted to create class <em>RestManager</em> for networking with generic
<em>fetchData</em> function. Function is returning <em>AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;</em> where <em>ErrorType</em> is enum with <em>.noInternetConnection, .empty and .general</em> cases.</p>
<p>I tried to use <em>URLSession</em> with <em>dataTaskPublisher</em> and <em>flatMap</em></p>
<pre><code>func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt; {
    URLSession
        .shared
        .dataTaskPublisher(for: url)
        .flatMap { (data, response) -&gt; AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt; in
            switch response.result {
            case .success(let data):
                if let data = try? JSONDecoder().decode(T.self, from: data){
                    return Just(data).eraseToAnyPublisher()
                }
            case .failure(let error):
                if let error = error as? URLError {
                    switch error.code {
                    case .notConnectedToInternet, .networkConnectionLost, .timedOut:
                        return Fail(ErrorType.noInternetConnection).eraseToAnyPublisher()
                    case .cannotDecodeRawData, .cannotDecodeContentData:
                        return Fail(ErrorType.empty).eraseToAnyPublisher()
                    default:
                        return Fail(ErrorType.general).eraseToAnyPublisher()
                    }
                }
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>But I am getting</p>
<p><em>Cannot convert return expression of type 'AnyPublisher&lt;AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;.Output, URLSession.DataTaskPublisher.Failure&gt;' (aka 'AnyPublisher&lt;AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;.Output, URLError&gt;') to return type 'AnyPublisher&lt;Result&lt;T, ErrorType&gt;, Never&gt;'</em> error.</p>
","16455916","","4667835","","2022-03-10 10:38:50","2022-03-10 10:40:43","Using flatMap in RestManager with generic function not working","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71425444","1","71426490","","2022-03-10 14:04:00","","0","140","<p>I have two async calls to fetch data from the server, but I want them to handle them as a single response, also want to handle errors for each response.</p>
<p>for example, here I have two methods <code>m1()</code>, <code>m2()</code> each can throw the different types of errors.</p>
<p><strong>We should wait to get a response of both</strong> and show an error message based on its error type. If there is no error, continue with the flow.
Which operator do we have to use? I tried with <code>Publishers.Zip</code> &amp; <code>Publishers.Map</code> not able to handle errors.</p>
<pre class=""lang-swift prettyprint-override""><code>
enum Error1: Error {
    case e1
}

enum Error2: Error {
    case e2
}

func m1() -&gt; Future&lt;Bool, Error1&gt; {
    return Future { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            promise(.failure(.e1))
        }
    }
}

func m2() -&gt; Future&lt;String, Error2&gt; {
    return Future { promise in
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            promise(.success(&quot;1&quot;))
        }
    }
}

</code></pre>
<p>Help would be greatly appreciated.!! Thank you.</p>
","11997939","","415303","","2022-05-26 22:37:49","2022-05-26 22:37:49","How two handle errors in async calls in swift combine?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71428825","1","71440994","","2022-03-10 18:07:04","","0","100","<p>I have a function which returns a list of Items using elastic search and falls back on realm cache. I'm wondering how can I use <code>Combine</code> to achieve the same.</p>
<p>I am trying to do something like this where I have a publisher for each store but I am getting stuck on the sorting them by score.</p>
<pre><code>    func search(for text: String) -&gt; AnyPublisher&lt;[Item], Error&gt; {
          
          return store.search(with: text)
            // Invalid syntax *
            .map { searchResults in
                let sorted = cacheStore.search(with: text)
                    .map { items in
                        items
                            .map { item in (item, searchResults.first { $0.id == item.id }?.score ?? 0) }
                            .sorted { $0.1 &gt; $1.1 } // by score
                            .map { $0.0 } // to item
                    }
                return sorted.eraseToAnyPublisher()
            }
            // *
            .catch { _ in cacheStore.search(with: text) }
            .eraseToAnyPublisher()
    }

</code></pre>
<p>This is the original function.</p>
<pre><code>func search(for text: String, completion: @escaping (Result&lt;[Item], Error&gt;) -&gt; Void) {
  
    store.search(with: text) {
        // Search network via elastic search or fall back to cache search
        // searchResults is of type [(id: Int, score: Double)] where id is item.id
        guard let searchResult = $0.value, $0.isSuccess else {
            return self.cacheStore.search(with: text, completion: completion)
        }
        
        self.cacheStore.fetch(ids: searchResult.map { $0.id }) {
            guard let items = $0.value, $0.isSuccess else {
                return self.cacheStore.search(with: text, completion: completion)
            }
            
            let scoredItems = items
                .map { item in (item, searchResult.first { $0.id == item.id }?.score ?? 0) }
                .sorted { $0.1 &gt; $1.1 } // by score
                .map { $0.0 } // to item
            
            completion(.success(scoredItems))
        }
    }
}
</code></pre>
","8213026","","8213026","","2022-03-11 16:53:39","2022-03-11 16:53:39","How to use Combine to show elastic search results using network while falling back on cache in Swift","<swift><caching><search><combine><publisher>","2","0","","","","CC BY-SA 4.0"
"71432580","1","","","2022-03-11 01:10:43","","0","179","<p>Here's my code to convert ReactiveSwift Signal Producers to Combine.Publishers</p>
<pre><code>

import ReactiveSwift
import Combine

/// convert SignalProducer&lt;X, Never&gt; -&gt; Publisher&lt;X, Never&gt;
public struct ReactiveSwiftPublisher&lt;Element&gt;: Publisher {
    public typealias Output = Element
    public typealias Failure = Never

    /// Subscription for ReactiveSwiftPublisher
    class Subscription&lt;SubscriberType: Subscriber&gt;: Combine.Subscription where SubscriberType.Input == Element {
        private var disposable: Disposable?

        init(producer: SignalProducer&lt;Element, Failure&gt;, subscriber: SubscriberType) {
            self.disposable = producer.startWithValues({
                _ = subscriber.receive($0)
            })
        }

        deinit {
            self.disposable?.dispose()
        }

        func request(_ demand: Subscribers.Demand) {}
        func cancel() {
            self.disposable?.dispose()
        }
    }

    private let producer: SignalProducer&lt;Element, Failure&gt;

    public init(producer: SignalProducer&lt;Element, Failure&gt;) {
        self.producer = producer
    }

    public func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Failure == S.Failure, Output == S.Input {
        let subscription = Subscription(producer: self.producer, subscriber: subscriber)
        subscriber.receive(subscription: subscription)
    }
}

extension SignalProducer where Error == Never {
    public var publisher: ReactiveSwiftPublisher&lt;Value&gt; {
        return ReactiveSwiftPublisher(producer: self)
    }
}
</code></pre>
<p>Creating a publisher is fine</p>
<pre><code>let x = MutableProperty&lt;Int&gt;(0)
var cancellables = Set&lt;AnyCancellable&gt;()

x.producer.publisher.sink {
    print(&quot;$0&quot;)
}.store(in: &amp;cancellables)

x.value = 33 // prints 33
</code></pre>
<p>but combining the latest doesn't yield a result</p>
<pre><code>let x = MutableProperty&lt;Int&gt;(1)
let y = MutableProperty&lt;Int&gt;(0)
x.producer.publisher.combineLatest(y.producer.publisher).sink {
    print($0) // does not print
}.store(in: &amp;self.cancellables)
</code></pre>
<p>but for some reason adding a current value subject makes it work</p>
<pre><code>// add this above the previous block 
let subj = CurrentValueSubject&lt;Int, Never&gt;(0)

// and change the subscription to this
Publishers.CombineLatest3(x.producer.publisher, y.producer.publisher, self.subj.eraseToAnyPublisher()).sink {
    print($0) // this prints (1, 0, 0)
}.store(in: &amp;self.cancellables)
</code></pre>
<p>Does anyone know what I'm doing wrong in my ReactiveSwiftPublisher code?</p>
","465446","","","","","2022-03-11 01:10:43","Reactive Swift Signal Producer conversion code to Combine.Publisher doesn't work with combine latest","<reactive><combine><publisher><subscriber><reactive-swift>","0","0","","","","CC BY-SA 4.0"
"71456618","1","71456919","","2022-03-13 12:08:43","","0","45","<p>After putting some operators on a publisher I am curious as to what the current return value and/or error is. Is there a quick way in Xcode that you can check that?</p>
<p>I would like to see something like <code>Map&lt;CombineLatest&lt;Published&lt;String&gt;, Published&lt;String&gt;, String?&gt;&gt;</code>.</p>
<p>I know I don't need to know if I erase it with <code>.eraseToAnyPublisher</code>, but I like to check.</p>
","174655","","","","","2022-03-13 12:51:21","How to check the current publisher type in Xcode?","<xcode><combine><publisher>","1","0","","","","CC BY-SA 4.0"
"71460557","1","71460723","","2022-03-13 20:24:34","","0","336","<p>I have an up-to-date json file hosted online and a local json file in my Xcode workspace. I would like to proceeed to decode a locally stored file if fetching failed: <code>MyError.fetchError</code> e.g. for no internet connection. This is the pipeline:</p>
<pre><code>func fetchAndDecode&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;T, MyError&gt; {
    fetchURL(url: url)
        .decode(type: T.self, decoder: JSONDecoder())
        .mapError { error in
            if let error = error as? DecodingError {
                return MyError.parsingError
            }  else {
                return MyError.fetchError //here somehow proceed to parse local json file
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>How to achieve this ?</p>
","18456673","","","","","2022-03-13 21:02:11","Combine - how to proceed to decode a local json file if online fetch failed?","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"71475905","1","71724704","","2022-03-15 01:12:16","","2","77","<p>I'm using Apple's example of an Observable wrapper around <code>SFSpeechRecognizer</code> as follows:</p>
<pre><code>class SpeechRecognizer: ObservableObject {
    @Published var transcript: String
    func transcribe() {}
}
</code></pre>
<p>The goal is to use a ViewModel to both consume the transcript as it is generated, as well as passing on the value to a SwiftUI View for visual debugging:</p>
<pre><code>class ViewModel : ObservableObject {
    @Published var SpeechText: String = &quot;&quot;
    @ObservedObject var speech: SpeechRecognizer = SpeechRecognizer()

    public init() {
        speech.transcribe()
        speech.transcript.publisher
            .map { $0 as! String? ?? &quot;&quot; }
            .sink(receiveCompletion: {
                print ($0) },
                  receiveValue: {
                    self.SpeechText = $0
                    self.doStuff(transcript: $0)
                  })
    }

    private void doStuffWithText(transcript: String) {
        //Process the output as commands in the application
    }
}
</code></pre>
<p>I can confirm that if I observe <code>transcript</code> directly in a SwiftUI view, that the data is flowing through. My problem is receiving the values as they change, and then assigning that data to my own published variable.</p>
<p>How do I make this work?</p>
","786487","","","","","2022-08-23 13:45:23","Publishing and Consuming a transcript from SFSpeechRecognizer","<swift><combine><sfspeechrecognizer>","1","0","","","","CC BY-SA 4.0"
"71509097","1","71510303","","2022-03-17 08:23:40","","0","407","<p>I'm trying to create an email input field in SwiftUI 2 that allows only certain characters to be entered. The code here is based on a piece of code from <a href=""https://stackoverflow.com/a/57829567/356105"">https://stackoverflow.com/a/57829567/356105</a>.</p>
<p>The code itself works but since this is a reusable view component I want to provide a text property from a parent view's view model to the <code>EmailTextField</code> which is updated when the text input changes ...</p>
<p><strong>EmailTextField view</strong>:</p>
<pre><code>import SwiftUI
import Combine

struct EmailTextField: View {
    private class EmailTextFieldViewModel: ObservableObject {
        @Published var text = String.Empty
        private var subCancellable: AnyCancellable!
        private var validCharSet = CharacterSet(charactersIn: &quot;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._-+$!~&amp;=#[]@&quot;)

        init() {
            subCancellable = $text.sink {
                value in

                /* Check if the new string contains any invalid characters. */
                if value.rangeOfCharacter(from: self.validCharSet.inverted) != nil {
                    /* Clean the string (do this on the main thread to avoid overlapping with the current ContentView update cycle). */
                    DispatchQueue.main.async {
                        self.text = String(self.text.unicodeScalars.filter {
                            self.validCharSet.contains($0)
                        })
                    }
                }
            }
        }

        deinit {
            subCancellable.cancel()
        }
    }

    @ObservedObject private var viewModel = EmailTextFieldViewModel()
    private let placeHolder: String

    var body: some View {
        TextField(placeHolder, text: $viewModel.text)
            .keyboardType(.emailAddress)
            .autocapitalization(.none)
            .disableAutocorrection(true)
    }

    init(_ placeHolder: String = .Empty, text: Binding&lt;String&gt;) {
        self.placeHolder = placeHolder
    }
}
</code></pre>
<p>In the parent view I'm trying this:</p>
<pre><code>var body: some View {
    VStack {
        EmailTextField(&quot;Email&quot;, text: $viewModel.email)
            .onChange(of: viewModel.email, perform: onEmailInputChanged)
    }
}

private func onEmailInputChanged(changedEmail: String) {
    // Nothing happens here!
    print(&quot;\(changedEmail)&quot;)
}
</code></pre>
<p>How do I need to change the <code>EmailTextField</code> code to be able to bind the <code>text</code> variable in its view model to the <code>text: Binding&lt;String&gt;</code> argument in its constructor?</p>
","356105","","","","","2022-03-17 09:57:04","Creating an Email Input Field in SwiftUI","<swift><swiftui><binding><combine>","1","0","","","","CC BY-SA 4.0"
"71513110","1","71513263","","2022-03-17 13:26:06","","1","157","<pre><code>    import SwiftUI


struct TimerView: View {
    
    @EnvironmentObject var tm : TimerModel
    
    @State var timerStyle : TimerStyle?
    @State var focusColors : [Color] = [Color.green, Color.mint, Color.green, Color.mint, Color.green]
    @State var breakColors : [Color] = [Color.blue, Color.mint, Color.blue, Color.mint, Color.blue]
    @State var longBreakColors : [Color] = [Color.gray, Color.white, Color.gray, Color.white, Color.gray]
    @State var isShowNewTimerView : Bool = false

    var body: some View {
        NavigationView {
            ZStack {
                Color(&quot;BackgroundColor&quot;).ignoresSafeArea(.all)
                if tm.timerStyle == nil {
                    NoTimerView()
                } else {
                    VStack(alignment : .center, spacing: 40){
                        Spacer()
                        if let timerStyle = tm.timerStyle {
                            switch timerStyle {
                                case .focus:
                                    Text(&quot;Focus Mode 🔥&quot;)
                                        .font(.system(size: 30, weight: .bold, design: .rounded))
                                        .fontWeight(.bold)
                       
                                case .short:
                                    Text(&quot;Break Mode ☕️&quot;)
                                        .font(.system(size: 30, weight: .bold, design: .rounded))
                                        .fontWeight(.bold)
                             
                                case .long:
                                    Text(&quot;Long Break Mode 🌕&quot;)
                                        .font(.system(size: 30, weight: .bold, design: .rounded))
                                        .fontWeight(.bold)//
                                    }
                                }
                        
                    if let timerStyle = tm.timerStyle {
                            switch timerStyle {
                            case .focus:
                                ProgressView(progress: tm.progress, gradientColors: focusColors, time: formatTime())
                                    .padding()
                                    .onReceive(tm.timer) { _ in
                                        if tm.timerMode == .start {
                                            if tm.elapsedFocusTime != 0 {
                                                tm.trackFocusProgress()
                                            } else {
                                                if tm.isAuto {
                                                    tm.timerStyle = .short
                                                    tm.progress = 0
                                                    tm.elapsedShortTime = tm.totalShortTime
                                                    
                                                    if tm.isOnSound {
                                                        playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                    }
                                                } else {
                                                    tm.timerMode = .normal
                                                    tm.timerStyle = .short
                                                    tm.isStarted = false
                                                    tm.progress = 0
                                                    tm.elapsedShortTime = tm.totalShortTime
                                                    audioPlayer1?.stop()
                                                    
                                                    if tm.isOnSound {
                                                        playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                    }
                                                }
                                            }
                                        }
                                    }
                            case .short:
                                ProgressView(progress: tm.progress, gradientColors: breakColors, time: formatTime())
                                    .padding()
                                    .onReceive(tm.timer) { _ in
                                        if tm.timerMode == .start {
                                            if tm.elapsedShortTime != 0 {
                                                tm.trackFocusProgress()
                                            } else {
                                                if tm.isAuto {
                                                    if tm.isSkipMode {
                                                        tm.timerStyle = .focus
                                                        tm.progress = 0
                                                        tm.elapsedFocusTime = tm.totalFocusTime
                                                        
                                                        if tm.isOnSound {
                                                            playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                        }
                                                        
                                                    } else {
                                                        tm.timerStyle = .long
                                                        tm.progress = 0
                                                        tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                                        if tm.isOnSound {
                                                            playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                        }
                                                    }
                                                } else {
                                                    if tm.isSkipMode {
                                                        tm.timerStyle = .focus
                                                        tm.timerMode = .normal
                                                        tm.timerStyle = .focus
                                                        tm.isStarted = false
                                                        tm.progress = 0
                                                        tm.elapsedFocusTime = tm.totalFocusTime
                                                        audioPlayer1?.stop()
                                                        
                                                        if tm.isOnSound {
                                                            playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                        }
                                                        
                                                    } else {
                                                        tm.timerMode = .normal
                                                        tm.timerStyle = .long
                                                        tm.isStarted = false
                                                        tm.progress = 0
                                                        tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                                        audioPlayer1?.stop()
                                                        
                                                        if tm.isOnSound {
                                                            playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                            case .long:
                                ProgressView(progress: tm.progress, gradientColors: longBreakColors, time: formatTime())
                                    .padding()
                                    .onReceive(tm.timer) { _ in
                                        if tm.timerMode == .start {
                                            if tm.elapsedLongBreakTime != 0 {
                                                tm.trackFocusProgress()
                                            } else {
                                                if tm.isAuto {
                                                    tm.timerStyle = .focus
                                                    tm.progress = 0
                                                    tm.elapsedFocusTime = tm.totalFocusTime
                                                    
                                                    if tm.isOnSound {
                                                        playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                    }
                                                    
                                                } else {
                                                    tm.timerMode = .normal
                                                    tm.timerStyle = .focus
                                                    tm.isStarted = false
                                                    tm.progress = 0
                                                    tm.elapsedFocusTime = tm.totalFocusTime
                                                    audioPlayer1?.stop()
                                                    
                                                    if tm.isOnSound {
                                                        playSound(sound: &quot;chimeup&quot;, type: &quot;mp3&quot;)
                                                    }
                                                }
                                            }
                                        }
                                    }
                        }
                    }
                    
                    if let timerStyle = tm.timerStyle {
                        switch timerStyle {
                        case .focus:
                            Text(&quot;Let's concentrate on your task!&quot;)
                                .font(.headline)
                                .multilineTextAlignment(.center)
                        case .short:
                            Text(&quot;Well done, Have a short break!&quot;)
                                .font(.headline)
                                .multilineTextAlignment(.center)
                        case .long:
                            Text(&quot;It's so long journey, take care yourself.&quot;)
                                .font(.headline)
                                .multilineTextAlignment(.center)
                        }
                    }
                    
                    HStack {
                    
                    Button(action: {
                        switch tm.timerMode {
                            
                        case .normal:
                            tm.timerMode = .start
                            tm.isStarted.toggle()
                            tm.backBroundMusic()
                            
                        case .start:
                            audioPlayer1?.stop()
                            tm.timerMode = .normal
                            
                            if let timerStyle = tm.timerStyle {
                                switch timerStyle {
                                case .focus:
                                    tm.progress = 0
                                    tm.elapsedFocusTime = tm.totalFocusTime
                                    
                                case .short:
                                    tm.progress = 0
                                    tm.elapsedShortTime = tm.totalShortTime
                                   
                                case .long:
                                    tm.progress = 0
                                    tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                }
                            }
                            
                            tm.isStarted.toggle()
                            
                        case .pause:
        
                            tm.isStarted.toggle()
                            tm.isPaused.toggle()
                            tm.timerMode = .normal
                            
                            if let timerStyle = tm.timerStyle {
                                switch timerStyle {
                                case .focus:
                                    tm.progress = 0
                                    tm.elapsedFocusTime = tm.totalFocusTime
                                    
                                case .short:
                                    tm.progress = 0
                                    tm.elapsedShortTime = tm.totalShortTime
                                   
                                case .long:
                                    tm.progress = 0
                                    tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                }
                            }
                            
                        case .stop:
                            tm.timerMode = .normal
                        }
                    }, label: {
                        Image(systemName: tm.isStarted ? &quot;square.fill&quot;:&quot;play.fill&quot;)
                            .frame(width : 60, height : 60)
                            .background(tm.isStarted ? .red : .green)
                            .foregroundColor(.white)
                            .font(.title)
                            .cornerRadius(10)
                            .shadow(color: .gray.opacity(0.5), radius: 1, x: 1, y: 1)
                    })
                    .disabled(tm.timerStyle == nil)
                    .padding()
                        
                    Button(action:  {
                        switch tm.timerMode {
                        case .normal:
                            return
                        case .start:
                            audioPlayer1?.stop()
                            tm.timerMode = .pause
                            tm.isPaused.toggle()
                        case .pause:
                            tm.backBroundMusic()
                            tm.timerMode = .start
                            tm.isPaused.toggle()
                        case .stop:
                            return
                        }
                    }, label: {
                        Image(systemName: tm.timerMode == .pause
                              ? &quot;play.fill&quot; : &quot;pause.fill&quot;)
                            .frame(width : 60, height : 60)
                            .background(tm.timerMode == .normal ? .gray : .yellow)
                            .foregroundColor(.white)
                            .font(.title)
                            .cornerRadius(10)
                            .shadow(color: .gray.opacity(0.5), radius: 1, x: 1, y: 1)
                    })
                    .disabled(tm.timerStyle == nil)
                    .padding()
                        
                    Button(action:  {
                        
                        audioPlayer1?.stop()
                        
                        if let timerStyle = tm.timerStyle {
                            switch timerStyle {
                            case .focus:
                                tm.timerMode = .normal
                                tm.timerStyle = .short
                                tm.isStarted = false
                                tm.progress = 0
                                tm.elapsedShortTime = tm.totalShortTime
                            case .short:
                                if tm.isSkipMode {
                                    tm.timerMode = .normal
                                    tm.timerStyle = .focus
                                    tm.isStarted = false
                                    tm.progress = 0
                                    tm.elapsedFocusTime = tm.totalFocusTime
                                } else {
                                    tm.timerMode = .normal
                                    tm.timerStyle = .long
                                    tm.isStarted = false
                                    tm.progress = 0
                                    tm.elapsedLongBreakTime = tm.totalLongBreakTime
                                }
                            case .long:
                                tm.timerMode = .normal
                                tm.timerStyle = .focus
                                tm.isStarted = false
                                tm.progress = 0
                                tm.elapsedFocusTime = tm.totalFocusTime
                            }
                        }
                    }, label: {
                        Image(systemName: &quot;forward.end.fill&quot;)
                            .frame(width : 60, height : 60)
                            .background(.blue)
                            .foregroundColor(.white)
                            .font(.title)
                            .cornerRadius(10)
                            .shadow(color: .gray.opacity(0.5), radius: 1, x: 1, y: 1)
                    })
                    .disabled(tm.timerStyle == nil)
                    .padding()
                        
                    } // hst
                    Spacer()
                }//vst
            }
        }//Zstack
                    .navigationTitle(&quot;PPO.MO ⏱&quot;)
                    .navigationBarTitleDisplayMode(.inline)
                    .navigationBarItems(trailing:
                       HStack{
                        
                        if tm.isOnBackgroundSound {
                            Menu {
                                Button(action: {
                                    switch tm.timerMode {
                                    case .normal:
                                        tm.backgroundNoise = .forest
                                    case .start:
                                        tm.backgroundNoise = .forest
                                        tm.backBroundMusic()
                                    case .pause:
                                        audioPlayer1?.stop()
                                    case .stop:
                                        tm.backgroundNoise = .forest
                                    }
                                    
                                }, label: {
                                    Label(tm.backgroundNoise == .forest ? &quot;✅ Forest&quot; : &quot;Forest&quot;, systemImage: &quot;leaf&quot;)
                                })
                                
                                Button(action: {
                                    switch tm.timerMode {
                                    case .normal:
                                        tm.backgroundNoise = .river
                                    case .start:
                                        tm.backgroundNoise = .river
                                        tm.backBroundMusic()
                                    case .pause:
                                        audioPlayer1?.stop()
                                    case .stop:
                                        tm.backgroundNoise = .river
                                    }
                                }, label: {
                                    Label(tm.backgroundNoise == .river ? &quot;✅ River&quot; : &quot;River&quot;, systemImage: &quot;drop.circle&quot;)
                                })
                                
                                Button(action: {
                                    switch tm.timerMode {
                                    case .normal:
                                        tm.backgroundNoise = .rain
                                    case .start:
                                        tm.backgroundNoise = .rain
                                        tm.backBroundMusic()
                                    case .pause:
                                        audioPlayer1?.stop()
                                    case .stop:
                                        tm.backgroundNoise = .rain
                                    }
                                }, label: {
                                    Label(tm.backgroundNoise == .rain ? &quot;✅ Rain&quot; : &quot;Rain&quot;, systemImage: &quot;cloud.rain&quot;)
                                })
                                
                                Button(action: {
                                    switch tm.timerMode {
                                    case .normal:
                                        tm.backgroundNoise = .wave
                                    case .start:
                                        tm.backgroundNoise = .wave
                                        tm.backBroundMusic()
                                    case .pause:
                                        audioPlayer1?.stop()
                                    case .stop:
                                        tm.backgroundNoise = .wave
                                    }
                                }, label: {
                                    Label(tm.backgroundNoise == .wave ? &quot;✅ Wave&quot; : &quot;Wave&quot;, systemImage: &quot;cloud.rain&quot;)
                                })
                                
                                Button(action: {
                                    tm.backgroundNoise = .turnOff
                                    audioPlayer1?.stop()
                                }, label: {
                                    Label(tm.backgroundNoise == .turnOff ? &quot;✅ Turn off&quot; : &quot;Turn off&quot;, systemImage: &quot;speaker.slash&quot;)
                                })
                                
                            } label: {
                                Image(systemName: tm.backgroundNoise == .turnOff ? &quot;speaker.slash.circle&quot; : &quot;speaker.circle&quot;)
                            }
                        }
                        
                        NavigationLink(destination: {
                            AddTimerView()
                        }, label: {
                            Image(systemName: &quot;plus&quot;)
                        })
                        .simultaneousGesture(TapGesture().onEnded({
                            tm.timerMode = .pause
                            audioPlayer1?.stop()
                        }))
                    })
        }//nav
    }
}

extension TimerView {
    
    func formatTime() -&gt; String {
        
        if let timerStyle = tm.timerStyle {
            switch timerStyle {
            case .focus:
                let minute = Int(tm.elapsedFocusTime) / 60 % 60
                let second = Int(tm.elapsedFocusTime) % 60
                
                return String(format: &quot;%02i:%02i&quot;, minute, second)
            case .short:
                let minute = Int(tm.elapsedShortTime) / 60 % 60
                let second = Int(tm.elapsedShortTime) % 60
                
                return String(format: &quot;%02i:%02i&quot;, minute, second)
            case .long:
                let minute = Int(tm.elapsedLongBreakTime) / 60 % 60
                let second = Int(tm.elapsedLongBreakTime) % 60
                
                return String(format: &quot;%02i:%02i&quot;, minute, second)
            }
        }
            return &quot;00:00&quot;
    }
}
</code></pre>
<p>Hi, I am trying to make pomodoro timer myself.</p>
<p>But, when I checked bugs, I found that my onReceive modifier is turned off when the view is closed by swipe up.</p>
<p>When did that, timer is stopped and I think the onReceive is not working.</p>
<p>So, I want to know how I can maintain onreceive even if the view is swipe down.</p>
","16634995","","","","","2022-03-17 13:36:57","SwiftUI : How I can maintain onReceive when the View in closed","<swiftui><timer><combine>","1","0","","","","CC BY-SA 4.0"
"71520546","1","71532629","","2022-03-18 00:29:33","","0","208","<p>I would like to create a PassthroughSubject object that can send an output of any type. In code I currently have something like this:</p>
<pre><code>let cmd1Subj = PassthroughSubject&lt;String, Never&gt;()
let cmd2Subj = PassthroughSubject&lt;String, Never&gt;()
var desiredCmd: PassthroughSubject&lt;String, Never&gt;?
let executeDesiredCmdSubj = PassthroughSubject&lt;String, Never&gt;()
var arg: String?

func executeDesiredCmd(cmdArg: String) -&gt; AnyPublisher&lt;String, Never&gt; {
    guard (desiredCmd != nil) else {
        return Just(&quot;Nothing to execute\n&quot;).eraseToAnyPublisher()
    }
    desiredCmd?.send(cmdArg)
    return Just(&quot;Executed: \(String(describing: desiredCmd)) with argument: \(cmdArg)&quot;).eraseToAnyPublisher()
}

let cancellable = executeDesiredCmdSubj
    .flatMap(executeDesiredCmd)
    .receive(on: DispatchQueue.main)
    .sink(receiveValue: {
        print($0)
    })

desiredCmd = cmd1Subj
arg = &quot;This is the argument for command 1&quot;
desiredCmd?.send(arg!)
desiredCmd = cmd2Subj
arg = &quot;This is the argument for command 2&quot;
desiredCmd?.send(arg!)
</code></pre>
<p>How do I change <code>desiredCmd</code> and <code>executeDesiredCmdSubj</code> such that they can send an output of any type, as determined at runtime? I'd like to do something like this:</p>
<pre><code>let cmd1Subj = PassthroughSubject&lt;Int, Never&gt;()
let cmd2Subj = PassthroughSubject&lt;String, Never&gt;()
var desiredCmd: PassthroughSubject&lt;Some_Generic_Type, Never&gt;?
let executeDesiredCmdSubj = PassthroughSubject&lt;Some_Generic_Type, Never&gt;()
var arg: Some_Generic_Type?

func executeDesiredCmd(cmdArg: Some_Generic_Type) -&gt; AnyPublisher&lt;String, Never&gt; {
    guard (desiredCmd != nil) else {
        return Just(&quot;Nothing to execute\n&quot;).eraseToAnyPublisher()
    }
    desiredCmd?.send(cmdArg)
    return Just(&quot;Executed: \(String(describing: desiredCmd)) with argument: \(cmdArg)&quot;).eraseToAnyPublisher()
}

let cancellable = executeDesiredCmdSubj
    .flatMap(executeDesiredCmd)
    .receive(on: DispatchQueue.main)
    .sink(receiveValue: {
        print($0)
    })

desiredCmd = cmd1Subj
arg = 12345
desiredCmd?.send(arg!)
desiredCmd = cmd2Subj
arg = &quot;This is the argument for command 2&quot;
desiredCmd?.send(arg!)
</code></pre>
<p>where <strong>Some_Generic_Type</strong> is a placeholder that can be used to represent any type I attempt to pass through my PassthroughSubject. I tried using &quot;Any&quot; as the placeholder but it produces a couple of compilation errors:</p>
<ul>
<li>&quot;Cannot assign value of type 'PassthroughSubject&lt;Int, Never&gt;' to type 'PassthroughSubject&lt;Any, Never&gt;&quot;</li>
<li>&quot;Cannot assign value of type 'PassthroughSubject&lt;String, Never&gt;' to type 'PassthroughSubject&lt;Any, Never&gt;&quot;</li>
</ul>
","4347877","","4347877","","2022-03-18 15:40:57","2022-03-18 20:06:45","How do I create a PassthroughSubject that can have an output of any type?","<swift><casting><combine>","1","4","","","","CC BY-SA 4.0"
"71528818","1","","","2022-03-18 14:47:25","","2","187","<p>I have a class with two variables depending on each other. If one variable changes it should change the other and vice versa.</p>
<p>I am using the Combine framework in iOS Swift. So with <code>sink</code> I am listening/subscribe to changes of the publisher.</p>
<pre><code>var store = Set&lt;AnyCancellable&gt;()
class Obs: ObservableObject {
    @Published var pub: Int = 0
}
let ob1 = Obs()
let ob2 = Obs()
    
ob1.$pub
    .dropFirst()  // ignore initial assignment
    .sink { num in
        if ob2.pub != num {
            ob2.pub = num
        }
    }.store(in: &amp;store)
    
ob2.$pub
    .dropFirst()
    .sink { num in
        if ob1.pub != num {
            ob1.pub = num
        }
    }.store(in: &amp;store)
    
ob1.pub = 1
</code></pre>
<p>With this code I get a stack overflow. How can I break the &quot;infinite loop&quot;?</p>
<p>Should I use something like semaphores? Or some kind of flag within a tuple? Or are there some special combine filter? Or any other ideas...?</p>
<p>I think I may have some general misunderstanding of the problem...</p>
","7405518","","2894790","","2022-03-29 09:25:34","2022-04-06 15:25:45","Variables dependency using Combine","<ios><swift><infinite-loop><combine>","2","2","","","","CC BY-SA 4.0"
"71562543","1","","","2022-03-21 18:37:02","","0","340","<p>I have a combine construct to combine calls to the functions that return AnyPublishers.   [credVendor.credentials() and credVendor.accessToken()]. The issue here is that the call to the publisher does not return back sometimes and the application freezes and the scheduler for timeout does not work.</p>
<p>But when I use a <em>DispatchQueue.main</em> instead of <em>DispatchQueue.global()</em> on the scheduler this behavior never happens. I would like to understand this weird behavior. I pretty new to iOS and still learning. I would really appreciate if someone can point me in the right direction.</p>
<p>Code for the combine.</p>
<pre><code> anyCancellable = credVendor.credentials()
        .combineLatest(credVendor.accessToken())
        .eraseToAnyPublisher()
        .catch { error -&gt; AnyPublisher&lt;(Credentials, AccessToken), Error&gt; in
            return Fail(outputType: (Credentials, AccessToken).self, failure: error).eraseToAnyPublisher()
        }
        .sink(
            receiveCompletion: { completion in
                switch completion {
                case .failure:
                    let error = Error(message: &quot;\(self) Could not find credentials.&quot;, type: .credentialsError)
                    completionHandler?(false, error)
                default: ()
                }
            },
            receiveValue: { [weak self] credentials, accessToken in
                guard let self = self else {
                   return
                }

                self.display(request: request, timer: timer, token: accessToken, credentials: credentials) { result in
                    switch result {
                    case .success(let maybeSplash):
                        -- success-&gt; Do the work
                    case .failure(let error):
                        ---
                        completionHandler?(false, error)
                        return
                    }
                }
              }
        )
</code></pre>
<p>Code for the publishers.</p>
<pre><code> func credentials() -&gt; AnyPublisher&lt;Credentials, Error&gt; {
    return authentication.getSessionId().compactMap { $0 }
        .combineLatest(authentication.getDirectedID().compactMap { $0 })
        .first()
        .setFailureType(to: CredentialsFetchError.self)
        .timeout(.seconds(10), scheduler: DispatchQueue.global(), customError: { .timeout })
        .tryMap { (sessionId, directedId) -&gt; Credentials in
            // use the sessionId and directedId to populate credentials object
            return Credentials(....some attributes)
        }
        .mapError { $0 as Error }
        .eraseToAnyPublisher()
}



func accessToken() -&gt; AnyPublisher&lt;AccessToken, Error&gt; {
    return authentication.accessToken.compactMap { $0 }
        .first()
        .setFailureType(to: CredentialsFetchError.self)
        .timeout(.seconds(10), scheduler: DispatchQueue.global(), customError: { .timeout })
        .mapError { $0 as Error }
        .eraseToAnyPublisher()
}
</code></pre>
","7301679","","7301679","","2022-03-21 20:10:33","2022-03-21 20:10:33","Call to get publishers never returns in combine swift","<ios><swift><combine><combinelatest>","0","3","","","","CC BY-SA 4.0"
"71562973","1","71584586","","2022-03-21 19:17:05","","0","609","<p>I'm very new to the concept Publishers and I'm creating a networking service using <code>dataTaskPublisher</code> on <code>URLSession</code>. There is a case for refreshing token and I have a <code>refreshToken()</code> method which returns <code>AnyPublisher&lt;Bool, Never&gt;</code>:</p>
<pre><code>    func refreshToken() -&gt; AnyPublisher&lt;Bool, Never&gt; {
        var disposable = Set&lt;AnyCancellable&gt;()
        
        do {
            let request = URLRequest(url: URL(string: &quot;refresh_token_url&quot;)!)
            URLSession.shared.dataTaskPublisher(for: request).sink { finished in
                /// Compiler error: Cannot convert value of type 'AnyPublisher&lt;Bool, Never&gt;' to closure result type 'Void'
                return Just(false).eraseToAnyPublisher()
            } receiveValue: { _ in
                /// What should I return here?
                return Just(true).eraseToAnyPublisher()
            }.store(in: &amp;disposable)

        } catch {
            return Just(false).eraseToAnyPublisher()
        }
        
    }
</code></pre>
<p>Compiler complains for both of <code>Just().eraseToAnyPublisher()</code>.  I don't know how and where should return <code>Just(false).eraseToAnyPublisher()</code> based on success or failure of this refresh token call.</p>
","689779","","","","","2022-03-23 09:14:42","Swift: Return publisher after another publisher is done","<swift><combine>","1","5","","","","CC BY-SA 4.0"
"71564445","1","71564601","","2022-03-21 21:38:49","","-1","105","<p><em>NetworkManager</em> class has <em>fetchData</em> generic function for fetching data from Internet.</p>
<pre><code>class NetworkManager {
    
    func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;T, ErrorType&gt; {
        URLSession
            .shared
            .dataTaskPublisher(for: url)
            .tryMap { data, _ in
                return try JSONDecoder().decode(T.self, from: data)
            }
            .mapError { error -&gt; ErrorType in
                switch error {
                case let urlError as URLError:
                    switch urlError.code {
                    case .notConnectedToInternet, .networkConnectionLost, .timedOut:
                        return .noInternetConnection
                    case .cannotDecodeRawData, .cannotDecodeContentData:
                        return .empty
                    default:
                        return .general
                    }
                default:
                    return .general
                }
            }
            .eraseToAnyPublisher()
    }

}
</code></pre>
<p>In <em>HomeRepositoryImpl</em> class I am trying to get data from specific url with <em>AnyPublisher&lt;[CountryDayOneResponse], ErrorType&gt;</em> return value. I wanted to sort responed array, so I used <em>flatMap</em> on <em>NetworkManager</em> like this:</p>
<pre><code>func getCountryStats(for countryName: String) -&gt; AnyPublisher&lt;[CountryDayOneResponse], ErrorType&gt; {
    let url = RestEndpoints.countryStats(countryName: countryName).endpoint()

    return NetworkManager().fetchData(url: url)
        .flatMap { result -&gt; AnyPublisher&lt;[CountryDayOneResponse], ErrorType&gt; in
            switch result {
            case .success(var response):
                let filteredCountry = Array(response.sorted(by: {$0.date &gt; $1.date}))
                response = filteredCountry
                return response
            case .failure(let error):
                return error
            }
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>But I am getting <em>Unable to infer type of a closure parameter 'result' in the current context</em> error.</p>
","16455916","","421018","","2022-03-21 21:47:38","2022-03-21 22:45:49","unable to infer type in flatMap","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71568376","1","71654429","","2022-03-22 07:38:53","","1","349","<p>I try to show progress of file downloading with combine and Alamofire. I have downloader class</p>
<pre><code>class DataManager: NSObject, DataManagerProtocol {
    private(set) var value = 0.0 {
        didSet { subject.send(value) }
    }

    private let subject = PassthroughSubject&lt;Double, Never&gt;()

    func increment(by value: Double) {
        self.value = value
    }
    
    func saveFile(urlString: String, fileName: String) -&gt; AnyPublisher&lt;Double, Never&gt; {
        download(urlString: urlString, fileName: fileName)
        return subject.eraseToAnyPublisher()
    }
    
    private func download(urlString: String, fileName: String) {
        AF.download(urlString)
            .downloadProgress { [self] progress in
                print(&quot;Download Progress: \(progress.fractionCompleted)&quot;)
                increment(by: progress.fractionCompleted)
            }
            .responseData { response in
                if let data = response.value {
                    print(&quot;data recieved&quot;)
                    self.writeToFile(data: data, fileName: fileName)
                }
            }
    }
    
    func writeToFile(data: Data, fileName: String) {
        // get path of directory
        
        guard let directory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).last else {
            return
        }
        // create file url
        let fileurl =  directory.appendingPathComponent(filename)
        if FileManager.default.fileExists(atPath: fileurl.path) {
            if let fileHandle = FileHandle(forWritingAtPath: fileurl.path) {
                print(&quot;FileExist&quot;)
            } else {
                print(&quot;Can't open file to write.&quot;)
            }
        } else {
            // if file does not exist write data for the first time
            do {
                try data.write(to: fileurl, options: .atomic)
            } catch {
                print(&quot;Unable to write in new file.&quot;)
            }
        }
    }
}
</code></pre>
<p>in console I see and file success downloaded</p>
<blockquote>
<p>Download Progress: 0.2707762694368025 Download Progress:
0.30361701168087313 Download Progress: 0.45961053734020857 Download Progress: 0.5088716507063145 Download Progress: 0.5827633207554733
Download Progress: 0.615604062999544 Download Progress:
0.6484448052436146 Download Progress: 0.7798077742198971 Download Progress: 0.8783300009521089 Download Progress: 1.0 data recieved</p>
</blockquote>
<p>but in my ViewModel i dont see publishing of progress changing</p>
<pre><code>import Combine

final class RecordsListViewModel: ObservableObject {
    private var cancellable: AnyCancellable?
    private(set) var progress = PassthroughSubject&lt;Double, Never&gt;()
    private let dataManager: DataManagerProtocol
    
    init(dataManager: DataManagerProtocol) {
        self.dataManager = dataManager
    }
    
    func downloadFile() {
        cancellable = dataManager.saveFile(urlString: &quot;https://i.artfile.ru/2880x1800_1455670_[www.ArtFile.ru].jpg&quot;, fileName: &quot;filename.jpg&quot;)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                print(completion, &quot;completion&quot;)
            } receiveValue: { progress in
                print(progress, &quot;progress&quot;)
            }
    }
}
</code></pre>
","8909145","","","","","2022-04-01 07:59:00","downloading progress with combine","<swift><alamofire><combine>","1","1","","","","CC BY-SA 4.0"
"71575484","1","71575717","","2022-03-22 16:20:26","","2","257","<p>In <em>HomeRepositoryImpl</em> is <em>getWorldWideData</em> function which returns <em>AnyPublisher&lt;WorldwideResponseItem, ErrorType&gt;</em></p>
<pre><code>func getWorldwideData() -&gt; AnyPublisher&lt;WorldwideResponseItem, ErrorType&gt; {
    let url = RestEndpoints.worldwideStats.endpoint()
    let publisher: AnyPublisher&lt;WorldwideResponseItem, ErrorType&gt; = RestManager().fetchData(url: url)
    
    return publisher
        .flatMap {
            let filteredCountries = Array($0.countries.sorted(by: {$0.totalConfirmed &gt; $1.totalConfirmed}).prefix(3))
            $0.countries = filteredCountries
            return Just($0)
        }
}
</code></pre>
<p>FlatMap takes <em>WorldResponseItem</em> from publisher and <em>WorldResponseItem</em> has <em>countries</em> array property which I wanted to sort, so I created new variable called <em>filteredCountries</em> and changed it value to array with 3 sorted countries, and I changed <em>WorldResponseItem</em> countries property to <em>filteredCountries</em> and flatMap is returning Just with <em>WorldResponseItem</em> from publisher.</p>
<p>But I am getting <em>No 'flatMap' candidates produce the expected contextual result type 'AnyPublisher&lt;WorldwideResponseItem, ErrorType&gt;'</em> error, and when I add <em>.eraseToAnyPublisher()</em> to pipeline, I am getting <em>Type of expression is ambiguous without more context</em></p>
","16455916","","4667835","","2022-03-22 16:23:27","2022-03-22 16:37:11","Combine flatMap returning no expected contextual result type","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71603379","1","","","2022-03-24 13:27:13","","1","123","<p>In this example, each time sink fires, newValue contains Bool.</p>
<p>How to get [Bool] with states from all publishers each time it fires?</p>
<p>PS: .collect() before .sink makes it fire only once, that's not what I want, I don't want to stop observing</p>
<pre><code>class SomePublisher: ObservableObject {
    @Published var state: Bool
    
    init(_ value: Bool) {
        state = value
    }
}

class Listener: ObservableObject {
    var bucket: [AnyCancellable] = []
    var publishers: [SomePublisher] = []
    
    func addPublishers() {
        publishers.append(.init(true))
        publishers.append(.init(true))
        publishers.append(.init(false))
        publishers.append(.init(false))
    }
    
    func subscribe() {
        Publishers.MergeMany(publishers.map{ $0.$state })
            .sink { newValue in
                print(newValue)
            }
            .store(in: &amp;bucket)
    }
}

let listener = Listener()
listener.addPublishers()
listener.subscribe()

listener.publishers[1].state = false
DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1) {
    listener.publishers[0].state = false
}
</code></pre>
<p>Output:</p>
<pre><code>true
true
false
false
false
false
</code></pre>
<p>Desired Output:</p>
<pre><code>[true, true, false, false]
[true, false, false, false]
[false, false, false, false]
</code></pre>
","7147231","","","","","2022-03-24 13:39:32","How to get whole all array from observed publishers each time?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"71608511","1","","","2022-03-24 19:41:38","","0","472","<pre><code>    $overallSecondsLeft
    .map
    { ti -&gt; String? in
        let seconds = (ti.rounded(.up))
        if seconds &gt; 0
        {
            return { String(format: &quot;%02d:%02d&quot;, $0.0, $0.1) }(seconds.minutesAndSecondsOverHours)
        }
        return nil
    }
    .assign(to: \.timerText, on: bv)
    .store(in: &amp;cancellables)
</code></pre>
<p>does not work. I mean - nothing happens. map returns string, but this string do not come in timerText.</p>
<p>Variant</p>
<pre><code>    $overallSecondsLeft
    .map
    { ti -&gt; String? in
        let seconds = (ti.rounded(.up))
        if seconds &gt; 0
        {
            return { String(format: &quot;%02d:%02d&quot;, $0.0, $0.1) }(seconds.minutesAndSecondsOverHours)
        }
        return nil
    }
    .sink{ bv.timerText = $0 }
    .store(in: &amp;cancellables)
</code></pre>
<p>works correctly.</p>
<p>Environment:</p>
<pre><code>class BView: UIView {
    ...
    var timerText: String? {
        get { ... }
        set { ... }
    }
    ...
}
guard let bv = view as? BView else { return }
</code></pre>
<p>Obviously, the question is: w..?</p>
<p><em>I found an advice to add .receive(on: RunLoop.main) before .assign, but it did not help.</em></p>
","2685506","","2685506","","2022-03-25 09:44:21","2022-03-25 17:49:22","Swift combine: assign value in .sink, but can't use .assign","<swift><combine>","1","5","1","","","CC BY-SA 4.0"
"71609138","1","","","2022-03-24 20:37:47","","0","49","<p>We have old project we are trying to convert to SwiftUI but right now depending on the state of couple of things we are loading different StoryBoards. But in our case we just one to replace on storyboard at the time with SwiftUI. Any of you knows how can we accomplish this?</p>
<p>Here is an example of how we are loading each StoryBoard:</p>
<pre><code>UIStoryboard *mainStoryboard = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle: nil];
Aceptado *targetViewController = (Aceptado*)[mainStoryboard instantiateViewControllerWithIdentifier:@&quot;servicio_aceptado&quot;];

UINavigationController *navVc=(UINavigationController *) self.window.rootViewController;

[navVc pushViewController: targetViewController animated:YES];
</code></pre>
","2924482","","","","","2022-03-24 20:37:47","iOS: pushing view (SwiftUI) from AppDelegate","<swift><xcode><swiftui><appdelegate><combine>","0","1","","","","CC BY-SA 4.0"
"71629887","1","","","2022-03-26 16:31:18","","0","72","<p>I am trying to use AWS Amplify Auth with iOS Combine to integrate social network logins (Google, Facebook and Apple) but I blocked with:</p>
<pre><code>func signInWithFacebook(context: Any) -&gt; AnyPublisher&lt;AuthSignInResult, AuthError&gt; {
    guard let window = context as? UIWindow else {
        return Fail(error: AuthError(error: Foo.unexpectedError(reason: &quot;empty context&quot;)))
                    .eraseToAnyPublisher()
    }
        
    return Amplify.Auth.signInWithWebUI(for: .facebook, presentationAnchor: window)
            .resultPublisher
            .eraseToAnyPublisher()
}
</code></pre>
<p>FooError is a basic enum</p>
<pre><code>enum FooError: Error {
   case unexpectedError(reason: String)
}
</code></pre>
<p>However, I cannot seem to get the Fail construct correct, I am getting the following error: <code>'AuthSignInStep' cannot be constructed because it has no accessible initializers</code></p>
<p>Thoughts on how I can construct the Fail mechanism?</p>
","768419","","","","","2022-03-26 16:31:18","Using AWS Amplify Auth with iOS Combine","<ios><aws-amplify><combine>","0","0","","","","CC BY-SA 4.0"
"71652616","1","71655103","","2022-03-28 19:15:09","","0","97","<p>I try to implement a simple player app with a tracks list where each row has a play button, and if I press Play for one track, current playing track (if any) should stop playing (in this case Play button should change icon). Here I got some questions - how do I identify current playing track (where Play button is in playing mode), how can I reset it to initial state so that only one track plays at a time.</p>
<p>In this example multiple buttons can be switched to playing state, not exclusively one as desired</p>
<pre><code>import SwiftUI

class Audio: ObservableObject, Identifiable {
    let id = UUID()
    var title: String
    @Published var isPlaying = false {
        didSet {
            print(isPlaying)
        }
    }
    
    init(title: String) {
        self.title = title
    }
}

class AudiosFetcher: ObservableObject {
    
    @Published var audios = [Audio]()
    
    func fetchAudios() {
        audios = [
            Audio(title: &quot;track 1&quot;),
            Audio(title: &quot;track 2&quot;),
            Audio(title: &quot;track 3&quot;)
        ]
    }
    
}

struct ListRow: View {
    
    @ObservedObject var audio: Audio
    
    var body: some View {
        HStack {
            Button(action: {
                audio.isPlaying.toggle()
            }) {
                Image(systemName: audio.isPlaying ? &quot;pause.circle&quot; : &quot;play.circle&quot;)
            }
            .buttonStyle(BorderlessButtonStyle())
            .font(.largeTitle)
            
            Text(audio.title)
        }
    }
}

struct ContentView: View {
    
    @ObservedObject var audiosFetcher = AudiosFetcher()
    
    var body: some View {
        List(audiosFetcher.audios, id: \.id) { audio in
            ListRow(audio: audio)
        }.onAppear {
            audiosFetcher.fetchAudios()
        }
    }
}
</code></pre>
<p><strong>Update: solution</strong></p>
<p>Thanks to @Yrb's answer, we can do it like this. Maybe <code>AudiosFetcher</code> is not the best place to hold current playing audio, but it works and can be extracted to a separate entity if needed</p>
<pre><code>struct ContentView: View {
    // The intialization of the ObservableObject should be a @StateObject,
    // not an @ObservedObject.
    @StateObject var audiosFetcher = AudiosFetcher()
    
    var body: some View {
        List($audiosFetcher.audios) { audio in
            ListRow(audiosFetcher: audiosFetcher, audio: audio)
        }
        .onAppear {
            audiosFetcher.fetchAudios()
        }
    }
}

struct ListRow: View {
    
    @StateObject var audiosFetcher: AudiosFetcher
    @Binding var audio: Audio
    
    var body: some View {
        HStack {
            Button(action: {
                audiosFetcher.playingAudio = (audiosFetcher.playingAudio == audio ? nil : audio)
            }) {
                Image(systemName: audiosFetcher.playingAudio == audio ? &quot;pause.circle&quot; : &quot;play.circle&quot;)
            }
            .buttonStyle(BorderlessButtonStyle())
            .font(.largeTitle)
            
            Text(audio.title)
        }
    }
}

struct Audio: Identifiable, Equatable {
    let id = UUID()
    var title: String
    
    init(title: String) {
        self.title = title
    }
}

class AudiosFetcher: ObservableObject {
    
    @Published var audios = [Audio]()
    @Published var playingAudio: Audio?
    
    func fetchAudios() {
        audios = [
            Audio(title: &quot;track 1&quot;),
            Audio(title: &quot;track 2&quot;),
            Audio(title: &quot;track 3&quot;)
        ]
    }
}
</code></pre>
","3004003","","3004003","","2022-03-29 07:49:58","2022-03-29 07:49:58","SwiftUI: toggle buttons state inside List","<swiftui><binding><combine>","2","0","","","","CC BY-SA 4.0"
"71654244","1","","","2022-03-28 22:07:34","","1","117","<p>My code is printing the value that i want in the console, however the view isn't updating. Ive tried @StateObject as well and still no luck. Checked multiple similar questions and tried their solutions.</p>
<p>My ObservableObject with the @Published var city</p>
<pre><code>class WeatherManager: ObservableObject {
  @Published var city = &quot;Weatha&quot;
  
  let weatherURL = *my url with key*
  
  func fetchWeather(lat: CLLocationDegrees, lon: CLLocationDegrees) {
    let urlString = &quot;\(weatherURL)&amp;lat=\(lat)&amp;lon=\(lon)&quot;
    print(urlString)
    requestData(from: urlString)
  }
  
  func requestData(from url: String) {
    guard let url = URL(string: url) else {
      print(&quot;No URL Found&quot;)
      return
    }
    URLSession.shared.dataTask(with: url) { data, response, error in
      do {
        if let safeData = try JSONDecoder().decode(WeatherModel?.self, from: data!) {
          let weather = safeData
          DispatchQueue.main.async {
            self.city = weather.name
            print(&quot;Success&quot;)
            print(weather.name)
          }
        }
      } catch {
        print(&quot;Failed fetching data, \(error)&quot;)
      }
    }
    .resume()
  }
}
</code></pre>
<p>My view that i'm trying to update with weathermanager.city</p>
<pre><code>struct CenterWeatherView: View {
  @StateObject private var locationManager = LocationManager()
  @ObservedObject var weatherManager = WeatherManager()
  
  var body: some View {
    VStack {
      Text(weatherManager.city)
        .kerning(1.0)
        .fontWeight(.bold)
        .foregroundColor(Color(&quot;TextColor&quot;))
        .multilineTextAlignment(.center)
        .lineSpacing(4)
        .font(.title)
    }
  }
}
</code></pre>
<p>Heres where i make the request if it matters</p>
<pre><code>struct TopToolBar: View {
  
  @StateObject private var locationManager = LocationManager()
  @ObservedObject var weatherManager = WeatherManager()
  var body: some View {
        Button {
          locationManager.manager.requestWhenInUseAuthorization()
          print(locationManager.lastLocation ?? 0)
          weatherManager.fetchWeather(lat: locationManager.lastLocation!.latitude, lon: locationManager.lastLocation!.longitude)
        } label : {
          Image(systemName: &quot;location.circle&quot;)
            .resizable()
            .frame(width: 30, height: 30)
            .foregroundColor(Color(&quot;TextColor&quot;))
            .padding()
      }
}
</code></pre>
<p>I cant get weatherManager.city to on the view, but i get it in the console. Thanks!</p>
","9482722","","","","","2022-03-28 22:07:34","@Published var from ObservableObject not updating SwiftUI View","<ios><swift><struct><swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"71665010","1","71666059","","2022-03-29 15:39:54","","0","167","<p>I am using this code in a SwiftUI view model:</p>
<pre><code>    car.publisher(for: \.sold, options: [.new])
        .removeDuplicates()
        .receive(on: RunLoop.main)
        .sink { [weak self] sold in
            guard let self = self else { return }
            .... here is reference the car entity for some logic ....
        }
        .store(in: &amp;subscribers)
</code></pre>
<p>All works fine, until I actually delete that Car entity and the sink kicks in and then <code>.... here is reference the car entity for some logic ....</code> runs and it crashes trying to use a DELETED Core Data entity.</p>
<p>My pattern seems to be wrong here. Is there a way for that sink to cancel automatically when that car entity is deleted from context?</p>
","728246","","","","","2022-03-29 16:59:17","Swift Combine: sink() called after core data entity deletion","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"71667815","1","71667887","","2022-03-29 19:29:52","","1","545","<p>Today I refactored a ViewModel for a SwiftUI view to structured concurrency. It fires a network request and when the request comes back, updates a <code>@Published</code> property to update the UI. Since I use a <code>Task</code> to perform the network request, I have to get back to the <code>MainActor</code> to update my property, and I was exploring different ways to do that. One straightforward way was to use <code>MainActor.run</code> inside my <code>Task</code>, which works just fine. I then tried to use <code>@MainActor</code>, and don't quite understand the behaviour here.</p>
<p>A bit simplified, my ViewModel would look somewhat like this:</p>
<pre><code>class ContentViewModel: ObservableObject {
    
    @Published var showLoadingIndicator = false
    
    @MainActor func reload() {
        showLoadingIndicator = true
        
        Task {
            try await doNetworkRequest()
            showLoadingIndicator = false
        }
    }
    
    @MainActor func someOtherMethod() {
        // does UI work
    }
    
}
</code></pre>
<p>I would have expected this to not work properly.</p>
<p>First, I expected SwiftUI to complain that <code>showLoadingIndicator = false</code> happens off the main thread. It didn't. So I put in a breakpoint, and it seems even the <code>Task</code> within a <code>@MainActor</code> is run on the main thread. Why that is is maybe a question for another day, I think I haven't quite figured out <code>Task</code> yet. For now, let's accept this.</p>
<p>So then I would have expected the UI to be blocked during my networkRequest - after all, it is run on the main thread. But this is not the case either. The network request runs, and the UI stays responsive during that. Even a call to another method on the main actor (e.g. <code>someOtherMethod</code>) works completely fine.<br />
Even running something like <code>Task.sleep()</code> within <code>doNetworkRequest</code> will STILL work completely fine. This is great, but I would like to understand why.</p>
<p>My questions:<br />
a) Am I right in assuming a <code>Task</code> within a <code>MainActor</code> does not block the UI? Why?<br />
b) Is this a sensible approach, or can I run into trouble by using <code>@MainActor</code> for dispatching asynchronous work like this?</p>
","1421550","","1264804","","2022-03-29 19:32:00","2022-03-29 19:37:29","Why does a Task within a @MainActor not block the UI?","<swift><swiftui><actor><combine><structured-concurrency>","1","2","","","","CC BY-SA 4.0"
"71669228","1","","","2022-03-29 21:58:11","","0","204","<p>I'm trying to implement this solution: <a href=""https://betterprogramming.pub/combine-publishers-and-core-data-424b68fe9473"" rel=""nofollow noreferrer"">Combine, Publishers, and Core Data</a> but I'm getting the following error:</p>
<p><a href=""https://i.stack.imgur.com/S985w.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/S985w.png"" alt=""enter image description here"" /></a></p>
<p>Here is my implantation:</p>
<pre><code>class DataModel: ObservableObject {
    @Published var customers: [Task] = []
    private var cancellables = Set&lt;AnyCancellable&gt;()

    init(viewContext: NSManagedObjectContext) {
        CDPublisher(request: Task.fetchRequest(),
                    context: viewContext)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { value in
                   print(&quot;value: \(value)&quot;)
                })
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>This is part of my view implementation:</p>
<pre><code>import SwiftUI
struct ContentView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @FetchRequest(sortDescriptors: [])
    var dataModel: DataModel
    var task: FetchedResults&lt;Task&gt;
    init() {
        self.dataModel = DataModel(viewContext: viewContext)
    }
    var body: some View {
</code></pre>
<p>Any of you knows why I'm getting this error or what do I need to do to fix this error?</p>
<p>I'll really appreciate your help</p>
","2924482","","","","","2022-03-30 08:58:31","SwiftUI: Property type does not match wrappedValue for type FetchedResults<NSManagedObject>","<xcode><core-data><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"71670739","1","71671698","","2022-03-30 02:10:02","","0","82","<p>I have RestManager class for fetching data from Internet.</p>
<p>I wanted to made special case when empty array is decoded function returns error.</p>
<p>So I made this</p>
<pre><code>class RestManager {

    func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;T, ErrorType&gt; {
        URLSession
        .shared
        .dataTaskPublisher(for: url)
        .tryMap { data, _ in
            let value = try JSONDecoder().decode(T.self, from: data)
            if let array = value as? [AnyObject], array.isEmpty {
                throw ErrorType.empty
            }
            return value
        }
        .mapError { error -&gt; ErrorType in
            switch error {

            case is Swift.DecodingError:
                return ErrorType.empty

            case let urlError as URLError:
                switch urlError.code {
                case .notConnectedToInternet, .networkConnectionLost, .timedOut:
                    return .noInternetConnection
                case .cannotDecodeRawData, .cannotDecodeContentData:
                    return .empty
                default:
                    return .general
                }
            default:
                return .general
            }
        }
        .eraseToAnyPublisher()
   }
}
</code></pre>
<p>But the problem is that returning ErrorType is <em>.general</em> instead of <em>.empty</em></p>
","16455916","","","","","2022-03-30 04:54:57","decoding empty array not throwing specified array","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"71671584","1","","","2022-03-30 04:40:22","","1","114","<p>I have the following class:</p>
<pre><code>class User: ObservableObject {
    @Published private(set) var isPremium: Bool = false
    @Published private var subscriptionType: String = &quot;Trial&quot;
    
    private var cancellables = [AnyCancellable]()
    
    init() {
        $subscriptionType
            .map { type in
                if (type == &quot;Trial&quot; || type == &quot;Subscription_3m&quot;) {
                    return true
                }
                return false
            }
            .assign(to: \.isPremium, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>Now, I would like to be able to persist this <code>user</code> in a Realm DB. So the class would look something like this:</p>
<pre><code>class User: Object {
    @Published private(set) var isPremium: Bool = false
    @Persisted private var subscriptionType: String = &quot;Trial&quot;
    
    private var cancellables = [AnyCancellable]()
    
    override init() {
        super.init()
        
        $subscriptionType
            .map { type in
                if (type == &quot;Trial&quot; || type == &quot;Subscription_3m&quot;) {
                    return true
                }
                return false
            }
            .assign(to: \.isPremium, on: self)
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>The problem I'm facing is that the <code>$</code> notation of the <code>subscriptionType</code> property is no longer valid now that the property is wrapped as <code>@Persisted</code> i.s.o <code>@Published</code></p>
<p>How can I observe changes to <code>subscriptionType</code> like in the original <code>user</code> to be able to change the value of <code>isPremium</code> when a change comes through?</p>
","695524","","","","","2022-04-04 09:13:15","SwiftUI Realm @Published property","<mongodb><swiftui><realm><combine>","1","0","","","","CC BY-SA 4.0"
"71695956","1","71727699","","2022-03-31 16:17:08","","0","210","<p>Working with <code>flagpedia.net/download/api</code></p>
<p>It has two endpoints:</p>
<p>1 - Returns [String:String] dictionary of code-country pairs, like [“us”:”United States”] as a json</p>
<p>2 - Returns an image data for a country code and specified image size, example url <code>flagcdn.com/16x12/us.png</code></p>
<p>I have create two functions using regular completion handler</p>
<ul>
<li><code>fetchCodes(completion: @escaping (Result&lt;[String],Error&gt;) -&gt; Void) { … }</code></li>
<li><code>fetchImage(forCode: String, completion: @escaping (Result&lt;UIImage,Error&gt;) -&gt; Void) { … }</code></li>
</ul>
<p>And also their Combine variations</p>
<ul>
<li><code>fetchCodes() -&gt; AnyPublisher&lt;[String],Error&gt; { … }</code></li>
<li><code>fetchImage(forCode: String) -&gt; AnyPublisher&lt;UIImage,Error&gt; { … }</code></li>
</ul>
<p>Both methods works fine, and returns expected result. How could we merge them?</p>
<p>fetchCodes() method decodes json into dictionary and create an array from the keys.</p>
<p>After getting codes: [String] from fetchCodes() want to do something like this:</p>
<ul>
<li><code>var results = [UIImage]()</code></li>
<li><code>for code in codes {</code></li>
<li><code>let image = fetchImage(forCode: code)</code></li>
<li><code>images.append(image)</code></li>
<li><code>}</code></li>
</ul>
<p>How to achieve this?</p>
<p>I tried Publishers.ManyMerge and flatMap but wasn’t successful. Ended up getting warning regarding mismatch in return types.</p>
<p><code>Sorry for the indentation, I’m posting this on mobile.</code></p>
","2916820","","2916820","","2022-03-31 16:24:26","2022-04-07 14:26:31","How to merge multiple network calls’ responses into an array? With or without Combine?","<ios><swift><combine>","1","0","1","","","CC BY-SA 4.0"
"71697551","1","","","2022-03-31 18:34:33","","1","82","<p>I have a question regarding how can observe am NSManageObject entity. For example I have this two CoreData entities(<code>Todo</code> and <code>Done</code>):</p>
<p><a href=""https://i.stack.imgur.com/d0ztp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/d0ztp.png"" alt=""enter image description here"" /></a></p>
<p>But I want to observe when the done entity has change. Currently I have the following:</p>
<pre><code>class ViewModel: ObservableObject {
    @Published internal var todo:[Todo] = []
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private var context: NSManagedObjectContext
    private let persistanceContainer = PersistanceController.share
    init() {
        self.context = persistanceContainer.container.viewContext
        NotificationCenter.default.publisher(for: .NSManagedObjectContextObjectsDidChange)
            .sink { _ in
                print(&quot;sink&quot;)
            } receiveValue: { _ in
                print(&quot;new value&quot;)
            }.store(in: &amp;cancellables)
    }
}
</code></pre>
<p>The problem with this implementation is I'm getting a notification every time either entity has change. Any of you knows how I specify a particular entity in this case <code>Done</code> entity?</p>
","2924482","","","","","2022-03-31 18:34:33","SwiftUI/Combine: Observe NSManagedObject entity","<xcode><core-data><swiftui><combine><nsmanagedobjectcontext>","0","4","","","","CC BY-SA 4.0"
"71698894","1","","","2022-03-31 20:39:35","","0","439","<p>I'm trying to create an <code>CoreData</code> <code>Entity</code> observer:</p>
<pre><code>@FetchRequest(sortDescriptors: []) var todoResult: FetchedResults&lt;Todo&gt;
    
    init() {
        todoResult.publisher.sink { _ in
            print(&quot;sink&quot;)
        } receiveValue: { todos in
            print(&quot;recoved todos&quot;)
        }.store(in: &amp;cancellables)
}

</code></pre>
<p>But I'm getting this error:</p>
<pre><code>Accessing StateObject's object without being installed on a View. This will create a new instance each time.
</code></pre>
<p><a href=""https://i.stack.imgur.com/whFJH.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/whFJH.png"" alt=""enter image description here"" /></a></p>
<p>Any of you knows why I'm getting this error since I'm not creating this instance in a model? or if you know a work around this error. I'll really appreciated.</p>
","2924482","","","","","2022-04-01 07:56:50","SwiftUI/Combine: FetchedResults Error Accessing StateObject's object without being installed on a View","<xcode><core-data><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"71717828","1","71717875","","2022-04-02 13:10:26","","0","98","<p>I have a Circular ProgressBar View that takes a <code>@Binding var progress: Float</code> property as its progress value, what I would like to be able to do is pass the <code>var progress: Float</code> value from the <code>Task</code> objects respectably in the <code>List</code>. I tried assigning the <code>progress = task.progress</code> the value from the <code>Task</code> objects to a @State property within the ContentView but of course that cannot be done inside a View (see commented code line below).</p>
<p>How can I pass the progress values from each Task to the ProgressBar view respectably?</p>
<h2>Task Model:</h2>
<pre><code>class Task:Identifiable{
    var name = &quot;&quot;
    var progress: Float = 0.0
    
    init(name:String, progress:Float){
        self.name = name
        self.progress = progress
    }
}
</code></pre>
<h2>Content View</h2>
<pre><code>var tasks = [Task(name: &quot;Ketchen Floors&quot;, progress: 0.5),
            Task(name: &quot;Install Windows&quot;, progress: 0.75)]

struct ContentView: View {
    @State var progress:Float = 0.15
    
    var body: some View {
        List {
            ForEach(tasks) { task in
                // outputs error: Type '()' cannot conform to 'View'
                // progress = task.progress 
                HStack{
                    Text(task.name)
                    // here $progress value shoud come from task.progress
                    ProgressBar(progress: $progress)
                }
            }
        }
    }
}
</code></pre>
<h2>ProgressBar View</h2>
<pre><code>struct ProgressBar: View {
    @Binding var progress: Float
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(lineWidth:5.0)
                .opacity(0.3)
                .foregroundColor(Color.orange)
            
            Circle()
                .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0)))
                .stroke(style: StrokeStyle(lineWidth: 5.0, lineCap: .round, lineJoin: .round))
                .foregroundColor(Color.orange)
                .rotationEffect(Angle(degrees: 270.0))
                .animation(.linear, value: progress)

            VStack{
                Text(String(format: &quot;%.0f %%&quot;, min(self.progress, 1.0)*100.0))
                    .font(.caption2)
            }
        }
    }
}
</code></pre>
<h2>Screen</h2>
<p>As you can see, every item shows the initial 15% progress value, no surprise. Again, what I want is to be able to use the value from each Task respectably, Ketchen Floors at 50% and Install Windows at 75%.</p>
<p><a href=""https://i.stack.imgur.com/JNlvp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JNlvp.png"" alt=""enter image description here"" /></a></p>
","1577308","","","","","2022-04-02 13:17:27","How to bind a Float value from a model to a @Binding:Float property in a SwiftUI View","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"71718017","1","","","2022-04-02 13:35:47","","2","113","<p>Event subscription has been added to a <code>scene</code>of an <code>ARView</code> in <code>RealityKit</code>:</p>
<pre><code>arView.scene.subscribe(to: CollisionEvents.Began.self) { event in
    print(&quot;Some collision occured&quot;)
}
</code></pre>
<p><code>Entities</code> are visually colliding in the <code>scene</code> but the <code>CollisionEvent</code> is not being fired. Here are 2 example hierarchies of objects which are clearly colliding:</p>
<p>▿ 'backboard' : __RKPhysics, children: 1<br />
...⟐ PhysicsMotionComponent<br />
...⟐ Transform<br />
...⟐ CollisionComponent<br />
...⟐ SynchronizationComponent<br />
...⟐ PhysicsBodyComponent<br />
...▿ 'simpBld_root' : ModelEntity<br />
......⟐ Transform<br />
......⟐ ModelComponent<br />
......⟐ SynchronizationComponent</p>
<p>With <code>CollisionComponent</code>:</p>
<blockquote>
<p>CollisionComponent(shapes: [RealityKit.ShapeResource], mode: RealityKit.CollisionComponent.Mode.default, filter: RealityKit.CollisionFilter(group: RealityKit.CollisionGroup(rawValue: 1), mask: RealityKit.CollisionGroup(rawValue: 1)))</p>
</blockquote>
<p>▿ 'ball' : ModelEntity
...⟐ Transform<br />
...⟐ CollisionComponent<br />
...⟐ ModelComponent<br />
...⟐ SynchronizationComponent<br />
...⟐ PhysicsBodyComponent</p>
<p>With <code>CollisionComponent</code>:</p>
<blockquote>
<p>CollisionComponent(shapes: [RealityKit.ShapeResource], mode: RealityKit.CollisionComponent.Mode.default, filter: RealityKit.CollisionFilter(group: RealityKit.CollisionGroup(rawValue: 1), mask: RealityKit.CollisionGroup(rawValue: 4294967295)))</p>
</blockquote>
<p>Named <code>Entities</code>have been added to the seen as part of an <code>AnchorEntity</code>:</p>
<pre><code>let anchorEntity = AnchorEntity(anchor: anchor)
anchorEntity.addChild(backboardEntity)
anchorEntity.addChild(ballEntity)
arView.scene.anchors.append(anchorEntity)
</code></pre>
<p>Why are no <code>CollisionEvents</code> not fired?</p>
","17438972","","6599590","","2022-04-02 17:04:15","2022-04-02 17:04:15","Reasons for CollisionEvent not firing in RealityKit scene?","<swift><augmented-reality><collision><combine><realitykit>","1","0","1","","","CC BY-SA 4.0"
"71730852","1","","","2022-04-04 00:22:51","","1","135","<p><a href=""https://i.stack.imgur.com/m2Pjf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/m2Pjf.png"" alt=""enter image description here"" /></a></p>
<p>I cannot figure out how to remove this Passwords autofill box in SwiftUI when building for macOS.  I have tried different kinds of textContentType but nothing gets rid of this box.  It is blocking my attempt to login to my app from a return press.  Both the onCommit, or the keyboardShortcut modifier return press is being swallowed by this box.  The strange thing is, I create a blank new app with one SecureField, and the box is not there.  I am wondering if there is some kind of initial setup telling the app to use suggested passwords?  I know in the past our team looked at password autofill and supporting Associated Domains.</p>
","1302387","","","","","2022-07-20 19:53:10","On a SecureField in SwiftUI How do you remove the password fill box on OSX?","<swift><macos><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"71731482","1","71733431","","2022-04-04 02:35:38","","0","357","<p>I have a SwiftUI <code>ProgressBar</code> View that displays the percentage progress based on a percentage-value you enter as a Bindable parameter. The progress percentage-value is calculated by a <code>ReminderHelper</code> class, which takes two Ints as its parameters, <code>totalDays</code> and <code>daysLeft</code>, the values input to the ReminderHelper class come from a <code>Reminder</code> object saved in Core Data.</p>
<p>I'm very confused as to how to structure my code to accomplish such of thing due to the poor understanding of how the SwiftUI/Combine, @Binding, @Published, @State, etc. work.</p>
<p>Based on the code below, what I'm expecting to see is two reminders, <code>Cut the Grass</code> at 20% and <code>Power Wash Siding</code> at 50%.  Again, the two <code>Ints</code> that determine the total percentage progress come from the <code>Reminder</code> object saved in Core Data and the actual total percentage result comes from the <code>RemindersHelper</code> class.</p>
<p>Any idea how to accomplish what I describe above?</p>
<h2>Model:</h2>
<p>This is saved in Core Data.</p>
<pre><code>class Reminder:Identifiable{
    var name = &quot;&quot;
    var totalDays = 0
    var daysLeft = 0
    
    init(name:String, totalDays:Int, daysLeft:Int){
        self.name = name
        self.totalDays = totalDays
        self.daysLeft = daysLeft
    }
}
</code></pre>
<h2>Helper class</h2>
<p>This needs to be in charge of calculating the total percentage that will be passed to the ProgressBar View with the values coming
from the Reminder object saved in Core Data.</p>
<pre><code>class ReminderHelper:ObservableObject{
    @Published var percentageLeft: Float = 0.80
    
    func calculatePerentageLeft(daysLeft: Int, totalDays:Int)-&gt;Float{
        percentageLeft  = Float(daysLeft / totalDays)
        return percentageLeft
    }
}
</code></pre>
<h2>Content View:</h2>
<p>Here I'm calling the <code>calculatePerentageLeft</code> method to prepare the <code>percentageLeft</code> property before presenting the ProgressBar. Which of course is not working.
I see an error:</p>
<blockquote>
<p>Static method 'buildBlock' requires that 'Float' conform to 'View'</p>
</blockquote>
<pre><code>struct ContentView: View {
    var reminders = [Reminder(name: &quot;Cut the Grass&quot;, totalDays: 50, daysLeft: 10),
                Reminder(name: &quot;Power Wash Siding&quot;, totalDays: 30, daysLeft: 15)]
    
    @StateObject var reminderModel = ReminderHelper()
    
    var body: some View {
        List {
            ForEach(reminders) { reminder in
                HStack{
                    Text(reminder.name)
                    reminderModel.calculatePerentageLeft(daysLeft: reminder.daysLeft, totalDays: reminder.totalDays)
                    ProgressBar(progress: reminderModel.percentageLeft)
                }
            }
        }
    }
}
</code></pre>
<h2>ProgressBar View</h2>
<p>This is the view in charge of drawing and displaying the percentage value.</p>
<pre><code>struct ProgressBar: View {
    @Binding var progress: Float
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(lineWidth:5.0)
                .opacity(0.3)
                .foregroundColor(Color.orange)
            
            Circle()
                .trim(from: 0.0, to: CGFloat(min(self.progress, 1.0)))
                .stroke(style: StrokeStyle(lineWidth: 5.0, lineCap: .round, lineJoin: .round))
                .foregroundColor(Color.orange)
                .rotationEffect(Angle(degrees: 270.0))
                .animation(.linear, value: progress)

            VStack{
                Text(String(format: &quot;%.0f %%&quot;, min(self.progress, 1.0)*100.0))
                    .font(.caption2)
            }
        }
    }
}
</code></pre>
","1577308","","","","","2022-04-04 07:28:11","How to dynamically update a SwiftUI View with an @Bindable value","<swift><swiftui><combine>","1","0","1","","","CC BY-SA 4.0"
"71739969","1","71740763","","2022-04-04 15:37:03","","0","99","<p>So I have this problem with a <code>@Published</code> realm result that is not updating in tests.</p>
<p>Basically what I am trying to do is, to test if a realm update is causing my ViewModel to update the ui. To do this I am subscribing to the published field.</p>
<p>This is the Test:</p>
<pre class=""lang-swift prettyprint-override""><code>   func testListUpdate() {
       // when
       let expectation = XCTestExpectation(description: &quot;Wasn't updated.&quot;)

       _ = sut.$stocks
           .dropFirst()
           .sink { value in
               expectation.fulfill()
           }

       try! realm.write {
           realm.add(Stock(value: [&quot;name&quot;: &quot;Test3&quot;]))
       }

       // then
       wait(for: [expectation], timeout: 1)
   }
</code></pre>
<p><code>sut</code> is the ViewModel which looks like this:</p>
<pre class=""lang-swift prettyprint-override""><code>import Foundation
import RealmSwift

class StockListViewModel: ViewModelBase, ObservableObject {
    let stockRepository: StockRepository

    @Published var stocks: Results&lt;Stock&gt;

    init(stockRepository: StockRepository) {
        self.stockRepository = stockRepository

        stocks = stockRepository.all
            .sorted(byKeyPath: &quot;createdAt&quot;, ascending: true)

        super.init(title: &quot;StockList_title&quot;.localize())

        self.notificationTokens.append(
            stocks
                .observe({ change in
                    switch change {
                    case .update(let updated, _, _, _):
                        self.stocks = updated
                    default: break
                    }
                })
        )
    }
}
</code></pre>
<p>As you can see, the viewmodel has as `@Published var stocks: Results.</p>
<p>In the initializer the stocks are set (this update is emitted by the <code>Publisher</code> successfully and tested in another case.</p>
<p>Then I assign a realm change listener to those stocks and when it updates, I set the stocks new (see in the <code>observe</code> closure). This update is really called, but the <code>sink</code> in the test never emits the update. Thus the test fails.</p>
<p>So my question is: Why is the <code>Publisher</code> emitting the initial value, but never the updated one?</p>
","1640012","","4667835","","2022-04-04 15:48:57","2022-04-04 16:37:57","@Published not emitting update in tests","<swift><realm><combine>","2","4","","","","CC BY-SA 4.0"
"71745549","1","71759403","","2022-04-05 01:56:48","","3","406","<p>As part of moving from RX to Combine. What exactly works like &quot;BehaviorRelay&quot; of RxRelay in Swift Combine?</p>
","1909513","","","","","2022-04-05 23:12:19","Alternative for BehaviorRelay in Swift Combine","<rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"71756471","1","71834974","","2022-04-05 18:06:03","","0","227","<p>I am new to the combine world and have written a query that returns the results I need correctly. It's multi-step, but basically makes an api call over the network, parses the returned json and creates an array of records I need.</p>
<pre class=""lang-swift prettyprint-override""><code>let results2: Publishers.Map&lt;Publishers.ReceiveOn&lt;Publishers.Decode&lt;Publishers.Map&lt;URLSession.DataTaskPublisher, JSONDecoder.Input&gt;, Wrapper&lt;Question&gt;, JSONDecoder&gt;, DispatchQueue&gt;, [Question]&gt;
</code></pre>
<p>I'm trying to rewrite a portion of my code and realize that I still don't quite grasp the ins and outs of parsing the results.
If you look at the datatype of results2 you will see the final portion contains an array of <code>Question</code>. How do I assign this array to a variable, as in:</p>
<pre class=""lang-swift prettyprint-override""><code>let finalAnswer: [Question] = turnThisIntoAnArray(results2)
</code></pre>
<p>If possible, I'd prefer a general answer to this general question, rather than providing all the code needed to recreate this specific string of publishers.</p>
<p>thanks</p>
","5156054","","","","","2022-04-11 22:23:37","How do i parse results from a combine publisher","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"71757173","1","","","2022-04-05 19:07:25","","0","172","<p>I am trying to use Combine to load initial results using cache from Realm and then making a network request but keep running into road blocks.</p>
<p>My work in progress code tries to fetch cache then chains the network request. It also tries to catch the correct errors and maps them to return data which is correct. I'm trying to change it to return the cached results first and then fetch network results all at the same time, I don't think currently it does this.</p>
<p>My function in Combine:</p>
<pre><code>    func fetch(byCurrency currency: String) -&gt; AnyPublisher&lt;CreditType, DataError&gt; {
        let networkPublisher = store.fetch(byCurrency: currency)

        guard let cacheStore = self.cacheStore else {
            return networkPublisher
        }
        
        let cachedPublisher = cacheStore.fetch(byCurrency: currency)
    
        return cachedPublisher
            .flatMap { cachedCredit -&gt; AnyPublisher&lt;CreditType, DataError&gt; in
                return networkPublisher
                    .flatMap { networkCredit -&gt; AnyPublisher&lt;CreditType, DataError&gt; in
                        return cacheStore.createOrUpdate(networkCredit)
                            .eraseToAnyPublisher()
                    }
                    .eraseToAnyPublisher()
            }
            .catch { error -&gt; AnyPublisher&lt;CreditType, DataError&gt; in
                if case .nonExistent = error {
                    return networkPublisher
                        .flatMap { networkCredit -&gt; AnyPublisher&lt;CreditType, DataError&gt; in
                            return cacheStore.createOrUpdate(networkCredit)
                        }
                        .eraseToAnyPublisher()
                }
                return AnyPublisher(Fail&lt;CreditType, DataError&gt;(error: error))
            }
            .eraseToAnyPublisher()
    }
</code></pre>
<p>Function to convert:</p>
<pre><code>    func fetch(byCurrency currency: String, completion: @escaping (Result&lt;CreditType, DataError&gt;) -&gt; Void) {

        // Use cache storage if applicable
        guard let cacheStore = cacheStore else { return store.fetch(byCurrency: currency, completion: completion) }
        
        cacheStore.fetch(byCurrency: currency) {

            // Retrieve missing cache data from cloud if applicable
            if case .nonExistent? = $0.error {

                return self.store.fetch(byCurrency: currency) {

                    guard let element = $0.value, $0.isSuccess else { return completion($0) }
                    cacheStore.createOrUpdate(element, completion: completion)
                }
            }
            
            // Immediately return local response
            completion($0)
            
            guard let cacheElement = $0.value, $0.isSuccess else { return }
            
            // Sync remote updates to cache if applicable
            self.store.fetch(byCurrency: currency) {

                // Validate if any updates that needs to be stored
                guard let element = $0.value, cacheElement.amountCents != element.amountCents, $0.isSuccess else { return }
                
                // Update local storage with updated data
                cacheStore.createOrUpdate(element) {

                    guard $0.isSuccess else {
                        return self.Log(error: &quot;Could not save updated credit locally from remote storage: \(String(describing: $0.error))&quot;)
                    }
                    
                    // Callback handler again if updated
                    completion($0)
                }
            }
        }
    }
</code></pre>
","8213026","","","","","2022-04-05 19:07:25","How to load results from Realm cache while loading network results in Swift Combine","<swift><networking><caching><realm><combine>","0","2","","","","CC BY-SA 4.0"
"71774817","1","","","2022-04-06 23:53:35","","0","232","<p>I'm new to combine and URLSession and I'm trying to find a way to log in after I get a 401 error back. My Set up for the URLSession.</p>
<p>APIErrors:</p>
<pre><code> enum APIError: Error {
  case requestFailed
  case jsonConversionFailure
  case invalidData
  case responseUnsuccessful
  case jsonParsingFailure
  case authorizationFailed
  
  var localizedDescription: String{
    switch self{
    case .requestFailed: return &quot;Request Failed&quot;
    case .invalidData: return &quot;Invalid Data&quot;
    case .responseUnsuccessful: return &quot;Response Unsuccessful&quot;
    case .jsonParsingFailure: return &quot;JSON Parsing Failure&quot;
    case .jsonConversionFailure: return &quot;JSON Conversion Failure&quot;
    case .authorizationFailed: return &quot;Failed to login the user.&quot;
    }
  }
} 
</code></pre>
<p>The CombinAPI itself, I'm trying to catch the 401 either in .catch or .tryCatch, but proving not as easy as I thought.</p>
<pre><code>//1- A Protocol that has an URLSession and a function that returns a publisher.
protocol CombineAPI{
  var session: URLSession { get}
 // var authenticationFeed: AuthenticationFeed { get }
  
  func execute&lt;T&gt;(_ request: URLRequest, decodingType: T.Type, queue: DispatchQueue, retries: Int) -&gt; AnyPublisher&lt;T, Error&gt; where T: Decodable
  //func reauthenticate&lt;T&gt;(_ request: URLRequest, decodingType: T.Type, queue: DispatchQueue, retries: Int) -&gt; AnyPublisher&lt;T, Error&gt; where T: Decodable
}

//2 - Extending CombineAPI so we can have a default implementation.
extension CombineAPI {
 func authenticationFeed() -&gt; URLRequest{
   return AuthenticationFeed.login(parameters: UserCredentials(userName: UserSettings.sharedInstance.getEmail(), password: UserSettings.sharedInstance.getPassword())).request
  }
  
  func execute&lt;T&gt;(_ request: URLRequest,
                  decodingType: T.Type,
                  queue: DispatchQueue = .main,
                  retries: Int = 0) -&gt; AnyPublisher&lt;T, Error&gt; where T: Decodable{
    return session.dataTaskPublisher(for: request)
      .tryMap {
        guard let response = $0.response as? HTTPURLResponse, response.statusCode == 200 else{
          let response = $0.response as? HTTPURLResponse
          if response?.statusCode == 401{
            throw APIError.authorizationFailed
          }
          print(response!.statusCode)
          throw APIError.responseUnsuccessful
        }
        //Return the data if everything is good
        return $0.data
      }
      .catch(){ _ in
        //Try to relogin here or in tryCatch block


      }
    //      .tryCatch { error in
    //        if Error as? APIError == .authorizationFailed {
    //          let subcription = self.callFunction().switchToLatest().flatMap { session.dataTaskPublisher(for: request)}.eraseToAnyPublisher()
    //          return subcription
    //        }else{
    //          throw APIError.responseUnsuccessful
    //        }
    //      }
      .decode(type: T.self, decoder: JSONDecoder())
      .receive(on: queue)
      .retry(retries)
      .eraseToAnyPublisher()
  }
  
  func reauthenticate&lt;T&gt;( decodingType: Token.Type, queue: DispatchQueue = .main,retries: Int = 2) -&gt; AnyPublisher&lt;T, Error&gt; where T: Decodable{
    return session.dataTaskPublisher(for: self.authenticationFeed())
      .tryMap{
        guard let response = $0.response as? HTTPURLResponse, response.statusCode == 200 else{
          let response = $0.response as? HTTPURLResponse
          if response?.statusCode == 401{
            throw APIError.authorizationFailed
          }
          print(response!.statusCode)
          throw APIError.responseUnsuccessful
        }
        //Return the data if everything is good
        return $0.data
      }
      .decode(type: T.self, decoder: JSONDecoder())
      .receive(on: queue)
      .retry(retries)
      .eraseToAnyPublisher()
  }
  
  
}
</code></pre>
<p>This is the feed that will create the URL request itself:</p>
<pre><code>enum UserFeed{
  case getUser(userId: Int)
}

extension UserFeed: Endpoint{
  var base: String {
    return &quot;http://192.168.1.15:8080&quot;
  }
  
  var path: String {
    switch self{
    case .getUser(let userId): return &quot;/api/v1/User/\(userId)&quot;
    }
  }
  
  
  var request: URLRequest{
    let url = urlComponents.url!
    var request = URLRequest(url: url)
    switch self{
    case .getUser(_):
      request.httpMethod = CallType.get.rawValue
      request.setValue(&quot;*/*&quot;, forHTTPHeaderField: &quot;accept&quot;)
      request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
      request.setValue(token,forHTTPHeaderField:  &quot;tokenheader&quot;)
      print(token)
      return request
    }
  } 
}
</code></pre>
<p>Then the client itself where you would create this would be in your viewModel, so you can make the web request for that type of data:</p>
<pre><code>import Foundation
import Combine

final class UserClient: CombineAPI{
  var authenticate = PassthroughSubject&lt;Token, Error&gt;()
  
  
  var session: URLSession
  
  init(configuration: URLSessionConfiguration){
    self.session = URLSession(configuration: configuration)
    
  }
  
convenience init(){
    self.init(configuration: .default)
  }
  
  func getFeedUser(_ feedKind: UserFeed) -&gt; AnyPublisher&lt;User, Error&gt;{
    return execute(feedKind.request, decodingType: User.self, retries: 2)
  }
}

</code></pre>
<p>I keep trying to make a new request to my authenticationClient, but it returns a different data type, so the ComineAPI doesn't like it. I'm not sure what I should do, otherwise, it works great until I have to authenticate, or get a new token? Any help would be appreciated, thanks.</p>
<p>I Just need it to log in, so I can save the new token to user settings and then continue on the request it left off with, If I can't get a new token, then I return an error to have the user login.</p>
","2649729","","","","","2022-04-16 14:22:57","How Do I relogin after getting a 401 back using URLSession and CombineAPI","<swift><combine><urlsession>","1","2","","","","CC BY-SA 4.0"
"71783587","1","71783622","","2022-04-07 13:59:26","","-1","112","<p>I am adding Combine to my iOS application. To do this, I have updated my create account ViewModel to use Combine rather than my previous implementation. Upon adding Combine to my ViewModel, I was met with an error prompting me to add <code>@available(iOS 13.0, *)</code> to my class. I also must add this attribute to every single VC that uses this ViewModel. My deployment target is iOS 13.0 so I am wondering if this is really necessary. Is there a way I can avoid adding this attribute in each class since I will have no users operating on an iOS version lower than iOS 13.0?</p>
","5568827","","","","","2022-04-07 14:01:24","Do I still need the @availible 13.0 attribute in my class if my minimum deployment target is iOS 13.0?","<ios><swift><combine><deployment-target>","1","1","","","","CC BY-SA 4.0"
"71795155","1","71795365","","2022-04-08 10:05:11","","0","187","<p>I have a variable with default value. And make a network call to get the value from server. If it returns some error, then I want to make the variable to <code>nil</code>. How can I do this with <code>Future</code>, <code>Promise</code>, <code>Combine</code>?</p>
<p><a href=""https://www.vadimbulavin.com/asynchronous-programming-with-future-and-promise-in-swift-with-combine-framework/"" rel=""nofollow noreferrer"">Asynchronous Programming with Futures and Promises in Swift with Combine Framework
</a></p>
","8014650","","8014650","","2022-04-08 10:44:18","2022-04-08 11:37:20","How to assign nil if network call returns error using Combine","<swift><promise><future><combine>","2","0","0","","","CC BY-SA 4.0"
"71812578","1","","","2022-04-09 23:09:07","","0","158","<p>How make CountdownTimer and how make let elapsed = public var . I want to make the variable constantly decrease life.
For example, as in Tamagotchi - You need to constantly feed the animal so that it does not die.
This timer should continuously run until it reaches 0. When the tamagotchi eats, the value is again added to the variable, which decreases over time.</p>
<pre><code>class Stopwatch: ObservableObject {
    /// String to show in UI
    @Published private(set) var message = &quot;Not running&quot;
    /// Is the timer running?
    @Published private(set) var isRunning = false
    /// Time that we're counting from
    private var startTime: Date? { didSet { saveStartTime() } }
    /// The timer
    private var timer: AnyCancellable?
    init() {
        startTime = fetchStartTime()
        if startTime != nil {
            start()
        }
    }
}
</code></pre>
<hr />
<pre><code>extension Stopwatch {
    func start() {
        timer?.cancel()  // cancel timer if any
        if startTime == nil {
            startTime = Date()
        }
        message = &quot;&quot;
        timer = Timer
            .publish(every: 0.1, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                guard
                    let self = self,
                    let startTime = self.startTime
                else { return }
                let now = Date()
                let elapsed = now.timeIntervalSince(startTime)
                guard elapsed &lt; 60 else {
                    self.stop()
                    return
                }
                self.message = String(format: &quot;%0.1f&quot;, elapsed)
            }
        isRunning = true
    }
    func stop() {
        timer?.cancel()
        timer = nil
        startTime = nil
        isRunning = false
        message = &quot;Not running&quot;
    }
}
</code></pre>
<hr />
<pre><code>private extension Stopwatch {
    func saveStartTime() {
        if let startTime = startTime {
            UserDefaults.standard.set(startTime, forKey: &quot;startTime&quot;)
        } else {
            UserDefaults.standard.removeObject(forKey: &quot;startTime&quot;)
        }
    }
    func fetchStartTime() -&gt; Date? {
        UserDefaults.standard.object(forKey: &quot;startTime&quot;) as? Date
    }
}
</code></pre>
<hr />
","18758802","","2303865","","2022-04-10 00:53:49","2022-04-10 00:53:49","SwiftUI: How to run a CountdownTimer in background","<swift><swiftui><timer><countdowntimer><combine>","0","3","","","","CC BY-SA 4.0"
"71822621","1","","","2022-04-11 04:06:54","","0","226","<p>What is the most idiomatic way to process a value a given number of times when that value is derived from another publisher and the resultant value is used in the next iteration?</p>
<p>If the value didn't come from another publisher I would use <code>reduce</code>.</p>
<p>Since I own this code I can rewrite to not return a publisher but I would like to know how this situation should be handled using Combine.</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import Foundation

let iterations = 1000
let initialValue = 0
let intSubject = PassthroughSubject&lt;Int, Never&gt;()

// Iterate over a value a number of times passing the result to the next iteration.
// This seems a lot like reduce but the problem is the reduce closure returns a value not a publisher.

let x = intSubject
        .flatMap { number in
            // This is the important part.  The number from the previous iteration
            // is needed to create the next publisher.  In the real life scenario this
            // result object is more complex than an Int.  Integer addition is used
            // here as an example I am not looking for a way to solve integer addition.
            return number.addOne()
        }
        .handleEvents(receiveOutput: { (number: Int) in
            DispatchQueue.main.async {
                intSubject.send(number)
            }
            return
        })
        .handleEvents(receiveRequest: { _ in
            DispatchQueue.main.async {
                intSubject.send(initialValue)
            }
        })
        .prefix(iterations)
        .eraseToAnyPublisher()

let subscription = x.sink(receiveValue: { number in print(&quot;\(number)&quot;) })

extension Int {
    func addOne() -&gt; AnyPublisher&lt;Int, Never&gt; {
        // Only returns a single value and completes
        [self].publisher.map { $0 + 1 }.eraseToAnyPublisher()
    }
}

</code></pre>
<p><strong>UPDATE 1</strong></p>
<p>I decided perhaps my contrived example was concealing some things so at the risk of complicating things here is my real scenario.  I was able to make a small simplication by using <code>CurrentValueSubject</code> instead of <code>PassthroughSubject</code> which handles the initial value nicely.</p>
<p>I am still not convinced that using <code>handleEvents</code> is the best way to propagate updated values back for the next iteration.  Additionally I don't want to use <code>.sink</code> as I want to pass the publisher on outside of this function for later subscription.</p>
<pre class=""lang-swift prettyprint-override""><code>    public func evolve(generations: Int, offspringCount: Int, populationLimit: Int, randomNumberGenerator: RandomNumberSource) -&gt; AnyPublisher&lt;GenePool&lt;Environment&gt;, GenePoolError&gt; {
        let genePoolSubject = CurrentValueSubject&lt;GenePool&lt;Environment&gt;, Never&gt;(self)

        return genePoolSubject
                .flatMap { genePool -&gt; AnyPublisher&lt;GenePool&lt;Environment&gt;, GenePoolError&gt; in
                    genePool.evolve(
                        offspringCount: offspringCount,
                        populationLimit: populationLimit,
                        randomNumberGenerator: randomNumberGenerator
                    )
                }
                .handleEvents(receiveOutput: { (pool: GenePool&lt;Environment&gt;) in
                    DispatchQueue.main.async {
                        genePoolSubject.send(pool)
                    }
                })
                .prefix(generations)
                .eraseToAnyPublisher()
    }

    private func evolve(offspringCount: Int, populationLimit: Int, randomNumberGenerator: RandomNumberSource) -&gt; AnyPublisher&lt;GenePool&lt;Environment&gt;, GenePoolError&gt; { ... }
</code></pre>
","1721611","","1721611","","2022-04-11 11:11:38","2022-04-11 11:11:38","Swift Combine equivalent of reduce where return value is a publisher not a value","<swift><reduce><combine>","0","7","","","","CC BY-SA 4.0"
"71828397","1","","","2022-04-11 13:06:15","","0","64","<pre class=""lang-swift prettyprint-override""><code>public struct FriendlyTextField: View, BeFriend {
    public let eternalId: String
    let title: String
    @Binding var text: String

    @State var focused: Bool = false

    @StateObject var speechManager = SpeechManager.shared
    @StateObject var positionManager = PositionManager.shared

    public init(_ id: String, _ title: String, text: Binding&lt;String&gt;) {
        self.eternalId = id
        self.title = title
        self._text = text
    }

    public var body: some View {
        FriendlyWrappedView(eternalId) {
            TextField(title, text: $text)
                .onAppear {
                    focused = true
                    print(focused)
                }
        }
        .onRight {
            focused = true

            if !focused {
                speechManager.startRecord()
                speechManager.onRecord = eternalId
            } else {
                speechManager.stopRecord()
                speechManager.onRecord = &quot;&quot;
            }
        }
        .onChange(of: self.focused) {
            if !$0 {
                speechManager.stopRecord()
                speechManager.onRecord = &quot;&quot;
            }
        }
        .onChange(of: speechManager.text) { _ in
            if speechManager.onRecord == eternalId {
                text = speechManager.lastText + speechManager.text
            }
        }
        .onChange(of: speechManager.lastText) { _ in
            if speechManager.onRecord == eternalId {
                text = speechManager.lastText + speechManager.text
            }
        }
        .onChange(of: positionManager.focus) { newValue in
            if newValue != eternalId {
                focused = false
            }
        }
    }
}
</code></pre>
<p>When this view appears, it prints <code>false</code>, but I set <code>focused</code> to <code>true</code>.
<code>FriendlyWrappedView</code> is just adding some modifiers to the view.
Also <code>StateObject</code> doesn't work. The published value was changed, but <code>onChange</code> isn't called.</p>
<p>And when I change <code>text</code>'s value, it works well.</p>
<p>If I change <code>focused</code> to a binding value, it works again</p>
<p>My Xcode version: 13.3
My iPad version: 15.4</p>
<p>Other views work well.</p>
","14854365","","","","","2022-04-11 13:06:15","SwiftUI @State cannot be modified","<ios><swift><ipad><swiftui><combine>","0","6","","","","CC BY-SA 4.0"
"71831249","1","","","2022-04-11 16:28:39","","0","180","<p>I have created a <code>gravityPublisher</code> (to receive updates in the current gravity vector) and subscribe to it by calling the following function:</p>
<pre><code>private func enableGravityDetection(_ gravityEnabled: Bool) {
    if gravityEnabled {
        if cancellable == nil {
            cancellable = gravityProvider
                .gravityPublisher
                .receive(on: RunLoop.main)
                .print()
                .assign(to: \.gravity, on: self)
        }
    } else {
        cancellable?.cancel()
    }
}
</code></pre>
<p>The <code>gravityPublisher</code> itself is just a <code>CurrentValueSubject</code></p>
<pre><code>private var gravitySubject = 
    CurrentValueSubject&lt;CMAcceleration, Never&gt;(CMAcceleration())
</code></pre>
<p>erased to <code>AnyPublisher&lt;CMAcceleration, Never&gt;</code>. The <code>cancellable</code> is stored as a state property as follows:</p>
<pre><code>@State private var cancellable: Cancellable?
</code></pre>
<p>I need to call this function from within a SwiftUI view. When I call it from an <code>onAppear</code> block everything works as expected and I continuously receive gravity vector updates:</p>
<pre><code>struct CustomView: View {
    var body: some View {
        MyView()
            .onAppear {
                enableGravityDetection(true)
            }
    }
}
</code></pre>
<p>However, when I call the same (unmodified) function from the view's initializer, I don't receive any gravity updates as the subscription is immediately canceled:</p>
<pre><code>struct CustomView: View {
    init() {
        enableGravityDetection(true)
    }

    var body: some View {
        MyView()
    }
}
</code></pre>
<p>The <code>print()</code> statement in the stream above prints the following output in this case:</p>
<pre><code>receive subscription: (ReceiveOn)
request unlimited
receive cancel // ← Why?
</code></pre>
<h3>Why is that and how can I fix this?</h3>
<p>I need to call this function in the initializer as I sometimes need to stop receiving gravity updates and need to decide this every time the view is recreated. (<code>onAppear</code> is only called once.)</p>
","2062785","","2062785","","2022-04-11 16:46:52","2022-04-11 16:46:52","Why is my Publisher subscription immediately cancelled when called from a SwiftUI view initializer?","<swift><swiftui><publish-subscribe><combine>","0","5","","","","CC BY-SA 4.0"
"71831820","1","71832336","","2022-04-11 17:15:16","","1","118","<p>I have the following code:</p>
<pre><code>    $myBoolean
        .debounce(for: 2, scheduler: RunLoop.main)
        .removeDuplicates()
        .sink { newValue in
            self.myBoolean = false
            ....... 
            ...... (closure called every 2 seconds if I don't use `removeDuplicates()`)
        }
        .store(in: &amp;subscribers)
</code></pre>
<p>I am using sink() on a @Published var in my observable object. Different parts of the app can set that boolean to <code>true</code>. When that happens, I want the code in <code>sink()</code> to run.</p>
<p>When that happens I want the code to reset <code>myBoolean</code> to false. So, only when I know the sink() code runs I want the boolean to be set back to false.</p>
<p>How can I set myBoolean back to false only when the sink() code runs without cause endless calls to the sink()?</p>
<p><code>myBoolean</code> is declared like so:</p>
<pre><code>@Published fileprivate var myBoolean:Bool = false
</code></pre>
","728246","","","","","2022-04-11 18:08:49","Combine: resetting observed boolean within sink() call?","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"71833216","1","71834482","","2022-04-11 19:20:08","","0","368","<p>I have the results from a publisher in an <code>Effect&lt;[Int], Error&gt;</code>
How do I assign that [Int] to a variable?</p>
<p>Although I am able to get the results using this:</p>
<pre><code>         case .reviewed:
               return environment.networkQuery.reviewed(pageCount: 1)
                  .catchToEffect()
                  .map(BespokeAction.processQueryResults)
         case let .processQuestionResult(.success(ids)):
             ...
  
         case let .processQuestionResult(.failure(error)):
            print(error)
           ...
</code></pre>
<p>I want to use the publisher outside of the reducer:</p>
<pre><code>let values: Effect&lt;[Question], Error&gt; = environment.networkQuery.reviewed(pageCount: 1)
</code></pre>
<p>what do I do to <code>values</code> to extract the array upon success?</p>
<p>note: this a more finely resolved take on a question I posted previously:</p>
<p><a href=""https://stackoverflow.com/questions/71756471/how-do-i-parse-results-from-a-combine-publisher"">previously asked</a></p>
","5156054","","","","","2022-04-11 22:29:08","In TCA: How to extract from Effect when not in the reducer?","<swift><combine><swift-composable-architecture>","1","0","","","","CC BY-SA 4.0"
"71835198","1","71835409","","2022-04-11 22:55:55","","1","93","<p>I am observing a peculiar behavior in my SwiftUI code and narrowed it down to the following minimal example.</p>
<p>Given this example storage holding an array of book model structs.</p>
<pre class=""lang-swift prettyprint-override""><code>struct Book: Identifiable {
    let id: UUID
    var likes: Int
    var unusedProperty: String = &quot;&quot;
}

extension Book: Equatable {
    static func == (lhs: Book, rhs: Book) -&gt; Bool {
        return lhs.id == rhs.id
    }
}

class MyStorage: ObservableObject {

    @Published var books: [Book] = [
        .init(id: .init(uuidString: &quot;B2A44450-BC03-47E6-85BE-E89EA69AF5AD&quot;)!, likes: 0),
        .init(id: .init(uuidString: &quot;F5AB9D18-DF73-433E-BB48-1C757CB6F8A7&quot;)!, likes: 0)
    ]

    func addLike(to book: Book) {
        for i in books.indices where books[i].id == book.id {
            books[i].likes += 1
        }
    }
}
</code></pre>
<p>And using it in this simple view hierarchy:</p>
<pre class=""lang-swift prettyprint-override""><code>struct ReducedContentView: View {
    @StateObject var storage: MyStorage = MyStorage()

    var body: some View {
        VStack(spacing: 8) {
            ForEach(storage.books) { book in
                HStack {
                    VStack(alignment: .leading) {
                        Text(&quot;Top-Level: \(book.likes)&quot;)
                        BookView(book: book)
                    }
                    Spacer()
                    Button(&quot;Add Like&quot;) {
                        storage.addLike(to: book)
                    }
                }.padding(.horizontal)
            }
        }
    }
}

struct BookView: View {
    let book: Book

    var body: some View {
        Text(&quot;Nested: \(book.likes)&quot;)
            .foregroundColor(.red)
    }
}
</code></pre>
<p>Any changes to the <code>likes</code> property don't propagate to the <code>BookView</code>, only to the &quot;top-level&quot; <code>Text</code>.</p>
<p><a href=""https://i.stack.imgur.com/a3si7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/a3si7.png"" alt=""enter image description here"" /></a></p>
<p>Now, <strong>if I change one of the following</strong>, it works:</p>
<ul>
<li>remove the <code>unusedProperty</code> (which is needed in production)</li>
<li>add <code>&amp;&amp; lhs.likes == rhs.likes</code> to the Equatable conformance (which is not intended)</li>
<li>modify <code>BookView</code> to accept <code>@Binding var book: Book</code> instead of a <code>let</code></li>
</ul>
<p>The last option is something I could adopt in my production code - nevertheless, I would really like to understand what's happening here, so any hints would be greatly appreciated.</p>
","5328140","","","","","2022-04-11 23:32:46","SwiftUI does not reliably propagate changes to child view","<ios><swift><swiftui><combine>","1","0","0","","","CC BY-SA 4.0"
"71853467","1","","","2022-04-13 07:22:27","","0","202","<h3>Question</h3>
<p>When I receive URL strings nested in JSON from the request response, what would be the best practices for downloading data from them?</p>
<h3>Detail</h3>
<p>For example, let's say I have downloaded several profile data from a network and then need to display them in a table where the names are displayed with profile images.</p>
<p><strong>Raw data</strong></p>
<pre><code>{
    {
        &quot;name&quot;: &quot;Jack&quot;,
        &quot;imageUrl&quot;: &quot;https://example.image/1.jpg&quot;
    },
    {
        &quot;name&quot;: &quot;Tom&quot;,
        &quot;imageUrl&quot;: &quot;https://example.image/2.jpg&quot;
    },
    {
        &quot;name&quot;: &quot;Mark&quot;,
        &quot;imageUrl&quot;: &quot;https://example.image/3.jpg&quot;
    }
}
</code></pre>
<p><strong>Codable struct</strong></p>
<pre><code>struct ProfileData: Codable {
    let name: String
    let imageUrl: String
    
    enum CodingKeys: String, CodingKey {
        case name, imageUrl
    }
}
</code></pre>
<p>I usually use <code>dataTaskPublihser</code> to get an array of Profiles(<code>[Profile]</code>) and image(<code>UIImage</code>) like:</p>
<pre><code>
func getProfileData() -&gt; AnyPublisher&lt;[ProfileData], Error&gt; {
    let exampleUrl = URL(string: &quot;https://exmaple.com&quot;)!
    return URLSession.shared.dataTaskPublisher(for: exampleUrl)
        .tryMap { (data, response) -&gt; Data in
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                throw URLError(.badServerResponse)
            }
            return data
        }
        .decode(type: [Profile].self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
}

func getImage(url: String) -&gt; AnyPublisher&lt;UIImage, Error&gt; {
    let exampleUrl = URL(string: url)!
    return URLSession.shared.dataTaskPublisher(for: exampleUrl)
        .tryMap { (data, response) -&gt; Data in
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                throw URLError(.badServerResponse)
            }
            return data
        }
        .map { UIImage(data: $0) ?? UIImage(systemName: &quot;xmark&quot;)! }
        .eraseToAnyPublisher()
}
    }
</code></pre>
<p>But it has a problem that I should download the actual image data after the first network request(<code>getProfileData</code> at this time) manually.</p>
<p>I made a <a href=""https://gist.github.com/enebin/08f3356681c8f4ea6047612549cced81"" rel=""nofollow noreferrer"">sample case</a> using the method I mentioned right before. In here, a cell initializes the view model when it's shown on the screen, so the image loads too slowly. In addition, it creates unnecessary network requests because the text field refreshes the entire view every time you type a character(because the variance <code>test</code> is <code>@State</code>).</p>
<p>So I'm wondering are there any ways to create the following:</p>
<pre><code>// New struct which has UIImage, not URL
struct Profile {
    let id = UUID()
    let name: String
    let image: UIImage
}

func getProfile() -&gt; AnyPublisher&lt;[Profile], Error&gt; { ... }
</code></pre>
<p>Not sure if this is the best way, but it seems to solve the problem.</p>
<p>Please let me know if there is a better way. You don't even have to provide detailed solutions. I will appreciate it even if you give me just keywords or links.</p>
<p>Thank you.</p>
","11768262","","11768262","","2022-04-13 09:45:14","2022-04-13 09:45:14","Best practices for downloading data from URLs nested in JSON(Swift, Combine)","<ios><swift><combine>","0","1","0","","","CC BY-SA 4.0"
"71853741","1","","","2022-04-13 07:46:03","","0","186","<p>I have a single reducer in form of a <code>Subscriber</code>. The base class is like this:</p>
<pre><code>class ResponseReducer&lt;Input&gt;: Subscriber {

    func receive(subscription: Subscription) {
        subscription.request(.unlimited)
    }
    
    func receive(completion: Subscribers.Completion&lt;Error&gt;) {
    }
    
    func receive(_ input: Input) -&gt; Subscribers.Demand {
        return .unlimited
    }
}

let reducer = ResponseReducer&lt;Response&gt;()
</code></pre>
<p>And I subscribe it for network responses from different places the following way:</p>
<pre><code>networkRequestPublisher
    .subscribe(reducer)
</code></pre>
<p>Multiple subscriptions may exist at the same time. And the underlying <code>Subscription</code> is not retained without extra effort in such cases. I get only <code>receive(subscription:)</code> call inside <code>ResponseReducer</code> as a result.</p>
<p>If it was only one subscription at a time, I would store a reference to it inside <code>ResponseReducer</code> and release it inside the <code>receive(completion:)</code> func. But I have multiple subscriptions and there is no reference to the completing subscription inside the <code>receive(completion:)</code> func when it is called.</p>
<p>Experimentally, I've found how to achieve what I need, but not sure it is a reliable solution:</p>
<pre><code>networkRequestPublisher
    .handleEvents()
    .subscribe(reducer)
</code></pre>
<p><code>.handleEvents()</code> operator does the job. It will also work if I replace <code>.handleEvents()</code> with <code>.receive(on:)</code> or <code>.print()</code> operators.</p>
<p>Can somebody explain, why the solution with <code>.handleEvents()</code> works?
And what would be the best way to solve this task?</p>
","1531671","","","","","2022-04-13 07:46:03","How to retain multiple subscriptions till their completion in Combine when we subscribe a single subscriber?","<swift><combine>","0","1","0","","","CC BY-SA 4.0"
"71878360","1","","","2022-04-14 22:45:17","","0","53","<p>I am using <a href=""https://docs.amplify.aws/lib/auth/signin/q/platform/ios/"" rel=""nofollow noreferrer"">Amplify Auth for iOS</a> and attempting to implement the signUp functionality:</p>
<pre class=""lang-swift prettyprint-override""><code>public class UserSessionRepository {
  func signUp(email: String, password: String) -&gt; AnyPublisher&lt;AuthSignUpResult, AuthError&gt; {
    let userAttributes = [AuthUserAttribute(.email, value: email)]
    let options = AuthSignUpRequest.Options(userAttributes: userAttributes)

    return Amplify.Auth.signUp(username: email, password: password, options: options).resultPublisher
  }
}
</code></pre>
<p>However, when I attempt to subscribe to the Publisher and remap the return values, the subscribe does not seem to function correctly:</p>
<pre class=""lang-swift prettyprint-override""><code>class SignUpEmailService {
  @Injected private var userSessionRepository: UserSessionRepository

  func signupEmailRequest(to email: String, password: String) -&gt; AnyPublisher&lt;SignupComplete, Error&gt; {
    return userSessionRepository.signUp(email: email, password: password)
      .map { signupResult in
        print(&quot;SignUpEmailService.signupEmailRequest: \(signupResult)&quot;)

        return SignupComplete(result: signupResult.isSignupComplete)
      }
      .mapError { error in
        print(&quot;SignUpEmailService.signupEmailRequest: \(error)&quot;)
                
        return FooError.authError
      }
      .eraseToAnyPublisher()
  }
}
</code></pre>
<p>Neither the <code>map</code> or <code>mapError</code> is actually called.</p>
<p>Thoughts on what I am missing in terms of setting up the Combine publish/subscribe mechanism?</p>
","768419","","560942","","2022-04-14 22:47:17","2022-04-14 22:47:17","Subscribing to Amplify.Auth Publisher","<swift><aws-amplify><combine>","0","1","","","","CC BY-SA 4.0"
"71895547","1","","","2022-04-16 16:17:31","","0","68","<p>I have the following classes that perform a network call -</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import Combine

struct CoinsView: View {
    
    private let coinsViewModel = CoinViewModel()
    
    var body: some View {
        Text(&quot;CoinsView&quot;).onAppear {
            self.coinsViewModel.fetchCoins()
        }
    }
    
}

class CoinViewModel: ObservableObject {
    
    private let networkService = NetworkService()
    
    @Published var data = String()
    
    var cancellable : AnyCancellable?
    
    func fetchCoins() {
        cancellable = networkService.fetchCoins().sink(receiveCompletion: { _ in
            print(&quot;inside receive completion&quot;)
        }, receiveValue: { value in
            print(&quot;received value - \(value)&quot;)
        })
    }
}

class NetworkService: ObservableObject {
    
    
    private var urlComponents : URLComponents {
        var components = URLComponents()
        components.scheme = &quot;https&quot;
        components.host = &quot;jsonplaceholder.typicode.com&quot;
        components.path = &quot;/users&quot;
        return components
    }
    
    var cancelablle : AnyCancellable?
    
    func fetchCoins() -&gt; AnyPublisher&lt;Any, URLError&gt; {
        return URLSession.shared.dataTaskPublisher(for: urlComponents.url!)
            .map{ $0.data }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>What I want to achieve currently is just to print the JSON result.</p>
<p>This doesn't seem to work, and from debugging it never seems to go inside the <code>sink{}</code> method, therefor not executing it.</p>
<p>What am I missing?</p>
<hr />
<p>After further investigation with Asperi's help I took the code to a clean project and saw that I have initialized a struct that wraps NSPersistentContainer which causes for some reason my network requests not to work. Here is the code, hopefully someone can explain why it prevented my networking to execute -</p>
<pre class=""lang-swift prettyprint-override""><code>
import SwiftUI

@main
struct BasicApplication: App {
    
    let persistenceController = BasicApplciationDatabase.instance
    
    @Environment(\.scenePhase)
    var scenePhase
    
    
    var body: some Scene {
        WindowGroup {
            CoinsView()
        }
        .onChange(of: scenePhase) { newScenePhase in
            switch newScenePhase {

                case .background:
                    print(&quot;Scene is background&quot;)
                    persistenceController.save()
                case .inactive:
                    print(&quot;Scene is inactive&quot;)
                case .active:
                    print(&quot;Scene is active&quot;)
                @unknown default:
                    print(&quot;Scene is unknown default&quot;)
            }
        }
    }
}

import CoreData

struct BasicApplciationDatabase {
    
    static let instance = BasicApplciationDatabase()
    
    let container : NSPersistentContainer
    
    init() {
        container = NSPersistentContainer(name: &quot;CoreDataDatabase&quot;)
        container.loadPersistentStores { NSEntityDescription, error in
            if let error = error {
                fatalError(&quot;Error: \(error.localizedDescription)&quot;)
            }
        }
    }
    
    func save(completion : @escaping(Error?) -&gt; () = {_ in} ){
        let context = container.viewContext
        if context.hasChanges {
            do {
                try context.save()
                completion(nil)
            } catch {
                completion(error)
            }
        }
    }
    
    func delete(_ object: NSManagedObject, completion : @escaping(Error?) -&gt; () = {_ in} ) {
        let context = container.viewContext
        context.delete(object)
        save(completion: completion)
    }
}
</code></pre>
","8943516","","2370483","","2022-04-17 14:32:23","2022-04-17 14:32:23","Network request using Combine doesn't execute","<ios><swift><mvvm><swiftui><combine>","0","3","","","","CC BY-SA 4.0"
"71902788","1","","","2022-04-17 14:37:34","","0","302","<p>I have this function</p>
<pre><code>import Foundation
import Combine
import Amplify

func fetchCurrentAuthSession() -&gt; AnyCancellable {
    Amplify.Auth.fetchAuthSession().resultPublisher
        .sink {
            if case let .failure(authError) = $0 {
                print(&quot;Fetch session failed with error \(authError)&quot;)
            }
        }
receiveValue: { session in
    print(&quot;Is user signed in - \(session.isSignedIn)&quot;)
}
}
</code></pre>
<p>and I am calling it like this</p>
<pre><code> Button(action: {
          print(&quot;button pressed&quot;)
          fetchCurrentAuthSession()
          
        }) {
          Text(&quot;Authenticated Test&quot;)
        }

</code></pre>
<p>I get the Xcode warning <code>Result of call to 'fetchCurrentAuthSession()' is unused</code></p>
<p>its not clear to me what the &quot;result of the call&quot; is, or how I should be &quot;using it&quot;</p>
","","user18365424","","","","2022-04-17 15:52:36","Result of call is unused with Combine","<swift><combine>","1","4","","","","CC BY-SA 4.0"
"71910874","1","","","2022-04-18 10:55:11","","4","254","<p>So I want to implement a custom control as a <code>UIViewRepresentable</code> which correctly handles focus using an <code>@FocusState</code> binding.</p>
<p>So I want to be able to manage the focus like so:</p>
<pre><code>struct MyControl: UIViewRepresentable { ... }


struct Container: View {

    @FocusState var hasFocus: Bool = false

    var body: some View {
        VStack {
            MyControl()
                .focused($hasFocus)

            Button(&quot;Focus my control&quot;) {
                hasFocus = true
            }
        }
    }
}
</code></pre>
<p>What do I have to implement in <code>MyControl</code> to have it respond to the focus state properly?  Is there a protocol or something which must be implemented?</p>
","814570","","","","","2022-04-18 11:16:07","How do I make my own focusable view in SwiftUI using FocusState?","<ios><swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"71912548","1","","","2022-04-18 13:38:12","","0","131","<p>I have <code>RestManager</code> class which is used for fetching data from Internet and is returning <code>AnyPublisher</code></p>
<pre><code>class RestManager {

func fetchData&lt;T: Decodable&gt;(url: URL) -&gt; AnyPublisher&lt;T, ErrorType&gt; {
    URLSession
        .shared
        .dataTaskPublisher(for: url)
        .tryMap({ data, _ in
            let value = try JSONDecoder().decode(T.self, from: data)
                        if let array = value as? Array&lt;Any&gt;, array.isEmpty {
                            throw ErrorType.empty
                        }
                        return value
        })
        .mapError { error -&gt; ErrorType in
            switch error {
                
            case is ErrorType:
                return ErrorType.empty
                
            case let urlError as URLError:
                switch urlError.code {
                case .notConnectedToInternet, .networkConnectionLost, .timedOut:
                    return .noInternetConnection
                case .cannotDecodeRawData, .cannotDecodeContentData:
                    return .empty
                default:
                    return .general
                }
            default:
                return .general
            }
        }
        .eraseToAnyPublisher()
}
}
</code></pre>
<p>Repository has two functions (<code>getWorldwideData</code> and <code>getCountryData</code> returning <code>AnyPublisher&lt;(WorldwideResponse item or CountryResponse item), ErrorType&gt;</code>)</p>
<p>In viewModel, I made these functions.</p>
<pre><code>private func getData() {
    $useCaseSelection
        .flatMap { value -&gt; AnyPublisher&lt;Covid19StatisticsDomainItem, ErrorType&gt; in
            self.loader = true
            self.error = nil
            
            switch value {
            case let .country(name):
                return self.countryPipeline(name: name)
            case .worldwide:
                return self.worldwidePipeline()
            }
        }
        .mapError { error in
            self.error = error
        }
        .assign(to: &amp;$homeScreenDomainItem)
}

private func worldwidePipeline() -&gt; AnyPublisher&lt;Covid19StatisticsDomainItem, ErrorType&gt; {
    repository
        .getWorldwideData()
        .map { response -&gt; Covid19StatisticsDomainItem in
            self.error = nil
            self.loader = false
            return Covid19StatisticsDomainItem(worldwideResponseItem: response)
        }
        .eraseToAnyPublisher()
}

private func countryPipeline(name: String) -&gt; AnyPublisher&lt;Covid19StatisticsDomainItem, ErrorType&gt; {
    repository
        .getCountryData(for: name)
        .map { response -&gt; Covid19StatisticsDomainItem in
            self.error = nil
            self.loader = false
            return Covid19StatisticsDomainItem(countryDayOneStatsResponse: response)
        }
        .eraseToAnyPublisher()
}
</code></pre>
<p>I wanted to make clean code, so I split code into two separate function based on <code>useCaseSelection</code>.</p>
<p><code>useCaseSelection</code> is enum with two types.
<code>error</code> is <code>ErrorType?</code> value wrapped with <code>@Published</code>, in which I want to save error type if there is any error.
<code>homeScreenDomainItem</code> is <code>Covid19StatisticsDomainItem</code> instance wrapped with <code>@Published</code>.</p>
<p>Problem is in <code>getData</code> function where in <code>MapError</code> pipeline I am getting:</p>
<blockquote>
<p>Cannot convert value of type <code>()</code> to closure result type <code>Never</code></p>
</blockquote>
<p>I tried to use <code>setFailureType(to: ErrorType.self)</code> but that is not helping.</p>
","16455916","","3141234","","2022-04-18 13:46:08","2022-04-18 13:46:08","Cannot map error after flatMap usage (Never result type)","<swift><combine>","0","1","","","","CC BY-SA 4.0"
"71930605","1","","","2022-04-19 19:55:54","","0","169","<p>I’m currently building out a new MVVM app in SwiftUI and wanted to see whether there was a cleaner way of assigning a value from a CurrentValueSubject to my ViewModel, whilst still achieving animations?   </p>
<p>I’m currently leaning toward solution 2 below as that keeps the animation code neatly within the View, but it’s quite annoying having to setup another State for every animated change. Hoping there’s another way!</p>
<p><strong>Solution 1 - use sink and withAnimation together in the ViewModel:</strong></p>
<p>ViewModel:</p>
<pre><code>authenticationService.authenticationState
    .receive(on: DispatchQueue.main)
    .sink { [unowned self] state in
        withAnimation(.easeInOut(duration: Constants.Animation.slideSpeed)) {
            self.authenticationState = state
        }
    }
    .store(in: &amp;cancellables)
</code></pre>
<p><strong>Solution 2 - Use assign in the ViewModel and onReceive (+ withAnimation) in the view</strong></p>
<p>ViewModel:</p>
<pre><code>authenticationService.authenticationState
    .receive(on: DispatchQueue.main)
    .assign(to: &amp;$authenticationState)
</code></pre>
<p>View:</p>
<pre><code>struct ContentView: View {
    @StateObject private var viewModel = ViewModel()
    @State private var authenticationState: AuthenticationState = .loggedOut

    private var shiftAnimation: AnyTransition {
        .asymmetric(insertion: .move(edge: .trailing), removal: .move(edge: .leading))
    }

    var body: some View {
        ZStack {
            switch authenticationState {
            case .loggedOut:
                LoginView()
                    .transition(shiftAnimation)
            case .loggedIn:
                AdminView()
                    .transition(shiftAnimation)
            }
            if viewModel.showProgressView {
                ProgressView()
            }
        }
        .onReceive(viewModel.$authenticationState) { state in
            withAnimation(.easeInOut(duration: Constants.Animation.slideSpeed)) {
                self.authenticationState = state
            }
        }
    }
}
</code></pre>
","11181115","","","","","2022-04-19 19:55:54","Best way to achieve animation in SwiftUI with a CurrentValueSubject value change","<ios><swift><animation><swiftui><combine>","0","2","0","","","CC BY-SA 4.0"
"71935702","1","","","2022-04-20 07:26:16","","1","362","<p>Both <code>CurrentValueSubject</code> and <code>@Published.Publisher</code> (retrieved via $ from an ObservableObject property) immediately send a notification with the current value when a new subscriber is added (verified with this <a href=""https://github.com/ralfebert/CombinePublisherBehaviour/blob/main/CombinePublisherBehaviour/CombinePublisherBehaviourView.swift"" rel=""nofollow noreferrer"">example</a>).</p>
<p>Is there a way to require this behaviour with a protocol?</p>
<p>For example, if you offer an initializer that requires to pass a publisher, one would use <code>AnyPublisher</code> here:</p>
<pre class=""lang-swift prettyprint-override""><code>init(settings: AnyPublisher&lt;Settings, Never&gt;) {
    // ...
}
</code></pre>
<p>This would allow to be sneaky and pass in a <code>PassthroughSubject</code> erased to <code>AnyPublisher</code>. Is there a way to prevent this that would allow to pass in both a <code>CurrentValueSubject</code> or an <code>@Published</code> property? (something like a <code>AnyValuePublisher</code>?)</p>
","128083","","128083","","2022-04-20 09:52:40","2022-04-20 09:52:40","Requiring a Publisher with a current value","<combine>","1","1","1","","","CC BY-SA 4.0"
"71990061","1","71991527","","2022-04-24 15:55:20","","0","467","<p>I'm currently migrating code that was using Combine Publisher to an AsyncSequence.  I previously used this alongside <code>@Published</code> search query that user could type in and now trying to &quot;combine&quot; that search term with <code>AsyncSequence</code> based data source such as following (using <code>values</code> to convert the search query to <code>AsyncSequence</code> as well).  However, I'm only seeing the <code>flatMap</code> code being executed once initially.</p>
<pre><code>@MainActor
class FantasyPremierLeagueViewModel: ObservableObject {
    @Published var playerList = [Player]()
    @Published var query: String = &quot;&quot;
    
    private let repository: FantasyPremierLeagueRepository
    init(repository: FantasyPremierLeagueRepository) {
        self.repository = repository
        
        Task {
            let playerStream = asyncStream(for: repository.playerListNative)
            
            let filteredPlayerStream = $query
                .debounce(for: 0.5, scheduler: DispatchQueue.main)
                .values
                .flatMap { query in
                    playerStream
                        .map { $0.filter { uery.isEmpty || $0.name.contains(query) } }
                }
                .map { $0.sorted { $0.points &gt; $1.points } }
                
            
            for try await data in filteredPlayerStream {
                self.playerList = data
            }
        }
    }
}
</code></pre>
<p>Code pushed to branch and can also be viewed in <a href=""https://github.com/joreilly/FantasyPremierLeague/blob/kmp_native_coroutines/ios/FantasyPremierLeague/FantasyPremierLeague/ViewModel.swift"" rel=""nofollow noreferrer"">https://github.com/joreilly/FantasyPremierLeague/blob/kmp_native_coroutines/ios/FantasyPremierLeague/FantasyPremierLeague/ViewModel.swift</a></p>
","793861","","793861","","2022-04-24 16:00:23","2022-04-24 19:06:33","Using Combine Publisher with AsyncSequence","<swift><async-await><combine>","1","4","","","","CC BY-SA 4.0"
"71997761","1","","","2022-04-25 10:02:55","","1","107","<p>I was refering to this <a href=""https://www.vadimbulavin.com/asynchronous-swiftui-image-loading-from-url-with-combine-and-swift/"" rel=""nofollow noreferrer"">Link</a> which helps to load images froma url asynchronously in swiftui.
(Using <code>Combine</code> and <code>AsyncImage</code>)
However some of the images which I need to dsplay are in <strong>pdf format.</strong></p>
<p>Is there any way to load pdf using the reference code i used?</p>
","15559816","","","","","2022-04-25 10:02:55","Loading pdf Images in Swiftui View","<ios><swiftui><uikit><combine>","0","3","","","","CC BY-SA 4.0"
"72009766","1","72009946","","2022-04-26 07:14:08","","0","35","<p>I've implemented a two-way binding in a Foreach statement that seems to <strong>work properly</strong>:</p>
<pre><code>struct ContentView: View {
    @ObservedObject var dataManager: ContentViewModel
    var body: some View {
        ScrollView(.horizontal, showsIndicators: false){
            HStack(spacing: 20){
                ForEach($dataManager.data) { $item in 
                    if item.status == true {
                        Button(item.tag){
                            item.status.toggle()
                        }
                        .foregroundColor(.white)
                        .background(Color.red)
                    } else {
                        Button(item.tag){
                            item.status.toggle()
                        }
                        .foregroundColor(.white)
                        .background(Color.blue)
                    }
                }
            }
        }
    }
}
</code></pre>
<p>The <strong>problem</strong> is when I've to use some nested views like:</p>
<pre><code>struct ContentView: View {
    @ObservedObject var dataManager: ContentViewModel
    var body: some View {
        
        ScrollView(.horizontal, showsIndicators: false){
            HStack(spacing: 20){
                ForEach($dataManager.data) { $item in
                    if item.status == true {
                        DetailView(dataManager: dataManager, item: item)
                            .foregroundColor(.white)
                            .background(Color.red)
                    } else {
                        Button(item.tag){
                            item.status.toggle()
                        }
                        .foregroundColor(.white)
                        .background(Color.blue)
                    }
                }
            }
        }
    }
}
</code></pre>
<p>and:</p>
<pre><code>struct DetailView: View {
    
    @ObservedObject var dataManager: ContentViewModel
    var item: SMTTagBoardItem
    
    var body: some View {
        Button(item.tag){
            item.status.toggle()
        }
    }
}

struct DetailView_Previews: PreviewProvider {
    static var previews: some View {
        DetailView(dataManager: ContentViewModel(), item: SMTTagBoardItem(id: UUID(), tag: &quot;tag1&quot;, rank: 0, status: true))
    }
}
</code></pre>
<p>I receive this error:</p>
<pre><code>Cannot use mutating member on immutable value: 'self' is immutable

</code></pre>
<p>at line :</p>
<pre><code>item.status.toggle() 
</code></pre>
<p>How can I implement a two-way binding in a ForEach statement that works by passing values to nested views?</p>
","1937003","","","","","2022-04-26 07:28:14","How to implement a two-way binding in a ForEach statement with nested views with Swift?","<swift><binding><combine>","1","0","","","","CC BY-SA 4.0"
"72010168","1","","","2022-04-26 07:44:43","","0","70","<p>I try to develop an WatchOS app, where the views are feeded by a timer:</p>
<pre><code>import SwiftUI
import Combine

class AcidityTimer: ObservableObject {
    @Published var num: Int = 0
    private var subscription: AnyCancellable?
    
    
    init() {
        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            self.num += 1
            if self.num == 101 {
                self.num = 0
            }
        }
    }
}

struct AcidityTextView: View {
    @EnvironmentObject var acTimer: AcidityTimer
    @State var acidity: Double = 0.0
    
    var body: some View {
        Text(String(format: &quot;Acidity: %.1f&quot;, acidity))
            .onReceive(acTimer.$num) { result in
                acidity = Double(result) / 10.0
            }
    }
}

struct AcidityGaugeView: View {
    @State var acidity = 0.0
    @EnvironmentObject var acTimer: AcidityTimer
    
    var body: some View {
        Gauge(value: acidity, in: 0...10) {
            Image(systemName: &quot;drop.fill&quot;)
                .foregroundColor(.green)
        } currentValueLabel: {
            Text(&quot;\(acidity, specifier: &quot;%.1f&quot;)&quot;)
        } minimumValueLabel: {
            Text(&quot;0&quot;)
        } maximumValueLabel: {
            Text(&quot;10&quot;)
        }
        .gaugeStyle(CircularGaugeStyle())
        .onReceive(acTimer.$num) { result in
            acidity = Double(result) / 10.0
        }
    }
}

struct ContentView: View {
    @ObservedObject var acTimer = AcidityTimer()
    @State var counter: Int = 0
    
    var body: some View {
        TabView {
            AcidityTextView()
                .environmentObject(acTimer)
            AcidityGaugeView()
                .environmentObject(acTimer)
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre>
<p>The app itself runs fine on the Apple Watch simulator, but I get the error message:</p>
<p>[SwiftUI] Accessing State's value outside of being installed on a View. This will result in a constant Binding of the initial value and will not update.</p>
<p>Any idea what's wrong?</p>
","12214128","","","","","2022-04-26 08:04:40","Problems with timer and views in SwiftUI","<swiftui><timer><combine>","1","0","","","","CC BY-SA 4.0"
"72010969","1","72211472","","2022-04-26 08:46:22","","1","451","<p>This question has effectively been asked before (<a href=""https://stackoverflow.com/questions/64957228/combine-assign-publisher-to-passthroughsubject"">Combine assign publisher to PassthroughSubject</a>) but the answer assumed the architecture of the question's example was totally wrong.</p>
<p>I'm faced with the same issue, in what I feel is a different example case, and I'd dearly love clarity on the issue.</p>
<hr />
<p>I have a viewmodel class which provides a public <code>errorMessage</code> publisher for the client layer to do what it will with. Just a string here. Privately this publisher is backed by a <code>PassthroughSubject</code> - I'm &quot;entering the monad&quot; from different places internally and so I want to send error messages imperatively at that stage.</p>
<p>One of my entry points here happens to be another Combine publisher. I'd like to just map and bind, as I would in RxSwift:</p>
<pre><code>private let _errorMessageSubject = PublishSubject&lt;String&gt;()
public let errorMessageRail = _errorMessageSubject.asObservable()

private func setup() {
   ...

   myEngine.errorMessages
     .map { msg in &quot;Internal error: \(msg)&quot; } 
     .bind(to: _errorMessageSubject)
   
   ...
}

private func someOtherMethod() {
   _errorMessageSubject.onNext(&quot;Surprise&quot;)
}
</code></pre>
<p>In Combine I'm not sure how to do it other than:</p>
<pre><code>private let _errorMessageSubject = PassthroughSubject&lt;String,Never&gt;()
public let errorMessageRail = _errorMessageSubject.eraseToAnyPublisher()

private func setup() {
   ...

   myEngine.errorMessages
     .map { msg in &quot;Internal error: \(msg)&quot; } 
     .sink { [weak self] msg in
         self?._errorMessageSubject.send(msg)
     }
   
   ...
}

private func someOtherMethod() {
   _errorMessageSubject.send(&quot;Surprise&quot;)
}
</code></pre>
<hr />
<p>Before we get into chatting concurrency issues, let's say I'm always carefully pushing to <code>_errorMessageSubject</code> on a specific dispatch queue. I omit that from the code above for clarity.</p>
<p>So given this example, unless I'm missing something staggeringly obvious a flatMap won't help me here.</p>
<ul>
<li>Am I stuck with this sink -&gt; send dance?</li>
<li>Or is there some eye-watering code-smell about my public/private publisher/subject pattern (that I use a lot for bridging imperative with reactive architectures) and can some kind soul point me in the direction of self-improvement?</li>
</ul>
","1602875","","","","","2022-05-12 07:15:45","Combine bind Publisher to PassthroughSubject","<ios><swift><reactive-programming><combine>","1","0","","","","CC BY-SA 4.0"
"72020769","1","72192652","","2022-04-26 21:33:22","","1","278","<p>Is there a way to have the publisher emit a value only to the latest subscriber/observer?</p>
<p>An example for that would be; a manager class that can be subscribed to by multiple observers. When an event occurs, I would like only the latest subscriber to be observed. As far as I know, there is no way for the publisher to keep track of its subscribers but my knowledge regarding Combine and reactive programming is limited so I am unsure if this is possible in the first place.</p>
","7294871","","","","","2022-05-10 22:06:51","How to have a publisher emit only to the last subscriber in Combine","<swift><combine>","1","0","1","","","CC BY-SA 4.0"
"72023252","1","72023302","","2022-04-27 04:24:08","","1","50","<p>I am trying to figure how to have a SwiftUI view properly react to the changes made to an NSManagedObject property.</p>
<p>Example:</p>
<pre><code>class MyViewModel: ObservableObject {
            
    @Published var car:Car // &lt;-- NSManagedObject
    @Published var sold:Bool = false // &lt;-- I don't want to do this, I want to simply observe the sold property on car and not have to implement this sink logic below
    var subs = [AnyCancellable]()
    
    init(car:Car) {
        self.car = car
        self.sold = car.sold
        self.car.publisher(for: \.sold)
            .removeDuplicates()
            .receive(on: RunLoop.main)
            .sink { [weak self] sold in
                self?.sold = sold
            }
            .store(in: &amp;subs)
    }
    
}
</code></pre>
<p>As an example, I have a Toggle that lets me set the <code>sold</code> property on the Car entity.</p>
<pre><code>Toggle(isOn: Binding&lt;Bool&gt;(get: { model.car.sold }, set: { model.car.sold = $0 } )) {
    if model.car.sold {
        Text(&quot;ON&quot;)
    } else {
        Text(&quot;OFF&quot;)
    }
}
</code></pre>
<p>Toggling the control does set the <code>sold</code> property on the car instance, but, the Toggle label:</p>
<pre><code>    if model.car.sold {
        Text(&quot;ON&quot;)
    } else {
        Text(&quot;OFF&quot;)
    }
</code></pre>
<p>does not update accordingly.</p>
<p>So, if I change the car entity as a whole, things update, if I change a property of the entity the view does not update. So then I implemented the <code>sink</code> logic to then set a published <code>sold</code> property on the model. So the <code>sold</code> property on the car is set by the toggle, the sink kicks in and sets the model.sold, and then the Toggle label Text does update.</p>
<p>How can I do away with the additional <code>@Published var sold:Bool = false</code> in the model and simply cause the Toggle label to react to the actual <code>car.sold</code> property?</p>
","728246","","","","","2022-04-27 04:32:16","SwiftUI: react to NSManagedObject property change in SwiftUI view?","<ios><swift><core-data><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"72032736","1","72463897","","2022-04-27 17:03:38","","2","445","<p>I'm learning combine and I want to use combine instead a delegate between cell and tableview. I have managed to connect and receive the information, but the problem is when the cell is reused, every time I generate the same event, I receive it as many times as it has been used previously in that reused cell.</p>
<p>I have declared cancelables in the view controller as</p>
<pre><code>var cancellables: Set&lt;AnyCancellable&gt; = []
</code></pre>
<p>And this is the cellForRow method</p>
<pre><code>func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
    guard let cell = tableView.dequeueReusableCell(withIdentifier: MyCell.celdaReuseIdentifier, for: indexPath)
        as? MyCell else {
            return MyCell()
    }
    
    cell.index = indexPath
    cell.lbTitle.text = String(&quot;Cell \(indexPath.row)&quot;)
    
    
    cell.tapButton.compactMap{$0}
        .sink { index in
        print(&quot;tap button in cell \(index.row)&quot;)
    }.store(in: &amp;cancellables)
    
    return cell
}
</code></pre>
<p>and the cell is</p>
<pre><code>class MyCell: UITableViewCell {
static let cellNibName = &quot;MyCell&quot;
static let celdaReuseIdentifier = &quot;MyCellReuseIdentifier&quot;

@IBOutlet weak var lbTitle: UILabel!
@IBOutlet weak var button: UIButton!

var index: IndexPath?

let tapButton = PassthroughSubject&lt;IndexPath?, Never&gt;()

override func awakeFromNib() {
    super.awakeFromNib()
    // Initialization code
}

@IBAction func tapButton(_ sender: Any) {
    self.tapButton.send(index)
}
}
</code></pre>
<p>Thanks for your help</p>
","6151270","","","","","2022-06-01 14:50:19","Connect UITableviewCell with UITableview using Combine repeat values","<swift><swift5><combine>","2","4","1","","","CC BY-SA 4.0"
"72034746","1","","","2022-04-27 20:12:38","","0","33","<p>I'm trying to create a publisher for CoreData changes.</p>
<p>I've implemented Publisher protocol and I was required to implement NSFetchedResultsControllerDelegate in same type (not in extension).</p>
<p>Next, I need to implement different NSFetchedResultsControllerDelegate methods for different Outputs.</p>
<p>But when I add constraint <em>where</em> to method, xcode tells that it is not protocol method but &quot;nearly matches optional requirement&quot; and this method not called.</p>
<pre><code>func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) 
    where Output == [T]
{

}

func controller(
    _ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;,
    didChangeContentWith snapshot: NSDiffableDataSourceSnapshotReference)
    where Output == PublishedSnapshot
{

}
</code></pre>
<p><a href=""https://i.stack.imgur.com/pswm8.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pswm8.png"" alt=""enter image description here"" /></a>
<a href=""https://i.stack.imgur.com/MbTJJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MbTJJ.png"" alt=""enter image description here"" /></a></p>
<p>I can't implement both methods without any conditions because ```controller(:didChangeContentWith) hides all other delegate methods.</p>
<p>What should I do to implement different methods depending on Output type?</p>
","2685506","","","","","2022-04-27 20:12:38","Can't add constraint to method","<swift><core-data><protocols><combine>","0","2","","","","CC BY-SA 4.0"
"72055965","1","","","2022-04-29 09:43:13","","-1","464","<p>I have 3 API call, all of them are being called using Publishers. API A &amp; API B will be called first before API C got called. But API C should be called only when the response from API A &amp; B met some conditions.</p>
<p>Currently I have these functions to get the API response:</p>
<pre><code>func getAPIA() -&gt; AnyPublisher&lt;Response&lt;ResponseA&gt;, Error&gt; { ... }
func getAPIB() -&gt; AnyPublisher&lt;Response&lt;ResponseB&gt;, Error&gt; { ... }
func getAPIC() -&gt; AnyPublisher&lt;Response&lt;ResponseC&gt;, Error&gt; { ... }
</code></pre>
<p>I have these line of code, it it possible to</p>
<pre><code>Publishers.Zip3(
    getAPIA(),
    getAPIB(),
    getAPIC() // --&gt; How to make this being called based on the response of A and B
).sink(
    receiveCompletion: { print($0) },
    receiveValue: { [weak self] a, b, c in
        // return value
    }
).store(in: &amp;cancellable)
</code></pre>
<p>If the response of A and B met some conditions, then APIC will be called, otherwise not. Is it achievable using Combine? Thanks.</p>
","897733","","","","","2022-05-02 10:39:44","Swift Combine dependent API Calls","<swift><combine><publisher>","1","1","","","","CC BY-SA 4.0"
"72061331","1","","","2022-04-29 16:58:02","","0","157","<p>I have a simple SwiftUI ScrollView. I need to have the row(cell) closest to center of the viewport move itself to exact center (same distance from top and bottom) after scrolling has finished. Using the code below this works fine but only when row height is exactly the same as viewport height. If row heigh is different than viewport height the row does scroll itself to next closest row but it doesn't stop there and keeps scrolling to first row. By viewport I mean the actual visible scroll area. here is the code I have so far (taken by bits and pieces from all around here).</p>
<pre><code>import SwiftUI
import Combine

struct SecondTry: View {
    let detector: CurrentValueSubject&lt;CGFloat, Never&gt;
    let publisher: AnyPublisher&lt;CGFloat, Never&gt;

    init() {
        let detector = CurrentValueSubject&lt;CGFloat, Never&gt;(0)
        self.publisher = detector
            .debounce(for: .seconds(0.2), scheduler: DispatchQueue.main)
            .dropFirst()
            .eraseToAnyPublisher()
        self.detector = detector
    }
    
    var body: some View {
        
        VStack {
            RoundedRectangle(cornerRadius: 20)
                .foregroundColor(Color.gray)
                .frame(height: 100)
                .padding()
            
            GeometryReader { geo in
                ScrollViewReader { reader in
                    ScrollView {
                        VStack(spacing: 0) {
                            ForEach(0...100, id: \.self) { i in
                                Rectangle()
                                    .frame(width: 200, height: 70)
                                    .foregroundColor(.green)
                                    .overlay(Text(&quot;\(i)&quot;))
                            }
                        }
                        .frame(maxWidth: .infinity)
                        .background(GeometryReader {
                            Color.clear.preference(key: ViewOffsetKey.self,
                                value: -$0.frame(in: .named(&quot;scroll&quot;)).origin.y)
                        })
                        .onPreferenceChange(ViewOffsetKey.self) { detector.send($0) }
                    }.coordinateSpace(name: &quot;scroll&quot;)
                    .onReceive(publisher) {
                        var index = $0/70
                        // Check if next item is near
                        let value = index &lt; 1 ? index : index.truncatingRemainder(dividingBy: CGFloat(Int(index)))
                        print(&quot;index: \(index) $0: \($0) geo.size.height: \(geo.size.height) value: \(value)&quot;)
                        if value &gt; 0.5 { index += 1 }
                        else { index = CGFloat(Int(index)) }
                        
                        //index = index.rounded() //this does the same as above if - else
                        
                        print(&quot;final index: \(index)&quot;)

                        // Scroll to index
                        withAnimation { reader.scrollTo(Int(index), anchor: .center) }
                    }
                }
            }
            .frame(height: 210) //if this is 70 too like row height then it works fine
            
        }

    }
}

struct ViewOffsetKey: PreferenceKey {
    typealias Value = CGFloat
    static var defaultValue = CGFloat.zero
    static func reduce(value: inout Value, nextValue: () -&gt; Value) {
        value += nextValue()
    }
}
</code></pre>
<p>When I replaced my onReceive with this now it works fine but I feel I shouldn't be using if else to stop it from scrolling forever.</p>
<pre><code>                    .onReceive(publisher) {
                    var index = ($0/70) + 2
                    var indexRounded = 0
                    
                    indexRounded = Int(index.rounded())
                    print(&quot;index: \(index)&quot;)
                    print(&quot;indexRounded: \(indexRounded)&quot;)

                    // Scroll to index only if index is not equal to indexRounded
                    if CGFloat(indexRounded) == index {
                        print(&quot;nothing&quot;)
                    } else {
                        withAnimation { reader.scrollTo(Int(index), anchor: .center) }
                    }
                    }
</code></pre>
<p>Why is the behavior different based on row height vs. viewport height (visible scrollview height)?</p>
<p>I basically want it to behave like iOS 15 DatePicker/TimePicker where after scrolling row centers itself in the middle.</p>
","5218038","","5218038","","2022-04-29 17:09:52","2022-04-29 17:09:52","SwiftUI - ScrollView behaves different based on viewport size","<key><combine><preference><swiftui-scrollview><scrollviewreader>","0","0","","","","CC BY-SA 4.0"
"72088268","1","","","2022-05-02 14:35:03","","0","48","<p>I have a published var called spotWallet in my BinanceStore class which conforms to observaleObject. I can create a publisher and subscribe to it. but there is property in my top level struct called balances which is an array of Balance struct. What I want to achieve is would like to update a property of Balance called price which comes from another network call. I cannot get that to work, in clean combine swiftui way.</p>
<pre><code>class BinanceStore: ObservableObject, Identifiable {
    @Published var spotWallet: SpotWallet?
    @Published var loadingError: String = &quot;&quot;
    @Published var showAlert: Bool = false
    private var cancellableSet: Set&lt;AnyCancellable&gt; = []
    private let binanceFetcher: BinanceFetchable
    
    init(binanceFetcher: BinanceFetchable) {
        self.binanceFetcher = binanceFetcher
    }
    
    func AccountDetailsOnSpot() async {
        binanceFetcher.getAccountDetailsOnSpot()
            .sink { (dataResponse) in
                if dataResponse.error != nil {
                    self.createAlert(with: dataResponse.error!)
                } else {
                    self.spotWallet = dataResponse.value!
                }
            }.store(in: &amp;cancellableSet)
    }
    
    func createAlert( with error: NetworkError ) {
        loadingError = error.localizedDescription
        self.showAlert = true
    }
}

struct SpotWallet: Codable, Hashable {
    let makerCommission, takerCommission, buyerCommission, sellerCommission: Int
    let canTrade, canWithdraw, canDeposit: Bool
    let updateTime: Int
    let accountType: String
    let balances: [Balance]
    let permissions: [String]
}


protocol BinanceFetchable {
    func getAccountDetailsOnSpot() -&gt; AnyPublisher&lt;DataResponse&lt;SpotWallet, NetworkError&gt;, Never&gt;
}

class BinanceFetcher {
    var coinPublisher = PassthroughSubject&lt;CoinBalance, Never&gt;()
}

extension BinanceFetcher: BinanceFetchable {
    
    func getAccountDetailsOnSpot() -&gt; AnyPublisher&lt;DataResponse&lt;SpotWallet, NetworkError&gt;, Never&gt; {
        let endpoint = &quot;/api/v3/account&quot;
        let params = BinanceWrapper.shared.makeRequestReady(queries: nil)
        let url = URL(string: &quot;\(BinanceWrapper.BINANCE_BASE_URL)\(endpoint)&quot;)!
        return AF.request(url, parameters: params, encoding: URLEncoding.default, headers: BinanceWrapper.BINANCE_HTTP_HEADERS)
            .validate()
            .publishDecodable(type: SpotWallet.self)
            .map { response in
                response.mapError { error in
                    return NetworkError.parsing(description: error.localizedDescription)
                }
            }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
    
    
}
</code></pre>
","19016454","","","","","2022-05-02 14:35:03","How to update nested structure of a published variable using another api call","<api><swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"72101970","1","72112729","","2022-05-03 15:41:26","","-2","138","<p>When uncommenting the code in the following code block I get the following error.</p>
<p><code>Cannot infer return type for closure with multiple statements; add explicit type to disambiguate</code></p>
<p>But I can't figure out the syntax for explicitly adding a type. How do I do it?</p>
<pre class=""lang-swift prettyprint-override""><code>let path:String = path ?? Self.path
let publisher: AnyPublisher&lt;[Self]?, Error&gt; = NetworkableManager.getAll(path: path) 
    .flatMap {
//     if path == &quot;menus&quot; {
//        print(&quot;It's a menu&quot;)
//     }
       return StorableManager.shared.saveAll($0)
                
    }
    .merge(with: StorableManager.shared.fetchAll(predicate: filters))
    .eraseToAnyPublisher()

</code></pre>
","11920147","","1015258","","2022-05-03 16:46:49","2022-05-04 12:10:05","Add explicit type to flatmap","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"72111025","1","72112141","","2022-05-04 09:54:13","","0","78","<p><code>@Published</code> publishes correctly when used in an <code>ObservableObject</code>. But does not seem to publish when used in an <code>NSManagedObject</code> (which conforms to <code>ObservableObject</code>).</p>
<p>In the following example when using <code>Data1</code> the text below the picker is updated. But using <code>Data2</code> it is not. Why is that?</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import CoreData

class Data1: ObservableObject {
    @Published var direction: Direction = .left
}

class Data2: NSManagedObject { // NSManagedObject conforms to ObservableObject
    @Published var direction: Direction = .left
}

enum Direction {
    case left
    case right
}

@main
struct SwiftUITestApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView().environmentObject(Data2()) // Or Data1() as needed
        }
    }
}

struct ContentView: View {
    @EnvironmentObject private var data: Data2
    
    var body: some View {
        VStack {
            Picker(&quot;&quot;, selection: $data.direction) {
                Text(&quot;Left&quot;).tag(Direction.left)
                Text(&quot;Right&quot;).tag(Direction.right)
            }.pickerStyle(.wheel)
            switch data.direction {
            case .left:
                Text(&quot;Selected: Left&quot;)
            case .right:
                Text(&quot;Selected: Right&quot;)
            }
        }.padding()
    }
}
</code></pre>
","1228933","","","","","2022-05-22 00:37:03","Why does @Published not work in NSManagedObject?","<core-data><swiftui><combine><nsmanagedobject><observableobject>","1","6","","","","CC BY-SA 4.0"
"72117159","1","72117262","","2022-05-04 17:29:45","","0","30","<p>I noticed that <code>sink</code> is called only once</p>
<pre><code>class StorefrontViewModel {
    @Published var page = 0
        @Published var string = &quot;lorem ipsum&quot;

        private var cancellableBag = Set&lt;AnyCancellable&gt;()

        init() {

            let publisher = $page
                .map { [unowned self] in
                    return $0 == 1 ? self.string.lowercased() : self.string.uppercased()
            }

            publisher
                .eraseToAnyPublisher()
                .assign(to: \.string, on: self)
                .store(in: &amp;cancellableBag) // must store the subscriber to get the events
        }
}
</code></pre>
<pre><code>    var pager = StorefrontViewModel()
        pager.$string.sink {  print($0)}
        pager.page = 1 // lorem ipsum
        pager.page = 2 // LOREM IPSUM
        pager.page = 3 // LOREM IPSUM
        pager.page = 4 // LOREM IPSUM
        pager.page = 1 // lorem ipsum
        pager.page = 1 // lorem ipsum
</code></pre>
<p>Here  is the output <code>LOREM IPSUM</code>.</p>
<p>Wondering why <code>sink</code> is called even though I set <code>pager.page</code> value multiple times</p>
","802766","","560942","","2022-05-04 17:31:14","2022-05-04 17:38:17","iOS Combine framework @Published doesnt capture post modification values","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"72128323","1","","","2022-05-05 13:49:01","","0","156","<p>I have a view with two <code>TextFields</code>. When the first one is focused, I'd like to display <code>Next</code> button in the toolbar and when the second text field is focused, I'd like to present <code>Previous</code> and <code>Done</code> buttons in the toolbar.</p>
<p>I have an <code>if</code> statement inside the toolbar, but it looks like it doesn't pick up the change of <code>FocusedState</code> until I type something.</p>
<p>Any ideas how to make it work properly or why doesn't the toolbar pick up the changes?</p>
<p>This is more or less the code (I simplified the actual code):</p>
<pre><code>import SwiftUI
import Combine

enum Field {
    case inLangName
    case outLangName
}


struct MyView: View {
    @FocusState private var focusedTextField: Field?
    @State var inLangName: String = &quot;&quot;
    @State var outLangName: String = &quot;&quot;
    
    var body: some View {
        NavigationView {
            VStack(spacing: 15) {
                TextField(&quot;In lang name&quot;, text: $inLangName)
                    .focused($focusedTextField, equals: .inLangName)
                    .simultaneousGesture(TapGesture().onEnded { _ in
                        focusedTextField = .inLangName
                    })
                
                TextField(&quot;Out lang name&quot;, text: $outLangName)
                    .focused($focusedTextField, equals: .outLangName)
                    .simultaneousGesture(TapGesture().onEnded { _ in
                        focusedTextField = .outLangName
                    })
                
            }
            .navigationBarHidden(true)
            .navigationBarTitleDisplayMode(.inline)
            .onAppear {
                if inLangName.isEmpty {
                    focusedTextField = .inLangName
                }
            }
            .toolbar {
                ToolbarItemGroup(placement: .keyboard) {
                    if focusedTextField == .inLangName || focusedTextField == nil {
                        Spacer()
                        Button(action: {
                            focusedTextField = .outLangName
                        }) {
                            Text(&quot;next&quot;)
                        }
                    } else if focusedTextField == .outLangName {
                        Button(action: {
                            focusedTextField = .inLangName
                        }) {
                            Text(&quot;previous&quot;)
                        }
                        Spacer()
                        Button(action: {
                            //onDoneButtonClicked()
                        }) {
                            Text(&quot;done&quot;)
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
","659389","","659389","","2022-05-05 13:54:28","2022-05-05 13:54:28","SwiftUI iOS15 Toolbar's content not refreshing based on the FocusedState value","<ios><swift><iphone><swiftui><combine>","0","4","","","","CC BY-SA 4.0"
"72145932","1","","","2022-05-06 18:29:13","","0","385","<p>I'm joining development on an existing SwiftUI / Combine iOS project, which is my first exposure to the technology.</p>
<p>The names of functions like <code>assign(to:on:)</code> are easy enough to grok, but I'm lost at <code>sink</code>.</p>
<p>This function is mentioned in some of the most basic Apple documentation, but seemingly never defined.</p>
<blockquote>
<p>Combine provides two built-in subscribers, which automatically match the output and failure types of their attached publisher:</p>
<ul>
<li><code>sink(receiveCompletion:receiveValue:)</code> takes two closures. The first closure executes when it receives Subscribers.Completion, which is an enumeration that indicates whether the publisher finished normally or failed with an error. The second closure executes when it receives an element from the publisher.</li>
</ul>
<p><a href=""https://developer.apple.com/documentation/combine/receiving-and-handling-events-with-combine"" rel=""nofollow noreferrer"">https://developer.apple.com/documentation/combine/receiving-and-handling-events-with-combine</a></p>
</blockquote>
<p>What is a &quot;sink&quot; function in the the world of SwiftUI, Combine, reactive programming?</p>
<p>Why is it called &quot;sink&quot;? What's the etymology? What's the meaning?</p>
<p>Is it intended to refer to &quot;sync&quot; as in syncing? Kitchen sink? Heat sink? Going below the surface? Why is the name &quot;sink&quot;?</p>
","1265393","","1265393","","2022-05-06 18:44:05","2022-05-06 20:11:47","Etymology of ""sink"" in SwiftUI / Combine?","<swiftui><reactive-programming><naming-conventions><naming><combine>","2","2","1","","","CC BY-SA 4.0"
"72170342","1","","","2022-05-09 10:14:21","","2","138","<p>Is there a way to conditionally execute the parts of the pipeline ? Say in the code below i would want a bool which determines whether the api call and the debounce are executed or not (if true execute the debounce and api call, if false erase without them) ?</p>
<pre><code>    var flag: Bool // true: validate university via server, 
                   // false: only validate with operations before debounce and flat map

    init(flag: Bool) {
        self.flag = flag
        
        validate
            .receive(on: RunLoop.main)
            .sink { [weak self] value in
                self?.loading = false
                self?.validated = value
            }
            //.assign(to: \.validated, on: self)
            .store(in: &amp;cancellables)
    }

    private var validate: AnyPublisher&lt;String?, Never&gt; {
        $value
            .dropFirst()
            .removeDuplicates()
            .trim()
            .filter { value in
                value.contains(&quot;@&quot;) &amp;&amp; value.contains(&quot;.&quot;)
            }
            .debounce(for: 1, scheduler: RunLoop.main) // from here on conditionally
            .flatMap { value in
                return Future { promise in
                    self.loading = true
                    Task {
                        Firebase.validate(email: value) { error in
                            promise(.success(error != nil ? nil : value))
                        }
                    }
                }
            }
            .eraseToAnyPublisher()
    }
</code></pre>
","9022641","","9022641","","2022-05-11 08:15:03","2022-05-11 13:42:48","Conditionally add operations to pipeline in Combine (Swift)","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"72186172","1","","","2022-05-10 12:16:41","","0","213","<p>I am refactoring / adding features to some code and encountered a situation where I want to migrate by protocoling the types.</p>
<p>Currently I have a data type like this:</p>
<pre><code>struct Result {
  let a: Int
  let b: Int
  let c: Int
}
</code></pre>
<p>and an <code>ObservableObject</code> like this:</p>
<pre><code>class Worker1 : ObservableObject {
   @Published var results: [Result] // this data is rendered by the UI against the concrete type of &quot;Result&quot;
}
</code></pre>
<p>and some views similar to this (using the <code>Result</code> type):</p>
<pre><code>struct SomeUIComponent: View {
  @Binding var results: [Result]
  ....
}
</code></pre>
<p>I am in the process of migrating to an augmented result type (identical otherwise to the original result)</p>
<pre><code>struct Result2 {
  let a: Int
  let b: Int
  let c: Int
  let d: Int // this along with some additional non-trivial things are new
}
</code></pre>
<p>handled by a new <code>Worker2</code> ObservableObject</p>
<pre><code>class Worker2: ObservableObject {
  @Published var results: [Result2] // I want this as a protocol instead
}
</code></pre>
<p>for the older UI components, they only utilize the common fields <code>a</code> and <code>b</code></p>
<p>while some new components care about the newly added fields.</p>
<p>I want to back patch the existing UI components gradually by working against the protocol types rather than the concrete types directly</p>
<p>To achieve this I created a set of protocols to align with the original <code>Result</code> type and implemented it on both the original <code>Result</code> as well as the newly defined <code>Result2</code>:</p>
<pre><code>// currently aligned with the original Result type
protocol ResultProtocol {
  var a: Int {get}
  var b: Int {get}
  var c: Int {get}
}
</code></pre>
<p>I need an additional protocol to support <code>Worker1</code> publishers and the new <code>Worker2</code> publishing of the <code>ResultProtocol </code> type (rather than the concrete type it had been defined to use earlier). This is important to allow gradual replacement of parts without fixing a large combination of things.</p>
<p>I tried this:</p>
<pre><code>// create a supporting protocol which the UI components can access , reading the protocol stubbed type rather than the concrete type
protocol WorkerProtocol {
  var resultsPublisher:  Published&lt;[ResultProtocol]&gt;.Publisher {get}
}
</code></pre>
<p>and now hitting a wall when trying to extend the &quot;Worker1&quot; implementation to handle this:</p>
<pre><code>extension Worker1 : WorkerProtocol {
  var resultsPublisher:  Published&lt;[ResultProtocol]&gt;.Publisher { $results } // this doesn't work, it doesn't &quot;cast&quot; the concrete type &quot;Result&quot; to the protocol type 
// I believe the concrete type is Published&lt;[Result]&gt;.Publisher, while Result does implement the ResultProtocol, this doesn't compile
// Type of expression is ambiguous without more context
}
</code></pre>
<p>I tried to cast it / map it / erase to anytype it / etc.</p>
<p>example:</p>
<pre><code>$results as  Published&lt;[ResultsProtocol]&gt;.Publisher
$results.eraseToAny
</code></pre>
","1532045","","","","","2022-05-10 12:16:41","how to protocol a publisher for SwiftUI","<swift><swiftui><combine>","0","1","","","","CC BY-SA 4.0"
"72186663","1","","","2022-05-10 12:52:14","","1","103","<p>Some users are getting this error in the app when storing a Cancellable in a <code>Set</code> using the <code>AnyCancellable.store(in:)</code> method. The error maybe happens to a 10% of the users and I can't really replicate it.</p>
<p>This is a simplified version of the code:</p>
<pre><code>    private var cancellables = Set&lt;AnyCancellable&gt;()
    private func doSomeWork() {
        doMoreWork() {
            DispatchQueue.main.async { [weak self] in
                guard let self = self else { return }

                service.valuesPublisher
                    .sink { [weak self] something in
                        self?.doSomeWork(something)
                    }
                    .store(in: &amp;self.cancellables)
            }
        }

</code></pre>
<p>And the error's log is the following:</p>
<pre><code>Exception Type:  EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note:  EXC_CORPSE_NOTIFY
Triggered by Thread:  0

Last Exception Backtrace:
0   CoreFoundation                  0x193a3cd78 __exceptionPreprocess + 220 (NSException.m:200)
1   libobjc.A.dylib                 0x1ac6a1734 objc_exception_throw + 60 (objc-exception.mm:565)
2   CoreFoundation                  0x193b1ab88 -[NSObject(NSObject) doesNotRecognizeSelector:] + 144 (NSObject.m:147)
3   CoreFoundation                  0x1939d1988 ___forwarding___ + 1764 (NSForwarding.m:3577)
4   CoreFoundation                  0x1939d0a60 _CF_forwarding_prep_0 + 96
5   libswiftCore.dylib              0x1986312fc __CocoaDictionary.lookup(_:) + 56
6   Combine                         0x1aba3d5ec specialized Set._Variant.insert(_:) + 104 (&lt;compiler-generated&gt;:0)
7   Combine                         0x1aba5a024 AnyCancellable.store(in:) + 48 (&lt;compiler-generated&gt;:0)

</code></pre>
<p>I have no idea why this could happen, any hints?</p>
","4102381","","4102381","","2022-05-11 13:57:25","2022-05-11 13:57:25","Error when storing a publisher in an AnyCancellable's Set","<swift><collections><combine><dylib>","0","5","","","","CC BY-SA 4.0"
"72196004","1","72204497","","2022-05-11 05:52:04","","1","135","<p>I am trying to subscribe to multiple publishers. The Output type of publishers may not be determined.</p>
<pre class=""lang-swift prettyprint-override""><code>static func listen&lt;T&gt;(publisher: Published&lt;T&gt;.Publisher){
    publisher.sink { _Arg in
        // do something
    }.store(in: &amp;cancellables)
}
listen(publisher: env.$showMenuIcon)
listen(publisher: env.$dateFormatLunar)
listen(publisher: env.$dateFormatAd)
listen(publisher: env.$showWeek)
listen(publisher: env.$showWeather)
// in env class
@Published var timeItem = true
@Published var dateFormatAd = &quot;yyyy-MM-dd&quot;
</code></pre>
<p>Each of my publishers may have different generic parameter types, and I can only call listen by copying multiple lines of code like this. Is there any way to modify the Listen method to accept an array type? Or is there another way I can simplify my code?</p>
","8545825","","","","","2022-05-11 16:24:41","In Swift, how to assign values when generic parameters are different","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72196892","1","72196948","","2022-05-11 07:16:46","","1","60","<p>If I create an <code>ObservableObject</code> with a <code>@Published</code> property and inject it into a SwifUI view with <code>.environmentObject()</code>, the view responds to changes in the ObservableObject as expected.</p>
<pre class=""lang-swift prettyprint-override""><code>class CounterStore: ObservableObject {
    @Published private(set) var counter = 0
    func increment() {
        counter += 1
    }
}

struct ContentView: View {
    @EnvironmentObject var store: CounterStore

    var body: some View {
        VStack {
            Text(&quot;Count: \(store.counter)&quot;)
            Button(action: { store.increment() }) {
                Text(&quot;Increment&quot;)
            }
        }
    }
}
</code></pre>
<p>Tapping on &quot;Increment&quot; will increase the count.</p>
<p>However, if I don't use the <code>EnvironmentObject</code> and instead pass the store instance into the view, the compiler does not complain, the store method <code>increment()</code> is called when the button is tapped, but the count in the <code>View</code> does <strong>not</strong> update.</p>
<pre><code>struct ContentViewWithStoreAsParameter: View {
    var store: CounterStore

    var body: some View {
        VStack {
            Text(&quot;Count: \(store.counter) (DOES NOT UPDATE)&quot;)
            Button(action: { store.increment() }) {
                Text(&quot;Increment&quot;)
            }
        }
    }
}
</code></pre>
<p>Here's how I'm calling both Views:</p>
<pre><code>@main
struct testApp: App {
    var store = CounterStore()
    
    var body: some Scene {
        WindowGroup {
            VStack {
                ContentView().environmentObject(store) // works
                ContentViewWithStoreAsParameter(store: store) // broken
            }
        }
    }
}

</code></pre>
<p>Is there a way to pass an <code>ObservableObject</code> into a View as a parameter? (Or what magic is <code>.environmentalObject()</code> doing behind the scenes?)</p>
","18158","","","","","2022-05-11 08:26:53","SwiftUI: Must an ObservableObject be passed into a View as an EnvironmentObject?","<swiftui><combine><observableobject>","2","0","","","","CC BY-SA 4.0"
"72203921","1","","","2022-05-11 15:40:51","","0","57","<p>I have two Publishers, I want to feed the second one with the result of first one, I could do what I wanted by calling the second one nested into the first one, it works but it does not feel good to look at, is there a better way to do it?</p>
<p>the first Publisher returns <code>AnyPublisher&lt;URL, Error&gt;</code> and the second one returns <code>AnyPublisher&lt;JsonModel, Error&gt;</code></p>
<pre><code>func upload(input: URL, output: URL) {
    let converter = MP3Converter()
    converter.convert(input: input, output: output)
        .sink { [weak self] result in
            if case .failure(let error) = result {
                ConsoleLogger.log(error)
                self?.uploadedRecordingURL = nil
            }
        } receiveValue: { url in
            guard let data = try? Data(contentsOf: url) else {
                return
            }
            self.repository.uploadCover(data: data)
                .sink(receiveCompletion: { [weak self] result in
                    if case .failure(let error) = result {
                        ConsoleLogger.log(error)
                        self?.uploadedRecordingURL = nil
                    }
            }, receiveValue: { [weak self] response in
                self?.uploadedRecordingURL = response.fileURL
            
            }).store(in: &amp;self.disposables)
        }.store(in: &amp;disposables)
}
</code></pre>
","689779","","","","","2022-05-11 19:14:20","An Ordered chain of Publishers","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"72208508","1","72208615","","2022-05-11 23:07:54","","1","40","<p>I am trying to better understand the Combine framework. AFAIK, <code>.sink()</code> connects a publisher to a subscriber. In an Xcode Playground page, who exactly is the subscriber? Consider the following example:</p>
<pre><code>PlaygroundPage.current.needsInfiniteExecution = true

var subscriptions: Set&lt;AnyCancellable&gt; = []

Timer.TimerPublisher(every: 1, on: .main, in: .common)
    .autoconnect()
    .sink { print($0) }    // Who is this sink connecting the timer publisher to?
    .store(in: &amp;subscriptions)
</code></pre>
<p>I know the pub-sub link is taking place because the publisher does indeed start publishing. It is just unclear who the subscriber is. Is there a way to deterministically query Combine for who the subscriber is?</p>
<p>Also, if the subscriber of this timer publisher is the playgroundPage's current instance, then why do I have to store the subscription using <code>store(in:)</code>? Shouldn't this be unnecessary since the subscriber is not going out of scope any time soon (not until I stop the playground)?</p>
","5565491","","","","","2022-05-11 23:35:26","Who exactly is the subscriber of an Xcode Playground Publisher?","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72214494","1","","","2022-05-12 11:10:56","","-3","116","<p>Is there a way to cancel a subscription within a sink? Below seems to work but comes an error</p>
<p><a href=""https://i.stack.imgur.com/ked76.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ked76.png"" alt=""enter image description here"" /></a></p>
","1861935","","","","","2022-05-12 13:30:03","Cancel subscription within sink in SwiftUI Combine","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"72222045","1","","","2022-05-12 21:05:01","","0","121","<p>The following codes will output</p>
<p>1,2,3,4,5, then 300,400, 500</p>
<p>Is there a way to emit one by one like</p>
<p>1, 300, 2, 400, 3, 500, 4, 5</p>
<pre class=""lang-swift prettyprint-override""><code>print(&quot;\n* Demonstrating Merge&quot;)
let publisher1 = [1,2,3,4,5].publisher
let publisher2 = [300,400,500].publisher

let mergedPublishersSubscription = Publishers
    .Merge(publisher1, publisher2)
    .sink { value in
        print(&quot;Merge: subscription received value \(value)&quot;)
}
</code></pre>
","1861935","","","","","2022-05-26 22:21:52","How to merge Publisher one by one in Swift Combine","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"72222778","1","72224949","","2022-05-12 22:42:42","","0","147","<p>I am trying to create a class that executes data loading once and returns the data to all callers of the method while the data was loading to not perform the data loading for the same item (identifier) more than once. The issue I am having is that it seems to crash on the first initialization of <code>CurrentValueSubject</code> for an identifier. This only happens if the <code>downloadStuff</code> returns an <code>Error</code> I have no idea what's wrong. Here is a reproduction of the issue.</p>
<p>Class that does the synchronization:</p>
<pre><code>class FetchSynchronizer&lt;T, ItemIdentifier: Hashable&gt; {

typealias CustomParams = (isFirstLoad: Bool, result: Result&lt;T, Error&gt;)

    enum FetchCondition {
        // executes data fetching only once
        case executeFetchOnlyOnce
        // re-executes fetch if request failed
        case retryOnlyIfFailure
        // always executes fetch even if response is cached
        case noDataCache
        // custom condition
        case custom((CustomParams) -&gt; Bool)
    }
    
    struct LoadingState&lt;T&gt; {
        let result: Result&lt;T, Error&gt;
        let isLoading: Bool
        
        init(result: Result&lt;T, Error&gt;? = nil, isLoading: Bool = false) {
            self.result = result ?? .failure(NoResultsError())
            self.isLoading = isLoading
        }
    }
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private var isLoading: [ItemIdentifier: CurrentValueSubject&lt;LoadingState&lt;T&gt;, Never&gt;] = [:]
    
    func startLoading(identifier: ItemIdentifier,
                      fetchCondition: FetchCondition = .executeFetchOnlyOnce,
                      loaderMethod: @escaping () async -&gt; Result&lt;T, Error&gt;) async -&gt; Result&lt;T, Error&gt; {
        
        // initialize loading tracker for identifier on first execution
        var isFirstExecution = false
        if isLoading[identifier] == nil {
            print(&quot;----0&quot;)
            isLoading[identifier] = CurrentValueSubject&lt;LoadingState&lt;T&gt;, Never&gt;(LoadingState&lt;T&gt;())
            isFirstExecution = true
        }
        
        guard let currentIsLoading = isLoading[identifier] else {
            assertionFailure(&quot;Should never be nil because it's set above&quot;)
            return .failure(NoResultsError())
        }
        
        if currentIsLoading.value.isLoading {
            // loading in progress, wait for finish and call pending callbacks
            return await withCheckedContinuation { continuation in
                currentIsLoading.filter { !$0.isLoading }.sink { currentIsLoading in
                    continuation.resume(returning: currentIsLoading.result)
                }.store(in: &amp;cancellables)
            }
        } else {
            // no fetching in progress, check if it can be executed
            let shouldFetchData: Bool
            switch fetchCondition {
            case .executeFetchOnlyOnce:
                // first execution -&gt; fetch data
                shouldFetchData = isFirstExecution
            case .retryOnlyIfFailure:
                // no cached data -&gt; fetch data
                switch currentIsLoading.value.result {
                case .success:
                    shouldFetchData = false
                case .failure:
                    shouldFetchData = true
                }
            case .noDataCache:
                // always fetch
                shouldFetchData = true
            case .custom(let completion):
                shouldFetchData = completion((isFirstLoad: isFirstExecution,
                                              result: currentIsLoading.value.result))
            }
            
            if shouldFetchData {
                
                currentIsLoading.send(LoadingState(isLoading: true))
                // fetch data
                return await withCheckedContinuation { continuation in
                    Task {
                        // execute loader method
                        let result = await loaderMethod()
                        let state = LoadingState(result: result,
                                                 isLoading: false)
                        currentIsLoading.send(state)
                        continuation.resume(returning: result)
                    }
                }
            } else {
                // use existing data
                return currentIsLoading.value.result
            }
        }
    }
}
</code></pre>
<p>Example usage:</p>
<pre><code>class Executer {
    
    let fetchSynchronizer = FetchSynchronizer&lt;Data?, String&gt;()
    
    func downloadStuff() async -&gt; Result&lt;Data?, Error&gt; {
        await fetchSynchronizer.startLoading(identifier: &quot;1&quot;) {
            return await withCheckedContinuation { continuation in
                sleep(UInt32.random(in: 1...3))
                print(&quot;-------request&quot;)
                continuation.resume(returning: .failure(NSError() as Error))
            }
        }
    }
    
    init() {
        start()
    }
    
    func start() {
        Task {
            await downloadStuff()
            print(&quot;-----3&quot;)
        }
        DispatchQueue.global(qos: .utility).async {
            Task {
                await self.downloadStuff()
                print(&quot;-----2&quot;)
            }
        }
        
        DispatchQueue.global(qos: .background).async {
            Task {
                await self.downloadStuff()
                print(&quot;-----1&quot;)
            }
        }
    }
}
</code></pre>
<p>Start the execution:</p>
<pre><code>Executer()
</code></pre>
<p>Crashes at</p>
<pre><code>isLoading[identifier] = CurrentValueSubject&lt;LoadingState&lt;T&gt;, Never&gt;(LoadingState&lt;T&gt;())
</code></pre>
<p>Any guidance would be appreciated.</p>
","1310984","","","","","2022-05-15 16:44:42","EXC_BAD_ACCESS when initializing Dictionary of CurrentValueSubject in Swift","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"72234481","1","72236104","","2022-05-13 19:17:13","","0","135","<p>How can I observe changes on an array with Combine framework but without SwiftUI?</p>
<p>Basically, I want this sink block to get called when an element is added or removed.</p>
<pre><code>import Combine

var list = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
list.publisher
    .collect()
    .sink { value in
        print(value)
    }

// I want to observe these changes.
list.append(&quot;D&quot;)
list.removeAll { $0 == &quot;B&quot;}
</code></pre>
<p>I read <a href=""https://stackoverflow.com/questions/71097740/how-to-observe-arrays-new-values-with-combine"">this article</a> and I know <code>@Published</code> property wrapper works this way.
But I can't use SwiftUI and am looking for another solution.</p>
","376482","","","","","2022-05-17 20:11:55","How do I observe changes on an array with Combine framework?","<ios><swift><combine>","1","4","","","","CC BY-SA 4.0"
"72240977","1","72306773","","2022-05-14 14:07:11","","0","194","<p>I have a <code>PassthroughSubject</code> which is connected to a <code>ScrollView</code> and it emits while it scrolls. I want the subject to emit the current scroll value, but only once per second. I tried <code>throttle</code> and <code>debounce</code>, but they don't seem to be doing what I need.</p>
<p>Like this, I can see every time it emits while I'm scrolling, so my base setup of scroll detection is working well.</p>
<pre><code>scrollSubject
    .sink { value in
        print(value)
    }
    .store(in: &amp;subscription)
</code></pre>
<p>But when I try to use either of these:</p>
<p><code>.throttle(for: 1, scheduler: RunLoop.main, latest: false)</code> (tried <code>latest: true</code> also)`</p>
<p><code>.debounce(for: 1, scheduler: RunLoop.main)</code></p>
<p>What happens is they are not emitting while I'm scrolling, only after I've stopped it emits the latest value. How is it possible to achieve the desire behaviour?</p>
","13505419","","","","","2022-05-19 14:53:13","Swift Combine - Emit the latest value once per second","<ios><swift><combine>","1","1","","","","CC BY-SA 4.0"
"72270490","1","","","2022-05-17 08:19:11","","0","168","<p>I have trouble with getting Binding values in correct format out of dataModel.</p>
<p>The XCode error I am getting is
&quot;Cannot convert value of type '[Binding&lt;String?&gt;]' to expected argument type
'Binding&lt;[String]&gt;'&quot;</p>
<pre><code>public final class RoomSelectionDataModel: ObservableObject {
    @Published var roomsList: [Room]
    @Published var selectedRoom: String?

}
public struct RoomSelectionView: View {
    @StateObject var dataModel: RoomSelectionDataModel
    public var body: some View {
        let bindingArray = $dataModel.roomsList.compactMap { $0.name } // here the format is '[Binding&lt;String?&gt;]' instead of 'Binding&lt;[String]&gt;'
        SelectionList(listElements: bindingArray,
                      backgroundColor: Color(red: 0.94, green: 0.94, blue: 0.94), // color to be removed
                      selectedElement: $dataModel.selectedRoom)
    }
    
    public init(dataModel: RoomSelectionDataModel) {
        self._dataModel = StateObject(wrappedValue: dataModel)
        
    }
}
</code></pre>
<pre><code>public struct SelectionList: View {
    
    let backgroundColor: Color
    @Binding var listElements: [String]
    @Binding var selectedElement: String?
    
    public init(listElements: Binding&lt;[String]&gt;, backgroundColor: Color, selectedElement: Binding&lt;String?&gt;) {
        self._listElements = listElements
        self.backgroundColor = backgroundColor
        self._selectedElement = selectedElement
    }
}
</code></pre>
<pre><code> public class Room: NSObject, Codable {
    public var name: String?
}
</code></pre>
<p>The models are simplified here, to only have the relevant information.</p>
","8420544","","8420544","","2022-05-17 08:44:53","2022-05-23 17:43:33","How to convert Binding array value to Binding<[type]> instead of [Binding<type>] in Swift/SwiftUI","<ios><arrays><swift><swiftui><combine>","1","11","0","","","CC BY-SA 4.0"
"72277049","1","","","2022-05-17 15:45:35","","0","74","<p>In SwiftUI, combine I have a published property.</p>
<pre><code>@Published
var name: String
</code></pre>
<p>And when the name is updated it calls an app and set other values.</p>
<pre><code>$name
...
...
.assign(to: &amp;$something)
</code></pre>
<p>Now I want to call this without updating the name at some case</p>
","8014650","","415303","","2022-05-23 17:15:31","2022-05-24 22:41:46","How to call published property without updating value","<ios><swiftui><combine>","1","5","","","","CC BY-SA 4.0"
"72292515","1","","","2022-05-18 16:03:32","","0","179","<p>I am new to SwiftUI and RealityKit.</p>
<p>I have a data in UIView which was updated by ARView's subscribe to a sceneEvent. When the subscribe function finished, I don't know how to receive the data variable in the ExtendARView in content_view</p>
<pre><code>class ExtendARView: ARView {
    private var data: Bool
    
...
} 
</code></pre>
<p>I use a subscribe function in it to alter the data variable</p>
<p>in content_view() I use a UIViewRepresentable:</p>
<pre><code>struct ARViewConatiner: UIViewRepresentable {
    
    @Binding var data: Bool
    
    let arView = TestARView(frame: .zero)
    
    func makeUIView(context: Context) -&gt; ExtendARView {
        return arView
    }
    
    func updateUIView(_ uiView: ExtendARView, context: Context) {
        
    }
    
}
</code></pre>
<p>I think I can achieve this by combine framework, or other possible ways?</p>
<p>Thank you in advance.</p>
","14652145","","1015258","","2022-05-18 20:36:38","2022-05-18 20:36:38","Pass value from UIViewRepresentable to SwiftUI","<swift><swiftui><publish-subscribe><combine>","0","3","","","","CC BY-SA 4.0"
"72301105","1","","","2022-05-19 08:26:47","","0","43","<p>I am trying to perform a cleanup after the subscriber has stopped listening to the publisher.</p>
<p>My approach was to register for a closing and deallocation event, but I am struggling to figure out when a subscriber has stopped listening for events coming from a <code>PassthroughSubject</code>.</p>
<p>By &quot;subscriber has stopped listening&quot;, I mean that the subscriber (<code>.sink</code>, for example), which created the subscription, either deallocated the subscription or explicitly called <code>cancel</code> on the returned cancellable value.</p>
<p>I know other reactive libraries usually come with an <code>onEnd</code> operator, but Combine doesn't have it. Is that even the right pattern here?</p>
","2946444","","2946444","","2022-05-19 08:57:50","2022-05-19 10:16:35","Apple Combine: How to tell that a subscriber stopped listening to a publisher","<swift><combine>","0","7","","2022-05-22 10:16:21","","CC BY-SA 4.0"
"72308801","1","72321316","","2022-05-19 17:29:29","","0","304","<p>I'm trying to use a Combine subscriber to wait for a specific value from a publisher, which seems easy enough if I handle the values in <code>sink(receiveValue:)</code>, but I want to convert the publisher to another publisher that just finishes when the specific value is received.</p>
<p>This is the code that works:</p>
<pre><code>let publisher: AnyPublisher&lt;Int, Never&gt; = ...

let cancellable = publisher.sink(receiveValue: { value in
    if value == myFavoriteNumber {
        // we're finished!
    }
})
</code></pre>
<p>What I'm trying to accomplish is something like this:</p>
<pre><code>let modifiedPublisher: AnyPublisher&lt;Never, Never&gt; = publisher.compactMap({ 
    $0 == myFavoriteNumber ? Publishers.Completion.finished : nil 
}).eraseToAnyPublisher()
</code></pre>
<p>Is there a way to do this?</p>
","1275947","","1275947","","2022-05-19 18:13:07","2022-05-20 15:20:21","How to have Combine subscriber finish upon receiving specific value","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72338747","1","72339453","","2022-05-22 15:04:36","","0","155","<p>I am a little uncertain about task cancellation in swift. My question is:</p>
<p><strong>If a task reaches its return line (in this example, <code>Line 4</code>), does this mean it will be automatically canceled?</strong> (and thus free up memory + any used thread(s) previously occupied by the Task?)</p>
<pre class=""lang-swift prettyprint-override""><code>someBlock {
    Task&lt;Bool, Never&gt; {
        await doSomeWork()
        return true // Line 4
    }
}
</code></pre>
<p>As a follow-up, what if we then call <code>.task</code> on a SwiftUI <code>View</code>? Does anything change?</p>
<pre class=""lang-swift prettyprint-override""><code>SomeView
    .task {
        await doSomeWork()
    }
</code></pre>
<p>Thank you for your time!</p>
","14602519","","14602519","","2022-05-22 15:18:00","2022-05-22 16:37:05","Are Tasks automatically cancelled upon return/completion in Swift?","<ios><swift><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"72343943","1","","","2022-05-23 06:09:46","","-1","78","<p>I am using combine to handle the network response. I am stuck here to handle the common errors. Can you please help me how Can I handle the errors.</p>
<pre><code>func performRequest&lt;T:Decodable&gt;(router:APIConfiguration, decodeType:T.Type) -&gt;AnyPublisher&lt;DataResponse&lt;T, NetworkError&gt;, Never&gt; {
    guard let url = URL.init(string: router.requestedURL) else {
        return Fail(error: NetworkError.init(code: 2345, message: &quot;Bad URL&quot;)).eraseToAnyPublisher()
    }
    let storage = KeycheinStorage()
    print(router.requestedURL,router.parameters ?? [:])
    return AF.request(router.requestedURL, method: router.method, parameters: router.parameters, interceptor: AuthTokenInterceptor(storage: storage))
        .validate()
        .publishDecodable(type: T.self)
        .map { response in
            response.mapError { error in
                let networkError = response.data.flatMap {
                    try? JSONDecoder().decode(NetworkError.self, from: $0)
                } ?? NetworkError(error)
                ErrorHandler.default.handle(networkError)
                return networkError
            }
        }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
}
</code></pre>
<p><a href=""https://i.stack.imgur.com/md10g.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/md10g.png"" alt=""enter image description here"" /></a></p>
","4497582","","","","","2022-05-24 03:26:16","How can I handle the bad url error using combine?","<ios><swift><alamofire><combine>","2","1","","","","CC BY-SA 4.0"
"72347551","1","","","2022-05-23 11:09:44","","-2","84","<p>I try to maing a global publisher,like:</p>
<pre><code>@Published var counter = 0
</code></pre>
<p>But here is a error:</p>
<pre><code>Property wrappers are not yet supported in top-level code
</code></pre>
<p>How to share global Publisher variables between models？</p>
","16316384","","4667835","","2022-05-23 11:29:36","2022-05-23 17:40:24","How to making a global Publisher?","<swift><combine>","2","1","","","","CC BY-SA 4.0"
"72350432","1","72364692","","2022-05-23 14:42:13","","0","546","<p>The following is the content of a playground that illustrates the problem. Basically I have a value stored in <code>UserDefaults</code> and accessed by a variable wrapped in the <code>@AppStorage</code> property wrapper. This lets me access the updated value in a <code>View</code> but I'm looking for a way to listen to changes in the property in <code>ViewModel</code>s and other non-<code>View</code> types.</p>
<p>I have it working in the follow code but I'm not sure it's the best way to do it and I'd love to avoid having to declare a <code>PassthroughSubject</code> for each property I want to watch.</p>
<p>Note: I did originally <code>sink</code> the <code>ObservableObject</code>'s <code>objectWillChange</code> property however that will reflect any change to the object and I'd like to do something more fine grained.</p>
<p>So does anyone have any ideas on how to improve this technique?</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import PlaygroundSupport
import SwiftUI

class AppSettings: ObservableObject {
    var myValueChanged = PassthroughSubject&lt;Int, Never&gt;()
    @AppStorage(&quot;MyValue&quot;) var myValue = 0 {
        didSet { myValueChanged.send(myValue) }
    }
}

struct ContentView: View {

    @ObservedObject var settings: AppSettings
    @ObservedObject var viewModel: ValueViewModel

    init() {
        let settings = AppSettings()
        self.settings = settings
        viewModel = ValueViewModel(settings: settings)
    }

    var body: some View {
        ValueView(viewModel)
            .environmentObject(settings)
    }
}

class ValueViewModel: ObservableObject {

    @ObservedObject private var settings: AppSettings
    @Published var title: String = &quot;&quot;
    private var cancellable: AnyCancellable?

    init(settings: AppSettings) {
        self.settings = settings
        title = &quot;Hello \(settings.myValue)&quot;

        // Is there a nicer way to do this?????
        cancellable = settings.myValueChanged.sink {
            print(&quot;object changed&quot;)
            self.title = &quot;Hello \($0)&quot;
        }
    }
}

struct ValueView: View {

    @EnvironmentObject private var settings: AppSettings
    @ObservedObject private var viewModel: ValueViewModel

    init(_ viewModel: ValueViewModel) {
        self.viewModel = viewModel
    }

    var body: some View {
        Text(&quot;This is my \(viewModel.title) value: \(settings.myValue)&quot;)
            .frame(width: 300.0)
        Button(&quot;+1&quot;) {
            settings.myValue += 1
        }
    }
}

PlaygroundPage.current.setLiveView(ContentView())
</code></pre>
","247090","","","","","2022-08-06 09:07:28","How can I listen to changes in a @AppStorage property when not in a view?","<swift><swiftui><combine>","3","2","","","","CC BY-SA 4.0"
"72384846","1","72386328","","2022-05-25 22:39:21","","0","507","<p>I am setting up a <code>sink</code> like so:</p>
<pre><code>    name.publisher
        .removeDuplicates()
        .receive(on: RunLoop.main)
        .sink { [weak self] config in
            guard let self = self else { return }

            // this closure gets called right away at setup even though the @Published property `name` was already setup and did not change
            
        }.store(in: &amp;subscribers)
</code></pre>
<p>The property is declared like so in an observable object:</p>
<pre><code> @Published var name:String = &quot;&quot;
</code></pre>
<p>So, I'm obviously missing something here. Why is sink called once at setup even though <code>name</code> did not change? I can avoid this behavior by using the <code>dropFirst()</code> operator but, I'd like to understand why the closure is always called once immediately after setup?</p>
<p>Why is that?</p>
","728246","","728246","","2022-05-26 03:16:57","2022-05-26 04:11:52","Swift Combine sink called once at setup?","<ios><swift><combine>","1","2","","","","CC BY-SA 4.0"
"72386187","1","72386626","","2022-05-26 02:56:58","","1","182","<p>I am using <code>WkWebView</code> for my app. When the view is loaded I would like to display the score Natively and not in the <code>WkWebView</code>. I used the <code>combine</code> Frame work to create an <code>ObservableObject</code> in order to display my score to the view and other views when the score changes in the <code>WkWebview</code>. I use <code>window.onload</code> to get the most recent score and display it when the page first renders. I do so by calling a JS function which sends a message to the Native side <code>webkit.messageHandlers.bridge.postMessage(&quot;0&quot;) </code> with the score and assign the sent score to my <code>ObservedObject</code>. The issue is on the Native side. The <code>UserContentController</code> function, which handles the message from the <code>WkWebview</code>, keeps printing out the score and reassigning the score to my <code>ObservedObject</code>.  It seems to be stuck in a loop. I provided a simplified version of the code below. Have been stuck on this for a few days now and cant seem to fix the issue.</p>
<pre><code> //Holds the score
class Myscore:ObservableObject{
@Published var score = &quot;0&quot;

}


 //Wkwebview
struct WebView: UIViewRepresentable {
@ObservedObject var myScore : Myscore

 class Coordinator: NSObject, WKNavigationDelegate, WKScriptMessageHandler {
    var webView: WKWebView?
    var myScore: Myscore
    init(myScore:Myscore) {
        self.myScore = myScore
        super.init()
        
    }
    
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        self.webView = webView
    }
    
    // receive message from wkwebview
    func userContentController(
        _ userContentController: WKUserContentController,
        didReceive message: WKScriptMessage
    ) {
        // This is where the issue occurs
        var newscore = message.body as! String
        myScore.score = newscore
        print(myScore.score)
    
    }
    
  }

func makeCoordinator() -&gt; Coordinator {
    return Coordinator(myScore:myScore)
}

func makeUIView(context: Context) -&gt; WKWebView {
    let coordinator = makeCoordinator()
    let userContentController = WKUserContentController()
    userContentController.add(coordinator, name: &quot;bridge&quot;)
    
    let configuration = WKWebViewConfiguration()
    configuration.userContentController = userContentController
    
    let _wkwebview = WKWebView(frame: .zero, configuration: configuration)
    _wkwebview.navigationDelegate = coordinator
    
    return _wkwebview
}

  func updateUIView(_ webView: WKWebView, context: Context) {
    guard let path: String = Bundle.main.path(forResource: &quot;index&quot;, ofType: &quot;html&quot;) 
 else { return }
    let localHTMLUrl = URL(fileURLWithPath: path, isDirectory: false)
    webView.loadFileURL(localHTMLUrl, allowingReadAccessTo: localHTMLUrl)
   }
 }

//Content View to display the Score
struct ContentView: View {
 @StateObject var myScore = Myscore()

var body: some View {
    VStack {
     
        Text(&quot;Your Score is\( myScore.score)&quot;)
        WebView(myScore: myScore)
    }
   }
  }
</code></pre>
<p>Edit here is the html side:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1, minimum-scale=1, viewport-fit=cover&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;button&gt;click me&lt;/button&gt;
&lt;hr/&gt;
&lt;div id=&quot;log&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    window.onload = function () {
        webkit.messageHandlers.bridge.postMessage(&quot;98 points&quot;)

    
    }
 
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Edit 2: This is what the console prints out
<a href=""https://i.stack.imgur.com/kX97a.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kX97a.png"" alt=""This is what the console prints out"" /></a></p>
","2029602","","2029602","","2022-05-26 04:04:19","2022-05-26 12:46:01","Change ObservedObject Value with Wkwebview","<swift><swiftui><wkwebview><combine>","2","4","","","","CC BY-SA 4.0"
"72394424","1","72395634","","2022-05-26 15:38:20","","0","218","<p>I want to use Alamofire to query my backend, encode the response using Alamofire's built-in Codable parsing and then publish an extract from the resulting Struct to be consumed by the caller of my API class.  Say I have some JSON data from my backend (simplified, but shows the structure):</p>
<pre><code>{
    &quot;total&quot;: 123,
    &quot;results&quot;: [
        {&quot;foo&quot; : &quot;bar&quot;},
        {&quot;foo&quot; : &quot;baz&quot;}
    ]
}
</code></pre>
<p>and the associated <code>Codable</code> Structs</p>
<pre><code>struct MyServerData: Codable {
    let total: Int
    let results: [Result]
}

struct Result: Codable {
    let foo: String
}
</code></pre>
<p>I can get, parse, publish, and subscribe all fine with the following:</p>
<pre class=""lang-swift prettyprint-override""><code>func myAPI() -&gt; DataResponsePublisher&lt;MyServerData&gt; {
    return AF.request(&quot;https://backend/path&quot;)
        .validate()
        .publishDecodable(type: MyServerData.self)
}

myAPI()
    .sink { response in /* Do stuff, e.g. update @State */ }
</code></pre>
<p>What I'd like to do is to publish just the <code>[Result]</code> array.  What's the correct approach to this?  Should I use <code>.responseDecodable()</code> and create a new publisher (somehow - <code>.map()</code>?) that returns a <code>[Result].publisher</code>?</p>
<p>While I think I understand the reactive/stream based principles my Combine-fu is still weak and I don't have a clear handle on the transformation of one publisher into another (I'm guessing?)</p>
<p>Thanks in advance!</p>
","2431627","","2431627","","2022-05-26 16:22:37","2022-05-26 17:15:00","Transforming Alamofire response when using Codable and Combine","<swift><alamofire><combine>","1","1","","","","CC BY-SA 4.0"
"72398373","1","","","2022-05-26 21:47:39","","0","203","<p>I am trying to load data from two different endpoints using two different publishers which have different return types. I need to update the UI when both requests complete, but both requests can also fail so <code>Zip</code> doesn't do the trick. Usually I would use a <code>DispatchGroup</code> to accomplish this, but I have not figured out how to do that using Combine. Is there a way to use DispatchGroup with Combine?</p>
<pre><code>let dispatchGroup: DispatchGroup = .init()
let networkQueue: DispatchQueue = .init(label: &quot;network&quot;, cos: .userInitiated)

dispatchGroup.notify { print(&quot;work all done!&quot; }

publisher
    .receive(on: networkQueue, options: .init(group: dispatchGroup)
    .sink { ... }
    .receiveValue { ... }
    .store(in: &amp;cancellables)

publisher2
    .receive(on: networkQueue, options: .init(group: dispatchGroup)
    .sink { ... }
    .receiveValue { ... }
    .store(in: &amp;cancellables)
</code></pre>
<p>The notify is immediately executed. Is this not the right way of doing this?</p>
","1009085","","","","","2022-05-27 23:48:57","Executing 2 parallel network requests using Swift Combine","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"72407431","1","","","2022-05-27 15:04:57","","0","44","<p>I have a <code>@EnvironmentObject</code> for my <code>Model</code> where I handle the database changes and view state changes.</p>
<p>Then I have a <code>View</code> where I initialise a <code>@StateObject</code> for my <code>ApplePayModel</code>, this handles actual payment transactions.</p>
<p>Currently I have the transactions working however I want to call methods from my model, specifically a method <code>model.completePaymentTransaction</code> this then handles view changes and updates the database.</p>
<p>How can I call methods from <code>@EnvironmentObject</code> my when changes are made to the <code>@StateObject</code> ?</p>
<p>PS: I have considered putting all methods in model, but I want to separate code.</p>
<p><strong>CheckoutView</strong></p>
<pre><code>struct CheckoutView: View {
  @EnvironmentObject var model: Model
  @StateObject var applePayModel = ApplePayModel()

  var body: some View {
      if applePayModel.clientSecret != nil {
           Button(action: {
               //presentS apple pay window

               applePayModel.pay(payment: model.payment!)

           }, label: { EmptyView() } )
           .buttonStyle(PaymentButtonStyle())
      }
  }
}
</code></pre>
<p><strong>ApplePayModel</strong></p>
<pre><code>func applePayContext(_ context: STPApplePayContext, didCompleteWith status: STPPaymentStatus, error: Error?) {
    // get status error
    self.paymentStatus = status
    self.lastPaymentError = error
    
    switch paymentStatus {
        
    case .success:
        // complete payment in model by calling model.completePayment

    case error:
        print(&quot;error&quot;)
    case .userCancellation:
        print(&quot;user cancelled&quot;)
    case .none:
        print(&quot;none&quot;)

    }
}
</code></pre>
","4556409","","","","","2022-05-27 17:00:15","How to call methods on StateObject changes","<swift><swiftui><combine>","0","2","","","","CC BY-SA 4.0"
"72430252","1","72430345","","2022-05-30 06:58:00","","0","30","<p><code>DataResponse</code> is the object of Alamofire. It returns <code>Decodable</code> object and <code>Error</code> in success itself in .</p>
<p>Requirement is to pass on received <code>Decodable</code> object and <code>Error</code> separately. Is it feasible to transform <code>AnyPublisher&lt;DataResponse&lt;T, Error&gt;, Never&gt;</code> to <code>AnyPublisher&lt;T, Error&gt;</code>.</p>
<p>Consider <code>T</code> as any data type object.</p>
<pre><code>func fetchDataViaAlamofire(usingURl url: String) -&gt; AnyPublisher&lt;T, Error&gt; {
        return AF.request(url,
                          method: .get)
        .validate()
        .publishDecodable(type: T.self)
        .map { response in
            
            // ?
            // Cannot convert value of type 'DataResponse&lt;T?, AFError&gt;' to closure result type 'T'
            response.map { value in
                return response.value
            }
            
            // ?
            // Any way to convert AFError to Error in AnyPublisher&lt;T, Error&gt;
        }
        .receive(on: DispatchQueue.main)
        .eraseToAnyPublisher()
        
    }
</code></pre>
","3035317","","12299030","","2022-05-30 07:07:01","2022-05-30 07:07:01","How to convert AnyPublisher<DataResponse<T, Error>, Never> to AnyPublisher<T, Error>","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72444221","1","72444317","","2022-05-31 08:07:24","","0","250","<p>I have a <code>CurrentValueSubject</code> to hold data received from <code>Firebase</code> fetch request.</p>
<pre><code>final class CardRepository: ObservableObject {

    private let store = Firestore.firestore()
    var resultSubject = CurrentValueSubject&lt;[Card], Error&gt;([])
    init() {
    }
    
    func get() {
        store.collection(StorageCollection.EnglishCard.getPath)
            .addSnapshotListener { [unowned self] snapshot, err in
                if let err = err {
                    resultSubject.send(completion: .failure(err))
                }
                if let snapshot = snapshot {
                    let cards = snapshot.documents.compactMap {
                        try? $0.data(as: Card.self)
                    }
                    resultSubject.send(cards)
                }
            }
    }
}
</code></pre>
<p>In my ViewModel, I want whenever <code>resultSubject</code> sends or <code>emits</code> a <code>value</code>. It will change the <code>state</code> and has that <code>value</code> attached to the <code>succes</code> state.</p>
<pre><code>class CardViewModel: CardViewModelProtocol, ObservableObject {
    
    @Published var repository: CardRepository
    @Published private(set) var state: CardViewModelState = .loading
    private var cancellables: Set&lt;AnyCancellable&gt; = []

    required init (_ repository: CardRepository) {
        self.repository = repository
        bindingCards()
        
    }
    
    private func bindingCards() {
        let _ = repository.resultSubject
            .sink { [unowned self] comp in
                switch comp {
                case .failure(let err):
                    self.state = .failed(err: err)
                case .finished:
                    print(&quot;finised&quot;)
                }
            } receiveValue: { [unowned self] res in
                self.state = .success(cards: res)
            }

    }
    
    func add(_ card: Card) {
        repository.add(card)
    }
    
    func get() {
        repository.get()
    }

}
</code></pre>
<p>On my ContentView, it will display a button that <code>print</code> the <code>result</code>.</p>
<pre><code>struct ContentView: View {
    @StateObject var viewModel = CardViewModel(CardRepository())
    var body: some View {
        Group {
            switch viewModel.state {
            case .loading:
                ProgressView()
                Text(&quot;Loading&quot;)
            case .success(cards: let cards):
                let data = cards
                Button {
                    print(data)
                } label: {
                    Text(&quot;Tap to show cards&quot;)
                }
            case .failed(err: let err):
                Button {
                    print(err)
                } label: {
                    Text(&quot;Retry&quot;)
                }
            }
            Button {
                viewModel.get()
            } label: {
                Text(&quot;Retry&quot;)
            }
        }.onAppear {viewModel.get() }
    }
}

</code></pre>
<p>My problem is the block below only trigger once when I first bind it to the <code>resultSubject</code>.</p>
<pre><code>} receiveValue: { [unowned self] res in
                self.state = .success(cards: res)
            }
</code></pre>
<p>I did add a debug and  <code>resultSubject.send(cards)</code> works every time.</p>
","11390095","","11390095","","2022-06-01 03:06:59","2022-06-01 05:48:31","CurrentValueSubject send(value) doesn't trigger receiveValue","<swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"72453046","1","72453099","","2022-05-31 19:13:06","","0","94","<p>I want to do something from the model file when the app goes to the background, like stop the timer or something else. But when I run the app and check for the <code>scenePhase</code> value it returns <code>.background</code> while the app is in the foreground.</p>
<pre><code>import SwiftUI
import Combine

class Model {
    @Environment(\.scenePhase) var scenePhase
    var timerSubscription: AnyCancellable?
    init() {
        timerSubscription = Timer.publish(every: 1, on: .main, in: .common).autoconnect().sink { _ in
            if self.scenePhase == .background {
                // do something when the app goes to the background.
            }
            print(self.scenePhase) // print background while the app is in the foreground.
        }
    }
}

struct ContentView: View {
    var model = Model()
    var body: some View {
        Text(&quot;Hello, world!&quot;)
            .padding()
            
    }
}
</code></pre>
","16153605","","","","","2022-05-31 19:35:19","Why scenePhase value is .background while the app is in the foreground?","<swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"72469808","1","","","2022-06-02 01:54:15","","2","91","<pre><code>let p1: PassthroughSubject&lt;Int, Never&gt; = .init()
let p2: PassthroughSubject&lt;Bool, Never&gt; = .init()

var pub1: AnyPublisher&lt;Int, Never&gt; {
    return p1.eraseToAnyPublisher()
}

var pub2: AnyPublisher&lt;Bool, Never&gt; {
    return p2.eraseToAnyPublisher()
}

var sub: AnyCancellable?

sub = Publishers.CombineLatest(pub1, pub2).sink(receiveValue: { output in
    print(&quot;output: \(output)&quot;)
})

p1.send(4)
// nothing printed
p2.send(false)
// printed: output: (4, false)
</code></pre>
<p>why is there no output when p1 sends <code>4</code>? How should I structure the code such that when either p1 pr p2 sends a value, there is an output?</p>
","6181721","","","","","2022-06-03 19:07:08","CombineLatest multiple PassthroughSubject no output","<ios><swift><combine>","1","4","","","","CC BY-SA 4.0"
"72485945","1","72485957","","2022-06-03 07:12:31","","2","163","<p>I have a binding on my SwiftUI view</p>
<pre><code>@Binding var pinValue: String
</code></pre>
<p>I want to get update every time the value is changed. I tried below as I'd do on a <code>publisher</code> but I'm getting errors because it's not a <code>publisher</code>.</p>
<pre><code>.onReceive($pinValue, perform: { output in
            print(output)
        })
</code></pre>
<p>I've also tried to access <code>$pinValue.publisher</code> but the <code>.onReceive</code> block wont' work.</p>
<p>How can I get an update every time the value of <code>pinValue</code> is changed?</p>
","1563260","","","","","2022-06-23 04:37:21","Get value change update on Binding in SwiftUI","<swift><swiftui><combine>","1","0","","2022-06-23 06:28:55","","CC BY-SA 4.0"
"72501184","1","72501915","","2022-06-04 15:59:23","","0","281","<p>I have the following code that makes an API call, receives data and assigns it to Core Data managed objects. This works well, and updates my data.</p>
<pre><code>func importUsers(url: URL) {
    URLSession.shared.dataTaskPublisher(for: url)
        .map(\.data)
        .sink(receiveCompletion: { completion in
            if case .failure(let error) = completion {
                print(&quot;DataImporter.runImport failed with error: \(error)&quot;)
            }
        }, receiveValue: { [weak self] data in
            guard let self = self
            else { return }
            
            self.importContext.perform {
                do {
                    // 2. Decode the response. This decodes directly to the Core Data Store
                    let users = try self.decoder.decode([GitUser].self, from: data)
                    
                    try? self.importContext.save()
                } catch {
                    print(&quot;DataImporter.runImport failed to decode json with error: \(error)&quot;)
                }
            }
        })
        .store(in: &amp;self.cancellables) // store the returned cancellable in a property on `DataImporter`
}
</code></pre>
<p>However, I need to return the number of objects returned and decoded as a result of this call. If it fails, I return 0. Essentially, I want this:</p>
<pre><code>func importUsers(url: URL) -&gt; Int {
    URLSession.shared.dataTaskPublisher(for: url)
        .map(\.data)
        .sink(receiveCompletion: { completion in
            if case .failure(let error) = completion {
                print(&quot;DataImporter.runImport failed with error: \(error)&quot;)
            }
        }, receiveValue: { [weak self] data in
            guard let self = self
            else { return 0 }
            
            var users: [GitUser] = []
            self.importContext.perform {
                do {
                    // 2. Decode the response. This decodes directly to the Core Data Store
                    users = try self.decoder.decode([GitUser].self, from: data)
                    
                    try? self.importContext.save()
                } catch {
                    print(&quot;DataImporter.runImport failed to decode json with error: \(error)&quot;)
                }
            }
            return users.count
        }).store(in: &amp;self.cancellables) // error: Cannot convert return expression of type '()' to return type 'Int'
}
</code></pre>
<p>How do I return the count of objects received as a result of the network call?</p>
","7129318","","","","","2022-06-04 18:27:51","Swift Combine Return Int From URLSession.shared.dataTaskPublisher","<swift><combine>","1","7","","","","CC BY-SA 4.0"
"72526541","1","","","2022-06-07 06:02:28","","0","102","<p>I am coming from RxSwift and usually end up binding <code>PublishSubjects</code> together. I see that in <code>Combine</code> <code>PassthroughSubject</code> is the equivalent.</p>
<p>I have tried the following code:</p>
<pre><code>let passthroughSubject1 = PassthroughSubject&lt;Void, Never&gt;()
let passthroughSubject2 = PassthroughSubject&lt;Void, Never&gt;()

private func bindEvents() {
    passthroughSubject1
        .assign(to: \.passthroughSubject1, on: self)
        .store(in: &amp;cancellables)
}
</code></pre>
<p>However I get the error <code>Key path value type 'PassthroughSubject&lt;Void, Never&gt;' cannot be converted to contextual type 'Void'</code>.</p>
<p>Is there not a way to bind two subjects together in <code>Combine</code>?</p>
","4083744","","","","","2022-06-07 08:41:48","How do I bind/assign one PassthroughSubject to another?","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"72557548","1","","","2022-06-09 09:04:55","","2","261","<p>I wonder if there is an excellent document to show the difference between Combine and RxSwift?</p>
<p>It's good for me to quickly learn the <code>Combine</code> because I already had good knowledge about <code>RxSwift</code></p>
","10270556","","","","","2022-06-09 15:57:56","What is difference between Combine and RxSwift?","<rx-swift><combine>","1","2","","","","CC BY-SA 4.0"
"72571978","1","72572087","","2022-06-10 09:24:24","","0","151","<p>Hello i have an issue with the refresh of my view when i toggle a boolean.
Here is the code</p>
<pre><code>class MyItem: Identifiable {
   @Published var isActive: Bool
}

struct myView: View {
   @Binding var item: MyItem
   var body: some View {
      HStack {
         Toggle(&quot;&quot;, isOn: $item.isActive)
         Spacer()
         TextField(&quot;&quot;, text: item.isActive ? $text : .constant(&quot;&quot;)) { isFocused in
             guard !isFocused &amp;&amp; text.count == 0 else { return }
             item.isActive.toggle
         }
            .background(item.isActive ? Color.white : Color.clear)
      }
   }
}
</code></pre>
<p>when i lose my focus and run <code>item.isActive.toggle</code> it change correctly his value, but my <code>Toggle</code> and my <code>TextField</code> doesn't update their UI (the Toggle is still active and the background of the TextField is still white)</p>
<p>Any idea of what i am missing ?</p>
","3227545","","3227545","","2022-06-10 09:31:15","2022-06-10 09:33:50","Toggle a Boolean in a Binding object doesn't update UI","<ios><swift><swiftui><combine>","1","2","","","","CC BY-SA 4.0"
"72602568","1","72604247","","2022-06-13 12:07:00","","0","67","<p>I have a basic view controller subclass which contains a UIStackView and a UIButton. I want to run some code each time a view is added or removed from the stack view's <code>arrangedSubviews</code> array using Combine. Here's is my failed attempt to do this:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine
import UIKit

class ViewController: UIViewController {
    @IBOutlet var stackView: UIStackView!
    @IBOutlet var button: UIButton!

    var cancelables = Set&lt;AnyCancellable&gt;()

    override func viewDidLoad() {
        super.viewDidLoad()

        stackView.publisher(for: \.arrangedSubviews).sink { views in
            button.isEnabled = views.count &lt; 5
        }
        .store(in: &amp;cancelables)
    }

    @IBAction func addTapped(_ sender: UIButton) {
        let customView = CustomView()
        stackView.addArrangedSubview(customView)
    }
}
</code></pre>
<p>Each time I tap the button, a new view is added to the stack view, but the change to <code>arrangedSubviews</code> is not published, which doesn't trigger the code in the <code>sink</code> block. In the case above, the button is still enabled even if <code>arrangedSubviews.count</code> is more than 5.</p>
<p>How can I fix this so that I can correctly publish changes whenever a new view is added or removed from the <code>arrangedSubviews</code> array?</p>
<p>Thank you for any help.</p>
","10654098","","","","","2022-06-13 14:24:28","Combine publisher for changes to UIStackView's arrangedSubviews array","<ios><swift><uikit><combine>","1","4","","","","CC BY-SA 4.0"
"72606185","1","72606308","","2022-06-13 16:33:07","","1","32","<p>I am trying to pop a SwiftUI view upon a particular event from an observed object. How can I do this? This code does not work because I can't refer to <code>self</code> inside the <code>sink</code> method.</p>
<pre><code>struct MyView: View {
  @Environment(\.presentationMode) var presentationMode
  @ObservedObject var observable: MyObservable

  init() {
    observable.$state.sink { state in    // !! Escaping closure captures mutating 'self' parameter !!
      presentationMode.wrappedValue.dismiss()
    }
  }
}
</code></pre>
","64505","","","","","2022-06-13 16:44:11","SwiftUI pop view upon observable event","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"72609975","1","72611881","","2022-06-13 23:10:40","","2","276","<p>A typical way to chain AnyPublisher is to use Combine operators like flatMap.</p>
<pre class=""lang-swift prettyprint-override""><code>
class MyService {
    func getUserList() -&gt; AnyPublisher&lt;[User], Error&gt; {
        ....
    }

    func getPostList(user: User) -&gt; AnyPublisher&lt;[Post], Error&gt; {
        ...
    }
}

class ViewModel: ObserableObject {
    let service = MyService()
    
    @published var post: [Post] = []
    
    func fetchAllPostFromLastUser() {
        service.getUserList().flatMap { [weak self] users in
            if let user = users.last {
                return self.service.getPosts(user: user)
            } else {
                return Fail(error:APIError.emptyUsers).eraseToAnyPublisher()
            }
        }
        .sink { result in
            
        }
    }
}

</code></pre>
<p>Is there a more elegant way to use async/await, so the code can be similar like</p>
<pre class=""lang-swift prettyprint-override""><code>class ViewModel: ObserableObject {
    let service = MyService()
    
    @published var post: [Post] = []
    
    func fetchAllPostFromLastUser() {
        let users = await service.getUserList().somethingMagicToConvertPublisherToAsync()
        let posts = await service.getPostList(user: user.first).somethingMagicToConvertPublisherToAsync()
    }
}

</code></pre>
","1861935","","","","","2022-06-14 14:51:13","How to chain AnyPublisher with async/await in SwiftUI","<swiftui><async-await><combine>","1","1","","","","CC BY-SA 4.0"
"72626093","1","","","2022-06-15 04:57:08","","0","68","<p>I'm working on a word game, and I'm trying to dynamically generate puzzles based on arrays of random letters from a weighted set. What I have below works, but the word list I'm using is fairly limited (about 2300 words), and <em>it takes forever</em>. My last test went through over 1300 groups of possible words before it found one contained 5 matching words from the word list. I've tested it with a larger word set of 5700+ words, and can find a puzzle in an acceptable time frame.</p>
<p>The Question:</p>
<p>Is there a way to spin off several calls to <code>Puzzle.generate()</code> and return the result of the first one to finish? I've thought about placing several in a TaskGroup and then canceling when a result is returned, but the <code>while</code> loop makes it difficult to cancel the other tasks.</p>
<p>Here's psudo code for what I'd like to be able to do...</p>
<pre><code>func multiGenerate() async -&gt; Puzzle {

        // Maybe this needs to be withThrowingTaskGroup ? 
        return await withTaskGroup(of: Puzzle.self, body: { group in
            var puzzle: Puzzle!
            
            for _ in 0..&lt;5 {
                group.addTask {
                    // try Task.checkCancellation()
                    return await Puzzle.generate()
                }
            }
            
            for await result in group {
                group.cancelAll()
                puzzle = result
            }
            
            return puzzle
        })
        
    }
</code></pre>
<p>...and here's what I'm using to generate the puzzles</p>
<pre><code>struct Puzzle {
    let outerLetters: [String]
    let middleLetters: [String]
    let centerLetter: [String]
    let words: [String]
    var found = [String]()

    static func generate() async -&gt; Self {
            var outerLetters: [String]?
            var middleLetters: [String]?
            var centerLetter: [String]?
            var words: [String]?

            var count: Int = 0

            // If one of the other calls to `generate()` returns a result, how do I break out of this and cancel any remaining tasks?
            var finished = false
            while !finished {
                count += 1
                let outer = ContentView.ViewModel.randomizeAvailableLetters(tileArraySize: 16, from: ContentView.ViewModel.weightedOuter)
                let middle = ContentView.ViewModel.randomizeAvailableLetters(tileArraySize: 8, from: ContentView.ViewModel.weightedMiddle)
                let center = ContentView.ViewModel.randomizeAvailableLetters(tileArraySize: 1)
                
                
                let possibleWords: Set&lt;String&gt; = Set(await Puzzle.getWords(outer: outer, middle: middle, center: center))
                
                var actual = [String]()
                
                for word in possibleWords {
                    if ContentView.ViewModel.wordList.contains(word) {
                        actual.append(word)
                    }
                }
                
                finished = actual.count &gt;= 5
                
                if finished {
                    outerLetters = outer
                    middleLetters = middle
                    centerLetter = center
                    words = actual
                    print(&quot;Count: \(count)&quot;)
                }
                
            }
            
            guard let outer = outerLetters, let middle = middleLetters, let center = centerLetter, let words = words else {
                fatalError(&quot;You should not be here...&quot;)
            }
            
            return Puzzle(outerLetters: outer, middleLetters: middle, centerLetter: center, words: words)
        }

    static func getWords(outer: [String], middle: [String], center: [String]) async -&gt; [String] {

            @Sendable func getOuter(with middle: [String], outer: [String]) async -&gt; [String] {

                var possibleWords = [String]()

                // Construct some words...

                let result = await withTaskGroup(of: [String].self) { group -&gt; [String] in
                    var words = [String]()

                    for i in 0..&lt;middle.count {
                        group.addTask {
                            return getMiddle(with: middle, outer: outer)
                        }
                    }

                    for await word in group {
                        words.append(contentsOf: word)
                    }

                    return words
                    
                }

                possibleWords.append(contentsOf: result)

                return possibleWords
            }

            @Sendable func getMiddle(with middle: [String], outer: [String]) -&gt; [String] {

                var possibleWords = [String]()

                // Construct some more words...
                
                return possibleWords
            }

            return await withTaskGroup(of: [String].self) { group in
                var possibleWords = [String]()

                for i in 0..&lt;outer.count {
                    group.addTask {
                        return await getOuter(with: middle, outer: outer)
                    }
                }

                for await words in group {
                    possibleWords.append(contentsOf: words)
                }

                return possibleWords
            }
            
        }
}
</code></pre>
","862224","","12299030","","2022-06-15 05:14:43","2022-06-15 05:14:43","Is it possible to get the result of the first Task in a group to finish and cancel the rest?","<ios><swift><combine>","0","6","","","","CC BY-SA 4.0"
"72628850","1","","","2022-06-15 09:20:51","","4","102","<p>Up to now I've been using <code>Combine</code> and the PointFree TestSchedulers <a href=""https://github.com/pointfreeco/combine-schedulers"" rel=""nofollow noreferrer"">https://github.com/pointfreeco/combine-schedulers</a> to &quot;control time&quot; in my tests.</p>
<p>I can make a request and then assert values at certain points in the process without any trouble.</p>
<p>Example...</p>
<pre><code>func testFetchContentSuccess() {
    let queue = TestSchedulerOf&lt;DispatchQueue&gt;(now: .init(.now()))

    let sut = sut(queue: queue.eraseToAnyScheduler())

    XCTAssertEqual(sut.content, .notAsked)

    sut.fetchContent()

    XCTAssertEqual(sut.content, .loading) // this would be impossible without a TestScheulder as the mock endpoint would return immediately.

    queue.advance() // this is what I'm looking for from async await

    assertSnapshot(matching: sut.content, as: .dump)
}
</code></pre>
<p>Is there a way to do something similar with async await?</p>
","421018","","","","","2022-08-03 16:27:20","Controlling time with async await in Swift","<swift><async-await><combine>","1","0","","","","CC BY-SA 4.0"
"72630551","1","72630806","","2022-06-15 11:30:07","","0","58","<p>Hello 👋🏼 I had spend over 10 hour to implement <code>Combine</code> framework but can't clear understanding how to link <code>Publisher</code> and <code>Subscriber</code>. In example I just wanna call <code>setTheme</code> funk from <code>Theme</code> class and automatically update <code>game</code> variable in <code>Game</code> class. I know how to achieve it with <code>didSet</code> but main goal to make it with <code>Combine</code>. Would be thankfull for help.</p>
<pre><code>import SwiftUI
import Combine
import Foundation

class Theme: ObservableObject {
    
    @Published private(set) var choosenTheme: Color? // Publisher right?
    
    func setTheme(with color: Color?) {
        if let unwrappedColor = color {
            self.choosenTheme = unwrappedColor
        } else {
            self.choosenTheme = nil
        }
    }
}

class Game: ObservableObject {
    
    @Published var game: String? // Subscriber right?
    private let gameTheme = Theme()
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        addSubscribers()
    }
    
    private func addSubscribers() { // I think something wrong here
        gameTheme.$choosenTheme
            .map(createGame)
            .sink { [weak self] (returnedString) in
                print(&quot;Value from sink \(String(describing: returnedString))&quot;)
                self?.game = returnedString
            }
            .store(in: &amp;cancellables)
    }
    
    private func createGame(for theme: Color?) -&gt; String? {
       if let unwrappedTheme = theme {
           print(unwrappedTheme)
           return String(&quot;\(unwrappedTheme)&quot;)
       } else {
           return nil
       }
   }
}

// Test:
var testTheme = Theme()
testTheme.setTheme(with: .orange)

var testGame = Game()
print(testGame.game) // Should be Orange

testTheme.setTheme(with: .blue)
print(testGame.game) // Should be Blue

testTheme.setTheme(with: nil)
print(testGame.game) // Should be nil
</code></pre>
","14737138","","","","","2022-06-15 11:46:29","Data flow with Combine in SwiftUI","<swift><swiftui><combine>","2","5","","","","CC BY-SA 4.0"
"72634192","1","72634478","","2022-06-15 15:39:16","","1","129","<p>I'm trying to understand how to chain and then recombine one-to-many network queries using Combine.</p>
<p>I have an initial request that retrieves some JSON data, decodes it and maps that to a list of IDs:</p>
<pre class=""lang-swift prettyprint-override""><code>let _ = URLSession.shared
    .dataTaskPublisher(for: url)
    .receive(on: apiQueue)
    .map(\.data)
    .decode(type: MyMainResultType.self, decoder: JSONDecoder())
    .map { $0.results.map { $0.id } } // 'results' is a struct containing 'id', among others
    // .sink() and .store() omitted
</code></pre>
<p>This gives me the expected array of ints: <code>[123, 456, ...]</code></p>
<p>For each of the ints I'd like to start another request that queries another endpoint using that ID as a parameter, retrieves some JSON, extracts an appropriate piece of data and then recombines that with the ID to give me a final list of <code>[(id, otherData), ...]</code>.</p>
<p>The second request is working as a function in isolation, with its own <code>sink()</code> and <code>store()</code>, and also as an <code>AnyPublisher&lt;&gt;</code>.</p>
<p>I've tried any number of <code>map { Publishers.Sequence ...}</code>, <code>.flatMap()</code>, <code>.combine()</code> etc. but think that maybe my mental model of what's happening is incorrect.</p>
<p>What I think I should be doing is <code>map()</code> each int to the secondary details request publisher, then doing a <code>flatMap()</code> to get back a single publisher, and <code>collect()</code>ing all the results, possibly with another map to bring in the ID, but nothing seems to give me a simple list, as described above, at the end.</p>
<p>How can I take my list of ints and spawn a number of further requests, waiting until all of them have completed, and then reassemble the id and the additional info into a single Combine chain?</p>
<p>TIA!</p>
","2431627","","","","","2022-06-15 16:01:04","Combine: how to chain and then recombine one-to-many network queries","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72634317","1","","","2022-06-15 15:48:44","","3","243","<p>It is the first time for me working with AppKit and a <code>NSTableView</code>. It is backed by a <code>NSFetchedResultsController</code> for Core Data. When there are changes to the dataset, a <code>Notification</code> is being sent:</p>
<pre class=""lang-swift prettyprint-override""><code>func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) {
    guard let links = self.fetchedResultsController.fetchedObjects else {
        return
    }

    if self.viewContext.hasChanges {
        try? self.viewContext.save()
    }
        
    self._links = links
    NotificationCenter.default.post(name: .reloadLinkList, object: nil)
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>NotificationCenter.default.publisher(for: .reloadLinkList).receive(on: RunLoop.main).sink { notification in
    self.list.tableView.reloadData()
    self.list.linksModel.selectedRows = IndexSet([])
}
.store(in: &amp;cancellables)
</code></pre>
<p>This works great for inserting and updating data. When I try to delete something, I get:</p>
<pre><code>Thread 1: Fatal error: UnsafeRawBufferPointer with negative count
</code></pre>
<p>The code for deleting selected objects looks as following:</p>
<pre class=""lang-swift prettyprint-override""><code>// selector methode for UIMenuItem`s action
@objc func onDeleteSelectedLinks(_ sender: AnyObject) {
    list.linksModel.deleteLinks(links: selectedLinks)
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>// Method for deleting links from the view context
func deleteLinks(links: [LBLink]) {
    for link in links {
        self.viewContext.delete(link)
    }
}
</code></pre>
<p>Thank you for any help in advance!</p>
","19346019","","4244136","","2022-06-15 21:11:28","2022-06-22 12:02:54","Fatal error: UnsafeRawBufferPointer with negative count on deleting object(s) from Core Data/NSFetchedResultsController","<swift><macos><nsfetchedresultscontroller><combine><appkit>","0","0","","","","CC BY-SA 4.0"
"72634444","1","72634941","","2022-06-15 15:58:42","","0","261","<p>I have an enum in my project:</p>
<pre><code>enum Remote&lt;Content&gt; {
  case .notAsked
  case .loading
  case .loaded(Content)
  case .failed(Error)
}
</code></pre>
<p>I then have a class:</p>
<pre><code>class MyViewModel: ObservableObject {
  @Published var content: Remote&lt;ContentStruct&gt; = .notAsked

  func fetchContent() {
    content = .loading

    service.fetchContent()
      .receive(on: queue)
      .map(Remote&lt;ContentStruct&gt;.loaded)
      .catch { error in Just(.failed(error)) }
      .assign(to: &amp;self.content)
  }
}
</code></pre>
<p>But this complains to me that:</p>
<pre><code>Cannot convert value of type 'Remote&lt;ContentStruct&gt;' to expected argument type 'Published&lt;Remote&lt;ContentStruct&gt;&gt;.Publisher'
</code></pre>
<p>I can change it to use this:</p>
<pre><code>func fetchContent() {
  content = .loading

  service.fetchContent()
    .receive(on: queue)
    .map(Remote&lt;ContentStruct&gt;.loaded)
    .catch { error in Just(.failed(error)) }
    .assign(to: \.content, on: self)
    .store(in: &amp;cancellables)
}
</code></pre>
<p>And this works and assigns the value correctly. But I don't understand why I can't use the <code>.assign(to: keyPath)</code> function on there?</p>
<p>Do I need to do something different? We've only recently updated to support a minimum of iOS14 and so not been using <code>assign(to:</code> before due to memory leaks and now I'm just not sure how this is working.</p>
<p>Thanks</p>
","421018","","421018","","2022-06-15 16:22:15","2022-06-15 16:38:07","Combine assign(to:) with a @Published var","<swift><combine>","1","3","","","","CC BY-SA 4.0"
"72644516","1","","","2022-06-16 10:40:10","","0","81","<p>I have a model that is a group of <code>NSMutableAttributedString</code>s. Well currently it's a wrapper of a <code>MyString</code> class. Each string manages it's own attributes/state.</p>
<pre class=""lang-swift prettyprint-override""><code>typealias NSAttrStringAttr = [NSAttributedString.Key: Any]
typealias MyStringAttribute = (NSAttrStringAttr, NSRange)
class MyString: ObservableObject {
  var attributedString: NSMutableAttributedString
  @Published var attributes: [MyStringAttribute] = []

  init(string: String) {
    self.attributedString = NSMutableAttributedString(string: string)
  }
}

</code></pre>
<p>The main reason for this is so that I can expose changes in the <code>NSAttributedString</code>s attributes, as follows:</p>
<pre class=""lang-swift prettyprint-override""><code>extension MyString {
  func updateAttributes() {
    self.attributes = []
    let range = NSMakeRange(0, self.attributedString.length - 1)
    attributedString.enumerateAttributes(in: range, using: {(attrs, range, _) in
      self.attributes.append((attrs, range))
    })
  }

  func addAttribute(_ name: NSAttributedString.Key, value: Any, range: NSRange) {
    attributedString.addAttribute(name, value: value, range: range)
    updateAttributes()
  }

  func addAttributes(_ attrs: [NSAttributedString.Key : Any] = [:], range: NSRange) {
    attributedString.addAttributes(attrs, range: range)
    updateAttributes()
  }
}
</code></pre>
<pre class=""lang-swift prettyprint-override""><code>class MyStringGroup {
  private var: strings: [MyString] = []
  var _attributedString: NSMutableAttributedString
  var attributedString {
    get {
      if let str = _attributedString {
        return str
      } else {
        var newAString = NSMutableAttributedString(string: &quot;&quot;)
        strings.forEach { self.newAString.append($0.attributedString) }
        _attributedString = newAString
      }
    }
  }
  var cancellable = Set&lt;AnyCancellable&gt;()

  func append(_ string: MyString) {
    string.$attributes.sink(receiveValue: { _ in
      // Handle rewriting portion of NSAttributedString based on substring update
    }).store(in: &amp;cancellable)
    strings.append(string
  }

  func someStringUpdate(..., range: NSRange) {
    let str = strings.findRightString(range: range)
    str.someStringUpdate(..., range: offsetRangeForString(str, range: range))
  }
}
</code></pre>
<p>The main reason for this is that strings are linked with strings outside of the text, and they update certain attributes based on user action, responses from the server, etc. The reason for wrapping <code>NSAttributedString</code> is so that the logic for managing string attributes, and their connection to the other text can be managed separately of the entire text, and <code>MyStringGroup</code> needs to know if a <code>MyString</code> instance has updated its attributes so that it can re-render. I have been trying to use the reactive pattern of <code>Combine</code>, but can't find anyway to natively listen to <code>attribute</code> changes in <code>NSAttributedString</code>, as the only way to access attributes is via function <code>attributes(at:effectiveRange:)</code> and <code>enumerateAttributes(in:using:)</code>, so currently I'm stuck with wrapping. Is there a better way to propagates changes in the substring/sentence <code>NSAttributedString</code> without having to wrap it and rewrite all it's methods?</p>
","3968048","","","","","2022-06-17 16:53:14","What's the best way to listen to NSAttributedString attribute changes in Combine?","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"72660391","1","","","2022-06-17 13:45:33","","2","95","<p>working on backward compatibility for an macOS App that does not make use of SwiftUI but makes use of <code>Combine</code> Framework feature <strong><code>@Published</code></strong> declarations that is also not available in this particular targeted System and also not in this Swift version. The feature set that Combine offers is mimicked with <code>OpenCombine</code> <a href=""https://github.com/OpenCombine/OpenCombine"" rel=""nofollow noreferrer"">see Github</a> framework and seems to work. But @Published declarations are not available (yet).</p>
<p>As this Swift <strong><code>@Published</code></strong> directive can't be expressed in code how could i (hopefully) declare such feature instead?</p>
<p>My thought is i could make use of the <code>@propertyWrapper</code> feature instead and implement some extra function to make it work..</p>
<p>for discussion.. <br> in the <code>OpenCombine.ObservableObject</code> aka <code>ObservableObject</code> is some property</p>
<pre class=""lang-swift prettyprint-override""><code>import OpenCombine
class SomeObservableClass : OpenCombine.ObservableObject {
    @Published var highlighted = false //where @Published feature is not available
}
</code></pre>
<p>and on the other side in a NSView subclass</p>
<pre class=""lang-swift prettyprint-override""><code>import OpenCombine
class SomeViewController: NSViewController {
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    override var representedObject: Any? {
        didSet {
            guard let observedObject = representedObject as? SomeObservableClass,
                  isViewLoaded else { return }
            observedObject.$highlighted
                .receive(on: DispatchQueue.main)
                .sink { [weak self] newValue in
                    self?.overlayView.needsDisplay = true
                }
                .store(in: &amp;cancellables)
        }
    }
}
</code></pre>
<p>and the following looks promising to me, at least it would allow to mimic &quot;@Published&quot; directive manually in some way. The propertyWrapper i would place in <code>#if .. #endif</code> marks to be able to have the same codebase for Swift that supports Combine &amp; @Published features then</p>
<pre class=""lang-swift prettyprint-override""><code>@propertyWrapper
struct Published&lt;T&gt; {
    var wrappedValue: T {
        willSet { /*...*/ }
        didSet { /*...*/ }
    }
    init(wrappedValue: T) {
        
        // * -- maybe magic here! -- */
        
        /* or do more specific stuff.. ^^
        switch (wrappedValue) {
        //case is Optional&lt;Any&gt;.Type :
            //break
        case is Bool :
            break
        case is Error :
            break
        case is Optional&lt;Error&gt;.Type :
            break
        default: break
        }
        */
        self.wrappedValue = wrappedValue
    }

}
</code></pre>
<p>Reminder: <strong>Combine</strong> is an Apple Framework that is heavily used in the <strong>SwiftUI</strong> Framework but of course also available without. So targeting SwiftUI solutions are not really desired as thats the whole point to be able to use the &quot;Combine-Design-pattern&quot; without SwiftUI. <a href=""https://github.com/OpenCombine/OpenCombine/issues/235"" rel=""nofollow noreferrer"">link to Github issue i opened</a></p>
<p>Reminder2: we also have preprocessor directives like <code>#if !canImport(Combine)</code> or similar to limit where it would be allowed to be applied</p>
<p>EDIT1: very likely my issue can also be some troubleing <code>typealias</code> rule. Because <br> <code>typealias Published = OpenCombine.Published</code> fixed the propertywrapper issue, instead i am facing the following</p>
<pre class=""lang-swift prettyprint-override""><code>observedObject.$highlighted
    .receive(on: DispatchQueue.main) //&lt;---- Argument type 'DispatchQueue' does not conform to expected type 'Scheduler'
    .sink { [weak self] newValue in
        self?.overlayView.needsDisplay = true
    }
    .store(in: &amp;cancellables)
</code></pre>
<p>likewise <code>typealias Scheduler = OpenCombine.Scheduler</code> did not fix that as i assumed.</p>
","1443038","","1443038","","2022-06-17 20:05:57","2022-06-17 22:05:36","Declare property like @Publisher in swift version that doesnt support this feature using OpenCombine Framework","<swift><macos><combine><xcode11.3>","1","6","","","","CC BY-SA 4.0"
"72676462","1","73543797","","2022-06-19 11:24:22","","-1","92","<p>I'm working on a project where I need to listen to any changes in an array of objects. By changes I refer:</p>
<ol>
<li>Add/Remove element in the array</li>
<li>Any change in the existing array elements</li>
</ol>
<p>Here is the sample code,</p>
<pre><code>enum DownloadState {
    case queued
    case completed
}

class DownloadTask: ObservableObject {
    var downloadState: DownloadState = .queued
}

class DownloadManager {
    var downloadTasks = [DownloadTask]()
}
</code></pre>
<p>In the above code, <code>DownloadManager</code> contains an array of <code>DownloadTask</code>. I want to listen to the changes when,</p>
<ol>
<li>A new <code>DownloadTask</code> instance is added into <code>downloadTasks</code> array</li>
<li>An existing <code>DownloadTask</code> instance is removed from <code>downloadTasks</code> array</li>
<li>The underlying <code>DownloadState</code> is changed for a particular <code>DownloadTask</code> in <code>downloadTasks</code> array</li>
</ol>
","5716829","","","","","2022-08-30 14:04:24","Listening to updates in an Array of Objects in Swift","<ios><arrays><swift><combine>","2","0","","","","CC BY-SA 4.0"
"72685846","1","","","2022-06-20 10:41:49","","0","133","<p>Can we bring down Combine <code>values</code> to iOS 14? (Currently, it supports only iOS 15), so we can bridge Combine to asyn/await. For example</p>
<pre class=""lang-swift prettyprint-override""><code>let publisher = [1, 2, 3, 4, 5]
  .publisher
  .delay(for: .seconds(3), scheduler: RunLoop.main)
  .eraseToAnyPublisher()

for await value in publisher.values {
  print(Date())
  print(value)
}
</code></pre>
","1861935","","","","","2022-06-21 18:38:05","'values' is only available in iOS 15.0 or newer in Combine","<swift><async-await><combine>","1","0","","","","CC BY-SA 4.0"
"72689736","1","","","2022-06-20 15:48:44","","0","67","<p>Crashlytics states that there is a crash when updating the object var.The error is <em>outlined consume of ObjectValue</em>, from the add listeners func.</p>
<p>ObjectValue is a struct.</p>
<p><em>object</em> is also updated from two other places. Is it possible that the updating in the combine call is unsafe (one places is accessing the memory while another place is changing its value)? How can I fix that?</p>
<pre><code>var object: ObjectValue? = nil {
                didSet {
                    guard oldValue != self.object else {
                        self.isLoading = false
                        return
                    }
                    self.prepareData()
                }
            }
    
override func addListeners() {
        self.manager.objectValue.$value
           .receive(on: RunLoop.main)
           .sink { [weak self] objectValue in
               guard self?.isDetailView == false else { return }
               self?.object = objectValue
           }
           .store(in: &amp;cancellables)
    }
</code></pre>
","6660789","","11287363","","2022-06-21 13:06:27","2022-06-21 13:06:27","Outlined consume of object crash in Combine receive func","<swift><multithreading><race-condition><combine>","0","1","","","","CC BY-SA 4.0"
"72714686","1","","","2022-06-22 11:28:52","","0","90","<p>Been away from the swift-ing for a good 3 years now.
Getting back into it now and trying to learn Combine and SwiftUI.</p>
<p>Making a test Workout app.
Add an exercise, record reps and weights for 3 sets.
Save data.</p>
<p>I'm having issues moving some data around from views to data store.
I think I'm confusing all the different property wrappers.
Summary at the bottom after code.</p>
<p>App:</p>
<pre><code>@main
struct TestApp: App {
  @StateObject private var store = ExerciseStore()

    var body: some Scene {
        WindowGroup {
            ContentView()
              .environmentObject(store)
        }
    }
}
</code></pre>
<p>Views:</p>
<pre><code>struct ContentView: View {
  @EnvironmentObject var store: ExerciseStore

    var body: some View {
      List {
          ForEach($store.completedExercises) { $exercise in
            ExerciseView(exercise: $exercise)
          }
      }
    }
}
</code></pre>
<pre><code>struct ExerciseView: View {
  @Binding var exercise: CompletedExercise

    var body: some View {
      VStack {
        Text(exercise.exercise.name)
        SetView(set: $exercise.sets[0])
        SetView(set: $exercise.sets[1])
        SetView(set: $exercise.sets[2])
      }
    }
}
</code></pre>
<pre><code>struct SetView: View {
  @Binding var set: ExerciseSet

    var body: some View {
      HStack {
          TextField(
            &quot;Reps&quot;,
            value: $set.reps,
            formatter: NumberFormatter()
          )
          TextField(
            &quot;Weight&quot;,
            value: $set.weight,
            formatter: NumberFormatter()
          )
      }
    }
}
</code></pre>
<p>Store:</p>
<pre><code>class ExerciseStore: ObservableObject {
  @Published var completedExercises: [CompletedExercise] = [CompletedExercise(Exercise())]

  init() {
    if let data = UserDefaults.standard.data(forKey: &quot;CompletedExercise&quot;) {
      if let decoded = try? JSONDecoder().decode([CompletedExercise].self, from: data) {
        completedExercises = decoded
        return
      }
    }
  }

  func save() {
      if let encoded = try? JSONEncoder().encode(completedExercises) {
          UserDefaults.standard.set(encoded, forKey: &quot;CompletedExercise&quot;)
      }
  }
}
</code></pre>
<p>Models:</p>
<pre><code>class CompletedExercise: Codable, Identifiable, ObservableObject {
  var id = UUID().uuidString
  var exercise: Exercise
  @Published var sets = [
    ExerciseSet(),
    ExerciseSet(),
    ExerciseSet()
  ]

  init(exercise: Exercise) {
    self.exercise = exercise
  }

  required init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)

    id = try container.decode(String.self, forKey: .id)
    exercise = try container.decode(Exercise.self, forKey: .exercise)
    sets = try container.decode([ExerciseSet].self, forKey: .sets)
  }

  func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)

      try container.encode(id, forKey: .id)
      try container.encode(exercise, forKey: .exercise)
      try container.encode(sets, forKey: .sets)
  }
}

private enum CodingKeys: CodingKey {
    case id, exercise, sets
}
</code></pre>
<pre><code>struct Exercise: Codable, Identifiable {
  var id = -1
  var name = &quot;Bench Press&quot;
}
</code></pre>
<pre><code>class ExerciseSet: Codable, ObservableObject {
  @Published var reps: Int?
  @Published var weight: Int?

  init() {}

  required init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)

    reps = try container.decodeIfPresent(Int.self, forKey: .reps)
    weight = try container.decodeIfPresent(Int.self, forKey: .weight)
  }

  func encode(to encoder: Encoder) throws {
      var container = encoder.container(keyedBy: CodingKeys.self)

      try container.encode(reps, forKey: .reps)
      try container.encode(weight, forKey: .weight)
  }
}

private enum CodingKeys: CodingKey {
    case reps, weight
}
</code></pre>
<p>Thats more or less the current code.
I've added a bunch of print statements in the save function in <code>ExerciseStore</code> to see what gets saved.
No matter what I've tried, I can't get the reps/weight via the <code>SetView</code> text fields to persist through the <code>ExerciseStore</code> and get saved.</p>
<p>I've played around with @Binding and such as well but can't get it working.</p>
<p>What am I missing/messing up with the new SwiftUI data flows.</p>
","16142366","","16142366","","2022-06-23 12:26:38","2022-06-23 12:26:38","SwiftUI Combine Data Flow","<swift><swiftui><combine>","3","0","","","","CC BY-SA 4.0"
"72734648","1","","","2022-06-23 17:59:45","","3","72","<p>I am seeing a very odd behavior in Publishers.CombineLatest related to demand management. In my code I have created a custom .withLatestFrom operator which manages backpressure by limiting upstream demand.</p>
<p>I am running in a situation where <code>Publishers.CombineLatest</code> propagates demand only to the 2nd publisher (latest2) but not to the first one (latest1).</p>
<p>What do you think? Is this a bug in CombineLatest - or do any of you see another reason why this might happen? I am not sure if miss anything, but to me it looks like quite a serious bug in a very common operator?</p>
<p>I am a bit puzzled - as this situation is currently stopping a publisher chain in my app...</p>
<p>Here is a test case (I have simplified it from my previous post and taken out any non-standard code):</p>
<pre><code>func testCombineLatest() {
    
    let latest1 = PassthroughSubject&lt;Int,Never&gt;()
    let latest2 = PassthroughSubject&lt;Int,Never&gt;()
    
    var result:[[Int]] = []
    var subscription:Subscription?
    
    let subscriber = AnySubscriber&lt;(Int,Int),Never&gt;(
        receiveSubscription: {sub in
            subscription = sub
            sub.request(.max(1))
        },
        receiveValue: { (v1,v2) in
            result.append([v1,v2])
            return .max(1)
        },
        receiveCompletion: {_ in}
    )
    
    let publisher = Publishers.CombineLatest(latest1.print(&quot;Latest1&quot;), latest2.print(&quot;Latest2&quot;))
        .print(&quot;CombineLatest&quot;)
    
    publisher
        .subscribe(subscriber)
    
    latest1.send(1)
    latest2.send(1)
    latest1.send(2) //&lt;- This has no effect.
    latest2.send(2)
    
    latest1.send(completion: .finished)
    latest2.send(completion: .finished)
    
    print(&quot;Result is:\(result)&quot;)
    
    XCTAssertEqual(result, [[1,1], [2,1], [2,2] ])

}
</code></pre>
<p>And here ist the output from the test run:</p>
<pre><code>Test Case '-[CAPTests.CAPTestPublisherExtensions testCombineLatest]' started.
Latest1: receive subscription: (PassthroughSubject)
Latest2: receive subscription: (PassthroughSubject)
CombineLatest: receive subscription: (CombineLatest)
CombineLatest: request max: (1)
Latest1: request max: (1)
Latest2: request max: (1)
Latest1: receive value: (1)
Latest2: receive value: (1)
CombineLatest: receive value: ((1, 1))
CombineLatest: request max: (1) (synchronous)
Latest2: request max: (1) (synchronous)
Latest2: receive value: (2)
CombineLatest: receive value: ((1, 2))
CombineLatest: request max: (1) (synchronous)
Latest2: request max: (1) (synchronous)
Latest1: receive finished
Latest2: receive finished
CombineLatest: receive finished
Result is:[[1, 1], [1, 2]]
error: -[CAPTests.CAPTestPublisherExtensions testCombineLatest] : XCTAssertEqual failed: (&quot;[[1, 1], [1, 2]]&quot;) is not equal to (&quot;[[1, 1], [2, 1], [2, 2]]&quot;)
</code></pre>
","10851991","","10851991","","2022-06-24 14:31:06","2022-06-24 14:31:06","Does Swift.Combine Publishers.CombineLatest have a bug handling back pressure correctly? (demand from downstream)","<swift><combine>","0","0","","","","CC BY-SA 4.0"
"72792881","1","72803557","","2022-06-28 20:36:22","","0","80","<p>I have a function that that builds several Publishers and returns them all in a single Publisher with MergeMany. The problem is that some users might have a LOT of endpoints in this publisher, and hitting all these endpoints at once frequently results in server timeouts. Is there a way to limit the concurrent network requests (like DispatchSemaphore) in Combine?</p>
<pre><code>let mergedPubs = Publishers.MergeMany(urlRequests.map { dataTaskPublisher(for: $0)
            .decode(type: RawJSON.self, decoder: JSONDecoder())
            .mapError { _ in
                return URLError(URLError.Code.badServerResponse)
            }
    })
        .collect()
        .eraseToAnyPublisher()
</code></pre>
","1349972","","","","","2022-06-29 17:41:08","Swift Combine MergeMany Publishers","<swift><networking><combine>","1","0","","","","CC BY-SA 4.0"
"72801416","1","72801518","","2022-06-29 12:25:12","","-2","44","<p>I've just started learning Combine and am quite confused with behaviour of KVO publishers. They just do not publish any events except for the initial value.
Here is the sample code I used:</p>
<pre><code>@objc class SampleClass: NSObject {
    @objc var name: NSString = &quot;1&quot;
}

var a = SampleClass()

let kvoPublisher = a.publisher(for: \.name)
    .sink(receiveCompletion: {
        print(&quot;completion \($0)&quot;)
    }, receiveValue: { newVal in
        print(&quot;new val - \(newVal)&quot;)
    })

a.name = &quot;2&quot;
a.name = &quot;3&quot;

print(&quot;Finished; publisher = \(kvoPublisher) | a.name = \(a.name)&quot;)
</code></pre>
<p>The console output is</p>
<pre><code>new val - 1
Finished; publisher = Combine.AnyCancellable | a.name = 3
</code></pre>
<p>Could you please explain what am I missing here and how to fix it?</p>
<p>Thanks.</p>
","7592330","","","","","2022-06-29 12:54:09","KVO publisher does not send signal on property change","<swift><reactive-programming><combine><key-value-observing>","1","0","","","","CC BY-SA 4.0"
"72807061","1","","","2022-06-29 19:48:22","","0","54","<p>I have been trying to load some data from a backend server and it comes in page size of 10 elements per page.</p>
<p>I am using combine and the issue is i am getting back videos and images from the server as well.</p>
<p>How do i load them properly? I have tried adding reloading functionality but it all just slows down the app massively. This is my code right now:</p>
<pre><code>class ProductDataService: ObservableObject {

    @Published var count = 1
    @Published var countPage = 0
    
    @Published var allProducts: [ListedItem] = []

    var productSubscription: AnyCancellable?

    init() {
        getProducts()
    }
    func getProducts() {
          guard let url = URL(string: &quot;myBackendURL-api/product/?page=\(count)&quot;) else{return}
        
        
        productSubscription = NetworkingManager.download(url: url)
            .decode(type: Product.self, decoder: JSONDecoder())
            .sink(receiveCompletion: NetworkingManager.handleCompletion, receiveValue: { [weak self] returnedProducts in
                self?.allProducts = returnedProducts.results
                self?.countPage = returnedProducts.count
                self?.nextPageView = returnedProducts.next
                self?.productSubscription?.cancel()
            })
    }
}
</code></pre>
<p>i would add the code for networking manager below as well, it's nothing unsual tho</p>
<p>my backend returns a json like this:</p>
<pre><code>&quot;count&quot;: 33,
    &quot;next&quot;: &quot;http://backend/product/?page=2&quot;,
    &quot;previous&quot;: null,
    &quot;results&quot;: [
        {
            &quot;id&quot;: 79,
            &quot;productName&quot;: &quot;Mango&quot;,
            &quot;producDescription&quot;: &quot;Banana&quot;,
            &quot;product_image1&quot;: &quot;https:something.png&quot;,

        },
</code></pre>
<p>For now I tried using the next parameter in every call to replace with the url property of my function but couldn't do it properly.</p>
<p>Right now am using the count of the total products and then inside my home view model i use:</p>
<pre><code>    private let dataService = ProductDataService()
    
    private var cancellables = Set&lt;AnyCancellable&gt;()
    @Published var allProducts: [ListedItem] = []
    @Published var tempArray: [ListedItem] = [] // listeditem is one product
    
    init() {
        addSubscribers()
    }
    
    func addSubscribers() {
        dataService.$allProducts
            .sink { [weak self] (returnedProducts) in
                self?.allProducts += returnedProducts    
            }
            .store(in: &amp;cancellables)
    }
</code></pre>
<p>And then i use a scrollview reader to read if the person reached the end of the screen to load more items.</p>
<p>I call this function from my view:</p>
<pre><code>func loadMoreData() {
        if allProducts.count &lt; dataService.countPage {
            if dataService.count &lt; Int(dataService.countPage/10) {
                print(&quot;our comparing value is \(Int(dataService.countPage/10))&quot;)
                dataService.count += 1
                dataService.getProducts()
            }
            else {
                dataService.count -= 1

            }
           
            print(&quot;value of count is : \(dataService.count)&quot;)
            
        }
    else {
        print(&quot;our product count is more &quot;)
    }
}
</code></pre>
<p>But it doesn't work exactly how i want it to be.</p>
<ul>
<li>First it just skips page 2 idk why and directly loads page 3 items. and now i have 33 items that is till page no. 4 but it never goes there due to my checks tho i can write +1 in my if conditon and it would work but still</li>
<li>It also hangs the screen for 2 secs when loading.</li>
<li>How do i show some progress view at that moment?</li>
<li>Where do i but the boolean for that?</li>
<li>Also is there a better way to load items from a GET Api rather than this?</li>
</ul>
<p>Now I would add my image problem:</p>
<p>Now inside my product image view am dealing with videos and images like this:</p>
<pre><code>var body: some View {
    if vm.image != nil {
        if let image = vm.image {
            Image(uiImage: image)

        }
        else if vm.isloading {
            ProgressView()
        }

    }
    else if let stringUrl = Optional(vm.product.product_image1) {
        ZStack {
            customVideoPlayer(player: player)
                .onAppear {
                    player.isMuted = isVideoMuted
                    if player.currentItem == nil {
                        let item = AVPlayerItem(url: URL(string: stringUrl) !)
                        player.replaceCurrentItem(with: item)

                    }
                }
        }
    }
}
</code></pre>
<p>The issue here is that before loading any image it takes in the frame of a video. And then it loads as an image but why so? I don't understand at all. I want it to either show a loading screen but not blank video screens.</p>
","19385868","","6950415","","2022-07-01 15:26:40","2022-07-01 15:26:40","How to load lots of data from a paged api in SwiftUI efficiently?","<swift><swiftui><get><combine><avkit>","0","4","","","","CC BY-SA 4.0"
"72839638","1","","","2022-07-02 14:04:35","","-4","44","<p>I am asking a question regarding Combines <code>.first(where: )</code> method. When looking at my code, I use Hello World as the reference by which to check if it contains the values emitted by my publisher.</p>
<p>Why is H the first value thats emitted, when in reality O gets printed first?</p>
<p>I hope my question is not confusing. If you read the code it should make much more sense. Thanks!</p>
<pre><code>// 1 Create a publisher that emits four letters.
    let publisher = [&quot;J&quot;, &quot;O&quot;, &quot;H&quot;, &quot;N&quot;].publisher
    
    // 2 Use the first(where:) operator to find the first letter contained in Hello World and then print it out.
    publisher
        .print(&quot;publisher&quot;)
        .first(where: { &quot;Hello World&quot;.contains($0) })
        .sink(receiveValue: { print(&quot;First match is \($0)&quot;) })
        .store(in: &amp;subscriptions)
</code></pre>
<p>And this is what get's printed to the console:</p>
<pre><code>publisher: receive subscription: ([&quot;J&quot;, &quot;O&quot;, &quot;H&quot;, &quot;N&quot;]) 
publisher: request unlimited 
publisher: receive value: (J) 
publisher: receive value: (O) 
publisher: receive value: (H) 
publisher: receive cancel First match is H
</code></pre>
<p>Shouldn't the first match be O? Since it's hell<strong>o</strong> world?
I understand it also contains <strong>h</strong>ello, but <strong>o</strong> get's emitted before h.</p>
<p>Thanks once more.</p>
","18919062","","","","","2022-07-02 18:30:47","When using Combines .first(where: ) operator, why is the value that is printed out H, and not O, in my example code? Thank you","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"72847741","1","","","2022-07-03 15:27:51","","2","68","<p>I'm trying to incorporate Combine in a current project, and I am not sure if the current approach is the best/most idiomatic way to do it.</p>
<p>So far I have a parent object which has a shared state with some child objects, and the state is being shared as a <code>CurrentValueSubject</code>:</p>
<pre><code>
class Child {
    var state: CurrentValueSubject&lt;SharedState, Never&gt;

    init(_ state: CurrentValueSubject&lt;SharedState, Never&gt;) {
        self.state = state
        state.sink { value in self.doSomething(value) }
    }
}

class Parent {
    var state: CurrentValueSubject&lt;SharedState, Never&gt; = 

    let child1: Child
    let child2: Child

    init() {
        let state = CurrentValueSubject&lt;SharedState, Never&gt;(SharedState())
        self.state = state
        self.child1 = Child(state: state)
        self.child2 = Child(state: state)
    }
    ...
}
</code></pre>
<p>So the goal is that the parent, child1 and child2 should each be able to update the shared state, and the other components should be able to observe and respond to the value change.</p>
<p>I believe the current implementation should work, but is there a better/more idiomatic way to implement this?</p>
<p>note: I this is <em>not</em> in the context of SwiftUI</p>
","814570","","12299030","","2022-07-03 15:40:10","2022-07-06 21:40:52","Is there a more 'Combine' way to share state within an object hierarchy?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"72848424","1","","","2022-07-03 17:04:51","","0","122","<p>Lets say I have a struct state like this</p>
<pre><code>struct SomeState: Equatable {
    var counter: Int = 0
    var foo: Bool = false
}
</code></pre>
<p>and then a subject of <code>private let _state = CurrentValueSubject(SomeState())</code></p>
<p>I know I can update it as <code>_state.value.counter += 1</code></p>
<p>Is this however thread-safe in a concurrent context? Will any write wait for the previous one? Or will there be some state smashing? I'm not sure how this works under the hood in swift, I'm coming from kotlin</p>
","1541188","","","","","2022-07-03 17:04:51","Thread safety of updating a Subject value in Combine?","<swift><thread-safety><combine><currentvaluesubject>","0","5","","","","CC BY-SA 4.0"
"72861985","1","72863692","","2022-07-04 21:01:17","","0","39","<p>I created this function for decoding locally saved data.</p>
<pre><code>private func getLocalCertificates(_ data: [CovidCertificateEntity]) -&gt; [CovidCertificateDomainItem]? {
    var newCertificates: [CovidCertificateDomainItem]?
    
    Publishers
        .MergeMany(
            data.map { result -&gt; AnyPublisher&lt;Result&lt;EUDCC, ErrorType&gt;, Never&gt; in
                self.certificateToDelete = result.qrCodeValue ?? &quot;&quot;
                return repository.getCertificateDetails(result.qrCodeValue ?? &quot;&quot;)
            })
        .map { result -&gt; CovidCertificateDomainItem? in
            switch result {
            case .success(let eudcc):
                do {
                    return try CovidCertificateDomainItem(eudcc: eudcc, qrCode: self.certificateToDelete)
                }
                catch {
                    return nil
                }
                
            case.failure(_):
                return nil
            }
        }
        .compactMap { $0 }
        .collect()
        .sink { result in
            newCertificates = result.reversed()
        }
        .store(in: &amp;cancellables)
    
    return newCertificates
}
</code></pre>
<p>I wanted to achieve that value <em>result</em> from <em>data.map</em> inside <em>MergeMany</em> operator is proceeded to <em>.map</em> operator, so I can use it in constructor of <em>CovidCertificateDomainItem</em></p>
<p>I tried to made this with help variable <em>certificateToDelete</em>, but it always have last value from <em>data.map</em>.</p>
<p>Is there any way to achieve this?</p>
","16366914","","12299030","","2022-07-05 03:03:40","2022-07-05 03:25:44","Using value inside MergeMany operator in another pipeline","<swift><combine>","1","0","","","","CC BY-SA 4.0"
"72877933","1","72878105","","2022-07-06 04:22:33","","1","62","<p>I am using Apollo Client subscriptions for my app. I follow the codes here on the documentation from Apollo <a href=""https://www.apollographql.com/docs/ios/subscriptions"" rel=""nofollow noreferrer"">https://www.apollographql.com/docs/ios/subscriptions</a> but I keep having an error on when I subscribe to the apollo subscription</p>
<p><code>Value of type 'Apollo.Cancellable' does not conform to 'Combine.Cancellable' in assignment</code></p>
<p>Here is my code</p>
<pre><code>self.subscription = ApolloNetwork.shared.apollo
            .subscribe(subscription: UserBalanceSubscription()) { [weak self] result in
            guard let self = self else {
                return
            }
            
            switch result {
            case .success(let graphQLResult):
                print(graphQLResult)
            case .failure(let error):
                print(&quot;error: \(error)&quot;)
            }
        }
</code></pre>
<p>Here is how I declare the var subscription</p>
<p><code>private var subscription: Cancellable?</code></p>
<p>I am getting confused what causing the issue and how to fix it.</p>
","8903723","","8903723","","2022-07-06 04:40:44","2022-07-06 04:54:06","Swift 'Apollo.Cancellable' does not conform to 'Combine.Cancellable'","<swift><graphql><apollo><apollo-client><combine>","1","3","","","","CC BY-SA 4.0"
"72887904","1","","","2022-07-06 17:49:07","","0","33","<p>I have the following structs:</p>
<pre class=""lang-swift prettyprint-override""><code>struct Search: Codable {
    struct Data: Codable {
        struct Item: Codable {
            let symbol: String
            let description: String
        }

        let items: [Item]
    }
   
    let data: Data
}
</code></pre>
<p>Search function:</p>
<pre class=""lang-swift prettyprint-override""><code>func getSearchkData(for search: String) {
    let url = URL(string: &quot;https://api.tastyworks.com/symbols/search/\(search)&quot;)!
    URLSession.shared
        .dataTaskPublisher(for: url)
        .tryMap { element -&gt; JSONDecoder.Input in
            guard let httpResponse = element.response as? HTTPURLResponse,
                      httpResponse.statusCode == 200 else {
                throw URLError(.badServerResponse)
            }
            return element.data
        }
        .decode(type: Search.self, decoder: JSONDecoder())
        .sink { completion in
            switch completion {
            case .failure(let error):
                print(error)
                return
            case .finished:
                return
            }
        } receiveValue: { [unowned self] searchAPI in                
            DispatchQueue.main.async {
                self.searchAPI.append(searchAPI)
            }
            print(searchAPI)
        }
        .store(in: &amp;cancellables)
}
</code></pre>
<p>Im able to get the search working in the console but how can I display that exact info into my list?
<a href=""https://i.stack.imgur.com/Hchgw.png"" rel=""nofollow noreferrer"">results of search when I type 'A' into the searchable in swift</a></p>
","19476650","","11432719","","2022-07-10 21:57:38","2022-07-10 21:57:38","How do I display my searchable data from console to a list in SwiftUI?","<json><api><swiftui><decode><combine>","1","0","","","","CC BY-SA 4.0"
"72901667","1","","","2022-07-07 16:55:42","","2","111","<p>I have a class set as ObservableObject to listen to a Firestore collection. Everything works until the app goes asleep (eg. after 30 mins) and a Cloud Function runs to update some data. Then the real time updates no longer happen until I kill and open the app again, only after that I get the most recent updates.</p>
<p>My code is working like this:</p>
<pre><code>class FirebaseRealTime: ObservableObject {
..

@Published var myUsers = [Users]()
..

self.listenToUserCollection()
..

func listenToUserCollection {
        db.collection(&quot;users&quot;).addSnapshotListener { (querySnapshot, error) in
DispatchQueue.global(qos: .background).async {
..
          DispatchQueue.main.async {
                        self.myUsers = tempUsers
                        //self.usersLoaded = true
          }
..
       }

}
</code></pre>
<p>Then a global var is set in the scene delegate as an environment object</p>
<pre><code>class SceneDelegate: UIResponder, UIWindowSceneDelegate {
..
 var userDetails = FirebaseRealTime()
..
 let contentView = ViewExample()
                      .environmentObject(userDetails)
..
}
</code></pre>
<p>Last, I have a SwiftUI view receiving the real time data.</p>
<pre><code>struct ViewExample: View {
    @EnvironmentObject var userDetails:FirebaseRealTime
    
    @State var users:[Users] = []
    
    var body: some View {
        VStack {
            ScrollView {
                ForEach(users) { user in
                    RowExample(user: user)
                }
            }
        }
        .onReceive(userDetails.$myUsers) { data in
             print (data) 
        }
    }
}
</code></pre>
<p>As I said when the app is active and I manually change a field in Firestore the data updates, but when the Google Cloud func runs on the backend it does not.</p>
<p>Any idea what's going on? Is there a way to &quot;force&quot; the received data to get updated, or any other work around?</p>
","11013300","","11013300","","2022-07-14 02:52:56","2022-07-29 18:31:43","Firebase ObservableObject not updating after app goes asleep in swiftui","<firebase><google-cloud-firestore><swiftui><google-cloud-functions><combine>","2","4","","","","CC BY-SA 4.0"
"72919047","1","72922279","","2022-07-09 04:56:42","","0","126","<p>Consider the below Observable Object.</p>
<pre><code>class User: ObservableObject {
    @Published var age: Int
    @Published var name: String {
        didSet {
            objectWillChange.send()
        }
    }
    
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

</code></pre>
<p>The below code prints blank value or Void block. Any reason why? If we change Integer value age it should simply print that value.</p>
<pre><code>let userJohnCancellable = userJohn.objectWillChange.sink { val in

    print(&quot;Changed Value \(val)&quot;)
    
}
userJohn.age = 21
userJohn.age = 39
</code></pre>
<p>We can try to print the values in the closure using <code>userJohn.age</code>. But why does val not return a Integer value in this case.</p>
<p>Also what would be the best way to handle <code>sink</code> changes for age and name, both, one is String other is Int.</p>
","908124","","","","","2022-07-09 14:41:34","sink value is Void with publisher","<swift><combine>","2","2","","","","CC BY-SA 4.0"
"72922641","1","","","2022-07-09 15:29:03","","0","88","<p>trying to fetch some data with dataTaskPublisher. however, constantly receive following log. it works every once in a while and not sure what's the difference. change URL does not make a difference. still only occasionally succeed the request.</p>
<blockquote>
<p>Test2: receive subscription: (TryMap)</p>
<p>Test2: request unlimited</p>
<p>Test2: receive cancel</p>
</blockquote>
<pre><code>class DataSource: NSObject, ObservableObject {

  var networker: Networker = Networker()

  func fetch() {
    guard let url = URL(string: &quot;https://jsonplaceholder.typicode.com/posts&quot;) else {
      fatalError(&quot;Invalid URL&quot;)
    }
    networker.fetchUrl(url: url)
  }
}

class Networker: NSObject, ObservableObject {
  var pub: AnyPublisher&lt;Data, Error&gt;? = nil
  var sub: Cancellable? = nil
  
  var data: Data? = nil
  var response: URLResponse? = nil
  
  func fetchUrl(url: URL)  {
    guard let url = URL(string: &quot;https://apple.com&quot;) else {
      return
    }
    pub = URLSession.shared.dataTaskPublisher(for: url)
      .receive(on: DispatchQueue.main)
      .tryMap() { data, response in
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
          throw URLError(.badServerResponse)
        }
        return data
      }
      .print(&quot;Test2&quot;)

      .eraseToAnyPublisher()
    sub = pub?.sink(
      receiveCompletion: { completion in
        switch completion {
        case .finished:
          break
        case .failure(let error):
          fatalError(error.localizedDescription)
        }
      },
      receiveValue: {
        print($0)
      }
    )
}
</code></pre>
","19516855","","6950415","","2022-07-09 17:16:58","2022-07-09 17:16:58","URLSession.shared.dataTaskPublisher receive cancel","<swift><combine>","0","3","","","","CC BY-SA 4.0"
"72925444","1","72926326","","2022-07-10 00:21:31","","0","61","<p>I have a function which I use to make api call but sometimes, I could get a decaying error and debugging this has been difficult. Below is my function, is there any way to maybe log or print the bad decoding key since I am using combine.</p>
<pre><code>    func request&lt;T&gt;(with builder: BaseRequest, customDecoder: JSONDecoder) -&gt; AnyPublisher&lt;T, APIError&gt; where T: Codable {
        
        let encoding: ParametersEncoder = [.get, .delete].contains(builder.method) ? URLParameretersEncoder() : JSONParametersEncoder()
        customDecoder.keyDecodingStrategy = .convertFromSnakeCase
        var url: URL {
            var components = URLComponents()
            components.scheme = &quot;http&quot;
            components.host = builder.baseUrl
            components.path = &quot;/api/v1&quot; + builder.path
            
            guard let url = components.url else {
                preconditionFailure(&quot;Invalid URL components: \(components)&quot;)
            }
            
            return url
        }
        var urlRequest = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalAndRemoteCacheData, timeoutInterval: 46.0)
        urlRequest.httpMethod = builder.method.rawValue
        builder.headers.forEach { key, value in
            urlRequest.setValue(value, forHTTPHeaderField: key)
        }
        if let token = tokenManager.token {
            urlRequest.setValue(&quot;Bearer &quot; + token, forHTTPHeaderField: &quot;Authorization&quot;)
        }
        if let parameters = builder.parameters {
            guard let encoded = try? encoding.encode(parameters: parameters, in: urlRequest) else {
                fatalError()
            }
            urlRequest = encoded
        }
        self.log(request: urlRequest)
        return URLSession.shared
            .dataTaskPublisher(for: urlRequest)
            .receive(on: DispatchQueue.main)
            .mapError { _ in .unknown }
            .flatMap { data, response -&gt; AnyPublisher&lt;T, APIError&gt; in
                guard let response = response as? HTTPURLResponse else {
                    return Fail(error: APIError.invalidResponse).eraseToAnyPublisher()
                }
                self.log(response: response, data: data, error: nil)
                if (200...299).contains(response.statusCode) {
                    return Just(data)
                        .decode(type: T.self, decoder: customDecoder)
//                        .map {
//                            print($0)
//                            return $0
//                        } //added
                        .mapError {_ in .decodingError}
                        .eraseToAnyPublisher()
                } else {
                    guard let errorResponse = try? customDecoder.decode(BaseResponse.self, from: data) else {
                        return Fail(error: APIError.decodingError).eraseToAnyPublisher()
                    }
                    return Fail(error: APIError.server(response: errorResponse))
                        .eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()
    }
</code></pre>
","8310287","","","","","2022-07-10 06:14:57","decoding key issue swift codable","<swift><combine><codable>","1","3","","","","CC BY-SA 4.0"
"72926348","1","","","2022-07-10 05:35:22","","0","107","<p>For my SwiftUI view, I am trying to create an <code>ObservableObject</code> that fetches some data from a Core Data entity, and repackages it into a dictionary that I can use for the new Charts UI. The view is created just fine, but I can't figure out how to listen and respond to changes in the data. If I used a @FetchRequest directly, it would listen to the changes and respond automatically, but here I manually fetch items using a NSFetchRequest</p>
<pre><code>class CJChartsDataDataSource: ObservableObject {

    @Published var cjCountItemsForDates = [Date: NSNumber]()        
    
    init(context: NSManagedObjectContext) {
        
        if let countForDates = CJDataItem.countForItemsByDate(with: context, with: Date(), andNumberOfDates: 7) {
            cjCountItemsForDates = countForDates
                            
        }
    }
}
</code></pre>
<p>Here is the simplified view:</p>
<pre><code>struct CJReportsViewController: View {
    
    @Environment(\.managedObjectContext) var managedObjectContext
    
    @ObservedObject var dataSource: CJChartsDataDataSource
    
    var body: some View {
        /// ...
    }
}
</code></pre>
<p>How do I respond to changes in this <code>CJDataItem</code> entity so that this <code>ObservableObject</code> gets updated, and so the SwiftUI view also gets the update?</p>
","145552","","","","","2022-07-12 08:47:01","SwiftUI ObservableObject - respond to Core Data changes","<swift><core-data><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"72927807","1","","","2022-07-10 10:33:09","","1","87","<p>I am receiving some JSON which looks like the below :</p>
<pre><code>{
    &quot;template&quot;: &quot;search&quot;,
    &quot;item&quot;: &quot;2&quot;,
    &quot;contents&quot;: [
      {
        &quot;title&quot;: &quot;title 1&quot;,
        &quot;subtitle&quot;: &quot;subtitle 1&quot;,
        &quot;imageurl&quot;: &quot;/data/dzzxw0177014_325qv.jpg?size=small&quot;,
        &quot;fullscreenimageurl&quot;: &quot;/data/xw0177014_325qv.jpg?size=large&quot;,
        &quot;id&quot;: &quot;0177014&quot;,
        &quot;detaillink&quot;: &quot;/apps/v2/details/programme/177014&quot;,
        &quot;duration&quot;: &quot;PT2H46M&quot;
      },
      {
        &quot;title&quot;: &quot;title2&quot;,
        &quot;subtitle&quot;: &quot;subtitle 2&quot;,
        &quot;imageurl&quot;: &quot;/data_p//11436/origin_dzdzdzdzw0046394_43fu1.jpg?size=small&quot;,
        &quot;fullscreenimageurl&quot;: &quot;/data/11456/w0046394_43fu1.jpg?size=large&quot;,
        &quot;id&quot;: &quot;0046394&quot;,
        &quot;detaillink&quot;: &quot;/apps/v2/details/programme/MYW0046394&quot;,
        &quot;duration&quot;: &quot;PT1H40M46S&quot;
      }
    ]
  }
</code></pre>
<p>and I have a corresponding model:</p>
<pre><code>import Foundation

// MARK: - Welcome
struct Welcome {
    let template, item: String
    let contents: [Content]
}

// MARK: - Content
struct Content {
    let title, subtitle, imageurl, fullscreenimageurl: String
    let id, detaillink, duration: String
}
</code></pre>
<p>I have an API manager :</p>
<pre><code>import Foundation
import Combine

class APIManager {
    
    static let shared = APIManager()
    
    let baseURL = &quot;https:// .....&quot;
    
    func fetchShows(with query: String) -&gt; AnyPublisher&lt;[Content], Error &gt; {
        
        Future&lt;Any, Error&gt; { promise in
            
            self.loadJson(withQuery: query) { (result) in
                
                promise(.success(result))
                
            }
            
        }
        .tryMap {
            
            try JSONSerialization.data(withJSONObject: $0, options: .prettyPrinted)
            
        }
        .decode(type: [Content].self, decoder: jsonDecoder)
        .eraseToAnyPublisher()
    }
    
    var jsonDecoder: JSONDecoder {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        return decoder
        
    }
        
    
    func loadJson(withQuery query: String,
                  completion: @escaping (Result&lt;Data, Error&gt;) -&gt; Void) {
        
        
        let UrlString = baseURL + (query.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? &quot;&quot;)
        
        if let url = URL(string: UrlString) {
            
            print (UrlString)
            
            let urlSession = URLSession(configuration: .default).dataTask(with: url) { (data, response, error) in
                
                if let error = error {
                    completion(.failure(error))
                }
                
                if let data = data {
                    
                    completion(.success(data))
                    
                }
            }
            
            
            urlSession.resume()
        }
    }
    
}
</code></pre>
<p>At the moment I have a crash with the error &quot;Invalid top-level type in JSON write&quot;, I assume this is because the JSON that I am trying to decode isn't an array of Content. It's a Welcome Struct which contains an array of Content.</p>
<p>At what point can I say that I am only interested in the Contents &quot;Array&quot; and decode it ? Should this be defined in the model some how ?</p>
<p>Thanks</p>
","14163130","","","","","2022-07-12 04:48:15","Swift / Combine JSON decodable - decode and receive array of content only 'Invalid top-level type in JSON write'","<json><swift><combine><nsjsonserialization><decodable>","1","5","","","","CC BY-SA 4.0"
"72955404","1","72955595","","2022-07-12 16:17:47","","2","67","<p>The question is best explained in an example:</p>
<pre><code>struct MyEditor: View {
    @Environment(\.managedObjectContext) var managedObjectContext
    
    @ObservedObject var song: Song
    
    var body: some View {
        TextEditor(text: $song.lyrics)
            .navigationTitle(song.title)
            .onChange(of: song.lyrics) { newValue in
                try? managedObjectContext.save()
            }
    }
}
</code></pre>
<p>It feels wrong to spam <code>save</code> but I want to make sure the data is stored. Is this allowed and a correct way to do it?</p>
<p>Another way I can think of is to create a publisher that smoothens the signal to save. If this is the correct way to do it. Can I retrieve the publisher from the ObservedObject or do I have to create a different <code>@State</code> property for that and use <code>onChange</code> to pass the values.</p>
<pre><code>struct MyEditor: View {
    @Environment(\.managedObjectContext) var managedObjectContext
    
    @ObservedObject var song: Song
    
    @State private var lyricsPublisher = PassthroughSubject&lt;String, Never&gt;()
    
    var body: some View {
        TextEditor(text: $song.lyrics)
            .navigationTitle(song.title)
            .onChange(of: song.lyrics) { newValue in
                lyricsPublisher.send(newValue)
            }
            .onReceive(lyricsPublisher
                .debounce(for: 0.5, scheduler: RunLoop.main)
                .removeDuplicates()
            ) { value in
                try? managedObjectContext.save()
            }
    }
}
</code></pre>
<p>This is what Song looks like as a <code>ManagedObject</code>.</p>
<pre><code>@objc(Song)
class Song: NSManagedObject, Identifiable {
    @nonobjc class func fetchRequest() -&gt; NSFetchRequest&lt;Song&gt; {
        return NSFetchRequest&lt;Scribble&gt;(entityName: &quot;Song&quot;)
    }

    @NSManaged public var id: UUID
    @NSManaged public var title: String
    @NSManaged public var lyrics: String
}
</code></pre>
","174655","","174655","","2022-07-12 16:44:49","2022-07-12 17:38:20","Are you allowed to save to the managed object context (Core Data) while typing in a TextEditor (Text Field Input)?","<core-data><swiftui><combine><observedobject>","2","4","1","","","CC BY-SA 4.0"
"72971969","1","72972358","","2022-07-13 19:59:58","","4","98","<p>Just getting into <code>Combine</code>, and for some reason I can't get <code>passthrough subjects</code> to work. Even though I have copy-pasted examples from multiple different sources, they just won't print anything. I have tried with <code>Publishers</code> and <code>CurrentValueSubjects</code> and they work fine, but with <code>PassThroughSubjects</code>; nope. Here's an example that I have tried:</p>
<pre><code>let mySubject = PassthroughSubject&lt;String, Error&gt;()

mySubject.sink(receiveCompletion: { completion in
        print(&quot;-- completion&quot;, completion)
    }, receiveValue: { value in
        print(&quot;-- value&quot;, value)
}).cancel()

mySubject.send(&quot;one&quot;)
mySubject.send(&quot;two&quot;)
mySubject.send(&quot;three&quot;)
</code></pre>
<p>This is run in <code>viewDidLoad</code>.
What am I doing wrong?</p>
<p>Like I said, I have tried <code>Publishers</code> and <code>CurrentValueSubjects</code> with success:</p>
<pre><code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;].publisher
    .sink(receiveValue: { v in
        print(&quot;-- hello&quot;, v)
}).cancel()

let subject = CurrentValueSubject&lt;String, Error&gt;(&quot;Initial Value&quot;)

subject.send(&quot;Hello&quot;)

subject.sink(receiveCompletion: { c in
    print(&quot;-- completion&quot;, c)
}, receiveValue: { v in
    print(&quot;-- value&quot;, v)
}).cancel()
</code></pre>
","8591381","","","","","2022-07-13 20:36:20","Why can't I get passthrough subjects to work for combine?","<ios><swift><combine>","2","2","","","","CC BY-SA 4.0"
"73015462","1","73015746","","2022-07-17 21:22:59","","1","118","<p>I'm trying to change my function from using a completion handler to a function that uses combine, but I'm getting an error message.</p>
<ol>
<li><p>with completionHandler:</p>
<pre><code> typealias AuthorizationCompletion = (UNAuthorizationStatus) -&gt; ()

 func reloadAuthorizationStatus(completion: @escaping AuthorizationCompletion) {
 UNUserNotificationCenter.current().getNotificationSettings { settings in
     DispatchQueue.main.async {
         let notificationStatus = settings.authorizationStatus
         completion(notificationStatus)
     }
 }
</code></pre>
</li>
<li><p>Using Combine:</p>
<pre><code> func reloadAuthorizationStatus() -&gt; AnyPublisher&lt;UNAuthorizationStatus, Error&gt;  {
 UNUserNotificationCenter.current().getNotificationSettings { settings in
     Just(settings)
         .tryMap({$0.authorizationStatus})
         .eraseToAnyPublisher()
 }
</code></pre>
</li>
</ol>
<p>But getting the error Cannot convert return expression of type 'Void' to return type 'AnyPublisher&lt;UNAuthorizationStatus, Error&gt;'</p>
<p>From the moment I add the return type to the function, the settings let will change from type UNNotificationSettings to error type</p>
<p>What am I missing here ?</p>
","4795917","","560942","","2022-07-17 21:53:21","2022-07-17 22:19:14","Convert function with completionHandler to Combine","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"73033391","1","73033648","","2022-07-19 08:13:51","","0","331","<p>I am trying to learn Combine and understand how I can make it work with the new async/await syntax. I have this code which consists of a view controller with a button and a table view, the button triggers a request to MapKit's <code>MKLocalSearchCompleter</code> with a random text, which then publishes the update to reload the view controller's table view, with the data fetched from the <code>MKLocalSearchCompleter</code>.</p>
<p>For some reason, the second time that I tap the button and <code>withCheckedContinuation</code> gets called again, I get this error:</p>
<blockquote>
<p>Fatal error: SWIFT TASK CONTINUATION MISUSE: fillTableView(with:) tried to resume its continuation more than once, returning [&quot;Recklinghausen&quot;, &quot;Recquignies&quot;, &quot;Recloses&quot;, &quot;Recco&quot;, &quot;Recy&quot;, &quot;Reconvilier&quot;, &quot;Rectorat de Paris&quot;, &quot;Recke&quot;, &quot;Recques-sur-Course&quot;, &quot;Recto Versoi&quot;, &quot;Rechberghausen&quot;, &quot;Rechlin&quot;, &quot;Reclinghem&quot;, &quot;Reckange-sur-Mess&quot;, &quot;Récourt&quot;]!</p>
</blockquote>
<p>I don't understand because I though that the continuation was correctly resuming after the first call. What is happening?</p>
<p>Here is the code:</p>
<pre><code>import _Concurrency
import Combine
import MapKit
import UIKit

class ViewController: UIViewController {
    private var components: [String] = []
    // View Properties
    private let randomTexts = [&quot;re&quot;, &quot;ma&quot;, &quot;so&quot;, &quot;lem&quot;, &quot;tap&quot;, &quot;do&quot;, &quot;rec&quot;]
    // MapKit Properties
    private var searchCompleter = MKLocalSearchCompleter()
    // Combine Properties
    private var cancellables = Set&lt;AnyCancellable&gt;()
    private var publisher = PassthroughSubject&lt;[String], Never&gt;()
    
    @IBOutlet weak var tableView: UITableView!
    
    // Methods
    @IBAction func tapped() {
        guard let randomText = randomTexts.randomElement() else {
            return
        }
        searchCompleter.queryFragment = randomText
        fillTableView(with: randomText)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        searchCompleter.delegate = self
    }
    
    private func fillTableView(with randomElement: String) {
        Task {
            let autocompletedComponents = await withCheckedContinuation { continuation in
                publisher
                    .sink { continuation.resume(returning: $0) }
                    .store(in: &amp;cancellables)
            }
            components = autocompletedComponents
            tableView.reloadData()
        }
    }
}

extension ViewController: MKLocalSearchCompleterDelegate {
    func completerDidUpdateResults(_ completer: MKLocalSearchCompleter) {
        publisher.send(
            completer.results.map { $0.title }
        )
    }
}

extension ViewController: UITableViewDataSource, UITableViewDelegate {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return components.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
        let cell = UITableViewCell()
        cell.textLabel?.text = components[indexPath.row]
        return cell
    }
}
</code></pre>
<p>Thank you for your help</p>
","14553929","","","","","2022-07-23 06:45:49","Swift: using combination of Combine and async/await results in Fatal error: SWIFT TASK CONTINUATION MISUSE tried to resume its continuation","<swift><async-await><combine><continuations>","2","2","","","","CC BY-SA 4.0"
"73037061","1","73037617","","2022-07-19 12:37:54","","-1","70","<p>I am sorry if this sounds very beginner, but after looking at Apple doc as well as several tutorials I still struggle to understand how Combine's Future works.</p>
<p>I have this very simple code which stores the current date on first button tap, and prints the interval on the second one:</p>
<pre><code>import UIKit

class MyViewController: UIViewController {
    private var startTime: Date = .now
    private var completion: (TimeInterval) -&gt; Void = { _ in }
    private var isOn = false
    
    @IBAction func tapped() {
        if isOn {
            completion(Date.now.timeIntervalSince(startTime))
        } else {
            startTime = .now
        }
        isOn.toggle()
    }

    init(_ completion: @escaping (TimeInterval) -&gt; Void) {
        super.init(nibName: &quot;MyViewController&quot;, bundle: .main)
        self.completion = completion
    }
    
    required init?(coder: NSCoder) {
        fatalError()
    }
}
</code></pre>
<p>In my AppDelegate:</p>
<pre><code>window?.rootViewController = MyViewController {
    print(&quot;Tapped with time interval: \($0)&quot;)
}
</code></pre>
<p>Now I would like to replace that completion handler with a <code>Future</code>, but I'm confused about what to do. I guess I have to create a function like this in my view controller:</p>
<pre><code>func afterSecondTap() -&gt; Future&lt;TimeInterval, Error&gt; {
    return Future { promise in
        // what to do here?
    }
}
</code></pre>
<p>And in the <code>AppDelegate</code> something like this:</p>
<pre><code>window?.rootViewController = MyViewController()
    .afterSecondTap()
    .sink(receiveCompletion: { completion in
            
    }, receiveValue: { value in
            
    })
    .store(in: &amp;subscriptions)
</code></pre>
<p>However this would not work because I get an error saying</p>
<blockquote>
<p>Cannot assign value of type '()' to type 'UIViewController'</p>
</blockquote>
<p>Thank you for helping me understand this</p>
","19579501","","","","","2022-07-19 13:15:02","Swift: how to replace a completion handler with a Future in an element initializer?","<swift><future><combine>","2","1","","","","CC BY-SA 4.0"
"73075094","1","73079344","","2022-07-22 04:22:31","","0","62","<p>In my app I have a task and a note object that both can contain an array of tags. The tasks and notes are fetched and stored in their respective stores. I pass these two classes down as environment objects. When a user is editing a task or a note, depending on the type, they go to the TaskEditView or NoteEditView. They can add a new tag, however if a tag already exists it will add that existing tag to the object. Because the tags are spread across two different stores how can I merge the two arrays and find if the tag exists without duplicating code?</p>
<pre><code>struct Task: Identifiable {
    var id: String = UUID().uuidString
    var tags: [Tag] = []
    // Other task properties
}

struct Note: Identifiable {
    var id: String = UUID().uuidString
    var tags: [Tag] = []
    // Other note properties
}

struct Tag {
    var title: String
    var color: Color
}

class TaskStore: ObservableObject {
    @Published var tasks = [Task]()
    // Other TaskStore properties and functions
}

class NoteStore: ObservableObject {
    @Published var notes = [Note]()
    // Other NoteStore properties and functions
}
</code></pre>
<hr />
<p>The only solution I have found is to pass the NoteStore and TaskStore down as environment objects and then map the tasks and notes arrays into a combined array of tag objects. However, I do not like this because I have to duplicate this code for the NoteEditView, TaskEditView and any other edit view of an object that contains a list of tags as a property. At the same time I have to pass every store that has objects that contain tags. Ideally I would want to create a class called TagStore that uses combine that subscribes to these two arrays.</p>
<pre><code>let tags = [taskStore.tasks.flatMap { $0.tags }, noteStore.notes.flatMap { $0.tags }]
     .flatMap { $0 }

if let tag = tags.first(where: { $0.title == &quot;History&quot; }) {
    // Tag already exists                       
}
</code></pre>
","","user19555877","","user19555877","2022-07-22 04:23:38","2022-07-22 11:11:45","How can I use combine to merge arrays from different ObservableObjects?","<arrays><swiftui><combine>","1","3","","","","CC BY-SA 4.0"
"73132771","1","73136687","","2022-07-27 05:44:09","","2","52","<p>In all tutorials and in official documentation I only see initialization of timer straight up when the view loads.</p>
<pre><code>@State private var timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
</code></pre>
<p>and later on</p>
<pre><code>.onReceive(timer) {....}
</code></pre>
<p>but how should I init timer only on button click and assign it to the unassigned / not connected timer.</p>
<p>Later on I will need to cancel and reconnect, but that is not the issue here. Issue here is connecting only after button click.</p>
<p>I tried to init it like this</p>
<pre><code>@State private var timer: Cancellable?
</code></pre>
<p>....</p>
<pre><code>timer = Timer.publish(every: 1, on: .main, in: .common).connect()
</code></pre>
<p>But I can not call onReceive on timer inited like this, because first:</p>
<pre><code>Protocol 'Cancellable' as a type cannot conform to 'Publisher'
</code></pre>
<p>and second</p>
<pre><code>Argument type 'Cancellable?' does not conform to expected type 'Cancellable'
</code></pre>
","7507291","","","","","2022-07-27 10:56:53","Timer publisher init timer after button click","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"73134718","1","","","2022-07-27 08:36:21","","0","71","<p>Ive got an API endpoint that i have got to take some data from but it needs an access token.
This access token is fetched from another endpoint of this api.</p>
<p>The access token expires every 2:30 hrs.</p>
<p>The way I am handling this is that every 2:20 hrs i have a a timer that fetches a new token. I know this is a bad practice since the user might turn off the internet during that fetching etc.</p>
<p>I am using an architectural pattern that splits my main app into 3 seperate layers.</p>
<p>A domain layer which contains all my models, use cases and repositories</p>
<p>A presentation layer which contains all my views and viewmodels.</p>
<p>And a Data layer that contains all my repository implementations , network constants, url builders and my API client where the request is made with alamofire.</p>
<p>My ApiClient is this :</p>
<pre><code>public enum ApiClient {
    static func requestCodable&lt;T: Codable&gt;(_ urlConvertible: URLRequestConvertible) -&gt; AnyPublisher&lt;DataResponse&lt;T, NetworkErrorResponse&gt;, Never&gt; {
        return AF.request(urlConvertible)
            .validate()
            .publishDecodable(type: T.self, emptyResponseCodes: [200])
            .map { response in
                response.mapError { error in
                    let backendError = response.data.flatMap { try? JSONDecoder().decode(BackendError.self, from: $0) }
                    return NetworkErrorResponse(initialError: error, backendError: backendError)
                }
            }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p>So , lets assume that i am making a call to an endpoint that needs the access token, and it fails because 3 hours have gone by ...
How can I say to my api client to fetch a new access token and then retry the endpoint that failed ?</p>
<p>Thanks for any help in advance.</p>
","9109774","","","","","2022-07-27 09:43:06","Swift - Alamofire - Combine - try to fetch access token if the endpoint returns 401 error code","<ios><swift><alamofire><access-token><combine>","1","0","","","","CC BY-SA 4.0"
"73140609","1","73140877","","2022-07-27 15:20:52","","1","57","<p>I created a simple Publisher from an array of paths I want to fetch from the internet. I am setting the failure type to match the DataTaskPublisher, and then I flatMap to get the new Publisher with the DataTask results. However, when I subscribe to the stream with sink, nothing gets called.</p>
<p>Here is my code:</p>
<pre><code>import Combine
import Foundation

class NetworkManager {
    var tasks = Set&lt;AnyCancellable&gt;()
    
    init() {
        getData()
    }
    
    func getData() {
        let baseUrl = URL(string: &quot;https://fmi.unibuc.ro&quot;)!
        [&quot;/prezentare&quot;, &quot;/cazare&quot;].publisher
            .setFailureType(to: URLError.self)
            .flatMap { path -&gt; URLSession.DataTaskPublisher in
                let url = baseUrl.appendingPathComponent(path)
                return URLSession.shared.dataTaskPublisher(for: url)
            }
            .sink(receiveCompletion: { completion in
                print(completion)
            }, receiveValue: { value in
                print(value)
            })
            .store(in: &amp;tasks)
    }
}

let manager = NetworkManager()
</code></pre>
<p>What am I doing wrong? 🤔</p>
","19633958","","4667835","","2022-07-27 15:40:42","2022-07-27 15:40:42","Combine's DataTaskPublisher does not output when passed through flatMap in Playgrounds","<swift><combine><swift-playground><urlsession>","1","0","","","","CC BY-SA 4.0"
"73152675","1","","","2022-07-28 12:10:10","","0","38","<p><code>@Published var allJobs:[JobsModel] = []</code>
this will populate on response on api call</p>
<p>here is my subscriber Code</p>
<pre><code>viewModel.$allJobs.subscribe(on: DispatchQueue.main ).sink(receiveCompletion: { completion in
            switch completion {
                case .finished:
                       print(&quot;finished&quot;)
                    break
                case .failure(let anError):
                    print(anError.localizedDescription)
                    break
            }
        }, receiveValue: { someValue in
            self.jobsTbl.reloadData()
            print(&quot;.sink() received \(someValue)&quot;)
        }).store(in: &amp;cancellable)

</code></pre>
<p>this is not working when data is populated
but working when I add delays like</p>
<pre><code>viewModel.$allJobs.subscribe(on: DispatchQueue.main ).sink(receiveCompletion: { completion in
            switch completion {
                case .finished:
                       print(&quot;finished&quot;)
                    break
                case .failure(let anError):
                    print(anError.localizedDescription)
                    break
            }
        }, receiveValue: { someValue in
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.01){
            self.jobsTbl.reloadData()
            }
            print(&quot;.sink() received \(someValue)&quot;)
        }).store(in: &amp;cancellable)
</code></pre>
","9182074","","","","","2022-08-18 15:43:42","TableView Not Reloading when working with combine but working when applied delay using DispatchQueue.Main.asyncAfter","<ios><swift><uikit><tableview><combine>","1","1","","","","CC BY-SA 4.0"
"73160043","1","73162563","","2022-07-28 23:05:26","","0","57","<p>I have a function using Combine that provides a list of results based on user entry.</p>
<p>For example:
If the user types rain it will display a list of results with the word rain in it.</p>
<p>The data is being stored in a struct and I need to first match on one element and if there are no matches, try matching on another element.</p>
<p>For example:</p>
<pre><code>struct dataSet: Codable, Hashable {
    let nameShort: String
    let nameLong: String
}
</code></pre>
<p>When the user enters a value in the form field, I want it to first look through nameShort, and then if there are no results, look through nameLong.</p>
<p>The second part of the equation is that I need it to match using the entire string, but with separate words.</p>
<p>For example:
If the user enters brown, it should look through the nameShort for brown and then the nameLong for brown. However, if there are tons of entries matching brown and the user then types brown chair, I need it to return results that match both of those values.</p>
<p>Likewise, if the user types brow chai, it should still return brown chair as the initial characters match a word in the struct, even if nameLong is Brown - Side Chair.</p>
<p>Here's an example of my current function:</p>
<pre><code>func editingChangedName(_ value: String) {
    $myName
        .debounce(for: 0.3, scheduler: RunLoop.main)
        .receive(on: DispatchQueue.global()) // Perform filter on background
        .map { [weak self] filterString in
            guard filterString.count &gt;= 3, let self = self else { return [] }
            return self.nameArray.filter {
                $0.nameShort
                    .lowercased()
                    .contains(
                        filterString.lowercased()
                    ) ||
                $0.nameLong
                    .lowercased()
                    .contains(
                        filterString.lowercased()
                    )
            }
        }
        .receive(on: RunLoop.main) // Switch back to main thread
        .assign(to: &amp;$allNamesArray)
} // End func
</code></pre>
<p>This runs onChange of the form field so it's constantly updating the results.</p>
<p>I've tried things like:</p>
<pre><code>let searchString = filterString.lowercased().components(separatedBy: &quot; &quot;)
</code></pre>
<p>below the guard statements, and then removed $0.nameShort and $0.nameLong from the return, replacing it with:</p>
<pre><code>searchString.contains(where: $0.nameLong.contains)
</code></pre>
<p>but then all the results get screwy.</p>
<p>If I remove $0.nameShort and only use $0.nameLong, and change .contains to .hasPrefix it will only read from left to right and match exactly those characters that exist. So, if I was to type chair I would get 0 results, whereas if I typed brown I would get all the results that start with brown.</p>
<p>I feel like I'm close but can't figure out how to do this properly.</p>
","11053343","","","","","2022-07-29 06:41:40","Swift Combine Compare String","<arrays><swift><filter><combine>","1","0","","","","CC BY-SA 4.0"
"73194185","1","73194355","","2022-08-01 13:10:14","","0","93","<p>I've been writing Swift with Combine for a while now. I've even finished an app that I use privately.  I've been struggling to understand and use Combine effectively.  Lately I'm working through the books &quot;Using Combine with Swift&quot; by Joseph Heck and &quot;Combine Mastery&quot; from Big Mountain by Mark Moeykens.  Both books have been extremely helpful in understanding Combine.</p>
<p>BUT..... I'm struggling to understand why in the examples I see code where the publisher / subscriber code is placed within init() {} like this example from Combine Mastery :</p>
<pre><code>
//  Copyright © 2021 Mark Moeykens. All rights reserved. | @BigMtnStudio
class Published_IntroductionViewModel: ObservableObject {
    var characterLimit = 30
    @Published var data = &quot;&quot;
    @Published var characterCount = 0
    @Published var countColor = Color.gray

    init() {
        $data
            .map { data -&gt; Int in
                return data.count
            }
            .assign(to: &amp;$characterCount)
        
        $characterCount
            .map { [unowned self] count -&gt; Color in
                let eightyPercent = Int(Double(characterLimit) * 0.8)
                if (eightyPercent...characterLimit).contains(count) {
                    return Color.yellow
                } else if count &gt; characterLimit {
                    return Color.red
                }
                return Color.gray
            }
            .assign(to: &amp;$countColor)
    }
}
</code></pre>
<p>and for other examples the code is not in init() {}
like this from Combine Mastery:</p>
<pre><code>
//  Copyright © 2021 Mark Moeykens. All rights reserved. | @BigMtnStudio

class Just_IntroductionViewModel: ObservableObject {
    @Published var data = &quot;&quot;
    @Published var dataToView: [String] = []
    
    func fetch() {
        let dataIn = [&quot;Julian&quot;, &quot;Meredith&quot;, &quot;Luan&quot;, &quot;Daniel&quot;, &quot;Marina&quot;]
        
        _ = dataIn.publisher
            .sink { [unowned self] (item) in
                dataToView.append(item)
            }
        
        if dataIn.count &gt; 0 {
            Just(dataIn[Int.random(in: 0..&lt;5)])
                .map { item in
                    item.uppercased()
                }
                .assign(to: &amp;$data)
        }
    }
}
</code></pre>
<p>The answer may be &quot;Duh that's so obvious&quot; but I'm afraid it completely escapes me and would appreciate any guidance on this topic.</p>
","13622371","","4667835","","2022-08-01 13:25:19","2022-08-01 13:48:54","Combine why publish in init or not in init","<swift><combine>","2","4","","","","CC BY-SA 4.0"
"73196446","1","","","2022-08-01 15:55:31","","0","130","<p>I have an actor that is processing values and is then publishing the values with a Combine Publisher.</p>
<p>I have problems understanding actors, I thought when using actors in an async context, it would automatically be serialised. However, the numbers get processed in different orders and not in the expected order (see class tests for comparison).</p>
<p>I understand that if I would wrap Task around the for loop that then this would be returned serialised, but my understanding is, that I could call a function of an actor and this would then be automatically serialised.</p>
<p>How can I make my actor thread safe so it publishes the values in the expected order even if it is called from a different thread?</p>
<pre><code>import XCTest
import Combine
import CryptoKit

actor AddNumbersActor {
    private let _numberPublisher: PassthroughSubject&lt;(Int,String), Never&gt; = .init()
    nonisolated lazy var numberPublisher = _numberPublisher.eraseToAnyPublisher()
    
    func process(_ number: Int) {
            let string = SHA512.hash(data: Data(String(number).utf8))
                .description
            _numberPublisher.send((number, string))
    }
}

class AddNumbersClass {
    private let _numberPublisher: PassthroughSubject&lt;(Int,String), Never&gt; = .init()
    lazy var numberPublisher = _numberPublisher.eraseToAnyPublisher()
    
    func process(_ number: Int) {
            let string = SHA512.hash(data: Data(String(number).utf8))
                .description
            _numberPublisher.send((number, string))
    }
}


final class TestActorWithPublisher: XCTestCase {
    var subscription: AnyCancellable?
    override func tearDownWithError() throws {
        subscription = nil
    }

    func testActor() throws {
        let addNumbers = AddNumbersActor()
        var numbersResults = [(int: Int, string: String)]()
        let expectation = expectation(description: &quot;numberOfExpectedResults&quot;)
        let numberCount = 1000
        subscription = addNumbers.numberPublisher
            .sink { results in
                print(results)
                numbersResults.append(results)
                if numberCount == numbersResults.count {
                    expectation.fulfill()
                }
            }
        
        
        for number in 1...numberCount {
            Task {
                await addNumbers.process(number)
            }
        }
        wait(for: [expectation], timeout: 5)
        print(numbersResults.count)
        XCTAssertEqual(numbersResults[10].0, 11)
        XCTAssertEqual(numbersResults[100].0, 101)
        XCTAssertEqual(numbersResults[500].0, 501)
    }
    
    func testClass() throws {
        let addNumbers = AddNumbersClass()
        var numbersResults = [(int: Int, string: String)]()
        let expectation = expectation(description: &quot;numberOfExpectedResults&quot;)
        let numberCount = 1000
        subscription = addNumbers.numberPublisher
            .sink { results in
                print(results)
                numbersResults.append(results)
                if numberCount == numbersResults.count {
                    expectation.fulfill()
                }
            }
        for number in 1...numberCount {
            addNumbers.process(number)
        }
        wait(for: [expectation], timeout: 5)
        print(numbersResults.count)
        XCTAssertEqual(numbersResults[10].0, 11)
        XCTAssertEqual(numbersResults[100].0, 101)
        XCTAssertEqual(numbersResults[500].0, 501)
    }
}

``
</code></pre>
","8887336","","","","","2022-08-01 18:58:29","Understanding actor and making it thread safe","<swift><concurrency><actor><combine>","1","0","","","","CC BY-SA 4.0"
"73200317","1","73224761","","2022-08-01 22:50:18","","2","74","<p>I'm having a little trouble with the following pattern which integrates Combine publishers into SwiftUI so that view state is updated when publishers emit:</p>
<pre class=""lang-swift prettyprint-override""><code>struct ItemList: View {
    var publisher: AnyPublisher&lt;[Item], Never&gt;
    @State private var items = [Item]()

    var body: some View {
        List(items) { item in
            ItemRow(item: item)
        }
        .onReceive(publisher) {
            items = $0
        }
    }
}
</code></pre>
<p><a href=""https://www.swiftbysundell.com/tips/observing-combine-publishers-in-swiftui-views/"" rel=""nofollow noreferrer"">Above example from Swift by Sundell</a></p>
<p>I feel like I'm missing something when I read it.</p>
<p>Let's assume you initialize <code>items</code> to the correct (at that time) value. What ensures that the published value won't change between the creation of <code>ItemList</code> and the first call to <code>body</code>, where it first starts listening to changes? Or if there is no such guarantee, then what else is preventing the view from ending up in the wrong initial state because of this?</p>
","220820","","","","","2022-08-03 16:36:45","How does the pattern of assigning `@State` in `onReceive` ensure that view state is in sync?","<swiftui><combine>","2","3","","","","CC BY-SA 4.0"
"73232961","1","73233048","","2022-08-04 08:51:25","","-1","78","<p>Let's assume you have a publisher that returns a list of some entity. Let's say it comes from a use case that fetches something from an api</p>
<pre><code>protocol SomeAPI {
    func fetchSomeEntity() -&gt; AnyPublisher&lt;[SomeEntity], Error&gt;
}
</code></pre>
<p>Now you want to run some side effect on the output. Say, saving the result into a repository.</p>
<p>You would go with the <code>handleEvents</code> operator wouldn't you.</p>
<pre><code>    api.fetchSomeEntity().handleEvents(receiveOutput: {[unowned self] list in 
         repository.save(list) 
    })
</code></pre>
<p>But what if someone did that using/misusing the map operator:</p>
<pre><code>api.fetchSomeEntity().map { [unowned self] list in
   repository.save(list)
   return list
}
</code></pre>
<p>Would you say there's something fundamentally wrong with that approach or is it just another path to the same end?</p>
","5724584","","","","","2022-08-04 09:36:53","Swift Combine: handleEvents vs map","<swift><combine>","1","6","","","","CC BY-SA 4.0"
"73238670","1","","","2022-08-04 15:37:21","","0","62","<p>I am trying organize and design a Combine-based API framework for communicating and reacting to <a href=""http://obsproject.com"" rel=""nofollow noreferrer"">OBS Studio</a> (live-streaming software), using <a href=""https://github.com/obsproject/obs-websocket/"" rel=""nofollow noreferrer"">obs-websocket</a>. I've written my own Combine Subject-wrapped Publisher for WebSocket communication, and am now using <em>that</em> to talk with OBS. I've created Publishers for sending request messages to OBS, as well as listening for event messages emitted by OBS. I've also been developing this alongside an actual SwiftUI app that uses the new framework.</p>
<p>While developing the app, I found that there are some complex combinations of requests and event listeners that I would need to use around the app. So, as part of the framework, I built out a few Publishers that merge results from an initial request and event listeners for changes to those properties. Testing these out, they worked great, so I committed to git and attempted to implement them in my app code. Instead, they didn't work consistently. I realized that by using the same Publishers in multiple places of the app, it was creating duplicate Publishers (because almost all Publishers are structs/value-types).</p>
<p>So, I found an article about implementing the <code>.share()</code> operator (<a href=""https://www.swiftbysundell.com/articles/using-combines-share-operator-to-avoid-duplicate-work/"" rel=""nofollow noreferrer"">https://www.swiftbysundell.com/articles/using-combines-share-operator-to-avoid-duplicate-work/</a>) and I tried it out. Specifically, I set up a system for storing the different publishers that could be recalled while still active. Some of them are keyed by relevant values (like keying by the URL in the article), but others are just single values, as there wouldn't be more than one of that publisher at a time. That worked fine.</p>
<pre><code>class PublisherStore {
    typealias ResponsePublisher = AnyPublisher&lt;OBSRequestResponse, Error&gt;
    var responsePublishers = [String: ResponsePublisher]()
    
    typealias BatchResponsePublisher = AnyPublisher&lt;OpDataTypes.RequestBatchResponse, Error&gt;
    var batchResponsePublishers = [String: BatchResponsePublisher]()
    
    typealias EventPublisher = AnyPublisher&lt;OBSEvent, Error&gt;
    var eventPublishers = [OBSEvents.AllTypes: EventPublisher]()
    var eventGroupPublishers = [String: EventPublisher]()
    
    var anyOpCode: AnyPublisher&lt;UntypedMessage, Error&gt;? = nil
    var anyOpCodeData: AnyPublisher&lt;OBSOpData, Error&gt;? = nil
    var allMessagesOfType = [OBSEnums.OpCode: AnyPublisher&lt;OBSOpData, Error&gt;]()
    
    var studioModeState: AnyPublisher&lt;Bool, Error&gt;? = nil
    var currentSceneNamePair: AnyPublisher&lt;SceneNamePair, Error&gt;? = nil
    var sceneList: AnyPublisher&lt;[OBSRequests.Subtypes.Scene], Error&gt;? = nil
    var sceneItemList = [String: AnyPublisher&lt;[OBSRequests.Subtypes.SceneItem], Error&gt;]()
    var activeSceneItemList: AnyPublisher&lt;[OBSRequests.Subtypes.SceneItem], Error&gt;? = nil
    var sceneItemState = [String: AnyPublisher&lt;SceneItemStatePair, Error&gt;]()
}
</code></pre>
<p>Where I started running into issues is attempting to implement the final part of the article: adding a custom <code>DispatchQueue</code>. What's been confusing me is the placement of <code>subscribe(on:)</code>/<code>receive(on:)</code> operators, and which ones should be to <code>DispatchQueue.main</code> vs. my internal custom queue. Here's what I have in my primary chain that calls one of the custom merged Publishers:</p>
<pre><code>try connectToOBS()
    .handleEvents(receiveOutput: { _ in print(&quot;Main thread outside before?:&quot;, Thread.isMainThread) })
    // &lt;1&gt;
    .tryFlatMap { _ in try studioModeStatePublisher() } // &lt;- custom Publisher
    // &lt;2&gt;
    .handleEvents(receiveOutput: { _ in print(&quot;Main thread outside after?:&quot;, Thread.isMainThread) })
    .output(in: 0..&lt;4)
    .sink(receiveCompletion: { print(&quot;Sink completion:&quot;, $0); expectation1.fulfill() },
          receiveValue: { _ in })
    .store(in: &amp;observers)
</code></pre>
<p>I have <code>.receive(on: DispatchQueue.main)</code></p>
<p>Should I be placing <code>.receive(on: DispatchQueue.main)</code> at &lt;1&gt; or &lt;2&gt;? When I put it at &lt;2&gt; or leave it out, I don't get any print outs past the custom publisher. <strong>If I put it at &lt;1&gt;, it works, but is that the right way to do it?</strong> Here is the code for the custom publisher (sorry for it being a bit messy):</p>
<pre><code>public func getStudioModeStateOnce() throws -&gt; AnyPublisher&lt;Bool, Error&gt; {
    return try sendRequest(OBSRequests.GetStudioModeEnabled())
        .map(\.studioModeEnabled)
        // If error is thrown because studio mode is not active, replace that error with false
        .catch { error -&gt; AnyPublisher&lt;Bool, Error&gt; in
            guard case Errors.requestResponseNotSuccess(let status) = error,
                  status.code == .studioModeNotActive else { return Fail(error: error).eraseToAnyPublisher() }
            return Just(false)
                .setFailureType(to: Failure.self)
                .eraseToAnyPublisher()
        }
        .eraseToAnyPublisher()
}

public func studioModeStatePublisher() throws -&gt; AnyPublisher&lt;Bool, Error&gt; {
    // &lt;3&gt;
    if let pub = publishers.studioModeState {
        return pub
    }
    
    // Get initial value
    let pub = try getStudioModeStateOnce()
        // Merge with listener for future values
        .merge(with: try listenForEvent(OBSEvents.StudioModeStateChanged.self, firstOnly: false)
                .map(\.studioModeEnabled))
        .removeDuplicates()
        .receive(on: sessionQueue) // &lt;- this being what Sundell's article suggested.
        .handleEvents(receiveCompletion: { [weak self] _ in
            self?.publishers.studioModeState = nil
        })
        .share()
        .eraseToAnyPublisher()
    
    // &lt;4&gt;
    publishers.studioModeState = pub
    return pub
}
</code></pre>
<p>Calls at &lt;3&gt; and &lt;4&gt; probably need to be done on the <code>sessionQueue</code>. <strong>What would be the best practice for that?</strong> The deepest level of publisher that this relies on looks like this:</p>
<pre><code>try self.wsPublisher.send(msg, encodingMode: self.encodingProtocol)
    // &lt;5&gt;
    .eraseToAnyPublisher()
</code></pre>
<p><strong>Should I put</strong> <code>.receive(on: sessionQueue)</code> <strong>at &lt;5&gt;?</strong> Even when the tests work, I'm not sure if I'm doing it right. Sorry for such a long thing, but I tried to add as much detail as possible and tried to bold my questions. Any and all help would be welcomed, and I'd be happy to provide any extra details if needed. Thanks!</p>
<p><strong>Edit:</strong> I've realized that it was actually subscribing to the stored Publisher and would receive values if the value changed in OBS post-subscription. But the issue of receiving the most recent value is the issue. I replaced <code>.share()</code> with the <code>.shareReplay</code> idea from this article: (<a href=""https://www.onswiftwings.com/posts/share-replay-operator/"" rel=""nofollow noreferrer"">https://www.onswiftwings.com/posts/share-replay-operator/</a>). Again, it works in my testing (including delays in subscription), but still doesn't receive the most recent value when used in my SwiftUI app. Anyone have any ideas?</p>
","12847125","","12847125","","2022-08-06 20:10:50","2022-08-06 20:10:50","Where should I be placing subscribe(on:)/receive(on:) in my Combine chain? Also, storing .share() Publishers","<swift><thread-safety><scheduler><combine>","0","3","","","","CC BY-SA 4.0"
"73247043","1","","","2022-08-05 08:47:20","","0","77","<p>I'm trying to create a wrapper around a WKWebView for SwiftUI, and I'm not sure how to prevent a memory leak.</p>
<p>I've created an ObservableObject which handles controlling the WebView, and a custom view that displays it.</p>
<p>The web view needs to be able to communicate with JavaScript, so I've added an onAction() method which gets called when the WebView gets a javascript event.</p>
<pre class=""lang-swift prettyprint-override""><code>public class WebViewStore: ObservableObject {
    var webView: WKWebView = WKWebView()

    // List of event handlers that will be called from the WebView
    var eventHandlers: [String: () -&gt; Void] = [:]
    
    deinit {
        // This is never called once an action has been set with the view, 
        // and the content view is destroyed
        print(&quot;deinit&quot;)
    }
    
    // All the WebView code, including custom JavaScript message handlers, custom scheme handlers, etc...
    func reloadWebView() { }
}
</code></pre>
<p>View wrapper:</p>
<pre class=""lang-swift prettyprint-override""><code>struct WebView: NSViewRepresentable {
    let store: WebViewStore
    
    func makeNSView(context: Context) -&gt; WKWebView {
        return store.webView
    }
    
    func updateNSView(_ view: WKWebView, context: Context) {}
}

extension WebView {
    /// Action event called from the WebView
    public func onAction(name: String, action: @escaping () -&gt; Void) -&gt; WebView {
        self.store.eventHandlers[name] = action
        return self
    }
}
</code></pre>
<p>Usage that creates the retain cycle:</p>
<pre class=""lang-swift prettyprint-override""><code>struct ContentView: View {
    
    @StateObject var store = WebViewStore()
    
    var body: some View {
        VStack {
            // Example of interacting with the WebView
            Button(&quot;Reload&quot;) {
                store.reloadWebView()
            }
            
            WebView(store: store)
                // This action closure captures the WebViewStore, causing the retain cycle.
                .onAction(name: &quot;javascriptMessage&quot;) {
                    print(&quot;Event!&quot;)
                }
        }
    }
}
</code></pre>
<p>Is there a way to prevent the retain cycle from happening, or is there a different SwiftUI pattern that can to handle this use case? I can't use <code>[weak self]</code> because the view is a struct. I need to be able to receive events from the WebView and send them to SwiftUI and vice versa.</p>
","7117009","","","","","2022-08-05 08:47:20","How to avoid retain cycle in custom SwiftUI view closure","<swift><swiftui><closures><wkwebview><combine>","0","3","","","","CC BY-SA 4.0"
"73279525","1","73279688","","2022-08-08 14:28:38","","0","49","<p>I use a pattern like this for mocking:</p>
<pre><code>protocol Foo {
    func bar() -&gt; AnyPublisher&lt;Bool, Never&gt;
}

final class MockFoo: Foo {

    var barResult: Result&lt;Bool, Never&gt;?

    init(barResult: Result&lt;Bool, Never&gt;? = nil) {
        self.barResult = barResult
    }

    func bar() -&gt; AnyPublisher&lt;Bool, Never&gt; {
        switch barResult {
        case let .some(result):
            return result
                .publisher
                .eraseToAnyPublisher()
        case .none:
            return Empty&lt;Bool, Never&gt;()
                .eraseToAnyPublisher()
        }
    }
}
</code></pre>
<p>Which means I end up mapping a <code>Result?</code> to publisher. It is trivial but I type it so often that I am really tempted to make it generic in order to be able to just write this:</p>
<pre><code>func bar() -&gt; AnyPublisher&lt;Bool, Never&gt; {
    barResult.publisher
}
</code></pre>
<p>Unfortunately I am having problems with defining the extension on <code>Optional</code>. I need something roughly like this:</p>
<pre><code>extension Optional where Wrapped == Result&lt;Success,Failure&gt; {

    var publisher: AnyPublisher&lt;Success, Failure&gt; {
        switch self {
        case .none:
            return Empty&lt;Success, Failure&gt;()
                .eraseToAnyPublisher()
        case let .some(result):
            return result.publisher
                .eraseToAnyPublisher()
        }
    }

}
</code></pre>
<p>But the above won't compile. Is it possible? How to declare it so that the compiler understands?</p>
","7948372","","","","","2022-08-08 14:39:30","How to declare an extension on Optional where Wrapped is a Result?","<swift><generics><combine>","1","0","","","","CC BY-SA 4.0"
"73297313","1","73298040","","2022-08-09 19:46:37","","0","113","<p>I would like to pass a timer from <code>ContentView</code> to <code>SecondView</code>, but I don't know how to manage it because I never used it before.</p>
<p>Can someone figure this out for me?</p>
<h2>ContentView</h2>
<pre><code>struct ContentView: View {
    @State private var timer = Timer.publish(every: 1, tolerance: 0.5, on: .main, in: .common).autoconnect()
    @State private var timeRemaining = 10
    
    
    var body: some View {
        NavigationView {
            VStack {
                Text(&quot;\(timeRemaining)&quot;)
                    .onReceive(timer) { _ in
                        if timeRemaining &gt; 0 {
                            timeRemaining -= 1
                        }
                    }
                
                NavigationLink {
                    SecondView(timer: ???) // &lt;-- What should i pass here?
                } label: {
                    Text(&quot;Change View&quot;)
                }
            }
        }
    }
}
</code></pre>
<h2>SecondView</h2>
<pre><code>struct SecondView: View {
    @Binding var timer: ??? // &lt;-- What type?
    @State private var timeRemaining = 5
    
    var body: some View {
        Text(&quot;Hello&quot;)
            .onReceive(timer) { _ in
                if timeRemaining &gt; 0 {
                    timeRemaining -= 1
                }
            }
    }
}

struct SecondView_Previews: PreviewProvider {
    static var previews: some View {
        SecondView(timer: ???) // &lt;-- Same thing here in SecondView preview
    }
}
</code></pre>
","18758938","","6950415","","2022-08-09 21:05:06","2022-08-10 08:39:06","How can I pass Binding<Timer> in SwiftUI?","<ios><swift><swiftui><timer><combine>","3","2","","","","CC BY-SA 4.0"
"73313012","1","","","2022-08-10 21:39:12","","2","54","<p>I have a rather larger screen that I am building with SwiftUI and Combine. I am using MVVM with an <code>ObservableObject</code> object acting as the VM. The main view itself is composed of smaller child views, each of which have their own &quot;dummy&quot; view models (that are currently not <code>ObservableObject</code> but rather simply structs) that take in the model and format the data for the component. I have a few questions and I would be curious to hear the community's thoughts:</p>
<h3>1. Where should the child view models be stored?</h3>
<p>Currently, I expose the child view models as <code>@Published</code> within my main view model (let's call it <code>CheckoutViewModel</code>). I then have a Combine publisher inside <code>CheckoutViewModel</code> that does a few things and updates the VMs:</p>
<pre class=""lang-swift prettyprint-override""><code>class CheckoutViewModel: ObservableObject, Identifiable {
    
    // MARK: - Publishers
    
    @Published var detailsViewModel: DetailsViewModel?
    @Published var optionsListViewModel: OptionsListViewModel?
    // etc...
    
    // MARK: - Private Members

    private var subscriptions = Set&lt;AnyCancellable&gt;()    
    private let repository: CheckoutRepository // DI'd

    // MARK: - Actions

    func load(productId: String) {
       repository.fetchData(forProductId: productId)
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { product in
                   self.detailsViewModel = DetailsViewModel(fromProduct: product)
                   self.optionsListViewModel = OptionsListViewModel(fromProduct: product)
                }
            )
            .store(in: &amp;subscriptions)
    }
}
</code></pre>
<p>Within my <code>CheckoutView</code>, I then call <code>load</code> and have the child VMs passed to the child views:</p>
<pre class=""lang-swift prettyprint-override""><code>struct CheckoutView: View {
   @ObservedObject var viewModel: CheckoutViewModel

   var body: some View {
      VStack {
         if let detailsViewModel = viewModel.detailsViewModel {
            ProductDetails(viewModel: detailsViewModel)
         }

         if let optionsListViewModel = viewModel.optionsListViewModel {
            OptionsList(viewModel: optionsListViewModel)
         }
         
         // ... and so on
      }
   }
}
</code></pre>
<p>I am not sure if I love this approach. Something feels odd about publishing these child view models like this.</p>
<p><strong>Should each of these child view models be observable objects on their own that then communicate to the parent view model?</strong></p>
<p>As you can see, once you bring in user interactions (i.e. a user can select an option in the <code>OptionsList</code>), my current approach may fall somewhat short or become unmanageable the larger the view gets.</p>
<p>This leads me to my second question.</p>
<h3>2. Who should own the state? How should user interactions be facilitated?</h3>
<p>As you can imagine, state in this case becomes very important, and with something like a checkout screen, there may be a lot of state to track. This is where I am totally lost currently. With this approach, I know I can store state directly in <code>CheckoutViewModel</code>, but it may just end up becoming too large and cumbersome to work with.</p>
<p>To deal with user interactions, I've tried passing down bindings directly to the child views and go from there, but that circumvents the child view models and &quot;clutters&quot; <code>CheckoutViewModel</code> with a bunch of state variables (that seems like they should be part of a model, not the view model).</p>
<p>Another approach was using closures in the child views, e.g. if the user selects a new option from <code>OptionsList</code>, call a closure with the option ID and then call the main view model from the view to update the state - but that seemed super cumbersome and I kept thinking there must be a better way to do this.</p>
<p>Maybe some sort of store or similar would be a good idea? I am trying to get an idea of best practices for how child views/child VMs should communicate with their parent.</p>
<h3>Conclusion</h3>
<p>As you can probably tell, I am a bit lost about proper state management and how to deal with child views using MVVM in SwiftUI. Any guidance or general ideas/suggestions would be greatly appreciated. Is using MVVM in SwiftUI maybe a bad idea in general? As anyone else done something similar, or am I on the completely wrong path here?</p>
","15184999","","","","","2022-08-10 21:39:12","Child view-models state management with SwiftUI and Combine","<swift><mvvm><swiftui><combine>","0","4","2","2022-08-13 17:08:22","","CC BY-SA 4.0"
"73330179","1","73330281","","2022-08-12 06:43:41","","3","56","<p>Right now, I've been running into an issue of registering protocol conforming to <code>ObservableObject</code>. Since <code>ObservableObject</code> uses an associated type, I cannot find a way to register it without compiling error.</p>
<p>This is my simple model, called A</p>
<pre><code>protocol A: ObservableObject {}
</code></pre>
<p>This is my simple class, called B</p>
<pre><code>final class B: A {}
</code></pre>
<p>Here is my Assembly</p>
<pre><code>final class ViewStoreAssembly: Assembly{
    func assemble(container: Container) {
        container.register(A.self) { _ in
            B()
        }
    }
}
</code></pre>
<p>I'm trying to register A comforming to ObservableObject, but the compilation error shows that</p>
<blockquote>
<p>Protocol 'A' can only be used as a generic constraint because it has
Self or associated type requirements</p>
</blockquote>
<p>Does anyone know how to tackle the issue? The benefits of doing this will be</p>
<ol>
<li>In SwiftUI, we can decouple view out of ViewStore/presenter so that view can be separated from viewModel holder</li>
<li>ViewStore/Presenter can be tested easily by mocking a view</li>
</ol>
","10344746","","","","","2022-08-12 06:53:30","How to use Swinject to register protocol conforming to ObservableObject?","<swift><swiftui><protocols><combine><swinject>","1","0","","","","CC BY-SA 4.0"
"73337546","1","","","2022-08-12 16:59:46","","0","45","<p>I've recently faced an issue with CombineLatest reporting one of it's values incorrectly. This is hard to reproduce, yet it is reproducible.</p>
<p>Setup:</p>
<pre><code>let onFirst = CurrentValueSubject&lt;Bool, Never&gt;(false)
let onSecond = CurrentValueSubject&lt;Bool, Never&gt;(false)

onFirst
    .sink { value in print(&quot;Single: first: \(value)&quot;) }
     ...

onSecond
    .sink { value in print(&quot;Single: second: \(value)&quot;) }
     ...

Publishers.CombineLatest(onFirst, onSecond)
     .handleEvents(receiveOutput: { print(&quot;CombineLatest: first: \($0); second: \($1)&quot;) })
     ...
</code></pre>
<p>At some point new values are published to both onFirst and onSecond. This produces following output:</p>
<p>2022-08-12 11:31:28.650 &gt; will invoke onFirst.send(true)</p>
<p>2022-08-12 11:31:28.650 &gt; will invoke onSecond.send(true)</p>
<p><strong>2022-08-12 11:31:28.650 Single: first: true</strong></p>
<p><strong>2022-08-12 11:31:28.650 Single: second: true</strong></p>
<p><strong>2022-08-12 11:31:28.650 CombineLatest: first: true; second: false</strong></p>
<p>Values are emitted only once and looking at individual subscriptions they report correct value. However combineLatest does not:</p>
<ul>
<li>i'd expect it would print twice (since since both values changed)</li>
<li>i'd expect that final result is (true, true) since both sub publishers reported true</li>
</ul>
<p>No idea where the combineLatest second value ('false') value comes from. Any clues?
Both onFirst and onSecond is likely invoked from separate threads and combineLatest may operate on any thread as well. But as far as I understand combineLatest is thread safe (..). Since all these events occur almost simultaneously there must be some race condition? I've tried adding 'subscribe(on) and observer(on)' on the same queue but it doesn't resolve this. Am I misunderstanding something about CombineLatest?</p>
<p>UPDATE:</p>
<p>I've found this post: <a href=""https://stackoverflow.com/questions/60527631/swift-combine-publishers-combinelatest-on-multiple-threads"">Swift Combine - Publishers.CombineLatest on multiple Threads</a></p>
<p>Created unit test, consider 2x cases:</p>
<ol>
<li>no synchronization<br>
<strong>Publishers.CombineLatest(onFirst, onSecond)</strong></li>
</ol>
<p>--------- Post<br>
post first: true<br>
post second: true<br>
received: true true<br>
received: true false<br></p>
<ol start=""2"">
<li>synchronized<br>
<strong>Publishers.CombineLatest(first.receive(on: queue), second.receive(on: queue))</strong></li>
</ol>
<p>--------- Post<br>
post first: false<br>
post second: false<br>
received: false true<br>
received: false false<br></p>
<p>I thought CombineLatest is thread safe (i.e. does not matter which thread emits values, CombineLatest serializes processing). This seems not true. As consequence, CombineLatest either does not emit all changes, or emits incorrect values. I would appreciate someone clarifying...</p>
","2546164","","2546164","","2022-08-12 18:17:52","2022-08-12 18:17:52","Publishers.CombineLatest - Incorrect Value","<swift><race-condition><combine><combinelatest>","0","2","","","","CC BY-SA 4.0"
"73338499","1","","","2022-08-12 18:40:14","","0","32","<p>I have following APILoader struct in my network layer.</p>
<pre><code>struct APILoader&lt;T: APIHandler&gt; {
    
    var apiHandler: T
    var urlSession: URLSession
    
    init(apiHandler: T, urlSession: URLSession = .shared) {
        self.apiHandler = apiHandler
        self.urlSession = urlSession
    }

func loadAPIRequest(requestData: T.RequestDataType) -&gt; AnyPublisher&lt;T.ResponseDataType, Error&gt; {
        
        guard let urlRequest = apiHandler.makeRequest(from: requestData) else {
            return Result&lt;T.ResponseDataType, Error&gt;.failure(NSError(domain: &quot;&quot;, code: -1, userInfo: [&quot;dte&quot;:1])).publisher.eraseToAnyPublisher()
        }
        
        return urlSession.dataTaskPublisher(for: urlRequest)
            .map() {
                $0.data
            }
            .decode(type: T.ResponseDataType.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
}
}
</code></pre>
<p>When I use <code>urlSession</code> struct property to call <code>dataTaskPublisher(for: urlRequest)</code> method, it's not working. But this is working for non combine traditional API calls.
When I use instance variable of <code>URLSession.shared</code> like follows, it's start working.</p>
<pre><code>return URLSession.shared.dataTaskPublisher(for: urlRequest)
.map() {
                $0.data
            }
            .decode(type: T.ResponseDataType.self, decoder: JSONDecoder())
            .receive(on: RunLoop.main)
            .eraseToAnyPublisher()
</code></pre>
<p>Following code shows how I init the APILoader and call the web service.</p>
<pre><code>func getData() {
        let request = TopStoriesService()
        let params = [Params.kApiKey.rawValue : CommonUtil.shared.NytApiKey()]
        let apiLoader = APILoader(apiHandler: request)
        apiLoader.loadAPIRequest(requestData: params)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { res in
                print(&quot;\(res)&quot;)
            })
            
    }
</code></pre>
<p>Can anyone explain what I'm missing here?</p>
","2876009","","2876009","","2022-08-13 05:25:02","2022-08-13 08:41:14","URLSession.shared struct property isn't working for Combine API call","<swift><api><combine><urlsession><nsurlsessiondatatask>","1","2","","","","CC BY-SA 4.0"
"73352258","1","","","2022-08-14 14:00:10","","0","35","<p>I want to develop AVPlayerItem observers using combine. I found a <a href=""https://stackoverflow.com/questions/60646857/swiftui-combine-for-onreceive-notifications-with-avplayer"">Example</a> code using <strong>PassthroughSubject</strong> but this is not what I'm looking for I want more generic way of doing it.</p>
","19762317","","","","","2022-08-14 14:00:10","How to develop AVPlayerItem observers using Combine","<ios><swift><avplayer><combine><avplayeritem>","0","2","","","","CC BY-SA 4.0"
"73369560","1","73389622","","2022-08-16 06:19:56","","0","45","<p>I'm observing a textfield using combine like this.</p>
<pre class=""lang-swift prettyprint-override""><code>extension UITextField {

    var textPublisher: AnyPublisher&lt;String, Never&gt; {
        NotificationCenter.default.publisher(
            for: UITextField.textDidChangeNotification,
            object: self
        )
        .compactMap { ($0.object as? UITextField)?.text }
        .eraseToAnyPublisher()
    }

}
</code></pre>
<p>(source code from <a href=""https://cocoacasts.com/combine-fundamentals-observing-a-text-field-with-combine"" rel=""nofollow noreferrer"">https://cocoacasts.com/combine-fundamentals-observing-a-text-field-with-combine</a>)</p>
<p>And I have a button that make textfield's text nil when pressed.<br />
<code>textPublisher</code> detect keyboard input very well, but when the button is pressed, it doesn't publish anything.</p>
<p>How can I detect the textfield's change when the button pressed?</p>
","17137933","","","","","2022-08-17 13:46:48","How to detect the change of UITextField when the button tapped","<ios><swift><uitextfield><combine>","1","2","","","","CC BY-SA 4.0"
"73390131","1","","","2022-08-17 14:20:11","","0","25","<p>I want to keep track of my UserDefaults in my View model. To retrieve and add from my UserDefault, I currently do this.</p>
<pre><code>extension UserDefaults {
    
    var ratedProducts: [Product] {
        get {
            guard let data = UserDefaults.standard.data(forKey: &quot;ratedProducts&quot;) else { return [] }
            return (try? PropertyListDecoder().decode([Product].self, from: data)) ?? []
        }
        set {
            UserDefaults.standard.set(try? PropertyListEncoder().encode(newValue), forKey: &quot;ratedProducts&quot;)
        }
    }
}
</code></pre>
<p>But now what I want to do is, having a published computed property in my View model that keeps track whenever an object is added. Which then should trigger an update in my progress bar within my view. How would I setup this property properly?</p>
<p>I thought of something like this. (Obviously this doesnt work)</p>
<pre><code>@Published var ratedProducts: [Product] {
        ratedProducts = UserDefaults.standard.ratedProducts
}
</code></pre>
<p>Thanks for any help!</p>
","17299448","","","","","2022-08-17 14:20:11","Setup UserDefaults property as Published property in View Model","<swift><swiftui><combine><userdefaults>","0","6","","2022-08-17 14:24:23","","CC BY-SA 4.0"
"73391756","1","73392757","","2022-08-17 16:13:18","","1","53","<p>I try to observe my array of custom objects in my UserDefaults using a <code>Combine</code> publisher.</p>
<p>First my extension:</p>
<pre><code>extension UserDefaults {
    
    var ratedProducts: [Product] {
        get {
            guard let data = UserDefaults.standard.data(forKey: &quot;ratedProducts&quot;) else { return [] }
            return (try? PropertyListDecoder().decode([Product].self, from: data)) ?? []
        }
        set {
            UserDefaults.standard.set(try? PropertyListEncoder().encode(newValue), forKey: &quot;ratedProducts&quot;)
        }
    }
}
</code></pre>
<p>Then in my View model, within my <code>init()</code> I do:</p>
<pre><code>UserDefaults.standard
                    .publisher(for: \.ratedProducts)
                    .sink { ratedProducts in
                        self.ratedProducts = ratedProducts
                    }
                    .store(in: &amp;subscriptions)
</code></pre>
<p>You can see that I basically want to update my <code>@Published</code> property <code>ratedProducts</code> in the sink call.</p>
<p>Now when I run it, I get:</p>
<blockquote>
<p>Fatal error: Could not extract a String from KeyPath
Swift.ReferenceWritableKeyPath&lt;__C.NSUserDefaults,
Swift.Array&lt;RebuyImageRating.Product&gt;&gt;</p>
</blockquote>
<p>I think I know that this is because in my extension the ratedProduct property is not marked as <code>@objc</code>, but I cant mark it as such because I need to store a custom type.</p>
<p>Anyone know what to do?</p>
<p>Thanks</p>
","17299448","","6950415","","2022-08-17 17:32:36","2022-08-17 17:37:37","Fatal error when publishing UserDefaults with Combine","<swift><swiftui><combine><userdefaults>","1","3","","","","CC BY-SA 4.0"
"73433738","1","","","2022-08-21 10:54:54","","0","18","<p>I develop a project which utilizes a dynamic data structure (tree-like). Both number of nodes in the structure change over time as well as data that is kept in the nodes. Some properties affect other - both within a certain node but also inside parent/children.</p>
<p>I've managed to get to the point where changes propagate correctly but a problem arose. The piece of code which sets up subscriptions and contains logic of propagation is a complete mess - due to the fact that I nest subscriptions set up. I'm new to the Combine framework so probably I don't know how to use it correctly. I'm hoping to get a suggestion.</p>
<p>Story that hopefully illustrate the problem</p>
<blockquote>
<p>Imagine that you have a tree and if you subscribe to a node's data
stream you are going to receive data from the node itself as well as
from its ancestors. The problem is that in order to get a data from
one subject you must go through a different one.</p>
</blockquote>
<p>Code ready for copying and pasting to the playground:</p>
<pre class=""lang-swift prettyprint-override""><code>//
//  Copyright © 2021 Mateusz Stompór. All rights reserved.
//

import Combine

// Helper

struct WeakRef&lt;T: AnyObject&gt; {
    weak var reference: T?
    init(_ reference: T?) {
        self.reference = reference
    }
}

// Parent is observable in order to react for change

class Node&lt;T&gt; {
    let data: T
    var parent: CurrentValueSubject&lt;WeakRef&lt;Node&gt;, Error&gt;
    let stream: CurrentValueSubject&lt;T, Error&gt;
    private var parentSubscription: AnyCancellable?
    private var parentStreamSubscription: AnyCancellable?
    init(data: T, parent: Node?) {
        self.data = data
        self.parent = CurrentValueSubject(WeakRef(parent))
        self.stream = CurrentValueSubject(data)
        setup()
    }
    func setup() {
        parentSubscription = parent.compactMap({ $0.reference?.stream }).sink(receiveCompletion: { [weak self] _ in
            self?.parentStreamSubscription?.cancel()
        }, receiveValue: { [weak self] stream in
            self?.parentStreamSubscription = stream.sink { _ in
                // Nothing needed
            } receiveValue: { value in
                guard let self = self else {
                    return
                }
                self.stream.send(value)
            }
        })
    }
}

let parent = Node(data: 2, parent: nil)
let child = Node(data: 1, parent: nil)

let subscription = child.stream.sink { _ in
    // nothing needed
} receiveValue: { value in
    print(value)
}

// '1' is printed right away

// Setup connection
child.parent.send(WeakRef(parent))


// '2' is printed once connection is set

parent.stream.send(3)

// '3' is printed

// Changing child's parent
let newParent = Node(data: 4, parent: nil)
child.parent.send(WeakRef(newParent))
// '4' is printed as parent change

parent.stream.send(5)
// '5' is NOT printed, node is no longer part of the tree

newParent.stream.send(6)
// '6' is printed
</code></pre>
<p>The core question: is there a way to avoid this kind of nesting?</p>
","6091011","","13302","","2022-08-21 11:48:46","2022-08-21 11:48:46","Handling dependencies between subjects in a manageable way","<coding-style><combine>","0","0","","","","CC BY-SA 4.0"
"73441509","1","","","2022-08-22 07:25:26","","0","86","<p>I need to implement repeat if with delay custom publisher for Swift Combine. The purpose of it is to repeatedly poll backend endpoint with delay set from previous response.  It could be long polling (max 5min. with 3 - 6sec time period).  I tried to use recursive approach, but it is not working consistelty. It makes from 20 to 200 repeats randomly, and then there is fired finished on the former/first subsciption and rest of the subscrptions are finished also. Count of repeats probably depends on memory situation etc.. Any coments or hints how to implement described functionality in reactive way are welcome.</p>
<p>Playground: git@github.com:BenBella/repeatif-publisher-playground.git</p>
<pre><code>enum CustomPublishers { }

extension CustomPublishers {
    struct RepeatIf&lt;Upstream: Publisher&gt;: Publisher {
        typealias Output = Upstream.Output
        typealias Failure = Upstream.Failure

        init(
            upstream: Upstream, shouldRepeat: @escaping (Upstream.Output) -&gt; Bool,
            withDelay: @escaping (Upstream.Output) -&gt; Int
        ) {
            self.upstream = upstream
            self.shouldRepeat = shouldRepeat
            self.withDelay = withDelay
        }

        var upstream: Upstream
        var shouldRepeat: (Upstream.Output) -&gt; Bool
        var withDelay: (Upstream.Output) -&gt; Int

        func receive&lt;Downstream: Subscriber&gt;(subscriber: Downstream) where Failure == Downstream.Failure, Output == Downstream.Input {
            upstream
                .print(&quot;CustomPublishers.RepeatIf(1)&gt;&quot;)
                .flatMap { output in
                    Just((output)).setFailureType(to: Downstream.Failure.self)
                        .delay(for: .seconds(withDelay(output)),
                               scheduler: DispatchQueue.global())
                }
                .flatMap { output in
                    shouldRepeat(output)
                    ? Self(upstream: upstream, shouldRepeat: shouldRepeat, withDelay: self.withDelay)
                        .eraseToAnyPublisher()
                    : Just((output)).setFailureType(to: Downstream.Failure.self)
                        .eraseToAnyPublisher()
                }
                .catch { (error: Upstream.Failure) -&gt; AnyPublisher&lt;Output, Failure&gt; in
                    return Fail(error: error).eraseToAnyPublisher()
                }
                .print(&quot;CustomPublishers.RepeatIf(2)&gt;&quot;)
                .receive(subscriber: subscriber)
        }
    }
}
</code></pre>
<p>I was able to implement desired functionality with different approach, but I am still interested in any comments regarding to why recursive flatMap doesn't work. Thank you</p>
<p>Working solution:</p>
<pre><code>func retryRequestWithDelay(url: URL) -&gt; AnyPublisher&lt;Response&gt;, AppError&gt; {
        let pollPublisher = CurrentValueSubject&lt;Int, AppError&gt;(0)
        return pollPublisher.compactMap { [weak self] delay in
            return self?.networkingService.request(url)
                .delay(for: .seconds(delay), scheduler: DispatchQueue.global())
        }
        .switchToLatest()
        .receive(on: DispatchQueue.main)
        .handleEvents(receiveOutput: { [weak self] (response: Response) in
            guard let self = self else { return }
            if response.status == .pending {
                self.pollPublisher.send(response.pollPeriod)
            } else {
                self.pollPublisher.send(completion: .finished)
            }
        })
        .filter { (response: Response) in
            guard response.data.status == .pending else { return true }
            return false
        }
        .eraseToAnyPublisher()
    }
</code></pre>
","5524314","","5524314","","2022-08-23 09:25:35","2022-08-23 17:16:05","Swift combine repeat if (with delay) custom publisher","<swift><recursion><reactive-programming><combine>","1","1","","","","CC BY-SA 4.0"
"73444406","1","73444492","","2022-08-22 11:33:00","","-2","34","<p>Swift, Combine: Is <code>@Published</code> key word for multiple lines? Is it applicable for more than one property?</p>
<p>Example:</p>
<pre><code>import Combine

final class Demo: ObservableObject {
    @Published
    var value1: Int?
    var value2: Double?
}
</code></pre>
<p>This is a valid code.
Question: Is @Published applied to value1 and value2? Or only for value1?
Is it one-liner?</p>
","5449670","","12299030","","2022-08-22 11:46:17","2022-08-22 11:46:17","Swift, Combine: Is @Published key word for multiple lines?","<swift><combine>","1","1","","","","CC BY-SA 4.0"
"73445948","1","73658542","","2022-08-22 13:29:35","","1","64","<p>I have a class that I want subscribe by multiple subscribers. How can I achieve something like this (consider as pseudo code)? Does it possible to implement such events easily without implementing manually Subscription, Publisher with lots of code?</p>
<p>In short, it should be upgraded Delegate pattern. And it could handle Void events potentially. Just creating a Published property of type ([Item], [Item]) is not the case because event with the same repeated data can be sent one by one.</p>
<pre><code>class SomeObservedClass: ObservableObject {
    //???
}

//We will have multiple listeners like this
class SomeListener1 {
    @Published var observedClass: SomeObservedClass
    
    init() {
        observedClass = .init()
        
        //Maybe something like this
        observedClass
            .publisher(for: .listChanged)
            .sink { (addingItems: [Item], removingItems: [Item]) in
                //Processing data
            }
            .store(in: &amp;cancellable)
        
        //Or something like this maybe
        observedClass
            .onReceive(.listChanged) { (addingItems: [Item], removingItems: [Item]) in
                //Processing data
            }
    }
}
</code></pre>
","7147231","","7147231","","2022-08-22 14:08:47","2022-09-09 07:12:25","How to create and emit custom event with Combine and Swift?","<swift><combine>","1","2","","","","CC BY-SA 4.0"
"73459298","1","73459574","","2022-08-23 13:07:08","","3","88","<p>I recently worked on SwiftUI and starting writing code in a declarative way. But here comes a confusion. Like what is shown below, I want to (1)load the song data and (2)show the view by setting <code>isInfoViewShown</code>, after <code>song</code> is assigned to any value.</p>
<p>I assume <code>didSet{}</code> and <code>Combine @Published .sink{}</code> are doing things interchangeably. So I want to ask what are the differences between them? And in my own opinion, <code>didSet{}</code> can do most of jobs <code>Combine</code> do. So why should Apple announce <code>Combine</code> framework?</p>
<p>Any help is appreciated.</p>
<pre><code>class InfoViewModel: ObservableObject {
    
    @Published var song: Song? {
        didSet {                      // Here's the didSet{}: [1] load song data
            if let song = song {
                load(song: song)
            }
        }
    }
    
    private var songSelectedSubscription: AnyCancellable?
    
    @Published var isInfoViewShown: Bool = false

    init() {                          // Here's the Combine @Published .sink{}: [2] show the view
        songSelectedSubscription = $song.sink{ self.isInfoViewShown = ($0 == nil ? false : true) }              
    }
}
</code></pre>
","19681631","","19681631","","2022-08-23 13:52:06","2022-08-23 15:48:23","What's the differences between `Combine` and `didSet` in Swift?","<swift><swiftui><combine>","2","4","","","","CC BY-SA 4.0"
"73475693","1","","","2022-08-24 15:14:56","","0","19","<p>I have a PDFThumbnailView that is used with a  PageViewController (That host a PDFView as a subview).</p>
<p>For a very specific case, I would like to detect any Index Change from PDFThumbnailView in order to change the PageViewController accordingly.</p>
<p>I am aware that when PDFThumbnailView is linked to a PDFView we can listen <strong>to Notifications from PDFView Page Changes</strong>, but this is not what I want. I just want an event from PDFThumbnailView. The goal is to use that for actioning something outside PDFView.</p>
<p>I tried to use Combine or Classic Observer to observe any property from PDFThumbnailView but none seem to work.</p>
<pre><code>     let observation = observe(
            \.pdfThumbnailView.selectedPages, // or any other property
                  options: [.old, .new]
          ) { object, change in
               print(&quot;new change: \(change.oldValue?.debugDescription ?? &quot;&quot;), updated to: \(change.newValue?.debugDescription ?? &quot;&quot;)&quot;)
}
</code></pre>
<p>Is there a way to observe page index change within the PDFThumbnailView (and not wait any PDFView linked PDFThumbnailView to get the Page Event)?</p>
<p>I did search a bit everywhere, but no result so far.</p>
","2014650","","","","","2022-08-24 15:14:56","How to detect Page Change only within the ThumnailView (but not listen PDFPageView Change)","<ios><swift><combine><ios-pdfkit>","0","1","","","","CC BY-SA 4.0"
"73489950","1","","","2022-08-25 15:11:36","","0","42","<p>I am following this tutorial (<a href=""https://peterfriese.dev/posts/replicating-reminder-swiftui-firebase-part2/#making-the-task-repository-user-aware"" rel=""nofollow noreferrer"">https://peterfriese.dev/posts/replicating-reminder-swiftui-firebase-part2/#making-the-task-repository-user-aware</a>) to create a similar app connected to firebase firestore and firebase auth.</p>
<p>I want to enable the user to change their display name via Firebase SDK. The problem is, that the updated user object does not get published - hence the new display name only shows after restarting the app. Here's the relevant code:</p>
<p><strong>AuthenticationService.swift</strong></p>
<pre><code>class AuthenticationService: ObservableObject {

@Published var user: User?
...

func updateDisplayName(displayName: String, completionHandler: @escaping (Result&lt;User, Error&gt;) -&gt; Void) {
      if let user = Auth.auth().currentUser {
        let changeRequest = user.createProfileChangeRequest()
        changeRequest.displayName = displayName
        changeRequest.commitChanges { error in
          if let error = error {
            completionHandler(.failure(error))
          }
          else {
            if let updatedUser = Auth.auth().currentUser {
              print(&quot;Successfully updated display name for user [\(user.uid)] to [\(updatedUser.displayName ?? &quot;(empty)&quot;)]&quot;)
              // force update the local user to trigger the publisher -&gt; NOT WORKING 
              self.user = updatedUser
              completionHandler(.success(updatedUser))
            }
          }
        }
      }
    }
}
</code></pre>
<p>** ViewModel.swift **</p>
<pre><code>class ViewModel: ObservableObject {
    
    @Injected var authenticationService: AuthenticationService
    
    var userId: String = &quot;unknown&quot;
    var username: String = &quot;unknown&quot;
    private var cancellables = Set&lt;AnyCancellable&gt;()
    
    init() {
        
        authenticationService.$user
            .compactMap { user in
                user?.displayName
            }
            .assign(to: \.username, on: self)
            .store(in: &amp;cancellables)
        
        authenticationService.$user
            .compactMap { user in
                user?.email
            }
            .assign(to: \.userId, on: self)
            .store(in: &amp;cancellables)
        
        
        // (re)load data if user changes
        authenticationService.$user
            .receive(on: DispatchQueue.main)
            .sink { user in
                self.fetchPrivateNotes()
                self.fetchSharedNotes()
            }
            .store(in: &amp;cancellables)
    }
}
</code></pre>
<p>I expect the attribute username in ViewModel.swift to be updated with the new display name, so any views that bind to that published attribute show it immediately.</p>
","13121089","","209103","","2022-08-25 15:30:38","2022-08-25 15:30:38","Swift UI combine not publishing changes","<ios><swift><firebase-authentication><combine>","0","4","","","","CC BY-SA 4.0"
"73493856","1","","","2022-08-25 21:24:59","","0","42","<p>From the documentation</p>
<p><code>An AnyCancellable instance automatically calls cancel() when deinitialized.</code></p>
<p>Yet in the following code</p>
<pre><code>    var cancellable: AnyCancellable?

    let subject: PassthroughSubject&lt;Int, Never&gt;? = PassthroughSubject&lt;Int, Never&gt;()

    cancellable = subject?.sink(receiveValue: {
        print(&quot;-&gt; sending to cancellable \($0)&quot;)
    })

    print(&quot;send 1&quot;)
    subject?.send(1)


    // documentation states &quot;An AnyCancellable instance automatically calls cancel() when deinitialized.&quot;
    print(&quot;cancellable nil'd&quot;)
    cancellable = nil

    print(&quot;send 2&quot;)
    subject?.send(2)

    print(&quot;send 3&quot;)
    subject?.send(3)

    DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(1)) {
        print(&quot;done&quot;)
    }

/*
send 1
-&gt; sending to cancellable 1
cancellable nil'd
send 2
-&gt; sending to cancellable 2
send 3
-&gt; sending to cancellable 3
done
*/
</code></pre>
<p>Shows that nil'ing cancellable does not stop the subscriber from getting values.</p>
<p>While using a Set and removing all or nil'ing the set will stop the subscriptions. I even tried throwing everything into an autoreleasepool and it didn't do anything. Is the AnyCancellable in the code not getting deinitialized? Is something hanging on to it?</p>
<p><a href=""https://ufile.io/4lg1m4fs"" rel=""nofollow noreferrer"">Test Playground</a></p>
","465446","","465446","","2022-08-25 21:53:11","2022-08-25 22:51:38","Nil'ing AnyCancellable not cancelling subscription","<swift><combine><cancellation><anycancellable>","1","7","","","","CC BY-SA 4.0"
"73496067","1","73496220","","2022-08-26 04:22:49","","1","43","<p>I find myself wanting the same functionality in Combine quite often, so I wanted to make a convenience method like so...</p>
<pre><code>public extension Published.Publisher {
    func sinkChanges(receiveValue: @escaping (Self.Output) -&gt; Void) -&gt; AnyCancellable {
        self.dropFirst()
            .removeDuplicates()
            .sink(receiveValue: closure)
    }
}
</code></pre>
<p>However I'm pretty new to the syntax and I get the error</p>
<p><code>Referencing instance method 'removeDuplicates()' on 'Publisher' requires that 'Publishers.Drop&lt;Published&lt;Value&gt;.Publisher&gt;.Output' (aka 'Value') conform to 'Equatable' </code></p>
<p>I understand why and what I have to do, just no idea syntactically where it goes...</p>
<p>My best guess so far was
<code>public extension Published.Publisher where Output: Equatable {</code>
but it didn't like that... what should I be searching for?</p>
","3624478","","3515033","","2022-08-26 04:23:46","2022-08-26 04:53:38","convenience method for combine publishers","<ios><swift><monads><combine>","1","3","","","","CC BY-SA 4.0"
"73516303","1","73520482","","2022-08-28 05:44:44","","2","94","<p>Here is a debounce example:</p>
<p>Data within half a second will be discarded.</p>
<pre class=""lang-swift prettyprint-override""><code>let bounces:[(Int,TimeInterval)] = [
    (0, 0),
    (1, 0.25),  // 0.25s interval since last index
    (2, 1),     // 0.75s interval since last index
    (3, 1.25),  // 0.25s interval since last index
    (4, 1.5),   // 0.25s interval since last index
    (5, 2)      // 0.5s interval since last index
]

let subject = PassthroughSubject&lt;Int, Never&gt;()
cancellable = subject
    .debounce(for: .seconds(0.5), scheduler: RunLoop.main)
    .sink { index in
        print (&quot;Received index \(index)&quot;)
    }

for bounce in bounces {
    DispatchQueue.main.asyncAfter(deadline: .now() + bounce.1) {
        subject.send(bounce.0)
    }
}

// Prints:
//  Received index 1
//  Received index 4
//  Received index 5
</code></pre>
<p>But I want to combine these discarded data, My expected result is:</p>
<pre><code>// Prints:
//  Received index [0, 1]
//  Received index [2, 3, 4]
//  Received index [5]
</code></pre>
<p>Any help?</p>
","15574419","","","","","2022-08-28 16:45:02","Swift combine debounce without dropping values","<swift><combine><debounce>","2","0","","","","CC BY-SA 4.0"
"73524259","1","73525005","","2022-08-29 04:53:47","","0","54","<p>I have a movie listing view with basic listing functionality, Once pagination reaches to the last page I want to show an alert for that I am using <code>reachedLastPage</code> property.</p>
<p>The <code>viewModel.state</code> is an enum, the case movies has associated value in which there is <code>moreRemaining</code> property which tells if there are more pages or not.</p>
<p>Once the <code>moreRemaining</code> property becomes false I want to make <code>reachedLastPage</code> to true so that I can show an alert.</p>
<p>How can I achieve this in best way?</p>
<pre class=""lang-swift prettyprint-override""><code>import SwiftUI
import SwiftUIRefresh

struct MovieListingView&lt;T&gt;: View where T: BaseMoviesListViewModel {
  
  @ObservedObject var viewModel: T
  @State var title: String
  @State var reachedLastPage: Bool = false
  
  var body: some View {
    NavigationView {
      ZStack {
        switch viewModel.state {
        case .loading:
          LoadingView(title: &quot;Loading Movies...&quot;)
            .onAppear {
              fetchMovies()
            }
        case .error(let error):
          ErrorView(message: error.localizedDescription, buttonTitle: &quot;Retry&quot;) {
            fetchMovies()
          }
        case .noData:
          Text(&quot;No data&quot;)
            .multilineTextAlignment(.center)
            .font(.system(size: 20))
        case .movies(let data):
          List {
            ForEach(data.movies) { movie in
              NavigationLink(destination: LazyView(MovieDetailView(viewModel: MovieDetailViewModel(id: movie.id)))) {
                MovieViewRow(movie: movie)
                  .onAppear {
                    if movie == data.movies.last &amp;&amp; data.moreRemaining {
                      DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                        fetchMovies()
                      }
                    }
                  }
              }
              if movie == data.movies.last &amp;&amp; data.moreRemaining {
                HStack {
                  Spacer()
                  ActivityIndicator(isAnimating: .constant(data.moreRemaining))
                  Spacer()
                }
              }
            }
          }.pullToRefresh(isShowing: .constant(data.isRefreshing)) {
            print(&quot;Refresheeeee&quot;)
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
              refreshMovies()
            }
          }
        }
      }
      .navigationViewStyle(.stack)
      .navigationBarTitle(&quot;\(title)&quot;, displayMode: .inline)
      .alert(isPresented: $reachedLastPage) {
        Alert(title: Text(&quot;You have reached to the end of the list.&quot;))
      }
    }
  }
  
  private func fetchMovies() {
    viewModel.trigger(.fetchMovies(false))
  }
  
  private func refreshMovies() {
    viewModel.trigger(.fetchMovies(true))
  }
}

</code></pre>
","5744323","","","","","2022-08-29 06:52:49","How to assign value to @State in View from ViewModel?","<swift><swiftui><combine>","2","0","","","","CC BY-SA 4.0"
"73525920","1","","","2022-08-29 08:15:56","","0","71","<p>I am working on a form build with Storyboard(UIKit). I have 4 input fields and when it is valid I will submit the data to a UI and show response on UI. I have created a ViewModel and added the validation code there. Following is my validation code:</p>
<pre><code>@Published public var firstName = &quot;&quot;
    @Published public var lastName = &quot;&quot;
    @Published public var phoneNumber = &quot;&quot;
    @Published public var emailAddress = &quot;&quot;    
var isFirstNameValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
        $firstName
            .map { name in
                return name.count &gt;= 3
            }
            .eraseToAnyPublisher()
    }
    
    var isLastNameValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
        $lastName
            .map { name in
                return name.count &gt;= 3
            }
            .eraseToAnyPublisher()
    }
    
    var isUserEmailValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
          $emailAddress
              .map { email in
                  let emailPredicate = NSPredicate(format:&quot;SELF MATCHES %@&quot;, &quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}&quot;)
                  return emailPredicate.evaluate(with: email)
              }
              .eraseToAnyPublisher()
      }
      
      var isPhoneNumberValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
          $phoneNumber
              .map { phoneNumber in
                  return phoneNumber.count &gt;= 8
              }
              .eraseToAnyPublisher()
      }
    
    public func isValidForm(firstName: String, lastName: String, phoneNum: String, emailAddress: String, isConsent: Bool) -&gt; AnyPublisher&lt;Bool, Never&gt; {
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNum
        self.emailAddress = emailAddress
        
        return Publishers.CombineLatest4(
          isFirstNameValidPublisher,
          isLastNameValidPublisher,
          isUserEmailValidPublisher,
          isPhoneNumberValidPublisher)
            .map { isFirstNameValid, isLastNameValid, isPhoneNumberValid, isEmailValid in
                return isFirstNameValid &amp;&amp; isLastNameValid &amp;&amp; isPhoneNumberValid &amp;&amp; isEmailValid &amp;&amp; isConsent
            }
            .eraseToAnyPublisher()
    }
</code></pre>
<p>I Am trying to use this on submit button click in my ViewController as following:</p>
<pre><code>cancellable = dependencies.leadConsumptionUseCase.isValidForm(firstName: firstNameTextView.text, lastName: lastNameTextView.text, phoneNum: phoneNumberTextView.text, emailAddress: emailTextView.text, isConsent: true).collect().sink(receiveCompletion: { completion in
        print(&quot;completed&quot;)
        print(completion)
    }, receiveValue: { res in
        print(&quot;result&quot;)
        print(res)
    })
</code></pre>
<p>I am able to validate the fields in ViewModel but somehow I am not getting any response in my ViewController.
Also I am not sure how and where should I add the api call. I have already created another service class where I have an api call that will return the response as AnyCancellable.
Most of the related examples are with SwiftUI but I am not using SwiftUI.</p>
<p><strong>Edit:</strong>
After removing collect from my isValidForm function call I am able to get the response but now it is coming multiple times. As a result of that my api call is executing multiple time.</p>
","260056","","260056","","2022-08-29 14:18:49","2022-08-29 18:20:03","Using Combine to validate and submit form in UIKit","<swift><mvvm><combine>","1","2","","","","CC BY-SA 4.0"
"73535584","1","","","2022-08-29 23:20:19","","0","33","<p>I am new to Combine and trying to use it in my application for validation of a form. It is a typical form with first name, last name, email and phoneNumber. There will be a submit button which will be initially disabled and will become active once the validations are passed.</p>
<p>Following is my UIViewController code:</p>
<pre><code>firstNameTextView.text = dependencies.leadConsumptionUseCase.firstName
    lastNameTextView.text = dependencies.leadConsumptionUseCase.lastName
    phoneNumberTextView.text = dependencies.leadConsumptionUseCase.phoneNumber
    emailTextView.text = dependencies.leadConsumptionUseCase.emailAddress

    self.cancellable = dependencies.leadConsumptionUseCase.isSignupFormValidPublisher.receive(on: RunLoop.main).sink(receiveValue: { isValid in
        self.continueButton.isEnabled = isValid
    })
</code></pre>
<p>Viewmodel Protocol:</p>
<pre><code>    public protocol LeadConsumptionProtocol {
    func setLead(_ lead: Lead)

    func saveLead(leadConsumptionDetails: Lead) -&gt; AnyPublisher&lt;Void, Error&gt;
    var isSignupFormValidPublisher: AnyPublisher&lt;Bool, Never&gt; { get }
    
    var firstName: String { get set}
    var lastName: String { get set}
    var phoneNumber: String { get set}
    var emailAddress: String { get set}
}
</code></pre>
<p>ViewModel/Interactor code:</p>
<pre><code>@Published public var firstName = &quot;&quot;
    @Published public var lastName = &quot;&quot;
    @Published public var phoneNumber = &quot;&quot;
    @Published public var emailAddress = &quot;&quot;
var isFirstNameValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
        $firstName
            .removeDuplicates()
            .map { name in
                return name.count &gt;= 3
            }
            .eraseToAnyPublisher()
    }
    
    var isLastNameValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
        $lastName
            .removeDuplicates()
            .map { name in
                return name.count &gt;= 3
            }
            .eraseToAnyPublisher()
    }
    
    var isUserEmailValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
          $emailAddress
            .removeDuplicates()
              .map { email in
                  let emailPredicate = NSPredicate(format:&quot;SELF MATCHES %@&quot;, &quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}&quot;)
                  return emailPredicate.evaluate(with: email)
              }
              .eraseToAnyPublisher()
      }
      
      var isPhoneNumberValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
          $phoneNumber
              .removeDuplicates()
              .map { phoneNumber in
                  return phoneNumber.count &gt;= 8
              }
              .eraseToAnyPublisher()
      }
    
    public var isSignupFormValidPublisher: AnyPublisher&lt;Bool, Never&gt; {
        Publishers.CombineLatest4(
            isFirstNameValidPublisher,
            isLastNameValidPublisher,
            isPhoneNumberValidPublisher,
            isUserEmailValidPublisher)
          .map { isNameValid, isEmailValid, isPasswordValid, passwordMatches in
              return isNameValid &amp;&amp; isEmailValid &amp;&amp; isPasswordValid &amp;&amp; passwordMatches
          }
          .eraseToAnyPublisher()
      }
</code></pre>
<p>I assume that binding is not working properly. What can I try next?</p>
","260056","","472495","","2022-09-03 21:38:58","2022-09-03 21:38:58","Form validation with combine and UIkit Swift","<swift><mvvm><combine><publisher>","1","4","","2022-09-03 21:43:08","","CC BY-SA 4.0"
"73564945","1","73575755","","2022-09-01 06:14:59","","6","130","<p>Recently, I have been learning Swift's Combine framework.</p>
<p>In Apple's words, &quot;The Combine framework provides a declarative approach for how your app processes events. Rather than potentially implementing multiple delegate callbacks or completion handler closures, you can create a single processing chain for a given event source. Each part of the chain is a Combine operator that performs a distinct action on the elements received from the previous step.&quot;</p>
<p>In Combine, There is a function called <code>compactMap</code>, which can filter nil values:</p>
<pre class=""lang-swift prettyprint-override""><code>import Combine

let strings = [&quot;a&quot;, &quot;1.24&quot;, &quot;3&quot;, &quot;def&quot;, &quot;45&quot;, &quot;0.23&quot;].publisher

strings
  .compactMap { Float($0) }
  .sink(receiveValue: {
    print($0)
  })
  .store(in: &amp;subscriptions)
)
</code></pre>
<p><a href=""https://i.stack.imgur.com/vxgV8.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/vxgV8.png"" alt=""compactMap in Swift"" /></a></p>
<p>I rewrite the above code in Raku as the following:</p>
<pre class=""lang-perl prettyprint-override""><code>my @strings = [&quot;a&quot;, &quot;1.24&quot;, &quot;3&quot;, &quot;def&quot;, &quot;45&quot;, &quot;0.23&quot;];
my Supply $supply = Supply.from-list(@strings);
my Supply $compact = $supply.map(-&gt; $value {
  try { Num($value) }
  if $! { Empty } else { Num($value) }
 }); # .grep(Num);

$compact.tap(
    &amp;say,
    done =&gt; { say 'finished' },
    quit =&gt; { say 'done'     }
);

# ()   &lt;--
# 1.24
# 3
# ()   &lt;--
# 45
# 0.23
</code></pre>
<p>But it also output two empty parentheses. When use map on plain Array instead of on a Supply, the map with Empty value got filtered:</p>
<pre class=""lang-perl prettyprint-override""><code>my @strings = [&quot;a&quot;, &quot;1.24&quot;, &quot;3&quot;, &quot;def&quot;, &quot;45&quot;, &quot;0.23&quot;];

my @compacted = @strings.map(-&gt; $value {
    try { Num($value) }
    if $! { Empty } else { Num($value) }
});

.say for @compacted;

# 1.24
# 3
# 45
# 0.23
</code></pre>
<p>Is the behavior of <code>map</code> function with <strong>Empty</strong> value in <code>Supply</code> and plain <code>Array</code> inconsistent?</p>
","5829526","","4294399","","2022-09-12 16:22:28","2022-09-12 16:22:28","Inconsistent behavior of map function with Empty value in Supply and plain Array?","<swift><raku><combine><compact-map>","1","4","","","","CC BY-SA 4.0"
"73602960","1","","","2022-09-04 21:35:53","","0","46","<p>I am implementing a network layer using combine and having a hard time extracting the inner array as the publisher in the type I need in a single swipe. I have it working but as 2 separate functions where on the second within .sink I pull what I need but I want it all to happen within the 1st function... current state for reference below.</p>
<p>json returned from api for reference:</p>
<pre><code>     {
            &quot;count&quot;: 1,
            &quot;entities&quot;: [
    {facetids:[],
    identifiers:[],
    description:String},
    {facetids:[],
    identifiers:[],
    description:String}
]
        }
</code></pre>
<p>What Entities looks like:</p>
<pre><code>struct Entities:Decodable
{
    var count:Int?
    var entities: [Entity]?
}
</code></pre>
<p>NetworkController.swift:</p>
<pre><code> func get&lt;T&gt;(type: T.Type, url: URL, headers: Headers) -&gt; AnyPublisher&lt;T, Error&gt; where T : Decodable
    {
    var urlRequest = URLRequest(url: url)
    
    headers.forEach
    {
        key, value in
        
        if let value = value as? String
        {
            urlRequest.setValue(value, forHTTPHeaderField: key)
        }
    }
    return URLSession.shared.dataTaskPublisher(for: urlRequest)
        return URLSession.shared.dataTaskPublisher(for: urlRequest)
        .map(\.data)
        .decode(type: T.self, decoder: JSONDecoder())
        .eraseToAnyPublisher()
}
</code></pre>
<p>EntitiesLogicController.swift:</p>
<pre><code>    func getEntities(named: String, count: Int) -&gt; AnyPublisher&lt;Entities, Error&gt; {
    let endpoint = Endpoint.companies(named: named, count: count)
    
    return networkController.get(type: Entities.self, url: endpoint.url, headers: endpoint.headers)
}
</code></pre>
<p>ApiCaller.swift:</p>
<pre><code>  func getEntities(named: String)
    {
        entitiesLogicController?.getEntities(named: named, count: 20).sink{
        [weak self] completion in

        
        if case let .failure(error) = completion
        {
            print(&quot;Error retrieving Entity, ERROR: \(error)&quot;)
        } else if case .finished = completion
        {
            print(&quot;Data successfully downloaded&quot;)
        }
    } receiveValue:
    {
        requestedEntity in
        
        do{
            let entities:[Entity] = try requestedEntity.entities!.compactMap{
                entity in
                do
                {
                    return try Entity(from: entity)
                }
            }
            self.entities = entities
        }catch
        {
            print(&quot;Error&quot;)
        }
    }.store(in: &amp;subscriptions)
}
</code></pre>
<p>I want/need the get to return AnyPublisher&lt;[T], Error&gt; instead
where [T] == [Entity] decodable structs work perfectly fine and everything else as well.</p>
","19729949","","560942","","2022-09-04 21:40:47","2022-09-04 22:12:12","Issue extracting array nested in a dictionary and return publishers for it with Combine and Swift","<ios><swift><combine>","1","3","","","","CC BY-SA 4.0"
"73610738","1","","","2022-09-05 14:12:02","","0","38","<p>In my viewModel I have either a <code>CurrentValueSubject</code> or a <code>PassthroughSubject</code>.</p>
<p>How can I bind them in my <strong>SwiftU</strong> where the view is expecting an input of type <code>@Binding&lt;Type&gt;</code>.</p>
<p>I've tried with but it doesn't work properly:</p>
<pre><code>extension CurrentValueSubject {
  var binding: Binding&lt;Output&gt; {
    Binding(get: {
      self.value
    }, set: {
      self.send($0)
    })
  }
}
</code></pre>
","6747915","","","","","2022-09-05 15:44:24","SwiftUI - Combine: Binding Subject in SwiftUI","<ios><swift><swiftui><combine>","1","0","","2022-09-06 05:19:46","","CC BY-SA 4.0"
"73616530","1","73616725","","2022-09-06 03:54:12","","2","40","<p>Assume the two following publishers:</p>
<pre><code>var firstFeed = PassthroughSubject&lt;Int?, Never&gt;()
var secondFeed = PassthroughSubject&lt;Int?, Never&gt;()
</code></pre>
<p>How do I create a subscription where the sink is called when the two feed provide two none-nil values. This is what I have so far, but it seems ugly.</p>
<pre><code>   let sub = firstFeed
        .compactMap{$0}
        .combineLatest(secondFeed.compactMap({$0}))
        .sink { firstValue, secondValue in
            print(&quot;we sunk with \(firstValue), \(secondValue)&quot;)
        }
</code></pre>
<p>With the following stream of data:</p>
<pre><code>    firstFeed.send(1)
    secondFeed.send(nil)
    secondFeed.send(2)
    firstFeed.send(nil)
    firstFeed.send(3)
    firstFeed.send(nil)
    secondFeed.send(nil)
    firstFeed.send(nil)
    secondFeed.send(nil)
    secondFeed.send(4)
    firstFeed.send(nil)
    secondFeed.send(nil)
    firstFeed.send(5)
    secondFeed.send(6)
    secondFeed.send(nil)
    firstFeed.send(nil)
    firstFeed.send(7)
    firstFeed.send(nil)
    secondFeed.send(8)
</code></pre>
<p>I get this output:</p>
<pre><code>we sunk with 1, 2
we sunk with 3, 2
we sunk with 3, 4
we sunk with 5, 4
we sunk with 5, 6
we sunk with 7, 6
we sunk with 7, 8
</code></pre>
<p>ideally I would want something like this:</p>
<pre><code>    let sub = firstFeed
        .combineLatest(secondFeed)
        .compactMap{?}
        .sink { firstValue, secondValue in
            print(&quot;we sunk with \(firstValue), \(secondValue)&quot;)
        }
</code></pre>
<p>I'm not sure what goes into the compact map when two publishers are combined...</p>
","1327778","","","","","2022-09-06 05:04:08","How to apply compactMap to two combined publishers","<swift><combine>","2","0","","","","CC BY-SA 4.0"
"73623289","1","","","2022-09-06 13:56:40","","0","42","<p>I'm converting my Swift app to use Combine as well as <code>async/await</code> and I'm trying to understand what's the best way to handle interactions between asynchronous functions and the main thread.</p>
<p>Here's an asynchronous function that loads a user:</p>
<pre><code>class AccountManager {

    static func fetchOrLoadUser() async throws -&gt; AppUser {
        if let user = AppUser.current.value {
            return user
        }
    
        let syncUser = try await loadUser()
        let user = try AppUser(syncUser: syncUser)
    
        AppUser.current.value = user // [warning]: &quot;Publishing changes from background threads is not allowed&quot;
        return user
    }
}
</code></pre>
<p>And a class:</p>
<pre><code>class AppUser {

    static var current = CurrentValueSubject&lt;AppUser?,Never&gt;(nil)

    // ...
}
</code></pre>
<p>Note: I chose to use <code>CurrentValueSubject</code> because it allows me to both (1) read this value synchronously whenever I need it and (2) subscribe for changes.</p>
<p>Now, on the line marked above I get the error <code>Publishing changes from background threads is not allowed</code>, which I understand. I see different ways to solve this issue:</p>
<h3>1. Mark whole <code>AccountManager</code> class as <code>@MainActor</code></h3>
<p>Since most of the work done in asynchronous functions is to wait for network results, I'm wondering if there is an issue with simply running everything on the main thread. Would that cause performance issues or not?</p>
<h3>2. Englobe error line in <code>DispatchQueue.main.sync</code></h3>
<p>Is that a reasonable solution, or would that cause threading problems like deadlocks?</p>
<h3>3. Use <code>DispatchGroup</code> with <code>enter()</code>, <code>leave()</code> and <code>wait()</code></h3>
<p>Like in <a href=""https://stackoverflow.com/a/42484670/3780788"">this answer</a>. Is there a difference at all with solution #2? Because this solution needs more lines of code so I'd rather not use it if possible —I prefer clean code.</p>
","3780788","","","","","2022-09-21 21:00:16","Best practice with asynchronous functions Swift & Combine","<swift><concurrency><combine>","1","3","","","","CC BY-SA 4.0"
"73624578","1","73668411","","2022-09-06 15:34:14","","-2","25","<p>If I assign the same value twice or more in succession to a <code>@Published</code> member of an <code>ObservableObject</code>, do both/all writes cause observers/receivers to receive updates with the same value, or does Combine suppress updates for assignments that don't actually change the value?</p>
","1541150","","","","","2022-09-09 23:55:52","Does Swift Combine coalesce successive writes of the same value to a @Published var?","<combine>","1","2","","","","CC BY-SA 4.0"
"73638763","1","","","2022-09-07 16:20:10","","1","41","<p>Let's say we have a parent view like:</p>
<pre><code>struct ParentView: View {
    @State var text: String = &quot;&quot;

    var body: some View {
        ChildView(text: $text)
    }
}
</code></pre>
<p>Child view like:</p>
<pre><code>struct ChildView: View {

    @ObservedObject var childViewModel: ChildViewModel

    init(text: Binding&lt;String&gt;) {
        self.childViewModel = ChildViewModel(text: text)
    }

    var body: some View {
        ...
    }
}
</code></pre>
<p>And a view model for the child view:</p>
<pre><code>class ChildViewModel: ObservableObject {
    @Published var value = false
    @Binding var text: String

    init(text: Binding&lt;String&gt;) {
        self._text = text
    }

    ...
}

</code></pre>
<p>Making changes on the String binding inside the child's view model makes the ChildView re-draw causing the viewModel to recreate itself and hence reset the @Published parameter to its default value. What is the best way to handle this in your opinion?</p>
<p>Cheers!</p>
","12205572","","","","","2022-09-07 18:45:55","SwiftUI - Binding in ObservableObject","<swiftui><binding><combine>","1","9","","","","CC BY-SA 4.0"
"73642775","1","73649896","","2022-09-08 01:06:55","","-1","38","<p>Is there a way to turn on the collect() after it sees a certain value and then turn it off after it sees another?</p>
<p>I tried using map and filter upstream and that's totally wrong.</p>
<p>Here's my playground</p>
<pre><code>import UIKit
import Foundation
import Combine

var subj = PassthroughSubject&lt;Int, Never&gt;()

for iter in 0...10 {
    DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(iter)) {
        print(&quot;send \(iter)&quot;)
        subj.send(iter)
    }
}

let queue = DispatchQueue(label: &quot;Q&quot;)

let cancellable = subj.collect(.byTime(queue, .seconds(2))).sink(receiveCompletion: {
    print(&quot;finish&quot;)
    print($0)
}, receiveValue: {
    print($0)
})

/* my print
send 0
send 1
send 2
[0, 1]
send 3
send 4
[2, 3]
send 5 
send 6
[4, 5] // is there a way to only have it dispatch all the values after this point? After it sees a value of 5?
send 7
send 8
[6, 7]
send 9
send 10
[8, 9, 10]

*/

</code></pre>
","465446","","","","","2022-09-08 13:31:29","Creating a publisher that collects values after a trigger","<swift><reactive-programming><combine><publisher>","1","3","","","","CC BY-SA 4.0"
"73655294","1","","","2022-09-08 21:41:00","","0","28","<p>My custom publisher acts strangely if I have another subscriber subscribing to the upstream publisher.</p>
<p>So in my example, my upstream publisher gates the values dispatched</p>
<pre><code>let onlyGreaterThan4 = pub.drop(while: { value in
    return value &lt; 4
})
</code></pre>
<p>I have two subscribers, one with a normal sink and one in a custom publisher.</p>
<pre><code>import UIKit
import Foundation
import Combine

var iter = 0
var pub: AnyPublisher&lt;Int, Never&gt; = Timer.publish(every: 1, on: .main, in: .common).autoconnect().map { _ -&gt; Int in
    iter += 1
    print(&quot;sending \(iter)&quot;)
    return iter
}.eraseToAnyPublisher()

/// Collects values and starts a timer after the `first` value from upstream is received. This differs from the collect(.byTime) publisher since that publisher collects on an interval
public struct CollectOnReceive&lt;T: Publisher&gt;: Publisher where T.Failure == Never {
    public typealias Output = [T.Output]
    public typealias Failure = T.Failure

    /// Subscription for ReactiveSwiftPublisher
    class Subscription&lt;SubscriberType: Subscriber&gt;: Combine.Subscription where SubscriberType.Input == Output, SubscriberType.Failure == Failure {
        private var cancellables: Set&lt;AnyCancellable&gt; = Set()

        private let subscriber: SubscriberType
        private let upstream: T
        private let queue: DispatchQueue
        private var collection: Output = []

        init(upstream: T, subscriber: SubscriberType, queue: DispatchQueue) {
            self.subscriber = subscriber
            self.upstream = upstream
            self.queue = queue
        }

        func request(_ demand: Subscribers.Demand) {
            let subscriber = self.subscriber

            Swift.print(&quot;-- observing --&quot;)

            // collect all the values
            self.upstream.subscribe(on: self.queue)
                .sink { [weak self] value in
                    Swift.print(&quot;-- appending: \(value)&quot;)
                    self?.collection.append(value)
                }.store(in: &amp;self.cancellables)

            // on the first item
            self.upstream.first()
                .flatMap({ _ -&gt; AnyPublisher&lt;Date, Never&gt; in
                    // dvttodo using dispatch interval timer might be necessary
                    Swift.print(&quot;start: \(Date())&quot;)
                    return Timer.publish(every: 5, on: .main, in: .common).autoconnect().eraseToAnyPublisher()
                }).subscribe(on: self.queue)
                .sink(receiveValue: { [weak self] _ in
                    guard let collection = self?.collection else {
                        subscriber.receive(completion: .finished)
                        return
                    }

                    Swift.print(&quot;--finish sub: \(collection) : \(Date())&quot;)
                    subscriber.receive(collection)
                    subscriber.receive(completion: .finished)
                }).store(in: &amp;self.cancellables)
        }

        func cancel() {
            self.cancellables.removeAll()
        }
    }

    private let upstream: T
    private let queue: DispatchQueue

    public init(upstream: T, queue: DispatchQueue) {
        self.upstream = upstream
        self.queue = queue
    }

    public func receive&lt;S&gt;(subscriber: S) where S : Subscriber, T.Failure == S.Failure, [T.Output] == S.Input {
        subscriber.receive(
            subscription: Subscription(
                upstream: self.upstream,
                subscriber: subscriber,
                queue: self.queue
            )
        )
    }
}

extension Publisher where Failure == Never {
    func collectOnReceive(queue: DispatchQueue = .init(label: &quot;CollectOnReceive&quot;)) -&gt; CollectOnReceive&lt;Self&gt; {
        return CollectOnReceive(upstream: self, queue: queue)
    }
}

let onlyGreaterThan4 = pub.drop(while: { value in
    return value &lt; 4
})

let q = DispatchQueue(label: &quot;ASDF&quot;)

let cancel = onlyGreaterThan4.collectOnReceive(queue: DispatchQueue(label: &quot;collect on receive&quot;)).sink {
    print(&quot;completion: \($0)&quot;)
} receiveValue: {
    print(&quot;values: \($0)&quot;)
}

let c2 = onlyGreaterThan4.sink {
    print(&quot;c2 sink: \($0)&quot;)
}

// if you comment out c2, it acts mostly reasonable, the publisher completes properly and sends out the following array [4, 6, 7, 8, 9, 10, 11], don't know what happened to the 5 but that's mostly correct.

// if you leave second subscription with c2 in tact, then it returns the following: [6, 8, 10, 12, 14, 16]. Where did all the odd numbers go? No idea.

</code></pre>
<p>I figure I must be dealing with the dispatch queues wrong or something silly.</p>
<p>The reason I created a custom publisher was that I wanted value collection for an interval only after the first value greater than or equal to 4 was discovered. Using collect(.byTime) would not be suitable since it executes on the interval, regardless of when upstream values come into it.</p>
<p>So the pseudo code of the goal</p>
<pre><code>when x &gt;= 4 was detected then {
    collect(values, for: timeInterval) { valuesGreaterThanEqualTo4 in 
        if valuesGreaterThanEqualTo4.count &gt; threshold {
            return sustained 
        }

        return notSustained
    }
}
</code></pre>
<p>Update:
I noticed in my print that my sink subscription all my even values where going there while my odd values were going to my custom publisher. So weird.</p>
<pre><code>-- observing --
sending 1
sending 2
sending 3
sending 4
c2 sink: 4
sending 5
-- appending: 5
sending 6
start: 2022-09-08 22:45:54 +0000
sending 7
-- appending: 7
sending 8
c2 sink: 8. // missing the append for all the even values!!!
sending 9
-- appending: 9
sending 10
c2 sink: 10
sending 11
-- appending: 11
sending 12
c2 sink: 12
sending 13
-- appending: 13
sending 14
c2 sink: 14
sending 15
-- appending: 15
sending 16
c2 sink: 16
--finish sub: [5, 7, 9, 11, 13, 15] : 2022-09-08 22:45:59 +0000
values: [5, 7, 9, 11, 13, 15]

</code></pre>
","465446","","465446","","2022-09-08 22:48:51","2022-09-09 00:14:26","Custom publisher acting up when upstream is subscribed by multiple subscribers","<swift><combine><publisher>","1","5","","","","CC BY-SA 4.0"
"73680340","1","","","2022-09-11 15:05:00","","0","36","<p>I have a new iOS App with an auto renewing subscription feature.
I'm using the Mercato lightweight Storekit2 library.
I issue a start to the transaction listener in the AppDelegate didFinishLaunch along with a retrieveProducts(), activeSubscriptions(), and activeSubscriptionsIDs().</p>
<p>It all works, BUT: the validation of an active subscription does not asynchronously complete until well after the initial viewWillAppear().
Therefore it always starts off in non-valid display mode, and premium features are available to select by the time the user starts navigating.</p>
<p>Is there a faster way to get a validation upfront, or failing that, is there a way to post an event that a subscription test has completed, so I can display, then stop some sort of distracting, time wasting animation until validation.</p>
","4945371","","","","","2022-09-11 15:05:00","Storekit 2 Test valid subscriptions at launch","<swift><combine><storekit><ios15>","0","0","","","","CC BY-SA 4.0"
"73680682","1","","","2022-09-11 15:59:39","","0","26","<p>I've been working on GraphQL for a while and I wanted to use custom publisher and Apollo together. But some kind of custom publisher didn't work, I've been dealing with it for days. I couldn't find what I missed</p>
<p>note: After running <code>fetchPublisher()</code>, no error or data is returned.</p>
<h2><strong>Custom Publisher</strong></h2>
<pre><code>import Foundation
import Apollo
import Combine

struct ApolloPublisher&lt;Query: GraphQLQuery&gt;: Publisher {
    
    typealias Output = GraphQLResult&lt;Query.Data&gt;
    typealias Failure = Error
    
    private let client: ApolloClient
    private let query: Query
    
    init(client:ApolloClient,
         query: Query) {
        self.client = client
        self.query = query
    }
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, S.Failure == Error, S.Input == GraphQLResult&lt;Query.Data&gt; {
        let subscription = ApolloSubscription(client: self.client,
                                                    query: self.query,
                                                    subscriber: subscriber)
        subscriber.receive(subscription: subscription)
    }
}
</code></pre>
<h2><strong>Custom Subscription</strong></h2>
<pre><code>import Foundation
import Apollo
import Combine

final class ApolloSubscription&lt;GraphQuery: GraphQLQuery, SubscriberType: Subscriber&gt;: Subscription where SubscriberType.Input == GraphQLResult&lt;GraphQuery.Data&gt;, SubscriberType.Failure == Error {

private let subscriber: SubscriberType
private var cancelable: Apollo.Cancellable?

init(client: ApolloClient,
     query: GraphQuery,
     subscriber: SubscriberType) {
    self.subscriber = subscriber
    self.cancelable = client.fetch(query: query,
                                   resultHandler: self.handle)
}

deinit {
    cancelable?.cancel()
}

func request(_ demand: Subscribers.Demand) {}

func cancel() {
    cancelable?.cancel()
    cancelable = nil
}

func handle(result: Result&lt;GraphQLResult&lt;GraphQuery.Data&gt;, Error&gt;) {
    switch result {
    case .success(let resultSet):
        _ = subscriber.receive(resultSet)
    case .failure(let error):
        subscriber.receive(completion: .failure(error))
    }
    subscriber.receive(completion: .finished)
    }
}
</code></pre>
<p>extension for ApolloClient</p>
<pre><code>extension ApolloClient {
    func fetchPublisher&lt;Query: GraphQLQuery&gt;(query: Query) -&gt; ApolloPublisher&lt;Query&gt; {
        return ApolloPublisher(client: self,
                               query: query)
    }
}
</code></pre>
<p>Client side.</p>
<pre><code>let apollo = ApolloClient(url: URL(string: &quot;https://api.spacex.land/graphql/&quot;)!)

func fetch() -&gt; AnyPublisher&lt;String, Error&gt; {
    return apollo.fetchPublisher(query: GetLaunchesQuery())
        .mapError { error in
            return error
        }
        .map { response in
           return response.data?.launches?.description ?? &quot;&quot;
        }
        .eraseToAnyPublisher()
}
</code></pre>
","7202335","","","","","2022-09-11 15:59:39","Combine - My Custom Publisher Is Not Publish","<swift><graphql><reactive-programming><apollo><combine>","0","3","","","","CC BY-SA 4.0"
"73710643","1","","","2022-09-14 01:51:34","","-1","41","<pre><code>extension Reactive where Base: UIViewController {
    var viewWillAppear: Observable&lt;Void&gt; {
        sentMessage(#selector(UIViewController.viewWillAppear(_:)))
            .filter { [weak base] _ in
                if base?.isImageViewerPresented == true {
                    return false
                }
                return true
            }
            .mapToVoid()
    }
}
</code></pre>
<p>i want observe viewWillAppear like <code>self.viewWillApplerPublisher</code>
please help how to observe it</p>
","10212146","","","","","2022-09-14 11:12:36","Observing ViewWillAppear (Migrating RXSwift to combine)","<ios><swift><rx-swift><combine>","1","1","","","","CC BY-SA 4.0"
"73720789","1","","","2022-09-14 17:12:11","","2","47","<p>I have a publisher where I want to handle receiving the first value one way, and receiving the rest another way. Currently I have the following:</p>
<pre><code>let bar = foo
    .first()
    .sink { value in
    print(&quot;first value is \(value)&quot;)
}

let baz = foo
    .dropFirst()
    .sink { value in
        print(&quot;one of the rest is \(value)&quot;)
    }

foo.send(1)
foo.send(2)
foo.send(3)
foo.send(4)
foo.send(5)
foo.send(6)
</code></pre>
<p>This works. But it forces me to have two subscriptions, one for the first value, and another for the rest. Is there a clever way of combining the two into one subscription (without external flag management). Something like:</p>
<pre><code>let bar = foo
    .first()
    .sink { value in
        print(&quot;first value is \(value)&quot;)
    }
    .dropFirst()
    .sink {
        print(&quot;the rest is \(value)&quot;)
    }
</code></pre>
<p>I'm aware the above doesn't make sense (and is probably uglier than the original solution) since a publisher is singular flow that doesn't branch (beyond value, completion, error), but that's due to my lack of creativity, I'm hoping someone here has something that I might be overlooking.</p>
","1327778","","","","","2022-09-15 09:05:08","How to capture the first value in a publisher one way and the rest another way","<swift><combine>","2","3","","","","CC BY-SA 4.0"
"73743347","1","","","2022-09-16 10:20:45","","0","37","<p>I am trying to nest multiple request together to create the object that I need. Just a short description about the API and what I try to accomplish. I am basically fetching an array of exercises. These exercise however don't have every information that I need so I have to take the id and do another request to get the whole object. From there on I get an array of images which contains the url that I need. Then I need another attribute called variations which consists of an array of exercise ids.</p>
<p>So I basically need to do 4 requests:</p>
<ul>
<li>Fetch all exercises</li>
<li>fetch exercise by id</li>
<li>From there I take the image urls and fetch the images</li>
<li>Then I want to fetch all the variations using the ids from the array</li>
</ul>
<p>So my new object should be an array of type:</p>
<pre><code>struct ExerciseDetails: Hashable {
    
    let id: Int
    let title: String
    let image: [UIImage]
    let variations: [ExerciseDetails]
}
</code></pre>
<p>Here is what I am trying to do:</p>
<pre><code>URLSession.shared.dataTaskPublisher(for: URL(string: &quot;https://wger.de/api/v2/exercise/?limit=70&amp;offset=40&quot;))
            .map { $0.data }
            .decode(type: [Exercise].self, decoder: JSONDecoder())
            .map { $0.map { $0.id } }
            .flatMap(\.publisher)
            .flatMap { id in
                URLSession.shared.dataTaskPublisher(for: URL(string: &quot;https://wger.de/api/v2/exerciseinfo/\(id)&quot;)!)
                    .map(\.data)
                    .decode(type: Exercise.self, decoder: JSONDecoder())
                    .map { $0.images }
                    .flatMap { image in
                        URLSession.shared.dataTaskPublisher(for: URL(string: image.imageUrl))
                            .map { return UIImage(data: $0.data) }
                    }
            }
            .map { $0.map { $0.variations } }
            .flatMap(\.publisher)
            .flatMap { id in
                URLSession.shared.dataTaskPublisher(for: URL(string: &quot;https://wger.de/api/v2/exerciseinfo/\(id)&quot;)!)
                    .map(\.data)
                    .decode(type: Exercise.self, decoder: JSONDecoder())
                    .map { return $0 }
            }
</code></pre>
<p>Now I don't know how to map the output to -&gt; [ExerciseInfo]</p>
<p>I think I am on a good way but there is something missing.</p>
<p>Can anybody help?</p>
","17299448","","17299448","","2022-09-16 15:18:58","2022-09-16 15:18:58","Chaining multiple requests in Combine","<swift><mapping><reactive-programming><combine><urlsession>","0","5","","","","CC BY-SA 4.0"
"73743490","1","","","2022-09-16 10:33:32","","0","35","<p>We have a Publisher which can publish new values <code>v</code> quickly but processing those values can be slow. This causes values to back up which we don't want. Having an array of multiple values <code>v</code> allows us to combine those into a single value. We cannot miss any published values.</p>
<p>We thus would like to collect values while sink is busy with <code>slowProcessing</code> and do nothing otherwise (i.e. go immediately to <code>slowProcessing</code> if the queue is currently free).</p>
<p>Due to the requirement of running <code>slowProcessing</code> immediately  we cannot buffer values using <code>buffer(size:prefetch:whenFull:)</code> or <code>collect(_:options:)</code>. As we cannot miss any values we cannot use <code>debounce(for:scheduler:options:)</code> or <code>throttle(for:scheduler:latest:)</code></p>
<p>Is there a way to achieve this using Swift Combine?</p>
<pre><code>private let snapshotQueue = DispatchQueue(
    label: &quot;snapshotQueue&quot;,
)

QuickUpdating.$currentSnapshot
    .receive(on: snapshotQueue)
    .sink { [weak self] currentSnapshot in
        slowProcessing(currentSnapshot)
        updateUI()

    }
    .store(in: &amp;cancellables)
</code></pre>
","2310837","","","","","2022-09-16 10:33:32","Swift Combine collect values only while sink is busy","<swift><combine>","0","6","","","","CC BY-SA 4.0"
"73757043","1","","","2022-09-17 17:23:58","","0","36","<p>How to pass Published as Binding?</p>
<p>I have rating views for an array of products and a clear button, when the clear button is pressed I want to clear the ratings of all.</p>
<p>I am converting the Published object to Binding in order to reflects the updates but it doesn't work.</p>
<p>If I use direct <code>$viewModel.products</code> in ForEach the ratings update &amp; clear works perfectly.</p>
<pre class=""lang-swift prettyprint-override""><code>struct ProductModel: Identifiable, Equatable {
    var id: Int
    var title: String
    var rating: Int
        
    mutating func clearRating() {
        rating = 0
    }
}

protocol ViewModelType: ObservableObject {
    associatedtype Input
    associatedtype State
    
    var state: State { get }
    func trigger(_ input: Input)
    
    var subscriptions: Set&lt;AnyCancellable&gt; { get }
}

struct TestView: View {
    
    @StateObject var viewModel = TestViewModel()
    
    var body: some View {
        switch viewModel.state {
        case .initial:
            Text(&quot;Hello world&quot;)
                .onAppear {
                    viewModel.trigger(.initial)
                }
            
        case .data(let products):
            VStack(spacing: 20) {
                ForEach(products) { product in
                    Text(&quot;\(product.rating.wrappedValue)&quot;)
                    RatingStarView(rating: product.rating)
                }
                Button {
                    viewModel.clear()
                } label: {
                    Text(&quot;Clear Rating&quot;)
                }
            }
        }
    }
}

class TestViewModel: ViewModelType {
    
    enum State {
        case initial
        case data(Binding&lt;[ProductModel]&gt;)
    }
    
    enum Input {
        case initial
        case clear
    }
    
    @Published var state: State = .initial
    @Published var products: [ProductModel] = [.init(id: 101, title: &quot;Product 1&quot;, rating: 3),
                                                             .init(id: 102, title: &quot;Product 2&quot;, rating: 2)]
    
    func trigger(_ input: Input) {
        switch input {
        case .initial:
            convertPublishedToBinding()
            
        case .clear:
            clear()
        }
    }
    
    func clear() {
        products.indices.forEach { products[$0].clearRating() }
    }
    
    private func convertPublishedToBinding() {
        state = .data(Binding(get: { [weak self] in
            self?.products ?? []
        }, set: { [weak self] newValue in
            print(newValue)
            self?.products = newValue
        }))
    }
}

</code></pre>
<p>NOTE: I was referring to this article <a href=""https://quickbirdstudios.com/blog/swiftui-architecture-redux-mvvm/"" rel=""nofollow noreferrer"">https://quickbirdstudios.com/blog/swiftui-architecture-redux-mvvm/</a></p>
","5744323","","","","","2022-09-18 11:19:06","How to pass Published as Binding in SwiftUI?","<swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"73775613","1","","","2022-09-19 15:10:13","","0","27","<p>I have a ViewModel with following variable:<br />
<code>@Published var refreshed: Bool = false</code></p>
<p>Then, I use this variable in View on list's refresh like this:</p>
<pre><code>List {
    [code...]
}
.refreshable {
    ratingsViewModel.refreshed = true
    ratingsViewModel.onRefresh()
}
</code></pre>
<p>My <code>ratingsViewModel</code> has it's function <code>onRefresh</code> which is fired on every view's refresh (as above):</p>
<pre><code>func onRefresh() {
        myCurrentRatingsList
            .sink(receiveValue: { [weak self] ratingsList in
                print(self?.refreshed)
            })
            .store(in: &amp;cancellableSet)
    }
</code></pre>
<p>myCurrentRatingsList is publisher created like this:</p>
<pre><code>private lazy var myCurrentRatingsList: AnyPublisher&lt;[RatingsListSection: [RatingsListRow]], Never&gt; = {
        myCurrentRatingsRepository.ratingsList
            .share()
            .replaceError(with: [:])
            .eraseToAnyPublisher()
    }()
</code></pre>
<p>The problem is function <code>onRefresh</code> is executed also on <code>ratingsViewModel</code> init so <code>ratingsViewModel.refreshed</code> value is printed when ViewModel instance is created. When I use refreshable on list by pulling down the screen, nothing is printed (the animation works).<br />
My question: is <code>.sink</code> only usable once? If yes, how can I replace it so that I can update value from my publisher many times</p>
","14793963","","14793963","","2022-09-19 15:23:04","2022-09-20 04:53:55","Combine Publisher performs .sink action only once","<ios><swift><xcode><swiftui><combine>","1","0","","","","CC BY-SA 4.0"
"73776235","1","73776529","","2022-09-19 16:02:42","","-2","35","<p>I have a ProtocolName that conforms to ObservableObject. I then have ClassName that conforms to ProtocolName.</p>
<p>However, when I try to use @ObservedObject serviceName: ProtocolName = ClassName, it fails to build with the following message: &quot;Type 'any ProtocolName' cannot conform to 'ObservableObject'&quot;</p>
<p>What am I doing wrong and how can I fix this?</p>
<p>Example:</p>
<pre><code>protocol ProtocolName: ObservableObject {
    let random: String
}

class ClassName: ProtocolName {
    let random: String
}

@ObservedObject serviceName: ProtocolName = ClassName()
</code></pre>
","18756318","","18756318","","2022-09-19 16:24:44","2022-09-20 12:00:22","Type 'any ProtocolName' cannot conform to '(ProtocolName's Inherited Protocol)'","<swift><swiftui><combine>","1","2","0","2022-09-19 16:42:57","","CC BY-SA 4.0"
"73777247","1","73777248","","2022-09-19 17:35:35","","0","42","<p>I currently have an SDK that has a <code>@Published</code> boolean variable within a class (we can call this <code>ClassA</code>).</p>
<p>I'd like to expose this variable to an application (to use in SwiftUI), but not expose the entire <code>ClassA</code>. Therefore I have created a bridging class (<code>BridgingClass</code>) that will be exposed to the application without having to expose ClassA.</p>
<p>I have the following code. But it feels weird to use <code>sink</code> and manually change the variable based on the result.</p>
<pre class=""lang-swift prettyprint-override""><code>@objc public class BridgingClass: NSObject, ObservableObject {
    var tmpVar: AnyCancellable?

    @objc public init (classA: ClassA) {
        super.init()

        tmpVar = classA.$hungryState.sink { val in
            self.isHungry = val
        }
    }

    @Published public var isHungry: Bool
}
</code></pre>
<p>How can I make the <code>isHungry</code> variable equal to <code>hungryState</code> from <code>classA</code>?</p>
","894067","","","","","2022-09-19 17:35:35","How to pass a @Published variable between classes using Combine?","<swift><swiftui><combine>","1","1","","","","CC BY-SA 4.0"
"73782442","1","73784104","","2022-09-20 06:32:37","","0","42","<p>I've made an extension for Publisher to simplify sink, but my backend (not made by me) is messed up and I have a custom error that shouldn't be an error, and I want to return .success.</p>
<pre class=""lang-swift prettyprint-override""><code>extension Publisher {
    func sinkToResult(_ result: @escaping ((Result&lt;Self.Output, Self.Failure&gt;) -&gt; Void)) -&gt; AnyCancellable {
        return sink(receiveCompletion: { completion in
            switch completion {
            case .failure(let error):
                if let error = error as? ApiError, let globalError = error.globalErrors.first, globalError.code == 2233 {
                    //Here i want to send something like return(.success(true))
                }
                result(.failure(error))
            case .finished:
                break
            }
        }, 
        receiveValue: { output in
            result(.success(output))
        })
    }
}
</code></pre>
<p>Can you help me to create a custom Output.Self type that I can return here?</p>
","16453266","","4105619","","2022-09-20 08:31:40","2022-09-20 13:39:11","Publisher extension for .sink","<swift><combine><publisher>","2","0","","","","CC BY-SA 4.0"
"73803727","1","73807915","","2022-09-21 15:52:16","","1","25","<p>I have an extension which takes a publisher and waits until a non-nil value is published before taking its value and returning it for use as an async/await function.</p>
<pre><code>extension Publisher {
  func value() async throws -&gt; Output {
    try await self
      .compactMap { $0 }
      .eraseToAnyPublisher()
      .async()
  }
}

enum AsyncError: Error {
  case finishedWithoutValue
}

extension AnyPublisher {
  /// Returns the first value of the publisher
  @discardableResult
  func async() async throws -&gt; Output {
    try await withCheckedThrowingContinuation { continuation in
      var cancellable: AnyCancellable?
      var finishedWithoutValue = true
      cancellable = first()
        .sink { result in
          switch result {
          case .finished:
            if finishedWithoutValue {
              continuation.resume(throwing: AsyncError.finishedWithoutValue)
            }
          case let .failure(error):
            continuation.resume(throwing: error)
          }
          cancellable?.cancel()
        } receiveValue: { value in
          finishedWithoutValue = false
          continuation.resume(with: .success(value))
        }
    }
  }
}
</code></pre>
<p>For some reason, when I use it on an optional <code>@Published</code> value, it returns an optional, rather than returning the unwrapped value of it. Since it waits until a non-nil value returns, why isn't it unwrapping it? For example, assuming <code>foo</code> is an optional published value:</p>
<pre><code>let one = await $foo.value() // Returns an optional
let two = await $foo.compactMap { $0 }.value() // Returns a non-optional
</code></pre>
<p>How do I fix this?</p>
","362840","","362840","","2022-09-21 16:15:56","2022-09-21 23:37:39","Publisher extension not returning unwrapped value","<ios><swift><combine>","1","0","","","","CC BY-SA 4.0"
"73813356","1","","","2022-09-22 10:52:06","","0","27","<p>I use Combine to track changes in the View Model and react to these changes in the View in the UIKit Application. The thing is that every time the change occurs sink is getting called one more time. I store subscriptions in the Set() and basically sink as called as many times as there are cancellables. If I remove and add items to the cart 5 times the sink would be called 10 times. Is this correct behavior or I'm doing something wrong?</p>
<p>My View Model Protocol:</p>
<pre><code>protocol CartTrackable {
    var addedToCart: Bool { get set }
    var addedToCartPublisher: Published&lt;Bool&gt;.Publisher { get }
}
</code></pre>
<p>My View Model:</p>
<pre><code>final class CartViewModel: ObservableObject, CartTrackable {
    @Published var addedToCart = false
    var addedToCartPublisher: Published&lt;Bool&gt;.Publisher { $addedToCart }

    func addToCart() {
        addedToCart = true
    }
    
    func removeFromCart() {
        addedToCart = false
    }
}
</code></pre>
<p>And here is the relevant code in my View:</p>
<pre><code> private var cancellables = Set&lt;AnyCancellable&gt;()

 func setObserver() {
        viewModel?.addedToCartPublisher
            .dropFirst()
            .receive(on: RunLoop.main)
            .sink { [weak self] cartStatus in
                self?.addToCartButton.showAnimation(for: cartStatus) 
            }
            .store(in: &amp;cancellables)
    }

</code></pre>
<p>Declaring cancellable as one object helps - .sink is always called only once, but I keep track of several things, and having separate cancellables for them is just a lot of repeated code. Would love to hear your opinions! Cheers!</p>
","12945073","","4667835","","2022-09-22 11:02:29","2022-09-22 11:02:29","Combine - .sink {..} is called as many times as there are cancellables","<swift><combine><publisher>","0","5","","","","CC BY-SA 4.0"
"73827632","1","","","2022-09-23 12:20:06","","-1","54","<p>How can I connect Binding value of View to Published value of ObservableObject?</p>
<p>The goal: all changes of objValue will be reflected on viewValue and vice versa.</p>
<p>Note: Do not propose onChange(obj.objValue) { viewValue = $0 } modifier. It will trigger extra drawing cycle of View (first for objValue and second for viewValue).</p>
<pre><code>class MyObject: ObservableObject {
    @Published var objValue: Int = 0
}

struct MyView: View {
    @Binding var viewValue: Int
    @StateObject var obj = MyObject()
    
    var body: some View {
        Text(&quot;Placeholder&quot;)
            .onChange(viewValue) {
                //Do something
            }
    }
}
</code></pre>
","7147231","","","","","2022-09-23 13:40:59","Mirror Binding value with Published in SwiftUI","<swift><swiftui><combine>","0","8","","","","CC BY-SA 4.0"
"73833433","1","73833516","","2022-09-23 22:11:21","","1","29","<p>Well guys like the title says i have on a response service call an JSON array and i cant find the way to decode with Combine:
<code>URLSession.shared.dataTaskPublisher</code></p>
<p>Service Response: <a href=""https://codebeautify.org/alleditor/y228809f7"" rel=""nofollow noreferrer"">https://codebeautify.org/alleditor/y228809f7</a></p>
<p>My Request Code:</p>
<pre><code>public func getGasStationDiscounts(requestModel: GasStationDiscountsRequestDomainModel) -&gt; CiMAObservable&lt;GasStationDiscountsDomainModel&gt; {
    guard let url = URL(string: RepositoryConstants.baseURL + String(format: RepositoryConstants.EndPoints.gasStationDiscounts, requestModel.gasStationID)) else {
        return Fail(error: NSError(domain: &quot;URL Invalid&quot;, code: 001, userInfo: nil)).eraseToAnyPublisher()
    }
    
    var urlRequest = URLRequest(url: url)
    urlRequest.httpMethod = &quot;GET&quot;
    urlRequest.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)
    urlRequest.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
    
    return URLSession.shared.dataTaskPublisher(for: urlRequest)
        .map(\.data)
        .decode(type: GasStationDiscountsDataModel.self, decoder: JSONDecoder())
        .map { model -&gt; GasStationDiscountsDomainModel in
            model.parseToDomainModel()
        }.eraseToAnyPublisher()
}
</code></pre>
<p>Decodable File: <a href=""https://codebeautify.org/alleditor/y2296aefe"" rel=""nofollow noreferrer"">https://codebeautify.org/alleditor/y2296aefe</a></p>
<p>So resuming, my problem is on trying to decode it because its an Array, on my project i'm working with diferent layers like Data, Domain and the Presentation (don't ask about architecture cuz is a new one, CiMA on GitHub) its a Hybrid Viper arch.</p>
<p>Thanks in advance!</p>
<p><strong>EDITED: SOLVED!</strong>
So finally i found a Solution which don't destroy my architecture.
So here the small changes on decodable Files: <a href=""https://codebeautify.org/alleditor/y22ad811e"" rel=""nofollow noreferrer"">https://codebeautify.org/alleditor/y22ad811e</a></p>
<p>and the last changes on the Request:</p>
<pre><code>    public func getGasStationDiscounts(requestModel: GasStationDiscountsRequestDomainModel) -&gt; CiMAObservable&lt;GasStationDiscountsDomainModel&gt; {
    guard let url = URL(string: RepositoryConstants.baseURL + String(format: RepositoryConstants.EndPoints.gasStationDiscounts, requestModel.gasStationID)) else {
        return Fail(error: NSError(domain: &quot;URL Invalid&quot;, code: 001, userInfo: nil)).eraseToAnyPublisher()
    }
    
    var urlRequest = URLRequest(url: url)
    urlRequest.httpMethod = &quot;GET&quot;
    urlRequest.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Accept&quot;)
    urlRequest.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
    
    return URLSession.shared.dataTaskPublisher(for: urlRequest)
        .map(\.data)
        .decode(type: [GasStationDiscountsDataModel].self, decoder: JSONDecoder())
        .map { model -&gt; GasStationDiscountsDomainModel in
            let stationDiscountsDomainModel = model.map { model -&gt; StationDiscountDomainModel in
                model.parseToDomainModel()
            }
            return GasStationDiscountsDomainModel(stationDiscounts: stationDiscountsDomainModel)
        }
        .mapError { error in
            print(error.localizedDescription)
            return error
        }.eraseToAnyPublisher()
}
</code></pre>
","17272112","","17272112","","2022-09-23 23:22:49","2022-09-24 05:07:38","Swift URLSession and Conbine json array decode fails","<json><swift><combine><urlsession><decodable>","2","0","","","","CC BY-SA 4.0"